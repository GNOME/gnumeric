%% lang.latex %%

%% Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005 Andrew Makhorin,
%% Department for Applied Informatics, Moscow Aviation Institute,
%% Moscow, Russia. All rights reserved. E-mail: <mao@mai2.rcnet.ru>.
%%
%% This file is part of GLPK (GNU Linear Programming Kit).
%%
%% GLPK is free software; you can redistribute it and/or modify it
%% under the terms of the GNU General Public License as published by
%% the Free Software Foundation; either version 2, or (at your option)
%% any later version.
%%
%% GLPK is distributed in the hope that it will be useful, but WITHOUT
%% ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
%% or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public
%% License for more details.
%%
%% You should have received a copy of the GNU General Public License
%% along with GLPK; see the file COPYING. If not, write to the Free
%% Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
%% 02111-1307, USA.

\documentclass[a4paper,11pt,twoside,draft]{article}

\setlength{\paperwidth}{210mm}
\setlength{\paperheight}{297mm}
\setlength{\hoffset}{-1in}
\addtolength{\hoffset}{5mm}
\setlength{\oddsidemargin}{25mm}
\setlength{\voffset}{-1in}
\addtolength{\voffset}{20mm}
\setlength{\topmargin}{0mm}
\setlength{\headheight}{3mm}
\setlength{\headsep}{7mm}
\setlength{\textwidth}{150mm}
\setlength{\textheight}{230mm}
\setlength{\parindent}{18pt}

\pagestyle{myheadings}
\sloppy

\begin{document}

\begin{titlepage}
\begin{center}

\vspace*{2.5in}

\begin{huge}
{\bf GNU Linear Programming Kit}
\end{huge}

\vspace{0.5in}

\begin{LARGE}
{\bf Modeling Language GNU MathProg}
\end{LARGE}

\vspace{0.5in}

\begin{LARGE}
{\bf Version 4.8}
\end{LARGE}

\vspace{0.5in}
\begin{Large}
(Draft Edition, January 2005)
\end{Large}
\end{center}

\newpage
\vspace*{1in}
\vfill

\noindent
The GLPK package is part of the GNU Project released under the aegis of
GNU.

\medskip \noindent
Copyright \copyright{} 2000, 2001, 2002, 2003, 2004, 2005 Andrew
Makhorin, Department for Applied Informatics, Moscow Aviation Institute,
Moscow, Russia. All rights reserved.

\medskip \noindent
Free Software Foundation, Inc., 59 Temple Place --- Suite 330, Boston,
MA 02111, USA.

\medskip \noindent
Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

\medskip \noindent
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
entire resulting derived work is distributed under the terms of
a permission notice identical to this one.

\medskip \noindent
Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions.
\end{titlepage}

\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage

\section{Introduction}

GNU MathProg is a modeling language intended for describing linear
mathematical programming models.\footnote{The GNU MathProg language is
a subset of the AMPL language.}

Model descriptions written in the GNU MathProg language consist of a set
of statements and data blocks constructed by the user from the language
elements described in this document.

In a process called translation, a program called the model translator
analyzes the model description and translates it into internal data
structures, which may be then used either for generating mathematical
programming problem instance or directly by a program called the solver
to obtain numeric solution of the problem.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Linear programming problem}

In MathProg the following formulation of linear programming (LP)
problem is assumed:

\medskip

\noindent
\hspace{1in} minimize (maximize)
$$Z = c_1 x_{m+1} + c_2 x_{m+2} + \dots + c_n x_{m+n} + c_0\eqno (1)$$
\hspace{1in} subject to linear constraints
$$
\begin{array}{c}
\nonumber
x_1 = \ a_{11}x_{m+1} + \ a_{12}x_{m+2} + \dots + a_{1n}x_{m+n} \\
\nonumber
x_2 = \ a_{21}x_{m+1} + \ a_{22}x_{m+2} + \dots + a_{2n}x_{m+n} \\
\nonumber
\dots \dots \dots \dots \dots \dots \\
\nonumber x_m = a_{m1}x_{m+1} + a_{m2}x_{m+2} + \dots + a_{mn}x_{m+n} \\
\end{array} \eqno (2)
$$
\hspace{1in} and bounds of variables
$$
\begin{array}{c}
\nonumber l_1 \leq x_1 \leq u_1 \\
\nonumber l_2 \leq x_2 \leq u_2 \\
\nonumber \dots \dots \dots \\
\nonumber l_{m+n} \leq x_{m+n} \leq u_{m+n} \\
\end{array} \eqno (3)
$$
where: $x_1, x_2, \dots, x_m$ are auxiliary variables;
$x_{m+1}, x_{m+2}, \dots, x_{m+n}$ are structural variables;
$Z$ is the objective function;
$c_1, c_2, \dots, c_n$ are coefficients of the objective function;
$c_0$ is the constant term of the objective function;
$a_{11}$, $a_{12}$, \dots, $a_{mn}$ are constraint coefficients;
$l_1, l_2, \dots, l_{m+n}$ are lower bounds of variables;
$u_1, u_2, \dots, u_{m+n}$ are upper bounds of variables.

Bounds of variables can be finite as well as infinite. Besides, lower
and upper bounds can be equal to each other. Thus, the following types
of variables are possible:
\begin{center}
\begin{tabular}{r@{}c@{}ll}
\multicolumn{3}{c}{Bounds of variable} & Type of variable \\
\hline
$-\infty <$ &$\ x_k\ $& $< +\infty$ & Free (unbounded) variable \\
$l_k \leq$ &$\ x_k\ $& $< +\infty$  & Variable with lower bound \\
$-\infty <$ &$\ x_k\ $& $\leq u_k$  & Variable with upper bound \\
$l_k \leq$ &$\ x_k\ $& $\leq u_k$   & Double-bounded variable \\
$l_k =$ &$\ x_k\ $& $= u_k$         & Fixed variable \\
\end{tabular}
\end{center}
\noindent
Note that the types of variables shown above are applicable to
structural as well as to auxiliary variables.

In addition to pure LP problems MathProg allows mixed integer linear
programming (MIP) problems, where some (or all) structural variables are
restricted to be integer.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Model objects}

In MathProg the model is described in terms of sets, parameters,
variables, constraints, and objectives, which are called {\it model
objects}.

The user introduces particular model objects using the language
statements. Each model object is provided with a symbolic name that
uniquely identifies the object and is intended for referencing purposes.

Model objects, including sets, can be multidimensional arrays built over
indexing sets. Formally, $n$-dimensional array $A$ is the mapping
$$A:\Delta \rightarrow \Xi, \eqno (4)$$
where $\Delta \subseteq S_1 \times S_2 \times \dots \times S_n$ is a
subset of the Cartesian product of indexing sets, $\Xi$ is a set of the
array members. In MathProg the set $\Delta$ is called {\it subscript
domain}. Its members are $n$-tuples $(i_1, i_2, \dots, i_n)$, where
$i_1 \in S_1$, $i_2 \in S_2$, \dots, $i_n \in S_n$.

If $n = 0$, the Cartesian product in (4) has exactly one element
(namely, 0-tuple), so it is convenient to think scalar objects as
0-dimensional arrays that have one member.

The type of array members is determined by the type of the
corresponding model object as follows:

\begin{center}
\begin{tabular}{ll}
Model object & Array member \\
\hline
Set & Elemental plain set \\
Parameter & Number or symbol \\
Variable & Elemental structural variable \\
Constraint & Elemental constraint \\
Objective & Elemental objective \\
\end{tabular}
\end{center}

In order to refer to a particular object member the object should be
provided with subscripts. For example, if $a$ is 2-dimensional
parameter built over $I \times J$, a reference to its particular
member can be written as $a[i,j]$, where $i \in I$ and $j \in J$.
It is understood that scalar objects being 0-dimensional need
no subscripts.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Structure of model description}

It is sometimes desirable to write a model which, at various points,
may require different data for each problem to be solved using that
model. For this reason in MathProg the model description consists of
two parts: model section and data section.

{\it Model section} is a main part of the model description that
contains declarations of model objects and is common for all problems
based on the corresponding model.

{\it Data section} is an optional part of the model description that
contains data specific for a particular problem.

Depending on what is more convenient model and data sections can be
placed either in one file or in two separate files. The latter feature
allows to have arbitrary number of different data sections to be used
with the same model section.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage

\section{Coding model description}

Model description is coded in plain text format using ASCII character
set. Valid characters acceptable in the model description are the
following:

$\bullet$ alphabetic characters: \verb|A| \verb|B| {\dots} \verb|Z|
\verb|a| \verb|b| {\dots} \verb|z| \verb|_|

$\bullet$ numeric characters: \verb|0| \verb|1| {\dots} \verb|9|

$\bullet$ special characters:
\verb$! " # & ' ( ) * + , - . / : ; < = > [ ] ^ { | }$

$\bullet$ white-space characters: \verb|SP HT CR NL VT FF|

Within string literals and comments any ASCII characters (except control
characters) are valid.

White-space characters are non-significant. They can be used freely
between lexical units to improve readability of the model description.
They are also used to separate lexical units from each other if there
is no other way to do that.

Syntactically model description is a sequence of lexical units in the
following categories:

$\bullet$ symbolic names;

$\bullet$ numeric literals;

$\bullet$ string literals;

$\bullet$ keywords;

$\bullet$ delimiters;

$\bullet$ comments.

The lexical units of the language are discussed below.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Symbolic names}

{\it Symbolic name} consists of alphabetic and numeric characters, the
first of which must be alphabetic. All symbolic names are distinct (case
sensitive).

\medskip

Examples:

\medskip

\verb|alpha123|

\verb|This_is_a_name|

\verb|_P123_abc_321|

\medskip

Symbolic names are used to identify model objects (sets, parameters,
variables, constraints, objectives) and dummy indices.

All symbolic names (except names of dummy indices) must be unique,
i.e. the model description must have no objects with the same name.
Symbolic names of dummy indices must be unique within the scope, where
they are valid.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Numeric literals}

{\it Numeric literal} has the form {\it xx}\verb|E|{\it syy}, where
{\it xx} is a real number with optional decimal point, {\it s} is the
sign \verb|+| or \verb|-|, {\it yy} is an integer decimal exponent. The
letter \verb|E| is case insensitive and can be coded as \verb|e|.

\medskip

Examples:

\medskip

\verb|123|

\verb|3.14159|

\verb|56.E+5|

\verb|.78|

\verb|123.456e-7|

\medskip

Numeric literals are used to represent numeric quantities. They have
obvious fixed meaning.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{String literals}

{\it String literal} is a sequence of arbitrary characters enclosed
either in single quotes or in double quotes. Both these forms are
equivalent.

If the single quote is a part of a string literal enclosed in single
quotes, it must be coded twice. Analogously, if the double quote is
a part of string literal enclosed in double quotes, it must be coded
twice.

\medskip

Examples:

\medskip

\verb|'This is a string'|

\verb|"This is another string"|

\verb|'1 + 2 = 3'|

\verb|'That''s all'|

\verb|"She said: ""No"""|

\medskip

String literals are used to represent symbolic quantities.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Keywords}

{\it Keyword} is a sequence of alphabetic characters and possibly some
special characters. All keywords fall into two categories: reserved
keywords, which cannot be used as symbolic names, and non-reserved
keywords, which being recognized by context can be used as symbolic
names.

Reserved keywords are:

\begin{center}
\begin{tabular}{*{6}{p{15mm}}}
\verb|and| & \verb|diff| & \verb|if| & \verb|less| & \verb|or| &
\verb|union| \\
\verb|by| & \verb|div| & \verb|in| & \verb|mod| & \verb|symdiff| &
\verb|within| \\
\verb|cross| & \verb|else| & \verb|inter| & \verb|not| &
\verb|then| & \\
\end{tabular}
\end{center}

Non-reserved keywords are described in following sections.

All the keywords have fixed meaning, which will be explained on
discussion of corresponding syntactic constructions, where the keywords
are used.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Delimiters}

{\it Delimiter} is either a single special character or a sequence of
two special characters as follows:

\begin{center}
\begin{tabular}{*{6}{p{15mm}}}
\verb|+|  & \verb|^|  & \verb|==| & \verb|!|  & \verb|:|  & \verb|)| \\
\verb|-|  & \verb|&|  & \verb|>=| & \verb|&&| & \verb|;|  & \verb|[| \\
\verb|*|  & \verb|<|  & \verb|>|  & \verb$||$ & \verb|:=| & \verb|]| \\
\verb|/|  & \verb|<=| & \verb|<>| & \verb|.|  & \verb|..| & \verb|{| \\
\verb|**| & \verb|=|  & \verb|!=| & \verb|,|  & \verb|(|  & \verb|}| \\
\end{tabular}
\end{center}

If delimiter consists of two characters, there must be no spaces between
the characters.

All the delimiters have fixed meaning, which will be explained on
discussion corresponding syntactic constructions, where the delimiters
are used.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Comments}

For documenting purposes the model description can be provided with
{\it comments}, which have two different forms. The first form is
a single-line comment, which begins with the character \verb|#| and
extends until end of line. The second form is a comment sequence,
which is a sequence of any characters enclosed between \verb|/*| and
\verb|*/|.

\medskip

Examples:

\medskip

\verb|set s{1..10}; # This is a comment|

\verb|/* This is another comment */|

\medskip

Comments are ignored by the model translator and can appear anywhere in
the model description, where white-space characters are allowed.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage

\section{Expressions}

{\it Expression} is a rule for computing a value. In model description
expressions are used as constituents of certain statements.

In general case expressions consist of operands and operators.

Depending on the type of the resultant value all expressions fall into
the following categories:

$\bullet$ numeric expressions;

$\bullet$ symbolic expressions;

$\bullet$ indexing expressions;

$\bullet$ set expressions;

$\bullet$ logical expressions;

$\bullet$ linear expressions.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Numeric expressions}

{\it Numeric expression} is a rule for computing a single numeric value
represented in the form of floating-point number.

The primary numeric expression may be a numeric literal, dummy index,
unsubscripted parameter, subscripted parameter, built-in function
reference, iterated numeric expression, conditional numeric expression,
or another numeric expression enclosed in parentheses.

\medskip

Examples:

\medskip

\begin{tabular}{@{}ll}
\verb|1.23| & numeric literal \\
\verb|j| & dummy index \\
\verb|time| & unsubscripted parameter \\
\verb|a['May 2003',j+1]| & subscripted parameter\\
\verb|abs(b[i,j])| & function reference \\
\verb|sum{i in S diff T} alpha[i] * b[i,j]| & iterated expression \\
\verb|if i in I and p >= 1 then 2 * p else q[i+1]|
& conditional expression \\
\verb|(b[i,j] + .5 * c)| & parenthesized expression \\
\end{tabular}

\medskip

More general numeric expressions containing two or more primary numeric
expressions may be constructed by using certain arithmetic operators.

\medskip

Examples:

\medskip

\verb|j+1|

\verb|2 * a[i-1,j+1] - b[i,j]|

\verb|sum{j in J} a[i,j] * x[j] + sum{k in K} b[i,k] * x[k]|

\verb|(if i in I and p >= 1 then 2 * p else q[i+1]) / (a[i,j] + 1.5)|

\paragraph{Numeric literals.}
If the primary numeric expression is a numeric literal, the resultant
value is obvious.

\paragraph{Dummy indices.}
If the primary numeric expression is a dummy index, the resultant value
is current value assigned to the dummy index.

\paragraph{Unsubscripted parameters.}
If the primary numeric expression is an unsubscripted parameter (which
must be 0-dimensional), the resultant value is the value of the
parameter.

\paragraph{Subscripted parameters.}
The primary numeric expression, which refers to a subscripted parameter,
has the following syntactic form:
$$name\verb|[|i_1\verb|,| i_2\verb|,| \dots\verb|,| i_n\verb|]|$$
where {\it name} is the symbolic name of the parameter,
$i_1$, $i_2$, \dots, $i_n$ are subscripts.

Each subscript must be a numeric or symbolic expression. The number of
subscripts in the subscript list must be the same as the dimension of
the parameter with which the subscript list is associated.

Actual values of subscript expressions are used to identify a particular
member of the parameter that determines the resultant value of the
primary expression.

\paragraph{Function references.} In MathProg there are the following
built-in functions which may be used in numeric expressions:

\begin{center}
\begin{tabular}{@{}ll}
\verb|abs|$(x)$ & absolute value \\
\verb|ceil|$(x)$ & smallest integer not less than $x$
(``ceiling of $x$'') \\
\verb|floor|$(x)$ & largest integer not greater than $x$
(``floor of $x$'') \\
\verb|exp|$(x)$ & base-$e$ exponential $e^x$ \\
\verb|log|$(x)$ & natural logarithm $\log x$ \\
\verb|log10|$(x)$ & common (decimal) logarithm $\log_{10} x$ \\
\verb|max|$(x_1, x_2, \dots, x_n)$ & the largest of values
$x_1, x_2, \dots, x_n$\\
\verb|min|$(x_1, x_2, \dots, x_n)$ & the smallest of values
$x_1, x_2, \dots, x_n$\\
\verb|round|$(x)$ & rounding $x$ to nearest integer \\
\verb|round|$(x,n)$ & rounding $x$ to $n$ fractional decimal digits \\
\verb|sqrt|$(x)$ & square root $\sqrt{x}$ \\
\verb|trunc|$(x)$ & truncating $x$ to nearest integer \\
\verb|trunc|$(x,n)$ & truncating $x$ to $n$ fractional decimal digits \\
\verb|Irand224|$()$ & pseudo-random integer uniformly distributed in
$[0,2^{24})$ \\
\verb|Uniform01|$()$ & pseudo-random number uniformly distributed in
$[0,1)$ \\
\verb|Uniform|$(a,b)$ & pseudo-random number uniformly distributed in
$[a,b)$ \\
\verb|Normal01|$()$ & Gaussian pseudo-random variate with $\mu=0$ and
$\sigma=1$ \\
\verb|Normal|$(\mu,\sigma)$ & Gaussian pseudo-random variate with given
$\mu$ and $\sigma$ \\
\end{tabular}
\end{center}

Arguments of all built-in functions (if required) must be numeric
expressions.

The resultant value of the numeric expression, which is a function
reference, is the result of applying the function to its argument(s).

Note that each pseudo-random generator function have a latent argument
(i.e. some internal state), which is changed whenever the function has
been applied. Thus, if the function is applied repeatedly even to
identical arguments, due to the side effect different resultant values
are always produced.

\paragraph{Iterated expressions.} Iterated numeric expression is a
primary numeric expression, which has the following syntactic form:

\begin{center}
{\it iterated-operator} {\it indexing-expression} {\it integrand}
\end{center}

\noindent
where {\it iterated-operator} is the symbolic name of the iterated
operator to be performed (see below), {\it indexing expression} is an
indexing expression which introduces dummy indices and controls
iterating, {\it integrand} is a numeric expression that participates in
the operation.

In MathProg there are four iterated operators, which may be used in
numeric expressions:

\begin{center}
\begin{tabular}{@{}lll}
\verb|sum| & summation &
$\sum_{(i_1, \dots, i_n) \in \Delta} x(i_1, \dots, i_n)$ \\
\verb|prod| & production &
$\prod_{(i_1, \dots, i_n) \in \Delta} x(i_1, \dots, i_n)$ \\
\verb|min| & minimum &
$\min_{(i_1, \dots, i_n) \in \Delta} x(i_1, \dots, i_n)$ \\
\verb|max| & maximum &
$\max_{(i_1, \dots, i_n) \in \Delta} x(i_1, \dots, i_n)$ \\
\end{tabular}
\end{center}

\noindent
where $i_1, \dots, i_n$ are dummy indices introduced in the indexing
expression, $\Delta$ is the domain, a set of $n$-tuples specified by the
indexing expression which defines particular values assigned to the
dummy indices on performing the iterated operation, $x(i_1, \dots, i_n)$
is the integrand, a numeric expression whose resultant value depends on
the dummy indices.

The resultant value of an iterated numeric expression is the result of
applying of the iterated operator to its integrand over all $n$-tuples
contained in the domain.

\paragraph{Conditional expressions.} Conditional numeric expression is
a primary numeric expression, which has the following two syntactic
forms:

\begin{center}
\begin{tabular}{l}
\verb|if| $b$ \verb|then| $x$ \verb|else| $y$ \\
\verb|if| $b$ \verb|then| $x$ \\
\end{tabular}
\end{center}

\noindent
where $b$ is an logical expression, $x$ and $y$ are numeric expressions.

The resultant value of the conditional expression depends on the value
of the logical expression that follows the keyword \verb|if|. If it is
true, the value of the conditional expression is the value of the
expression that follows the keyword \verb|then|. Otherwise, if the
logical expression has the value false, the value of the conditional
expression is the value of the expression that follows the keyword
\verb|else|. If the reduced form of the conditional expression is used
and the logical expression has the value false, the resultant value of
the conditional expression is zero.

\paragraph{Parenthesized expressions.} Any numeric expression may be
enclosed in parentheses that syntactically makes it primary numeric
expression.

Parentheses may be used in numeric expressions, as in algebra, to
specify the desired order in which operations are to be performed. Where
parentheses are used, the expression within the parentheses is evaluated
before the resultant value is used.

The resultant value of the parenthesized expression is the same as the
value of the expression enclosed within parentheses.

\paragraph{Arithmetic operators.} In MathProg there are the following
arithmetic operators, which may be used in numeric expressions:

\begin{center}
\begin{tabular}{ll}
\verb|+| $x$ & unary plus \\
\verb|-| $x$ & unary minus \\
$x$ \verb|+| $y$ & addition \\
$x$ \verb|-| $y$ & subtraction \\
$x$ \verb|less| $y$ & positive difference
(if $x < y$ then 0 else $x - y$) \\
$x$ \verb|*| $y$ & multiplication \\
$x$ \verb|/| $y$ & division \\
$x$ \verb|div| $y$ & quotient of exact division \\
$x$ \verb|mod| $y$ & remainder of exact division \\
$x$ \verb|**| $y$, $x$ \verb|^| $y$ & exponentiation
(raise to power) \\
\end{tabular}
\end{center}

\noindent
where $x$ and $y$ are numeric expressions.

If the expression includes more than one arithmetic operator, all
operators are performed from left to right according to the hierarchy
of operations (see below) with the only exception that the exponentiaion
operators are performed from right to left.

The resultant value of the expression, which contains arithmetic
operators, is the result of applying the operators to their operands.

\paragraph{Hierarchy of operations.} The following list shows the
hierarchy of operations in numeric expressions:

\begin{center}
\begin{tabular}{lc}
\hfil Operation & Hierarchy \\
\hline
Evaluation of functions (\verb|abs|, \verb|ceil|, etc.) & 1st \\
Exponentiation (\verb|**|, \verb|^|) & 2nd \\
Unary plus and minus (\verb|+|, \verb|-|) & 3rd \\
Multiplication and division (\verb|*|, \verb|/|, \verb|div|, \verb|mod|)
& 4th \\
Iterated operations (\verb|sum|, \verb|prod|, \verb|min|, \verb|max|)
& 5th \\
Addition and subtraction (\verb|+|, \verb|-|, \verb|diff|) & 6th \\
Conditional evaluation (\verb|if| \dots \verb|then| \dots \verb|else|)
& 7th \\
\end{tabular}
\end{center}

This hierarchy is used to determine which of two consecutive operations
is performed first. If the first operator is higher than or equal to the
second, the first operation is performed. If it is not, the second
operator is compared to the third, etc. When the end of the expression
is reached, all of the remaining operations are performed in the reverse
order.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Symbolic expressions}

{\it Symbolic expression} is a rule for computing a single symbolic
value represented in the form of character string.

The primary symbolic expression may be a string literal, dummy index,
unsubscripted parameter, subscripted parameter, conditional symbolic
expression, or another symbolic expression enclosed in parentheses.

It is also allowed to use a numeric expression as the primary symbolic
expression, in which case the resultant value of the numeric expression
is automatically converted to the symbolic type.

\medskip

Examples:

\medskip

\begin{tabular}{@{}ll}
\verb|'May 2003'| & string literal \\
\verb|j| & dummy index \\
\verb|p| & unsubscripted parameter \\
\verb|s['abc',j+1]| & subscripted parameter\\
\verb|if i in I then s[i,j] & "..." else t[i+1]|
& conditional expression \\
\verb|((10 * b[i,j]) & '.bis')| & parenthesized expression \\
\end{tabular}

\medskip

More general symbolic expressions containing two or more primary
symbolic expressions may be constructed by using the concatenation
operator.

\medskip

Examples:

\medskip

\verb|'abc[' & i & ',' & j & ']'|

\verb|"from " & city[i] " to " & city[j]|

\medskip

The principles of evaluation of symbolic expressions are entirely
analogous to that that given for numeric expressions (see above).

\paragraph{Symbolic operators.} Currently in MathProg there is the
only symbolic operator:

\begin{center}
\begin{tabular}{c}
$x$ \verb|&| $y$ \\
\end{tabular}
\end{center}

\noindent
where $x$ and $y$ are symbolic expressions. This operator means
concatenation of its two symbolic operands, which are character strings.

\paragraph{Hierarchy of operations} The following list shows the
hierarchy of operations in symbolic expressions:

\begin{center}
\begin{tabular}{lc}
\hfil Operation & Hierarchy \\
\hline
Evaluation of numeric operations & 1st-7th \\
Concatenation (\verb|&|) & 8th \\
Conditional evaluation (\verb|if| \dots \verb|then| \dots \verb|else|) &
9th \\
\end{tabular}
\end{center}

\noindent
This hierarchy has the same meaning as explained in Subsection
``Numeric expressions''.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Indexing expressions and dummy indices}

{\it Indexing expression} is an auxiliary construction, which specifies
a plain set of $n$-tuples and introduces dummy indices. It has two
syntactic forms:
$$
\begin{array}{l}
\verb|{| entry_1,\ entry_2,\ \dots,\ entry_m \verb|}| \\
\verb|{| entry_1,\ entry_2,\ \dots,\ entry_m\ \verb|:|\ predicate
\verb|}| \\
\end{array} \eqno (5)
$$
where {\it entry}$_1$, {\it entry}$_2$, \dots, {\it entry}$_m$ are
indexing entries, {\it predicate} is a logical expression which
specifies optional predicate.

Each indexing entry in the indexing expression have the following three
forms:
$$
\begin{array}{l}
t\ \verb|in|\ S \\
(t_1, t_2, \dots, t_k)\ \verb|in|\ S \\
S \\
\end{array} \eqno (6)
$$
where $t, t_1, t_2, \dots, t_k$ are indices, $S$ is a set expression
which specifies the basic set.

The number of indices in the indexing entry must be the same as the
dimension of the basic set $S$, i.e. if $S$ consists of 1-tuples, the
first form must be used, and if $S$ consists of $n$-tuples, where
$n > 1$, the second form must be used.

If the first form of the indexing entry is used, the index $t$ can be
a dummy index only. If the second form is used, the indices
$t_1, t_2, \dots, t_k$ can be either dummy indices or some numeric or
symbolic expressions, where at least one index must be a dummy index.
The third, reduced form of the indexing entry has the same effect as if
there were $t$ (if $S$ is 1-dimensional) or $t_1, t_2, \dots, t_k$ (if
$S$ is $n$-dimensional) all specified as dummy indices.

{\it Dummy index} is an auxiliary model object, which acts like an
individual variable. Values assigned to dummy indices are components
of $n$-tuples from basic sets, i.e. some numeric and symbolic
quantities.

For referencing purposes dummy indices can be provided with symbolic
names. However, unlike other model objects (sets, parameters, etc.)
dummy indices don't need to be explicitly declared. Each
{\it undeclared} symbolic name being used in indexing position of some
indexing entry is recognized as symbolic name of corresponding dummy
index.

Symbolic names of dummy indices are valid only within the scope of the
indexing expression, where the dummy indices were introduced. Beyond
the scope the dummy indices are completely inaccessible, so the same
symbolic names may be used for other purposes, in particular, to
represent dummy indices in other indexing expressions.

The scope of indexing expression, where implicit declarations of dummy
indices are valid, depends on the context, in which the indexing
expression is used:

1.~If the indexing expression is used in iterated operator, its scope
extends until the end of the integrand.

2.~If the indexing expression is used as a primary set expression, its
scope extends until the end of this indexing expression.

3.~If the indexing expression is used to define the subscript domain in
declarations of some model objects, its scope extends until the end of
the corresponding statement.

The indexing mechanism implemented by means of indexing expressions
is best explained by some examples discussed below.

Let there be three sets:
$$
\begin{array}{r@{\ }c@{\ }l}
A &=& \{4,7,9\} \\
B &=& \{(1,Jan),(1,Feb),(2,Mar),(2,Apr),(3,May),(3,Jun)\} \\
C &=& \{a,b,c\} \\
\end{array} \eqno (7)
$$
where $A$ and $B$ consist of 1-tuples (singles), $C$ consists of
2-tuples (doubles). And consider the following indexing expression:
$$\verb|{i in A, (j,k) in B, l in C}| \eqno(8)$$
where $i$, $j$, $k$, and $l$ are dummy indices.

Although MathProg is not a procedural language, for any indexing
expression an equivalent algorithmic description can be given.
In particular, the algorithmic description of the indexing expression
(8) is the following:

\begin{center}
\begin{tabular}{l}
{\bf for all} $i \in A$ {\bf do} \\
\ \ \ \ {\bf for all} $(j,k) \in B$ {\bf do} \\
\ \ \ \ \ \ \ \ {\bf for all} $l \in C$ {\bf do} \\
\ \ \ \ \ \ \ \ \ \ \ \ {\it action}; \\
\end{tabular}
\end{center}

\noindent
where the dummy indices $i$, $j$, $k$, $l$ are consecutively assigned
corresponding components of $n$-tuples from the basic sets $A$, $B$,
$C$, and {\it action} is some action that depends on the context, where
the indexing expression is used. For example, if the action were
printing current values of dummy indices, the output would look like
follows:
$$
\begin{array}{cccc}
i = 4 & j = 1 & k = Jan & l = a \\
i = 4 & j = 1 & k = Jan & l = b \\
i = 4 & j = 1 & k = Jan & l = c \\
i = 4 & j = 1 & k = Feb & l = a \\
i = 4 & j = 1 & k = Feb & l = b \\
\dots & \dots & \dots   & \dots \\
i = 9 & j = 3 & k = Jun & l = b \\
i = 9 & j = 3 & k = Jun & l = c \\
\end{array}
$$

Let the indexing expression (8) be used in the following iterated
operation:
$$\verb|sum{i in A, (j,k) in B, l in C} p[i,j,k,l] ** 2| \eqno (9)$$
where $p[i,j,k,l]$ may be a 4-dimensional numeric parameter or
some numeric expression whose resultant value depends on $i$, $j$, $k$,
and $l$. In this case the action is summation, so the resultant value
of the primary numeric expression (9) is:
$$\sum_{i\in A,(j,k)\in B,l\in C}(p_{ijkl})^2.$$

Now let the indexing expression (8) be used as a primary set expression.
In this case the action is gathering all 4-tuples (quadruples) of the
form $(i,j,k,l)$ in one set, so the resultant value of such operation
is simply the Cartesian product of the basic sets:
$$A\times B\times C = \{(i,j,k,l) | i \in A, (j,k) \in B, l \in C\}.$$
Note that in this case the same indexing expression might be written
in the reduced form:
$$\verb|{A, B, C}|$$
because the dummy indices $i,j,k,l$ are not referenced and therefore
their symbolic names are not needed.

Finally, let the indexing expression (8) be used as the subscript
domain in declaration of some 4-dimensional model object, for instance,
some numeric parameter:
$$
\verb|par p{i in A, (j,k) in B, l in C} ... ;|
$$
In this case the action is generating the parameter members, where each
member has the form $p[i,j,k,l]$.

As was said above, some indices in (6) may be numeric or symbolic
expressions, not dummy indices. In this case resultant values of such
expressions play role of some logical conditions to select only that
$n$-tuples from the Cartesian product of basic sets, which satisfy these
conditions.

Consider, for example, the following indexing expression:
$$\verb|{i in A, (i-1,k) in B, l in C}| \eqno(10) $$
where $i,k,l$ are dummy indices, and $i-1$ is a numeric expression. The
algorithmic decsription of the indexing expression (10) is the
following:

\begin{center}
\begin{tabular}{l}
{\bf for all} $i \in A$ {\bf do} \\
\ \ \ \ {\bf for all} $(j,k) \in B$ {\bf and} $j = i-1$ {\bf do} \\
\ \ \ \ \ \ \ \ {\bf for all} $l \in C$ {\bf do} \\
\ \ \ \ \ \ \ \ \ \ \ \ {\it action}; \\
\end{tabular}
\end{center}

\noindent
Thus, if the indexing expression (10) is used as a primary set
expression, the resultant set is the following:
$$
\{(4, May, a), (4, May, b), (4, May, c), (4, Jun, a), (4, Jun, b),
(4, Jun, c)\} \\
$$
Should note that in this case the resultant set consists of 3-tuples,
not of 4-tuples, because in the indexing expression (10) there is
no dummy index that corresponds to the first component of 2-tuples from
the set $B$.

The general rule is: the number of components of $n$-tuples defined by
an indexing expression is the same as the number of dummy indices in
that indexing expression, where the correspondence between dummy indices
and components on $n$-tuples in the resultant set is positional,
i.e. the first dummy index corresponds to the first component, the
second dummy index corresponds to the second component, etc.

In many cases it is needed to select a subset from some set of from the
Cartesian product of some sets. This may be attained by using an
optional logical predicate, which is specified in indexing expression
after the last or the only indexing entry.

Consider, for example, the following indexing expression:
$$\verb|{i in A, (j,k) in B, l in C: i <= 5 and k <> 'Mar'}| \eqno(11)$$
where the logical expression following the colon is a predicate.
The algorithmic description of this indexing expression is the
following:

\begin{center}
\begin{tabular}{l}
{\bf for all} $i \in A$ {\bf do} \\
\ \ \ \ {\bf for all} $(j,k) \in B$ {\bf do} \\
\ \ \ \ \ \ \ \ {\bf for all} $l \in C$ {\bf do} \\
\ \ \ \ \ \ \ \ \ \ \ \ {\bf if} $i\leq 5$ {\bf and} $k \neq$ `Mar'
{\bf then} \\
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ {\it action}; \\
\end{tabular}
\end{center}

\noindent
Thus, if the indexing expression (11) is used as a primary set
expression, the resultant set is the following:
$$\{(4,1,Jan,a),(4,1,Feb,a),(4,2,Apr,a),\dots,(4,3,Jun,c)\}.$$

If no predicate is specified in indexing expression, one is assumed
whose value is true.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Set expressions}

{\it Set expression} is a rule for computing an elemental set, i.e.
a collection of $n$-tuples, where components of $n$-tuples are numeric
and symbolic quantities.

The primary set expression may be a literal set, unsubscripted set,
subscripted set, ``arithmetic'' set, indexing expression, iterated set
expression, conditional set expression, or another set expression
enclosed in parentheses.

\medskip

Examples:

\medskip

\begin{tabular}{@{}ll}
\verb|{(123,'aaa'), (i+1,'bbb'), (j-1,'ccc')}| & literal set \\
\verb|I| & unsubscripted set \\
\verb|S[i-1,j+1]| & subscripted set \\
\verb|1..t-1 by 2| & ``arithmetic'' set \\
\verb|{t in 1..T, (t+1,j) in S: (t,j) in F}| & indexing expression \\
\verb|setof{i in I, j in J}(i+1,j-1)| & iterated set expression \\
\verb|if i < j then S[i,j] else F diff S[i,j]| & conditional set
expression \\
\verb|(1..10 union 21..30)| & parenthesized set expression \\
\end{tabular}

\medskip

More general set expressions containing two or more primary set
expressions may be constructed by using certain set operators.

\medskip

Examples:

\medskip

\verb|(A union B) inter (I cross J)|

\verb|1..10 cross (if i < j then {'a', 'b', 'c'} else {'d', 'e', 'f'})|

\medskip

\paragraph{Literal sets.} Literal set is a primary set expression, which
has the following two syntactic forms:
$$
\begin{array}{l}
\verb|{|e_1\verb|,| e_2\verb|,| \dots\verb|,| e_m\verb|}| \\
\verb|{(|e_{11}\verb|,| \dots\verb|,| e_{1n}\verb|),|
\verb|(|e_{21}\verb|,| \dots\verb|,| e_{2n}\verb|),|
\dots\verb|,| \verb|(|e_{m1}\verb|,| \dots\verb|,| e_{mn}\verb|)}| \\
\end{array}
$$
where $e_1$, \dots, $e_m$, $e_{11}$, \dots, $e_{mn}$ are numeric or
symbolic expressions.

If the first form is used, the resultant set consists of 1-tuples
(singles) enumerated within the curly braces. It is allowed to specify
an empty set, which has no 1-tuples.

If the second form is used, the resultant set consists of $n$-tuples
enumerated within the curly braces, where a particular $n$-tuple
consists of corresponding components enumerated within the parentheses.
All $n$-tuples must have the same number of components.

\paragraph{Unsubscripted set.} If the primary set expression is an
unsubscripted set (which must be 0-dimensional), the resultant set is
an elemental set associated with the corresponding set object.

\paragraph{Subscripted set.}
The primary set expression, which refers to a subscripted set, has the
following syntactic form:
$$name\verb|[|i_1\verb|,| i_2\verb|,| \dots\verb|,| i_n\verb|]|$$
where {\it name} is the symbolic name of the set object,
$i_1$, $i_2$, \dots, $i_n$ are subscripts.

Each subscript must be a numeric or symbolic expression. The number of
subscripts in the subscript list must be the same as the dimension of
the set object with which the subscript list is associated.

Actual values of subscript expressions are used to identify a particular
member of the set object that determines the resultant set.

\paragraph{``Arithmetic'' set.} The primary set expression, which is an
``arithmetic'' set, has the following two syntactic forms:
$$
\begin{array}{l}
t_0\ \verb|..|\ t_f\ \verb|by|\ \delta t \\
t_0\ \verb|..|\ t_f \\
\end{array}
$$
where $t_0$, $t_1$, and $\delta t$ are numeric expressions (the value
of $\delta t$ must not be zero). The second form is equivalent to the
first form, where $\delta t = 1$.

If $\delta t > 0$, the resultant set is determined as follows:
$$\{t:\exists k\in{\cal Z}
(t = t_0 + k \delta t,\ t_0 \leq t \leq t_f)\}$$

If $\delta t < 0$, the resultant set is determined as follows:
$$\{t:\exists k\in{\cal Z}
(t = t_0 + k \delta t,\ t_f \leq t \leq t_0)\}$$

\paragraph{Indexing expressions.} If the primary set expression is an
indexing expression, the resultant set is determined as described in
Subsection ``Indexing expressions and dummy indices'' (see above).

\paragraph{Iterated expressions.} Iterated set expression is a primary
set expression, which has the following syntactic form:

\begin{center}
\verb|setof| {\it indexing-expression} {\it integrand}
\end{center}

\noindent
where {\it indexing-expression} is an indexing expression which
introduces dummy indices and controls iterating, {\it integrand} is
either a single numeric or symbolic expression or a list of numeric and
symbolic expressions separated by commae and enclosed in parentheses.

If the integrand is a single numeric or symbolic expression, the
resultant set consists of 1-tuples and is determined as follows:
$$\{x:(i_1, \dots, i_n) \in \Delta\},$$
where $x$ is a value of the integrand, $i_1, \dots, i_n$ are dummy
indices introduced in the indexing expression, $\Delta$ is the domain,
a set of $n$-tuples specified by the indexing expression which defines
particular values assigned to the dummy indices on performing the
iterated operation.

If the integrand is a list containing $m$ numeric and symbolic
expressions, the resultant set consists of $m$-tuples and is determined
as follows:
$$\{(x_1, \dots, x_m):(i_1, \dots, i_n) \in \Delta\},$$
where $x_1, \dots, x_m$ are values of the expressions in the integrand
list, $i_1, \dots, i_n$ and $\Delta$ have the same meaning as above.

\paragraph{Conditional expressions.} Conditional set expression is
a primary set expression that has the following syntactic form:
$$\verb|if|\ b\ \verb|then|\ X\ \verb|else|\ Y$$
where $b$ is an logical expression, $X$ and $Y$ are set expressions,
which must define sets of the same dimension.

The resultant value of the conditional expression depends on the value
of the logical expression that follows the keyword \verb|if|. If it is
true, the resultant set is the value of the expression that follows the
keyword \verb|then|. Otherwise, if the logical expression has the value
false, the resultant set is the value of the expression that follows the
keyword \verb|else|.

\paragraph{Parenthesized expressions.} Any set expression may be
enclosed in parentheses that syntactically makes it primary set
expression.

Parentheses may be used in set expressions, as in algebra, to specify
the desired order in which operations are to be performed. Where
parentheses are used, the expression within the parentheses is evaluated
before the resultant value is used.

The resultant value of the parenthesized expression is the same as the
value of the expression enclosed within parentheses.

\paragraph{Set operators.} In MathProg there are the following set
operators, which may be used in set expressions:

\begin{center}
\begin{tabular}{ll}
$X$ \verb|union| $Y$ & union $X \cup Y$ \\
$X$ \verb|diff| $Y$ & difference $X \backslash Y$ \\
$X$ \verb|symdiff| $Y$ & symmetric difference $X \oplus Y$ \\
$X$ \verb|inter| $Y$ & intersection $X \cap Y$ \\
$X$ \verb|cross| $Y$ & cross (Cartesian) product $X \times Y$ \\
\end{tabular}
\end{center}

\noindent
where $X$ and $Y$ are set expressions, which must define sets of the
identical dimension (except for the Cartesian product).

If the expression includes more than one set operator, all operators are
performed from left to right according to the hierarchy of operations
(see below).

The resultant value of the expression, which contains set operators, is
the result of applying the operators to their operands.

The dimension of the resultant set, i.e. the dimension of $n$-tuples,
of which the resultant set consists of, is the same as the dimension
of the operands except the Cartesian product, where the dimension of
the resultant set is the sum of dimension of the operands.

\paragraph{Hierarchy of operations.} The following list shows the
hierarchy of operations in set expressions:

\begin{center}
\begin{tabular}{lc}
\hfil Operation & Hierarchy \\
\hline
Evaluation of numeric operations & 1st-7th \\
Evaluation of symbolic operations & 8th-9th \\
Evaluation of iterated or ``arithmetic'' set
(\verb|setof|, \verb|..|) & 10th \\
Cartesian product (\verb|cross|) & 11th \\
Intersection (\verb|inter|) & 12th \\
Union and difference (\verb|union|, \verb|diff|, \verb|symdiff|) &13th\\
Conditional evaluation (\verb|if| \dots \verb|then| \dots \verb|else|) &
14th \\
\end{tabular}
\end{center}

\noindent
This hierarchy is used to determine which of two consecutive operations
is performed first. If the first operator is higher than or equal to the
second, the first operation is performed. If it is not, the second
operator is compared to the third, etc. When the end of the expression
is reached, all of the remaining operations are performed in the reverse
order.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Logical expressions}

{\it Logical expression} is a rule for computing a single logical value,
which can be either true or false.

The primary logical expression may be a numeric expression, relational
expression, iterated logical expression, or another logical expression
enclosed in parentheses.

\medskip

Examples:

\medskip

\begin{tabular}{@{}ll}
\verb|i+1| & numeric expression \\
\verb|a[i,j] < 1.5| & relational expression \\
\verb|s[i+1,j-1] <> 'Mar' & year | & relational expression \\
\verb|(i+1,'Jan') not in I cross J| & relational expression \\
\verb|S union T within A[i] inter B[j]| & relational expression \\
\verb|forall{i in I, j in J} a[i,j] < .5 * b[i]| & iterated logical
expression \\
\verb|(a[i,j] < 1.5 or b[i] >= a[i,j])| & parenthesized logical
expression \\
\end{tabular}

\medskip

More general logical expressions containing two or more primary logical
expressions may be constructed by using certain logical operators.

\medskip

Examples:

\medskip

\verb|not (a[i,j] < 1.5 or b[i] >= a[i,j]) and (i,j) in S|

\verb|(i,j) in S or (i,j) not in T|

\paragraph{Numeric expressions.} The resultant value of the primary
logical expression, which is a numeric expression, is true if the
resultant value of the numeric expression is not zero, otherwise the
resultant value of the logical expression is false.

\paragraph{Relational expressions.} In MathProg there are the following
relational operators, which may be used in logical expressions:

\begin{center}
\begin{tabular}{ll}
$x$ \verb|<| $y$ & test on $x < y$ \\
$x$ \verb|<=| $y$ & test on $x \leq y$ \\
$x$ \verb|=| $y$, $x$ \verb|==| $y$ & test on $x = y$ \\
$x$ \verb|>=| $y$ & test on $x \geq y$ \\
$x$ \verb|<>| $y$, $x$ \verb|!=| $y$ & test on $x \neq y$ \\
$x$ \verb|in| $Y$ & test on $x \in Y$ \\
$(x_1,\dots,x_n)$ \verb|in| $Y$ & test on $(x_1,\dots,x_n) \in Y$ \\
$x$ \verb|not in| $Y$, $x$ \verb|!in| $Y$ & test on $x \not\in Y$ \\
$(x_1,\dots,x_n)$ \verb|not in| $Y$, $(x_1,\dots,x_n)$ \verb|!in| $Y$ &
test on $(x_1,\dots,x_n) \not\in Y$ \\
$X$ \verb|within| $Y$ & test on $X \subseteq Y$ \\
$X$ \verb|not within| $Y$, $X$ \verb|!within| $Y$ &
test on $X \not\subseteq Y$ \\
\end{tabular}
\end{center}

\noindent
where $x, x_1, \dots, x_n, y$ are numeric or symbolic expressions,
$X$ and $Y$ are set expression.

{\it Notes:}

1.~If $x$ and $y$ are symbolic expressions, only the relational
operators \verb|=|, \verb|==|, \verb|<>|, and \verb|!=| can be used.

2.~In the operations \verb|in|, \verb|not in|, and \verb|!in| the
number of components in the first operands must be the same as the
dimension of the second operand.

3.~In the operations \verb|within|, \verb|not within|, and
\verb|!within| both operands must have identical dimension.

All the relational operators have their conventional mathematical
meaning. The resultant value takes on the value true if the
corresponding relation is satisfied for its operands, otherwise false.

\paragraph{Iterated expressions.} Iterated logical expression is a
primary logical expression, which has the following syntactic form:

\begin{center}
{\it iterated-operator} {\it indexing-expression} {\it integrand}
\end{center}

\noindent
where {\it iterated-operator} is the symbolic name of the iterated
operator to be performed (see below), {\it indexing expression} is an
indexing expression which introduces dummy indices and controls
iterating, {\it integrand} is a logical expression that participates in
the operation.

In MathProg there are two iterated operators, which may be used in
logical expressions:

\begin{center}
\begin{tabular}{@{}lll}
\medskip \verb|forall| & $\forall$-quantification &
$\forall(i_1, \dots, i_n)_{\in \Delta}[x(i_1, \dots, i_n)]$ \\
\medskip \verb|exists| & $\exists$-quantification &
$\exists(i_1, \dots, i_n)_{\in \Delta}[x(i_1, \dots, i_n)]$ \\
\end{tabular}
\end{center}

\noindent
where $i_1, \dots, i_n$ are dummy indices introduced in the indexing
expression, $\Delta$ is the domain, a set of $n$-tuples specified by the
indexing expression which defines particular values assigned to the
dummy indices on performing the iterated operation, $x(i_1, \dots, i_n)$
is the integrand, a logical expression whose resultant value depends on
the dummy indices.

For $\forall$-quantification the resultant value of the iterated
logical expression is true if the value of the integrand is true for
all $n$-tuples contained in the domain, otherwise false.

For $\exists$-quantification the resultant value of the iterated
logical expression is false if the value of the integrand is false for
all $n$-tuples contained in the domain, otherwise true.

\paragraph{Parenthesized expressions.} Any logical expression may be
enclosed in parentheses that syntactically makes it primary logical
expression.

Parentheses may be used in logical expressions, as in algebra, to
specify the desired order in which operations are to be performed. Where
parentheses are used, the expression within the parentheses is evaluated
before the resultant value is used.

The resultant value of the parenthesized expression is the same as the
value of the expression enclosed within parentheses.

\paragraph{Logical operators.} In MathProg there are the following
logical operators, which may be used in logical expressions:

\begin{center}
\begin{tabular}{ll}
\verb|not| $x$, \verb|!| $x$ & negation \\
$x$ \verb|and| $y$, $x$ \verb|&&| $y$ & conjunction (logical ``and'') \\
$x$ \verb|or| $y$, $x$ \verb&||& $y$ & disjunction (logical ``or'') \\
\end{tabular}
\end{center}

\noindent
where $x$ and $y$ are logical expressions.

If the expression includes more than one logical operator, all
operators are performed from left to right according to the hierarchy
of operations (see below).

The resultant value of the expression, which contains logical
operators, is the result of applying the operators to their operands.

\paragraph{Hierarchy of operations.} The following list shows the
hierarchy of operations in logical expressions:

\begin{center}
\begin{tabular}{lc}
\hfil Operation & Hierarchy \\
\hline
Evaluation of numeric operations & 1st-7th \\
Evaluation of symbolic operations & 8th-9th \\
Evaluation of set operations & 10th-14th \\
Relational operations (\verb|<|, \verb|<=|, etc.) & 15th \\
Negation (\verb|not|, \verb|!|) & 16th \\
Conjunction (\verb|and|, \verb|&&|) & 17th \\
$\forall$- and $\exists$-quantification (\verb|forall|, \verb|exists|) &
18th \\
Disjunction (\verb|or|, \verb&||&) & 19th \\
\end{tabular}
\end{center}

\noindent
This hierarchy has the same meaning as explained in Subsection
``Numeric expressions''.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Linear expressions}

{\it Linear expression} is a rule for computing so called {\it linear
form} or simply {\it formula}, which is a linear (or affine) function of
elemental variables.

The primary linear expression may be an unsubscripted variable,
subscripted variable, iterated linear expression, conditional linear
expression, or another linear expression enclosed in parentheses.

It is also allowed to use a numeric expression as the primary linear
expression, in which case the resultant value of the numeric expression
is automatically converted to the formula that consists of the only
constant term.

Examples:

\medskip

\begin{tabular}{@{}ll}
\verb|z| & unsubscripted variable \\
\verb|x[i,j]| & subscripted variable \\
\verb|sum{j in J} (a[i,j] * x[i,j] + 3 * y[i-1])| &
iterated linear expression \\
\verb|if i in I then x[i,j] else 1.5 * z + 3.25| &
conditional linear expression \\
\verb|(a[i,j] * x[i,j] + y[i-1] + .1)| &
parenthesized linear expression \\
\end{tabular}

\medskip

More general linear expressions containing two or more primary linear
expressions may be constructed by using certain arithmetic operators.

\medskip

Examples:

\medskip

\verb|2 * x[i-1,j+1] + 3.5 * y[k] + .5 * z|

\verb|(- x[i,j] + 3.5 * y[k]) / sum{t in T} abs(d[i,j,t])|

\medskip

\paragraph{Unsubscripted variables.} If the primary linear expression
is an unsubscripted variable (which must be 0-dimensional), the
resultant formula is that unsubscripted variable.

\paragraph{Subscripted variables.}
The primary linear expression, which refers to a subscripted variable,
has the following syntactic form:
$$name\verb|[|i_1\verb|,| i_2\verb|,| \dots\verb|,| i_n\verb|]|$$
where {\it name} is the symbolic name of the variable,
$i_1$, $i_2$, \dots, $i_n$ are subscripts.

Each subscript must be a numeric or symbolic expression. The number of
subscripts in the subscript list must be the same as the dimension of
the variable with which the subscript list is associated.

Actual values of subscript expressions are used to identify
a particular member of the model variable that determines the resultant
formula, which is an elemental variable associated with the
corresponding member.

\paragraph{Iterated expressions.} Iterated linear expression is a
primary linear expression, which has the following syntactic form:

\begin{center}
\verb|sum| {\it indexing-expression} {\it integrand}
\end{center}

\noindent
where {\it indexing-expression} is an indexing expression which
introduces dummy indices and controls iterating, {\it integrand} is
a linear expression that participates in the operation.

The iterated linear expression is evaluated exactly in the same way as
the iterated numeric expression (see Subsection ``Numeric expressions''
above) with the exception that integrand participated in the summation
is a formula, not a numeric value.

\paragraph{Conditional expressions.} Conditional linear expression is
a primary linear expression, which has the following two syntactic
forms:

\begin{center}
\begin{tabular}{l}
\verb|if| $b$ \verb|then| $f$ \verb|else| $g$ \\
\verb|if| $b$ \verb|then| $f$ \\
\end{tabular}
\end{center}

\noindent
where $b$ is an logical expression, $f$ and $g$ are linear expressions.

The conditional linear expression is evaluated exactly in the same way
as the conditional numeric expression (see Subsection ``Numeric
expressions'' above) with the exception that operands participated in
the operation are formulae, not numeric values.

\paragraph{Parenthesized expressions.} Any linear expression may be
enclosed in parentheses that syntactically makes it primary linear
expression.

Parentheses may be used in linear expressions, as in algebra, to
specify the desired order in which operations are to be performed. Where
parentheses are used, the expression within the parentheses is evaluated
before the resultant formula is used.

The resultant value of the parenthesized expression is the same as the
value of the expression enclosed within parentheses.

\paragraph{Arithmetic operators.} In MathProg there are the following
arithmetic operators, which may be used in linear expressions:

\begin{center}
\begin{tabular}{ll}
\verb|+| $f$ & unary plus \\
\verb|-| $f$ & unary minus \\
$f$ \verb|+| $g$ & addition \\
$f$ \verb|-| $g$ & subtraction \\
$x$ \verb|*| $f$, $f$ \verb|*| $x$ & multiplication \\
$f$ \verb|/| $x$ & division \\
\end{tabular}
\end{center}

\noindent
where $f$ and $g$ are linear expressions, $x$ is numeric expression.

If the expression includes more than one arithmetic operator, all
operators are performed from left to right according to the hierarchy
of operations (see below).

The resultant value of the expression, which contains arithmetic
operators, is the result of applying the operators to their operands.

\paragraph{Hierarchy of operations.} The hierarchy of arithmetic
operations used in linear expressions is the same as for numeric
expressions (for details see Subsection ``Numeric expressions'').

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage

\section{Statements}

{\it Statements} are basic units of the model description. In MathProg
all statements are divided into two categories: declaration statements
and functional statements.

{\it Declaration statements} (set statement, parameter statement,
variable statement, constraint statement, and objective statement) are
used to declare model objects of certain kinds and define certain
properties of that objects.

{\it Functional statements} (solve statement, check statement, display
statement, printf statement, loop statement) are intended for performing
some specific actions.

Note that declaration statements may follow in arbitrary order which
doesn't affect the result of translation. However, any model object must
be declared before it is referenced in other statements.

\subsection{Set statement}

\medskip

\noindent
\begin{tabular}{|p{23mm}p{118mm}|}
\hline
\multicolumn{2}{|l|}{General Form} \\
& \\
\multicolumn{2}{|l|}{{\tt set} {\it name} {\it alias} {\it domain}
{\tt ,} {\it attrib} {\tt ,} \dots {\tt ,} {\it attrib} {\tt ;}} \\
& \\
Where:
& {\it name} is the symbolic name of a set. \\
& {\it alias} is an optional string literal which specifies the alias
of the set. \\
& {\it domain} is an optional indexing expression which specifies the
subscript domain of the set. \\
& {\it attrib}, \dots, {\it attrib} are optional attributes of the
set. (Commae preceding attributes may be omitted.) \\
& \\
\multicolumn{2}{|l|}{The attributes are:} \\
{\tt dimen} {\it n} & specifies dimension of $n$-tuples, which the set
consists of. \\
\multicolumn{2}{|l|}{{\tt within} {\it expression}} \\
& specifies a superset which restricts the set or all its members
(elemental sets) to be within this superset. \\
{\tt :=} {\it expression} & specifies an elemental set assigned to the
set or its members. \\
\multicolumn{2}{|l|}{{\tt default} {\it expression}} \\
& specifies an elemental set assigned to the set or its members whenever
no appropriate data are available in the data section. \\
\hline
\end{tabular}

\bigskip

\noindent Examples:
\begin{verbatim}
set nodes;
set arcs within nodes cross nodes;
set step{s in 1..maxiter} dimen 2 := if s = 1 then arcs else step[s-1]
   union setof{k in nodes, (i,k) in step[s-1], (k,j) in step[s-1]}(i,j);
set A{i in I, j in J}, within B[i+1] cross C[j-1], within D diff E,
   default {('abc',123), (321,'cba')};
\end{verbatim}

The set statement declares a set. If the subscript domain is not
specified, the set is a simple set, otherwise it is an array of
elemental sets.

The \verb|dimen| attribute specifies dimension of $n$-tuples, which
the set (if it is a simple set) or its members (if the set is an array
of elemental sets) consist of, where $n$ must be unsigned integer from
1 to 20. At most one \verb|dimen| attribute can be specified. If the
\verb|dimen| attribute is not specified, dimension of $n$-tuples is
implicitly determined by other attributes (for example, if there is a
set expression that follows \verb|:=| or the keyword \verb|default|,
the dimension of $n$-tuples of the corresponding elemental set is used).
If no dimension information is available, \verb|dimen 1| is assumed.

The \verb|within| attribute specifies a set expression whose resultant
value is a superset used to restrict the set (if it is a simple set) or
its members (if the set is an array of elemental sets) to be within this
superset. Arbitrary number of \verb|within| attributes may be specified
in the same set statement.

The assign (\verb|:=|) attribute specifies a set expression used to
evaluate elemental set(s) assigned to the set (if it is a simple set) or
its members (if the set is an array of elemental sets). If the assign
attribute is specified, the set is {\it computable} and therefore needs
no data to be provided in the data section. If the assign attribute is
not specified, the set must be provided with data in the data section.
At most one assign or \verb|default| attribute can be specified for the
same set.

The \verb|default| attribute specifies a set expression used to evaluate
elemental set(s) assigned to the set (if it is a simple set) or its
members (if the set is an array of elemental sets) whenever
no appropriate data are available in the data section. If neither assign
nor \verb|default| attribute is specified, missing data will cause an
error.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Parameter statement}

\medskip

\begin{tabular}{|p{23mm}p{118mm}|}
\hline
\multicolumn{2}{|l|}{General Form} \\
& \\
\multicolumn{2}{|l|}{{\tt param} {\it name} {\it alias} {\it domain}
{\tt ,} {\it attrib} {\tt ,} \dots {\tt ,} {\it attrib} {\tt ;}} \\
& \\
Where:
& {\it name} is the symbolic name of a parameter. \\
& {\it alias} is an optional string literal which specifies the alias
of the parameter. \\
& {\it domain} is an optional indexing expression which specifies the
subscript domain of the parameter. \\
& {\it attrib}, \dots, {\it attrib} are optional attributes of the
parameter. (Commae preceding attributes may be omitted.) \\
& \\
\multicolumn{2}{|l|}{The attributes are:} \\
{\tt integer} & specifies that the parameter is integer. \\
{\tt binary} & specifies that the parameter is binary. \\
{\tt symbolic} & specifies that the parameter is symbolic. \\
\multicolumn{2}{|l|}{{\it relation} {\it expression} (where
{\it relation} is one of: {\tt < <= = == >= > <> !=})} \\
& specifies a condition that restricts the parameter or its members to
satisfy this condition. \\
{\tt in} {\it expression} & specifies a superset that restricts the
parameter or its members to be in this superset. \\
{\tt :=} {\it expression} & specifies a value assigned to the parameter
or its members. \\
\multicolumn{2}{|l|}{{\tt default} {\it expression}} \\
& specifies a value assigned to the parameter or its members whenever
no appropriate data are available in the data section. \\
\hline
\end{tabular}

\bigskip\bigskip

\noindent Examples:
\begin{verbatim}
param units{raw, prd} >= 0;
param profit{prd, 1..T+1};
param N := 20 integer >= 0 <= 100;
param comb 'n choose k' {n in 0..N, k in 0..n} :=
   if k = 0 or k = n then 1 else comb[n-1,k-1] + comb[n-1,k];
param p{i in I, j in J}, integer, >= 0, <= i+j, in A[i] symdiff B[j],
   in C[i,j], default 0.5 * (i + j);
param month symbolic default 'May' in {'Mar', 'Apr', 'May'};
\end{verbatim}

The parameter statement declares a parameter. If the subscript domain
is not specified, the parameter is a simple (scalar) parameter,
otherwise it is a $n$-dimensional array.

The type attributes \verb|integer|, \verb|binary|, and \verb|symbolic|
qualify the type values which can be assigned to the parameter as shown
below:

\begin{center}
\begin{tabular}{ll}
Type attribute & \hfil Assigned values \\
\hline
not specified & Any numeric values \\
\verb|integer| & Only integer numeric values \\
\verb|binary| & Either 0 or 1 \\
\verb|symbolic| & Any numeric and symbolic values \\
\end{tabular}
\end{center}

\noindent
The \verb|symbolic| attribute cannot be specified along with other type
attributes. Being specified it must precede all other attributes.

The condition attribute specifies an optional condition that restricts
values assigned to the parameter to satisfy this condition. This
attribute has the following syntactic forms:

\begin{center}
\begin{tabular}{ll}
\verb|<| $v$ & Check for $x < v$ \\
\verb|<=| $v$ & Check for $x \leq v$ \\
\verb|=| $v$, \verb|==| $v$ & Check for $x = v$ \\
\verb|>=| $v$ & Check for $x \geq v$ \\
\verb|>| $v$ & Check for $x > v$ \\
\verb|<>| $v$, \verb|!=| $v$ & Check for $x \neq v$ \\
\end{tabular}
\end{center}

\noindent
where $x$ is a value assigned to the parameter, $v$ is the resultant
value of a numeric or symbolic expression specified in the condition
attribute. If the parameter is symbolic, conditions in the form of
inequality cannot be specified. Arbitrary number of condition attributes
can be specified for the same parameter. If a value being assigned to
the parameter during model evaluation violates at least one specified
condition, an error is raised.

The \verb|in| attribute is similar to the condition attribute and
specifies a set expression whose resultant value is a superset used
to restrict numeric or symbolic values assigned to the parameter to be
in this superset. Arbitrary number of the \verb|in| attributes can be
specified for the same parameter. If a value being assigned to the
parameter during model evaluation is not in at least one specified
superset, an error is raised.

The assign (\verb|:=|) attribute specifies a numeric or symbolic
expression used to compute a value assigned to the parameter (if it is
a simple parameter) or its member (if the parameter is an array). If the
assign attribute is specified, the parameter is {\it computable} and
therefore needs no data to be provided in the data section. If the
assign attribute is not specified, the parameter must be provided with
data in the data section. At most one assign or \verb|default| attribute
can be specified for the same parameter.

The \verb|default| attribute specifies a numeric or symbolic expression
used to compute a value assigned to the parameter or its member whenever
no appropriate data are available in the data section. If neither
assign nor \verb|default| attribute is specified, missing data will
cause an error.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Variable statement}

\medskip

\begin{tabular}{|p{23mm}p{118mm}|}
\hline
\multicolumn{2}{|l|}{General Form} \\
& \\
\multicolumn{2}{|l|}{{\tt var} {\it name} {\it alias} {\it domain}
{\tt ,} {\it attrib} {\tt ,} \dots {\tt ,} {\it attrib} {\tt ;}} \\
& \\
Where:
& {\it name} is the symbolic name of a variable. \\
& {\it alias} is an optional string literal which specifies the alias
of the variable. \\
& {\it domain} is an optional indexing expression which specifies the
subscript domain of the variable. \\
& {\it attrib}, \dots, {\it attrib} are optional attributes of the
variable. (Commae preceding attributes may be omitted.) \\
& \\
\multicolumn{2}{|l|}{The attributes are:} \\
{\tt integer} & restricts the variable to be integer. \\
{\tt binary} & restricts the variable to be binary. \\
{\tt >=} {\it expression} & specifies a lower bound of the variable. \\
{\tt <=} {\it expression} & specifies an upper bound of the variable. \\
\multicolumn{2}{|l|}{{\tt =} {\it expression}, {\tt ==}
{\it expression}} \\
& specifies a fixed value of the variable. \\
\hline
\end{tabular}

\bigskip

\noindent Examples:
\begin{verbatim}
var x >= 0;
var y{I,J};
var make{p in prd}, integer, >= commit[p], <= market[p];
var store{raw, 1..T+1} >= 0;
var z{i in I, j in J} >= i+j;
\end{verbatim}

The variable statement declares a variable. If the subscript domain
is not specified, the variable is a simple (scalar) variable,
otherwise it is a $n$-dimensional array of elemental variables.

Elemental variable(s) associated with the model variable (if it is
a simple variable) or its members (if it is an array) correspond to
structural variables in the LP/MIP problem formulation (see Subsection
``Linear programming problem''). Should note that only the elemental
variables actually referenced in some constraints and objectives are
included in the LP/MIP problem instance to be generated.

The type attributes \verb|integer| and \verb|binary| restrict the
variable to be integer or binary, respectively. If no type attribute
is specified, the variable is continuous. If all variables in the model
are continuous, the corresponding problem is of LP class. If there is
at least one integer or binary variable, the problem is of MIP class.

The lower bound (\verb|>=|) attribute specifies a numeric expression
for computing the lower bound of the variable. At most one lower bound
can be specified. By default variables (except binary ones) have
no lower bounds, so if a variable is required to be non-negative, its
zero lower bound should be explicitly specified.

The upper bound (\verb|<=|) attribute specifies a numeric expression
for computing the upper bound of the variable. At most one upper bound
attribute can be specified.

The fixed value (\verb|=|) attribute specifies a numeric expression
for computing the value, at which the variable is fixed. This attribute
cannot be specified along with lower/upper bound attributes.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Constraint statement}

\medskip

\begin{tabular}{|p{23mm}p{118mm}|}
\hline
\multicolumn{2}{|l|}{General Form} \\
& \\
\multicolumn{2}{|l|}{{\tt subject to} {\it name} {\it alias}
{\it domain} {\tt :} {\it expression} {\tt ,} {\tt =} {\it expression}
{\tt ;}} \\
& \\
\multicolumn{2}{|l|}{{\tt subject to} {\it name} {\it alias}
{\it domain} {\tt :} {\it expression} {\tt ,} {\tt <=} {\it expression}
{\tt ;}} \\
& \\
\multicolumn{2}{|l|}{{\tt subject to} {\it name} {\it alias}
{\it domain} {\tt :} {\it expression} {\tt ,} {\tt >=} {\it expression}
{\tt ;}} \\
& \\
\multicolumn{2}{|l|}{{\tt subject to} {\it name} {\it alias}
{\it domain} {\tt :} {\it expression} {\tt ,} {\tt <=} {\it expression}
{\tt ,} {\tt <=} {\it expression} {\tt ;}} \\
& \\
\multicolumn{2}{|l|}{{\tt subject to} {\it name} {\it alias}
{\it domain} {\tt :} {\it expression} {\tt ,} {\tt >=} {\it expression}
{\tt ,} {\tt >=} {\it expression} {\tt ;}} \\
& \\
Where:
& {\it name} is the symbolic name of a constraint. \\
& {\it alias} is an optional string literal which specifies the alias
of the constraint. \\
& {\it domain} is an optional indexing expression which specifies the
subscript domain of the constraint. \\
& {\it expressions} are linear expressions for computing components of
the constraint. (Commae following expressions may be omitted.) \\
& \\
Note:
& The keyword {\tt subject to} may be reduced to {\tt subj to}, or to
{\tt s.t.} or omitted at all. \\
\hline
\end{tabular}

\bigskip

\noindent Examples:
\begin{verbatim}
s.t. r: x + y + z, >= 0, <= 1;
limit{t in 1..T}: sum{j in prd} make[j,t] <= max_prd;
subject to balance{i in raw, t in 1..T}:
   store[i,t+1] - store[i,t] - sum{j in prd} units[i,j] * make[j,t];
subject to rlim 'regular-time limit' {t in time}:
   sum{p in prd} pt[p] * rprd[p,t] <= 1.3 * dpp[t] * crews[t];
\end{verbatim}

The constraint statement declares a constraint. If the subscript domain
is not specified, the constraint is a simple (scalar) constraint,
otherwise it is a $n$-dimensional array of elemental constraints.

Elemental constraint(s) associated with the model constraint (if it is
a simple constraint) or its members (if it is an array) correspond to
general linear constraints in the LP/MIP problem formulation (see
Subsection ``Linear programming problem'').

If the constraint has the form of equality or single inequality, i.e.
includes two expressions, one of which follows the colon and other
follows the relation sign \verb|=|, \verb|<=|, or \verb|>=|, both
expressions in the statement can be linear expressions.
If the constraint has the form of double inequality, i.e. includes
three expressions, the middle expression can be linear expression
while the leftmost and rightmost ones can be only numeric expressions.

Generating the model is, generally speaking, generating its constraints,
which are always evaluated for the entire subscript domain. Evaluating
constraints leads, in turn, to evaluating other model objects such as
sets, parameters, and variables.

Constructing the actual linear constraint included in the problem
instantce, which (constraint) corresponds to a particular elemental
constraint, is performed as follows.

If the constraint has the form of equality or single inequality,
evaluation of both linear expressions gives two resultant linear forms:
$$
\begin{array}{r@{\ }c@{\ }l}
f &=& a_1 x_{m+1} + a_2 x_{m+2} + \dots + a_n x_{m+n} + a_0, \\
g &=& b_1 x_{m+1} \,+ b_2 x_{m+2} + \dots + b_n x_{m+n} \,+ b_0, \\
\end{array}
$$
where $x_{m+1}, x_{m+2}, \dots, x_{m+n}$ are elemental variables,
$a_1, a_2, \dots, a_n, b_1, b_2, \dots, b_n$ are numeric coefficients,
$a_0$ and $b_0$ are constant terms. Then all linear terms of $f$ and $g$
are carried to the left-hand side, and the constant terms are carried to
the right-hand side that gives the final elemental constraint in the
standard form:
$$
x_i: (a_1-b_1)x_{m+1} + (a_2-b_2)x_{m+2} + \dots + (a_n-b_n)x_{m+n}
\left\{ \begin{array}{@{}l@{}} =\\ \leq\\ \geq\\ \end{array} \right\}
b_0-a_0,
$$
where $x_i$ is the implicit auxiliary variable of the constraint (see
Subsection ``Linear programming problem'').

If the constraint has the form of double inequality, evaluation of the
middle linear expression gives the resultant linear form:
$$f = a_1x_{m+1} + a_2x_{m+2} + \dots + a_nx_{m+n} + a_0,$$
and evaluation of the leftmost and rightmost numeric expressions gives
two numeric values $l$ and $u$ (or $u$ and $l$), respectively. Then
the constant term of the linear form is carried to both left-hand and
right-hand sides that gives the final elemental constraint in the
standard form:
$$l-a_0\leq x_i:a_1x_{m+1}+a_2x_{m+2}+\dots+a_nx_{m+n}\leq u-a_0,$$
where $x_i$ is the implicit auxiliary variable of the constraint.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Objective statement}

\medskip

\begin{tabular}{|p{23mm}p{118mm}|}
\hline
\multicolumn{2}{|l|}{General Form} \\
& \\
\multicolumn{2}{|l|}{{\tt minimize} {\it name} {\it alias}
{\it domain} {\tt :} {\it expression} {\tt ;}} \\
& \\
\multicolumn{2}{|l|}{{\tt maximize} {\it name} {\it alias}
{\it domain} {\tt :} {\it expression} {\tt ;}} \\
& \\
Where:
& {\it name} is the symbolic name of an objective. \\
& {\it alias} is an optional string literal which specifies the
objective alias. \\
& {\it domain} is an optional indexing expression which specifies the
subscript domain of the objective. \\
& {\it expression} is an linear expression which specifies the linear
form of the objective. \\
\hline
\end{tabular}

\bigskip

\noindent Examples:
\begin{verbatim}
minimize obj: x + 1.5 * (y + z);
maximize total_profit: sum{p in prd} profit[p] * make[p];
\end{verbatim}

The objective statement declares an objective. If the subscript domain
is not specified, the objective is a simple (scalar) objective.
Otherwise it is a $n$-dimensional array of elemental objectives.

Elemental objective(s) associated with the model objective (if it is
a simple objective) or its members (if it is an array) correspond to
general linear constraints in the LP/MIP problem formulation (see
Subsection ``Linear programming problem''). However, unlike constraints
the corresponding linear forms are free (unbounded).

Constructing the actual linear constraint included in the problem
instance, which (constraint) corresponds to a particular elemental
objective, is performed as follows. The linear expression specified in
the objective statement is evaluated that gives the resultant linear
form:
$$f = a_1 x_{m+1} + a_2 x_{m+2} + \dots + a_n x_{m+n} + a_0,$$
where $x_{m+1}, x_{m+2}, \dots, x_{m+n}$ are elemental variables,
$a_1, a_2, \dots, a_n$ are numeric coefficients, $a_0$ is the constant
term. Then the linear form is used to construct the final elemental
constraint in the standard form:
$$
-\infty\leq x_i:a_1x_{m+1}+a_2x_{m+2}+\dots+a_nx_{m+n}+a_0\leq+\infty,
$$
where $x_i$ is the implicit free (unbounded) auxiliary variable of the
constraint.

As a rule the model description contains only one objective
statement that defines the objective function (1) used in the problem
instance. However, it is allowed to declare arbitrary number of
objectives, in which case the actual objective function is the
{\it first} objective encountered in the model description. Other
objectives are also included in the problem instance, but they don't
affect the objective function.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Solve statement}

\medskip

\begin{tabular}{|p{23mm}p{118mm}|}
\hline
\multicolumn{2}{|l|}{General Form} \\
& \\
\multicolumn{2}{|l|}{{\tt solve} {\tt ;}} \\
& \\
Note:
& The solve statement is optional and can be used only once. If no solve
statement is used, one is assumed at the end of the model section. \\
\hline
\end{tabular}

\bigskip

\noindent Examples:
\begin{verbatim}
solve;
\end{verbatim}

The solve statement causes solving the model, that is computing numeric
values of all model variables. This allows using variables in statements
below the solve statement in the same way as if they were numeric
parameters.

Note that variable, constraint, and objective statements cannot be used
below the solve statement, i.e. all principal components of the model
must be described above the solve statement.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Check statement}

\medskip

\begin{tabular}{|p{23mm}p{118mm}|}
\hline
\multicolumn{2}{|l|}{General Form} \\
& \\
\multicolumn{2}{|l|}{{\tt check} {\it domain} {\tt :} {\it expression}
{\tt ;}} \\
& \\
Where:
& {\it domain} is an optional indexing expression which specifies the
subscript domain of the check statement. \\
& {\it expression} is an logical expression which specifies the logical
condition to be checked. (The colon preceding {\it expression} may be
omitted.) \\
\hline
\end{tabular}

\bigskip

\noindent Examples:
\begin{verbatim}
check: x + y <= 1 and x >= 0 and y >= 0;
check sum{i in ORIG} supply[i] = sum{j in DEST} demand[j];
check{i in I, j in 1..10}: S[i,j] in U[i] union V[j]; 
\end{verbatim}

The check statement allows checking the resultant value of an logical
expression specified in the statement. If the value is false, the model
translator reports an error.

If the subscript domain is not specified, the check is performed only
once. Specifying the subscript domain allows performing multiple checks
for every $n$-tuple in the domain set. In the latter case the logical
expression may include dummy indices introduced in the corresponding
indexing expression.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Display statement}

\medskip

\begin{tabular}{|p{23mm}p{118mm}|}
\hline
\multicolumn{2}{|l|}{General Form} \\
& \\
\multicolumn{2}{|l|}{{\tt display} {\it domain} {\tt :} {\it item}
{\tt ,} \dots {\tt ,} {\it item} {\tt ;}} \\
& \\
Where:
& {\it domain} is an optional indexing expression which specifies the
subscript domain of the display statement. \\
& {\it item} {\tt ,} \dots {\tt ,} {\it item} are items to be
displayed. (The colon preceding the first item may be omitted.) \\
\hline
\end{tabular}

\bigskip

\noindent Examples:
\begin{verbatim}
display: 'x =', x, 'y =', y, 'z =', z;
display sqrt(x ** 2 + y ** 2 + z ** 2);
display{i in I, j in J}: i, j, a[i,j], b[i,j];
\end{verbatim}

The display statement evaluates all items specified in the statement
and writes their values on the standard output in plain text format.

If the subscript domain is not specified, items are evaluated and
then displayed only once. Specifying the subscript domain causes
evaluating and displaying items for every $n$-tuple in the domain set.
In the latter case items may include dummy indices introduced in the
corresponding indexing expression.

Item to be displayed can be a model object (set, parameter, variable,
constraint, objective) or an expression.

If the item is a computable object (i.e. a set or parameter provided
with the assign attribute), the object is evaluated over the entire
domain and then its content (i.e. the content of the object array) is
displayed. Otherwise, if the item is not a computable object, only its
current content (i.e. the members actually generated during the model
evaluation) is displayed. Note that if the display statement is used
above the solve statement and the item is a variable, its displayed
``value'' means ``elemental variable'', not a numeric value, which the
variable could have in some solution obtained by the solver. To display
a numeric value of a variable the display statement should be used
below the solve statement. Analogously, if the item is a constraint or
objective, its ``value'' means ``elemental constraint'' or ``elemental
objective'', not a numeric value.

If the item is an expression, the expression is evaluated and its
resultant value is displayed.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Printf statement}

\medskip

\begin{tabular}{|p{23mm}p{118mm}|}
\hline
\multicolumn{2}{|l|}{General Form} \\
& \\
\multicolumn{2}{|l|}{{\tt printf} {\it domain} {\tt :}
{\it format} {\tt ,} {\it expression} {\tt ,} \dots {\tt ,}
{\it expression} {\tt ;}} \\
& \\
Where:
& {\it domain} is an optional indexing expression which specifies the
subscript domain of the printf statement. \\
& {\it format} is a symbolic expression whose value specifies a format
control string. \\
& {\it expression} {\tt ,} \dots {\tt ,} {\it expression} are zero or
more expressions whose values have to be formatted and printed. Each
expression must be of numeric, symbolic, or logical type. (The colon
preceding the format expression may be omitted.) \\
\hline
\end{tabular}

\bigskip

\noindent Examples:
\begin{verbatim}
printf 'Hello, world!\n';
printf: "x = %.3f; y = %.3f; z = %.3f\n", x, y, z;
printf{i in I, j in J}: "flow from %s to %s is %d\n", i, j, x[i,j];
printf{i in I} 'total flow from %s is %g\n', i, sum{j in J} x[i,j];
printf{k in K} "x[%s] = " & (if x[k] < 0 then "?" else "%g"), k, x[k];
\end{verbatim}

The printf statement is similar to the display statement, however, it
allows the user specifying a format control string used to format data
written on the standard output.

If the subscript domain is not specified, the printf statement is
executed only once. Specifying the subscript domain causes executing
the printf statement for every $n$-tuple in the domain set. In the
latter case {\it format} and {\it expressions} may include dummy
indices introduced in the corresponding indexing expression.

The format control string is a value of the symbolic expression
{\it format} specified in the printf statement. It is composed of zero
or more directives: ordinary characters (not \%), which are copied
unchanged to the standard output, and conversion specifications, each of
which causes evaluating of corresponding {\it expression} specified in
the printf statement, formatting it, and writing the resultant value to
the standard output.

Conversion specifications which may be used in the format control
string are the following: {\tt d}, {\tt i}, {\tt f}, {\tt F}, {\tt e},
{\tt E}, {\tt g}, {\tt G}, and {\tt s}. All they have the same syntax
and semantics as in the C programming language.

\subsection{For statement}

\medskip

\begin{tabular}{|p{23mm}p{118mm}|}
\hline
\multicolumn{2}{|l|}{General Form} \\
& \\
\multicolumn{2}{|l|}{{\tt for} {\it domain} {\tt :} {\it statement}} \\
& \\
\multicolumn{2}{|l|}{{\tt for} {\it domain} {\tt :} \{
{\it statement} \dots\ {\it statement} \}} \\
& \\
Where:
& {\it domain} is an indexing expression which specifies the subscript
domain of the for statement. (The colon following the indexing
expression may be omitted.)\\
& {\it statement} is a statement which has to be executed under control
of the for statement. \\
& {\it statement} \dots\ {\it statement} is a sequence of statements
(enclosed in curly braces) which have to be executed under control of
the for statement. \\
& \\
Note:
& Only following statements are allowed within the for statement: check,
display, printf, and another for. \\
\hline
\end{tabular}

\bigskip

\noindent Examples:
\begin{verbatim}
for {(i,j) in E: i != j}
{  printf "flow from %s to %s is %g\n", i, j, x[i,j];
   check x[i,j] >= 0;
}
for {i in 1..n}
{  for {j in 1..n} printf " %s", if x[i,j] then "Q" else ".";
   printf("\n");
}
for {1..72} printf("*");
\end{verbatim}

The for statement causes executing a statement or a sequence of
statements specified as part of the for statement for every $n$-tuple
in the domain set. Thus, statements within the for statement may refer
to dummy indices introduced in the corresponding indexing expression.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage

\section{Model data}

{\it Model data} include elemental sets, which are ``values'' of model
sets, and numeric and symbolic values of model parameters.

In MathProg there are two different ways to saturate model sets and
parameters with data. One way is simply providing necessary data using
the assign attribute. However, in many cases it is more practical to
separate the model itself and particular data needed for the model.
For the latter reason in MathProg there is other way, when the model
description is divided into two parts: model section and data section.

{\it Model section} is a main part of the model description that
contains declarations of all model objects and is common for all
problems based on that model.

{\it Data section} is an optional part of the model description that
contains model data specific for a particular problem.

In MathProg model and data sections can be placed either in one text
file or in two separate text files.

If both model and data sections are placed in one file, the file is
composed as follows:

\begin{center}
\begin{tabular}{|p{30mm}|}
\hline
statement \\
statement \\
\dots \\
statement \\
\verb|data;| \\
data block \\
data block \\
\dots \\
data block \\
\verb|end;| \\
\hline
\end{tabular}
\end{center}

If the model and data sections are placed in two separate files, the
files are composed as follows:

\begin{center}
\begin{tabular}{ccc}
\begin{tabular}{|p{30mm}|}
\hline
statement \\
statement \\
\dots \\
statement \\
\verb|end;| \\
\\
\hline
\end{tabular}
& &
\begin{tabular}{|p{30mm}|}
\hline
\verb|data;| \\
data block \\
data block \\
\dots \\
data block \\
\verb|end;| \\
\hline
\end{tabular}
\\
Model file & & Data file
\end{tabular}
\end{center}

Note: If the data section is placed in a separate file, the keyword
\verb|data| is optional and may be omitted along with the semicolon that
follows it.

\subsection{Coding data section}

The data section is a sequence of data blocks in various formats, which
are discussed in following subsections. The order, in which data blocks
follow in the data section, may be arbitrary, not necessarily the same
as in which the corresponding model objects follow in the model section.

The rules of coding the data section are commonly the same as the rules
of coding the model description (for details see Section ``Coding model
description''), i.e. data blocks are composed from basic lexical units
such as symbolic names, numeric and string literals, keywords,
delimiters, and comments. However, for the sake of convenience and
improving readability there is one deviation from the common rule: if
a string literal consists of only alphanumeric characters (including the
underscore character), the signs \verb|+| and \verb|-|, and/or the
decimal point, it may be coded {\it without} bordering (single or
double) quotes.

All numeric and symbolic material provided in the data section is coded
in the form of numbers and symbols, i.e. unlike the model section
no expressions are allowed in the data section. Nevertheless the signs
\verb|+| and \verb|-| can precede numeric literals to allow coding
signed numeric quantities, in which case there must be no white-space
characters between the sign and following numeric literal (if there is
at least one white-space, the sign and following numeric literal are
recognized as {\it two} different lexical units).

\subsection{Set data block}

\medskip

\begin{tabular}{|p{23mm}p{118mm}|}
\hline
\multicolumn{2}{|l|}{General Form} \\
& \\
\multicolumn{2}{|l|}{{\tt set} {\it name} {\tt ,} {\it record} {\tt ,}
\dots {\tt ,} {\it record} {\tt ;}} \\
& \\
\multicolumn{2}{|l|}{{\tt set} {\it name} {\tt [} {\it symbol} {\tt ,}
\dots {\tt ,} {\it symbol} {\tt ]} {\tt,} {\it record} {\tt ,} \dots
{\tt ,} {\it record} {\tt ;}} \\
& \\
Where:
& {\it name} is the symbolic name of a set. \\
& {\it symbol}, \dots, {\it symbol} are subscripts that specify a
particular member of the set (if the set is an array, i.e. set of
sets). \\
& {\it record}, \dots, {\it record} are data records. \\
& \\
Note: & Commae preceding data records may be omitted. \\
& \\
\multicolumn{2}{|l|}{The data records are:} \\
{\tt :=} & is a non-significant data record which may be used freely to
improve readability.\\
{\tt (} {\it slice} {\tt )} & specifies a slice. \\
{\it simple-data} & specifies set data in the simple format. \\
\multicolumn{2}{|l|}{{\tt :} {\it matrix-data} \ \ specifies set data
in the matrix format.} \\
\multicolumn{2}{|l|}{{\tt (tr) :} {\it matrix-data}} \\
& specifies set data in the transposed matrix format. (In this case the
colon following the keyword \verb|(tr)| may be omitted.) \\
\hline
\end{tabular}

\bigskip

\noindent Examples:
\begin{verbatim}
set month := Jan Feb Mar Apr May Jun;
set month "Jan", "Feb", "Mar", "Apr", "May", "Jun";
set A[3,Mar] := (1,2) (2,3) (4,2) (3,1) (2,2) (4,4) (3,4);
set A[3,'Mar'] := 1 2 2 3 4 2 3 1 2 2 4 4 2 4;
set A[3,'Mar'] : 1 2 3 4 :=
               1 - + - -
               2 - + + -
               3 + - - +
               4 - + - + ;
\end{verbatim}

\begin{verbatim}
set B := (1,2,3) (1,3,2) (2,3,1) (2,1,3) (1,2,2) (1,1,1) (2,1,1);
set B := (*,*,*) 1 2 3, 1 3 2, 2 3 1, 2 1 3, 1 2 2, 1 1 1, 2 1 1;
set B := (1,*,2) 3 2 (2,*,1) 3 1 (1,2,3) (2,1,3) (1,1,1);
set B := (1,*,*) : 1 2 3 :=
                 1 + - -
                 2 - + +
                 3 - + -
         (2,*,*) : 1 2 3 :=
                 1 + - +
                 2 - - -
                 3 + - - ;
\end{verbatim}

\noindent (In these examples the set \verb|month| is a simple set of
singles, \verb|A| is a 2-dimensional array of doubles, and \verb|B| is
a simple set of triples. Data blocks for the same set are equivalent in
the sense that they specify the same data in different formats.)

\bigskip

The set data block is used to specify a complete elemental set, which
is assigned to a set (if it is a simple set) or one of its members (if
the set is an array of sets).\footnote{There is another way to specify
data for a simple set along with data for parameters. This feature is
discussed in the next subsection.}

Data blocks can be specified only for the sets, which are
non-computable, i.e. which have no assign attribute in the corresponding
set statements.

If the set is a simple set, only its symbolic name should be given in
the header of the data block. Otherwise, if the set is a $n$-dimensional
array, its symbolic name should be provided with a complete list of
subscripts separated by commae and enclosed in square brackets to
specify a particular member of the set array. The number of subscripts
must be the same as the dimension of the set array, where each subscript
must be a number or symbol.

The elemental set defined in the set data block is coded as a sequence
of data records described below.\footnote{{\it Data record} is simply a
technical term. It {\it does not mean} that data records have any
special formatting.}

\paragraph{Assign data record.} The assign (\verb|:=|) data record is
a non-signficant element. It may be used for improving readability of
data blocks.

\paragraph{Slice data record.} The slice data record is a control
record which specifies a slice of the elemental set defined in the data
block. It has the following syntactic form:
$$\verb|(| s_1 \verb|,| s_2 \verb|,| \dots \verb|,| s_n \verb|)|$$
where $s_1, s_2, \dots, s_n$ are components of the slice.

Each component of the slice can be a number or symbol or the asterisk
(\verb|*|). The number of components in the slice must be the same as
the dimension of $n$-tuples in the elemental set to be defined. For
instance, if the elemental set contains 4-tuples (quadruples), the slice
must have four components. The number of asterisks in the slice is
called {\it slice dimension}.

The effect of using slices is the following. If a $m$-dimensional slice
(i.e. a slice that has $m$ asterisks) is specified in the data block,
all subsequent data records must specifiy tuples of the dimension $m$.
Whenever a $m$-tuple is encountered, each asterisk in the slice is
replaced by corresponding components of the $m$-tuple that gives the
resultant $n$-tuple, which is included in the elemental set to be
defined. For example, if the slice $(a,*,1,2,*)$ is in effect, and
the 2-tuple $(3,b)$ is encountered in a subsequent data record, the
resultant 5-tuple included in the elemental set is $(a,3,1,2,b)$.

The slice that has no asterisks itself defines a complete $n$-tuple,
which is included in the elemental set.

Being once specified the slice effects until either a new slice or the
end of data block has been encountered. Note that if there is no slice
specified in the data block, a dummy one, components of which are all
asterisks, is assumed.

\paragraph{Simple data record.} The simple data record defines one
$n$-tuple in simple format and has the following syntactic form:
$$t_1 \verb|,| t_2 \verb|,| \dots \verb|,| t_n$$
where $t_1, t_2, \dots, t_n$ are components of the $n$-tuple. Each
component can be a number or symbol. Commae between components are
optional and may be omitted.

\paragraph{Matrix data record.} The matrix data record defines several
$2$-tuples (doubles) in matrix format and has the following syntactic
form:
$$
\begin{array}{cccccc}
\verb|:| & c_1 & c_2 & \dots & c_n & \verb|:=| \\
r_1 & a_{11} & a_{12} & \dots & a_{1n} & \\
r_2 & a_{21} & a_{22} & \dots & a_{2n} & \\
\dots & \dots & \dots & \dots & \dots & \\
r_m & a_{m1} & a_{m2} & \dots & a_{mn} & \\
\end{array}
$$
where $r_1, r_2, \dots, r_m$ are numbers and/or symbols that correspond
to rows of the matrix, $c_1, c_2, \dots, c_n$ are numbers and/or
symbols that correspond to columns of the matrix,
$a_{11}, a_{12}, \dots, a_{mn}$ are the matrix elements, which can be
the signs \verb|+| and \verb|-|. (In this data record the delimiter
\verb|:| that precedes the column list and the delimiter \verb|:=| that
follows the column list cannot be omitted.)

Each element $a_{ij}$ of the matrix data block (where
$1\leq i\leq m, 1\leq j\leq n$) corresponds to the 2-tuple $(r_i, c_j)$.
If $a_{ij}$ is the plus (\verb|+|) sign, the corresponding 2-tuple
(or longer $n$-tuple, if a slice is used) is included in the elemental
set. Otherwise, if $a_{ij}$ is the minus (\verb|-|) sign, the
corresponding 2-tuple is not included in the elemental set.

Since the matrix data record defines 2-tuples, either the elemental
set must consist of 2-tuples or the slice currently used must be
2-dimensional.

\paragraph{Transposed matrix data record.} The transposed matrix data
record has the following syntactic form:
$$
\begin{array}{cccccc}
\verb|(tr) :| & c_1 & c_2 & \dots & c_n & \verb|:=| \\
r_1 & a_{11} & a_{12} & \dots & a_{1n} & \\
r_2 & a_{21} & a_{22} & \dots & a_{2n} & \\
\dots & \dots & \dots & \dots & \dots & \\
r_m & a_{m1} & a_{m2} & \dots & a_{mn} & \\
\end{array}
$$
(In this case the delimiter \verb|:| that follows the keyword
\verb|(tr)| is optional and may be omitted.)

This data record is completely analogous to the matrix data record (see
above) with the only exception that each element $a_{ij}$ of the matrix
corresponds to the 2-tuple $(c_j,r_i)$.

Being once specified the \verb|(tr)| indicator effects on {\it all}
subsequent data records until either a slice or the end of data block
has been encountered.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Parameter data block}

\medskip

\begin{tabular}{|p{23mm}p{118mm}|}
\hline
\multicolumn{2}{|l|}{General Form} \\
& \\
\multicolumn{2}{|l|}{{\tt param} {\it name} {\tt,} {\it record} {\tt ,}
\dots {\tt ,} {\it record} {\tt ;}} \\
& \\
\multicolumn{2}{|l|}{{\tt param} {\it name} {\tt default} {\it value}
{\tt,} {\it record} {\tt ,} \dots {\tt ,} {\it record} {\tt ;}} \\
& \\
\multicolumn{2}{|l|}{{\tt param} {\tt :} {\it tabbing-data} {\tt ;}} \\
& \\
\multicolumn{2}{|l|}{{\tt param} {\tt default} {\it value} {\tt :}
{\it tabbing-data} {\tt ;}} \\
& \\
Where:
& {\it name} is the symbolic name of a parameter. \\
& {\it value} is an optional default value of the parameter. \\
& {\it record}, \dots, {\it record} are data records. \\
& {\it tabbing-data} specifies parameter data in the tabbing format. \\
& \\
Note: & Commae preceding data records may be omitted. \\
& \\
\multicolumn{2}{|l|}{The data records are:} \\
{\tt :=} & is a non-significant data record which may be used freely to
improve readability.\\
{\tt [} {\it slice} {\tt ]} & specifies a slice. \\
{\it plain-data} & specifies parameter data in the plain format. \\
\multicolumn{2}{|l|}{{\tt :} {\it tabular-data} \ \ specifies parameter
data in the tabular format.} \\
\multicolumn{2}{|l|}{{\tt (tr) :} {\it tabular-data}} \\
& specifies parameter data in the transposed tabular format. (In this
case the colon following the keyword \verb|(tr)| may be omitted.) \\
\hline
\end{tabular}

\bigskip

\noindent Examples:
\begin{verbatim}
param T := 4;
param month := 1 Jan 2 Feb 3 Mar 4 Apr 5 May;
param month := [1] 'Jan', [2] 'Feb', [3] 'Mar', [4] 'Apr', [5] 'May';
param init_stock := iron 7.32 nickel 35.8;
param init_stock [*] iron 7.32, nickel 35.8;
param cost [iron] .025 [nickel] .03;
param value := iron -.1, nickel .02;
param       : init_stock  cost  value :=
      iron       7.32     .025   -.1
      nickel    35.8      .03     .02 ;
param : raw : init stock  cost  value :=
        iron     7.32     .025   -.1
        nickel  35.8      .03     .02 ;
param demand default 0 (tr)
       :  FRA  DET  LAN  WIN  STL  FRE  LAF :=
   bands  300   .   100   75   .   225  250
   coils  500  750  400  250   .   850  500
   plate  100   .    .    50  200   .   250 ;
param trans_cost :=
   [*,*,bands]:  FRA  DET  LAN  WIN  STL  FRE  LAF :=
         GARY     30   10    8   10   11   71    6
         CLEV     22    7   10    7   21   82   13
         PITT     19   11   12   10   25   83   15
   [*,*,coils]:  FRA  DET  LAN  WIN  STL  FRE  LAF :=
         GARY     39   14   11   14   16   82    8
         CLEV     27    9   12    9   26   95   17
         PITT     24   14   17   13   28   99   20
   [*,*,plate]:  FRA  DET  LAN  WIN  STL  FRE  LAF :=
         GARY     41   15   12   16   17   86    8
         CLEV     29    9   13    9   28   99   18
         PITT     26   14   17   13   31  104   20 ;
\end{verbatim}

The parameter data block is used to specify complete data for a
parameter (or parameters, if data are specified in the tabbing format)
whose name is given in the block.

Data blocks can be specified only for the parameters, which are
non-computable, i.e. which have no assign attribute in the corresponding
parameter statements.

Data defined in the parameter data block are coded as a sequence of
data records described below. Additionally the data block can be
provided with the optional \verb|default| attribute, which specifies
a default numeric or symbolic value of the parameter (parameters). This
default value is assigned to the parameter or its members, if
no appropriate value is defined in the parameter data block. The
\verb|default| attribute cannot be used, if it is already specified in
the corresponding parameter statement(s).

\paragraph{Assign data record.} The assign (\verb|:=|) data record is
a non-signficant element. It may be used for improving readability of
data blocks.

\paragraph{Slice data record.} The slice data record is a control
record which specifies a slice of the parameter array. It has the
following syntactic form:
$$\verb|[| s_1 \verb|,| s_2 \verb|,| \dots \verb|,| s_n \verb|]|$$
where $s_1, s_2, \dots, s_n$ are components of the slice.

Each component of the slice can be a number or symbol or the asterisk
(\verb|*|). The number of components in the slice must be the same as
the dimension of the parameter. For instance, if the parameter is a
4-dimensional array, the slice must have four components. The number of
asterisks in the slice is called {\it slice dimension}.

The effect of using slices is the following. If a $m$-dimensional slice
(i.e. a slice that has $m$ asterisks) is specified in the data block,
all subsequent data records must specify subscripts of the parameter
members as if the parameter were $m$-dimensional, not $n$-dimensional.

Whenever $m$ subscripts are encountered, each asterisk in the slice
is replaced by corresponding subscript that gives $n$ subscripts, which
define the actual parameter member. For example, if the slice
$[a,*,1,2,*]$ is in effect, and the subscripts 3 and $b$ are
encountered in a subsequent data record, the complete subscript list
used to choose a parameter member is $[a,3,1,2,b]$.

It is allowed to specify a slice that has no asterisks. Such slice
itself defines a complete subscript list, in which case the next data
record can define only a single value of the corresponding parameter
member.

Being once specified the slice effects until either a new slice or the
end of data block has been encountered. Note that if there is no slice
specified in the data block, a dummy one, components of which are all
asterisks, is assumed.

\paragraph{Plain data record.} The plain data record defines the
subscript list and a single value in plain format. This record has the
following syntactic form:
$$t_1 \verb|,| t_2 \verb|,| \dots \verb|,| t_n \verb|,| v$$
where $t_1, t_2, \dots, t_n$ are subscripts, $v$ is a value. Each
subscript as well as the value can be a number or symbol. Commae that
follow subscripts are optional and may be omitted.

In case of 0-dimensional parameter or slice the plain data record have
no subscripts and consists of a single value only.

\paragraph{Tabular data record.} The tabular data record defines
several values, where each value is provided with two subscripts.
This record has the following syntactic form:
$$
\begin{array}{cccccc}
\verb|:| & c_1 & c_2 & \dots & c_n & \verb|:=| \\
r_1 & a_{11} & a_{12} & \dots & a_{1n} & \\
r_2 & a_{21} & a_{22} & \dots & a_{2n} & \\
\dots & \dots & \dots & \dots & \dots & \\
r_m & a_{m1} & a_{m2} & \dots & a_{mn} & \\
\end{array}
$$
where $r_1, r_2, \dots, r_m$ are numbers and/or symbols that correspond
to rows of the matrix, $c_1, c_2, \dots, c_n$ are numbers and/or
symbols that correspond to columns of the table,
$a_{11}, a_{12}, \dots, a_{mn}$ are the table elements. Each element
can be a number or symbol or the single decimal point. (In this data
record the delimiter \verb|:| that precedes the column list and the
delimiter \verb|:=| that follows the column list cannot be omitted.)

Each element $a_{ij}$ of the tabular data block ($1\leq i\leq m,
1\leq j\leq n$) defines two subscripts, where the first subscript is
$r_i$, and the second one is $c_j$. These subscripts are used in
conjunction with the current slice to form the complete subscript list
that identifies a particular member of the parameter array. If $a_{ij}$
is a number or symbol, this value is assigned to the parameter member.
However, if $a_{ij}$ is the single decimal point, the member is assigned
a default value specified either in the parameter data block or in the
parameter statement, or, if no default value is specified, the member
remains undefined.

Since the tabular data record provides two subscripts for each value,
either the parameter or the slice currently used must be 2-dimensional.

\paragraph{Transposed tabular data record.} The transposed tabular data
record has the following syntactic form:
$$
\begin{array}{cccccc}
\verb|(tr) :| & c_1 & c_2 & \dots & c_n & \verb|:=| \\
r_1 & a_{11} & a_{12} & \dots & a_{1n} & \\
r_2 & a_{21} & a_{22} & \dots & a_{2n} & \\
\dots & \dots & \dots & \dots & \dots & \\
r_m & a_{m1} & a_{m2} & \dots & a_{mn} & \\
\end{array}
$$
(In this case the delimiter \verb|:| that follows the keyword
\verb|(tr)| is optional and may be omitted.)

This data record is completely analogous to the tabular data record (see
above) with the only exception that the first subscript defined by the
element $a_{ij}$ is $c_j$ while the second one is $r_i$.

Being once specified the \verb|(tr)| indicator effects on all
subsequent data records until either a slice or the end of data block
has been encountered.

\paragraph{Tabbing data format.} The parameter data block in the
tabbing format has the following syntactic form:
$$
\begin{array}{*{8}{l}}
\multicolumn{4}{l}
{{\tt param}\ {\tt default}\ value\ {\tt :}\ s\ {\tt :}}&
p_1\ \ \verb|,|&p_2\ \ \verb|,|&\dots\ \verb|,|&p_r\ \ \verb|:=|\\
r_{11}\ \verb|,|& r_{12}\ \verb|,|& \dots\ \verb|,|& r_{1n}\ \verb|,|&
a_{11}\ \verb|,|& a_{12}\ \verb|,|& \dots\ \verb|,|& a_{1r}\ \verb|,|\\
r_{21}\ \verb|,|& r_{22}\ \verb|,|& \dots\ \verb|,|& r_{2n}\ \verb|,|&
a_{21}\ \verb|,|& a_{22}\ \verb|,|& \dots\ \verb|,|& a_{2r}\ \verb|,|\\
\dots & \dots & \dots & \dots & \dots & \dots & \dots & \dots \\
r_{m1}\ \verb|,|& r_{m2}\ \verb|,|& \dots\ \verb|,|& r_{mn}\ \verb|,|&
a_{m1}\ \verb|,|& a_{m2}\ \verb|,|& \dots\ \verb|,|& a_{mr}\ \verb|;|\\
\end{array}
$$

Notes:

1. The keyword \verb|default| may be omitted along with a value that
follows it.

2. The symbolic name $s$ of a set may be omitted along with the colon
that follows it.

3. All comae are optional and may be omitted.

The data block in the tabbing format shown above is exactly equivalent
to the following data blocks:

\bigskip

\verb|set| $s$\ \verb|:=|\ $
\verb|(|r_{11}\verb|,|r_{12}\verb|,|\dots\verb|,|r_{1n}\verb|) |
\verb|(|r_{21}\verb|,|r_{22}\verb|,|\dots\verb|,|r_{2n}\verb|) |
\dots
\verb| (|r_{m1}\verb|,|r_{m2}\verb|,|\dots\verb|,|r_{mn}\verb|);|$

\verb|param| $p_1$\ \verb|default|\ $value$\ \verb|:=|

$\verb|   |
\verb|[|r_{11}\verb|,|r_{12}\verb|,|\dots\verb|,|r_{1n}\verb|] |a_{11}
\verb| [|r_{21}\verb|,|r_{22}\verb|,|\dots\verb|,|r_{2n}\verb|] |a_{21}
\verb| |\dots
\verb| [|r_{m1}\verb|,|r_{m2}\verb|,|\dots\verb|,|r_{mn}\verb|] |a_{m1}
\verb|;|
$

\verb|param| $p_2$\ \verb|default|\ $value$\ \verb|:=|

$\verb|   |
\verb|[|r_{11}\verb|,|r_{12}\verb|,|\dots\verb|,|r_{1n}\verb|] |a_{12}
\verb| [|r_{21}\verb|,|r_{22}\verb|,|\dots\verb|,|r_{2n}\verb|] |a_{22}
\verb| |\dots
\verb| [|r_{m1}\verb|,|r_{m2}\verb|,|\dots\verb|,|r_{mn}\verb|] |a_{m2}
\verb|;|
$

\verb|   |\dots\dots\dots

\verb|param| $p_r$\ \verb|default|\ $value$\ \verb|:=|

$\verb|   |
\verb|[|r_{11}\verb|,|r_{12}\verb|,|\dots\verb|,|r_{1n}\verb|] |a_{1r}
\verb| [|r_{21}\verb|,|r_{22}\verb|,|\dots\verb|,|r_{2n}\verb|] |a_{2r}
\verb| |\dots
\verb| [|r_{m1}\verb|,|r_{m2}\verb|,|\dots\verb|,|r_{mn}\verb|] |a_{mr}
\verb|;|
$

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\appendix

\newpage

\section{Using the MathProg translator with GLPK API}

The GLPK package includes the API routine \verb|lpx_read_model|, which
is a high-level interface to the GNU MathProg translator.

\paragraph{Synopsis}

\begin{verbatim}
#include "glpk.h"
LPX *lpx_read_model(char *model, char *data, char *output);
\end{verbatim}

\paragraph{Description}

The routine \verb|lpx_read_model| reads and translates LP/MIP model
(problem) written in the GNU MathProg modeling language.

The character string \verb|model| specifies name of input text file,
which contains model section and, optionally, data section. This
parameter cannot be \verb|NULL|.

The character string \verb|data| specifies name of input text file,
which contains data section. This parameter can be \verb|NULL|. (If the
data file is specified and the model file also contains data section,
that section is ignored and data section from the data file is used.)

The character string \verb|output| specifies name of output text file,
to which the output produced by display statements is written. If the
parameter output is \verb|NULL|, the display output is sent to stdout
via the routine \verb|print|.

\paragraph{Returns}

If no errors occurred, the routine returns a pointer to the created
problem object. Otherwise the routine sends diagnostics to the standard
output and returns \verb|NULL|.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage

\section{Solving models with the solver {\tt glpsol}}

The GLPK package includes the program {\tt glpsol} which is a
stand-alone LP/MIP solver. This program can be invoked from the command
line or from the shell to solve models written in the GNU MathProg
modeling language.

In order to tell the solver that the input file contains a model
description, the option \verb|--model| should be specified in the
command line. For example:

\begin{verbatim}
   glpsol --model foobar.mod
\end{verbatim}

Sometimes it is necessary to use the data section placed in another
file, in which case the following command may be used:

\begin{verbatim}
   glpsol --model foobar.mod --data foobar.dat
\end{verbatim}

\noindent
Note that if the model file also contains the data section, that
section is ignored.

If the model description contains some display statements, by default
the display output goes onto the screen (more precisely, onto the
standard output device). In order to redirect the display output to
a file the following command may be used:

\begin{verbatim}
   glpsol --model foobar.mod --display foobar.out
\end{verbatim}

If you need to look at the problem which has been generated by the model
translator, the option \verb|--wtxt| should be specified in the
command line as follows:

\begin{verbatim}
   glpsol --model foobar.mod --wtxt foobar.txt
\end{verbatim}

\noindent
in which case the problem will be written to the file \verb|foobar.txt|
in plain text format suitable for visual analysis.

Sometimes it is necessary merely to check the model description not
solving the generated problem. In this case the option \verb|--check|
should be given in the command line, for example:

\begin{verbatim}
   glpsol --check --model foobar.mod --wtxt foobar.txt
\end{verbatim}

In order to write a numeric solution obtained by the solver the
following command may be used

\begin{verbatim}
   glpsol --model foobar.mod --output foobar.sol
\end{verbatim}

\noindent
in which case the solution will be written to the file \verb|foobar.sol|
in plain text format.

Complete list of the {\tt glpsol} options can be found in the reference
manual included in the GLPK distribution.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage

\section{Example of model description}

\subsection{Model description written in GNU MathProg}

This is a complete example of model description written in the GNU
MathProg modeling language.

{\small
\begin{verbatim}
# A TRANSPORTATION PROBLEM
#
# This problem finds a least cost shipping schedule that meets
# requirements at markets and supplies at factories.
#
#  References:
#              Dantzig, G B., Linear Programming and Extensions
#              Princeton University Press, Princeton, New Jersey, 1963,
#              Chapter 3-3.

set I;
/* canning plants */

set J;
/* markets */

param a{i in I};
/* capacity of plant i in cases */

param b{j in J};
/* demand at market j in cases */

param d{i in I, j in J};
/* distance in thousands of miles */

param f;
/* freight in dollars per case per thousand miles */

param c{i in I, j in J} := f * d[i,j] / 1000;
/* transport cost in thousands of dollars per case */

var x{i in I, j in J} >= 0;
/* shipment quantities in cases */

minimize cost: sum{i in I, j in J} c[i,j] * x[i,j];
/* total transportation costs in thousands of dollars */

s.t. supply{i in I}: sum{j in J} x[i,j] <= a[i];
/* observe supply limit at plant i */

s.t. demand{j in J}: sum{i in I} x[i,j] >= b[j];
/* satisfy demand at market j */

data;

set I := Seattle San-Diego;

set J := New-York Chicago Topeka;
\end{verbatim}

\newpage

\begin{verbatim}
param a := Seattle     350
           San-Diego   600;

param b := New-York    325
           Chicago     300
           Topeka      275;

param d :              New-York   Chicago   Topeka :=
           Seattle     2.5        1.7       1.8
           San-Diego   2.5        1.8       1.4  ;

param f := 90;

end;
\end{verbatim}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Generated LP problem}

This is the LP problem that has been generated by the model translator
for the example model description.
{\small
\begin{verbatim}
Problem:    TRANSP
Class:      LP
Rows:       6
Columns:    6
Non-zeros:  18

*** OBJECTIVE FUNCTION ***

Minimize: cost
                 0.225 x[Seattle,New-York]
                 0.153 x[Seattle,Chicago]
                 0.162 x[Seattle,Topeka]
                 0.225 x[San-Diego,New-York]
                 0.162 x[San-Diego,Chicago]
                 0.126 x[San-Diego,Topeka]

*** ROWS (CONSTRAINTS) ***

Row 1: cost free
                 0.126 x[San-Diego,Topeka]
                 0.225 x[San-Diego,New-York]
                 0.153 x[Seattle,Chicago]
                 0.225 x[Seattle,New-York]
                 0.162 x[Seattle,Topeka]
                 0.162 x[San-Diego,Chicago]

Row 2: supply[Seattle] <= 350
                     1 x[Seattle,Chicago]
                     1 x[Seattle,New-York]
                     1 x[Seattle,Topeka]

Row 3: supply[San-Diego] <= 600
                     1 x[San-Diego,Chicago]
                     1 x[San-Diego,New-York]
                     1 x[San-Diego,Topeka]
\end{verbatim}

\newpage

\begin{verbatim}
Row 4: demand[New-York] >= 325
                     1 x[Seattle,New-York]
                     1 x[San-Diego,New-York]

Row 5: demand[Chicago] >= 300
                     1 x[Seattle,Chicago]
                     1 x[San-Diego,Chicago]

Row 6: demand[Topeka] >= 275
                     1 x[Seattle,Topeka]
                     1 x[San-Diego,Topeka]

*** COLUMNS (VARIABLES) ***

Col 1: x[Seattle,New-York] >= 0
                 0.225 (objective)
                 0.225 cost
                     1 supply[Seattle]
                     1 demand[New-York]

Col 2: x[Seattle,Chicago] >= 0
                 0.153 (objective)
                 0.153 cost
                     1 supply[Seattle]
                     1 demand[Chicago]

Col 3: x[Seattle,Topeka] >= 0
                 0.162 (objective)
                 0.162 cost
                     1 supply[Seattle]
                     1 demand[Topeka]

Col 4: x[San-Diego,New-York] >= 0
                 0.225 (objective)
                 0.225 cost
                     1 supply[San-Diego]
                     1 demand[New-York]

Col 5: x[San-Diego,Chicago] >= 0
                 0.162 (objective)
                 0.162 cost
                     1 supply[San-Diego]
                     1 demand[Chicago]

Col 6: x[San-Diego,Topeka] >= 0
                 0.126 (objective)
                 0.126 cost
                     1 supply[San-Diego]
                     1 demand[Topeka]

End of output
\end{verbatim}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Optimal solution of the generated LP problem}

This is the optimal solution of the generated LP problem that has been
found by the GLPK simplex solver.
{\small
\begin{verbatim}
Problem:    TRANSP
Rows:       6
Columns:    6
Non-zeros:  18
Status:     OPTIMAL
Objective:  cost = 153.675 (MINimum)

   No.   Row name   St   Activity     Lower bound   Upper bound    Marginal
------ ------------ -- ------------- ------------- ------------- -------------
     1 cost         B        153.675
     2 supply[Seattle]
                    B            300                         350
     3 supply[San-Diego]
                    NU           600                         600         < eps
     4 demand[New-York]
                    NL           325           325                       0.225
     5 demand[Chicago]
                    NL           300           300                       0.153
     6 demand[Topeka]
                    NL           275           275                       0.126

   No. Column name  St   Activity     Lower bound   Upper bound    Marginal
------ ------------ -- ------------- ------------- ------------- -------------
     1 x[Seattle,New-York]
                    B              0             0               
     2 x[Seattle,Chicago]
                    B            300             0               
     3 x[Seattle,Topeka]
                    NL             0             0                       0.036
     4 x[San-Diego,New-York]
                    B            325             0               
     5 x[San-Diego,Chicago]
                    NL             0             0                       0.009
     6 x[San-Diego,Topeka]
                    B            275             0

End of output
\end{verbatim}
}

\end{document}

%% eof %%
