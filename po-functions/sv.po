# Copyright (C) 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
# Richard Hult <rhult@codefactory.se>, 1999, 2000, 2001.
# Andreas Hyden <a.hyden@cyberpoint.se>, 2000.
# Christian Rose <menthos@menthos.com>, 2000, 2001, 2002.
# Jörgen Tegnér <jorgen.tegner@telia.com>, 2001.
# Jan Morén <jan.moren@lucs.lu.se>, 2002.
#
# $Id: sv.po,v 1.3 2005/08/30 00:52:54 jody Exp $
#
# Regler:
#
# * ' översätts med \"
#
# * Svenskt decimaltecken är komma (,), inte punkt (.) som i originalet.
#   Använd komma i översättningarna, för det gör Gnumeric. I
#   funktionsuttryck åtskiljs parametrarna med semikolon (;), inte komma
#   (,) som i originalet. Kom ihåg detta då exempel och
#   funktionsanrop översätts.
#
# * [Red] i formatkoderna är en färgkod och ska INTE översättas. Inte nu
#   heller.
#   Sluta då.
#   Sluta bråka.
#
# * Ta inte bort skräpsträngar från slutet (markerade med #~).
#
# * Skriv en kommentar över strängar du är osäker på: # FIXME: kommentar.
#
msgid ""
msgstr ""
"Project-Id-Version: gnumeric\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2011-02-09 11:12-0500\n"
"PO-Revision-Date: 2004-11-03 14:33+0900\n"
"Last-Translator: Jan Morén <jan.moren@lucs.lu.se>\n"
"Language-Team: Swedish <sv@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../plugins/fn-christian-date/functions.c:140
msgid ""
"EASTERSUNDAY:Easter Sunday in the Gregorian calendar according to the Roman "
"rite of the Christian Church"
msgstr ""

#: ../plugins/fn-christian-date/functions.c:142
msgid ""
"year:year between 1582 and 9956, defaults to the year of the next Easter "
"Sunday"
msgstr ""

#: ../plugins/fn-christian-date/functions.c:143
#: ../plugins/fn-christian-date/functions.c:166
#: ../plugins/fn-christian-date/functions.c:186
#: ../plugins/fn-christian-date/functions.c:205
#: ../plugins/fn-christian-date/functions.c:224
msgid ""
"Two digit years are adjusted as elsewhere in Gnumeric. Dates before 1904 may "
"also be prohibited."
msgstr ""

#: ../plugins/fn-christian-date/functions.c:146
msgid ""
"The 1-argument version of EASTERSUNDAY is compatible with OpenOffice for "
"years after 1904. This function is not specified in ODF/OpenFormula."
msgstr ""

#: ../plugins/fn-christian-date/functions.c:163
msgid ""
"ASHWEDNESDAY:Ash Wednesday in the Gregorian calendar according to the Roman "
"rite of the Christian Church"
msgstr ""

#: ../plugins/fn-christian-date/functions.c:165
msgid ""
"year:year between 1582 and 9956, defaults to the year of the next Ash "
"Wednesday"
msgstr ""

#: ../plugins/fn-christian-date/functions.c:183
msgid ""
"PENTECOSTSUNDAY:Pentecost Sunday in the Gregorian calendar according to the "
"Roman rite of the Christian Church"
msgstr ""

#: ../plugins/fn-christian-date/functions.c:185
msgid ""
"year:year between 1582 and 9956, defaults to the year of the next Pentecost "
"Sunday"
msgstr ""

#: ../plugins/fn-christian-date/functions.c:202
msgid ""
"GOODFRIDAY:Good Friday in the Gregorian calendar according to the Roman rite "
"of the Christian Church"
msgstr ""

#: ../plugins/fn-christian-date/functions.c:204
msgid ""
"year:year between 1582 and 9956, defaults to the year of the next Good Friday"
msgstr ""

#: ../plugins/fn-christian-date/functions.c:221
msgid ""
"ASCENSIONTHURSDAY:Ascension Thursday in the Gregorian calendar according to "
"the Roman rite of the Christian Church"
msgstr ""

#: ../plugins/fn-christian-date/functions.c:223
msgid ""
"year:year between 1582 and 9956, defaults to the year of the next Ascension "
"Thursday"
msgstr ""

#: ../plugins/fn-complex/functions.c:81
msgid "COMPLEX:a complex number of the form @{x} + @{y}@{i}"
msgstr ""

#: ../plugins/fn-complex/functions.c:82
msgid "x:real part"
msgstr ""

#: ../plugins/fn-complex/functions.c:83
msgid "y:imaginary part"
msgstr ""

#: ../plugins/fn-complex/functions.c:84
msgid ""
"i:the suffix for the complex number, either \"i\" or \"j\"; defaults to \"i\""
msgstr ""

#: ../plugins/fn-complex/functions.c:85
msgid "If @{i} is neither \"i\" nor \"j\", COMPLEX returns #VALUE!"
msgstr ""

#: ../plugins/fn-complex/functions.c:86 ../plugins/fn-complex/functions.c:114
#: ../plugins/fn-complex/functions.c:141 ../plugins/fn-complex/functions.c:165
#: ../plugins/fn-complex/functions.c:192 ../plugins/fn-complex/functions.c:263
#: ../plugins/fn-complex/functions.c:289 ../plugins/fn-complex/functions.c:394
#: ../plugins/fn-complex/functions.c:421 ../plugins/fn-complex/functions.c:447
#: ../plugins/fn-complex/functions.c:472 ../plugins/fn-complex/functions.c:499
#: ../plugins/fn-complex/functions.c:526 ../plugins/fn-complex/functions.c:561
#: ../plugins/fn-complex/functions.c:593
#: ../plugins/fn-complex/functions.c:1076
#: ../plugins/fn-complex/functions.c:1103
#: ../plugins/fn-complex/functions.c:1133
#: ../plugins/fn-complex/functions.c:1202 ../plugins/fn-date/functions.c:84
#: ../plugins/fn-date/functions.c:197 ../plugins/fn-date/functions.c:219
#: ../plugins/fn-date/functions.c:356 ../plugins/fn-date/functions.c:391
#: ../plugins/fn-date/functions.c:408 ../plugins/fn-date/functions.c:429
#: ../plugins/fn-date/functions.c:454 ../plugins/fn-date/functions.c:473
#: ../plugins/fn-date/functions.c:496 ../plugins/fn-date/functions.c:519
#: ../plugins/fn-date/functions.c:541 ../plugins/fn-date/functions.c:565
#: ../plugins/fn-date/functions.c:589 ../plugins/fn-date/functions.c:617
#: ../plugins/fn-date/functions.c:658 ../plugins/fn-date/functions.c:696
#: ../plugins/fn-eng/functions.c:238 ../plugins/fn-eng/functions.c:263
#: ../plugins/fn-eng/functions.c:287 ../plugins/fn-eng/functions.c:312
#: ../plugins/fn-eng/functions.c:336 ../plugins/fn-eng/functions.c:359
#: ../plugins/fn-eng/functions.c:403 ../plugins/fn-eng/functions.c:430
#: ../plugins/fn-eng/functions.c:453 ../plugins/fn-eng/functions.c:476
#: ../plugins/fn-eng/functions.c:499 ../plugins/fn-eng/functions.c:519
#: ../plugins/fn-eng/functions.c:608 ../plugins/fn-eng/functions.c:637
#: ../plugins/fn-eng/functions.c:1127 ../plugins/fn-eng/functions.c:1150
#: ../plugins/fn-info/functions.c:97 ../plugins/fn-info/functions.c:1285
#: ../plugins/fn-info/functions.c:1351 ../plugins/fn-info/functions.c:1440
#: ../plugins/fn-info/functions.c:1458 ../plugins/fn-info/functions.c:1480
#: ../plugins/fn-info/functions.c:1507 ../plugins/fn-info/functions.c:1534
#: ../plugins/fn-info/functions.c:1571 ../plugins/fn-info/functions.c:1587
#: ../plugins/fn-info/functions.c:1609 ../plugins/fn-info/functions.c:1626
#: ../plugins/fn-info/functions.c:1644 ../plugins/fn-info/functions.c:1661
#: ../plugins/fn-info/functions.c:1683 ../plugins/fn-info/functions.c:1703
#: ../plugins/fn-info/functions.c:1722 ../plugins/fn-info/functions.c:1759
#: ../plugins/fn-logical/functions.c:52 ../plugins/fn-logical/functions.c:103
#: ../plugins/fn-logical/functions.c:131 ../plugins/fn-logical/functions.c:269
#: ../plugins/fn-logical/functions.c:287 ../plugins/fn-math/functions.c:61
#: ../plugins/fn-math/functions.c:124 ../plugins/fn-math/functions.c:225
#: ../plugins/fn-math/functions.c:243 ../plugins/fn-math/functions.c:266
#: ../plugins/fn-math/functions.c:326 ../plugins/fn-math/functions.c:351
#: ../plugins/fn-math/functions.c:370 ../plugins/fn-math/functions.c:389
#: ../plugins/fn-math/functions.c:423 ../plugins/fn-math/functions.c:469
#: ../plugins/fn-math/functions.c:543 ../plugins/fn-math/functions.c:655
#: ../plugins/fn-math/functions.c:723 ../plugins/fn-math/functions.c:752
#: ../plugins/fn-math/functions.c:772 ../plugins/fn-math/functions.c:826
#: ../plugins/fn-math/functions.c:845 ../plugins/fn-math/functions.c:879
#: ../plugins/fn-math/functions.c:940 ../plugins/fn-math/functions.c:1018
#: ../plugins/fn-math/functions.c:1075 ../plugins/fn-math/functions.c:1108
#: ../plugins/fn-math/functions.c:1130 ../plugins/fn-math/functions.c:1158
#: ../plugins/fn-math/functions.c:1182 ../plugins/fn-math/functions.c:1208
#: ../plugins/fn-math/functions.c:1282 ../plugins/fn-math/functions.c:1325
#: ../plugins/fn-math/functions.c:1343 ../plugins/fn-math/functions.c:1440
#: ../plugins/fn-math/functions.c:1458 ../plugins/fn-math/functions.c:1505
#: ../plugins/fn-math/functions.c:1529 ../plugins/fn-math/functions.c:1575
#: ../plugins/fn-math/functions.c:1592 ../plugins/fn-math/functions.c:1627
#: ../plugins/fn-math/functions.c:1662 ../plugins/fn-math/functions.c:1697
#: ../plugins/fn-math/functions.c:1734 ../plugins/fn-math/functions.c:1813
#: ../plugins/fn-math/functions.c:1838 ../plugins/fn-math/functions.c:1864
#: ../plugins/fn-math/functions.c:1890 ../plugins/fn-math/functions.c:1914
#: ../plugins/fn-math/functions.c:1955 ../plugins/fn-math/functions.c:2000
#: ../plugins/fn-math/functions.c:2127 ../plugins/fn-math/functions.c:2375
#: ../plugins/fn-math/functions.c:2419 ../plugins/fn-math/functions.c:2462
#: ../plugins/fn-math/functions.c:2505 ../plugins/fn-math/functions.c:2562
#: ../plugins/fn-math/functions.c:2819 ../plugins/fn-math/functions.c:2886
#: ../plugins/fn-random/functions.c:48 ../plugins/fn-random/functions.c:249
#: ../plugins/fn-stat/functions.c:83 ../plugins/fn-stat/functions.c:111
#: ../plugins/fn-stat/functions.c:138 ../plugins/fn-stat/functions.c:166
#: ../plugins/fn-stat/functions.c:276 ../plugins/fn-stat/functions.c:324
#: ../plugins/fn-stat/functions.c:354 ../plugins/fn-stat/functions.c:387
#: ../plugins/fn-stat/functions.c:411 ../plugins/fn-stat/functions.c:436
#: ../plugins/fn-stat/functions.c:467 ../plugins/fn-stat/functions.c:496
#: ../plugins/fn-stat/functions.c:525 ../plugins/fn-stat/functions.c:545
#: ../plugins/fn-stat/functions.c:572 ../plugins/fn-stat/functions.c:599
#: ../plugins/fn-stat/functions.c:625 ../plugins/fn-stat/functions.c:661
#: ../plugins/fn-stat/functions.c:695 ../plugins/fn-stat/functions.c:721
#: ../plugins/fn-stat/functions.c:756 ../plugins/fn-stat/functions.c:796
#: ../plugins/fn-stat/functions.c:850 ../plugins/fn-stat/functions.c:918
#: ../plugins/fn-stat/functions.c:950 ../plugins/fn-stat/functions.c:980
#: ../plugins/fn-stat/functions.c:1007 ../plugins/fn-stat/functions.c:1037
#: ../plugins/fn-stat/functions.c:1125 ../plugins/fn-stat/functions.c:1162
#: ../plugins/fn-stat/functions.c:1245 ../plugins/fn-stat/functions.c:1282
#: ../plugins/fn-stat/functions.c:1448 ../plugins/fn-stat/functions.c:1480
#: ../plugins/fn-stat/functions.c:1576 ../plugins/fn-stat/functions.c:1603
#: ../plugins/fn-stat/functions.c:1633 ../plugins/fn-stat/functions.c:1668
#: ../plugins/fn-stat/functions.c:1695 ../plugins/fn-stat/functions.c:1727
#: ../plugins/fn-stat/functions.c:1759 ../plugins/fn-stat/functions.c:1791
#: ../plugins/fn-stat/functions.c:1824 ../plugins/fn-stat/functions.c:1874
#: ../plugins/fn-stat/functions.c:1899 ../plugins/fn-stat/functions.c:1924
#: ../plugins/fn-stat/functions.c:1956 ../plugins/fn-stat/functions.c:1985
#: ../plugins/fn-stat/functions.c:2004 ../plugins/fn-stat/functions.c:2030
#: ../plugins/fn-stat/functions.c:2152 ../plugins/fn-stat/functions.c:2195
#: ../plugins/fn-stat/functions.c:2244 ../plugins/fn-stat/functions.c:2324
#: ../plugins/fn-stat/functions.c:2382 ../plugins/fn-stat/functions.c:2441
#: ../plugins/fn-stat/functions.c:2466 ../plugins/fn-stat/functions.c:2493
#: ../plugins/fn-stat/functions.c:2525 ../plugins/fn-stat/functions.c:2552
#: ../plugins/fn-stat/functions.c:2582 ../plugins/fn-stat/functions.c:2609
#: ../plugins/fn-stat/functions.c:2733 ../plugins/fn-stat/functions.c:2776
#: ../plugins/fn-stat/functions.c:2817 ../plugins/fn-stat/functions.c:2883
#: ../plugins/fn-stat/functions.c:3052 ../plugins/fn-stat/functions.c:3916
#: ../plugins/fn-stat/functions.c:3973 ../plugins/fn-stat/functions.c:4021
#: ../plugins/fn-stat/functions.c:4086 ../plugins/fn-string/functions.c:68
#: ../plugins/fn-string/functions.c:140 ../plugins/fn-string/functions.c:202
#: ../plugins/fn-string/functions.c:221 ../plugins/fn-string/functions.c:238
#: ../plugins/fn-string/functions.c:258 ../plugins/fn-string/functions.c:322
#: ../plugins/fn-string/functions.c:342 ../plugins/fn-string/functions.c:469
#: ../plugins/fn-string/functions.c:538 ../plugins/fn-string/functions.c:558
#: ../plugins/fn-string/functions.c:580 ../plugins/fn-string/functions.c:624
#: ../plugins/fn-string/functions.c:655 ../plugins/fn-string/functions.c:693
#: ../plugins/fn-string/functions.c:750 ../plugins/fn-string/functions.c:796
#: ../plugins/fn-string/functions.c:897 ../plugins/fn-string/functions.c:921
#: ../plugins/fn-string/functions.c:974 ../plugins/fn-string/functions.c:1021
#: ../plugins/fn-string/functions.c:1117 ../plugins/fn-string/functions.c:1188
#: ../plugins/fn-string/functions.c:1271
msgid "This function is Excel compatible."
msgstr ""

#: ../plugins/fn-complex/functions.c:111
msgid "IMAGINARY:the imaginary part of the complex number @{z}"
msgstr ""

#: ../plugins/fn-complex/functions.c:112 ../plugins/fn-complex/functions.c:139
#: ../plugins/fn-complex/functions.c:163 ../plugins/fn-complex/functions.c:190
#: ../plugins/fn-complex/functions.c:215 ../plugins/fn-complex/functions.c:238
#: ../plugins/fn-complex/functions.c:261 ../plugins/fn-complex/functions.c:287
#: ../plugins/fn-complex/functions.c:313 ../plugins/fn-complex/functions.c:340
#: ../plugins/fn-complex/functions.c:366 ../plugins/fn-complex/functions.c:392
#: ../plugins/fn-complex/functions.c:418 ../plugins/fn-complex/functions.c:442
#: ../plugins/fn-complex/functions.c:470 ../plugins/fn-complex/functions.c:497
#: ../plugins/fn-complex/functions.c:591 ../plugins/fn-complex/functions.c:616
#: ../plugins/fn-complex/functions.c:640 ../plugins/fn-complex/functions.c:665
#: ../plugins/fn-complex/functions.c:690 ../plugins/fn-complex/functions.c:714
#: ../plugins/fn-complex/functions.c:739 ../plugins/fn-complex/functions.c:763
#: ../plugins/fn-complex/functions.c:790 ../plugins/fn-complex/functions.c:817
#: ../plugins/fn-complex/functions.c:844 ../plugins/fn-complex/functions.c:868
#: ../plugins/fn-complex/functions.c:893 ../plugins/fn-complex/functions.c:917
#: ../plugins/fn-complex/functions.c:944 ../plugins/fn-complex/functions.c:972
#: ../plugins/fn-complex/functions.c:1000
#: ../plugins/fn-complex/functions.c:1024
#: ../plugins/fn-complex/functions.c:1049
#: ../plugins/fn-complex/functions.c:1074
msgid "z:a complex number"
msgstr ""

#: ../plugins/fn-complex/functions.c:113 ../plugins/fn-complex/functions.c:140
#: ../plugins/fn-complex/functions.c:164 ../plugins/fn-complex/functions.c:191
#: ../plugins/fn-complex/functions.c:216 ../plugins/fn-complex/functions.c:239
#: ../plugins/fn-complex/functions.c:262 ../plugins/fn-complex/functions.c:288
#: ../plugins/fn-complex/functions.c:315 ../plugins/fn-complex/functions.c:342
#: ../plugins/fn-complex/functions.c:368 ../plugins/fn-complex/functions.c:393
#: ../plugins/fn-complex/functions.c:420 ../plugins/fn-complex/functions.c:446
#: ../plugins/fn-complex/functions.c:471 ../plugins/fn-complex/functions.c:498
#: ../plugins/fn-complex/functions.c:592 ../plugins/fn-complex/functions.c:617
#: ../plugins/fn-complex/functions.c:641 ../plugins/fn-complex/functions.c:666
#: ../plugins/fn-complex/functions.c:691 ../plugins/fn-complex/functions.c:715
#: ../plugins/fn-complex/functions.c:740 ../plugins/fn-complex/functions.c:766
#: ../plugins/fn-complex/functions.c:793 ../plugins/fn-complex/functions.c:820
#: ../plugins/fn-complex/functions.c:845 ../plugins/fn-complex/functions.c:869
#: ../plugins/fn-complex/functions.c:894 ../plugins/fn-complex/functions.c:920
#: ../plugins/fn-complex/functions.c:948 ../plugins/fn-complex/functions.c:976
#: ../plugins/fn-complex/functions.c:1001
#: ../plugins/fn-complex/functions.c:1025
#: ../plugins/fn-complex/functions.c:1050
#: ../plugins/fn-complex/functions.c:1075
msgid "If @{z} is not a valid complex number, #VALUE! is returned."
msgstr ""

#: ../plugins/fn-complex/functions.c:138
msgid "IMABS:the absolute value of the complex number @{z}"
msgstr ""

#: ../plugins/fn-complex/functions.c:162
msgid "IMREAL:the real part of the complex number @{z}"
msgstr ""

#: ../plugins/fn-complex/functions.c:189
msgid "IMCONJUGATE:the complex conjugate of the complex number @{z}"
msgstr ""

#: ../plugins/fn-complex/functions.c:214
msgid "IMINV:the reciprocal, or inverse, of the complex number @{z}"
msgstr ""

#: ../plugins/fn-complex/functions.c:237
msgid "IMNEG:the negative of the complex number @{z}"
msgstr ""

#: ../plugins/fn-complex/functions.c:260
msgid "IMCOS:the cosine of the complex number @{z}"
msgstr ""

#: ../plugins/fn-complex/functions.c:286
msgid "IMTAN:the tangent of the complex number @{z}"
msgstr ""

#: ../plugins/fn-complex/functions.c:312
msgid "IMSEC:the secant of the complex number @{z}"
msgstr ""

#: ../plugins/fn-complex/functions.c:314
msgid "secz = 1/cosz."
msgstr ""

#: ../plugins/fn-complex/functions.c:339
msgid "IMCSC:the cosecant of the complex number @{z}"
msgstr ""

#: ../plugins/fn-complex/functions.c:341
msgid "cscz = 1/sinz."
msgstr ""

#: ../plugins/fn-complex/functions.c:365
msgid "IMCOT:the cotangent of the complex number @{z}"
msgstr ""

#: ../plugins/fn-complex/functions.c:367
msgid "cotz = cosz/sinz."
msgstr ""

#: ../plugins/fn-complex/functions.c:391
msgid "IMEXP:the exponential of the complex number @{z}"
msgstr ""

#: ../plugins/fn-complex/functions.c:417
msgid "IMARGUMENT:the argument theta of the complex number @{z} "
msgstr ""

#: ../plugins/fn-complex/functions.c:419
msgid ""
"The argument theta of a complex number is its angle in radians from the real "
"axis."
msgstr ""

#: ../plugins/fn-complex/functions.c:441
msgid "IMLN:the natural logarithm of the complex number @{z}"
msgstr ""

#: ../plugins/fn-complex/functions.c:443
msgid ""
"The result will have an imaginary part between -π and +π.\n"
"The natural logarithm is not uniquely defined on complex numbers. You may "
"need to add or subtract an even multiple of π to the imaginary part."
msgstr ""

#: ../plugins/fn-complex/functions.c:469
msgid "IMLOG2:the base-2 logarithm of the complex number @{z}"
msgstr ""

#: ../plugins/fn-complex/functions.c:496
msgid "IMLOG10:the base-10 logarithm of the complex number @{z}"
msgstr ""

#: ../plugins/fn-complex/functions.c:522
msgid "IMPOWER:the complex number @{z1} raised to the @{z2}th power"
msgstr ""

#: ../plugins/fn-complex/functions.c:523 ../plugins/fn-complex/functions.c:558
#: ../plugins/fn-complex/functions.c:1100
#: ../plugins/fn-complex/functions.c:1130
#: ../plugins/fn-complex/functions.c:1199
msgid "z1:a complex number"
msgstr ""

#: ../plugins/fn-complex/functions.c:524 ../plugins/fn-complex/functions.c:559
#: ../plugins/fn-complex/functions.c:1101
#: ../plugins/fn-complex/functions.c:1131
#: ../plugins/fn-complex/functions.c:1200
msgid "z2:a complex number"
msgstr ""

#: ../plugins/fn-complex/functions.c:525 ../plugins/fn-complex/functions.c:560
#: ../plugins/fn-complex/functions.c:1102
msgid "If @{z1} or @{z2} is not a valid complex number, #VALUE! is returned."
msgstr ""

#: ../plugins/fn-complex/functions.c:557
msgid "IMDIV:the quotient of two complex numbers @{z1}/@{z2}"
msgstr ""

#: ../plugins/fn-complex/functions.c:590
msgid "IMSIN:the sine of the complex number @{z}"
msgstr ""

#: ../plugins/fn-complex/functions.c:615
msgid "IMSINH:the hyperbolic sine of the complex number @{z}"
msgstr ""

#: ../plugins/fn-complex/functions.c:639
msgid "IMCOSH:the hyperbolic cosine of the complex number @{z}"
msgstr ""

#: ../plugins/fn-complex/functions.c:664
msgid "IMTANH:the hyperbolic tangent of the complex number @{z}"
msgstr ""

#: ../plugins/fn-complex/functions.c:689
msgid "IMSECH:the hyperbolic secant of the complex number @{z}"
msgstr ""

#: ../plugins/fn-complex/functions.c:713
msgid "IMCSCH:the hyperbolic cosecant of the complex number @{z}"
msgstr ""

#: ../plugins/fn-complex/functions.c:738
msgid "IMCOTH:the hyperbolic cotangent of the complex number @{z}"
msgstr ""

#: ../plugins/fn-complex/functions.c:762
msgid "IMARCSIN:the complex arcsine of the complex number @{z}"
msgstr ""

#: ../plugins/fn-complex/functions.c:764
msgid ""
"IMARCSIN returns the complex arcsine of the complex number @{z}. The branch "
"cuts are on the real axis, less than -1 and greater than 1."
msgstr ""

#: ../plugins/fn-complex/functions.c:789
msgid "IMARCCOS:the complex arccosine of the complex number "
msgstr ""

#: ../plugins/fn-complex/functions.c:791
msgid ""
"IMARCCOS returns the complex arccosine of the complex number @{z}. The "
"branch cuts are on the real axis, less than -1 and greater than 1."
msgstr ""

#: ../plugins/fn-complex/functions.c:816
msgid "IMARCTAN:the complex arctangent of the complex number "
msgstr ""

#: ../plugins/fn-complex/functions.c:818
msgid ""
"IMARCTAN returns the complex arctangent of the complex number @{z}. The "
"branch cuts are on the imaginary axis, below -i and above i."
msgstr ""

#: ../plugins/fn-complex/functions.c:843
msgid "IMARCSEC:the complex arcsecant of the complex number @{z}"
msgstr ""

#: ../plugins/fn-complex/functions.c:867
msgid "IMARCCSC:the complex arccosecant of the complex number @{z}"
msgstr ""

#: ../plugins/fn-complex/functions.c:892
msgid "IMARCCOT:the complex arccotangent of the complex number @{z}"
msgstr ""

#: ../plugins/fn-complex/functions.c:916
msgid "IMARCSINH:the complex hyperbolic arcsine of the complex number @{z}"
msgstr ""

#: ../plugins/fn-complex/functions.c:918
msgid ""
"IMARCSINH returns the complex hyperbolic arcsine of the complex number @"
"{z}.  The branch cuts are on the imaginary axis, below -i and above i."
msgstr ""

#: ../plugins/fn-complex/functions.c:943
msgid "IMARCCOSH:the complex hyperbolic arccosine of the complex number @{z}"
msgstr ""

#: ../plugins/fn-complex/functions.c:945
msgid ""
"IMARCCOSH returns the complex hyperbolic arccosine of the complex number @"
"{z}. The branch cut is on the real axis, less than 1."
msgstr ""

#: ../plugins/fn-complex/functions.c:971
msgid "IMARCTANH:the complex hyperbolic arctangent of the complex number @{z}"
msgstr ""

#: ../plugins/fn-complex/functions.c:973
msgid ""
"IMARCTANH returns the complex hyperbolic arctangent of the complex number @"
"{z}. The branch cuts are on the real axis, less than -1 and greater than 1."
msgstr ""

#: ../plugins/fn-complex/functions.c:999
msgid "IMARCSECH:the complex hyperbolic arcsecant of the complex number @{z}"
msgstr ""

#: ../plugins/fn-complex/functions.c:1023
msgid "IMARCCSCH:the complex hyperbolic arccosecant of the complex number @{z}"
msgstr ""

#: ../plugins/fn-complex/functions.c:1048
msgid ""
"IMARCCOTH:the complex hyperbolic arccotangent of the complex number @{z}"
msgstr ""

#: ../plugins/fn-complex/functions.c:1073
msgid "IMSQRT:the square root of the complex number @{z}"
msgstr ""

#: ../plugins/fn-complex/functions.c:1099
msgid "IMSUB:the difference of two complex numbers"
msgstr ""

#: ../plugins/fn-complex/functions.c:1129
msgid "IMPRODUCT:the product of the given complex numbers"
msgstr ""

#: ../plugins/fn-complex/functions.c:1132
#: ../plugins/fn-complex/functions.c:1201
msgid ""
"If any of @{z1}, @{z2},... is not a valid complex number, #VALUE! is "
"returned."
msgstr ""

#: ../plugins/fn-complex/functions.c:1198
msgid "IMSUM:the sum of the given complex numbers"
msgstr ""

#: ../plugins/fn-database/functions.c:45
msgid ""
"database:a range in which rows of related information are records and "
"columns of data are fields"
msgstr ""

#: ../plugins/fn-database/functions.c:48
msgid "field:a string or integer specifying which field is to be used"
msgstr ""

#: ../plugins/fn-database/functions.c:50
msgid "criteria:a range containing conditions"
msgstr ""

#: ../plugins/fn-database/functions.c:52
msgid ""
"@{database} is a range in which rows of related information are records and "
"columns of data are fields. The first row of a database contains labels for "
"each column."
msgstr ""

#: ../plugins/fn-database/functions.c:57
msgid ""
"@{field} is a string or integer specifying which field is to be used. If @"
"{field} is an integer n then the nth column will be used. If @{field} is a "
"string, then the column with the matching label will be used."
msgstr ""

#: ../plugins/fn-database/functions.c:62
msgid ""
"@{criteria} is a range containing conditions. The first row of a @{criteria} "
"should contain labels. Each label specifies to which field the conditions "
"given in that column apply. Each cell below the label specifies a condition "
"such as \">3\" or \"<9\". An equality condition can be given by simply "
"specifying a value, e. g. \"3\" or \"Jody\". For a record to be considered "
"it must satisfy all conditions in at least one of the rows of @{criteria}."
msgstr ""

#: ../plugins/fn-database/functions.c:73
msgid ""
"Let us assume that the range A1:C7 contain the following values:\n"
"\n"
"Name    \tAge     \tSalary\n"
"John    \t34      \t54342\n"
"Bill    \t35      \t22343\n"
"Clark   \t29      \t34323\n"
"Bob     \t43      \t47242\n"
"Susan   \t37      \t42932\n"
"Jill    \t\t45      \t45324\n"
"\n"
"In addition, the cells A9:B11 contain the following values:\n"
"Age     \tSalary\n"
"<30\n"
">40     \t>46000\n"
msgstr ""

#: ../plugins/fn-database/functions.c:322
msgid ""
"DAVERAGE:average of the values in @{field} in @{database} belonging to "
"records that match @{criteria}"
msgstr ""

#: ../plugins/fn-database/functions.c:331
msgid "DAVERAGE(A1:C7, \"Salary\", A9:A11) equals 42296.3333."
msgstr ""

#: ../plugins/fn-database/functions.c:332
msgid "DAVERAGE(A1:C7, \"Age\", A9:A11) equals 39."
msgstr ""

#: ../plugins/fn-database/functions.c:333
msgid "DAVERAGE(A1:C7, \"Salary\", A9:B11) equals 40782.5."
msgstr ""

#: ../plugins/fn-database/functions.c:334
msgid "DAVERAGE(A1:C7, \"Age\", A9:B11) equals 36."
msgstr ""

#: ../plugins/fn-database/functions.c:358
msgid ""
"DCOUNT:count of numbers in @{field} in @{database} belonging to records that "
"match @{criteria}"
msgstr ""

#: ../plugins/fn-database/functions.c:367
msgid "DCOUNT(A1:C7, \"Salary\", A9:A11) equals 3."
msgstr ""

#: ../plugins/fn-database/functions.c:368
msgid "DCOUNT(A1:C7, \"Salary\", A9:B11) equals 2."
msgstr ""

#: ../plugins/fn-database/functions.c:369
msgid "DCOUNT(A1:C7, \"Name\", A9:B11) equals 0."
msgstr ""

#: ../plugins/fn-database/functions.c:393
msgid ""
"DCOUNTA:count of cells with data in @{field} in @{database} belonging to "
"records that match @{criteria}"
msgstr ""

#: ../plugins/fn-database/functions.c:402
msgid "DCOUNTA(A1:C7, \"Salary\", A9:A11) equals 3."
msgstr ""

#: ../plugins/fn-database/functions.c:403
msgid "DCOUNTA(A1:C7, \"Salary\", A9:B11) equals 2."
msgstr ""

#: ../plugins/fn-database/functions.c:404
msgid "DCOUNTA(A1:C7, \"Name\", A9:B11) equals 2."
msgstr ""

#: ../plugins/fn-database/functions.c:425
msgid ""
"DGET:a value from @{field} in @{database} belonging to records that match @"
"{criteria}"
msgstr ""

#: ../plugins/fn-database/functions.c:434
msgid "If none of the records match the conditions, DGET returns #VALUE!"
msgstr ""

#: ../plugins/fn-database/functions.c:435
msgid "If more than one record match the conditions, DGET returns #NUM!"
msgstr ""

#: ../plugins/fn-database/functions.c:436
msgid "DGET(A1:C7, \"Salary\", A9:A10) equals 34323."
msgstr ""

#: ../plugins/fn-database/functions.c:437
msgid "DGET(A1:C7, \"Name\", A9:A10) equals \"Clark\"."
msgstr ""

#: ../plugins/fn-database/functions.c:466
msgid ""
"DMAX:largest number in @{field} in @{database} belonging to a record that "
"match @{criteria}"
msgstr ""

#: ../plugins/fn-database/functions.c:475
msgid "DMAX(A1:C7, \"Salary\", A9:A11) equals 47242."
msgstr ""

#: ../plugins/fn-database/functions.c:476
msgid "DMAX(A1:C7, \"Age\", A9:A11) equals 45."
msgstr ""

#: ../plugins/fn-database/functions.c:477
msgid "DMAX(A1:C7, \"Age\", A9:B11) equals 43."
msgstr ""

#: ../plugins/fn-database/functions.c:502
msgid ""
"DMIN:smallest number in @{field} in @{database} belonging to a record that "
"match @{criteria}"
msgstr ""

#: ../plugins/fn-database/functions.c:511
msgid "DMIN(A1:C7, \"Salary\", A9:B11) equals 34323."
msgstr ""

#: ../plugins/fn-database/functions.c:512
msgid "DMIN(A1:C7, \"Age\", A9:B11) equals 29."
msgstr ""

#: ../plugins/fn-database/functions.c:535
msgid ""
"DPRODUCT:product of all values in @{field} in @{database} belonging to "
"records that match @{criteria}"
msgstr ""

#: ../plugins/fn-database/functions.c:544
msgid "DPRODUCT(A1:C7, \"Age\", A9:B11) equals 1247."
msgstr ""

#: ../plugins/fn-database/functions.c:568
msgid ""
"DSTDEV:sample standard deviation of the values in @{field} in @{database} "
"belonging to records that match @{criteria}"
msgstr ""

#: ../plugins/fn-database/functions.c:577
msgid "DSTDEV(A1:C7, \"Age\", A9:B11) equals 9.89949."
msgstr ""

#: ../plugins/fn-database/functions.c:578
msgid "DSTDEV(A1:C7, \"Salary\", A9:B11) equals 9135.112506."
msgstr ""

#: ../plugins/fn-database/functions.c:601
msgid ""
"DSTDEVP:standard deviation of the population of values in @{field} in @"
"{database} belonging to records that match @{criteria}"
msgstr ""

#: ../plugins/fn-database/functions.c:611
msgid "DSTDEVP(A1:C7, \"Age\", A9:B11) equals 7."
msgstr ""

#: ../plugins/fn-database/functions.c:612
msgid "DSTDEVP(A1:C7, \"Salary\", A9:B11) equals 6459.5."
msgstr ""

#: ../plugins/fn-database/functions.c:635
msgid ""
"DSUM:sum of the values in @{field} in @{database} belonging to records that "
"match @{criteria}"
msgstr ""

#: ../plugins/fn-database/functions.c:644
msgid "DSUM(A1:C7, \"Age\", A9:B11) equals 72."
msgstr ""

#: ../plugins/fn-database/functions.c:645
msgid "DSUM(A1:C7, \"Salary\", A9:B11) equals 81565."
msgstr ""

#: ../plugins/fn-database/functions.c:669
msgid ""
"DVAR:sample variance of the values in @{field} in @{database} belonging to "
"records that match @{criteria}"
msgstr ""

#: ../plugins/fn-database/functions.c:678
msgid "DVAR(A1:C7, \"Age\", A9:B11) equals 98."
msgstr ""

#: ../plugins/fn-database/functions.c:679
msgid "DVAR(A1:C7, \"Salary\", A9:B11) equals 83450280.5."
msgstr ""

#: ../plugins/fn-database/functions.c:702
msgid ""
"DVARP:variance of the population of values in @{field} in @{database} "
"belonging to records that match @{criteria}"
msgstr ""

#: ../plugins/fn-database/functions.c:712
msgid "DVARP(A1:C7, \"Age\", A9:B11) equals 49."
msgstr ""

#: ../plugins/fn-database/functions.c:713
msgid "DVARP(A1:C7, \"Salary\", A9:B11) equals 41725140.25."
msgstr ""

#: ../plugins/fn-database/functions.c:736
msgid "GETPIVOTDATA:summary data from a pivot table"
msgstr ""

#: ../plugins/fn-database/functions.c:737
msgid "pivot_table:cell range containing the pivot table"
msgstr ""

#: ../plugins/fn-database/functions.c:738
msgid "field_name:name of the field for which the summary data is requested"
msgstr ""

#: ../plugins/fn-database/functions.c:739
msgid "If the summary data is unavailable, GETPIVOTDATA returns #REF!"
msgstr ""

#: ../plugins/fn-date/functions.c:74
msgid "DATE:create a date serial value"
msgstr ""

#: ../plugins/fn-date/functions.c:75
msgid "year:year of date"
msgstr ""

#: ../plugins/fn-date/functions.c:76
msgid "month:month of year"
msgstr ""

#: ../plugins/fn-date/functions.c:77
msgid "day:day of month"
msgstr ""

#: ../plugins/fn-date/functions.c:78
msgid ""
"The DATE function creates date serial values.  1-Jan-1900 is serial value 1, "
"2-Jan-1900 is serial value 2, and so on.  For compatibility reasons, a "
"serial value is reserved for the non-existing date 29-Feb-1900."
msgstr ""

#: ../plugins/fn-date/functions.c:79
msgid ""
"If @{month} or @{day} is less than 1 or too big, then the year and/or month "
"will be adjusted."
msgstr ""

#: ../plugins/fn-date/functions.c:80
msgid ""
"For spreadsheets created with the Mac version of Excel, serial 1 is 1-Jan-"
"1904."
msgstr ""

#: ../plugins/fn-date/functions.c:137
msgid "UNIX2DATE:date value corresponding to the Unix timestamp @{t}"
msgstr ""

#: ../plugins/fn-date/functions.c:138
msgid "t:Unix time stamp"
msgstr ""

#: ../plugins/fn-date/functions.c:139
msgid ""
"The UNIX2DATE function translates Unix timestamps into the corresponding "
"date.  A Unix timestamp is the number of seconds since midnight (0:00) of "
"January 1st, 1970 GMT."
msgstr ""

#: ../plugins/fn-date/functions.c:167
msgid "DATE2UNIX:the Unix timestamp corresponding to a date @{d}"
msgstr ""

#: ../plugins/fn-date/functions.c:168
msgid "d:date"
msgstr ""

#: ../plugins/fn-date/functions.c:169
msgid ""
"The DATE2UNIX function translates a date into a Unix timestamp. A Unix "
"timestamp is the number of seconds since midnight (0:00) of January 1st, "
"1970 GMT."
msgstr ""

#: ../plugins/fn-date/functions.c:193
msgid "DATEVALUE:the date part of a date and time serial value"
msgstr ""

#: ../plugins/fn-date/functions.c:194 ../plugins/fn-date/functions.c:451
msgid "serial:date and time serial value"
msgstr ""

#: ../plugins/fn-date/functions.c:195
msgid ""
"DATEVALUE returns the date serial value part of a date and time serial value."
msgstr ""

#: ../plugins/fn-date/functions.c:211
msgid "DATEDIF:difference between dates"
msgstr ""

#: ../plugins/fn-date/functions.c:212 ../plugins/fn-date/functions.c:651
#: ../plugins/fn-date/functions.c:956 ../plugins/fn-date/functions.c:1222
#: ../plugins/fn-date/functions.c:1251
msgid "start_date:starting date serial value"
msgstr ""

#: ../plugins/fn-date/functions.c:213 ../plugins/fn-date/functions.c:652
#: ../plugins/fn-date/functions.c:957 ../plugins/fn-date/functions.c:1223
#: ../plugins/fn-date/functions.c:1252
msgid "end_date:ending date serial value"
msgstr ""

#: ../plugins/fn-date/functions.c:214
msgid "interval:counting unit"
msgstr ""

#: ../plugins/fn-date/functions.c:215
msgid ""
"DATEDIF returns the distance from @{start_date} to @{end_date} according to "
"the unit specified by @{interval}."
msgstr ""

#: ../plugins/fn-date/functions.c:216
msgid ""
"If @{interval} is \"y\", \"m\", or \"d\" then the distance is measured in "
"complete years, months, or days respectively."
msgstr ""

#: ../plugins/fn-date/functions.c:217
msgid ""
"If @{interval} is \"ym\" or \"yd\" then the distance is measured in complete "
"months or days, respectively, but excluding any difference in years."
msgstr ""

#: ../plugins/fn-date/functions.c:218
msgid ""
"If @{interval} is \"md\" then the distance is measured in complete days but "
"excluding any difference in months."
msgstr ""

#: ../plugins/fn-date/functions.c:352
msgid "EDATE:adjust a date by a number of months"
msgstr ""

#: ../plugins/fn-date/functions.c:353 ../plugins/fn-date/functions.c:539
#: ../plugins/fn-date/functions.c:563 ../plugins/fn-date/functions.c:587
#: ../plugins/fn-date/functions.c:611 ../plugins/fn-date/functions.c:693
#: ../plugins/fn-date/functions.c:733 ../plugins/fn-date/functions.c:1123
#: ../plugins/fn-date/functions.c:1147 ../plugins/fn-date/functions.c:1183
msgid "date:date serial value"
msgstr ""

#: ../plugins/fn-date/functions.c:354 ../plugins/fn-date/functions.c:694
msgid "months:signed number of months"
msgstr ""

#: ../plugins/fn-date/functions.c:355
msgid ""
"EDATE returns @{date} moved forward or backward the number of months "
"specified by @{months}."
msgstr ""

#: ../plugins/fn-date/functions.c:389
msgid "TODAY:the date serial value of today"
msgstr ""

#: ../plugins/fn-date/functions.c:390
msgid ""
"The TODAY function returns the date serial value of the day it is computed.  "
"Recomputing on a later date will produce a different value."
msgstr ""

#: ../plugins/fn-date/functions.c:406
msgid "NOW:the date and time serial value of the current time"
msgstr ""

#: ../plugins/fn-date/functions.c:407
msgid ""
"The NOW function returns the date and time serial value of the moment it is "
"computed.  Recomputing later will produce a different value."
msgstr ""

#: ../plugins/fn-date/functions.c:423
msgid "TIME:create a time serial value"
msgstr ""

#: ../plugins/fn-date/functions.c:424
msgid "hour:hour of the day"
msgstr ""

#: ../plugins/fn-date/functions.c:425
msgid "minute:minute within the hour"
msgstr ""

#: ../plugins/fn-date/functions.c:426
msgid "second:second within the minute"
msgstr ""

#: ../plugins/fn-date/functions.c:427
msgid ""
"The TIME function computes the fractional day between midnight at the time "
"given by @{hour}, @{minute}, and @{second}."
msgstr ""

#: ../plugins/fn-date/functions.c:450
msgid "TIMEVALUE:the time part of a date and time serial value"
msgstr ""

#: ../plugins/fn-date/functions.c:452
msgid "TIMEVALUE returns the time-of-day part of a date and time serial value."
msgstr ""

#: ../plugins/fn-date/functions.c:469
msgid "HOUR:compute hour part of fractional day"
msgstr ""

#: ../plugins/fn-date/functions.c:470 ../plugins/fn-date/functions.c:493
#: ../plugins/fn-date/functions.c:516
msgid "time:time of day as fractional day"
msgstr ""

#: ../plugins/fn-date/functions.c:471
msgid ""
"The HOUR function computes the hour part of the fractional day given by @"
"{time}."
msgstr ""

#: ../plugins/fn-date/functions.c:492
msgid "MINUTE:compute minute part of fractional day"
msgstr ""

#: ../plugins/fn-date/functions.c:494
msgid ""
"The MINUTE function computes the minute part of the fractional day given by @"
"{time}."
msgstr ""

#: ../plugins/fn-date/functions.c:515
msgid "SECOND:compute seconds part of fractional day"
msgstr ""

#: ../plugins/fn-date/functions.c:517
msgid ""
"The SECOND function computes the seconds part of the fractional day given by "
"@{time}."
msgstr ""

#: ../plugins/fn-date/functions.c:538
msgid "YEAR:the year part of a date serial value"
msgstr ""

#: ../plugins/fn-date/functions.c:540
msgid "The YEAR function returns the year part of @{date}."
msgstr ""

#: ../plugins/fn-date/functions.c:562
msgid "MONTH:the month part of a date serial value"
msgstr ""

#: ../plugins/fn-date/functions.c:564
msgid "The MONTH function returns the month part of @{date}."
msgstr ""

#: ../plugins/fn-date/functions.c:586
msgid "DAY:the day-of-month part of a date serial value"
msgstr ""

#: ../plugins/fn-date/functions.c:588
msgid "The DAY function returns the day-of-month part of @{date}."
msgstr ""

#: ../plugins/fn-date/functions.c:610
msgid "WEEKDAY:day-of-week"
msgstr ""

#: ../plugins/fn-date/functions.c:612 ../plugins/fn-date/functions.c:1184
msgid "method:numbering system, defaults to 1"
msgstr ""

#: ../plugins/fn-date/functions.c:613
msgid ""
"The WEEKDAY function returns the day-of-week of @{date}.  The value of @"
"{method} determines how days are numbered; it defaults to 1. "
msgstr ""

#: ../plugins/fn-date/functions.c:614
msgid "If @{method} is 1, then Sunday is 1, Monday is 2, etc."
msgstr ""

#: ../plugins/fn-date/functions.c:615
msgid "If @{method} is 2, then Monday is 1, Tuesday is 2, etc."
msgstr ""

#: ../plugins/fn-date/functions.c:616
msgid "If @{method} is 3, then Monday is 0, Tuesday is 1, etc."
msgstr ""

#: ../plugins/fn-date/functions.c:650
msgid "DAYS360:days between dates"
msgstr ""

#: ../plugins/fn-date/functions.c:653
msgid "method:counting method"
msgstr ""

#: ../plugins/fn-date/functions.c:654
msgid "DAYS360 returns the number of days from @{start_date} to @{end_date}."
msgstr ""

#: ../plugins/fn-date/functions.c:655
msgid ""
"If @{method} is 0, the default, the MS Excel (tm) US method will be used. "
"This is a somewhat complicated industry standard method where the last day "
"of February is considered to be the 30th day of the month, but only for @"
"{start_date}."
msgstr ""

#: ../plugins/fn-date/functions.c:656
msgid ""
"If @{method} is 1, the European method will be used.  In this case, if the "
"day of the month is 31 it will be considered as 30"
msgstr ""

#: ../plugins/fn-date/functions.c:657
msgid ""
"If @{method} is 2, a saner version of the US method is used in which both "
"dates get the same February treatment."
msgstr ""

#: ../plugins/fn-date/functions.c:692
msgid "EOMONTH:end of month"
msgstr ""

#: ../plugins/fn-date/functions.c:695
msgid ""
"EOMONTH returns the date serial value of the end of the month specified by @"
"{date} adjusted forward or backward the number of months specified by @"
"{months}."
msgstr ""

#: ../plugins/fn-date/functions.c:732
msgid "WORKDAY:add working days"
msgstr ""

#: ../plugins/fn-date/functions.c:734
msgid "days:number of days to add"
msgstr ""

#: ../plugins/fn-date/functions.c:735 ../plugins/fn-date/functions.c:958
msgid "holidays:array of holidays"
msgstr ""

#: ../plugins/fn-date/functions.c:736 ../plugins/fn-date/functions.c:959
msgid ""
"weekend:array of 0s and 1s, indicating whether a weekday (S, M, T, W, T, F, "
"S) is on the weekend, defaults to {1,0,0,0,0,0,1}"
msgstr ""

#: ../plugins/fn-date/functions.c:738
msgid ""
"WORKDAY adjusts @{date} by @{days} skipping over weekends and @{holidays} in "
"the process."
msgstr ""

#: ../plugins/fn-date/functions.c:739
msgid "@{days} may be negative."
msgstr ""

#: ../plugins/fn-date/functions.c:740 ../plugins/fn-date/functions.c:962
msgid ""
"If an entry of @{weekend} is non-zero, the corresponding weekday is not a "
"work day."
msgstr ""

#: ../plugins/fn-date/functions.c:741 ../plugins/fn-date/functions.c:963
msgid "This function is Excel compatible if the last argument is omitted."
msgstr ""

#: ../plugins/fn-date/functions.c:742 ../plugins/fn-date/functions.c:964
#: ../plugins/fn-date/functions.c:1254 ../plugins/fn-eng/functions.c:213
#: ../plugins/fn-eng/functions.c:380 ../plugins/fn-eng/functions.c:748
#: ../plugins/fn-financial/functions.c:1312 ../plugins/fn-math/functions.c:424
#: ../plugins/fn-math/functions.c:1019 ../plugins/fn-math/functions.c:1046
#: ../plugins/fn-math/functions.c:1363 ../plugins/fn-math/functions.c:1383
#: ../plugins/fn-math/functions.c:2048 ../plugins/fn-math/functions.c:2781
#: ../plugins/fn-stat/functions.c:1515 ../plugins/fn-stat/functions.c:2383
#: ../plugins/fn-stat/functions.c:4512 ../plugins/fn-string/functions.c:259
#: ../plugins/fn-string/functions.c:343 ../plugins/fn-string/functions.c:470
#: ../plugins/fn-string/functions.c:1058 ../plugins/fn-string/functions.c:1400
#: ../plugins/fn-string/functions.c:1530
msgid "This function is OpenFormula compatible."
msgstr ""

#: ../plugins/fn-date/functions.c:955
msgid "NETWORKDAYS:number of workdays in range"
msgstr ""

#: ../plugins/fn-date/functions.c:961
msgid ""
"NETWORKDAYS calculates the number of days from @{start_date} to @{end_date} "
"skipping weekends and @{holidays} in the process."
msgstr ""

#: ../plugins/fn-date/functions.c:1122
msgid "ISOWEEKNUM:ISO week number"
msgstr ""

#: ../plugins/fn-date/functions.c:1124
msgid ""
"ISOWEEKNUM calculates the week number according to the ISO 8601 standard.  "
"Weeks start on Mondays and week 1 contains the first Thursday of the year."
msgstr ""

#: ../plugins/fn-date/functions.c:1125 ../plugins/fn-date/functions.c:1149
msgid ""
"January 1 of a year is sometimes in week 52 or 53 of the previous year.  "
"Similarly, December 31 is sometimes in week 1 of the following year."
msgstr ""

#: ../plugins/fn-date/functions.c:1146
msgid "ISOYEAR:year corresponding to the ISO week number"
msgstr ""

#: ../plugins/fn-date/functions.c:1148
msgid ""
"ISOYEAR calculates the year to go with week number according to the ISO 8601 "
"standard."
msgstr ""

#: ../plugins/fn-date/functions.c:1182
msgid "WEEKNUM:week number"
msgstr ""

#: ../plugins/fn-date/functions.c:1185
msgid ""
"WEEKNUM calculates the week number according to @{method} which defaults to "
"1."
msgstr ""

#: ../plugins/fn-date/functions.c:1186
msgid ""
"If @{method} is 1, then weeks start on Sundays and January 1 is in week 1."
msgstr ""

#: ../plugins/fn-date/functions.c:1187
msgid ""
"If @{method} is 2, then weeks start on Mondays and January 1 is in week 1."
msgstr ""

#: ../plugins/fn-date/functions.c:1188
msgid "If @{method} is 150, then the ISO 8601 numbering is used."
msgstr ""

#: ../plugins/fn-date/functions.c:1221
msgid "YEARFRAC:fractional number of years between dates"
msgstr ""

#: ../plugins/fn-date/functions.c:1224 ../plugins/fn-financial/functions.c:454
#: ../plugins/fn-financial/functions.c:492
#: ../plugins/fn-financial/functions.c:530
#: ../plugins/fn-financial/functions.c:571
#: ../plugins/fn-financial/functions.c:608
#: ../plugins/fn-financial/functions.c:652
#: ../plugins/fn-financial/functions.c:1895
#: ../plugins/fn-financial/functions.c:2258
#: ../plugins/fn-financial/functions.c:2308
#: ../plugins/fn-financial/functions.c:2415
#: ../plugins/fn-financial/functions.c:2461
#: ../plugins/fn-financial/functions.c:2503
#: ../plugins/fn-financial/functions.c:2653
#: ../plugins/fn-financial/functions.c:2748
#: ../plugins/fn-financial/functions.c:2826
#: ../plugins/fn-financial/functions.c:2903
#: ../plugins/fn-financial/functions.c:2959
#: ../plugins/fn-financial/functions.c:3002
#: ../plugins/fn-financial/functions.c:3026
#: ../plugins/fn-financial/functions.c:3050
#: ../plugins/fn-financial/functions.c:3074
#: ../plugins/fn-financial/functions.c:3100
#: ../plugins/fn-financial/functions.c:3126
#: ../plugins/fn-financial/functions.c:3240
msgid "basis:calendar basis"
msgstr ""

#: ../plugins/fn-date/functions.c:1225
msgid ""
"YEARFRAC calculates the number of days from @{start_date} to @{end_date} "
"according to the calendar specified by @{basis}, which defaults to 0, and "
"expresses the result as a fractional number of years."
msgstr ""

#: ../plugins/fn-date/functions.c:1250
msgid "DAYS:difference between dates in days"
msgstr ""

#: ../plugins/fn-date/functions.c:1253
msgid ""
"DAYS returns the positive or negative number of days from @{start_date} to @"
"{end_date}."
msgstr ""

#. Some common decriptors
#: ../plugins/fn-derivatives/options.c:46
msgid "call_put_flag:'c' for a call and 'p' for a put"
msgstr ""

#: ../plugins/fn-derivatives/options.c:47
msgid "spot:spot price"
msgstr ""

#: ../plugins/fn-derivatives/options.c:48
msgid "strike:strike price"
msgstr ""

#: ../plugins/fn-derivatives/options.c:49
msgid "time:time to maturity in years"
msgstr ""

#: ../plugins/fn-derivatives/options.c:50
msgid "time:time to maturity in days"
msgstr ""

#: ../plugins/fn-derivatives/options.c:51
msgid "time_payout:time to dividend payout"
msgstr ""

#: ../plugins/fn-derivatives/options.c:52
msgid "time_exp:time to expiration"
msgstr ""

#: ../plugins/fn-derivatives/options.c:53
msgid "rate:risk-free interest rate to the exercise date in percent"
msgstr ""

#: ../plugins/fn-derivatives/options.c:54
msgid "rate:annualized interest rate"
msgstr ""

#: ../plugins/fn-derivatives/options.c:55
msgid "rate:annualized risk-free interest rate"
msgstr ""

#: ../plugins/fn-derivatives/options.c:56
msgid ""
"volatility:annualized volatility of the asset in percent for the period "
"through to the exercise date"
msgstr ""

#: ../plugins/fn-derivatives/options.c:57
msgid "volatility:annualized volatility of the asset"
msgstr ""

#: ../plugins/fn-derivatives/options.c:58
msgid "d:amount of the dividend to be paid expressed in currency"
msgstr ""

#: ../plugins/fn-derivatives/options.c:59
msgid ""
"cost_of_carry:net cost of holding the underlying asset (for common stocks, "
"the risk free rate less the dividend yield), defaults to 0"
msgstr ""

#: ../plugins/fn-derivatives/options.c:60
msgid "cost_of_carry:net cost of holding the underlying asset"
msgstr ""

#: ../plugins/fn-derivatives/options.c:62
msgid ""
"The returned value will be expressed in the same units as @{strike} and @"
"{spot}."
msgstr ""

#: ../plugins/fn-derivatives/options.c:192
msgid "CUM_BIV_NORM_DIST:cumulative bivariate normal distribution"
msgstr ""

#: ../plugins/fn-derivatives/options.c:193
msgid "a:limit for first random variable"
msgstr ""

#: ../plugins/fn-derivatives/options.c:194
msgid "b:limit for second random variable"
msgstr ""

#: ../plugins/fn-derivatives/options.c:195
msgid "rho:correlation of the two random variables"
msgstr ""

#: ../plugins/fn-derivatives/options.c:196
msgid ""
"CUM_BIV_NORM_DIST calculates the probability that two standard normal "
"distributed random variables with correlation @{rho} are respectively each "
"less than @{a} and @{b}."
msgstr ""

#: ../plugins/fn-derivatives/options.c:245
msgid "OPT_BS:price of a European option"
msgstr ""

#: ../plugins/fn-derivatives/options.c:253
msgid ""
"OPT_BS uses the Black-Scholes model to calculate the price of a European "
"option struck at @{strike} on an asset with spot price @{spot}."
msgstr ""

#: ../plugins/fn-derivatives/options.c:302
msgid "OPT_BS_DELTA:delta of a European option"
msgstr ""

#: ../plugins/fn-derivatives/options.c:310
msgid ""
"OPT_BS_DELTA uses the Black-Scholes model to calculate the 'delta' of a "
"European option struck at @{strike} on an asset with spot price @{spot}."
msgstr ""

#: ../plugins/fn-derivatives/options.c:344
msgid "OPT_BS_GAMMA:gamma of a European option"
msgstr ""

#: ../plugins/fn-derivatives/options.c:351
msgid ""
"OPT_BS_GAMMA uses the Black-Scholes model to calculate the 'gamma' of a "
"European option struck at @{strike} on an asset with spot price @{spot}. The "
"gamma of an option is the second derivative of its price with respect to the "
"price of the underlying asset."
msgstr ""

#: ../plugins/fn-derivatives/options.c:356
msgid ""
"Gamma is expressed as the rate of change of delta per unit change in @{spot}."
msgstr ""

#: ../plugins/fn-derivatives/options.c:358
msgid "Gamma is the same for calls and puts."
msgstr ""

#: ../plugins/fn-derivatives/options.c:401
msgid "OPT_BS_THETA:theta of a European option"
msgstr ""

#: ../plugins/fn-derivatives/options.c:409
msgid ""
"OPT_BS_THETA uses the Black-Scholes model to calculate the 'theta' of a "
"European option struck at @{strike} on an asset with spot price @{spot}. The "
"theta of an option is the rate of change of its price with respect to time "
"to expiry."
msgstr ""

#: ../plugins/fn-derivatives/options.c:414
msgid ""
"Theta is expressed as the negative of the rate of change of the option "
"value, per 365.25 days."
msgstr ""

#: ../plugins/fn-derivatives/options.c:445
msgid "OPT_BS_VEGA:vega of a European option"
msgstr ""

#: ../plugins/fn-derivatives/options.c:452
msgid ""
"OPT_BS_VEGA uses the Black-Scholes model to calculate the 'vega' of a "
"European option struck at @{strike} on an asset with spot price @{spot}. The "
"vega of an option is the rate of change of its price with respect to "
"volatility."
msgstr ""

#: ../plugins/fn-derivatives/options.c:457
msgid "Vega is the same for calls and puts."
msgstr ""

#: ../plugins/fn-derivatives/options.c:459
#, no-c-format
msgid ""
"Vega is expressed as the rate of change of option value, per 100% volatility."
msgstr ""

#: ../plugins/fn-derivatives/options.c:510
msgid "OPT_BS_RHO:rho of a European option"
msgstr ""

#: ../plugins/fn-derivatives/options.c:518
msgid ""
"OPT_BS_RHO uses the Black-Scholes model to calculate the 'rho' of a European "
"option struck at @{strike} on an asset with spot price @{spot}. The rho of "
"an option is the rate of change of its price with respect to the risk free "
"interest rate."
msgstr ""

#: ../plugins/fn-derivatives/options.c:524
#, no-c-format
msgid ""
"Rho is expressed as the rate of change of the option value, per 100% change "
"in @{rate}."
msgstr ""

#: ../plugins/fn-derivatives/options.c:566
msgid "OPT_BS_CARRYCOST:elasticity of a European option"
msgstr ""

#: ../plugins/fn-derivatives/options.c:574
msgid ""
"OPT_BS_CARRYCOST uses the Black-Scholes model to calculate the 'elasticity' "
"of a European option struck at @{strike} on an asset with spot price @"
"{spot}. The elasticity of an option is the rate of change of its price with "
"respect to its @{cost_of_carry}."
msgstr ""

#: ../plugins/fn-derivatives/options.c:580
#, no-c-format
msgid ""
"Elasticity is expressed as the rate of change of the option value, per 100% "
"volatility."
msgstr ""

#: ../plugins/fn-derivatives/options.c:624
msgid "OPT_GARMAN_KOHLHAGEN:theoretical price of a European currency option"
msgstr ""

#: ../plugins/fn-derivatives/options.c:628
msgid "time:number of days to exercise"
msgstr ""

#: ../plugins/fn-derivatives/options.c:629
msgid ""
"domestic_rate:domestic risk-free interest rate to the exercise date in "
"percent"
msgstr ""

#: ../plugins/fn-derivatives/options.c:630
msgid ""
"foreign_rate:foreign risk-free interest rate to the exercise date in percent"
msgstr ""

#: ../plugins/fn-derivatives/options.c:632
msgid ""
"OPT_GARMAN_KOHLHAGEN values the theoretical price of a European currency "
"option struck at @{strike} on an asset with spot price @{spot}."
msgstr ""

#: ../plugins/fn-derivatives/options.c:678
msgid ""
"OPT_FRENCH:theoretical price of a European option adjusted for trading day "
"volatility"
msgstr ""

#: ../plugins/fn-derivatives/options.c:682
msgid ""
"time:ratio of the number of calendar days to exercise and the number of "
"calendar days in the year"
msgstr ""

#: ../plugins/fn-derivatives/options.c:683
msgid ""
"ttime:ratio of the number of trading days to exercise and the number of "
"trading days in the year"
msgstr ""

#: ../plugins/fn-derivatives/options.c:687
msgid ""
"OPT_FRENCH values the theoretical price of a European option adjusted for "
"trading day volatility, struck at @{strike} on an asset with spot price @"
"{spot}."
msgstr ""

#: ../plugins/fn-derivatives/options.c:731
msgid ""
"OPT_JUMP_DIFF:theoretical price of an option according to the Jump Diffusion "
"process"
msgstr ""

#: ../plugins/fn-derivatives/options.c:736
msgid "rate:the annualized rate of interest"
msgstr ""

#: ../plugins/fn-derivatives/options.c:738
msgid "lambda:expected number of 'jumps' per year"
msgstr ""

#: ../plugins/fn-derivatives/options.c:739
msgid "gamma:proportion of volatility explained by the 'jumps'"
msgstr ""

#: ../plugins/fn-derivatives/options.c:740
msgid ""
"OPT_JUMP_DIFF models the theoretical price of an option according to the "
"Jump Diffusion process (Merton)."
msgstr ""

#: ../plugins/fn-derivatives/options.c:818
msgid ""
"OPT_MILTERSEN_SCHWARTZ:theoretical price of options on commodities futures "
"according to Miltersen & Schwartz"
msgstr ""

#: ../plugins/fn-derivatives/options.c:820
msgid "p_t:zero coupon bond with expiry at option maturity"
msgstr ""

#: ../plugins/fn-derivatives/options.c:821
msgid "f_t:futures price"
msgstr ""

#: ../plugins/fn-derivatives/options.c:823
msgid "t1:time to maturity of the option"
msgstr ""

#: ../plugins/fn-derivatives/options.c:824
msgid "t2:time to maturity of the underlying commodity futures contract"
msgstr ""

#: ../plugins/fn-derivatives/options.c:825
msgid "v_s:volatility of the spot commodity price"
msgstr ""

#: ../plugins/fn-derivatives/options.c:826
msgid "v_e:volatility of the future convenience yield"
msgstr ""

#: ../plugins/fn-derivatives/options.c:827
msgid "v_f:volatility of the forward rate of interest"
msgstr ""

#: ../plugins/fn-derivatives/options.c:828
msgid ""
"rho_se:correlation between the spot commodity price and the convenience yield"
msgstr ""

#: ../plugins/fn-derivatives/options.c:829
msgid ""
"rho_sf:correlation between the spot commodity price and the forward interest "
"rate"
msgstr ""

#: ../plugins/fn-derivatives/options.c:830
msgid ""
"rho_ef:correlation between the forward interest rate and the convenience "
"yield"
msgstr ""

#: ../plugins/fn-derivatives/options.c:831
msgid "kappa_e:speed of mean reversion of the convenience yield"
msgstr ""

#: ../plugins/fn-derivatives/options.c:832
msgid "kappa_f:speed of mean reversion of the forward interest rate"
msgstr ""

#: ../plugins/fn-derivatives/options.c:915
msgid ""
"OPT_RGW:theoretical price of an American option according to the Roll-Geske-"
"Whaley approximation"
msgstr ""

#: ../plugins/fn-derivatives/options.c:958
msgid ""
"OPT_BAW_AMER:theoretical price of an option according to the Barone Adesie & "
"Whaley approximation"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1130
msgid ""
"OPT_BJER_STENS:theoretical price of American options according to the "
"Bjerksund & Stensland approximation technique"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1204
msgid "OPT_EXEC:theoretical price of executive stock options"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1212
msgid "lambda:jump rate for executives"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1213
msgid ""
"The model assumes executives forfeit their options if they leave the company."
msgstr ""

#: ../plugins/fn-derivatives/options.c:1242
msgid "OPT_FORWARD_START:theoretical price of forward start options"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1245
msgid ""
"alpha:fraction setting the strike price at the future date @{time_start}"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1246
msgid "time_start:time until the option starts in days"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1294
msgid "OPT_TIME_SWITCH:theoretical price of time switch options"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1298
msgid "a:amount received for each time period"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1300
msgid "m:number of time units the option has already met the condition"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1301
msgid "dt:agreed upon discrete time period expressed as a fraction of a year"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1306
msgid ""
"OPT_TIME_SWITCH models the theoretical price of time switch options. (Pechtl "
"1995). The holder receives @{a} * @{dt} for each period that the asset price "
"was greater than @{strike} (for a call) or below it (for a put)."
msgstr ""

#: ../plugins/fn-derivatives/options.c:1336
msgid "OPT_SIMPLE_CHOOSER:theoretical price of a simple chooser option"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1340
msgid "time1:time in years until the holder chooses a put or a call option"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1341
msgid "time2:time in years until the chosen option expires"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1385
msgid "OPT_COMPLEX_CHOOSER:theoretical price of a complex chooser option"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1387
msgid "strike_call:strike price, if exercised as a call option"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1388
msgid "strike_put:strike price, if exercised as a put option"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1389
msgid "time:time in years until the holder chooses a put or a call option"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1390
msgid "time_call:time in years to maturity of the call option if chosen"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1391
msgid "time_put:time in years  to maturity of the put option if chosen"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1486
msgid "OPT_ON_OPTIONS:theoretical price of options on options"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1487
msgid ""
"type_flag:'cc' for calls on calls, 'cp' for calls on puts, and so on for "
"'pc', and 'pp'"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1489
msgid "strike1:strike price at which the option being valued is struck"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1490
msgid "strike2:strike price at which the underlying option is struck"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1491
msgid "time1:time in years to maturity of the option"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1492
msgid "time2:time in years to the maturity of the underlying option"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1494
msgid ""
"cost_of_carry:net cost of holding the underlying asset of the underlying "
"option"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1495
msgid ""
"volatility:annualized volatility in price of the underlying asset of the "
"underlying option"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1496
msgid ""
"For common stocks, @{cost_of_carry} is the risk free rate less the dividend "
"yield."
msgstr ""

#: ../plugins/fn-derivatives/options.c:1497
msgid "@{time2} ≥ @{time1}"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1563
msgid "OPT_EXTENDIBLE_WRITER:theoretical price of extendible writer options"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1566
msgid "strike1:strike price at which the option is struck"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1567
msgid ""
"strike2:strike price at which the option is re-struck if out of the money at "
"@{time1}"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1568
msgid "time1:initial maturity of the option in years"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1569
msgid "time2:extended maturity in years if chosen"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1573
msgid ""
"OPT_EXTENDIBLE_WRITER models the theoretical price of extendible writer "
"options. These are options that have their maturity extended to @{time2} if "
"the option is out of the money at @{time1}."
msgstr ""

#: ../plugins/fn-derivatives/options.c:1615
msgid ""
"OPT_2_ASSET_CORRELATION:theoretical price of options on 2 assets with "
"correlation @{rho}"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1617
msgid "spot1:spot price of the underlying asset of the first option"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1618
msgid "spot2:spot price of the underlying asset of the second option"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1619
msgid "strike1:strike prices of the first option"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1620
msgid "strike2:strike prices of the second option"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1622
msgid ""
"cost_of_carry1:net cost of holding the underlying asset of the first option "
"(for common stocks, the risk free rate less the dividend yield)"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1624
msgid ""
"cost_of_carry2:net cost of holding the underlying asset of the second option "
"(for common stocks, the risk free rate less the dividend yield)"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1627
msgid ""
"volatility1:annualized volatility in price of the underlying asset of the "
"first option"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1628
msgid ""
"volatility2:annualized volatility in price of the underlying asset of the "
"second option"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1629
msgid "rho:correlation between the two underlying assets"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1630
msgid ""
"OPT_2_ASSET_CORRELATION models the theoretical price of options on 2 assets "
"with correlation @{rho}. The payoff for a call is max(@{spot2} - @"
"{strike2},0) if @{spot1} > @{strike1} or 0 otherwise. The payoff for a put "
"is max (@{strike2} - @{spot2}, 0) if @{spot1} < @{strike1} or 0 otherwise."
msgstr ""

#: ../plugins/fn-derivatives/options.c:1665
msgid ""
"OPT_EURO_EXCHANGE:theoretical price of a European option to exchange assets"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1666
#: ../plugins/fn-derivatives/options.c:1710
msgid "spot1:spot price of asset 1"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1667
#: ../plugins/fn-derivatives/options.c:1711
msgid "spot2:spot price of asset 1"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1668
#: ../plugins/fn-derivatives/options.c:1712
msgid "qty1:quantity of asset 1"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1669
#: ../plugins/fn-derivatives/options.c:1713
msgid "qty2:quantity of asset 2"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1672
#: ../plugins/fn-derivatives/options.c:1716
msgid ""
"cost_of_carry1:net cost of holding asset 1 (for common stocks, the risk free "
"rate less the dividend yield)"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1674
#: ../plugins/fn-derivatives/options.c:1718
msgid ""
"cost_of_carry2:net cost of holding asset 2 (for common stocks, the risk free "
"rate less the dividend yield)"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1676
#: ../plugins/fn-derivatives/options.c:1720
msgid "volatility1:annualized volatility in price of asset 1"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1677
#: ../plugins/fn-derivatives/options.c:1721
msgid "volatility2:annualized volatility in price of asset 2"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1678
#: ../plugins/fn-derivatives/options.c:1722
msgid "rho:correlation between the prices of the two assets"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1679
msgid ""
"OPT_EURO_EXCHANGE models the theoretical price of a European option to "
"exchange one asset with quantity @{qty2} and spot price @{spot2} for another "
"with quantity @{qty1} and spot price @{spot1}."
msgstr ""

#: ../plugins/fn-derivatives/options.c:1709
msgid ""
"OPT_AMER_EXCHANGE:theoretical price of an American option to exchange assets"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1723
msgid ""
"OPT_AMER_EXCHANGE models the theoretical price of an American option to "
"exchange one asset with quantity @{qty2} and spot price @{spot2} for another "
"with quantity @{qty1} and spot price @{spot1}."
msgstr ""

#: ../plugins/fn-derivatives/options.c:1753
msgid ""
"OPT_SPREAD_APPROX:theoretical price of a European option on the spread "
"between two futures contracts"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1755
msgid "fut_price1:price of the first futures contract"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1756
msgid "fut_price2:price of the second futures contract"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1760
msgid ""
"volatility1:annualized volatility in price of the first underlying futures "
"contract"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1761
msgid ""
"volatility2:annualized volatility in price of the second underlying futures "
"contract"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1762
msgid "rho:correlation between the two futures contracts"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1808
msgid ""
"OPT_FLOAT_STRK_LKBK:theoretical price of floating-strike lookback option"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1811
#: ../plugins/fn-derivatives/options.c:1875
msgid "spot_min:minimum spot price of the underlying asset so far observed"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1812
#: ../plugins/fn-derivatives/options.c:1876
msgid "spot_max:maximum spot price of the underlying asset so far observed"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1817
msgid ""
"OPT_FLOAT_STRK_LKBK determines the theoretical price of a floating-strike "
"lookback option where the holder of the option may exercise on expiry at the "
"most favourable price observed during the options life of the underlying "
"asset."
msgstr ""

#: ../plugins/fn-derivatives/options.c:1872
msgid "OPT_FIXED_STRK_LKBK:theoretical price of a fixed-strike lookback option"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1882
msgid ""
"OPT_FIXED_STRK_LKBK determines the theoretical price of a fixed-strike "
"lookback option where the holder of the option may exercise on expiry at the "
"most favourable price observed during the options life of the underlying "
"asset."
msgstr ""

#: ../plugins/fn-derivatives/options.c:1956
msgid ""
"OPT_BINOMIAL:theoretical price of either an American or European style "
"option using a binomial tree"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1957
msgid ""
"amer_euro_flag:'a' for an American style option or 'e' for a European style "
"option"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1959
msgid "num_time_steps:number of time steps used in the valuation"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1966
msgid ""
"A larger @{num_time_steps} yields greater accuracy but  OPT_BINOMIAL is "
"slower to calculate."
msgstr ""

#: ../plugins/fn-eng/functions.c:207
msgid "BASE:string of digits representing the number @{n} in base @{b}"
msgstr ""

#: ../plugins/fn-eng/functions.c:208 ../plugins/fn-math/functions.c:1279
#: ../plugins/fn-numtheory/numtheory.c:578
#: ../plugins/fn-numtheory/numtheory.c:608
msgid "n:integer"
msgstr ""

#: ../plugins/fn-eng/functions.c:209
msgid "b:base (2 ≤ @{b} ≤ 36)"
msgstr ""

#: ../plugins/fn-eng/functions.c:210
msgid "length:minimum length of the resulting string"
msgstr ""

#: ../plugins/fn-eng/functions.c:211
msgid ""
"BASE converts @{n} to its string representation in base @{b}. Leading zeroes "
"will be added to reach the minimum length given by @{length}."
msgstr ""

#: ../plugins/fn-eng/functions.c:236
msgid "BIN2DEC:decimal representation of the binary number @{x}"
msgstr ""

#: ../plugins/fn-eng/functions.c:237 ../plugins/fn-eng/functions.c:259
#: ../plugins/fn-eng/functions.c:283
msgid ""
"x:a binary number, either as a string or as a number involving only the "
"digits 0 and 1"
msgstr ""

#: ../plugins/fn-eng/functions.c:258
msgid "BIN2OCT:octal representation of the binary number @{x}"
msgstr ""

#: ../plugins/fn-eng/functions.c:260 ../plugins/fn-eng/functions.c:284
#: ../plugins/fn-eng/functions.c:309 ../plugins/fn-eng/functions.c:333
#: ../plugins/fn-eng/functions.c:356 ../plugins/fn-eng/functions.c:427
#: ../plugins/fn-eng/functions.c:450 ../plugins/fn-eng/functions.c:473
#: ../plugins/fn-eng/functions.c:496
msgid "places:number of digits"
msgstr ""

#: ../plugins/fn-eng/functions.c:261
msgid ""
"If @{places} is given, BIN2OCT pads the result with zeros to achieve exactly "
"@{places} digits. If this is not possible, BIN2OCT returns #NUM!"
msgstr ""

#: ../plugins/fn-eng/functions.c:282
msgid "BIN2HEX:hexadecimal representation of the binary number @{x}"
msgstr ""

#: ../plugins/fn-eng/functions.c:285
msgid ""
"If @{places} is given, BIN2HEX pads the result with zeros to achieve exactly "
"@{places} digits. If this is not possible, BIN2HEX returns #NUM!"
msgstr ""

#: ../plugins/fn-eng/functions.c:307
msgid "DEC2BIN:binary representation of the decimal number @{x}"
msgstr ""

#: ../plugins/fn-eng/functions.c:308 ../plugins/fn-eng/functions.c:332
#: ../plugins/fn-eng/functions.c:355 ../plugins/fn-math/functions.c:1278
msgid "x:integer"
msgstr ""

#: ../plugins/fn-eng/functions.c:310
msgid ""
"If @{places} is given, DEC2BIN pads the result with zeros to achieve exactly "
"@{places} digits. If this is not possible, DEC2BIN returns #NUM!"
msgstr ""

#: ../plugins/fn-eng/functions.c:331
msgid "DEC2OCT:octal representation of the decimal number @{x}"
msgstr ""

#: ../plugins/fn-eng/functions.c:334
msgid ""
"If @{places} is given, DEC2OCT pads the result with zeros to achieve exactly "
"@{places} digits. If this is not possible, DEC2OCT returns #NUM!"
msgstr ""

#: ../plugins/fn-eng/functions.c:354
msgid "DEC2HEX:hexadecimal representation of the decimal number @{x}"
msgstr ""

#: ../plugins/fn-eng/functions.c:357
msgid ""
"If @{places} is given, DEC2HEX pads the result with zeros to achieve exactly "
"@{places} digits. If this is not possible, DEC2HEX returns #NUM!"
msgstr ""

#: ../plugins/fn-eng/functions.c:377
msgid "DECIMAL:decimal representation of @{x}"
msgstr ""

#: ../plugins/fn-eng/functions.c:378
msgid "x:number in base @{base}"
msgstr ""

#: ../plugins/fn-eng/functions.c:379
msgid "base:base of @{x}, (2 ≤ @{base} ≤ 36)"
msgstr ""

#: ../plugins/fn-eng/functions.c:401
msgid "OCT2DEC:decimal representation of the octal number @{x}"
msgstr ""

#: ../plugins/fn-eng/functions.c:402 ../plugins/fn-eng/functions.c:426
#: ../plugins/fn-eng/functions.c:449
msgid "x:a octal number, either as a string or as a number"
msgstr ""

#: ../plugins/fn-eng/functions.c:425
msgid "OCT2BIN:binary representation of the octal number @{x}"
msgstr ""

#: ../plugins/fn-eng/functions.c:428
msgid ""
"If @{places} is given, OCT2BIN pads the result with zeros to achieve exactly "
"@{places} digits. If this is not possible, OCT2BIN returns #NUM!"
msgstr ""

#: ../plugins/fn-eng/functions.c:448
msgid "OCT2HEX:hexadecimal representation of the octal number @{x}"
msgstr ""

#: ../plugins/fn-eng/functions.c:451
msgid ""
"If @{places} is given, OCT2HEX pads the result with zeros to achieve exactly "
"@{places} digits. If this is not possible, OCT2HEX returns #NUM!"
msgstr ""

#: ../plugins/fn-eng/functions.c:471
msgid "HEX2BIN:binary representation of the hexadecimal number @{x}"
msgstr ""

#: ../plugins/fn-eng/functions.c:472 ../plugins/fn-eng/functions.c:495
#: ../plugins/fn-eng/functions.c:518
msgid ""
"x:a hexadecimal number, either as a string or as a number if no A to F are "
"needed"
msgstr ""

#: ../plugins/fn-eng/functions.c:474
msgid ""
"If @{places} is given, HEX2BIN pads the result with zeros to achieve exactly "
"@{places} digits. If this is not possible, HEX2BIN returns #NUM!"
msgstr ""

#: ../plugins/fn-eng/functions.c:494
msgid "HEX2OCT:octal representation of the hexadecimal number @{x}"
msgstr ""

#: ../plugins/fn-eng/functions.c:497
msgid ""
"If @{places} is given, HEX2OCT pads the result with zeros to achieve exactly "
"@{places} digits. If this is not possible, HEX2OCT returns #NUM!"
msgstr ""

#: ../plugins/fn-eng/functions.c:517
msgid "HEX2DEC:decimal representation of the hexadecimal number @{x}"
msgstr ""

#: ../plugins/fn-eng/functions.c:540
msgid ""
"BESSELI:Modified Bessel function of the first kind of order @{α} at @{x}"
msgstr ""

#: ../plugins/fn-eng/functions.c:541 ../plugins/fn-eng/functions.c:579
#: ../plugins/fn-eng/functions.c:603 ../plugins/fn-eng/functions.c:632
msgid "X:number"
msgstr ""

#: ../plugins/fn-eng/functions.c:542 ../plugins/fn-eng/functions.c:580
msgid "α:order (any number)"
msgstr ""

#: ../plugins/fn-eng/functions.c:543 ../plugins/fn-eng/functions.c:581
msgid ""
"If @{x} or @{α} are not numeric, #VALUE! is returned. If @{α} < 0, #NUM! is "
"returned."
msgstr ""

#: ../plugins/fn-eng/functions.c:544 ../plugins/fn-eng/functions.c:582
msgid "This function is Excel compatible if only integer orders @{α} are used."
msgstr ""

#: ../plugins/fn-eng/functions.c:547 ../plugins/fn-eng/functions.c:585
#: ../plugins/fn-eng/functions.c:611
msgid "wiki:en:Bessel_function"
msgstr ""

#: ../plugins/fn-eng/functions.c:578
msgid ""
"BESSELK:Modified Bessel function of the second kind of order @{α} at @{x}"
msgstr ""

#: ../plugins/fn-eng/functions.c:602
msgid "BESSELJ:Bessel function of the first kind of order @{α} at @{x}"
msgstr ""

#: ../plugins/fn-eng/functions.c:604 ../plugins/fn-eng/functions.c:633
msgid "α:order (any non-negative integer)"
msgstr ""

#: ../plugins/fn-eng/functions.c:605 ../plugins/fn-eng/functions.c:634
msgid ""
"If @{x} or @{α} are not numeric, #VALUE! is returned. If @{α} < 0, #NUM! is "
"returned. If @{α} is not an integer, it is truncated."
msgstr ""

#: ../plugins/fn-eng/functions.c:631
msgid "BESSELY:Bessel function of the second kind of order @{α} at @{x}"
msgstr ""

#: ../plugins/fn-eng/functions.c:658
msgid "CONVERT:a converted measurement"
msgstr ""

#: ../plugins/fn-eng/functions.c:659 ../plugins/fn-eng/functions.c:1103
#: ../plugins/fn-math/functions.c:223 ../plugins/fn-math/functions.c:242
#: ../plugins/fn-math/functions.c:265 ../plugins/fn-math/functions.c:306
#: ../plugins/fn-math/functions.c:324 ../plugins/fn-math/functions.c:349
#: ../plugins/fn-math/functions.c:368 ../plugins/fn-math/functions.c:387
#: ../plugins/fn-math/functions.c:447 ../plugins/fn-math/functions.c:718
#: ../plugins/fn-math/functions.c:771 ../plugins/fn-math/functions.c:789
#: ../plugins/fn-math/functions.c:807 ../plugins/fn-math/functions.c:843
#: ../plugins/fn-math/functions.c:861 ../plugins/fn-math/functions.c:878
#: ../plugins/fn-math/functions.c:909 ../plugins/fn-math/functions.c:939
#: ../plugins/fn-math/functions.c:963 ../plugins/fn-math/functions.c:987
#: ../plugins/fn-math/functions.c:1071 ../plugins/fn-math/functions.c:1107
#: ../plugins/fn-math/functions.c:1203 ../plugins/fn-math/functions.c:1381
#: ../plugins/fn-math/functions.c:1421 ../plugins/fn-math/functions.c:1439
#: ../plugins/fn-math/functions.c:1591 ../plugins/fn-math/functions.c:1624
#: ../plugins/fn-math/functions.c:1661 ../plugins/fn-math/functions.c:1696
#: ../plugins/fn-math/functions.c:1836 ../plugins/fn-math/functions.c:1885
#: ../plugins/fn-math/functions.c:1909 ../plugins/fn-math/functions.c:1950
#: ../plugins/fn-math/functions.c:1997 ../plugins/fn-stat/functions.c:410
#: ../plugins/fn-stat/functions.c:462 ../plugins/fn-stat/functions.c:523
#: ../plugins/fn-stat/functions.c:843 ../plugins/fn-stat/functions.c:912
#: ../plugins/fn-stat/functions.c:975 ../plugins/fn-stat/functions.c:1117
#: ../plugins/fn-stat/functions.c:1189 ../plugins/fn-stat/functions.c:1276
#: ../plugins/fn-stat/functions.c:1306 ../plugins/fn-stat/functions.c:1539
#: ../plugins/fn-stat/functions.c:1718 ../plugins/fn-stat/functions.c:1754
#: ../plugins/fn-stat/functions.c:1921 ../plugins/fn-stat/functions.c:4312
#: ../plugins/fn-stat/functions.c:4343 ../plugins/fn-stat/functions.c:4377
#: ../plugins/fn-stat/functions.c:4412 ../plugins/fn-stat/functions.c:4451
#: ../plugins/fn-stat/functions.c:4484
msgid "x:number"
msgstr ""

#: ../plugins/fn-eng/functions.c:660
msgid "from:unit (string)"
msgstr ""

#: ../plugins/fn-eng/functions.c:661
msgid "to:unit (string)"
msgstr ""

#: ../plugins/fn-eng/functions.c:662
msgid ""
"CONVERT returns a conversion from one measurement system to another. @{x} is "
"a value in @{from} units that is to be converted into @{to} units."
msgstr ""

#: ../plugins/fn-eng/functions.c:664
msgid "If @{from} and @{to} are different types, CONVERT returns #N/A!"
msgstr ""

#: ../plugins/fn-eng/functions.c:665
#, fuzzy
msgid ""
"@{from} and @{to} can be any of the following:\n"
"\n"
"Weight and mass:\n"
"\t'g'  \t\t\tGram\n"
"\t'sg' \t\t\tSlug\n"
"\t'lbm'\t\tPound\n"
"\t'u'  \t\t\tU (atomic mass)\n"
"\t'ozm'\t\tOunce\n"
"\n"
"Distance:\n"
"\t'm'   \t\tMeter\n"
"\t'mi'  \t\tStatute mile\n"
"\t'Nmi' \t\tNautical mile\n"
"\t'in'  \t\t\tInch\n"
"\t'ft'  \t\t\tFoot\n"
"\t'yd'  \t\tYard\n"
"\t'ang' \t\tAngstrom\n"
"\t'Pica'\t\tPica Points\n"
"\t'picapt'\t\tPica Points\n"
"\t'pica'\t\tPica\n"
"\n"
"Time:\n"
"\t'yr'  \t\t\tYear\n"
"\t'day' \t\tDay\n"
"\t'hr'  \t\t\tHour\n"
"\t'mn'  \t\tMinute\n"
"\t'sec' \t\tSecond\n"
"\n"
"Pressure:\n"
"\t'Pa'  \t\tPascal\n"
"\t'atm' \t\tAtmosphere\n"
"\t'mmHg'\t\tmm of Mercury\n"
"\n"
"Force:\n"
"\t'N'   \t\t\tNewton\n"
"\t'dyn' \t\tDyne\n"
"\t'lbf' \t\t\tPound force\n"
"\n"
"Energy:\n"
"\t'J'    \t\t\tJoule\n"
"\t'e'    \t\tErg\n"
"\t'c'    \t\tThermodynamic calorie\n"
"\t'cal'  \t\tIT calorie\n"
"\t'eV'   \t\tElectron volt\n"
"\t'HPh'  \t\tHorsepower-hour\n"
"\t'Wh'   \t\tWatt-hour\n"
"\t'flb'  \t\tFoot-pound\n"
"\t'BTU'  \t\tBTU\n"
"\n"
"Power:\n"
"\t'HP'   \t\tHorsepower\n"
"\t'W'    \t\tWatt\n"
"\n"
"Magnetism:\n"
"\t'T'    \t\tTesla\n"
"\t'ga'   \t\tGauss\n"
"\n"
"Temperature:\n"
"\t'C'    \t\tDegree Celsius\n"
"\t'F'    \t\tDegree Fahrenheit\n"
"\t'K'    \t\tDegree Kelvin\n"
"\n"
"Liquid measure:\n"
"\t'tsp'  \t\tTeaspoon\n"
"\t'tbs'  \t\tTablespoon\n"
"\t'oz'   \t\tFluid ounce\n"
"\t'cup'  \t\tCup\n"
"\t'pt'   \t\tPint\n"
"\t'qt'   \t\tQuart\n"
"\t'gal'  \t\tGallon\n"
"\t'l'    \t\t\tLiter\n"
"\n"
"For metric units any of the following prefixes can be used:\n"
"\t'Y'  \tyotta \t\t1E+24\n"
"\t'Z'  \tzetta \t\t1E+21\n"
"\t'E'  \texa   \t\t1E+18\n"
"\t'P'  \tpeta  \t\t1E+15\n"
"\t'T'  \ttera  \t\t1E+12\n"
"\t'G'  \tgiga  \t\t1E+09\n"
"\t'M'  \tmega  \t\t1E+06\n"
"\t'k'  \tkilo  \t\t1E+03\n"
"\t'h'  \thecto \t\t1E+02\n"
"\t'e'  \tdeca (deka)\t1E+01\n"
"\t'd'  \tdeci  \t\t1E-01\n"
"\t'c'  \tcenti \t\t1E-02\n"
"\t'm'  \tmilli \t\t1E-03\n"
"\t'u'  \tmicro \t\t1E-06\n"
"\t'n'  \tnano  \t\t1E-09\n"
"\t'p'  \tpico  \t\t1E-12\n"
"\t'f'  \tfemto \t\t1E-15\n"
"\t'a'  \tatto  \t\t1E-18\n"
"\t'z'  \tzepto \t\t1E-21\n"
"\t'y'  \tyocto \t\t1E-24"
msgstr ""
"@FUNCTION=CONVERT\n"
"@SYNTAX=CONVERT(tal;från_enhet;till_enhet)\n"
"@DESCRIPTION=CONVERT omvandlar från ett enhetssytem till ett annat. Till "
"exempel kan du konvertera vikt i pund till en vikt i gram. @tal är värdet "
"som skall omvandlas, @från_enhet anger enheten på @tal, och @till_enhet är "
"resultatets enhet.\n"
"\n"
"@från_enhet och @till_enhet kan vara någon av följande:\n"
"\n"
"Vikt och massa:\n"
"\t\"g\"    \t\tGram\n"
"\t\"sg\"   \t\tSlug\n"
"\t\"lbm\"  \t\tPund\n"
"\t\"u\"    \t\tU (atommassa)\n"
"\t\"ozm\"  \t\tOunce\n"
"\n"
"Avstånd:\n"
"\t\"m\"    \t\tMeter\n"
"\t\"mi\"   \t\tStatute mile\n"
"\t\"Nmi\"  \t\tSjömil\n"
"\t\"in\"   \t\tTum\n"
"\t\"ft\"   \t\tFot\n"
"\t\"yd\"   \t\tYard\n"
"\t\"ang\"  \t\tÅngstrom\n"
"\t\"Pica\" \t\tPica\n"
"\n"
"Tid:\n"
"\t\"yr\"   \t\tÅr\n"
"\t\"day\"  \t\tDag\n"
"\t\"hr\"   \t\tTimme\n"
"\t\"mn\"   \t\tMinut\n"
"\t\"sec\"  \t\tSekund\n"
"\n"
"Tryck:\n"
"\t\"Pa\"   \t\tPascal\n"
"\t\"atm\"  \t\tAtmosfär\n"
"\t\"mmHg\" \tmm kvicksilver\n"
"\n"
"Kraft:\n"
"\t\"N\"    \t\tNewton\n"
"\t\"dyn\"  \t\tDyne\n"
"\t\"lbf\"  \t\tPound force\n"
"\n"
"Energi:\n"
"\t\"J\"    \t\tJoule\n"
"\t\"e\"    \t\tErg\n"
"\t\"c\"    \t\tTermodynamiska kalorier\n"
"\t\"cal\"  \t\tIT-kalorier\n"
"\t\"eV\"   \tElektronvolt\n"
"\t\"HPh\"  \tHästkraft-timme\n"
"\t\"Wh\"   \tWatt-timme\n"
"\t\"flb\"  \t\tFot-pund\n"
"\t\"BTU\"  \tBTU\n"
"\n"
"Effekt:\n"
"\t\"HP\"   \tHästkraft\n"
"\t\"W\"    \tWatt\n"
"\n"
"Magnetism:\n"
"\t\"T\"    \t\tTesla\n"
"\t\"ga\"   \tGauss\n"
"\n"
"Temperatur:\n"
"\t\"C\"    \t\tGrader celsius\n"
"\t\"F\"    \t\tGrader fahrenheit\n"
"\t\"K\"    \t\tGrader kelvin\n"
"\n"
"Volym (flytande):\n"
"\t\"tsp\"  \t\tTesked\n"
"\t\"tbs\"  \t\tMatsked\n"
"\t\"oz\"   \t\tFluid ounce\n"
"\t\"cup\"  \tKopp\n"
"\t\"pt\"   \t\tPint\n"
"\t\"qt\"   \t\tQuart\n"
"\t\"gal\"  \t\tGallon\n"
"\t\"l\"    \t\tLiter\n"
"\n"
"För enheter i det metriska systemet kan följande prefix användas:\n"
"\t\"Y\"  yotta  \t1E+24\n"
"\t\"Z\"  zetta  \t1E+21\n"
"\t\"E\"  exa    \t1E+18\n"
"\t\"P\"  peta   \t1E+15\n"
"\t\"T\"  tera   \t\t1E+12\n"
"\t\"G\"  giga   \t1E+09\n"
"\t\"M\"  mega   \t1E+06\n"
"\t\"k\"  kilo   \t\t1E+03\n"
"\t\"h\"  hekto  \t1E+02\n"
"\t\"e\"  dekao  \t1E+01\n"
"\t\"d\"  deci   \t1E-01\n"
"\t\"c\"  centi  \t\t1E-02\n"
"\t\"m\"  milli  \t\t1E-03\n"
"\t\"u\"  micro  \t1E-06\n"
"\t\"n\"  nano   \t1E-09\n"
"\t\"p\"  pico   \t1E-12\n"
"\t\"f\"  femto  \t1E-15\n"
"\t\"a\"  atto   \t\t1E-18\n"
"\t\"z\"  zepto  \t\t1E-21\n"
"\t\"y\"  yocto  \t\t1E-24\n"
"\n"
"* Om @från_enhet och @till_enhet har olika typ, returnerar CONVERT felvärdet "
"#NUM!.\n"
"* Denna funktion är kompatibel med Excel.\n"
"\n"
"@EXAMPLES=\n"
"CONVERT(3;\"ilbm\";\"g\") är lika med 1360,7769.\n"
"CONVERT(5,8;\"m\";\"in\") är lika med 228,3465.\n"
"CONVERT(7,9;\"cal\";\"J\") är lika med 33,07567.\n"
"@SEEALSO="

#: ../plugins/fn-eng/functions.c:747
msgid "This function is Excel compatible (except \"picapt\")."
msgstr ""

#: ../plugins/fn-eng/functions.c:1070
msgid "ERF:Gauss error function"
msgstr ""

#: ../plugins/fn-eng/functions.c:1071
msgid "lower:lower limit of the integral, defaults to 0"
msgstr ""

#: ../plugins/fn-eng/functions.c:1072
msgid "upper:upper limit of the integral"
msgstr ""

#: ../plugins/fn-eng/functions.c:1073
msgid ""
"ERF returns 2/sqrt(π)* integral from @{lower} to @{upper} of exp(-t*t) dt"
msgstr ""

#: ../plugins/fn-eng/functions.c:1074
msgid ""
"This function is Excel compatible if two arguments are supplied and neither "
"is negative."
msgstr ""

#: ../plugins/fn-eng/functions.c:1078 ../plugins/fn-eng/functions.c:1107
msgid "wiki:en:Error_function"
msgstr ""

#: ../plugins/fn-eng/functions.c:1102
msgid "ERFC:Complementary Gauss error function"
msgstr ""

#: ../plugins/fn-eng/functions.c:1104
msgid "ERFC returns 2/sqrt(π)* integral from @{x} to ∞ of exp(-t*t) dt"
msgstr ""

#: ../plugins/fn-eng/functions.c:1122
msgid "DELTA:Kronecker delta function"
msgstr ""

#: ../plugins/fn-eng/functions.c:1123 ../plugins/fn-eng/functions.c:1146
msgid "x0:number"
msgstr ""

#: ../plugins/fn-eng/functions.c:1124 ../plugins/fn-eng/functions.c:1147
msgid "x1:number, defaults to 0"
msgstr ""

#: ../plugins/fn-eng/functions.c:1125
msgid "DELTA  returns 1 if  @{x1} = @{x0} and 0 otherwise."
msgstr ""

#: ../plugins/fn-eng/functions.c:1126 ../plugins/fn-eng/functions.c:1149
msgid "If either argument is non-numeric, #VALUE! is returned."
msgstr ""

#: ../plugins/fn-eng/functions.c:1145
msgid "GESTEP:step function with step at @{x1} evaluated at @{x0}"
msgstr ""

#: ../plugins/fn-eng/functions.c:1148
msgid "GESTEP returns 1 if  @{x1} ≤ @{x0} and 0 otherwise."
msgstr ""

#: ../plugins/fn-eng/functions.c:1168
msgid "INVSUMINV:the reciprocal of the sum of reciprocals of the arguments"
msgstr ""

#: ../plugins/fn-eng/functions.c:1169
msgid "x0:non-negative number"
msgstr ""

#: ../plugins/fn-eng/functions.c:1170
msgid "x1:non-negative number"
msgstr ""

#: ../plugins/fn-eng/functions.c:1171
msgid ""
"If any of the arguments is negative, #VALUE! is returned.\n"
"If any argument is zero, the result is zero."
msgstr ""

#: ../plugins/fn-eng/functions.c:1173
msgid ""
"INVSUMINV sum calculates the reciprocal (the inverse) of the sum of "
"reciprocals (inverses) of all its arguments."
msgstr ""

#: ../plugins/fn-erlang/functions.c:105
msgid "PROBBLOCK:probability of blocking"
msgstr ""

#: ../plugins/fn-erlang/functions.c:106 ../plugins/fn-erlang/functions.c:191
msgid "traffic:number of calls"
msgstr ""

#: ../plugins/fn-erlang/functions.c:107 ../plugins/fn-erlang/functions.c:132
#: ../plugins/fn-erlang/functions.c:229
msgid "circuits:number of circuits"
msgstr ""

#: ../plugins/fn-erlang/functions.c:108
msgid ""
"PROBBLOCK returns probability of blocking when @{traffic} calls load into @"
"{circuits} circuits."
msgstr ""

#: ../plugins/fn-erlang/functions.c:110 ../plugins/fn-erlang/functions.c:134
msgid "@{traffic} cannot exceed @{circuits}."
msgstr ""

#: ../plugins/fn-erlang/functions.c:130
msgid "OFFTRAF:predicted number of offered calls"
msgstr ""

#: ../plugins/fn-erlang/functions.c:131
msgid "traffic:number of carried calls"
msgstr ""

#: ../plugins/fn-erlang/functions.c:133
msgid ""
"OFFTRAF returns the predicted number of offered calls given @{traffic} "
"carried calls (taken from measurements) on @{circuits} circuits."
msgstr ""

#: ../plugins/fn-erlang/functions.c:190
msgid "DIMCIRC:number of circuits required"
msgstr ""

#: ../plugins/fn-erlang/functions.c:192 ../plugins/fn-erlang/functions.c:230
msgid "gos:grade of service"
msgstr ""

#: ../plugins/fn-erlang/functions.c:193
msgid ""
"DIMCIRC returns the number of circuits required given @{traffic} calls with "
"grade of service @{gos}."
msgstr ""

#: ../plugins/fn-erlang/functions.c:228
msgid "OFFCAP:traffic capacity"
msgstr ""

#: ../plugins/fn-erlang/functions.c:231
msgid ""
"OFFCAP returns the traffic capacity given @{circuits} circuits with grade of "
"service @{gos}."
msgstr ""

#. *************************************************************************
#: ../plugins/fn-financial/functions.c:53
msgid "@{frequency} may be 1 (annual), 2 (semi-annual), or 4 (quarterly)."
msgstr ""

#: ../plugins/fn-financial/functions.c:56
msgid ""
"If @{type} is 0, the default, payment is at the end of each period.  If @"
"{type} is 1, payment is at the beginning of each period."
msgstr ""

#: ../plugins/fn-financial/functions.c:362
msgid "ACCRINT:accrued interest"
msgstr ""

#: ../plugins/fn-financial/functions.c:363
#: ../plugins/fn-financial/functions.c:450
#: ../plugins/fn-financial/functions.c:605
#: ../plugins/fn-financial/functions.c:2458
#: ../plugins/fn-financial/functions.c:2497
#: ../plugins/fn-financial/functions.c:2647
msgid "issue:date of issue"
msgstr ""

#: ../plugins/fn-financial/functions.c:364
msgid "first_interest:date of first interest payment"
msgstr ""

#: ../plugins/fn-financial/functions.c:365
#: ../plugins/fn-financial/functions.c:488
#: ../plugins/fn-financial/functions.c:526
#: ../plugins/fn-financial/functions.c:567
#: ../plugins/fn-financial/functions.c:603
#: ../plugins/fn-financial/functions.c:648
#: ../plugins/fn-financial/functions.c:1086
#: ../plugins/fn-financial/functions.c:1124
#: ../plugins/fn-financial/functions.c:1158
#: ../plugins/fn-financial/functions.c:1890
#: ../plugins/fn-financial/functions.c:2252
#: ../plugins/fn-financial/functions.c:2302
#: ../plugins/fn-financial/functions.c:2411
#: ../plugins/fn-financial/functions.c:2456
#: ../plugins/fn-financial/functions.c:2495
#: ../plugins/fn-financial/functions.c:2645
#: ../plugins/fn-financial/functions.c:2741
#: ../plugins/fn-financial/functions.c:2819
#: ../plugins/fn-financial/functions.c:2999
#: ../plugins/fn-financial/functions.c:3023
#: ../plugins/fn-financial/functions.c:3047
#: ../plugins/fn-financial/functions.c:3071
#: ../plugins/fn-financial/functions.c:3097
#: ../plugins/fn-financial/functions.c:3123
#: ../plugins/fn-financial/functions.c:3235
msgid "settlement:settlement date"
msgstr ""

#: ../plugins/fn-financial/functions.c:366
#: ../plugins/fn-financial/functions.c:452
#: ../plugins/fn-financial/functions.c:529
#: ../plugins/fn-financial/functions.c:686
#: ../plugins/fn-financial/functions.c:2254
#: ../plugins/fn-financial/functions.c:2304
#: ../plugins/fn-financial/functions.c:2459
#: ../plugins/fn-financial/functions.c:2499
#: ../plugins/fn-financial/functions.c:2649
#: ../plugins/fn-financial/functions.c:2744
#: ../plugins/fn-financial/functions.c:2822
msgid "rate:nominal annual interest rate"
msgstr ""

#: ../plugins/fn-financial/functions.c:367
msgid "par:par value, defaults to $1000"
msgstr ""

#: ../plugins/fn-financial/functions.c:368
#: ../plugins/fn-financial/functions.c:1894
#: ../plugins/fn-financial/functions.c:2257
#: ../plugins/fn-financial/functions.c:2307
#: ../plugins/fn-financial/functions.c:2502
#: ../plugins/fn-financial/functions.c:2652
#: ../plugins/fn-financial/functions.c:2747
#: ../plugins/fn-financial/functions.c:2825
#: ../plugins/fn-financial/functions.c:3001
#: ../plugins/fn-financial/functions.c:3025
#: ../plugins/fn-financial/functions.c:3049
#: ../plugins/fn-financial/functions.c:3073
#: ../plugins/fn-financial/functions.c:3099
#: ../plugins/fn-financial/functions.c:3125
#: ../plugins/fn-financial/functions.c:3239
msgid "frequency:number of interest payments per year"
msgstr ""

#: ../plugins/fn-financial/functions.c:369
msgid "basis:calendar basis, defaults to 0"
msgstr ""

#: ../plugins/fn-financial/functions.c:370
msgid "calc_method:calculation method, defaults to TRUE"
msgstr ""

#: ../plugins/fn-financial/functions.c:372
msgid ""
"If @{first_interest} < @{settlement} and @{calc_method} is TRUE, then "
"ACCRINT returns the sum of the interest accrued in all coupon periods from @"
"{issue}  date until @{settlement} date."
msgstr ""

#: ../plugins/fn-financial/functions.c:377
msgid ""
"If @{first_interest} < @{settlement} and @{calc_method} is FALSE, then "
"ACCRINT returns the sum of the interest accrued in all coupon periods from @"
"{first_interest}  date until @{settlement} date."
msgstr ""

#: ../plugins/fn-financial/functions.c:382
msgid ""
"Otherwise ACCRINT returns the sum of the interest accrued in all coupon "
"periods from @{issue}  date until @{settlement} date."
msgstr ""

#: ../plugins/fn-financial/functions.c:385
msgid ""
"@{frequency} must be one of 1, 2 or 4, but the exact value does not affect "
"the result."
msgstr ""

#: ../plugins/fn-financial/functions.c:387
msgid "@{issue} must precede both @{first_interest} and @{settlement}."
msgstr ""

#: ../plugins/fn-financial/functions.c:449
msgid "ACCRINTM:accrued interest"
msgstr ""

#: ../plugins/fn-financial/functions.c:451
#: ../plugins/fn-financial/functions.c:489
#: ../plugins/fn-financial/functions.c:527
#: ../plugins/fn-financial/functions.c:568
#: ../plugins/fn-financial/functions.c:604
#: ../plugins/fn-financial/functions.c:649
#: ../plugins/fn-financial/functions.c:1087
#: ../plugins/fn-financial/functions.c:1125
#: ../plugins/fn-financial/functions.c:1159
#: ../plugins/fn-financial/functions.c:1891
#: ../plugins/fn-financial/functions.c:2253
#: ../plugins/fn-financial/functions.c:2303
#: ../plugins/fn-financial/functions.c:2412
#: ../plugins/fn-financial/functions.c:2457
#: ../plugins/fn-financial/functions.c:2496
#: ../plugins/fn-financial/functions.c:2646
#: ../plugins/fn-financial/functions.c:2742
#: ../plugins/fn-financial/functions.c:2820
#: ../plugins/fn-financial/functions.c:3000
#: ../plugins/fn-financial/functions.c:3024
#: ../plugins/fn-financial/functions.c:3048
#: ../plugins/fn-financial/functions.c:3072
#: ../plugins/fn-financial/functions.c:3098
#: ../plugins/fn-financial/functions.c:3124
#: ../plugins/fn-financial/functions.c:3236
msgid "maturity:maturity date"
msgstr ""

#: ../plugins/fn-financial/functions.c:453
msgid "par:par value"
msgstr ""

#: ../plugins/fn-financial/functions.c:455
msgid "ACCRINTM calculates the accrued interest from @{issue} to @{maturity}."
msgstr ""

#: ../plugins/fn-financial/functions.c:456
msgid "@{par} defaults to $1000."
msgstr ""

#: ../plugins/fn-financial/functions.c:487
msgid "INTRATE:interest rate"
msgstr ""

#: ../plugins/fn-financial/functions.c:490
#: ../plugins/fn-financial/functions.c:528
msgid "investment:amount paid on settlement"
msgstr ""

#: ../plugins/fn-financial/functions.c:491
#: ../plugins/fn-financial/functions.c:570
#: ../plugins/fn-financial/functions.c:651
#: ../plugins/fn-financial/functions.c:2256
#: ../plugins/fn-financial/functions.c:2306
#: ../plugins/fn-financial/functions.c:2414
#: ../plugins/fn-financial/functions.c:2501
#: ../plugins/fn-financial/functions.c:2651
#: ../plugins/fn-financial/functions.c:2746
#: ../plugins/fn-financial/functions.c:2824
msgid "redemption:amount received at maturity"
msgstr ""

#: ../plugins/fn-financial/functions.c:493
msgid "INTRATE calculates the interest of a fully vested security."
msgstr ""

#: ../plugins/fn-financial/functions.c:525
msgid "RECEIVED:amount to be received at maturity"
msgstr ""

#: ../plugins/fn-financial/functions.c:531
msgid "RECEIVED calculates the amount to be received when a security matures."
msgstr ""

#: ../plugins/fn-financial/functions.c:566
msgid "PRICEDISC:discounted price"
msgstr ""

#: ../plugins/fn-financial/functions.c:569
#: ../plugins/fn-financial/functions.c:606
#: ../plugins/fn-financial/functions.c:1088
#: ../plugins/fn-financial/functions.c:1126
msgid "discount:annual rate at which to discount"
msgstr ""

#: ../plugins/fn-financial/functions.c:572
msgid ""
"PRICEDISC calculates the price per $100 face value of a bond that does not "
"pay interest at maturity."
msgstr ""

#: ../plugins/fn-financial/functions.c:602
msgid "PRICEMAT:price at maturity"
msgstr ""

#: ../plugins/fn-financial/functions.c:607
#: ../plugins/fn-financial/functions.c:1893
#: ../plugins/fn-financial/functions.c:2255
#: ../plugins/fn-financial/functions.c:2500
#: ../plugins/fn-financial/functions.c:2745
#: ../plugins/fn-financial/functions.c:3238
msgid "yield:annual yield of security"
msgstr ""

#: ../plugins/fn-financial/functions.c:609
msgid ""
"PRICEMAT calculates the price per $100 face value of a bond that pays "
"interest at maturity."
msgstr ""

#: ../plugins/fn-financial/functions.c:647
msgid "DISC:discount rate"
msgstr ""

#: ../plugins/fn-financial/functions.c:650
msgid "par:price per $100 face value"
msgstr ""

#: ../plugins/fn-financial/functions.c:653
msgid "DISC calculates the discount rate for a security."
msgstr ""

#: ../plugins/fn-financial/functions.c:654
msgid "@{redemption} is the redemption value per $100 face value."
msgstr ""

#: ../plugins/fn-financial/functions.c:685
msgid "EFFECT:effective interest rate"
msgstr ""

#: ../plugins/fn-financial/functions.c:687
#: ../plugins/fn-financial/functions.c:712
msgid "nper:number of periods used for compounding"
msgstr ""

#: ../plugins/fn-financial/functions.c:688
msgid ""
"EFFECT calculates the effective interest rate using the formula (1+@{rate}/@"
"{nper})^@{nper}-1."
msgstr ""

#: ../plugins/fn-financial/functions.c:710
msgid "NOMINAL:nominal interest rate"
msgstr ""

#: ../plugins/fn-financial/functions.c:711
#: ../plugins/fn-financial/functions.c:736
#: ../plugins/fn-financial/functions.c:1542
#: ../plugins/fn-financial/functions.c:1728
#: ../plugins/fn-financial/functions.c:1758
#: ../plugins/fn-financial/functions.c:1798
#: ../plugins/fn-financial/functions.c:1842
#: ../plugins/fn-financial/functions.c:1934
msgid "rate:effective annual interest rate"
msgstr ""

#: ../plugins/fn-financial/functions.c:713
msgid "NOMINAL calculates the nominal interest rate from the effective rate."
msgstr ""

#: ../plugins/fn-financial/functions.c:735
msgid "ISPMT:interest payment for period"
msgstr ""

#: ../plugins/fn-financial/functions.c:737
#: ../plugins/fn-financial/functions.c:1759
#: ../plugins/fn-financial/functions.c:1799
msgid "per:period number"
msgstr ""

#: ../plugins/fn-financial/functions.c:738
#: ../plugins/fn-financial/functions.c:1192
#: ../plugins/fn-financial/functions.c:1459
#: ../plugins/fn-financial/functions.c:1693
#: ../plugins/fn-financial/functions.c:1729
#: ../plugins/fn-financial/functions.c:1760
#: ../plugins/fn-financial/functions.c:1800
#: ../plugins/fn-financial/functions.c:3148
#: ../plugins/fn-financial/functions.c:3192
msgid "nper:number of periods"
msgstr ""

#: ../plugins/fn-financial/functions.c:739
#: ../plugins/fn-financial/functions.c:1194
#: ../plugins/fn-financial/functions.c:1307
#: ../plugins/fn-financial/functions.c:1695
#: ../plugins/fn-financial/functions.c:1730
#: ../plugins/fn-financial/functions.c:1761
#: ../plugins/fn-financial/functions.c:1801
#: ../plugins/fn-financial/functions.c:1844
#: ../plugins/fn-financial/functions.c:1935
#: ../plugins/fn-financial/functions.c:3149
#: ../plugins/fn-financial/functions.c:3193
msgid "pv:present value"
msgstr ""

#: ../plugins/fn-financial/functions.c:740
msgid "ISPMT calculates the interest payment for period number @{per}."
msgstr ""

#: ../plugins/fn-financial/functions.c:771
msgid "DB:depreciation of an asset"
msgstr ""

#: ../plugins/fn-financial/functions.c:772
#: ../plugins/fn-financial/functions.c:822
#: ../plugins/fn-financial/functions.c:871
#: ../plugins/fn-financial/functions.c:901
#: ../plugins/fn-financial/functions.c:2897
#: ../plugins/fn-financial/functions.c:2953
#: ../plugins/fn-financial/functions.c:3280
msgid "cost:initial cost of asset"
msgstr ""

#: ../plugins/fn-financial/functions.c:773
#: ../plugins/fn-financial/functions.c:823
#: ../plugins/fn-financial/functions.c:872
#: ../plugins/fn-financial/functions.c:902
#: ../plugins/fn-financial/functions.c:2900
#: ../plugins/fn-financial/functions.c:2956
#: ../plugins/fn-financial/functions.c:3281
msgid "salvage:value after depreciation"
msgstr ""

#: ../plugins/fn-financial/functions.c:774
#: ../plugins/fn-financial/functions.c:824
#: ../plugins/fn-financial/functions.c:873
#: ../plugins/fn-financial/functions.c:903
#: ../plugins/fn-financial/functions.c:3282
msgid "life:number of periods"
msgstr ""

#: ../plugins/fn-financial/functions.c:775
#: ../plugins/fn-financial/functions.c:825
#: ../plugins/fn-financial/functions.c:904
#: ../plugins/fn-financial/functions.c:2901
#: ../plugins/fn-financial/functions.c:2957
msgid "period:subject period"
msgstr ""

#: ../plugins/fn-financial/functions.c:776
msgid "month:number of months in first year of depreciation"
msgstr ""

#: ../plugins/fn-financial/functions.c:777
msgid ""
"DB calculates the depreciation of an asset for a given period using the "
"fixed-declining balance method."
msgstr ""

#: ../plugins/fn-financial/functions.c:821
msgid "DDB:depreciation of an asset"
msgstr ""

#: ../plugins/fn-financial/functions.c:826
#: ../plugins/fn-financial/functions.c:3285
msgid "factor:factor at which the balance declines"
msgstr ""

#: ../plugins/fn-financial/functions.c:827
msgid ""
"DDB calculates the depreciation of an asset for a given period using the "
"double-declining balance method."
msgstr ""

#: ../plugins/fn-financial/functions.c:870
msgid "SLN:depreciation of an asset"
msgstr ""

#: ../plugins/fn-financial/functions.c:874
msgid ""
"SLN calculates the depreciation of an asset using the straight-line method."
msgstr ""

#: ../plugins/fn-financial/functions.c:900
msgid "SYD:sum-of-years depreciation"
msgstr ""

#: ../plugins/fn-financial/functions.c:905
msgid ""
"SYD calculates the depreciation of an asset using the sum-of-years method."
msgstr ""

#: ../plugins/fn-financial/functions.c:933
msgid "DOLLARDE:convert to decimal dollar amount"
msgstr ""

#: ../plugins/fn-financial/functions.c:934
msgid "fractional_dollar:amount to convert"
msgstr ""

#: ../plugins/fn-financial/functions.c:935
#: ../plugins/fn-financial/functions.c:983
msgid "fraction:denominator"
msgstr ""

#: ../plugins/fn-financial/functions.c:936
msgid ""
"DOLLARDE converts a fractional dollar amount into a decimal amount.  This is "
"the inverse of the DOLLARFR function."
msgstr ""

#: ../plugins/fn-financial/functions.c:981
msgid "DOLLARFR:convert to dollar fraction"
msgstr ""

#: ../plugins/fn-financial/functions.c:982
msgid "decimal_dollar:amount to convert"
msgstr ""

#: ../plugins/fn-financial/functions.c:984
msgid ""
"DOLLARFR converts a decimal dollar amount into a fractional amount which is "
"represented as the digits after the decimal point.  For example, 2/8 would "
"be represented as .2 while 3/16 would be represented as .03. This is the "
"inverse of the DOLLARDE function."
msgstr ""

#: ../plugins/fn-financial/functions.c:1027
msgid "MIRR:modified internal rate of return"
msgstr ""

#: ../plugins/fn-financial/functions.c:1028
#: ../plugins/fn-financial/functions.c:1341
#: ../plugins/fn-financial/functions.c:1543
#: ../plugins/fn-financial/functions.c:1598
msgid "values:cash flow"
msgstr ""

#: ../plugins/fn-financial/functions.c:1029
msgid "finance_rate:interest rate for financing cost"
msgstr ""

#: ../plugins/fn-financial/functions.c:1030
msgid "reinvest_rate:interest rate for reinvestments"
msgstr ""

#: ../plugins/fn-financial/functions.c:1031
msgid ""
"MIRR calculates the modified internal rate of return of a periodic cash flow."
msgstr ""

#: ../plugins/fn-financial/functions.c:1085
msgid "TBILLEQ:bond-equivalent yield for a treasury bill"
msgstr ""

#: ../plugins/fn-financial/functions.c:1089
msgid "TBILLEQ calculates the bond-equivalent yield for a treasury bill."
msgstr ""

#: ../plugins/fn-financial/functions.c:1123
msgid "TBILLPRICE:price of a treasury bill"
msgstr ""

#: ../plugins/fn-financial/functions.c:1127
msgid ""
"TBILLPRICE calculates the price per $100 face value for a treasury bill."
msgstr ""

#: ../plugins/fn-financial/functions.c:1157
msgid "TBILLYIELD:yield of a treasury bill"
msgstr ""

#: ../plugins/fn-financial/functions.c:1160
msgid "price:price"
msgstr ""

#: ../plugins/fn-financial/functions.c:1161
msgid "TBILLYIELD calculates the yield of a treasury bill."
msgstr ""

#: ../plugins/fn-financial/functions.c:1191
msgid "RATE:rate of investment"
msgstr ""

#: ../plugins/fn-financial/functions.c:1193
#: ../plugins/fn-financial/functions.c:1460
#: ../plugins/fn-financial/functions.c:1694
#: ../plugins/fn-financial/functions.c:1843
msgid "pmt:payment at each period"
msgstr ""

#: ../plugins/fn-financial/functions.c:1195
#: ../plugins/fn-financial/functions.c:1308
#: ../plugins/fn-financial/functions.c:1461
#: ../plugins/fn-financial/functions.c:1731
#: ../plugins/fn-financial/functions.c:1762
#: ../plugins/fn-financial/functions.c:1802
#: ../plugins/fn-financial/functions.c:1845
#: ../plugins/fn-financial/functions.c:1936
msgid "fv:future value"
msgstr ""

#: ../plugins/fn-financial/functions.c:1196
#: ../plugins/fn-financial/functions.c:1462
#: ../plugins/fn-financial/functions.c:1696
#: ../plugins/fn-financial/functions.c:1732
#: ../plugins/fn-financial/functions.c:1763
#: ../plugins/fn-financial/functions.c:1803
#: ../plugins/fn-financial/functions.c:1846
#: ../plugins/fn-financial/functions.c:3152
#: ../plugins/fn-financial/functions.c:3196
msgid "type:payment type"
msgstr ""

#: ../plugins/fn-financial/functions.c:1197
#: ../plugins/fn-financial/functions.c:1342
#: ../plugins/fn-financial/functions.c:1600
msgid "guess:an estimate of what the result should be"
msgstr ""

#: ../plugins/fn-financial/functions.c:1198
msgid "RATE calculates the rate of return."
msgstr ""

#: ../plugins/fn-financial/functions.c:1200
#: ../plugins/fn-financial/functions.c:1345
#: ../plugins/fn-financial/functions.c:1602
msgid ""
"The optional @{guess} is needed because there can be more than one valid "
"result.  It defaults to 10%."
msgstr ""

#: ../plugins/fn-financial/functions.c:1305
msgid "RRI:equivalent interest rate for an investment increasing in value"
msgstr ""

#: ../plugins/fn-financial/functions.c:1306
msgid "p:number of periods"
msgstr ""

#: ../plugins/fn-financial/functions.c:1309
msgid ""
"RRI determines an equivalent interest rate for an investment that increases "
"in value. The interest is compounded after each complete period."
msgstr ""

#: ../plugins/fn-financial/functions.c:1311
msgid ""
"Note that @{p} need not be an integer but for fractional value the "
"calculated rate is only approximate."
msgstr ""

#: ../plugins/fn-financial/functions.c:1340
msgid "IRR:internal rate of return"
msgstr ""

#: ../plugins/fn-financial/functions.c:1343
msgid ""
"IRR calculates the internal rate of return of a cash flow with periodic "
"payments.  @{values} lists the payments (negative values) and receipts "
"(positive values) for each period."
msgstr ""

#: ../plugins/fn-financial/functions.c:1457
msgid "PV:present value"
msgstr ""

#: ../plugins/fn-financial/functions.c:1458
#: ../plugins/fn-financial/functions.c:1498
#: ../plugins/fn-financial/functions.c:1692
msgid "rate:effective interest rate per period"
msgstr ""

#: ../plugins/fn-financial/functions.c:1463
msgid ""
"PV calculates the present value of @{fv} which is @{nper} periods into the "
"future, assuming a periodic payment of @{pmt} and an interest rate of @"
"{rate} per period."
msgstr ""

#: ../plugins/fn-financial/functions.c:1497
msgid "NPV:net present value"
msgstr ""

#: ../plugins/fn-financial/functions.c:1499
msgid "value1:cash flow for period 1"
msgstr ""

#: ../plugins/fn-financial/functions.c:1500
msgid "value2:cash flow for period 2"
msgstr ""

#: ../plugins/fn-financial/functions.c:1501
msgid "NPV calculates the net present value of a cash flow."
msgstr ""

#: ../plugins/fn-financial/functions.c:1541
msgid "XNPV:net present value"
msgstr ""

#: ../plugins/fn-financial/functions.c:1544
#: ../plugins/fn-financial/functions.c:1599
msgid "dates:dates of cash flow"
msgstr ""

#: ../plugins/fn-financial/functions.c:1545
msgid "XNPV calculates the net present value of a cash flow at irregular times"
msgstr ""

#: ../plugins/fn-financial/functions.c:1597
msgid "XIRR:internal rate of return"
msgstr ""

#: ../plugins/fn-financial/functions.c:1601
msgid ""
"XIRR calculates the annualized internal rate of return of a cash flow at "
"arbitrary points in time.  @{values} lists the payments (negative values) "
"and receipts (positive values) with one value for each entry in @{dates}."
msgstr ""

#: ../plugins/fn-financial/functions.c:1691
msgid "FV:future value"
msgstr ""

#: ../plugins/fn-financial/functions.c:1697
msgid ""
"FV calculates the future value of @{pv} moved @{nper} periods into the "
"future, assuming a periodic payment of @{pmt} and an interest rate of @"
"{rate} per period."
msgstr ""

#: ../plugins/fn-financial/functions.c:1727
msgid "PMT:payment for annuity"
msgstr ""

#: ../plugins/fn-financial/functions.c:1733
msgid "PMT calculates the payment amount for an annuity."
msgstr ""

#: ../plugins/fn-financial/functions.c:1757
msgid "IPMT:interest payment for period"
msgstr ""

#: ../plugins/fn-financial/functions.c:1764
msgid ""
"IPMT calculates the interest part of an annuity's payment for period number @"
"{per}."
msgstr ""

#: ../plugins/fn-financial/functions.c:1797
msgid "PPMT:interest payment for period"
msgstr ""

#: ../plugins/fn-financial/functions.c:1804
msgid ""
"PPMT calculates the principal part of an annuity's payment for period number "
"@{per}."
msgstr ""

#: ../plugins/fn-financial/functions.c:1841
msgid "NPER:number of periods"
msgstr ""

#: ../plugins/fn-financial/functions.c:1847
msgid ""
"NPER calculates the number of periods of an investment based on periodic "
"constant payments and a constant interest rate."
msgstr ""

#: ../plugins/fn-financial/functions.c:1889
msgid "DURATION:the duration of a security"
msgstr ""

#: ../plugins/fn-financial/functions.c:1892
#: ../plugins/fn-financial/functions.c:3237
msgid "coupon:annual coupon rate"
msgstr ""

#: ../plugins/fn-financial/functions.c:1896
msgid "DURATION calculates the duration of a security."
msgstr ""

#: ../plugins/fn-financial/functions.c:1933
msgid "G_DURATION:the duration of a investment"
msgstr ""

#: ../plugins/fn-financial/functions.c:1937
msgid ""
"G_DURATION calculates the number of periods needed for an investment to "
"attain a desired value."
msgstr ""

#: ../plugins/fn-financial/functions.c:1938
msgid "G_DURATION is the OpenFormula function PDURATION."
msgstr ""

#: ../plugins/fn-financial/functions.c:1966
msgid "FVSCHEDULE:future value"
msgstr ""

#: ../plugins/fn-financial/functions.c:1967
msgid "principal:initial value"
msgstr ""

#: ../plugins/fn-financial/functions.c:1968
msgid "schedule:range of interest rates"
msgstr ""

#: ../plugins/fn-financial/functions.c:1969
msgid ""
"FVSCHEDULE calculates the future value of @{principal} after applying a "
"range of interest rates with compounding."
msgstr ""

#: ../plugins/fn-financial/functions.c:2002
msgid "EURO:equivalent of 1 EUR"
msgstr ""

#: ../plugins/fn-financial/functions.c:2003
msgid "currency:three-letter currency code"
msgstr ""

#: ../plugins/fn-financial/functions.c:2004
msgid ""
"EURO calculates the national currency amount corresponding to 1 EUR for any "
"of the national currencies that were replaced by the Euro on its "
"introduction."
msgstr ""

#: ../plugins/fn-financial/functions.c:2005
msgid ""
"@{currency} must be one of ATS (Austria), BEF (Belgium), CYP (Cyprus), DEM "
"(Germany), EEK (Estonia), ESP (Spain), EUR (Euro), FIM (Finland), FRF "
"(France), GRD (Greece), IEP (Ireland), ITL (Italy), LUF (Luxembourg), MTL "
"(Malta), NLG (The Netherlands), PTE (Portugal), SIT (Slovenia), or SKK "
"(Slovakia)."
msgstr ""

#: ../plugins/fn-financial/functions.c:2024
#: ../plugins/fn-financial/functions.c:2208
msgid "This function is not likely to be useful anymore."
msgstr ""

#: ../plugins/fn-financial/functions.c:2199
msgid "EUROCONVERT:pre-Euro amount from one currency to another"
msgstr ""

#: ../plugins/fn-financial/functions.c:2200
msgid "n:amount"
msgstr ""

#: ../plugins/fn-financial/functions.c:2201
msgid "source:three-letter source currency code"
msgstr ""

#: ../plugins/fn-financial/functions.c:2202
msgid "target:three-letter target currency code"
msgstr ""

#: ../plugins/fn-financial/functions.c:2203
msgid "full_precision:whether to provide the full precision; defaults to false"
msgstr ""

#: ../plugins/fn-financial/functions.c:2204
msgid ""
"triangulation_precision:number of digits (at least 3) to be rounded to after "
"conversion of the source currency to euro; defaults to no rounding"
msgstr ""

#: ../plugins/fn-financial/functions.c:2205
msgid ""
"EUROCONVERT converts @{n} units of currency @{source} to currency @"
"{target}.  The rates used are the official ones used on the introduction of "
"the Euro."
msgstr ""

#: ../plugins/fn-financial/functions.c:2206
msgid ""
"If @{full_precision} is true, the result is not rounded; if it false the "
"result is rounded to 0 or 2 decimals depending on the target currency; "
"defaults to false."
msgstr ""

#: ../plugins/fn-financial/functions.c:2207
msgid ""
"@{source} and @{target} must be one of the currencies listed for the EURO "
"function."
msgstr ""

#: ../plugins/fn-financial/functions.c:2251
msgid "PRICE:price of a security"
msgstr ""

#: ../plugins/fn-financial/functions.c:2259
msgid ""
"PRICE calculates the price per $100 face value of a security that pays "
"periodic interest."
msgstr ""

#: ../plugins/fn-financial/functions.c:2301
msgid "YIELD:yield of a security"
msgstr ""

#: ../plugins/fn-financial/functions.c:2305
#: ../plugins/fn-financial/functions.c:2413
#: ../plugins/fn-financial/functions.c:2460
#: ../plugins/fn-financial/functions.c:2650
#: ../plugins/fn-financial/functions.c:2823
msgid "price:price of security"
msgstr ""

#: ../plugins/fn-financial/functions.c:2309
msgid "YIELD calculates the yield of a security that pays periodic interest."
msgstr ""

#: ../plugins/fn-financial/functions.c:2410
msgid "YIELDDISC:yield of a discounted security"
msgstr ""

#: ../plugins/fn-financial/functions.c:2416
msgid "YIELDDISC calculates the yield of a discounted security."
msgstr ""

#: ../plugins/fn-financial/functions.c:2455
msgid "YIELDMAT:yield of a security"
msgstr ""

#: ../plugins/fn-financial/functions.c:2462
msgid ""
"YIELDMAT calculates the yield of a security for which the interest is paid "
"at maturity date."
msgstr ""

#: ../plugins/fn-financial/functions.c:2494
msgid "ODDFPRICE:price of a security that has an odd first period"
msgstr ""

#: ../plugins/fn-financial/functions.c:2498
#: ../plugins/fn-financial/functions.c:2648
msgid "first_interest:first interest date"
msgstr ""

#: ../plugins/fn-financial/functions.c:2504
msgid ""
"ODDFPRICE calculates the price per $100 face value of a security that pays "
"periodic interest, but has an odd first period."
msgstr ""

#: ../plugins/fn-financial/functions.c:2644
msgid "ODDFYIELD:yield of a security that has an odd first period"
msgstr ""

#: ../plugins/fn-financial/functions.c:2654
msgid ""
"ODDFYIELD calculates the yield of a security that pays periodic interest, "
"but has an odd first period."
msgstr ""

#: ../plugins/fn-financial/functions.c:2740
msgid "ODDLPRICE:price of a security that has an odd last period"
msgstr ""

#: ../plugins/fn-financial/functions.c:2743
#: ../plugins/fn-financial/functions.c:2821
msgid "last_interest:last interest date"
msgstr ""

#: ../plugins/fn-financial/functions.c:2749
msgid ""
"ODDLPRICE calculates the price per $100 face value of a security that pays "
"periodic interest, but has an odd last period."
msgstr ""

#: ../plugins/fn-financial/functions.c:2818
msgid "ODDLYIELD:yield of a security that has an odd last period"
msgstr ""

#: ../plugins/fn-financial/functions.c:2827
msgid ""
"ODDLYIELD calculates the yield of a security that pays periodic interest, "
"but has an odd last period."
msgstr ""

#: ../plugins/fn-financial/functions.c:2896
msgid "AMORDEGRC:depreciation of an asset using French accounting conventions"
msgstr ""

#: ../plugins/fn-financial/functions.c:2898
#: ../plugins/fn-financial/functions.c:2954
msgid "purchase_date:date of purchase"
msgstr ""

#: ../plugins/fn-financial/functions.c:2899
#: ../plugins/fn-financial/functions.c:2955
msgid "first_period:end of first period"
msgstr ""

#: ../plugins/fn-financial/functions.c:2902
#: ../plugins/fn-financial/functions.c:2958
msgid "rate:depreciation rate"
msgstr ""

#: ../plugins/fn-financial/functions.c:2905
msgid ""
"AMORDEGRC calculates the depreciation of an asset using French accounting "
"conventions. Assets purchased in the middle of a period take prorated "
"depreciation into account. This is similar to AMORLINC, except that a "
"depreciation coefficient is applied in the calculation depending on the life "
"of the assets."
msgstr ""

#: ../plugins/fn-financial/functions.c:2909
msgid ""
"The depreciation coefficient used is:\n"
"1.0 for an expected lifetime less than 3 years,\n"
"1.5 for an expected lifetime of at least 3 years but less than 5 years,\n"
"2.0 for an expected lifetime of at least 5 years but at most 6 years,\n"
"2.5 for an expected lifetime of more than 6 years."
msgstr ""

#: ../plugins/fn-financial/functions.c:2914
msgid ""
"Special depreciation rules are applied for the last two periods resulting in "
"a possible total depreciation exceeding the difference of @{cost} - @"
"{salvage}."
msgstr ""

#: ../plugins/fn-financial/functions.c:2916
msgid "Named for AMORtissement DEGRessif Comptabilite."
msgstr ""

#: ../plugins/fn-financial/functions.c:2952
msgid "AMORLINC:depreciation of an asset using French accounting conventions"
msgstr ""

#: ../plugins/fn-financial/functions.c:2961
msgid ""
"AMORLINC calculates the depreciation of an asset using French accounting "
"conventions. Assets purchased in the middle of a period take prorated "
"depreciation into account. "
msgstr ""

#: ../plugins/fn-financial/functions.c:2963
msgid "Named for AMORtissement LINeaire Comptabilite."
msgstr ""

#: ../plugins/fn-financial/functions.c:2998
msgid "COUPDAYBS:number of days from coupon period to settlement"
msgstr ""

#: ../plugins/fn-financial/functions.c:3003
#: ../plugins/fn-financial/functions.c:3027
#: ../plugins/fn-financial/functions.c:3051
#: ../plugins/fn-financial/functions.c:3075
#: ../plugins/fn-financial/functions.c:3101
#: ../plugins/fn-financial/functions.c:3127
msgid "eom:end-of-month flag"
msgstr ""

#: ../plugins/fn-financial/functions.c:3004
msgid ""
"COUPDAYBS calculates the number of days from the beginning of the coupon "
"period to the settlement date."
msgstr ""

#: ../plugins/fn-financial/functions.c:3022
msgid "COUPDAYS:number of days in the coupon period of the settlement date"
msgstr ""

#: ../plugins/fn-financial/functions.c:3028
msgid ""
"COUPDAYS calculates the number of days in the coupon period of the "
"settlement date."
msgstr ""

#: ../plugins/fn-financial/functions.c:3046
msgid ""
"COUPDAYSNC:number of days from the settlement date to the next coupon period"
msgstr ""

#: ../plugins/fn-financial/functions.c:3052
msgid ""
"COUPDAYSNC calculates number of days from the settlement date to the next "
"coupon period."
msgstr ""

#: ../plugins/fn-financial/functions.c:3070
msgid "COUPNCD:the next coupon date after settlement"
msgstr ""

#: ../plugins/fn-financial/functions.c:3076
msgid "COUPNCD calculates the coupon date following settlement."
msgstr ""

#: ../plugins/fn-financial/functions.c:3096
msgid "COUPPCD:the last coupon date before settlement"
msgstr ""

#: ../plugins/fn-financial/functions.c:3102
msgid "COUPPCD calculates the coupon date preceding settlement."
msgstr ""

#: ../plugins/fn-financial/functions.c:3122
msgid "COUPNUM:number of coupons"
msgstr ""

#: ../plugins/fn-financial/functions.c:3128
msgid ""
"COUPNUM calculates the number of coupons to be paid between the settlement "
"and maturity dates, rounded up."
msgstr ""

#: ../plugins/fn-financial/functions.c:3146
msgid "CUMIPMT:cumulative interest payment"
msgstr ""

#: ../plugins/fn-financial/functions.c:3147
#: ../plugins/fn-financial/functions.c:3191
msgid "rate:interest rate per period"
msgstr ""

#: ../plugins/fn-financial/functions.c:3150
#: ../plugins/fn-financial/functions.c:3194
#: ../plugins/fn-financial/functions.c:3283
msgid "start_period:first period to accumulate for"
msgstr ""

#: ../plugins/fn-financial/functions.c:3151
#: ../plugins/fn-financial/functions.c:3195
#: ../plugins/fn-financial/functions.c:3284
msgid "end_period:last period to accumulate for"
msgstr ""

#: ../plugins/fn-financial/functions.c:3153
msgid ""
"CUMIPMT calculates the cumulative interest paid on a loan from @"
"{start_period} to @{end_period}."
msgstr ""

#: ../plugins/fn-financial/functions.c:3190
msgid "CUMPRINC:cumulative principal"
msgstr ""

#: ../plugins/fn-financial/functions.c:3197
msgid ""
"CUMPRINC calculates the cumulative principal paid on a loan from @"
"{start_period} to @{end_period}."
msgstr ""

#: ../plugins/fn-financial/functions.c:3234
msgid "MDURATION:the Macaulay duration of a security"
msgstr ""

#: ../plugins/fn-financial/functions.c:3241
msgid "MDURATION calculates the Macaulay duration of a security."
msgstr ""

#: ../plugins/fn-financial/functions.c:3279
msgid "VDB:depreciation of an asset"
msgstr ""

#: ../plugins/fn-financial/functions.c:3286
msgid "no_switch:do not switch to straight-line depreciation"
msgstr ""

#: ../plugins/fn-financial/functions.c:3287
msgid ""
"VDB calculates the depreciation of an asset for a given period range using "
"the variable-rate declining balance method."
msgstr ""

#: ../plugins/fn-financial/functions.c:3288
msgid ""
"If @{no_switch} is FALSE, the calculation switches to straight-line "
"depreciation when depreciation is greater than the declining balance "
"calculation."
msgstr ""

#: ../plugins/fn-hebrew-date/functions.c:92
msgid "HDATE:Hebrew date"
msgstr ""

#: ../plugins/fn-hebrew-date/functions.c:93
#: ../plugins/fn-hebrew-date/functions.c:162
#: ../plugins/fn-hebrew-date/functions.c:235
#: ../plugins/fn-hebrew-date/functions.c:262
#: ../plugins/fn-hebrew-date/functions.c:289
#: ../plugins/fn-hebrew-date/functions.c:316
msgid "year:Gregorian year of date, defaults to the current year"
msgstr ""

#: ../plugins/fn-hebrew-date/functions.c:94
#: ../plugins/fn-hebrew-date/functions.c:163
#: ../plugins/fn-hebrew-date/functions.c:236
#: ../plugins/fn-hebrew-date/functions.c:263
#: ../plugins/fn-hebrew-date/functions.c:290
#: ../plugins/fn-hebrew-date/functions.c:317
msgid "month:Gregorian month of year, defaults to the current month"
msgstr ""

#: ../plugins/fn-hebrew-date/functions.c:95
#: ../plugins/fn-hebrew-date/functions.c:164
#: ../plugins/fn-hebrew-date/functions.c:237
#: ../plugins/fn-hebrew-date/functions.c:264
#: ../plugins/fn-hebrew-date/functions.c:291
#: ../plugins/fn-hebrew-date/functions.c:318
msgid "day:Gregorian day of month, defaults to the current day"
msgstr ""

#: ../plugins/fn-hebrew-date/functions.c:127
msgid "DATE2HDATE:Hebrew date"
msgstr ""

#: ../plugins/fn-hebrew-date/functions.c:128
#: ../plugins/fn-hebrew-date/functions.c:203
#: ../plugins/fn-hebrew-date/functions.c:342
msgid "date:Gregorian date, defaults to today"
msgstr ""

#: ../plugins/fn-hebrew-date/functions.c:161
msgid "HDATE_HEB:Hebrew date in Hebrew"
msgstr ""

#: ../plugins/fn-hebrew-date/functions.c:202
msgid "DATE2HDATE_HEB:Hebrew date in Hebrew"
msgstr ""

#: ../plugins/fn-hebrew-date/functions.c:234
msgid "HDATE_MONTH:Hebrew month of Gregorian date"
msgstr ""

#: ../plugins/fn-hebrew-date/functions.c:261
msgid "HDATE_DAY:Hebrew day of Gregorian date"
msgstr ""

#: ../plugins/fn-hebrew-date/functions.c:288
msgid "HDATE_YEAR:Hebrew year of Gregorian date"
msgstr ""

#: ../plugins/fn-hebrew-date/functions.c:315
msgid "HDATE_JULIAN:Julian day number for given Gregorian date"
msgstr ""

#: ../plugins/fn-hebrew-date/functions.c:341
msgid "DATE2JULIAN:Julian day number for given Gregorian date"
msgstr ""

#: ../plugins/fn-info/functions.c:68
msgid "CELL:information of @{type} about @{cell}"
msgstr ""

#: ../plugins/fn-info/functions.c:69
msgid "type:string specifying the type of information requested"
msgstr ""

#: ../plugins/fn-info/functions.c:70
msgid "cell:cell reference"
msgstr ""

#: ../plugins/fn-info/functions.c:71
msgid ""
"@{type} specifies the type of information you want to obtain:\n"
"  address        \t\tReturns the given cell reference as text.\n"
"  col            \t\tReturns the number of the column in @{cell}.\n"
"  color          \t\tReturns 0.\n"
"  contents       \t\tReturns the contents of the cell in @{cell}.\n"
"  column         \t\tReturns the number of the column in @{cell}.\n"
"  columnwidth    \tReturns the column width.\n"
"  coord          \t\tReturns the absolute address of @{cell}.\n"
"  datatype       \tsame as type\n"
"  filename       \t\tReturns the name of the file of @{cell}.\n"
"  format         \t\tReturns the code of the format of the cell.\n"
"  formulatype    \tsame as type\n"
"  locked         \t\tReturns 1 if @{cell} is locked.\n"
"  parentheses    \tReturns 1 if @{cell} contains a negative value\n"
"                 \t\tand its format displays it with parentheses.\n"
"  prefix         \t\tReturns a character indicating the horizontal\n"
"                 \t\talignment of @{cell}.\n"
"  prefixcharacter  \tsame as prefix\n"
"  protect        \t\tReturns 1 if @{cell} is locked.\n"
"  row            \t\tReturns the number of the row in @{cell}.\n"
"  sheetname      \tReturns the name of the sheet of @{cell}.\n"
"  type           \t\tReturns \"l\" if @{cell} contains a string, \n"
"                 \t\t\"v\" if it contains some other value, and \n"
"                 \t\t\"b\" if @{cell} is blank.\n"
"  value          \t\tReturns the contents of the cell in @{cell}.\n"
"  width          \t\tReturns the column width."
msgstr ""

#: ../plugins/fn-info/functions.c:1173
msgid "EXPRESSION:expression in @{cell} as a string"
msgstr ""

#: ../plugins/fn-info/functions.c:1174
msgid "cell:a cell reference"
msgstr ""

#: ../plugins/fn-info/functions.c:1175
msgid "If @{cell} contains no expression, EXPRESSION returns empty."
msgstr ""

#: ../plugins/fn-info/functions.c:1210
msgid "GET.FORMULA:the formula in @{cell} as a string"
msgstr ""

#: ../plugins/fn-info/functions.c:1211 ../plugins/fn-info/functions.c:1253
#: ../plugins/fn-info/functions.c:1816
msgid "cell:the referenced cell"
msgstr ""

#: ../plugins/fn-info/functions.c:1212
msgid "GET.FORMULA is the OpenFormula function FORMULA."
msgstr ""

#: ../plugins/fn-info/functions.c:1213
msgid ""
"If A1 is empty and A2 contains =B1+B2, then\n"
"GET.FORMULA(A2) yields '=B1+B2' and\n"
"GET.FORMULA(A1) yields ''."
msgstr ""

#: ../plugins/fn-info/functions.c:1252
msgid "ISFORMULA:TRUE if @{cell} contains a formula"
msgstr ""

#: ../plugins/fn-info/functions.c:1254
msgid "ISFORMULA is OpenFormula compatible."
msgstr ""

#: ../plugins/fn-info/functions.c:1283
msgid "COUNTBLANK:the number of blank cells in @{range}"
msgstr ""

#: ../plugins/fn-info/functions.c:1284
msgid "range:a cell range"
msgstr ""

#: ../plugins/fn-info/functions.c:1286
msgid "COUNTBLANK(A1:A20) returns the number of blank cell in A1:A20."
msgstr ""

#: ../plugins/fn-info/functions.c:1338
msgid ""
"INFO:information about the current operating environment according to @{type}"
msgstr ""

#: ../plugins/fn-info/functions.c:1340
msgid "type:string giving the type of information requested"
msgstr ""

#: ../plugins/fn-info/functions.c:1341
#, fuzzy
msgid ""
"INFO returns information about the current operating environment according "
"to @{type}:\n"
"  memavail     \t\tReturns the amount of memory available, bytes.\n"
"  memused      \tReturns the amount of memory used (bytes).\n"
"  numfile      \t\tReturns the number of active worksheets.\n"
"  osversion    \t\tReturns the operating system version.\n"
"  recalc       \t\tReturns the recalculation mode (automatic).\n"
"  release      \t\tReturns the version of Gnumeric as text.\n"
"  system       \t\tReturns the name of the environment.\n"
"  totmem       \t\tReturns the amount of total memory available."
msgstr ""
"@FUNCTION=INFO\n"
"@SYNTAX=INFO(typ)\n"
"@DESCRIPTION=INFO returnerar information om den aktuella operativmiljön.\n"
"\n"
"@typ är den typ av information som du vill erhålla:\n"
"\n"
"  memavail        \tReturnerar mängden tillgängligt minne (byte).\n"
"  memused         \tReturnerar mängden använt minne (byte).\n"
"  numfile         \t\tReturnerar antalet aktiva arbetsblad.\n"
"  osversion       \t\tReturnerar operativsystemsversionen.\n"
"  recalc          \t\tReturnerar omkalkyleringsläget (automatiskt).\n"
"  release         \t\tReturnerar Gnumerics versionsnummer som text.\n"
"  system          \t\tReturnerar namnet på miljön.\n"
"  totmem          \t\tReturnerar totala mängden tillgängligt minne.\n"
"\n"
"* Denna funktion är kompatibel med Excel, förutom att typkataloger och "
"ursprung inte är implementerade.\n"
"\n"
"@EXAMPLES=\n"
"INFO(\"system\") returnerar \"Linux\" på ett Linuxsystem.\n"
"\n"
"@SEEALSO="

#: ../plugins/fn-info/functions.c:1438
msgid "ISERROR:TRUE if @{value} is any error value"
msgstr ""

#: ../plugins/fn-info/functions.c:1439 ../plugins/fn-info/functions.c:1457
#: ../plugins/fn-info/functions.c:1479 ../plugins/fn-info/functions.c:1569
#: ../plugins/fn-info/functions.c:1607 ../plugins/fn-info/functions.c:1625
#: ../plugins/fn-info/functions.c:1642 ../plugins/fn-info/functions.c:1681
#: ../plugins/fn-info/functions.c:1702 ../plugins/fn-info/functions.c:1752
msgid "value:a value"
msgstr ""

#: ../plugins/fn-info/functions.c:1456
msgid "ISNA:TRUE if @{value} is the #N/A error value"
msgstr ""

#: ../plugins/fn-info/functions.c:1478
msgid "ISERR:TRUE if @{value} is any error value except #N/A"
msgstr ""

#: ../plugins/fn-info/functions.c:1497
msgid "ERROR.TYPE:the type of @{error}"
msgstr ""

#: ../plugins/fn-info/functions.c:1498
msgid "error:an error"
msgstr ""

#: ../plugins/fn-info/functions.c:1499
#, fuzzy
msgid ""
"ERROR.TYPE returns an error number corresponding to the given error value.  "
"The error numbers for error values are:\n"
"\n"
"\t#DIV/0!  \t\t2\n"
"\t#VALUE!  \t3\n"
"\t#REF!    \t\t4\n"
"\t#NAME?   \t5\n"
"\t#NUM!    \t6\n"
"\t#N/A     \t\t7"
msgstr ""
"@FUNCTION=ERROR.TYPE\n"
"@SYNTAX=ERROR.TYPE(värde)\n"
"@DESCRIPTION=ERROR.TYPE returnerar ett felnummer som motsvarar det angivna "
"felvärdet. Felnumren för felvärden är\n"
"\n"
"\t#DIV/0!    \t\t2\n"
"\t#VÄRDE!    \t\t3\n"
"\t#REF!      \t\t4\n"
"\t#NAMN?     \t5\n"
"\t#NUM!      \t\t6\n"
"\t#-         \t\t7\n"
"\n"
"* Denna funktion är kompatibel med Excel.\n"
"\n"
"@EXAMPLES=\n"
"ERROR.TYPE(NA()) är lika med 7.\n"
"\n"
"@SEEALSO=ISERROR"

#: ../plugins/fn-info/functions.c:1533
msgid "NA:the error value #N/A"
msgstr ""

#: ../plugins/fn-info/functions.c:1551
msgid "ERROR:the error with the given @{name}"
msgstr ""

#: ../plugins/fn-info/functions.c:1552
msgid "name:string"
msgstr ""

#: ../plugins/fn-info/functions.c:1568
msgid "ISBLANK:TRUE if @{value} is blank"
msgstr ""

#: ../plugins/fn-info/functions.c:1570
msgid ""
"This function checks if a value is blank.  Empty cells are blank, but empty "
"strings are not."
msgstr ""

#: ../plugins/fn-info/functions.c:1585
msgid "ISEVEN:TRUE if @{n} is even"
msgstr ""

#: ../plugins/fn-info/functions.c:1586 ../plugins/fn-info/functions.c:1660
msgid "n:number"
msgstr ""

#: ../plugins/fn-info/functions.c:1606
msgid "ISLOGICAL:TRUE if @{value} is a logical value"
msgstr ""

#: ../plugins/fn-info/functions.c:1608
msgid "This function checks if a value is either TRUE or FALSE."
msgstr ""

#: ../plugins/fn-info/functions.c:1624
msgid "ISNONTEXT:TRUE if @{value} is not text"
msgstr ""

#: ../plugins/fn-info/functions.c:1641
msgid "ISNUMBER:TRUE if @{value} is a number"
msgstr ""

#: ../plugins/fn-info/functions.c:1643
msgid ""
"This function checks if a value is a number.  Neither TRUE nor FALSE are "
"numbers for this purpose."
msgstr ""

#: ../plugins/fn-info/functions.c:1659
msgid "ISODD:TRUE if @{n} is odd"
msgstr ""

#: ../plugins/fn-info/functions.c:1680
msgid "ISREF:TRUE if @{value} is a reference"
msgstr ""

#: ../plugins/fn-info/functions.c:1682
msgid "This function checks if a value is a cell reference."
msgstr ""

#: ../plugins/fn-info/functions.c:1701
msgid "ISTEXT:TRUE if @{value} is text"
msgstr ""

#: ../plugins/fn-info/functions.c:1719
msgid "N:@{text} converted to a number"
msgstr ""

#: ../plugins/fn-info/functions.c:1720 ../plugins/fn-string/functions.c:321
#: ../plugins/fn-string/functions.c:537 ../plugins/fn-string/functions.c:578
#: ../plugins/fn-string/functions.c:622 ../plugins/fn-string/functions.c:749
#: ../plugins/fn-string/functions.c:973 ../plugins/fn-string/functions.c:1020
#: ../plugins/fn-string/functions.c:1053 ../plugins/fn-string/functions.c:1395
msgid "text:string"
msgstr ""

#: ../plugins/fn-info/functions.c:1721
msgid "If @{text} contains non-numerical text, 0 is returned."
msgstr ""

#: ../plugins/fn-info/functions.c:1724
msgid "=N(\"eleven\")"
msgstr ""

#: ../plugins/fn-info/functions.c:1751
msgid "TYPE:a number indicating the data type of @{value}"
msgstr ""

#: ../plugins/fn-info/functions.c:1753
msgid ""
"TYPE returns a number indicating the data type of @{value}:\n"
"1  \t= number\n"
"2  \t= text\n"
"4  \t= boolean\n"
"16 \t= error\n"
"64 \t= array"
msgstr ""

#: ../plugins/fn-info/functions.c:1792
msgid "GETENV:the value of execution environment variable @{name}"
msgstr ""

#: ../plugins/fn-info/functions.c:1793
msgid "name:the name of the environment variable"
msgstr ""

#: ../plugins/fn-info/functions.c:1794
msgid "If a variable called @{name} does not exist, #N/A! will be returned."
msgstr ""

#: ../plugins/fn-info/functions.c:1795
msgid "Variable names are case sensitive."
msgstr ""

#: ../plugins/fn-info/functions.c:1815
msgid "GET.LINK:the target of the hyperlink attached to @{cell} as a string"
msgstr ""

#: ../plugins/fn-info/functions.c:1817
msgid ""
"The value return is not updated automatically when the link attached to @"
"{cell} changes but requires a recalculation."
msgstr ""

#: ../plugins/fn-logical/functions.c:44
msgid "AND:logical conjunction"
msgstr ""

#: ../plugins/fn-logical/functions.c:45 ../plugins/fn-logical/functions.c:124
#: ../plugins/fn-logical/functions.c:178
msgid "b0:logical value"
msgstr ""

#: ../plugins/fn-logical/functions.c:46 ../plugins/fn-logical/functions.c:125
#: ../plugins/fn-logical/functions.c:179
msgid "b1:logical value"
msgstr ""

#: ../plugins/fn-logical/functions.c:47
msgid "AND calculates the logical conjunction of its arguments @{b0},@{b1},..."
msgstr ""

#: ../plugins/fn-logical/functions.c:48 ../plugins/fn-logical/functions.c:127
#: ../plugins/fn-logical/functions.c:181
msgid ""
"If an argument is numerical, zero is considered FALSE and anything else TRUE."
msgstr ""

#: ../plugins/fn-logical/functions.c:49 ../plugins/fn-logical/functions.c:102
#: ../plugins/fn-logical/functions.c:128 ../plugins/fn-logical/functions.c:182
msgid "Strings and empty values are ignored."
msgstr ""

#: ../plugins/fn-logical/functions.c:50 ../plugins/fn-logical/functions.c:129
#: ../plugins/fn-logical/functions.c:183
msgid "If no logical values are provided, then the error #VALUE! is returned."
msgstr ""

#: ../plugins/fn-logical/functions.c:51 ../plugins/fn-logical/functions.c:130
#: ../plugins/fn-logical/functions.c:184
msgid ""
"This function is strict: if any argument is an error, the result will be the "
"first such error."
msgstr ""

#: ../plugins/fn-logical/functions.c:57
msgid "wiki:en:Logical_conjunction"
msgstr ""

#: ../plugins/fn-logical/functions.c:98
msgid "NOT:logical negation"
msgstr ""

#: ../plugins/fn-logical/functions.c:99
msgid "b:logical value"
msgstr ""

#: ../plugins/fn-logical/functions.c:100
msgid "NOT calculates the logical negation of its argument."
msgstr ""

#: ../plugins/fn-logical/functions.c:101
msgid ""
"If the argument is numerical, zero is considered FALSE and anything else "
"TRUE."
msgstr ""

#: ../plugins/fn-logical/functions.c:107
msgid "wiki:en:Negation"
msgstr ""

#: ../plugins/fn-logical/functions.c:123
msgid "OR:logical disjunction"
msgstr ""

#: ../plugins/fn-logical/functions.c:126
msgid "OR calculates the logical disjunction of its arguments @{b0},@{b1},..."
msgstr ""

#: ../plugins/fn-logical/functions.c:136
msgid "wiki:en:Logical_disjunction"
msgstr ""

#: ../plugins/fn-logical/functions.c:177
msgid "XOR:logical exclusive disjunction"
msgstr ""

#: ../plugins/fn-logical/functions.c:180
msgid ""
"XOR calculates the logical exclusive disjunction of its arguments @{b0},@"
"{b1},..."
msgstr ""

#: ../plugins/fn-logical/functions.c:189
msgid "wiki:en:Exclusive_disjunction"
msgstr ""

#: ../plugins/fn-logical/functions.c:230
msgid "IFERROR:test for error"
msgstr ""

#: ../plugins/fn-logical/functions.c:231
msgid "x:value to test for error"
msgstr ""

#: ../plugins/fn-logical/functions.c:232 ../plugins/fn-logical/functions.c:250
msgid "y:alternate value"
msgstr ""

#: ../plugins/fn-logical/functions.c:233
msgid ""
"This function returns the first value, unless that is an error, in which "
"case it returns the second."
msgstr ""

#: ../plugins/fn-logical/functions.c:248
msgid "IFNA:test for #NA! error"
msgstr ""

#: ../plugins/fn-logical/functions.c:249
msgid "x:value to test for #NA! error"
msgstr ""

#: ../plugins/fn-logical/functions.c:251
msgid ""
"This function returns the first value, unless that is #NA!, in which case it "
"returns the second."
msgstr ""

#: ../plugins/fn-logical/functions.c:267
msgid "TRUE:the value TRUE"
msgstr ""

#: ../plugins/fn-logical/functions.c:268
msgid "TRUE returns the value TRUE."
msgstr ""

#: ../plugins/fn-logical/functions.c:272 ../plugins/fn-logical/functions.c:290
msgid "wiki:en:Logical_value"
msgstr ""

#: ../plugins/fn-logical/functions.c:285
msgid "FALSE:the value FALSE"
msgstr ""

#: ../plugins/fn-logical/functions.c:286
msgid "FALSE returns the value FALSE."
msgstr ""

#: ../plugins/fn-lookup/functions.c:714
msgid "ADDRESS:cell address as text"
msgstr ""

#: ../plugins/fn-lookup/functions.c:715
msgid "row_num:row number"
msgstr ""

#: ../plugins/fn-lookup/functions.c:716
msgid "col_num:column number"
msgstr ""

#: ../plugins/fn-lookup/functions.c:717
msgid ""
"abs_num:1 for an absolute, 2 for a row absolute and column relative, 3 for a "
"row relative and column absolute, and 4 for a relative reference; defaults "
"to 1"
msgstr ""

#: ../plugins/fn-lookup/functions.c:720
msgid ""
"a1:if TRUE, an A1-style reference is provided, otherwise an R1C1-style "
"reference; defaults to TRUE"
msgstr ""

#: ../plugins/fn-lookup/functions.c:722
msgid "text:name of the worksheet, defaults to no sheet"
msgstr ""

#: ../plugins/fn-lookup/functions.c:723
msgid "If @{row_num} or @{col_num} is less than one, ADDRESS returns #VALUE!"
msgstr ""

#: ../plugins/fn-lookup/functions.c:725
msgid "If @{abs_num} is greater than 4 ADDRESS returns #VALUE!"
msgstr ""

#: ../plugins/fn-lookup/functions.c:799
msgid "AREAS:number of areas in @{reference}"
msgstr ""

#: ../plugins/fn-lookup/functions.c:800
msgid "reference:range"
msgstr ""

#: ../plugins/fn-lookup/functions.c:867
msgid "CHOOSE:the (@{index}+1)th argument"
msgstr ""

#: ../plugins/fn-lookup/functions.c:868
msgid "index:positive number"
msgstr ""

#: ../plugins/fn-lookup/functions.c:869
msgid "value1:first value"
msgstr ""

#: ../plugins/fn-lookup/functions.c:870
msgid "value2:second value"
msgstr ""

#: ../plugins/fn-lookup/functions.c:871
msgid "CHOOSE returns its (@{index}+1)th argument."
msgstr ""

#: ../plugins/fn-lookup/functions.c:872
msgid ""
"@{index} is truncated to an integer. If @{index} < 1 or the truncated @"
"{index} > number of values, CHOOSE returns #VALUE!"
msgstr ""

#: ../plugins/fn-lookup/functions.c:914
msgid "VLOOKUP:search the first column of @{range} for @{value}"
msgstr ""

#: ../plugins/fn-lookup/functions.c:915 ../plugins/fn-lookup/functions.c:976
msgid "value:search value"
msgstr ""

#: ../plugins/fn-lookup/functions.c:916 ../plugins/fn-lookup/functions.c:977
msgid "range:range to search"
msgstr ""

#: ../plugins/fn-lookup/functions.c:917
msgid "column:1-based column offset indicating the return values"
msgstr ""

#: ../plugins/fn-lookup/functions.c:918 ../plugins/fn-lookup/functions.c:979
msgid ""
"approximate:if false, an exact match of @{value} must be found; defaults to "
"TRUE"
msgstr ""

#: ../plugins/fn-lookup/functions.c:920
msgid "as_index:if true, the 0-based row offset is returned; defaults to FALSE"
msgstr ""

#: ../plugins/fn-lookup/functions.c:922
msgid ""
"VLOOKUP function finds the row in @{range} that has a first cell similar to @"
"{value}.  If @{approximate} is not true it finds the row with an exact "
"equality. If @{approximate} is true, it finds the last row with first value "
"less than or equal to @{value}. If @{as_index} is true the 0-based row "
"offset is returned."
msgstr ""

#: ../plugins/fn-lookup/functions.c:929 ../plugins/fn-lookup/functions.c:990
msgid ""
"If @{approximate} is true, then the values must be sorted in order of "
"ascending value."
msgstr ""

#: ../plugins/fn-lookup/functions.c:931
msgid "VLOOKUP returns #REF! if @{column} falls outside @{range}."
msgstr ""

#: ../plugins/fn-lookup/functions.c:975
msgid "HLOOKUP:search the first row of @{range} for @{value}"
msgstr ""

#: ../plugins/fn-lookup/functions.c:978
msgid "row:1-based row offset indicating the return values "
msgstr ""

#: ../plugins/fn-lookup/functions.c:981
msgid ""
"as_index:if true, the 0-based column offset is returned; defaults to FALSE"
msgstr ""

#: ../plugins/fn-lookup/functions.c:983
msgid ""
"HLOOKUP function finds the row in @{range} that has a first cell similar to @"
"{value}.  If @{approximate} is not true it finds the column with an exact "
"equality. If @{approximate} is true, it finds the last column with first "
"value less than or equal to @{value}. If @{as_index} is true the 0-based "
"column offset is returned."
msgstr ""

#: ../plugins/fn-lookup/functions.c:992
msgid "HLOOKUP returns #REF! if @{row} falls outside @{range}."
msgstr ""

#: ../plugins/fn-lookup/functions.c:1036
msgid ""
"LOOKUP:contents of @{vector2} at the corresponding location to @{value} in @"
"{vector1}"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1038
msgid "value:value to look up"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1039
msgid "vector1:range to search:"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1040
msgid "vector2:range of return values"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1041
msgid ""
"If  @{vector1} has more rows than columns, LOOKUP searches the first row of @"
"{vector1}, otherwise the first column. If @{vector2} is omitted the return "
"value is taken from the last row or column of @{vector1}."
msgstr ""

#: ../plugins/fn-lookup/functions.c:1045
msgid ""
"If LOOKUP can't find @{value} it uses the largest value less than @{value}."
msgstr ""

#: ../plugins/fn-lookup/functions.c:1047
msgid "The data must be sorted."
msgstr ""

#: ../plugins/fn-lookup/functions.c:1048
msgid "If @{value} is smaller than the first value it returns #N/A."
msgstr ""

#: ../plugins/fn-lookup/functions.c:1049
msgid ""
"If the corresponding location does not exist in @{vector2}, it returns #N/A."
msgstr ""

#: ../plugins/fn-lookup/functions.c:1136
msgid "MATCH:the index of @{seek} in @{vector}"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1137
msgid "seek:value to find"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1138
msgid "vector:n by 1 or 1 by n range to be searched"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1139
msgid ""
"type:+1 (the default) to find the largest value ≤ @{seek}, 0 to find the "
"first value = @{seek}, or-1 to find the smallest value ≥ @{seek}"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1142
msgid "MATCH searches @{vector} for @{seek} and returns the 1-based index."
msgstr ""

#: ../plugins/fn-lookup/functions.c:1143
msgid ""
" For @{type} = -1 the data must be sorted in descending order; for @{type} = "
"+1 the data must be sorted in ascending order."
msgstr ""

#: ../plugins/fn-lookup/functions.c:1145
msgid "If @{seek} could not be found, #N/A is returned."
msgstr ""

#: ../plugins/fn-lookup/functions.c:1146
msgid "If @{vector} is neither n by 1 nor 1 by n, #N/A is returned."
msgstr ""

#: ../plugins/fn-lookup/functions.c:1197
msgid "INDIRECT:contents of the cell pointed to by the @{ref_text} string"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1198
msgid "ref_text:textual reference"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1199
msgid ""
"format:if true, @{ref_text} is given in A1-style, otherwise it is given in "
"R1C1 style; defaults to true"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1201
msgid ""
"If @{ref_text} is not a valid reference in the style determined by @"
"{format}, INDIRECT returns #REF!"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1235
msgid "INDEX:reference to a cell in the given @{array}"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1236
msgid "array:cell or inline array"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1237
msgid "row:desired row, defaults to 1"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1238
msgid "col:desired column, defaults to 1"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1239
msgid "area:from which area to select a cell, defaults to 1"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1240
msgid ""
"INDEX gives a reference to a cell in the given @{array}. The cell is "
"selected by @{row} and @{col}, which count the rows and columns in the array."
msgstr ""

#: ../plugins/fn-lookup/functions.c:1245
msgid ""
"If the reference falls outside the range of @{array}, INDEX returns #REF!"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1247
msgid ""
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
"21.3, 25.9, and 40.1. Then INDEX(A1:A5,4,1,1) equals 25.9"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1336
msgid "COLUMN:vector of column numbers"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1337 ../plugins/fn-lookup/functions.c:1489
msgid "x:reference, defaults to the position of the current expression"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1338
msgid ""
"COLUMN function returns a Nx1 array containing the sequence of integers from "
"the first column to the last column of @{x}."
msgstr ""

#: ../plugins/fn-lookup/functions.c:1341 ../plugins/fn-lookup/functions.c:1493
msgid ""
"If @{x} is neither an array nor a reference nor a range, returns #VALUE!"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1345
msgid "column() in G13 equals 7."
msgstr ""

#: ../plugins/fn-lookup/functions.c:1385
msgid "COLUMNNUMBER:column number for the given column called @{name}"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1386
msgid "name:column name such as \"IV\""
msgstr ""

#: ../plugins/fn-lookup/functions.c:1387
msgid "If @{name} is invalid, COLUMNNUMBER returns #VALUE!"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1412
msgid "COLUMNS:number of columns in @{reference}"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1413
msgid "reference:array or area"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1414
msgid ""
"If @{reference} is neither an array nor a reference nor a range, COLUMNS "
"returns #VALUE!"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1430
msgid "OFFSET:an offset cell range"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1431
msgid "range:reference or range"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1432
msgid "row:number of rows to offset @{range}"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1433
msgid "col:number of columns to offset @{range}"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1434
msgid "height:height of the offset range, defaults to height of @{range}"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1435
msgid "width:width of the offset range, defaults to width of @{range}"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1436
msgid ""
"OFFSET returns the cell range starting at offset (@{row},@{col}) from @"
"{range} of height @{height} and width @{width}."
msgstr ""

#: ../plugins/fn-lookup/functions.c:1439
msgid "If @{range} is neither a reference nor a range, OFFSET returns #VALUE!"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1488
msgid "ROW:vector of row numbers"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1490
msgid ""
"ROW function returns a 1xN array containing the sequence of integers from "
"the first row to the last row of @{x}."
msgstr ""

#: ../plugins/fn-lookup/functions.c:1536
msgid "ROWS:number of rows in @{reference}"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1537
msgid "reference:array, reference, or range"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1538
msgid ""
"If @{reference} is neither an array nor a reference nor a range, ROWS "
"returns #VALUE!"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1554
msgid "SHEETS:number of sheets in @{reference}"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1555
msgid "reference:array, reference, or range, defaults to the maximum range"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1556
msgid ""
"If @{reference} is neither an array nor a reference nor a range, SHEETS "
"returns #VALUE!"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1592
msgid "SHEET:sheet number of @{reference}"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1593
msgid ""
"reference:reference or literal sheet name, defaults to the current sheet"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1594
msgid ""
"If @{reference} is neither a reference nor a literal sheet name, SHEET "
"returns #VALUE!"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1643
msgid "HYPERLINK:second or first arguments"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1644
msgid "link_location:string"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1645
msgid "label:string, optional"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1646
msgid ""
"HYPERLINK function currently returns its 2nd argument, or if that is omitted "
"the 1st argument."
msgstr ""

#: ../plugins/fn-lookup/functions.c:1665
msgid "TRANSPOSE:the transpose of @{matrix}"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1666
msgid "matrix:range"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1702
msgid "ARRAY:vertical array of the arguments"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1703
msgid "v:value"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1759
msgid "SORT:sorted list of numbers as vertical array"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1760 ../plugins/fn-stat/functions.c:163
#: ../plugins/fn-stat/functions.c:215
msgid "ref:list of numbers"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1761
msgid "order:0 (descending order) or 1 (ascending order); defaults to 0"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1762
msgid "Strings, booleans, and empty cells are ignored."
msgstr ""

#: ../plugins/fn-lookup/functions.c:1763
msgid "SORT({4,3,5}) evaluates to {5,4,3}"
msgstr ""

#: ../plugins/fn-math/functions.c:48
msgid ""
"Numbers, text and logical values are included in the calculation too. If the "
"cell contains text or the argument evaluates to FALSE, it is counted as "
"value zero (0). If the argument evaluates to TRUE, it is counted as one (1)."
msgstr ""

#: ../plugins/fn-math/functions.c:56
msgid "GCD:the greatest common divisor"
msgstr ""

#: ../plugins/fn-math/functions.c:57 ../plugins/fn-math/functions.c:120
msgid "n0:positive integer"
msgstr ""

#: ../plugins/fn-math/functions.c:58 ../plugins/fn-math/functions.c:121
msgid "n1:positive integer"
msgstr ""

#: ../plugins/fn-math/functions.c:59
msgid ""
"GCD calculates the greatest common divisor of the given numbers @{n0},@"
"{n1},..., the greatest integer that is a divisor of each argument."
msgstr ""

#: ../plugins/fn-math/functions.c:60 ../plugins/fn-math/functions.c:123
msgid "If any of the arguments is not an integer, it is truncated."
msgstr ""

#: ../plugins/fn-math/functions.c:119
msgid "LCM:the least common multiple"
msgstr ""

#: ../plugins/fn-math/functions.c:122
msgid ""
"LCM calculates the least common multiple of the given numbers @{n0},@"
"{n1},..., the smallest integer that is a multiple of each argument."
msgstr ""

#: ../plugins/fn-math/functions.c:175
msgid "GD:Gudermannian function"
msgstr ""

#: ../plugins/fn-math/functions.c:176 ../plugins/fn-math/functions.c:288
#: ../plugins/fn-stat/functions.c:1691
msgid "x:value"
msgstr ""

#: ../plugins/fn-math/functions.c:179
msgid "wolfram:Gudermannian.html"
msgstr ""

#: ../plugins/fn-math/functions.c:180
msgid "wiki:en:Gudermannian_function"
msgstr ""

#: ../plugins/fn-math/functions.c:199
msgid "HYPOT:the square root of the sum of the squares of the arguments"
msgstr ""

#: ../plugins/fn-math/functions.c:200
msgid "n0:number"
msgstr ""

#: ../plugins/fn-math/functions.c:201
msgid "n1:number"
msgstr ""

#: ../plugins/fn-math/functions.c:222
msgid "ABS:absolute value"
msgstr ""

#: ../plugins/fn-math/functions.c:224
msgid ""
"ABS gives the absolute value of @{x}, i.e. the non-negative number of the "
"same magnitude as @{x}."
msgstr ""

#: ../plugins/fn-math/functions.c:241
msgid "ACOS:the arc cosine of @{x}"
msgstr ""

#: ../plugins/fn-math/functions.c:264
msgid "ACOSH:the hyperbolic arc cosine of @{x}"
msgstr ""

#: ../plugins/fn-math/functions.c:287
msgid "ACOT:inverse cotangent of @{x}"
msgstr ""

#: ../plugins/fn-math/functions.c:291
msgid "wolfram:InverseCotangent.html"
msgstr ""

#: ../plugins/fn-math/functions.c:292 ../plugins/fn-math/functions.c:754
#: ../plugins/fn-math/functions.c:793 ../plugins/fn-math/functions.c:1347
#: ../plugins/fn-math/functions.c:1367 ../plugins/fn-math/functions.c:1407
msgid "wiki:en:Trigonometric_functions"
msgstr ""

#: ../plugins/fn-math/functions.c:305
msgid "ACOTH:the inverse hyperbolic cotangent of @{x}"
msgstr ""

#: ../plugins/fn-math/functions.c:309
msgid "wolfram:InverseHyperbolicCotangent.html"
msgstr ""

#: ../plugins/fn-math/functions.c:310
msgid "wiki:en:Inverse_hyperbolic_function"
msgstr ""

#: ../plugins/fn-math/functions.c:323
msgid "ASIN:the arc sine of @{x}"
msgstr ""

#: ../plugins/fn-math/functions.c:325
msgid ""
"ASIN calculates the arc sine of @{x}; that is the value whose sine is @{x}."
msgstr ""

#: ../plugins/fn-math/functions.c:327
msgid "If @{x} falls outside the range -1 to 1, ASIN returns #NUM!"
msgstr ""

#: ../plugins/fn-math/functions.c:348
msgid "ASINH:the inverse hyperbolic sine of @{x}"
msgstr ""

#: ../plugins/fn-math/functions.c:350
msgid ""
"ASINH calculates the inverse hyperbolic sine of @{x}; that is the value "
"whose hyperbolic sine is @{x}."
msgstr ""

#: ../plugins/fn-math/functions.c:367
msgid "ATAN:the arc tangent of @{x}"
msgstr ""

#: ../plugins/fn-math/functions.c:369
msgid ""
"ATAN calculates the arc tangent of @{x}; that is the value whose tangent is @"
"{x}."
msgstr ""

#: ../plugins/fn-math/functions.c:386
msgid "ATANH:the inverse hyperbolic tangent of @{x}"
msgstr ""

#: ../plugins/fn-math/functions.c:388
msgid ""
"ATANH calculates the inverse hyperbolic tangent of @{x}; that is the value "
"whose hyperbolic tangent is @{x}."
msgstr ""

#: ../plugins/fn-math/functions.c:390
msgid "If the absolute value of @{x} is greater than 1.0, ATANH returns #NUM!"
msgstr ""

#: ../plugins/fn-math/functions.c:411
msgid "ATAN2:the arc tangent of the ratio @{y}/@{x}"
msgstr ""

#: ../plugins/fn-math/functions.c:413
msgid "x:x-coordinate"
msgstr ""

#: ../plugins/fn-math/functions.c:414
msgid "y:y-coordinate"
msgstr ""

#: ../plugins/fn-math/functions.c:415
msgid ""
"ATAN2 calculates the direction from the origin to the point (@{x},@{y}) as "
"an angle from the x-axis in radians."
msgstr ""

#: ../plugins/fn-math/functions.c:419
msgid "The result will be between π and +π."
msgstr ""

#: ../plugins/fn-math/functions.c:421
msgid "The order of the arguments may be unexpected."
msgstr ""

#: ../plugins/fn-math/functions.c:446
msgid "CEIL:smallest integer larger than or equal to @{x}"
msgstr ""

#: ../plugins/fn-math/functions.c:448
msgid "CEIL(@{x}) is the smallest integer that is at least as large as @{x}."
msgstr ""

#: ../plugins/fn-math/functions.c:449
msgid "This function is the OpenFormula function CEILING(@{x})."
msgstr ""

#: ../plugins/fn-math/functions.c:466
msgid "COUNTIF:count of the cells meeting the given @{criteria}"
msgstr ""

#: ../plugins/fn-math/functions.c:467 ../plugins/fn-math/functions.c:540
#: ../plugins/fn-math/functions.c:652
msgid "range:cell area"
msgstr ""

#: ../plugins/fn-math/functions.c:468
msgid "criteria:condition for a cell to be counted"
msgstr ""

#: ../plugins/fn-math/functions.c:539
msgid ""
"SUMIF:sum of the cells in @{actual_range} for which the corresponding cells "
"in the range meet the given @{criteria}"
msgstr ""

#: ../plugins/fn-math/functions.c:541
msgid "criteria:condition for a cell to be summed"
msgstr ""

#: ../plugins/fn-math/functions.c:542 ../plugins/fn-math/functions.c:654
msgid "actual_range:cell area, defaults to @{range}"
msgstr ""

#: ../plugins/fn-math/functions.c:651
msgid ""
"AVERAGEIF:average of the cells in @{actual range} for which the "
"corresponding cells in the range meet the given @{criteria}"
msgstr ""

#: ../plugins/fn-math/functions.c:653
msgid "criteria:condition for a cell to be included"
msgstr ""

#: ../plugins/fn-math/functions.c:717
msgid ""
"CEILING:nearest multiple of @{significance} whose absolute value is at least "
"ABS(@{x})"
msgstr ""

#: ../plugins/fn-math/functions.c:719 ../plugins/fn-math/functions.c:1072
msgid ""
"significance:base multiple (defaults to 1 for @{x} > 0 and -1 for @{x} <0)"
msgstr ""

#: ../plugins/fn-math/functions.c:720
msgid ""
"CEILING(@{x},@{significance}) is the nearest multiple of @{significance} "
"whose absolute value is at least ABS(@{x})."
msgstr ""

#: ../plugins/fn-math/functions.c:721
msgid ""
"If @{x} or @{significance} is non-numeric, CEILING returns a #VALUE! error."
msgstr ""

#: ../plugins/fn-math/functions.c:722
msgid ""
"If @{x} and @{significance} have different signs, CEILING returns a #NUM! "
"error."
msgstr ""

#: ../plugins/fn-math/functions.c:724
msgid ""
"CEILING(@{x}) is exported to ODF as CEILING(@{x},SIGN(@{x}),1). CEILING(@{x},"
"@{significance}) is the OpenFormula function CEILING(@{x},@{significance},1)."
msgstr ""

#: ../plugins/fn-math/functions.c:750
msgid "COS:the cosine of @{x}"
msgstr ""

#: ../plugins/fn-math/functions.c:751 ../plugins/fn-math/functions.c:825
#: ../plugins/fn-math/functions.c:1342 ../plugins/fn-math/functions.c:1361
#: ../plugins/fn-math/functions.c:1401 ../plugins/fn-math/functions.c:1574
msgid "x:angle in radians"
msgstr ""

#: ../plugins/fn-math/functions.c:753
msgid "wolfram:Cosine.html"
msgstr ""

#: ../plugins/fn-math/functions.c:770
msgid "COSH:the hyperbolic cosine of @{x}"
msgstr ""

#: ../plugins/fn-math/functions.c:788
msgid "COT:the cotangent of @{x}"
msgstr ""

#: ../plugins/fn-math/functions.c:792
msgid "wolfram:Cotangent.html"
msgstr ""

#: ../plugins/fn-math/functions.c:806
msgid "COTH:the hyperbolic cotangent of @{x}"
msgstr ""

#: ../plugins/fn-math/functions.c:810
msgid "wolfram:HyperbolicCotangent.html"
msgstr ""

#: ../plugins/fn-math/functions.c:811 ../plugins/fn-math/functions.c:1387
#: ../plugins/fn-math/functions.c:1427
msgid "wiki:en:Hyperbolic_function"
msgstr ""

#: ../plugins/fn-math/functions.c:824
msgid "DEGREES:equivalent degrees to @{x} radians"
msgstr ""

#: ../plugins/fn-math/functions.c:842
msgid "EXP:e raised to the power of @{x}"
msgstr ""

#: ../plugins/fn-math/functions.c:844
msgid "e is the base of the natural logarithm."
msgstr ""

#: ../plugins/fn-math/functions.c:860
msgid "EXPM1:EXP(@{x})-1"
msgstr ""

#: ../plugins/fn-math/functions.c:862
msgid ""
"This function has a higher resulting precision than evaluating EXP(@{x})-1."
msgstr ""

#: ../plugins/fn-math/functions.c:877
msgid "FACT:the factorial of @{x}, i.e. @{x}!"
msgstr ""

#: ../plugins/fn-math/functions.c:880
msgid "The domain of this function has been extended using the GAMMA function."
msgstr ""

#: ../plugins/fn-math/functions.c:908
msgid "GAMMA:the Gamma function"
msgstr ""

#: ../plugins/fn-math/functions.c:938
msgid "GAMMALN:natural logarithm of the Gamma function"
msgstr ""

#: ../plugins/fn-math/functions.c:962
msgid "BETA:Euler beta function"
msgstr ""

#: ../plugins/fn-math/functions.c:964 ../plugins/fn-math/functions.c:988
#: ../plugins/fn-math/functions.c:1204
msgid "y:number"
msgstr ""

#: ../plugins/fn-math/functions.c:965
msgid ""
"BETA function returns the value of the Euler beta function extended to all "
"real numbers except 0 and negative integers."
msgstr ""

#: ../plugins/fn-math/functions.c:966
msgid ""
"If @{x}, @{y}, or (@{x} + @{y}) are non-positive integers, BETA returns #NUM!"
msgstr ""

#: ../plugins/fn-math/functions.c:970 ../plugins/fn-math/functions.c:994
msgid "wiki:en:Beta_function"
msgstr ""

#: ../plugins/fn-math/functions.c:986
msgid ""
"BETALN:natural logarithm of the absolute value of the Euler beta function"
msgstr ""

#: ../plugins/fn-math/functions.c:989
msgid ""
"BETALN function returns the natural logarithm of the absolute value of the "
"Euler beta function extended to all real numbers except 0 and negative "
"integers."
msgstr ""

#: ../plugins/fn-math/functions.c:990
msgid ""
"If @{x}, @{y}, or (@{x} + @{y}) are non-positive integers, BETALN returns "
"#NUM!"
msgstr ""

#: ../plugins/fn-math/functions.c:1011
msgid "COMBIN:binomial coefficient"
msgstr ""

#: ../plugins/fn-math/functions.c:1012 ../plugins/fn-math/functions.c:1044
#: ../plugins/fn-math/functions.c:2121
msgid "n:non-negative integer"
msgstr ""

#: ../plugins/fn-math/functions.c:1013 ../plugins/fn-math/functions.c:1045
msgid "k:non-negative integer"
msgstr ""

#: ../plugins/fn-math/functions.c:1014
msgid ""
"COMBIN returns the binomial coefficient \"@{n} choose @{k}\", the number of @"
"{k}-combinations of an @{n}-element set without repetition."
msgstr ""

#: ../plugins/fn-math/functions.c:1017
msgid "If @{n} is less than @{k} COMBIN returns #NUM!"
msgstr ""

#: ../plugins/fn-math/functions.c:1022
msgid "wiki:en:Binomial_coefficient"
msgstr ""

#: ../plugins/fn-math/functions.c:1042
msgid ""
"COMBINA:the number of @{k}-combinations of an @{n}-element set with "
"repetition"
msgstr ""

#: ../plugins/fn-math/functions.c:1050
msgid "wiki:en:Multiset"
msgstr ""

#: ../plugins/fn-math/functions.c:1070
msgid ""
"FLOOR:nearest multiple of @{significance} whose absolute value is at most ABS"
"(@{x})"
msgstr ""

#: ../plugins/fn-math/functions.c:1074
msgid ""
"FLOOR(@{x},@{significance}) is the nearest multiple of @{significance} whose "
"absolute value is at most ABS(@{x})"
msgstr ""

#: ../plugins/fn-math/functions.c:1076
msgid ""
"FLOOR(@{x}) is exported to ODF as FLOOR(@{x},SIGN(@{x}),1). FLOOR(@{x},@"
"{significance}) is the OpenFormula function FLOOR(@{x},@{significance},1)."
msgstr ""

#: ../plugins/fn-math/functions.c:1106
msgid "INT:largest integer not larger than @{x}"
msgstr ""

#: ../plugins/fn-math/functions.c:1125
msgid "LOG:logarithm of @{x} with base @{base}"
msgstr ""

#: ../plugins/fn-math/functions.c:1126 ../plugins/fn-math/functions.c:1156
#: ../plugins/fn-math/functions.c:1179 ../plugins/fn-math/functions.c:1234
#: ../plugins/fn-math/functions.c:1256
msgid "x:positive number"
msgstr ""

#: ../plugins/fn-math/functions.c:1127
msgid "base:base of the logarithm, defaults to 10"
msgstr ""

#: ../plugins/fn-math/functions.c:1128
msgid "@{base} must be positive and not equal to 1."
msgstr ""

#: ../plugins/fn-math/functions.c:1129
msgid "If @{x} ≤ 0, LOG returns #NUM! error."
msgstr ""

#: ../plugins/fn-math/functions.c:1155
msgid "LN:the natural logarithm of @{x}"
msgstr ""

#: ../plugins/fn-math/functions.c:1157
msgid "If @{x} ≤ 0, LN returns #NUM! error."
msgstr ""

#: ../plugins/fn-math/functions.c:1178
msgid "LN1P:LN(1+@{x})"
msgstr ""

#: ../plugins/fn-math/functions.c:1180
msgid ""
"LN1P calculates LN(1+@{x}) but yielding a higher precision than evaluating LN"
"(1+@{x})."
msgstr ""

#: ../plugins/fn-math/functions.c:1181
msgid "If @{x} ≤ -1, LN returns #NUM! error."
msgstr ""

#: ../plugins/fn-math/functions.c:1202
msgid "POWER:the value of @{x} raised to the power @{y}"
msgstr ""

#: ../plugins/fn-math/functions.c:1205
msgid "If both @{x} and @{y} equal 0, POWER returns #NUM!"
msgstr ""

#: ../plugins/fn-math/functions.c:1206
msgid "If @{x} = 0 and @{y} < 0, POWER returns #DIV/0!"
msgstr ""

#: ../plugins/fn-math/functions.c:1207
msgid "If @{x} < 0 and @{y} is not an integer, POWER returns #NUM!"
msgstr ""

#: ../plugins/fn-math/functions.c:1233
msgid "LOG2:the base-2 logarithm of @{x}"
msgstr ""

#: ../plugins/fn-math/functions.c:1235
msgid "If @{x} ≤ 0, LOG2 returns #NUM!"
msgstr ""

#: ../plugins/fn-math/functions.c:1255
msgid "LOG10:the base-10 logarithm of @{x}"
msgstr ""

#: ../plugins/fn-math/functions.c:1257
msgid "If @{x} ≤ 0, LOG10 returns #NUM!"
msgstr ""

#: ../plugins/fn-math/functions.c:1277
msgid "MOD:the remainder of @{x} under division by @{n}"
msgstr ""

#: ../plugins/fn-math/functions.c:1280
msgid "MOD function returns the remainder when @{x} is divided by @{n}."
msgstr ""

#: ../plugins/fn-math/functions.c:1281
msgid "If @{n} is 0, MOD returns #DIV/0!"
msgstr ""

#: ../plugins/fn-math/functions.c:1323
msgid "RADIANS:the number of radians equivalent to @{x} degrees"
msgstr ""

#: ../plugins/fn-math/functions.c:1324
msgid "x:angle in degrees"
msgstr ""

#: ../plugins/fn-math/functions.c:1341
msgid "SIN:the sine of @{x}"
msgstr ""

#: ../plugins/fn-math/functions.c:1346
msgid "wolfram:Sine.html"
msgstr ""

#: ../plugins/fn-math/functions.c:1360
msgid "CSC:the cosecant of @{x}"
msgstr ""

#: ../plugins/fn-math/functions.c:1362 ../plugins/fn-math/functions.c:1382
#: ../plugins/fn-math/functions.c:1402 ../plugins/fn-math/functions.c:1422
msgid "This function is not Excel compatible."
msgstr ""

#: ../plugins/fn-math/functions.c:1366
msgid "wolfram:Cosecant.html"
msgstr ""

#: ../plugins/fn-math/functions.c:1380
msgid "CSCH:the hyperbolic cosecant of @{x}"
msgstr ""

#: ../plugins/fn-math/functions.c:1386
msgid "wolfram:HyperbolicCosecant.html"
msgstr ""

#: ../plugins/fn-math/functions.c:1400
msgid "SEC:Secant"
msgstr ""

#: ../plugins/fn-math/functions.c:1403
msgid "SEC(@{x}) is exported to OpenFormula as 1/COS(@{x})."
msgstr ""

#: ../plugins/fn-math/functions.c:1406
msgid "wolfram:Secant.html"
msgstr ""

#: ../plugins/fn-math/functions.c:1420
msgid "SECH:the hyperbolic secant of @{x}"
msgstr ""

#: ../plugins/fn-math/functions.c:1423
msgid "SECH(@{x}) is exported to OpenFormula as 1/COSH(@{x})."
msgstr ""

#: ../plugins/fn-math/functions.c:1426
msgid "wolfram:HyperbolicSecant.html"
msgstr ""

#: ../plugins/fn-math/functions.c:1438
msgid "SINH:the hyperbolic sine of @{x}"
msgstr ""

#: ../plugins/fn-math/functions.c:1456
msgid "SQRT:square root of @{x}"
msgstr ""

#: ../plugins/fn-math/functions.c:1457 ../plugins/fn-math/functions.c:1863
msgid "x:non-negative number"
msgstr ""

#: ../plugins/fn-math/functions.c:1459
msgid "If @{x} is negative, SQRT returns #NUM!"
msgstr ""

#: ../plugins/fn-math/functions.c:1478
msgid "SUMA:sum of all values and cells referenced"
msgstr ""

#: ../plugins/fn-math/functions.c:1479 ../plugins/fn-math/functions.c:1503
msgid "area0:first cell area"
msgstr ""

#: ../plugins/fn-math/functions.c:1480 ../plugins/fn-math/functions.c:1504
msgid "area1:second cell area"
msgstr ""

#: ../plugins/fn-math/functions.c:1502
msgid "SUMSQ:sum of the squares of all values and cells referenced"
msgstr ""

#: ../plugins/fn-math/functions.c:1525
msgid ""
"MULTINOMIAL:multinomial coefficient (@{x1}+⋯+@{xn}) choose (@{x1},…,@{xn})"
msgstr ""

#: ../plugins/fn-math/functions.c:1526
msgid "x1:first number"
msgstr ""

#: ../plugins/fn-math/functions.c:1527
msgid "x2:second number"
msgstr ""

#: ../plugins/fn-math/functions.c:1528
msgid "xn:nth number"
msgstr ""

#: ../plugins/fn-math/functions.c:1532
msgid "wiki:en:Multinomial_theorem"
msgstr ""

#: ../plugins/fn-math/functions.c:1550
msgid "G_PRODUCT:product of all the values and cells referenced"
msgstr ""

#: ../plugins/fn-math/functions.c:1551
msgid "x1:number"
msgstr ""

#: ../plugins/fn-math/functions.c:1552
msgid "x2:number"
msgstr ""

#: ../plugins/fn-math/functions.c:1553
msgid "Empty cells are ignored and the empty product is 1."
msgstr ""

#: ../plugins/fn-math/functions.c:1573
msgid "TAN:the tangent of @{x}"
msgstr ""

#: ../plugins/fn-math/functions.c:1590
msgid "TANH:the hyperbolic tangent of @{x}"
msgstr ""

#: ../plugins/fn-math/functions.c:1607
msgid "PI:the constant π"
msgstr ""

#: ../plugins/fn-math/functions.c:1608
msgid ""
"This function is Excel compatible, but it returns π with a better precision."
msgstr ""

#: ../plugins/fn-math/functions.c:1623
msgid "TRUNC:@{x} truncated to @{d} digits"
msgstr ""

#: ../plugins/fn-math/functions.c:1625
msgid "d:non-negative integer, defaults to 0"
msgstr ""

#: ../plugins/fn-math/functions.c:1626
msgid ""
"If @{d} is omitted or negative then it defaults to zero. If it is not an "
"integer then it is truncated to an integer."
msgstr ""

#: ../plugins/fn-math/functions.c:1660
msgid "EVEN:@{x} rounded away from 0 to the next even integer"
msgstr ""

#: ../plugins/fn-math/functions.c:1695
msgid "ODD:@{x} rounded away from 0 to the next odd integer"
msgstr ""

#: ../plugins/fn-math/functions.c:1730
msgid "FACTDOUBLE:double factorial"
msgstr ""

#: ../plugins/fn-math/functions.c:1731
msgid "x:non-negative integer"
msgstr ""

#: ../plugins/fn-math/functions.c:1732
msgid "FACTDOUBLE function returns the double factorial @{x}!!"
msgstr ""

#: ../plugins/fn-math/functions.c:1733
msgid ""
"If @{x} is not an integer, it is truncated. If @{x} is negative, FACTDOUBLE "
"returns #NUM!"
msgstr ""

#: ../plugins/fn-math/functions.c:1767
msgid "FIB:Fibonacci numbers"
msgstr ""

#: ../plugins/fn-math/functions.c:1768 ../plugins/fn-numtheory/numtheory.c:219
#: ../plugins/fn-numtheory/numtheory.c:253
#: ../plugins/fn-numtheory/numtheory.c:294
#: ../plugins/fn-numtheory/numtheory.c:326
#: ../plugins/fn-numtheory/numtheory.c:386
#: ../plugins/fn-numtheory/numtheory.c:442
#: ../plugins/fn-numtheory/numtheory.c:473
msgid "n:positive integer"
msgstr ""

#: ../plugins/fn-math/functions.c:1769
msgid "FIB(@{n}) is the @{n}th Fibonacci number."
msgstr ""

#: ../plugins/fn-math/functions.c:1770
msgid ""
"If @{n} is not an integer, it is truncated. If it is negative or zero FIB "
"returns #NUM!"
msgstr ""

#: ../plugins/fn-math/functions.c:1808
msgid "QUOTIENT:integer portion of a division"
msgstr ""

#: ../plugins/fn-math/functions.c:1809
msgid "numerator:integer"
msgstr ""

#: ../plugins/fn-math/functions.c:1810
msgid "denominator:non-zero integer"
msgstr ""

#: ../plugins/fn-math/functions.c:1811
msgid ""
"QUOTIENT yields the integer portion of the division @{numerator}/@"
"{denominator}.\n"
"QUOTIENT (@{numerator},@{denominator})⨉@{denominator}+MOD(@{numerator},@"
"{denominator})=@{numerator}"
msgstr ""

#: ../plugins/fn-math/functions.c:1835
msgid "SIGN:sign of @{x}"
msgstr ""

#: ../plugins/fn-math/functions.c:1837
msgid ""
"SIGN returns 1 if the @{x} is positive and it returns -1 if @{x} is negative."
msgstr ""

#: ../plugins/fn-math/functions.c:1862
msgid "SQRTPI:the square root of @{x} times π"
msgstr ""

#: ../plugins/fn-math/functions.c:1884
msgid "ROUNDDOWN:@{x} rounded towards 0"
msgstr ""

#: ../plugins/fn-math/functions.c:1886 ../plugins/fn-math/functions.c:1910
#: ../plugins/fn-math/functions.c:1951
msgid "d:integer, defaults to 0"
msgstr ""

#: ../plugins/fn-math/functions.c:1887
msgid ""
"If @{d} is greater than zero, @{x} is rounded toward 0 to the given number "
"of digits.\n"
"If @{d} is zero, @{x} is rounded toward 0 to the next integer.\n"
"If @{d} is less than zero, @{x} is rounded toward 0 to the left of the "
"decimal point"
msgstr ""

#: ../plugins/fn-math/functions.c:1908
msgid "ROUND:rounded @{x}"
msgstr ""

#: ../plugins/fn-math/functions.c:1911
msgid ""
"If @{d} is greater than zero, @{x} is rounded to the given number of "
"digits.\n"
"If @{d} is zero, @{x} is rounded to the next integer.\n"
"If @{d} is less than zero, @{x} is rounded to the left of the decimal point"
msgstr ""

#: ../plugins/fn-math/functions.c:1949
msgid "ROUNDUP:@{x} rounded away from 0"
msgstr ""

#: ../plugins/fn-math/functions.c:1952
msgid ""
"If @{d} is greater than zero, @{x} is rounded away from 0 to the given "
"number of digits.\n"
"If @{d} is zero, @{x} is rounded away from 0 to the next integer.\n"
"If @{d} is less than zero, @{x} is rounded away from 0 to the left of the "
"decimal point"
msgstr ""

#: ../plugins/fn-math/functions.c:1996
msgid "MROUND:@{x} rounded to a multiple of @{m}"
msgstr ""

#: ../plugins/fn-math/functions.c:1998
msgid "m:number"
msgstr ""

#: ../plugins/fn-math/functions.c:1999
msgid "If @{x} and @{m} have different sign, MROUND returns #NUM!"
msgstr ""

#: ../plugins/fn-math/functions.c:2042
msgid "ARABIC:the Roman numeral @{roman} as number"
msgstr ""

#: ../plugins/fn-math/functions.c:2043
msgid "roman:Roman numeral"
msgstr ""

#: ../plugins/fn-math/functions.c:2044
msgid ""
"Any Roman symbol to the left of a larger symbol (directly or indirectly) "
"reduces the final value by the symbol amount, otherwise, it increases the "
"final amount by the symbol's amount."
msgstr ""

#: ../plugins/fn-math/functions.c:2120
msgid "ROMAN:@{n} as a roman numeral text"
msgstr ""

#: ../plugins/fn-math/functions.c:2122
msgid "type:0,1,2,3,or 4, defaults to 0"
msgstr ""

#: ../plugins/fn-math/functions.c:2123
msgid ""
"ROMAN returns the arabic number @{n} as a roman numeral text.\n"
"If @{type} is 0 or it is omitted, ROMAN returns classic roman numbers.\n"
"Type 1 is more concise than classic type, type 2 is more concise than type "
"1, and type 3 is more concise than type 2. Type 4 is a simplified type."
msgstr ""

#: ../plugins/fn-math/functions.c:2370
msgid "SUMX2MY2:sum of the difference of squares"
msgstr ""

#: ../plugins/fn-math/functions.c:2371 ../plugins/fn-math/functions.c:2413
#: ../plugins/fn-math/functions.c:2456
msgid "array0:first cell area"
msgstr ""

#: ../plugins/fn-math/functions.c:2372 ../plugins/fn-math/functions.c:2414
#: ../plugins/fn-math/functions.c:2457
msgid "array1:second cell area"
msgstr ""

#: ../plugins/fn-math/functions.c:2373
msgid ""
"SUMX2MY2 function returns the sum of the difference of squares of "
"corresponding values in two arrays. The equation of SUMX2MY2 is SUM(x^2-y^2)."
msgstr ""

#: ../plugins/fn-math/functions.c:2412
msgid "SUMX2PY2:sum of the sum of squares"
msgstr ""

#: ../plugins/fn-math/functions.c:2415
msgid ""
"SUMX2PY2 function returns the sum of the sum of squares of corresponding "
"values in two arrays. The equation of SUMX2PY2 is SUM(x^2+y^2)."
msgstr ""

#: ../plugins/fn-math/functions.c:2417
msgid ""
"If @{array0} and @{array1} have different number of data points, SUMX2PY2 "
"returns #N/A.\n"
"Strings and empty cells are simply ignored."
msgstr ""

#: ../plugins/fn-math/functions.c:2455
msgid "SUMXMY2:sum of the squares of differences"
msgstr ""

#: ../plugins/fn-math/functions.c:2458
msgid ""
"SUMXMY2 function returns the sum of the squares of the differences of "
"corresponding values in two arrays. The equation of SUMXMY2 is SUM((x-y)^2)."
msgstr ""

#: ../plugins/fn-math/functions.c:2460
msgid ""
"If @{array0} and @{array1} have different number of data points, SUMXMY2 "
"returns #N/A.\n"
"Strings and empty cells are simply ignored."
msgstr ""

#: ../plugins/fn-math/functions.c:2500
msgid "SERIESSUM:sum of a power series at @{x}"
msgstr ""

#: ../plugins/fn-math/functions.c:2501
msgid "x:number where to evaluate the power series"
msgstr ""

#: ../plugins/fn-math/functions.c:2502
msgid "n:non-negative integer, exponent of the lowest term of the series"
msgstr ""

#: ../plugins/fn-math/functions.c:2503
msgid "m:increment to each exponent"
msgstr ""

#: ../plugins/fn-math/functions.c:2504
msgid "coeff:coefficients of the power series"
msgstr ""

#: ../plugins/fn-math/functions.c:2558
msgid "MINVERSE:the inverse matrix of @{matrix}"
msgstr ""

#: ../plugins/fn-math/functions.c:2559 ../plugins/fn-math/functions.c:2884
msgid "matrix:a square matrix"
msgstr ""

#: ../plugins/fn-math/functions.c:2560
msgid "If @{matrix} is not invertible, MINVERSE returns #NUM!"
msgstr ""

#: ../plugins/fn-math/functions.c:2561
msgid ""
"If @{matrix} does not contain an equal number of columns and rows, MINVERSE "
"returns #VALUE!"
msgstr ""

#: ../plugins/fn-math/functions.c:2692
msgid ""
"CHOLESKY:the Cholesky decomposition of the symmetric positive-definite @"
"{matrix}"
msgstr ""

#: ../plugins/fn-math/functions.c:2693
msgid "matrix:a symmetric positive definite matrix"
msgstr ""

#: ../plugins/fn-math/functions.c:2694
msgid ""
"If the Cholesky-Banachiewicz algorithm applied to @{matrix} fails, Cholesky "
"returns #NUM!"
msgstr ""

#: ../plugins/fn-math/functions.c:2695
msgid ""
"If @{matrix} does not contain an equal number of columns and rows, CHOLESKY "
"returns #VALUE!"
msgstr ""

#: ../plugins/fn-math/functions.c:2779
msgid "MUNIT:the @{n} by @{n} identity matrix"
msgstr ""

#: ../plugins/fn-math/functions.c:2780
msgid "n:size of the matrix"
msgstr ""

#: ../plugins/fn-math/functions.c:2816
msgid "MMULT:the matrix product of @{mat1} and @{mat2}"
msgstr ""

#: ../plugins/fn-math/functions.c:2817
msgid "mat1:a matrix"
msgstr ""

#: ../plugins/fn-math/functions.c:2818
msgid "mat2:a matrix"
msgstr ""

#: ../plugins/fn-math/functions.c:2883
msgid "MDETERM:the determinant of the matrix @{matrix}"
msgstr ""

#: ../plugins/fn-math/functions.c:2919
msgid "SUMPRODUCT:multiplies components and adds the results"
msgstr ""

#: ../plugins/fn-math/functions.c:2921
msgid ""
"Multiplies corresponding data entries in the given arrays or ranges, and "
"then returns the sum of those products."
msgstr ""

#: ../plugins/fn-math/functions.c:2924
msgid "If an entry is not numeric, the value zero is used instead."
msgstr ""

#: ../plugins/fn-math/functions.c:2925
msgid ""
"If arrays or range arguments do not have the same dimensions, return #VALUE! "
"error."
msgstr ""

#: ../plugins/fn-math/functions.c:2927
msgid ""
"SUMPRODUCTs arguments are arrays or ranges. Attempting to use A1:A5>0 will "
"not work, implicit intersection will kick in. Instead use --(A1:A5>0)"
msgstr ""

#: ../plugins/fn-math/functions.c:3041
msgid "EIGEN:eigenvalues and eigenvectors of the symmetric @{matrix}"
msgstr ""

#: ../plugins/fn-math/functions.c:3042
msgid "matrix:a symmetric matrix"
msgstr ""

#: ../plugins/fn-math/functions.c:3043
msgid "If @{matrix} is not symmetric, EIGEN returns #NUM!"
msgstr ""

#: ../plugins/fn-math/functions.c:3044
msgid ""
"If @{matrix} does not contain an equal number of columns and rows, EIGEN "
"returns #VALUE!"
msgstr ""

#: ../plugins/fn-numtheory/numtheory.c:218
msgid "NT_PHI:Euler's totient function"
msgstr ""

#: ../plugins/fn-numtheory/numtheory.c:220
msgid ""
"Euler's totient function gives the number of integers less than or equal to @"
"{n} that are relatively prime (coprime) to @{n}."
msgstr ""

#: ../plugins/fn-numtheory/numtheory.c:223
msgid "wiki:en:Euler's_totient_function"
msgstr ""

#: ../plugins/fn-numtheory/numtheory.c:252
msgid "NT_MU:Möbius mu function"
msgstr ""

#: ../plugins/fn-numtheory/numtheory.c:255
#, fuzzy
msgid ""
"NT_MU function (Möbius mu function) returns 0  if @{n} is divisible by the "
"square of a prime. Otherwise, if @{n} has an odd  number of different prime "
"factors, NT_MU returns -1, and if @{n} has an even number of different prime "
"factors, it returns 1. If @{n} = 1, NT_MU returns 1."
msgstr ""
"@FUNCTION=NT_MU\n"
"@SYNTAX=NT_MU(n)\n"
"@DESCRIPTION=Funktionen NT_MU (Möbius µ-funktion) returnerar \n"
"0 om @n är delbart med kvadraten av ett primtal.\n"
"Annars returnerar det: \n"
"\n"
"  -1 om @n har ett udda  antal olika primfaktorer.\n"
"   1  om @n har ett jämnt antal olika primfaktorer.\n"
"\n"
"* Om @n=1 returnerar det 1\n"
"\n"
"@EXAMPLES=\n"
"@SEEALSO=NT_D, ITHPRIME, NT_PHI"

#: ../plugins/fn-numtheory/numtheory.c:262
msgid "wiki:en:Möbius_function"
msgstr ""

#: ../plugins/fn-numtheory/numtheory.c:263
msgid "wolfram:MoebiusFunction.html"
msgstr ""

#: ../plugins/fn-numtheory/numtheory.c:293
msgid "NT_D:number of divisors"
msgstr ""

#: ../plugins/fn-numtheory/numtheory.c:295
msgid "NT_D calculates the number of divisors of @{n}."
msgstr ""

#: ../plugins/fn-numtheory/numtheory.c:325
msgid "NT_SIGMA:sigma function"
msgstr ""

#: ../plugins/fn-numtheory/numtheory.c:327
msgid "NT_SIGMA calculates the sum of the divisors of @{n}."
msgstr ""

#: ../plugins/fn-numtheory/numtheory.c:330
msgid "wiki:en:Divisor_function"
msgstr ""

#: ../plugins/fn-numtheory/numtheory.c:359
msgid "ITHPRIME:@{i}th prime"
msgstr ""

#: ../plugins/fn-numtheory/numtheory.c:360
msgid "i:positive integer"
msgstr ""

#: ../plugins/fn-numtheory/numtheory.c:361
msgid "ITHPRIME finds the @{i}th prime."
msgstr ""

#: ../plugins/fn-numtheory/numtheory.c:385
msgid "ISPRIME:whether @{n} is prime"
msgstr ""

#: ../plugins/fn-numtheory/numtheory.c:387
msgid "ISPRIME returns TRUE if @{n} is prime and FALSE otherwise."
msgstr ""

#: ../plugins/fn-numtheory/numtheory.c:390
msgid "wolfram:PrimeNumber.html"
msgstr ""

#: ../plugins/fn-numtheory/numtheory.c:441
msgid "PFACTOR:smallest prime factor"
msgstr ""

#: ../plugins/fn-numtheory/numtheory.c:443
msgid "PFACTOR finds the smallest prime factor of its argument."
msgstr ""

#: ../plugins/fn-numtheory/numtheory.c:444
msgid ""
"The argument @{n} must be at least 2. Otherwise a #VALUE! error is returned."
msgstr ""

#: ../plugins/fn-numtheory/numtheory.c:472
msgid "NT_PI:number of primes upto @{n}"
msgstr ""

#: ../plugins/fn-numtheory/numtheory.c:474
msgid "NT_PI returns the number of primes less than or equal to @{n}."
msgstr ""

#: ../plugins/fn-numtheory/numtheory.c:477
msgid "wolfram:PrimeCountingFunction.html"
msgstr ""

#: ../plugins/fn-numtheory/numtheory.c:503
msgid "BITOR:bitwise or"
msgstr ""

#: ../plugins/fn-numtheory/numtheory.c:504
#: ../plugins/fn-numtheory/numtheory.c:528
#: ../plugins/fn-numtheory/numtheory.c:552
#: ../plugins/fn-numtheory/numtheory.c:577
#: ../plugins/fn-numtheory/numtheory.c:607
msgid "a:non-negative integer"
msgstr ""

#: ../plugins/fn-numtheory/numtheory.c:505
#: ../plugins/fn-numtheory/numtheory.c:529
#: ../plugins/fn-numtheory/numtheory.c:553
msgid "b:non-negative integer"
msgstr ""

#: ../plugins/fn-numtheory/numtheory.c:506
msgid ""
"BITOR returns the bitwise or of the binary representations of its arguments."
msgstr ""

#: ../plugins/fn-numtheory/numtheory.c:527
msgid "BITXOR:bitwise exclusive or"
msgstr ""

#: ../plugins/fn-numtheory/numtheory.c:530
msgid ""
"BITXOR returns the bitwise exclusive or of the binary representations of its "
"arguments."
msgstr ""

#: ../plugins/fn-numtheory/numtheory.c:551
msgid "BITAND:bitwise and"
msgstr ""

#: ../plugins/fn-numtheory/numtheory.c:554
msgid ""
"BITAND returns the bitwise and of the binary representations of its "
"arguments."
msgstr ""

#: ../plugins/fn-numtheory/numtheory.c:576
msgid "BITLSHIFT:bit-shift to the left"
msgstr ""

#: ../plugins/fn-numtheory/numtheory.c:579
msgid ""
"BITLSHIFT returns the binary representations of @{a} shifted @{n} positions "
"to the left."
msgstr ""

#: ../plugins/fn-numtheory/numtheory.c:580
msgid ""
"If @{n} is negative, BITLSHIFT shifts the bits to the right by ABS(@{n}) "
"positions."
msgstr ""

#: ../plugins/fn-numtheory/numtheory.c:606
msgid "BITRSHIFT:bit-shift to the right"
msgstr ""

#: ../plugins/fn-numtheory/numtheory.c:609
msgid ""
"BITRSHIFT returns the binary representations of @{a} shifted @{n} positions "
"to the right."
msgstr ""

#: ../plugins/fn-numtheory/numtheory.c:610
msgid ""
"If @{n} is negative, BITRSHIFT shifts the bits to the left by ABS(@{n}) "
"positions."
msgstr ""

#: ../plugins/fn-r/functions.c:19
msgid "R.DNORM:probability density function of the normal distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:20 ../plugins/fn-r/functions.c:45
#: ../plugins/fn-r/functions.c:99 ../plugins/fn-r/functions.c:124
#: ../plugins/fn-r/functions.c:151 ../plugins/fn-r/functions.c:178
#: ../plugins/fn-r/functions.c:203 ../plugins/fn-r/functions.c:257
#: ../plugins/fn-r/functions.c:282 ../plugins/fn-r/functions.c:336
#: ../plugins/fn-r/functions.c:359 ../plugins/fn-r/functions.c:409
#: ../plugins/fn-r/functions.c:434 ../plugins/fn-r/functions.c:461
#: ../plugins/fn-r/functions.c:488 ../plugins/fn-r/functions.c:512
#: ../plugins/fn-r/functions.c:564 ../plugins/fn-r/functions.c:589
#: ../plugins/fn-r/functions.c:643 ../plugins/fn-r/functions.c:666
#: ../plugins/fn-r/functions.c:716 ../plugins/fn-r/functions.c:739
#: ../plugins/fn-r/functions.c:789 ../plugins/fn-r/functions.c:814
#: ../plugins/fn-r/functions.c:841 ../plugins/fn-r/functions.c:868
#: ../plugins/fn-r/functions.c:893 ../plugins/fn-r/functions.c:947
#: ../plugins/fn-r/functions.c:974 ../plugins/fn-r/functions.c:1032
#: ../plugins/fn-r/functions.c:1055 ../plugins/fn-r/functions.c:1105
#: ../plugins/fn-r/functions.c:1130 ../plugins/fn-r/functions.c:1184
#: ../plugins/fn-r/functions.c:1211 ../plugins/fn-r/functions.c:1240
msgid "x:observation"
msgstr ""

#: ../plugins/fn-r/functions.c:21 ../plugins/fn-r/functions.c:46
#: ../plugins/fn-r/functions.c:73
msgid "mu:mean of the distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:22 ../plugins/fn-r/functions.c:47
#: ../plugins/fn-r/functions.c:74
msgid "sigma:standard deviation of the distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:23 ../plugins/fn-r/functions.c:102
#: ../plugins/fn-r/functions.c:181 ../plugins/fn-r/functions.c:260
#: ../plugins/fn-r/functions.c:338 ../plugins/fn-r/functions.c:412
#: ../plugins/fn-r/functions.c:490 ../plugins/fn-r/functions.c:567
#: ../plugins/fn-r/functions.c:645 ../plugins/fn-r/functions.c:718
#: ../plugins/fn-r/functions.c:792 ../plugins/fn-r/functions.c:871
#: ../plugins/fn-r/functions.c:951 ../plugins/fn-r/functions.c:1034
#: ../plugins/fn-r/functions.c:1108 ../plugins/fn-r/functions.c:1188
#: ../plugins/fn-r/functions.c:1243
msgid "give_log:if true, log of the result will be returned instead"
msgstr ""

#: ../plugins/fn-r/functions.c:24
msgid ""
"This function returns the probability density function of the normal "
"distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:44
msgid "R.PNORM:cumulative distribution function of the normal distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:48 ../plugins/fn-r/functions.c:75
#: ../plugins/fn-r/functions.c:127 ../plugins/fn-r/functions.c:154
#: ../plugins/fn-r/functions.c:206 ../plugins/fn-r/functions.c:233
#: ../plugins/fn-r/functions.c:285 ../plugins/fn-r/functions.c:312
#: ../plugins/fn-r/functions.c:361 ../plugins/fn-r/functions.c:386
#: ../plugins/fn-r/functions.c:437 ../plugins/fn-r/functions.c:464
#: ../plugins/fn-r/functions.c:514 ../plugins/fn-r/functions.c:540
#: ../plugins/fn-r/functions.c:592 ../plugins/fn-r/functions.c:619
#: ../plugins/fn-r/functions.c:668 ../plugins/fn-r/functions.c:693
#: ../plugins/fn-r/functions.c:741 ../plugins/fn-r/functions.c:766
#: ../plugins/fn-r/functions.c:817 ../plugins/fn-r/functions.c:844
#: ../plugins/fn-r/functions.c:896 ../plugins/fn-r/functions.c:923
#: ../plugins/fn-r/functions.c:978 ../plugins/fn-r/functions.c:1007
#: ../plugins/fn-r/functions.c:1057 ../plugins/fn-r/functions.c:1082
#: ../plugins/fn-r/functions.c:1133 ../plugins/fn-r/functions.c:1160
#: ../plugins/fn-r/functions.c:1215
msgid ""
"lower_tail:if true (the default), the lower tail of the distribution is "
"considered"
msgstr ""

#: ../plugins/fn-r/functions.c:49 ../plugins/fn-r/functions.c:76
#: ../plugins/fn-r/functions.c:128 ../plugins/fn-r/functions.c:155
#: ../plugins/fn-r/functions.c:207 ../plugins/fn-r/functions.c:234
#: ../plugins/fn-r/functions.c:286 ../plugins/fn-r/functions.c:313
#: ../plugins/fn-r/functions.c:362 ../plugins/fn-r/functions.c:387
#: ../plugins/fn-r/functions.c:438 ../plugins/fn-r/functions.c:465
#: ../plugins/fn-r/functions.c:515 ../plugins/fn-r/functions.c:541
#: ../plugins/fn-r/functions.c:593 ../plugins/fn-r/functions.c:620
#: ../plugins/fn-r/functions.c:669 ../plugins/fn-r/functions.c:694
#: ../plugins/fn-r/functions.c:742 ../plugins/fn-r/functions.c:767
#: ../plugins/fn-r/functions.c:818 ../plugins/fn-r/functions.c:845
#: ../plugins/fn-r/functions.c:897 ../plugins/fn-r/functions.c:924
#: ../plugins/fn-r/functions.c:979 ../plugins/fn-r/functions.c:1008
#: ../plugins/fn-r/functions.c:1058 ../plugins/fn-r/functions.c:1083
#: ../plugins/fn-r/functions.c:1134 ../plugins/fn-r/functions.c:1161
#: ../plugins/fn-r/functions.c:1216
msgid "log_p:if true, log of the probability is used"
msgstr ""

#: ../plugins/fn-r/functions.c:50
msgid ""
"This function returns the cumulative distribution function of the normal "
"distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:71
msgid "R.QNORM:probability quantile function of the normal distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:72 ../plugins/fn-r/functions.c:230
#: ../plugins/fn-r/functions.c:309 ../plugins/fn-r/functions.c:384
#: ../plugins/fn-r/functions.c:538 ../plugins/fn-r/functions.c:616
#: ../plugins/fn-r/functions.c:691 ../plugins/fn-r/functions.c:764
#: ../plugins/fn-r/functions.c:920 ../plugins/fn-r/functions.c:1003
#: ../plugins/fn-r/functions.c:1080 ../plugins/fn-r/functions.c:1157
#: ../plugins/fn-random/functions.c:630 ../plugins/fn-stat/functions.c:492
#: ../plugins/fn-stat/functions.c:945 ../plugins/fn-stat/functions.c:1003
#: ../plugins/fn-stat/functions.c:1154 ../plugins/fn-stat/functions.c:1241
#: ../plugins/fn-stat/functions.c:1442 ../plugins/fn-stat/functions.c:1787
msgid "p:probability"
msgstr ""

#: ../plugins/fn-r/functions.c:77
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the normal distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:98
msgid "R.DLNORM:probability density function of the log-normal distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:100 ../plugins/fn-r/functions.c:125
#: ../plugins/fn-r/functions.c:152
msgid "logmean:mean of the underlying normal distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:101 ../plugins/fn-r/functions.c:126
#: ../plugins/fn-r/functions.c:153
msgid "logsd:standard deviation of the underlying normal distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:103
msgid ""
"This function returns the probability density function of the log-normal "
"distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:123
msgid ""
"R.PLNORM:cumulative distribution function of the log-normal distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:129
msgid ""
"This function returns the cumulative distribution function of the log-normal "
"distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:150
msgid "R.QLNORM:probability quantile function of the log-normal distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:156
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the log-normal distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:177
msgid "R.DGAMMA:probability density function of the gamma distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:179 ../plugins/fn-r/functions.c:204
#: ../plugins/fn-r/functions.c:231 ../plugins/fn-r/functions.c:565
#: ../plugins/fn-r/functions.c:590 ../plugins/fn-r/functions.c:617
#: ../plugins/fn-r/functions.c:1185 ../plugins/fn-r/functions.c:1212
#: ../plugins/fn-r/functions.c:1242
msgid "shape:the shape parameter of the distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:180 ../plugins/fn-r/functions.c:205
#: ../plugins/fn-r/functions.c:232 ../plugins/fn-r/functions.c:566
#: ../plugins/fn-r/functions.c:591 ../plugins/fn-r/functions.c:618
#: ../plugins/fn-r/functions.c:717 ../plugins/fn-r/functions.c:740
#: ../plugins/fn-r/functions.c:765 ../plugins/fn-r/functions.c:1107
#: ../plugins/fn-r/functions.c:1132 ../plugins/fn-r/functions.c:1159
#: ../plugins/fn-r/functions.c:1187 ../plugins/fn-r/functions.c:1214
msgid "scale:the scale parameter of the distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:182
msgid ""
"This function returns the probability density function of the gamma "
"distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:202
msgid "R.PGAMMA:cumulative distribution function of the gamma distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:208
msgid ""
"This function returns the cumulative distribution function of the gamma "
"distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:229
msgid "R.QGAMMA:probability quantile function of the gamma distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:235
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the gamma distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:256
msgid "R.DBETA:probability density function of the beta distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:258 ../plugins/fn-r/functions.c:283
#: ../plugins/fn-r/functions.c:310
msgid "a:the first shape parameter of the distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:259 ../plugins/fn-r/functions.c:284
#: ../plugins/fn-r/functions.c:311
msgid "b:the second scale parameter of the distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:261
msgid ""
"This function returns the probability density function of the beta "
"distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:281
msgid "R.PBETA:cumulative distribution function of the beta distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:287
msgid ""
"This function returns the cumulative distribution function of the beta "
"distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:308
msgid "R.QBETA:probability quantile function of the beta distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:314
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the beta distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:335
msgid "R.DT:probability density function of the Student t distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:337 ../plugins/fn-r/functions.c:360
#: ../plugins/fn-r/functions.c:385 ../plugins/fn-r/functions.c:1241
msgid "n:the number of degrees of freedom of the distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:339
msgid ""
"This function returns the probability density function of the Student t "
"distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:358
msgid "R.PT:cumulative distribution function of the Student t distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:363
msgid ""
"This function returns the cumulative distribution function of the Student t "
"distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:383
msgid "R.QT:probability quantile function of the Student t distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:388
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the Student t distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:408
msgid "R.DF:probability density function of the F distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:410 ../plugins/fn-r/functions.c:435
#: ../plugins/fn-r/functions.c:462
msgid "n1:the first number of degrees of freedom of the distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:411 ../plugins/fn-r/functions.c:436
#: ../plugins/fn-r/functions.c:463
msgid "n2:the second number of degrees of freedom of the distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:413
msgid ""
"This function returns the probability density function of the F distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:433
msgid "R.PF:cumulative distribution function of the F distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:439
msgid ""
"This function returns the cumulative distribution function of the F "
"distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:460
msgid "R.QF:probability quantile function of the F distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:466
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the F distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:487
msgid "R.DCHISQ:probability density function of the chi-square distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:489 ../plugins/fn-r/functions.c:513
#: ../plugins/fn-r/functions.c:539
msgid "df:the number of degrees of freedom of the distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:491
msgid ""
"This function returns the probability density function of the chi-square "
"distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:492
msgid ""
"A two argument invocation R.DCHISQ(@{x},@{df}) is exported to OpenFormula as "
"CHISQDIST(@{x},@{df},FALSE())."
msgstr ""

#: ../plugins/fn-r/functions.c:511
msgid ""
"R.PCHISQ:cumulative distribution function of the chi-square distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:516
msgid ""
"This function returns the cumulative distribution function of the chi-square "
"distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:517
msgid ""
"A two argument invocation R.PCHISQ(@{x},@{df}) is exported to OpenFormula as "
"CHISQDIST(@{x},@{df})."
msgstr ""

#: ../plugins/fn-r/functions.c:537
msgid "R.QCHISQ:probability quantile function of the chi-square distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:542
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the chi-square distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:543
msgid ""
"A two argument invocation R.QCHISQ(@{p},@{df}) is exported to OpenFormula as "
"CHISQINV(@{p},@{df})."
msgstr ""

#: ../plugins/fn-r/functions.c:563
msgid "R.DWEIBULL:probability density function of the Weibull distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:568
msgid ""
"This function returns the probability density function of the Weibull "
"distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:588
msgid "R.PWEIBULL:cumulative distribution function of the Weibull distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:594
msgid ""
"This function returns the cumulative distribution function of the Weibull "
"distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:615
msgid "R.QWEIBULL:probability quantile function of the Weibull distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:621
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the Weibull distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:642
msgid "R.DPOIS:probability density function of the Poisson distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:644 ../plugins/fn-r/functions.c:667
#: ../plugins/fn-r/functions.c:692
msgid "lambda:the mean of the distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:646
msgid ""
"This function returns the probability density function of the Poisson "
"distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:665
msgid "R.PPOIS:cumulative distribution function of the Poisson distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:670
msgid ""
"This function returns the cumulative distribution function of the Poisson "
"distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:690
msgid "R.QPOIS:probability quantile function of the Poisson distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:695
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the Poisson distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:715
msgid "R.DEXP:probability density function of the exponential distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:719
msgid ""
"This function returns the probability density function of the exponential "
"distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:738
msgid "R.PEXP:cumulative distribution function of the exponential distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:743
msgid ""
"This function returns the cumulative distribution function of the "
"exponential distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:763
msgid "R.QEXP:probability quantile function of the exponential distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:768
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the exponential distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:788
msgid "R.DBINOM:probability density function of the binomial distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:790 ../plugins/fn-r/functions.c:815
#: ../plugins/fn-r/functions.c:842 ../plugins/fn-r/functions.c:869
#: ../plugins/fn-r/functions.c:894 ../plugins/fn-r/functions.c:921
msgid "n:the number of trials"
msgstr ""

#: ../plugins/fn-r/functions.c:791 ../plugins/fn-r/functions.c:816
#: ../plugins/fn-r/functions.c:843 ../plugins/fn-r/functions.c:870
#: ../plugins/fn-r/functions.c:895 ../plugins/fn-r/functions.c:922
#: ../plugins/fn-r/functions.c:1033 ../plugins/fn-r/functions.c:1056
#: ../plugins/fn-r/functions.c:1081
msgid "psuc:the probability of success in each trial"
msgstr ""

#: ../plugins/fn-r/functions.c:793
msgid ""
"This function returns the probability density function of the binomial "
"distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:813
msgid "R.PBINOM:cumulative distribution function of the binomial distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:819
msgid ""
"This function returns the cumulative distribution function of the binomial "
"distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:840
msgid "R.QBINOM:probability quantile function of the binomial distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:846
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the binomial distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:867
msgid ""
"R.DNBINOM:probability density function of the negative binomial distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:872
msgid ""
"This function returns the probability density function of the negative "
"binomial distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:892
msgid ""
"R.PNBINOM:cumulative distribution function of the negative binomial "
"distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:898
msgid ""
"This function returns the cumulative distribution function of the negative "
"binomial distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:919
msgid ""
"R.QNBINOM:probability quantile function of the negative binomial distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:925
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the negative binomial "
"distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:946
msgid ""
"R.DHYPER:probability density function of the hypergeometric distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:948 ../plugins/fn-r/functions.c:975
#: ../plugins/fn-r/functions.c:1004
msgid "r:the number of red balls"
msgstr ""

#: ../plugins/fn-r/functions.c:949 ../plugins/fn-r/functions.c:976
#: ../plugins/fn-r/functions.c:1005
msgid "b:the number of black balls"
msgstr ""

#: ../plugins/fn-r/functions.c:950 ../plugins/fn-r/functions.c:977
#: ../plugins/fn-r/functions.c:1006
msgid "n:the number of balls drawn"
msgstr ""

#: ../plugins/fn-r/functions.c:952
msgid ""
"This function returns the probability density function of the hypergeometric "
"distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:973
msgid ""
"R.PHYPER:cumulative distribution function of the hypergeometric distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:980
msgid ""
"This function returns the cumulative distribution function of the "
"hypergeometric distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:1002
msgid ""
"R.QHYPER:probability quantile function of the hypergeometric distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:1009
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the hypergeometric distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:1031
msgid "R.DGEOM:probability density function of the geometric distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:1035
msgid ""
"This function returns the probability density function of the geometric "
"distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:1054
msgid "R.PGEOM:cumulative distribution function of the geometric distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:1059
msgid ""
"This function returns the cumulative distribution function of the geometric "
"distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:1079
msgid "R.QGEOM:probability quantile function of the geometric distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:1084
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the geometric distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:1104
msgid "R.DCAUCHY:probability density function of the Cauchy distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:1106 ../plugins/fn-r/functions.c:1131
#: ../plugins/fn-r/functions.c:1158
msgid "location:the center of the distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:1109
msgid ""
"This function returns the probability density function of the Cauchy "
"distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:1129
msgid "R.PCAUCHY:cumulative distribution function of the Cauchy distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:1135
msgid ""
"This function returns the cumulative distribution function of the Cauchy "
"distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:1156
msgid "R.QCAUCHY:probability quantile function of the Cauchy distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:1162
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the Cauchy distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:1183
msgid "R.DSNORM:probability density function of the skew-normal distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:1186 ../plugins/fn-r/functions.c:1213
msgid "location:the location parameter of the distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:1189
msgid ""
"This function returns the probability density function of the skew-normal "
"distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:1210
msgid ""
"R.PSNORM:cumulative distribution function of the skew-normal distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:1217
msgid ""
"This function returns the cumulative distribution function of the skew-"
"normal distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:1239
msgid "R.DST:probability density function of the skew-t distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:1244
msgid ""
"This function returns the probability density function of the skew-t "
"distribution."
msgstr ""

#: ../plugins/fn-random/functions.c:47
msgid "RAND:a random number between zero and one"
msgstr ""

#: ../plugins/fn-random/functions.c:64
msgid ""
"RANDUNIFORM:random variate from the uniform distribution from @{a} to @{b}"
msgstr ""

#: ../plugins/fn-random/functions.c:65
msgid "a:lower limit of the uniform distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:66
msgid "b:upper limit of the uniform distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:67
msgid "If @{a} > @{b} RANDUNIFORM returns #NUM!"
msgstr ""

#: ../plugins/fn-random/functions.c:89
msgid "RANDDISCRETE:random variate from a finite discrete distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:90
msgid "val_range:possible values of the random variable"
msgstr ""

#: ../plugins/fn-random/functions.c:91
msgid ""
"prob_range:probabilities of the corresponding values in @{val_range}, "
"defaults to equal probabilities"
msgstr ""

#: ../plugins/fn-random/functions.c:93
msgid ""
"RANDDISCRETE returns one of the values in the @{val_range}. The "
"probabilities for each value are given in the @{prob_range}."
msgstr ""

#: ../plugins/fn-random/functions.c:95
msgid ""
"If the sum of all values in @{prob_range} is not one, RANDDISCRETE returns "
"#NUM!"
msgstr ""

#: ../plugins/fn-random/functions.c:96
msgid ""
"If @{val_range} and @{prob_range} are not the same size, RANDDISCRETE "
"returns #NUM!"
msgstr ""

#: ../plugins/fn-random/functions.c:97
msgid ""
"If @{val_range} or @{prob_range} is not a range, RANDDISCRETE returns #VALUE!"
msgstr ""

#: ../plugins/fn-random/functions.c:175
msgid "RANDEXP:random variate from an exponential distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:176
msgid "b:parameter of the exponential distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:194
msgid "RANDPOISSON:random variate from a Poisson distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:195
msgid "λ:parameter of the Poisson distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:196
msgid "If @{λ} < 0 RANDPOISSON returns #NUM!"
msgstr ""

#: ../plugins/fn-random/functions.c:218
msgid "RANDBINOM:random variate from a binomial distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:219 ../plugins/fn-random/functions.c:276
#: ../plugins/fn-random/functions.c:582
msgid "p:probability of success in a single trial"
msgstr ""

#: ../plugins/fn-random/functions.c:220
msgid "n:number of trials"
msgstr ""

#: ../plugins/fn-random/functions.c:221
msgid "If @{p} < 0 or @{p} > 1 RANDBINOM returns #NUM!"
msgstr ""

#: ../plugins/fn-random/functions.c:222
msgid "If @{n} < 0 RANDBINOM returns #NUM!"
msgstr ""

#: ../plugins/fn-random/functions.c:244
msgid ""
"RANDBETWEEN:a random integer number between and including @{bottom} and @"
"{top}"
msgstr ""

#: ../plugins/fn-random/functions.c:246
msgid "bottom:lower limit"
msgstr ""

#: ../plugins/fn-random/functions.c:247
msgid "top:upper limit"
msgstr ""

#: ../plugins/fn-random/functions.c:248
msgid "If @{bottom} > @{top}, RANDBETWEEN returns #NUM!"
msgstr ""

#: ../plugins/fn-random/functions.c:275
msgid "RANDNEGBINOM:random variate from a negative binomial distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:277
msgid "n:number of failures"
msgstr ""

#: ../plugins/fn-random/functions.c:278
msgid "If @{p} < 0 or @{p} > 1 RANDNEGBINOM returns #NUM!"
msgstr ""

#: ../plugins/fn-random/functions.c:279
msgid "If @{n} < 1 RANDNEGBINOM returns #NUM!"
msgstr ""

#: ../plugins/fn-random/functions.c:300
msgid "RANDBERNOULLI:random variate from a Bernoulli distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:301 ../plugins/fn-stat/functions.c:877
msgid "p:probability of success"
msgstr ""

#: ../plugins/fn-random/functions.c:302
msgid "If @{p} < 0 or @{p} > 1 RANDBERNOULLI returns #NUM!"
msgstr ""

#: ../plugins/fn-random/functions.c:324
msgid "RANDNORM:random variate from a normal distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:325
msgid "μ:mean of the distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:326 ../plugins/fn-random/functions.c:374
msgid "σ:standard deviation of the distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:327
msgid "If @{σ} < 0, RANDNORM returns #NUM!"
msgstr ""

#: ../plugins/fn-random/functions.c:349
msgid "RANDCAUCHY:random variate from a Cauchy or Lorentz distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:350
msgid "a:scale parameter of the distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:351
msgid "If @{a} < 0 RANDCAUCHY returns #NUM!"
msgstr ""

#: ../plugins/fn-random/functions.c:372
msgid "RANDLOGNORM:random variate from a lognormal distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:373
msgid "ζ:parameter of the lognormal distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:375
msgid "If @{σ} < 0, RANDLOGNORM returns #NUM!"
msgstr ""

#: ../plugins/fn-random/functions.c:394
msgid "RANDWEIBULL:random variate from a Weibull distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:395
msgid "a:parameter of the Weibull distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:396
msgid "b:parameter of the Weibull distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:415
msgid "RANDLAPLACE:random variate from a Laplace distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:416
msgid "a:parameter of the Laplace distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:434
msgid "RANDRAYLEIGH:random variate from a Rayleigh distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:435 ../plugins/fn-random/functions.c:455
msgid "σ:scale parameter of the Rayleigh distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:453
msgid ""
"RANDRAYLEIGHTAIL:random variate from the tail of a Rayleigh distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:454 ../plugins/fn-random/functions.c:793
msgid "a:lower limit of the tail"
msgstr ""

#: ../plugins/fn-random/functions.c:474
msgid "RANDGAMMA:random variate from a Gamma distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:475
msgid "a:parameter of the Gamma distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:476
msgid "b:parameter of the Gamma distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:477
msgid "If @{a} ≤ 0, RANDGAMMA returns #NUM!"
msgstr ""

#: ../plugins/fn-random/functions.c:499
msgid "RANDPARETO:random variate from a Pareto distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:500
msgid "a:parameter of the Pareto distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:501
msgid "b:parameter of the Pareto distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:520
msgid "RANDFDIST:random variate from an F distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:521
msgid "df1:numerator degrees of freedom"
msgstr ""

#: ../plugins/fn-random/functions.c:522
msgid "df2:denominator degrees of freedom"
msgstr ""

#: ../plugins/fn-random/functions.c:541
msgid "RANDBETA:random variate from a Beta distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:542
msgid "a:parameter of the Beta distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:543
msgid "b:parameter of the Beta distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:562
msgid "RANDLOGISTIC:random variate from a logistic distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:563
msgid "a:parameter of the logistic distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:581
msgid "RANDGEOM:random variate from a geometric distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:583
msgid "If @{p} < 0 or @{p} > 1 RANDGEOM returns #NUM!"
msgstr ""

#: ../plugins/fn-random/functions.c:604
msgid "RANDHYPERG:random variate from a hypergeometric distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:605
msgid "n1:number of objects of type 1"
msgstr ""

#: ../plugins/fn-random/functions.c:606
msgid "n2:number of objects of type 2"
msgstr ""

#: ../plugins/fn-random/functions.c:607
msgid "t:total number of objects selected"
msgstr ""

#: ../plugins/fn-random/functions.c:629
msgid "RANDLOG:random variate from a logarithmic distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:631
msgid "If @{p} < 0 or @{p} > 1 RANDLOG returns #NUM!"
msgstr ""

#: ../plugins/fn-random/functions.c:652
msgid "RANDCHISQ:random variate from a Chi-square distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:653 ../plugins/fn-random/functions.c:672
#: ../plugins/fn-random/functions.c:923
msgid "df:degrees of freedom"
msgstr ""

#: ../plugins/fn-random/functions.c:671
msgid "RANDTDIST:random variate from a Student t distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:690
msgid "RANDGUMBEL:random variate from a Gumbel distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:691
msgid "a:parameter of the Gumbel distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:692
msgid "b:parameter of the Gumbel distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:693
msgid "type:type of the Gumbel distribution, defaults to 1"
msgstr ""

#: ../plugins/fn-random/functions.c:694
msgid "If @{type} is neither 1 nor 2, RANDGUMBEL returns #NUM!"
msgstr ""

#: ../plugins/fn-random/functions.c:719
msgid "RANDLEVY:random variate from a Lévy distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:720
msgid "c:parameter of the Lévy distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:721
msgid "α:parameter of the Lévy distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:722
msgid "β:parameter of the Lévy distribution, defaults to 0"
msgstr ""

#: ../plugins/fn-random/functions.c:723
msgid ""
"For @{α} = 1, @{β}=0, the Lévy distribution reduces to the Cauchy (or "
"Lorentzian) distribution."
msgstr ""

#: ../plugins/fn-random/functions.c:725
msgid ""
"For @{α} = 2, @{β}=0, the Lévy distribution reduces to the normal "
"distribution."
msgstr ""

#: ../plugins/fn-random/functions.c:727
msgid "If @{α} ≤ 0 or @{α} > 2, RANDLEVY returns #NUM!"
msgstr ""

#: ../plugins/fn-random/functions.c:728
msgid "If @{β} < -1 or @{β} > 1, RANDLEVY returns #NUM!"
msgstr ""

#: ../plugins/fn-random/functions.c:751
msgid "RANDEXPPOW:random variate from an exponential power distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:752
msgid "a:scale parameter of the exponential power distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:753
msgid "b:exponent of the exponential power distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:754
msgid ""
"For @{b} = 1 the exponential power distribution reduces to the Laplace "
"distribution."
msgstr ""

#: ../plugins/fn-random/functions.c:756
msgid ""
"For @{b} = 2 the exponential power distribution reduces to the normal "
"distribution with σ = a/sqrt(2)"
msgstr ""

#: ../plugins/fn-random/functions.c:776
msgid "RANDLANDAU:random variate from the Landau distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:792
msgid ""
"RANDNORMTAIL:random variate from the upper tail of a normal distribution "
"with mean 0"
msgstr ""

#: ../plugins/fn-random/functions.c:794
msgid "σ:standard deviation of the normal distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:795
msgid ""
"The method is based on Marsaglia's famous rectangle-wedge-tail algorithm "
"(Ann Math Stat 32, 894-899 (1961)), with this aspect explained in Knuth, v2, "
"3rd ed, p139, 586 (exercise 11)."
msgstr ""

#: ../plugins/fn-random/functions.c:816
msgid ""
"SIMTABLE:one of the values in the given argument list depending on the round "
"number of the simulation tool"
msgstr ""

#: ../plugins/fn-random/functions.c:818
msgid "d1:first value"
msgstr ""

#: ../plugins/fn-random/functions.c:819
msgid "d2:second value"
msgstr ""

#: ../plugins/fn-random/functions.c:820
#, fuzzy
msgid ""
"SIMTABLE returns one of the values in the given argument list depending on "
"the round number of the simulation tool. When the simulation tool is not "
"activated, SIMTABLE returns @{d1}.\n"
"With the simulation tool and the SIMTABLE function you can test given "
"decision variables. Each SIMTABLE function contains the possible values of a "
"simulation variable. In most valid simulation models you should have the "
"same number of values @{dN} for all decision variables.  If the simulation "
"is run more rounds than there are values defined, SIMTABLE returns #N/A! "
"error (e.g. if A1 contains `=SIMTABLE(1)' and A2 `=SIMTABLE(1,2)', A1 yields "
"#N/A! error on the second round).\n"
"The successive use of the simulation tool also requires that you give to the "
"tool at least one input variable having RAND() or any other "
"RAND<distribution name>() function in it. On each round, the simulation tool "
"iterates for the given number of rounds over all the input variables to "
"reevaluate them. On each iteration, the values of the output variables are "
"stored, and when the round is completed, descriptive statistical information "
"is created according to the values."
msgstr ""
"@FUNCTION=SIMTABLE\n"
"@SYNTAX=SIMTABLE(d1; d2; ...; dN)\n"
"@DESCRIPTION=SIMTABLE returnerar ett av värdena i argumentlistan beroende på "
"den nuvarande rundan i simulationsverktyget. Om simulationsverktyget inte är "
"aktiverat returnerar SIMTABLE @d1.\n"
"\n"
"Med simulationsverktyget och SIMTABLE-funktionen kan du testa givna "
"beslutsvariabler. I de flesta korrekta simulationsmodeller bör du ha samma "
"antal värden @dN för alla beslutsvariabler. Om simulationen körs i fler "
"rundor än det finns definierade variabler returnerar SIMTABLE felet #- (med "
"andra ord, om A1 innehåller \"=SIMTABLE(1)\" och A2 \"SIMTABLE(1;2)\" så ger "
"A1 #- andra rundan).\n"
"\n"
"Ett iterativt användande av simulationsverktyget kräver också att du ger det "
"åtminstonde en indatavariabel med RAND() eller annan RAND<distribution>() "
"funktion. För varje runda itererar simulationsverktyget ett givet antal "
"gånger över alla indatavariabler för att evaluera dem. Under varje iteration "
"sparas värdena på utdatavariablerna, och när rundan är klar skapas "
"deskriptiv statistisk information beroende på dessa värden.\n"
"\n"
"@EXAMPLES=\n"
"SIMTABLE(SANT,FALSKT) returnerar SANT den första simulationsrundan och "
"FALSKT den andra rundan.\n"
"SIMTABLE(223;225;227;229) returnerar 227 under simulationsrunda 3..\n"
"\n"
"@SEEALSO="

#: ../plugins/fn-random/functions.c:883
msgid "RANDSNORM:random variate from a skew normal distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:884 ../plugins/fn-random/functions.c:924
msgid "a:amount of skew, defaults to 0"
msgstr ""

#: ../plugins/fn-random/functions.c:885
msgid "μ:mean of the underlying normal distribution, defaults to 0"
msgstr ""

#: ../plugins/fn-random/functions.c:886
msgid ""
"σ:standard deviation of the underlying normal distribution, defaults to 1"
msgstr ""

#: ../plugins/fn-random/functions.c:887
msgid "If @{σ} < 0, RANDSNORM returns #NUM!"
msgstr ""

#: ../plugins/fn-random/functions.c:922
msgid "RANDSTDIST:random variate from a skew t distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:45
#, fuzzy
msgid ""
"Numbers, text and logical values are included in the calculation too. If the "
"cell contains text or the argument evaluates to FALSE, it is counted as "
"value zero (0). If the argument evaluates to TRUE, it is counted as one (1). "
"Note that empty cells are not counted."
msgstr ""
"@FUNCTION=SUMA\n"
"@SYNTAX=SUMA(värde1; värde2; ...)\n"
"@DESCRIPTION=SUMA Beräknar summan av alla värden och celler som refereras "
"till i argumentlistan. Tal, text och logiska värden inkluderas även de i "
"beräkningen. Om cellen innehåller text eller om argumenten evalueras till "
"FALSKT, räknas de som noll (0). Om ett argument evalueras till SANT, räknas "
"det som 1.\n"
"\n"
"@EXAMPLES=\n"
"Antag att cellerna A1; A2; ...; A5 innehåller talen 11, 15, 17, 21, och 43. "
"Då är\n"
"SUMA(A1:A5) lika med 107.\n"
"\n"
"@SEEALSO=AVERAGE, SUM, COUNT"

#: ../plugins/fn-stat/functions.c:50
msgid "VARP:variance of an entire population"
msgstr ""

#: ../plugins/fn-stat/functions.c:51 ../plugins/fn-stat/functions.c:77
#: ../plugins/fn-stat/functions.c:107 ../plugins/fn-stat/functions.c:135
#: ../plugins/fn-stat/functions.c:2517 ../plugins/fn-stat/functions.c:2548
#: ../plugins/fn-stat/functions.c:2576 ../plugins/fn-stat/functions.c:2605
msgid "area1:first cell area"
msgstr ""

#: ../plugins/fn-stat/functions.c:52 ../plugins/fn-stat/functions.c:78
#: ../plugins/fn-stat/functions.c:108 ../plugins/fn-stat/functions.c:136
#: ../plugins/fn-stat/functions.c:2518 ../plugins/fn-stat/functions.c:2549
#: ../plugins/fn-stat/functions.c:2577 ../plugins/fn-stat/functions.c:2606
msgid "area2:second cell area"
msgstr ""

#: ../plugins/fn-stat/functions.c:53
msgid "VARP is also known as the N-variance."
msgstr ""

#: ../plugins/fn-stat/functions.c:54
msgid ""
"Let us assume that the cells A1, A2, ..., A5 contain number 11.4, 17.3, "
"21.3, 25.9, and 40.1."
msgstr ""

#: ../plugins/fn-stat/functions.c:55
msgid "Then VARP(A1:A5) equals 94.112"
msgstr ""

#: ../plugins/fn-stat/functions.c:57 ../plugins/fn-stat/functions.c:87
msgid "wiki:en:Variance"
msgstr ""

#: ../plugins/fn-stat/functions.c:58 ../plugins/fn-stat/functions.c:88
msgid "wolfram:Variance.html"
msgstr ""

#: ../plugins/fn-stat/functions.c:76
msgid "VAR:sample variance of the given sample"
msgstr ""

#: ../plugins/fn-stat/functions.c:79
msgid "VAR is also known as the N-1-variance."
msgstr ""

#: ../plugins/fn-stat/functions.c:80 ../plugins/fn-stat/functions.c:2522
msgid ""
"Since the N-1-variance includes Bessel's correction, whereas the N-variance "
"calculated by VARPA or VARP does not, under reasonable conditions the N-1-"
"variance is an unbiased estimator of the variance of the population from "
"which the sample is drawn."
msgstr ""

#: ../plugins/fn-stat/functions.c:84 ../plugins/fn-stat/functions.c:112
#: ../plugins/fn-stat/functions.c:139 ../plugins/fn-stat/functions.c:277
#: ../plugins/fn-stat/functions.c:573 ../plugins/fn-stat/functions.c:600
#: ../plugins/fn-stat/functions.c:626 ../plugins/fn-stat/functions.c:696
#: ../plugins/fn-stat/functions.c:722 ../plugins/fn-stat/functions.c:757
#: ../plugins/fn-stat/functions.c:797 ../plugins/fn-stat/functions.c:822
#: ../plugins/fn-stat/functions.c:1825 ../plugins/fn-stat/functions.c:1851
#: ../plugins/fn-stat/functions.c:1875 ../plugins/fn-stat/functions.c:1900
#: ../plugins/fn-stat/functions.c:2031 ../plugins/fn-stat/functions.c:2153
#: ../plugins/fn-stat/functions.c:2196 ../plugins/fn-stat/functions.c:2384
#: ../plugins/fn-stat/functions.c:2734 ../plugins/fn-stat/functions.c:2777
msgid ""
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
"21.3, 25.9, and 40.1."
msgstr ""

#: ../plugins/fn-stat/functions.c:85
msgid "Then VAR(A1:A5) equals 117.64."
msgstr ""

#: ../plugins/fn-stat/functions.c:106
msgid "STDEV:sample standard deviation of the given sample"
msgstr ""

#: ../plugins/fn-stat/functions.c:109
msgid "STDEV is also known as the N-1-standard deviation."
msgstr ""

#: ../plugins/fn-stat/functions.c:110
msgid ""
"To obtain the population standard deviation of a whole population use STDEVP."
msgstr ""

#: ../plugins/fn-stat/functions.c:113
msgid "Then STDEV(A1:A5) equals 10.84619749."
msgstr ""

#: ../plugins/fn-stat/functions.c:115 ../plugins/fn-stat/functions.c:142
msgid "wiki:en:Standard_deviation"
msgstr ""

#: ../plugins/fn-stat/functions.c:116 ../plugins/fn-stat/functions.c:143
msgid "wolfram:StandardDeviation.html"
msgstr ""

#: ../plugins/fn-stat/functions.c:134
msgid "STDEVP:population standard deviation of the given population"
msgstr ""

#: ../plugins/fn-stat/functions.c:137 ../plugins/fn-stat/functions.c:2607
msgid "This is also known as the N-standard deviation"
msgstr ""

#: ../plugins/fn-stat/functions.c:140
msgid "Then STDEVP(A1:A5) equals 9.701133954."
msgstr ""

#: ../plugins/fn-stat/functions.c:161
msgid "RANK:rank of a number in a list of numbers"
msgstr ""

#: ../plugins/fn-stat/functions.c:162 ../plugins/fn-stat/functions.c:214
msgid "x:number whose rank you want to find"
msgstr ""

#: ../plugins/fn-stat/functions.c:164 ../plugins/fn-stat/functions.c:216
msgid "order:0 (descending order) or non-zero (ascending order); defaults to 0"
msgstr ""

#: ../plugins/fn-stat/functions.c:165
msgid "In case of a tie, RANK returns the largest possible rank."
msgstr ""

#: ../plugins/fn-stat/functions.c:167
msgid ""
"Let us assume that the cells A1, A2, …, A5 contain numbers 11.4, 17.3, 21.3, "
"25.9, and 25.9."
msgstr ""

#: ../plugins/fn-stat/functions.c:168
msgid "Then RANK(17.3,A1:A5) equals 4."
msgstr ""

#: ../plugins/fn-stat/functions.c:169
msgid "Then RANK(25.9,A1:A5) equals 1."
msgstr ""

#: ../plugins/fn-stat/functions.c:213
msgid "RANK.AVG:rank of a number in a list of numbers"
msgstr ""

#: ../plugins/fn-stat/functions.c:217
msgid "In case of a tie, RANK returns the average rank."
msgstr ""

#: ../plugins/fn-stat/functions.c:218
msgid "This function is Excel 2010 compatible."
msgstr ""

#: ../plugins/fn-stat/functions.c:219
msgid ""
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
"21.3, 25.9, and 25.9."
msgstr ""

#: ../plugins/fn-stat/functions.c:220
msgid "Then RANK.AVG(17.3,A1:A5) equals 4."
msgstr ""

#: ../plugins/fn-stat/functions.c:221
msgid "Then RANK.AVG(25.9,A1:A5) equals 1.5."
msgstr ""

#: ../plugins/fn-stat/functions.c:271
msgid "TRIMMEAN:mean of the interior of a data set"
msgstr ""

#: ../plugins/fn-stat/functions.c:272
msgid "ref:list of numbers whose mean you want to calculate"
msgstr ""

#: ../plugins/fn-stat/functions.c:273
msgid "fraction:fraction of the data set excluded from the mean"
msgstr ""

#: ../plugins/fn-stat/functions.c:274
msgid ""
"If @{fraction}=0.2 and the data set contains 40 numbers, 8 numbers are "
"trimmed from the data set (40 x 0.2): the 4 largest and the 4 smallest. To "
"avoid a bias, the number of points to be excluded is always rounded down to "
"the nearest even number."
msgstr ""

#: ../plugins/fn-stat/functions.c:278
msgid ""
"Then TRIMMEAN(A1:A5,0.2) equals 23.2 and TRIMMEAN(A1:A5,0.4) equals 21.5."
msgstr ""

#: ../plugins/fn-stat/functions.c:320
msgid "COVAR:covariance of two data sets"
msgstr ""

#: ../plugins/fn-stat/functions.c:321 ../plugins/fn-stat/functions.c:351
msgid "array1:first data set"
msgstr ""

#: ../plugins/fn-stat/functions.c:322
msgid "array2:set data set"
msgstr ""

#: ../plugins/fn-stat/functions.c:323 ../plugins/fn-stat/functions.c:353
#: ../plugins/fn-stat/functions.c:543 ../plugins/fn-stat/functions.c:791
#: ../plugins/fn-stat/functions.c:820 ../plugins/fn-stat/functions.c:1817
#: ../plugins/fn-stat/functions.c:1848 ../plugins/fn-stat/functions.c:1898
#: ../plugins/fn-stat/functions.c:1984 ../plugins/fn-stat/functions.c:2003
#: ../plugins/fn-stat/functions.c:2027
msgid "Strings and empty cells are simply ignored."
msgstr ""

#: ../plugins/fn-stat/functions.c:325 ../plugins/fn-stat/functions.c:355
#: ../plugins/fn-stat/functions.c:2325 ../plugins/fn-stat/functions.c:2818
#: ../plugins/fn-stat/functions.c:2884 ../plugins/fn-stat/functions.c:3917
#: ../plugins/fn-stat/functions.c:3974 ../plugins/fn-stat/functions.c:4026
msgid ""
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
"21.3, 25.9, and 40.1, and the cells B1, B2, ... B5 23.2, 25.8, 29.9, 33.5, "
"and 42.7."
msgstr ""

#: ../plugins/fn-stat/functions.c:328
msgid "Then COVAR(A1:A5,B1:B5) equals 65.858."
msgstr ""

#: ../plugins/fn-stat/functions.c:330
msgid "wiki:en:Covariance"
msgstr ""

#: ../plugins/fn-stat/functions.c:331 ../plugins/fn-stat/functions.c:361
msgid "wolfram:Covariance.html"
msgstr ""

#: ../plugins/fn-stat/functions.c:350
msgid "CORREL:Pearson correlation coefficient of two data sets"
msgstr ""

#: ../plugins/fn-stat/functions.c:352
msgid "array2:second data set"
msgstr ""

#: ../plugins/fn-stat/functions.c:358
msgid "Then CORREL(A1:A5,B1:B5) equals 0.996124788."
msgstr ""

#: ../plugins/fn-stat/functions.c:360
msgid "wiki:en:CorrelationCoefficient.html"
msgstr ""

#: ../plugins/fn-stat/functions.c:380
msgid ""
"NEGBINOMDIST:probability mass function of the negative binomial distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:381
msgid "f:number of failures"
msgstr ""

#: ../plugins/fn-stat/functions.c:382
msgid "t:threshold number of successes"
msgstr ""

#: ../plugins/fn-stat/functions.c:383
msgid "p:probability of a success"
msgstr ""

#: ../plugins/fn-stat/functions.c:384
msgid "If @{f} or @{t} is a non-integer it is truncated."
msgstr ""

#: ../plugins/fn-stat/functions.c:385
msgid "If (@{f} + @{t} -1) <= 0 this function returns a #NUM! error."
msgstr ""

#: ../plugins/fn-stat/functions.c:386
msgid "If @{p} < 0 or @{p} > 1 this functions returns a #NUM! error."
msgstr ""

#: ../plugins/fn-stat/functions.c:409
msgid ""
"NORMSDIST:cumulative density function of the standard normal distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:412
msgid "NORMSDIST is the OpenFormula function LEGACY.NORMSDIST."
msgstr ""

#: ../plugins/fn-stat/functions.c:415 ../plugins/fn-stat/functions.c:440
msgid "wiki:en:Normal_distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:416 ../plugins/fn-stat/functions.c:441
msgid "wolfram:NormalDistribution.html"
msgstr ""

#: ../plugins/fn-stat/functions.c:433
msgid ""
"NORMSINV:inverse of the cumulative density function of the standard normal "
"distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:434
msgid "p:given probability"
msgstr ""

#: ../plugins/fn-stat/functions.c:435
msgid "If @{p} < 0 or @{p} > 1 this function returns #NUM! error."
msgstr ""

#: ../plugins/fn-stat/functions.c:437
msgid "NORMSINV is the OpenFormula function LEGACY.NORMSINV."
msgstr ""

#: ../plugins/fn-stat/functions.c:461
msgid ""
"LOGNORMDIST:cumulative distribution function of the lognormal distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:463 ../plugins/fn-stat/functions.c:493
msgid "mean:mean"
msgstr ""

#: ../plugins/fn-stat/functions.c:464 ../plugins/fn-stat/functions.c:494
msgid "stddev:standard deviation"
msgstr ""

#: ../plugins/fn-stat/functions.c:465
msgid "If @{stddev} = 0 LOGNORMDIST returns a #DIV/0! error."
msgstr ""

#: ../plugins/fn-stat/functions.c:466
msgid ""
"If @{x} <= 0, @{mean} < 0 or @{stddev} <= 0 this function returns a #NUM! "
"error."
msgstr ""

#: ../plugins/fn-stat/functions.c:470 ../plugins/fn-stat/functions.c:499
msgid "wiki:en:Log-normal_distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:471 ../plugins/fn-stat/functions.c:500
msgid "wolfram:LogNormalDistribution.html"
msgstr ""

#: ../plugins/fn-stat/functions.c:491
msgid ""
"LOGINV:inverse of the cumulative distribution function of the lognormal "
"distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:495
msgid ""
"If @{p} < 0 or @{p} > 1 or @{stddev} <= 0 this function returns #NUM! error."
msgstr ""

#: ../plugins/fn-stat/functions.c:522
msgid "FISHERINV:inverse of the Fisher transformation"
msgstr ""

#: ../plugins/fn-stat/functions.c:524
msgid "If @{x} is a non-number this function returns a #VALUE! error."
msgstr ""

#: ../plugins/fn-stat/functions.c:540
msgid "MODE:first most common number in the dataset"
msgstr ""

#: ../plugins/fn-stat/functions.c:541 ../plugins/fn-stat/functions.c:569
#: ../plugins/fn-stat/functions.c:596 ../plugins/fn-stat/functions.c:623
#: ../plugins/fn-stat/functions.c:659 ../plugins/fn-stat/functions.c:693
#: ../plugins/fn-stat/functions.c:719 ../plugins/fn-stat/functions.c:754
#: ../plugins/fn-stat/functions.c:789 ../plugins/fn-stat/functions.c:818
#: ../plugins/fn-stat/functions.c:1815 ../plugins/fn-stat/functions.c:1846
#: ../plugins/fn-stat/functions.c:1872 ../plugins/fn-stat/functions.c:1896
#: ../plugins/fn-stat/functions.c:2025 ../plugins/fn-stat/functions.c:2438
#: ../plugins/fn-stat/functions.c:2463 ../plugins/fn-stat/functions.c:2490
msgid "number1:first value"
msgstr ""

#: ../plugins/fn-stat/functions.c:542 ../plugins/fn-stat/functions.c:570
#: ../plugins/fn-stat/functions.c:597 ../plugins/fn-stat/functions.c:624
#: ../plugins/fn-stat/functions.c:660 ../plugins/fn-stat/functions.c:694
#: ../plugins/fn-stat/functions.c:720 ../plugins/fn-stat/functions.c:755
#: ../plugins/fn-stat/functions.c:790 ../plugins/fn-stat/functions.c:819
#: ../plugins/fn-stat/functions.c:1816 ../plugins/fn-stat/functions.c:1847
#: ../plugins/fn-stat/functions.c:1873 ../plugins/fn-stat/functions.c:1897
#: ../plugins/fn-stat/functions.c:2026 ../plugins/fn-stat/functions.c:2439
#: ../plugins/fn-stat/functions.c:2464 ../plugins/fn-stat/functions.c:2491
msgid "number2:second value"
msgstr ""

#: ../plugins/fn-stat/functions.c:544
msgid ""
"If the data set does not contain any duplicates this function returns a #N/A "
"error."
msgstr ""

#: ../plugins/fn-stat/functions.c:546
msgid ""
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
"11.4, 25.9, and 40.1."
msgstr ""

#: ../plugins/fn-stat/functions.c:547
msgid "Then MODE(A1:A5) equals 11.4."
msgstr ""

#: ../plugins/fn-stat/functions.c:549
msgid "wiki:en:Mode_(statistics)"
msgstr ""

#: ../plugins/fn-stat/functions.c:550
msgid "wolfram:Mode.html"
msgstr ""

#: ../plugins/fn-stat/functions.c:568
msgid "HARMEAN:harmonic mean"
msgstr ""

#: ../plugins/fn-stat/functions.c:571
msgid ""
"The harmonic mean of N data points is  N divided by the sum of the "
"reciprocals of the data points)."
msgstr ""

#: ../plugins/fn-stat/functions.c:574
msgid "Then HARMEAN(A1:A5) equals 19.529814427."
msgstr ""

#: ../plugins/fn-stat/functions.c:576
msgid "wiki:en:Harmonic_mean"
msgstr ""

#: ../plugins/fn-stat/functions.c:577
msgid "wolfram:HarmonicMean.html"
msgstr ""

#: ../plugins/fn-stat/functions.c:595
msgid "GEOMEAN:geometric mean"
msgstr ""

#: ../plugins/fn-stat/functions.c:598
msgid ""
"The geometric mean is equal to the Nth root of the product of the N values."
msgstr ""

#: ../plugins/fn-stat/functions.c:601
msgid "Then GEOMEAN(A1:A5) equals 21.279182482."
msgstr ""

#: ../plugins/fn-stat/functions.c:603
msgid "wiki:en:Geometric_mean"
msgstr ""

#: ../plugins/fn-stat/functions.c:604
msgid "wolfram:GeometricMean.html"
msgstr ""

#: ../plugins/fn-stat/functions.c:622
msgid "COUNT:total number of integer or floating point arguments passed"
msgstr ""

#: ../plugins/fn-stat/functions.c:627
msgid "Then COUNT(A1:A5) equals 5."
msgstr ""

#: ../plugins/fn-stat/functions.c:658
msgid "COUNTA:number of arguments passed not including empty cells"
msgstr ""

#: ../plugins/fn-stat/functions.c:662
msgid ""
"Let us assume that the cells A1, A2, ..., A5 contain numbers and strings "
"11.4, \"missing\", \"missing\", 25.9, and 40.1."
msgstr ""

#: ../plugins/fn-stat/functions.c:663
msgid "Then COUNTA(A1:A5) equals 5."
msgstr ""

#: ../plugins/fn-stat/functions.c:692
msgid "AVERAGE:average of all the numeric values and cells"
msgstr ""

#: ../plugins/fn-stat/functions.c:697
msgid "Then AVERAGE(A1:A5) equals 23.2."
msgstr ""

#: ../plugins/fn-stat/functions.c:699
msgid "wiki:en:Arithmetic_mean"
msgstr ""

#: ../plugins/fn-stat/functions.c:700
msgid "wolfram:ArithmeticMean.html"
msgstr ""

#: ../plugins/fn-stat/functions.c:718
msgid ""
"MIN:smallest value, with negative numbers considered smaller than positive "
"numbers"
msgstr ""

#: ../plugins/fn-stat/functions.c:723
msgid "Then MIN(A1:A5) equals 11.4."
msgstr ""

#: ../plugins/fn-stat/functions.c:753
msgid ""
"MAX:largest value, with negative numbers considered smaller than positive "
"numbers"
msgstr ""

#: ../plugins/fn-stat/functions.c:758
msgid "Then MAX(A1:A5) equals 40.1."
msgstr ""

#: ../plugins/fn-stat/functions.c:788
msgid "SKEW:unbiased estimate for skewness of a distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:792
msgid ""
"This is only meaningful if the underlying distribution really has a third "
"moment.  The skewness of a symmetric (e.g., normal) distribution is zero."
msgstr ""

#: ../plugins/fn-stat/functions.c:795
msgid ""
"If less than three numbers are given, this function returns a #DIV/0! error."
msgstr ""

#: ../plugins/fn-stat/functions.c:798
msgid "Then SKEW(A1:A5) equals 0.976798268."
msgstr ""

#: ../plugins/fn-stat/functions.c:817
msgid "SKEWP:population skewness of a data set"
msgstr ""

#: ../plugins/fn-stat/functions.c:821
msgid "If less than two numbers are given, SKEWP returns a #DIV/0! error."
msgstr ""

#: ../plugins/fn-stat/functions.c:823
msgid "Then SKEWP(A1:A5) equals 0.655256198."
msgstr ""

#: ../plugins/fn-stat/functions.c:842
msgid ""
"EXPONDIST:probability density or cumulative distribution function of the "
"exponential distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:844
msgid "y:scale parameter"
msgstr ""

#: ../plugins/fn-stat/functions.c:845 ../plugins/fn-stat/functions.c:915
#: ../plugins/fn-stat/functions.c:1541 ../plugins/fn-stat/functions.c:1721
#: ../plugins/fn-stat/functions.c:1757
msgid ""
"cumulative:whether to evaluate the density function or the cumulative "
"distribution function"
msgstr ""

#: ../plugins/fn-stat/functions.c:846
msgid ""
"If @{cumulative} is false it will return:\t@{y} * exp (-@{y}*@{x}),otherwise "
"it will return\t1 - exp (-@{y}*@{x})."
msgstr ""

#: ../plugins/fn-stat/functions.c:849
msgid "If @{x} < 0 or @{y} <= 0 this will return an error."
msgstr ""

#: ../plugins/fn-stat/functions.c:875
msgid "BERNOULLI:probability mass function of a Bernoulli distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:876
msgid "k:integer"
msgstr ""

#: ../plugins/fn-stat/functions.c:878
msgid "If @{k} != 0 and @{k} != 1 this function returns a #NUM! error."
msgstr ""

#: ../plugins/fn-stat/functions.c:879 ../plugins/fn-stat/functions.c:948
#: ../plugins/fn-stat/functions.c:1159 ../plugins/fn-stat/functions.c:1446
#: ../plugins/fn-stat/functions.c:1479 ../plugins/fn-stat/functions.c:1513
#: ../plugins/fn-stat/functions.c:1574 ../plugins/fn-stat/functions.c:4285
msgid "If @{p} < 0 or @{p} > 1 this function returns a #NUM! error."
msgstr ""

#: ../plugins/fn-stat/functions.c:911
msgid ""
"GAMMADIST:probability density or cumulative distribution function of the "
"gamma distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:913 ../plugins/fn-stat/functions.c:946
#: ../plugins/fn-stat/functions.c:1118 ../plugins/fn-stat/functions.c:1155
#: ../plugins/fn-stat/functions.c:1719
msgid "alpha:scale parameter"
msgstr ""

#: ../plugins/fn-stat/functions.c:914 ../plugins/fn-stat/functions.c:947
#: ../plugins/fn-stat/functions.c:1119 ../plugins/fn-stat/functions.c:1156
#: ../plugins/fn-stat/functions.c:1720
msgid "beta:scale parameter"
msgstr ""

#: ../plugins/fn-stat/functions.c:916 ../plugins/fn-stat/functions.c:1280
#: ../plugins/fn-stat/functions.c:1725 ../plugins/fn-stat/functions.c:1954
msgid "If @{x} < 0 this function returns a #NUM! error."
msgstr ""

#: ../plugins/fn-stat/functions.c:917 ../plugins/fn-stat/functions.c:1123
#: ../plugins/fn-stat/functions.c:1160
msgid "If @{alpha} <= 0 or @{beta} <= 0, this function returns a #NUM! error."
msgstr ""

#: ../plugins/fn-stat/functions.c:944
msgid "GAMMAINV:inverse of the cumulative gamma distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:949 ../plugins/fn-stat/functions.c:1726
msgid "If @{alpha} <= 0 or @{beta} <= 0 this function returns a #NUM! error."
msgstr ""

#: ../plugins/fn-stat/functions.c:974
msgid "CHIDIST:survival function of the chi-squared distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:976 ../plugins/fn-stat/functions.c:1004
#: ../plugins/fn-stat/functions.c:1190 ../plugins/fn-stat/functions.c:1242
msgid "dof:number of degrees of freedom"
msgstr ""

#: ../plugins/fn-stat/functions.c:977 ../plugins/fn-stat/functions.c:1005
#: ../plugins/fn-stat/functions.c:1192 ../plugins/fn-stat/functions.c:1243
#: ../plugins/fn-stat/functions.c:1279 ../plugins/fn-stat/functions.c:1445
msgid "The survival function is 1 minus the cumulative distribution function."
msgstr ""

#: ../plugins/fn-stat/functions.c:978
msgid "If @{dof} is non-integer it is truncated."
msgstr ""

#: ../plugins/fn-stat/functions.c:979 ../plugins/fn-stat/functions.c:1193
msgid "If @{dof} < 1 this function returns a #NUM! error."
msgstr ""

#: ../plugins/fn-stat/functions.c:981
msgid ""
"CHIDIST(@{x},@{dof}) is the OpenFormula function LEGACY.CHIDIST(@{x},@{dof})."
msgstr ""

#: ../plugins/fn-stat/functions.c:1002
msgid "CHIINV:inverse of the survival function of the chi-squared distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:1006 ../plugins/fn-stat/functions.c:1244
msgid ""
"If @{p} < 0 or @{p} > 1 or @{dof} < 1 this function returns a #NUM! error."
msgstr ""

#: ../plugins/fn-stat/functions.c:1008
msgid ""
"CHIINV(@{p},@{dof}) is the OpenFormula function LEGACY.CHIDIST(@{p},@{dof})."
msgstr ""

#: ../plugins/fn-stat/functions.c:1029
msgid "CHITEST:p value of the Goodness of Fit Test"
msgstr ""

#: ../plugins/fn-stat/functions.c:1030
msgid "actual_range:observed data"
msgstr ""

#: ../plugins/fn-stat/functions.c:1031
msgid "theoretical_range:expected values"
msgstr ""

#: ../plugins/fn-stat/functions.c:1032
msgid ""
"If the actual range is not an n by 1 or 1 by n range, but an n by m range, "
"then CHITEST uses (n-1) times (m-1) as degrees of freedom. This is useful if "
"the expected values were calculated from the observed value in a test of "
"independence or test of homogeneity."
msgstr ""

#: ../plugins/fn-stat/functions.c:1038
msgid "CHITEST is the OpenFormula function LEGACY.CHITEST."
msgstr ""

#: ../plugins/fn-stat/functions.c:1116
msgid "BETADIST:cumulative distribution function of the beta distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:1120 ../plugins/fn-stat/functions.c:1157
msgid "a:optional lower bound, defaults to 0"
msgstr ""

#: ../plugins/fn-stat/functions.c:1121 ../plugins/fn-stat/functions.c:1158
msgid "b:optional upper bound, defaults to 1"
msgstr ""

#: ../plugins/fn-stat/functions.c:1122
msgid "If @{x} < @{a} or @{x} > @{b} this function returns a #NUM! error."
msgstr ""

#: ../plugins/fn-stat/functions.c:1124 ../plugins/fn-stat/functions.c:1161
msgid "If @{a} >= @{b} this function returns a #NUM! error."
msgstr ""

#: ../plugins/fn-stat/functions.c:1153
msgid ""
"BETAINV:inverse of the cumulative distribution function of the beta "
"distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:1188
msgid "TDIST:survival function of the Student t-distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:1191
msgid "tails:1 or 2"
msgstr ""

#: ../plugins/fn-stat/functions.c:1194
msgid "If @{tails} is neither 1 or 2 this function returns a #NUM! error."
msgstr ""

#: ../plugins/fn-stat/functions.c:1195
msgid ""
"The parameterization of this function is different from what is used for, e."
"g., NORMSDIST.  This is a common source of mistakes, but necessary for "
"compatibility."
msgstr ""

#: ../plugins/fn-stat/functions.c:1198
msgid "This function is Excel compatible for non-negative @{x}."
msgstr ""

#: ../plugins/fn-stat/functions.c:1240
msgid "TINV:inverse of the survival function of the Student t-distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:1246
msgid ""
"The parameterization of this function is different from what is used for, e."
"g., NORMSINV.  This is a common source of mistakes, but necessary for "
"compatibility."
msgstr ""

#: ../plugins/fn-stat/functions.c:1275
msgid "FDIST:survival function of the F distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:1277 ../plugins/fn-stat/functions.c:1443
msgid "dof_of_num:numerator degrees of freedom"
msgstr ""

#: ../plugins/fn-stat/functions.c:1278 ../plugins/fn-stat/functions.c:1444
msgid "dof_of_denom:denominator degrees of freedom"
msgstr ""

#: ../plugins/fn-stat/functions.c:1281
msgid ""
"If @{dof_of_num} < 1 or @{dof_of_denom} < 1, this function returns a #NUM! "
"error."
msgstr ""

#: ../plugins/fn-stat/functions.c:1283
msgid "FDIST is the OpenFormula function LEGACY.FDIST."
msgstr ""

#: ../plugins/fn-stat/functions.c:1305
msgid ""
"LANDAU:approximate probability density function of the Landau distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:1441
msgid "FINV:inverse of the survival function of the F distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:1447
msgid ""
"If @{dof_of_num} < 1 or @{dof_of_denom} < 1 this function returns a #NUM! "
"error."
msgstr ""

#: ../plugins/fn-stat/functions.c:1449
msgid "FINV is the OpenFormula function LEGACY.FINV."
msgstr ""

#: ../plugins/fn-stat/functions.c:1471
msgid ""
"BINOMDIST:probability mass or cumulative distribution function of the "
"binomial distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:1472
msgid "n:number of successes"
msgstr ""

#: ../plugins/fn-stat/functions.c:1473 ../plugins/fn-stat/functions.c:1507
#: ../plugins/fn-stat/functions.c:1569
msgid "trials:number of trials"
msgstr ""

#: ../plugins/fn-stat/functions.c:1474 ../plugins/fn-stat/functions.c:1508
#: ../plugins/fn-stat/functions.c:1570
msgid "p:probability of success in each trial"
msgstr ""

#: ../plugins/fn-stat/functions.c:1475 ../plugins/fn-stat/functions.c:1629
#: ../plugins/fn-stat/functions.c:1952 ../plugins/fn-stat/functions.c:4283
msgid ""
"cumulative:whether to evaluate the mass function or the cumulative "
"distribution function"
msgstr ""

#: ../plugins/fn-stat/functions.c:1476
msgid "If @{n} or @{trials} are non-integer they are truncated."
msgstr ""

#: ../plugins/fn-stat/functions.c:1477
msgid "If @{n} < 0 or @{trials} < 0 this function returns a #NUM! error."
msgstr ""

#: ../plugins/fn-stat/functions.c:1478
msgid "If @{n} > @{trials} this function returns a #NUM! error."
msgstr ""

#: ../plugins/fn-stat/functions.c:1506
msgid ""
"BINOM.DIST.RANGE:probability of the binomial distribution over an interval"
msgstr ""

#: ../plugins/fn-stat/functions.c:1509
msgid "start:start of the interval"
msgstr ""

#: ../plugins/fn-stat/functions.c:1510
msgid "end:end of the interval, defaults to @{start}"
msgstr ""

#: ../plugins/fn-stat/functions.c:1511
msgid "If @{start}, @{end} or @{trials} are non-integer they are truncated."
msgstr ""

#: ../plugins/fn-stat/functions.c:1512 ../plugins/fn-stat/functions.c:1573
msgid "If @{trials} < 0 this function returns a #NUM! error."
msgstr ""

#: ../plugins/fn-stat/functions.c:1514
msgid "If @{start} > @{end} this function returns 0."
msgstr ""

#: ../plugins/fn-stat/functions.c:1537
msgid ""
"CAUCHY:probability density or cumulative distribution function of the "
"Cauchy, Lorentz or Breit-Wigner distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:1540 ../plugins/fn-stat/functions.c:4313
#: ../plugins/fn-stat/functions.c:4452
msgid "a:scale parameter"
msgstr ""

#: ../plugins/fn-stat/functions.c:1542
msgid "If @{a} < 0 this function returns a #NUM! error."
msgstr ""

#: ../plugins/fn-stat/functions.c:1543 ../plugins/fn-stat/functions.c:4286
msgid ""
"If @{cumulative} is neither TRUE nor FALSE this function returns a #VALUE! "
"error."
msgstr ""

#: ../plugins/fn-stat/functions.c:1568
msgid "CRITBINOM:right-tailed critical value of the binomial distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:1571
msgid "alpha:significance level (area of the tail)"
msgstr ""

#: ../plugins/fn-stat/functions.c:1572
msgid "If @{trials} is a non-integer it is truncated."
msgstr ""

#: ../plugins/fn-stat/functions.c:1575
msgid "If @{alpha} < 0 or @{alpha} > 1 this function returns a #NUM! error."
msgstr ""

#: ../plugins/fn-stat/functions.c:1598
msgid "PERMUT:number of @{k}-permutations of a @{n}-set"
msgstr ""

#: ../plugins/fn-stat/functions.c:1599
msgid "n:size of the base set"
msgstr ""

#: ../plugins/fn-stat/functions.c:1600
msgid "k:number of elements in each permutation"
msgstr ""

#: ../plugins/fn-stat/functions.c:1601
msgid "If @{n} = 0 this function returns a #NUM! error."
msgstr ""

#: ../plugins/fn-stat/functions.c:1602
msgid "If @{n} < @{k} this function returns a #NUM! error."
msgstr ""

#: ../plugins/fn-stat/functions.c:1624
msgid ""
"HYPGEOMDIST:probability mass or cumulative distribution function of the "
"hypergeometric distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:1625
msgid "x:number of successes"
msgstr ""

#: ../plugins/fn-stat/functions.c:1626
msgid "n:sample size"
msgstr ""

#: ../plugins/fn-stat/functions.c:1627
msgid "M:number of possible successes in the population"
msgstr ""

#: ../plugins/fn-stat/functions.c:1628
msgid "N:population size"
msgstr ""

#: ../plugins/fn-stat/functions.c:1630
msgid "If @{x},@{n},@{M} or @{N} is a non-integer it is truncated."
msgstr ""

#: ../plugins/fn-stat/functions.c:1631
msgid "If @{x},@{n},@{M} or @{N} < 0 this function returns a #NUM! error."
msgstr ""

#: ../plugins/fn-stat/functions.c:1632
msgid "If @{x} > @{M} or @{n} > @{N} this function returns a #NUM! error."
msgstr ""

#: ../plugins/fn-stat/functions.c:1660
msgid ""
"CONFIDENCE:margin of error of a confidence interval for the population mean"
msgstr ""

#: ../plugins/fn-stat/functions.c:1661
msgid "alpha:significance level"
msgstr ""

#: ../plugins/fn-stat/functions.c:1662
msgid "stddev:population standard deviation"
msgstr ""

#: ../plugins/fn-stat/functions.c:1663
msgid "size:sample size"
msgstr ""

#: ../plugins/fn-stat/functions.c:1664
msgid ""
"This function requires the usually unknown population standard deviation."
msgstr ""

#: ../plugins/fn-stat/functions.c:1665
msgid "If @{size} is non-integer it is truncated."
msgstr ""

#: ../plugins/fn-stat/functions.c:1666
msgid "If @{size} < 0 this function returns a #NUM! error."
msgstr ""

#: ../plugins/fn-stat/functions.c:1667
msgid "If @{size} is 0 this function returns a #DIV/0! error."
msgstr ""

#: ../plugins/fn-stat/functions.c:1690
msgid "STANDARDIZE:z-score of a value"
msgstr ""

#: ../plugins/fn-stat/functions.c:1692
msgid "mean:mean of the original distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:1693
msgid "stddev:standard deviation of the original distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:1694 ../plugins/fn-stat/functions.c:1758
msgid "If @{stddev} is 0 this function returns a #DIV/0! error."
msgstr ""

#: ../plugins/fn-stat/functions.c:1717
msgid ""
"WEIBULL:probability density or cumulative distribution function of the "
"Weibull distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:1722
msgid ""
"If the @{cumulative} boolean is true it will return: 1 - exp (-(@{x}/@{beta})"
"^@{alpha}),otherwise it will return (@{alpha}/@{beta}^@{alpha}) * @{x}^(@"
"{alpha}-1) * exp(-(@{x}/@{beta}^@{alpha}))."
msgstr ""

#: ../plugins/fn-stat/functions.c:1753
msgid ""
"NORMDIST:probability density or cumulative distribution function of a normal "
"distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:1755 ../plugins/fn-stat/functions.c:1788
#: ../plugins/fn-stat/functions.c:1951
msgid "mean:mean of the distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:1756 ../plugins/fn-stat/functions.c:1789
msgid "stddev:standard deviation of the distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:1786
msgid ""
"NORMINV:inverse of the cumulative distribution function of a normal "
"distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:1790
msgid ""
"If @{p} < 0 or @{p} > 1 or @{stddev} <= 0 this function returns a #NUM! "
"error."
msgstr ""

#: ../plugins/fn-stat/functions.c:1814
msgid "KURT:unbiased estimate of the kurtosis of a data set"
msgstr ""

#: ../plugins/fn-stat/functions.c:1818
msgid ""
"This is only meaningful if the underlying distribution really has a fourth "
"moment.  The kurtosis is offset by three such that a normal distribution "
"will have zero kurtosis."
msgstr ""

#: ../plugins/fn-stat/functions.c:1822
msgid ""
"If fewer than four numbers are given or all of them are equal this function "
"returns a #DIV/0! error."
msgstr ""

#: ../plugins/fn-stat/functions.c:1826
msgid "Then KURT(A1:A5) equals 1.234546305."
msgstr ""

#: ../plugins/fn-stat/functions.c:1845
msgid "KURTP:population kurtosis of a data set"
msgstr ""

#: ../plugins/fn-stat/functions.c:1849
msgid ""
"If fewer than two numbers are given or all of them are equal this function "
"returns a #DIV/0! error."
msgstr ""

#: ../plugins/fn-stat/functions.c:1852
msgid "Then KURTP(A1:A5) equals -0.691363424."
msgstr ""

#: ../plugins/fn-stat/functions.c:1871
msgid "AVEDEV:average of the absolute deviations of a data set"
msgstr ""

#: ../plugins/fn-stat/functions.c:1876
msgid "Then AVEDEV(A1:A5) equals 7.84."
msgstr ""

#: ../plugins/fn-stat/functions.c:1895
msgid "DEVSQ:sum of squares of deviations of a data set"
msgstr ""

#: ../plugins/fn-stat/functions.c:1901
msgid "Then DEVSQ(A1:A5) equals 470.56."
msgstr ""

#: ../plugins/fn-stat/functions.c:1920
msgid "FISHER:Fisher transformation"
msgstr ""

#: ../plugins/fn-stat/functions.c:1922
msgid "If @{x} is not a number, this function returns a #VALUE! error."
msgstr ""

#: ../plugins/fn-stat/functions.c:1923
msgid "If @{x} <= -1 or @{x} >= 1, this function returns a #NUM! error."
msgstr ""

#: ../plugins/fn-stat/functions.c:1949
msgid ""
"POISSON:probability mass or cumulative distribution function of the Poisson "
"distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:1950
msgid "x:number of events"
msgstr ""

#: ../plugins/fn-stat/functions.c:1953
msgid "If @{x} is a non-integer it is truncated."
msgstr ""

#: ../plugins/fn-stat/functions.c:1955
msgid "If @{mean} <= 0 POISSON returns the #NUM! error."
msgstr ""

#: ../plugins/fn-stat/functions.c:1981
msgid "PEARSON:Pearson correlation coefficient of the paired set of data"
msgstr ""

#: ../plugins/fn-stat/functions.c:1982 ../plugins/fn-stat/functions.c:2001
msgid "array1:first component values"
msgstr ""

#: ../plugins/fn-stat/functions.c:1983 ../plugins/fn-stat/functions.c:2002
msgid "array2:second component values"
msgstr ""

#: ../plugins/fn-stat/functions.c:2000
msgid ""
"RSQ:square of the Pearson correlation coefficient of the paired set of data"
msgstr ""

#: ../plugins/fn-stat/functions.c:2024
msgid "MEDIAN:median of a data set"
msgstr ""

#: ../plugins/fn-stat/functions.c:2028
msgid ""
"If even numbers are given MEDIAN returns the average of the two numbers in "
"the center."
msgstr ""

#: ../plugins/fn-stat/functions.c:2032
msgid "Then MEDIAN(A1:A5) equals 21.3."
msgstr ""

#: ../plugins/fn-stat/functions.c:2034
msgid "wiki:en:Median"
msgstr ""

#: ../plugins/fn-stat/functions.c:2035
msgid "wolfram:StatisticalMedian.html"
msgstr ""

#: ../plugins/fn-stat/functions.c:2054
msgid ""
"SSMEDIAN:median for grouped data as commonly determined in the social "
"sciences"
msgstr ""

#: ../plugins/fn-stat/functions.c:2055
msgid "array:data set"
msgstr ""

#: ../plugins/fn-stat/functions.c:2056
msgid "interval:length of each grouping interval, defaults to 1"
msgstr ""

#: ../plugins/fn-stat/functions.c:2057
msgid ""
"The data points given in @{array} are assumed to be the result of grouping "
"data into intervals of length @{interval}"
msgstr ""

#: ../plugins/fn-stat/functions.c:2059 ../plugins/fn-stat/functions.c:2731
#: ../plugins/fn-stat/functions.c:2773
msgid "If @{array} is empty, this function returns a #NUM! error."
msgstr ""

#: ../plugins/fn-stat/functions.c:2060
msgid ""
"If @{interval} <= 0, this function returns a #NUM! error.SSMEDIAN does not "
"check whether the data points are at least @{interval} apart."
msgstr ""

#: ../plugins/fn-stat/functions.c:2063
msgid "Let us assume that the cells A1, A2, A3 contain numbers 7, 8, 8."
msgstr ""

#: ../plugins/fn-stat/functions.c:2064
msgid "Then SSMEDIAN(A1:A3, 1) equals 7.75."
msgstr ""

#: ../plugins/fn-stat/functions.c:2146
msgid "LARGE:@{k}-th largest value in a data set"
msgstr ""

#: ../plugins/fn-stat/functions.c:2147 ../plugins/fn-stat/functions.c:2190
msgid "data:data set"
msgstr ""

#: ../plugins/fn-stat/functions.c:2148 ../plugins/fn-stat/functions.c:2191
msgid "k:which value to find"
msgstr ""

#: ../plugins/fn-stat/functions.c:2149 ../plugins/fn-stat/functions.c:2192
msgid "If data set is empty this function returns a #NUM! error."
msgstr ""

#: ../plugins/fn-stat/functions.c:2150 ../plugins/fn-stat/functions.c:2193
msgid ""
"If @{k} <= 0 or @{k} is greater than the number of data items given this "
"function returns a #NUM! error."
msgstr ""

#: ../plugins/fn-stat/functions.c:2155
msgid "Then LARGE(A1:A5,2) equals 25.9.LARGE(A1:A5,4) equals 17.3."
msgstr ""

#: ../plugins/fn-stat/functions.c:2189
msgid "SMALL:@{k}-th smallest value in a data set"
msgstr ""

#: ../plugins/fn-stat/functions.c:2198
msgid "Then SMALL(A1:A5,2) equals 17.3.SMALL(A1:A5,4) equals 25.9."
msgstr ""

#: ../plugins/fn-stat/functions.c:2233
msgid ""
"PROB:probability of an interval for a discrete (and finite) probability "
"distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:2234
msgid "x_range:possible values"
msgstr ""

#: ../plugins/fn-stat/functions.c:2235
msgid "prob_range:probabilities of the corresponding values"
msgstr ""

#: ../plugins/fn-stat/functions.c:2236
msgid "lower_limit:lower interval limit"
msgstr ""

#: ../plugins/fn-stat/functions.c:2237
msgid "upper_limit:upper interval limit, defaults to @{lower_limit}"
msgstr ""

#: ../plugins/fn-stat/functions.c:2238
msgid ""
"If the sum of the probabilities in @{prob_range} is not equal to 1 this "
"function returns a #NUM! error."
msgstr ""

#: ../plugins/fn-stat/functions.c:2240
msgid ""
"If any value in @{prob_range} is <=0 or > 1, this function returns a #NUM! "
"error."
msgstr ""

#: ../plugins/fn-stat/functions.c:2242
msgid ""
"If @{x_range} and @{prob_range} contain a different number of data entries, "
"this function returns a #N/A error."
msgstr ""

#: ../plugins/fn-stat/functions.c:2319
msgid "STEYX:standard error of the predicted y-value in the regression"
msgstr ""

#: ../plugins/fn-stat/functions.c:2320 ../plugins/fn-stat/functions.c:3365
#: ../plugins/fn-stat/functions.c:3481 ../plugins/fn-stat/functions.c:3723
#: ../plugins/fn-stat/functions.c:3821 ../plugins/fn-stat/functions.c:3908
#: ../plugins/fn-stat/functions.c:3967 ../plugins/fn-stat/functions.c:4019
msgid "known_ys:known y-values"
msgstr ""

#: ../plugins/fn-stat/functions.c:2321 ../plugins/fn-stat/functions.c:3482
#: ../plugins/fn-stat/functions.c:3909 ../plugins/fn-stat/functions.c:3968
#: ../plugins/fn-stat/functions.c:4020
msgid "known_xs:known x-values"
msgstr ""

#: ../plugins/fn-stat/functions.c:2322
msgid ""
"If @{known_ys} and @{known_xs} are empty or have a different number of "
"arguments then this function returns a #N/A error."
msgstr ""

#: ../plugins/fn-stat/functions.c:2328
msgid "Then STEYX(A1:A5,B1:B5) equals 1.101509979."
msgstr ""

#: ../plugins/fn-stat/functions.c:2372
msgid ""
"ZTEST:the probability of observing a sample mean as large as or larger than "
"the mean of the given sample"
msgstr ""

#: ../plugins/fn-stat/functions.c:2374
msgid "ref:data set (sample)"
msgstr ""

#: ../plugins/fn-stat/functions.c:2375
msgid "x:population mean"
msgstr ""

#: ../plugins/fn-stat/functions.c:2376
msgid ""
"stddev:population standard deviation, defaults to the sample standard "
"deviation"
msgstr ""

#: ../plugins/fn-stat/functions.c:2377
msgid ""
"ZTEST calulates the probability of observing a sample mean as large as or "
"larger than the mean of the given sample for samples drawn from a normal "
"distribution with mean @{x} and standard deviation @{stddev}."
msgstr ""

#: ../plugins/fn-stat/functions.c:2380
msgid ""
"If @{ref} contains less than two data items ZTEST returns #DIV/0! error."
msgstr ""

#: ../plugins/fn-stat/functions.c:2386
msgid "Then ZTEST(A1:A5,20) equals 0.254717826."
msgstr ""

#: ../plugins/fn-stat/functions.c:2437
msgid "AVERAGEA:average of all the values and cells"
msgstr ""

#: ../plugins/fn-stat/functions.c:2442 ../plugins/fn-stat/functions.c:2467
#: ../plugins/fn-stat/functions.c:2494 ../plugins/fn-stat/functions.c:2526
#: ../plugins/fn-stat/functions.c:2553 ../plugins/fn-stat/functions.c:2583
#: ../plugins/fn-stat/functions.c:2610
msgid ""
"Let us assume that the cells A1, A2, ..., A5 contain numbers and strings "
"11.4, 17.3, \"missing\", 25.9, and 40.1."
msgstr ""

#: ../plugins/fn-stat/functions.c:2443
msgid "Then AVERAGEA(A1:A5) equals 18.94."
msgstr ""

#: ../plugins/fn-stat/functions.c:2462
msgid ""
"MAXA:largest value, with negative numbers considered smaller than positive "
"numbers"
msgstr ""

#: ../plugins/fn-stat/functions.c:2469
msgid "Then MAXA(A1:A5) equals 40.1."
msgstr ""

#: ../plugins/fn-stat/functions.c:2489
msgid ""
"MINA:smallest value, with negative numbers considered smaller than positive "
"numbers"
msgstr ""

#: ../plugins/fn-stat/functions.c:2496
msgid "Then MINA(A1:A5) equals 0."
msgstr ""

#: ../plugins/fn-stat/functions.c:2516
msgid "VARA:sample variance of the given sample"
msgstr ""

#: ../plugins/fn-stat/functions.c:2519
msgid "VARA is also known as the N-1-variance."
msgstr ""

#: ../plugins/fn-stat/functions.c:2520
msgid "To get the true variance of a complete population use VARPA."
msgstr ""

#: ../plugins/fn-stat/functions.c:2528
msgid "Then VARA(A1:A5) equals 228.613."
msgstr ""

#: ../plugins/fn-stat/functions.c:2547
msgid "VARPA:variance of an entire population"
msgstr ""

#: ../plugins/fn-stat/functions.c:2550
msgid "VARPA is also known as the N-variance."
msgstr ""

#: ../plugins/fn-stat/functions.c:2555
msgid "Then VARPA(A1:A5) equals 182.8904."
msgstr ""

#: ../plugins/fn-stat/functions.c:2574
msgid "STDEVA:sample standard deviation of the given sample"
msgstr ""

#: ../plugins/fn-stat/functions.c:2578
msgid "STDEVA is also known as the N-1-standard deviation."
msgstr ""

#: ../plugins/fn-stat/functions.c:2579
msgid ""
"To obtain the population standard deviation of a whole population use "
"STDEVPA."
msgstr ""

#: ../plugins/fn-stat/functions.c:2585
msgid "Then STDEVA(A1:A5) equals 15.119953704."
msgstr ""

#: ../plugins/fn-stat/functions.c:2604
msgid "STDEVPA:population standard deviation of an entire population"
msgstr ""

#: ../plugins/fn-stat/functions.c:2612
msgid "Then STDEVPA(A1:A5) equals 13.523697719."
msgstr ""

#: ../plugins/fn-stat/functions.c:2631
msgid "PERCENTRANK:rank of a data point in a data set"
msgstr ""

#: ../plugins/fn-stat/functions.c:2632
msgid "array:range of numeric values"
msgstr ""

#: ../plugins/fn-stat/functions.c:2633
msgid "x:data point to be ranked"
msgstr ""

#: ../plugins/fn-stat/functions.c:2634
msgid "significance:number of significant digits, defaults to 3"
msgstr ""

#: ../plugins/fn-stat/functions.c:2635
msgid ""
"If @{array} contains no data points, this function returns a #NUM! error."
msgstr ""

#: ../plugins/fn-stat/functions.c:2637
msgid ""
"If @{significance} is less than one, this function returns a #NUM! error."
msgstr ""

#: ../plugins/fn-stat/functions.c:2639
msgid ""
"If @{x} exceeds the largest value or is less than the smallest value in @"
"{array}, this function returns a #NUM! error."
msgstr ""

#: ../plugins/fn-stat/functions.c:2641
msgid ""
"If @{x} does not match any of the values in @{array} or @{x} matches more "
"than once, this function interpolates the returned value."
msgstr ""

#: ../plugins/fn-stat/functions.c:2728
msgid ""
"PERCENTILE:determines the  100*@{k}-th percentile of the given data points"
msgstr ""

#: ../plugins/fn-stat/functions.c:2729 ../plugins/fn-stat/functions.c:2771
msgid "array:data points"
msgstr ""

#: ../plugins/fn-stat/functions.c:2730
msgid "k:which percentile to calculate"
msgstr ""

#: ../plugins/fn-stat/functions.c:2732
msgid "If @{k} < 0 or @{k} > 1, this function returns a #NUM! error."
msgstr ""

#: ../plugins/fn-stat/functions.c:2735
msgid "Then PERCENTILE(A1:A5,0.42) equals 20.02."
msgstr ""

#: ../plugins/fn-stat/functions.c:2770
msgid "QUARTILE:the @{k}-th quartile of the data points"
msgstr ""

#: ../plugins/fn-stat/functions.c:2772
msgid "quart:a number from 0 to 4, indicating which quartile to calculate"
msgstr ""

#: ../plugins/fn-stat/functions.c:2774
msgid ""
"If @{quart} < 0 or @{quart} > 4, this function returns a #NUM! error. If @"
"{quart} = 0, the smallest value of @{array} to be returned."
msgstr ""

#: ../plugins/fn-stat/functions.c:2775
msgid "If @{quart} is not an integer, it is truncated."
msgstr ""

#: ../plugins/fn-stat/functions.c:2778
msgid "Then QUARTILE(A1:A5,1) equals 17.3."
msgstr ""

#: ../plugins/fn-stat/functions.c:2813
msgid ""
"FTEST:p-value for the two-tailed hypothesis test comparing the variances of "
"two populations"
msgstr ""

#: ../plugins/fn-stat/functions.c:2815 ../plugins/fn-stat/functions.c:2872
msgid "array1:sample from the first population"
msgstr ""

#: ../plugins/fn-stat/functions.c:2816 ../plugins/fn-stat/functions.c:2873
msgid "array2:sample from the second population"
msgstr ""

#: ../plugins/fn-stat/functions.c:2821
msgid "Then FTEST(A1:A5,B1:B5) equals 0.510815017."
msgstr ""

#: ../plugins/fn-stat/functions.c:2870
msgid ""
"TTEST:p-value for a hypothesis test comparing the means of two populations "
"using the Student t-distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:2874
msgid "tails:number of tails to consider"
msgstr ""

#: ../plugins/fn-stat/functions.c:2875
msgid ""
"type:Type of test to perform. 1 indicates a test for paired variables, 2 a "
"test of unpaired variables with equal variances, and 3 a test of unpaired "
"variables with unequal variances"
msgstr ""

#: ../plugins/fn-stat/functions.c:2878
msgid ""
"If the data sets contain a different number of data points and the test is "
"paired (@{type} one), TTEST returns the #N/A error."
msgstr ""

#: ../plugins/fn-stat/functions.c:2880
msgid "@{tails} and @{type} are truncated to integers."
msgstr ""

#: ../plugins/fn-stat/functions.c:2881
msgid "If @{tails} is not one or two, this function returns a #NUM! error."
msgstr ""

#: ../plugins/fn-stat/functions.c:2882
msgid ""
"If @{type} is any other than one, two, or three, this function returns a "
"#NUM! error."
msgstr ""

#: ../plugins/fn-stat/functions.c:2887
msgid ""
"Then TTEST(A1:A5,B1:B5,1,1) equals 0.003127619.TTEST(A1:A5,B1:B5,2,1) equals "
"0.006255239.TTEST(A1:A5,B1:B5,1,2) equals 0.111804322.TTEST(A1:A5,B1:B5,1,3) "
"equals 0.113821797."
msgstr ""

#: ../plugins/fn-stat/functions.c:3045
msgid "FREQUENCY:frequency table"
msgstr ""

#: ../plugins/fn-stat/functions.c:3046
msgid "data_array:data values"
msgstr ""

#: ../plugins/fn-stat/functions.c:3047
msgid "bins_array:array of cutoff values"
msgstr ""

#: ../plugins/fn-stat/functions.c:3048
msgid "The results are given as an array."
msgstr ""

#: ../plugins/fn-stat/functions.c:3049
msgid ""
"If the @{bins_array} is empty, this function returns the number of data "
"points in @{data_array}."
msgstr ""

#: ../plugins/fn-stat/functions.c:3267
msgid "LINEST:multiple linear regression coefficients and statistics"
msgstr ""

#: ../plugins/fn-stat/functions.c:3268 ../plugins/fn-stat/functions.c:3576
msgid "known_ys:vector of values of dependent variable"
msgstr ""

#: ../plugins/fn-stat/functions.c:3269 ../plugins/fn-stat/functions.c:3577
msgid ""
"known_xs:array of values of independent variables, defaults to a single "
"vector {1,…,n}"
msgstr ""

#: ../plugins/fn-stat/functions.c:3270 ../plugins/fn-stat/functions.c:3367
#: ../plugins/fn-stat/functions.c:3579 ../plugins/fn-stat/functions.c:3725
#: ../plugins/fn-stat/functions.c:3824
msgid "affine:if true, the model contains a constant term, defaults to true"
msgstr ""

#: ../plugins/fn-stat/functions.c:3271
msgid ""
"stats:if true, some additional statistics are provided, defaults to false"
msgstr ""

#: ../plugins/fn-stat/functions.c:3272
msgid ""
"This function returns an array with the first row giving the regression "
"coefficients for the independent variables x_m, x_(m-1),…,x_2, x_1 followed "
"by the y-intercept if @{affine} is true."
msgstr ""

#: ../plugins/fn-stat/functions.c:3275
msgid ""
"If @{stats} is true, the second row contains the corresponding standard "
"errors of the regression coefficients.In this case, the third row contains "
"the R^2 value and the standard error for the predicted value. The fourth row "
"contains the observed F value and its degrees of freedom. Finally, the fifth "
"row contains the regression sum of squares and the residual sum of squares."
msgstr ""

#: ../plugins/fn-stat/functions.c:3282
msgid ""
"If @{affine} is false, R^2 is the uncentered version of the coefficient of "
"determination; that is the proportion of the sum of squares explained by the "
"model."
msgstr ""

#: ../plugins/fn-stat/functions.c:3285 ../plugins/fn-stat/functions.c:3580
msgid ""
"If the length of @{known_ys} does not match the corresponding length of @"
"{known_xs}, this function returns a #NUM! error."
msgstr ""

#: ../plugins/fn-stat/functions.c:3364
msgid "LOGREG:the logarithmic regression"
msgstr ""

#: ../plugins/fn-stat/functions.c:3366 ../plugins/fn-stat/functions.c:3822
msgid "known_xs:known x-values; defaults to the array {1, 2, 3, …}"
msgstr ""

#: ../plugins/fn-stat/functions.c:3368 ../plugins/fn-stat/functions.c:3726
msgid ""
"stat:if true, extra statistical information will be returned; defaults to "
"FALSE"
msgstr ""

#: ../plugins/fn-stat/functions.c:3369
msgid ""
"LOGREG function transforms your x's to z=ln(x) and applies the “least "
"squares” method to fit the linear equation y = m * z + b to your y's and z's "
"--- equivalent to fitting the equation y = m * ln(x) + b to y's and x's. "
"LOGREG returns an array having two columns and one row. m is given in the "
"first column and b in the second. "
msgstr ""

#: ../plugins/fn-stat/functions.c:3377
msgid ""
"Any extra statistical information is written below m and b in the result "
"array.  This extra statistical information consists of four rows of data:  "
"In the first row the standard error values for the coefficients m, b are "
"given.  The second row contains the square of R and the standard error for "
"the y estimate. The third row contains the F-observed value and the degrees "
"of freedom.  The last row contains the regression sum of squares and the "
"residual sum of squares.The default of @{stat} is FALSE."
msgstr ""

#: ../plugins/fn-stat/functions.c:3386 ../plugins/fn-stat/functions.c:3741
#: ../plugins/fn-stat/functions.c:3832
msgid ""
"If @{known_ys} and @{known_xs} have unequal number of data points, this "
"function returns a #NUM! error."
msgstr ""

#: ../plugins/fn-stat/functions.c:3480
msgid "LOGFIT:logarithmic least square fit (using a trial and error method)"
msgstr ""

#: ../plugins/fn-stat/functions.c:3484
msgid ""
"LOGFIT function applies the “least squares” method to fit the logarithmic "
"equation y = a + b * ln(sign * (x - c)) ,   sign = +1 or -1 to your data. "
"The graph of the equation is a logarithmic curve moved horizontally by c and "
"possibly mirrored across the y-axis (if sign = -1)."
msgstr ""

#: ../plugins/fn-stat/functions.c:3490
msgid ""
"LOGFIT returns an array having five columns and one row. `Sign' is given in "
"the first column, `a', `b', and `c' are given in columns 2 to 4. Column 5 "
"holds the sum of squared residuals."
msgstr ""

#: ../plugins/fn-stat/functions.c:3494
msgid ""
"An error is returned when there are less than 3 different x's or y's, or "
"when the shape of the point cloud is too different from a ``logarithmic'' "
"one."
msgstr ""

#: ../plugins/fn-stat/functions.c:3497
msgid ""
"You can use the above formula = a + b * ln(sign * (x - c)) or rearrange it "
"to = (exp((y - a) / b)) / sign + c to compute unknown y's or x's, "
"respectively. "
msgstr ""

#: ../plugins/fn-stat/functions.c:3502
msgid ""
"This is non-linear fitting by trial-and-error. The accuracy of `c' is: width "
"of x-range -> rounded to the next smaller (10^integer), times 0.000001. "
"There might be cases in which the returned fit is not the best possible."
msgstr ""

#: ../plugins/fn-stat/functions.c:3575
msgid ""
"TREND:estimates future values of a given data set using a least squares "
"approximation"
msgstr ""

#: ../plugins/fn-stat/functions.c:3578
msgid ""
"new_xs:array of x-values for which to estimate the y-values; defaults to @"
"{known_xs}"
msgstr ""

#: ../plugins/fn-stat/functions.c:3582
msgid ""
"Let us assume that the cells A1, A2, …, A5 contain numbers 11.4, 17.3, 21.3, "
"25.9, and 40.1, and the cells B1, B2, ... B5 23.2, 25.8, 29.9, 33.5, and "
"42.7."
msgstr ""

#: ../plugins/fn-stat/functions.c:3585
msgid "Then TREND(A1:A5,B1:B5) equals {12.1, 15.7, 21.6, 26.7, 39.7}."
msgstr ""

#: ../plugins/fn-stat/functions.c:3722
msgid "LOGEST:exponential least square fit"
msgstr ""

#: ../plugins/fn-stat/functions.c:3724
msgid "known_xs:known x-values; default to an array {1, 2, 3, …}"
msgstr ""

#: ../plugins/fn-stat/functions.c:3727
msgid ""
"LOGEST function applies the “least squares” method to fit an exponential "
"curve of the form\ty = b * m{1}^x{1} * m{2}^x{2}... to your data."
msgstr ""

#: ../plugins/fn-stat/functions.c:3731
msgid "LOGEST returns an array { m{n},m{n-1}, ...,m{1},b }."
msgstr ""

#: ../plugins/fn-stat/functions.c:3732
msgid ""
"Extra statistical information is written below the regression line "
"coefficients in the result array.  Extra statistical information consists of "
"four rows of data.  In the first row the standard error values for the "
"coefficients m1, (m2, ...), b are represented.  The second row contains the "
"square of R and the standard error for the y estimate.  The third row "
"contains the F-observed value and the degrees of freedom.  The last row "
"contains the regression sum of squares and the residual sum of squares."
msgstr ""

#: ../plugins/fn-stat/functions.c:3820
msgid "GROWTH:exponential growth prediction"
msgstr ""

#: ../plugins/fn-stat/functions.c:3823
msgid ""
"new_xs:x-values for which to estimate the y-values; defaults to @{known_xs}"
msgstr ""

#: ../plugins/fn-stat/functions.c:3825
msgid ""
"GROWTH function applies the “least squares” method to fit an exponential "
"curve to your data and predicts the exponential growth by using this curve."
msgstr ""

#: ../plugins/fn-stat/functions.c:3830
msgid ""
"GROWTH returns an array having one column and a row for each data point in @"
"{new_xs}."
msgstr ""

#: ../plugins/fn-stat/functions.c:3905
msgid ""
"FORECAST:estimates a future value according to existing values using simple "
"linear regression"
msgstr ""

#: ../plugins/fn-stat/functions.c:3907
msgid "x:x-value whose matching y-value should be forecast"
msgstr ""

#: ../plugins/fn-stat/functions.c:3910
msgid ""
"This function estimates a future value according to existing values using "
"simple linear regression."
msgstr ""

#: ../plugins/fn-stat/functions.c:3912 ../plugins/fn-stat/functions.c:3969
#: ../plugins/fn-stat/functions.c:4022
msgid ""
"If @{known_xs} or @{known_ys} contains no data entries or different number "
"of data entries, this function returns a #N/A error."
msgstr ""

#: ../plugins/fn-stat/functions.c:3914
msgid ""
"If the variance of the @{known_xs} is zero, this function returns a #DIV/0 "
"error."
msgstr ""

#: ../plugins/fn-stat/functions.c:3920
msgid "Then FORECAST(7,A1:A5,B1:B5) equals -10.859397661."
msgstr ""

#: ../plugins/fn-stat/functions.c:3966
msgid "INTERCEPT:the intercept of a linear regression line"
msgstr ""

#: ../plugins/fn-stat/functions.c:3971 ../plugins/fn-stat/functions.c:4024
msgid ""
"If the variance of the @{known_xs} is zero, this function returns #DIV/0 "
"error."
msgstr ""

#: ../plugins/fn-stat/functions.c:3977
msgid "Then INTERCEPT(A1:A5,B1:B5) equals -20.785117212."
msgstr ""

#: ../plugins/fn-stat/functions.c:4018
msgid "SLOPE:the slope of a linear regression line"
msgstr ""

#: ../plugins/fn-stat/functions.c:4029
msgid "Then SLOPE(A1:A5,B1:B5) equals 1.417959936."
msgstr ""

#: ../plugins/fn-stat/functions.c:4070
msgid "SUBTOTAL:the subtotal of the given list of arguments"
msgstr ""

#: ../plugins/fn-stat/functions.c:4071
msgid ""
"function_nbr:determines which function to use according to the following "
"table:\n"
"\t1   AVERAGE\n"
"\t2   COUNT\n"
"\t3   COUNTA\n"
"\t4   MAX\n"
"\t5   MIN\n"
"\t6   PRODUCT\n"
"\t7   STDEV\n"
"\t8   STDEVP\n"
"\t9   SUM\n"
"\t10   VAR\n"
"\t11   VARP"
msgstr ""

#: ../plugins/fn-stat/functions.c:4084
msgid "ref1:first value"
msgstr ""

#: ../plugins/fn-stat/functions.c:4085
msgid "ref2:second value"
msgstr ""

#: ../plugins/fn-stat/functions.c:4087
msgid ""
"Let us assume that the cells A1, A2, ..., A5 contain numbers 23, 27, 28, 33, "
"and 39."
msgstr ""

#: ../plugins/fn-stat/functions.c:4088
msgid ""
"Then SUBTOTAL(1,A1:A5) equals 30.SUBTOTAL(6,A1:A5) equals 22378356.SUBTOTAL"
"(7,A1:A5) equals 6.164414003.SUBTOTAL(9,A1:A5) equals 150.SUBTOTAL(11,A1:A5) "
"equals 30.4."
msgstr ""

#: ../plugins/fn-stat/functions.c:4167
msgid "CRONBACH:Cronbach's alpha"
msgstr ""

#: ../plugins/fn-stat/functions.c:4168
msgid "ref1:first data set"
msgstr ""

#: ../plugins/fn-stat/functions.c:4169
msgid "ref2:second data set"
msgstr ""

#: ../plugins/fn-stat/functions.c:4280
msgid ""
"GEOMDIST:probability mass or cumulative distribution function of the "
"geometric distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:4281
msgid "k:number of trials"
msgstr ""

#: ../plugins/fn-stat/functions.c:4282
msgid "p:probability of success in any trial"
msgstr ""

#: ../plugins/fn-stat/functions.c:4284
msgid "If @{k} < 0 this function returns a #NUM! error."
msgstr ""

#: ../plugins/fn-stat/functions.c:4311
msgid "LOGISTIC:probability density function of the logistic distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:4342
msgid "PARETO:probability density function of the Pareto distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:4344
msgid "a:exponent"
msgstr ""

#: ../plugins/fn-stat/functions.c:4345 ../plugins/fn-stat/functions.c:4453
msgid "b:scale parameter"
msgstr ""

#: ../plugins/fn-stat/functions.c:4376
msgid "RAYLEIGH:probability density function of the Rayleigh distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:4378 ../plugins/fn-stat/functions.c:4414
msgid "sigma:scale parameter"
msgstr ""

#: ../plugins/fn-stat/functions.c:4411
msgid ""
"RAYLEIGHTAIL:probability density function of the Rayleigh tail distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:4413
msgid "a:lower limit"
msgstr ""

#: ../plugins/fn-stat/functions.c:4449
msgid ""
"EXPPOWDIST:the probability density function of the Exponential Power "
"distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:4455
#, fuzzy
msgid ""
"This distribution has been recommended for lifetime analysis when a U-shaped "
"hazard function is desired. This corresponds to rapid failure once the "
"product starts to wear out after a period of steady or even improving "
"reliability."
msgstr ""
"@FUNCTION=EXPPOWDIST\n"
"@SYNTAX=EXPPOWDIST(x;a;b)\n"
"@DESCRIPTION=EXPPOWDIST returnerar sannolikhetstätheten p(x) vid @x för "
"exponentialfördelningen med skalparametern @a och exponenten @b.\n"
"\n"
"@EXAMPLES=\n"
"EXPPOWDIST(0,4;1;2).\n"
"\n"
"@SEEALSO=RANDEXPPOW"

#: ../plugins/fn-stat/functions.c:4483
msgid "LAPLACE:probability density function of the Laplace distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:4485
msgid "a:mean"
msgstr ""

#: ../plugins/fn-stat/functions.c:4506
msgid ""
"PERMUTATIONA:the number of permutations of @{y} objects chosen from @{x} "
"objects with repetition allowed"
msgstr ""

#: ../plugins/fn-stat/functions.c:4507
msgid "x:total number of objects"
msgstr ""

#: ../plugins/fn-stat/functions.c:4508
msgid "y:number of selected objects"
msgstr ""

#: ../plugins/fn-stat/functions.c:4509
msgid "If both @{x} and @{y} equal 0, PERMUTATIONA returns 1."
msgstr ""

#: ../plugins/fn-stat/functions.c:4510
msgid "If @{x} < 0 or @{y} < 0, PERMUTATIONA returns #NUM!"
msgstr ""

#: ../plugins/fn-stat/functions.c:4511
msgid "If @{x} or @{y} are not integers, they are truncated"
msgstr ""

#: ../plugins/fn-stat/functions.c:4539
msgid "LKSTEST:Lilliefors (Kolmogorov-Smirnov) Test of Normality"
msgstr ""

#: ../plugins/fn-stat/functions.c:4540 ../plugins/fn-stat/functions.c:4657
#: ../plugins/fn-stat/functions.c:4741 ../plugins/fn-stat/functions.c:4826
msgid "x:array of sample values"
msgstr ""

#: ../plugins/fn-stat/functions.c:4541
msgid ""
"This function returns an array with the first row giving the p-value of the "
"Lilliefors (Kolmogorov-Smirnov) Test, the second row the test statistic of "
"the test, and the third the number of observations in the sample."
msgstr ""

#: ../plugins/fn-stat/functions.c:4543
msgid "If there are less than 5 sample values, LKSTEST returns #VALUE!"
msgstr ""

#: ../plugins/fn-stat/functions.c:4545
msgid "wiki:en:Lilliefors_test"
msgstr ""

#: ../plugins/fn-stat/functions.c:4656
msgid "SFTEST:Shapiro-Francia Test of Normality"
msgstr ""

#: ../plugins/fn-stat/functions.c:4658
msgid ""
"This function returns an array with the first row giving the p-value of the "
"Shapiro-Francia Test, the second row the test statistic of the test, and the "
"third the number of observations in the sample."
msgstr ""

#: ../plugins/fn-stat/functions.c:4660
msgid ""
"If there are less than 5 or more than 5000 sample values, SFTEST returns "
"#VALUE!"
msgstr ""

#: ../plugins/fn-stat/functions.c:4740
msgid "CVMTEST:Cramér-von Mises Test of Normality"
msgstr ""

#: ../plugins/fn-stat/functions.c:4742
msgid ""
"This function returns an array with the first row giving the p-value of the "
"Cramér-von Mises Test, the second row the test statistic of the test, and "
"the third the number of observations in the sample."
msgstr ""

#: ../plugins/fn-stat/functions.c:4744
msgid "If there are less than 8 sample values, CVMTEST returns #VALUE!"
msgstr ""

#: ../plugins/fn-stat/functions.c:4746
msgid "wiki:en:Cramér–von-Mises_criterion"
msgstr ""

#: ../plugins/fn-stat/functions.c:4825
msgid "ADTEST:Anderson-Darling Test of Normality"
msgstr ""

#: ../plugins/fn-stat/functions.c:4827
msgid ""
"This function returns an array with the first row giving the p-value of the "
"Anderson-Darling Test, the second row the test statistic of the test, and "
"the third the number of observations in the sample."
msgstr ""

#: ../plugins/fn-stat/functions.c:4829
msgid "If there are less than 8 sample values, ADTEST returns #VALUE!"
msgstr ""

#: ../plugins/fn-stat/functions.c:4831
msgid "wiki:en:Anderson–Darling_test"
msgstr ""

#: ../plugins/fn-string/functions.c:56
msgid "CHAR:the CP1252 (Windows-1252) character for the code point @{x}"
msgstr ""

#: ../plugins/fn-string/functions.c:57
msgid "x:code point"
msgstr ""

#: ../plugins/fn-string/functions.c:58
msgid "CHAR(@{x}) returns the CP1252 (Windows-1252) character with code @{x}."
msgstr ""

#: ../plugins/fn-string/functions.c:59
msgid "@{x} must be in the range 1 to 255."
msgstr ""

#: ../plugins/fn-string/functions.c:60 ../plugins/fn-string/functions.c:136
msgid ""
"CP1252 (Windows-1252) is also known as the \"ANSI code page\", but it is not "
"an ANSI standard."
msgstr ""

#: ../plugins/fn-string/functions.c:62
msgid ""
"CP1252 (Windows-1252) is based on an early draft of ISO-8859-1, and contains "
"all of its printable characters. It also contains all of ISO-8859-15's "
"printable characters (but partially at different positions.)"
msgstr ""

#: ../plugins/fn-string/functions.c:66 ../plugins/fn-string/functions.c:138
msgid ""
"In CP1252 (Windows-1252), 129, 141, 143, 144, and 157 do not have matching "
"characters."
msgstr ""

#: ../plugins/fn-string/functions.c:67 ../plugins/fn-string/functions.c:139
msgid ""
"For @{x} from 1 to 255 except 129, 141, 143, 144, and 157 we have CODE(CHAR(@"
"{x}))=@{x}."
msgstr ""

#: ../plugins/fn-string/functions.c:105
msgid ""
"UNICHAR:the Unicode character represented by the Unicode code point @{x}"
msgstr ""

#: ../plugins/fn-string/functions.c:106
msgid "x:Unicode code point"
msgstr ""

#: ../plugins/fn-string/functions.c:133
msgid "CODE:the CP1252 (Windows-1252) code point for the character @{c}"
msgstr ""

#: ../plugins/fn-string/functions.c:134 ../plugins/fn-string/functions.c:179
msgid "c:character"
msgstr ""

#: ../plugins/fn-string/functions.c:135
msgid "@{c} must be a valid CP1252 (Windows-1252) character."
msgstr ""

#: ../plugins/fn-string/functions.c:137
msgid ""
"CP1252 (Windows-1252) is based on an early draft of ISO-8859-1, and contains "
"all of its printable characters (but partially at different positions.)"
msgstr ""

#: ../plugins/fn-string/functions.c:178
msgid "UNICODE:the Unicode code point for the character @{c}"
msgstr ""

#: ../plugins/fn-string/functions.c:199
msgid "EXACT:TRUE if @{string1} is exactly equal to @{string2}"
msgstr ""

#: ../plugins/fn-string/functions.c:200
msgid "string1:first string"
msgstr ""

#: ../plugins/fn-string/functions.c:201
msgid "string2:second string"
msgstr ""

#: ../plugins/fn-string/functions.c:219
msgid "LEN:the number of characters of the string @{s}"
msgstr ""

#: ../plugins/fn-string/functions.c:220 ../plugins/fn-string/functions.c:237
#: ../plugins/fn-string/functions.c:255 ../plugins/fn-string/functions.c:287
#: ../plugins/fn-string/functions.c:339 ../plugins/fn-string/functions.c:379
#: ../plugins/fn-string/functions.c:466 ../plugins/fn-string/functions.c:502
msgid "s:the string"
msgstr ""

#: ../plugins/fn-string/functions.c:236
msgid "LENB:the number of bytes in the string @{s}"
msgstr ""

#: ../plugins/fn-string/functions.c:254
msgid "LEFT:the first @{num_chars} characters of the string @{s}"
msgstr ""

#: ../plugins/fn-string/functions.c:256 ../plugins/fn-string/functions.c:467
msgid "num_chars:the number of characters to return (defaults to 1)"
msgstr ""

#: ../plugins/fn-string/functions.c:257
msgid ""
"If the string @{s} is in a right-to-left script, the returned first "
"characters are from the right of the string."
msgstr ""

#: ../plugins/fn-string/functions.c:286
msgid ""
"LEFTB:the first characters  of the string @{s} comprising at most @"
"{num_bytes} bytes"
msgstr ""

#: ../plugins/fn-string/functions.c:288 ../plugins/fn-string/functions.c:381
#: ../plugins/fn-string/functions.c:503
msgid "num_bytes:the maximum number of bytes to return (defaults to 1)"
msgstr ""

#: ../plugins/fn-string/functions.c:289 ../plugins/fn-string/functions.c:382
#: ../plugins/fn-string/functions.c:504 ../plugins/fn-string/functions.c:849
#: ../plugins/fn-string/functions.c:1340
msgid ""
"The semantics of this function is subject to change as various applications "
"implement it."
msgstr ""

#: ../plugins/fn-string/functions.c:290
msgid ""
"If the string is in a right-to-left script, the returned first characters "
"are from the right of the string."
msgstr ""

#: ../plugins/fn-string/functions.c:291 ../plugins/fn-string/functions.c:383
#: ../plugins/fn-string/functions.c:427 ../plugins/fn-string/functions.c:506
#: ../plugins/fn-string/functions.c:850 ../plugins/fn-string/functions.c:1341
msgid ""
"While this function is syntactically Excel compatible, the differences in "
"the underlying text encoding will usually yield different results."
msgstr ""

#: ../plugins/fn-string/functions.c:292 ../plugins/fn-string/functions.c:385
#: ../plugins/fn-string/functions.c:429 ../plugins/fn-string/functions.c:507
#: ../plugins/fn-string/functions.c:852 ../plugins/fn-string/functions.c:1343
msgid ""
"While this function is OpenFormula compatible, most of its behavior is, at "
"this time, implementation specific."
msgstr ""

#: ../plugins/fn-string/functions.c:320
msgid "LOWER:a lower-case version of the string @{text}"
msgstr ""

#: ../plugins/fn-string/functions.c:338
msgid ""
"MID:the substring of the string @{s} starting at position @{position} "
"consisting of @{length} characters"
msgstr ""

#: ../plugins/fn-string/functions.c:340
msgid "position:the starting position"
msgstr ""

#: ../plugins/fn-string/functions.c:341
msgid "length:the number of characters to return"
msgstr ""

#: ../plugins/fn-string/functions.c:378
msgid ""
"MIDB:the characters following the first @{start_pos} bytes comprising at "
"most @{num_bytes} bytes"
msgstr ""

#: ../plugins/fn-string/functions.c:380
msgid "start_pos:the number of the byte with which to start (defaults to 1)"
msgstr ""

#: ../plugins/fn-string/functions.c:422
msgid ""
"FINDB:first byte position of @{string1} in @{string2} following byte "
"position @{start}"
msgstr ""

#: ../plugins/fn-string/functions.c:423 ../plugins/fn-string/functions.c:651
msgid "string1:search string"
msgstr ""

#: ../plugins/fn-string/functions.c:424 ../plugins/fn-string/functions.c:652
msgid "string2:search field"
msgstr ""

#: ../plugins/fn-string/functions.c:425 ../plugins/fn-string/functions.c:1330
msgid "start:starting byte position, defaults to 1"
msgstr ""

#: ../plugins/fn-string/functions.c:426 ../plugins/fn-string/functions.c:654
msgid "This search is case-sensitive."
msgstr ""

#: ../plugins/fn-string/functions.c:465
msgid "RIGHT:the last @{num_chars} characters of the string @{s}"
msgstr ""

#: ../plugins/fn-string/functions.c:468 ../plugins/fn-string/functions.c:505
msgid ""
"If the string @{s} is in a right-to-left script, the returned last "
"characters are from the left of the string."
msgstr ""

#: ../plugins/fn-string/functions.c:501
msgid ""
"RIGHTB:the last characters of the string @{s} comprising at most @"
"{num_bytes} bytes"
msgstr ""

#: ../plugins/fn-string/functions.c:536
msgid "UPPER:an upper-case version of the string @{text}"
msgstr ""

#: ../plugins/fn-string/functions.c:555
msgid "CONCATENATE:the concatenation of the strings @{s1}, @{s2},…"
msgstr ""

#: ../plugins/fn-string/functions.c:556
msgid "s1:first string"
msgstr ""

#: ../plugins/fn-string/functions.c:557
msgid "s2:second string"
msgstr ""

#: ../plugins/fn-string/functions.c:577
msgid "REPT:@{num} repetitions of string @{text}"
msgstr ""

#: ../plugins/fn-string/functions.c:579
msgid "num:non-negative integer"
msgstr ""

#: ../plugins/fn-string/functions.c:621
msgid "CLEAN:@{text} with any non-printable characters removed"
msgstr ""

#: ../plugins/fn-string/functions.c:623
msgid ""
"CLEAN removes non-printable characters from its argument leaving only "
"regular characters and white-space."
msgstr ""

#: ../plugins/fn-string/functions.c:650
msgid ""
"FIND:first position of @{string1} in @{string2} following position @{start}"
msgstr ""

#: ../plugins/fn-string/functions.c:653 ../plugins/fn-string/functions.c:1261
msgid "start:starting position, defaults to 1"
msgstr ""

#: ../plugins/fn-string/functions.c:688
msgid "FIXED:formatted string representation of @{num}"
msgstr ""

#: ../plugins/fn-string/functions.c:689 ../plugins/fn-string/functions.c:1186
msgid "num:number"
msgstr ""

#: ../plugins/fn-string/functions.c:690
msgid "decimals:number of decimals"
msgstr ""

#: ../plugins/fn-string/functions.c:691
msgid ""
"no_commas:TRUE if no thousand separators should be used, defaults to FALSE"
msgstr ""

#: ../plugins/fn-string/functions.c:748
msgid "PROPER:@{text} with initial of each word capitalised"
msgstr ""

#: ../plugins/fn-string/functions.c:790
msgid ""
"REPLACE:string @{old} with @{num} characters starting at @{start} replaced "
"by @{new}"
msgstr ""

#: ../plugins/fn-string/functions.c:792 ../plugins/fn-string/functions.c:843
msgid "old:original text"
msgstr ""

#: ../plugins/fn-string/functions.c:793
msgid "start:starting position"
msgstr ""

#: ../plugins/fn-string/functions.c:794
msgid "num:number of characters to be replaced"
msgstr ""

#: ../plugins/fn-string/functions.c:795 ../plugins/fn-string/functions.c:846
#: ../plugins/fn-string/functions.c:1114
msgid "new:replacement string"
msgstr ""

#: ../plugins/fn-string/functions.c:841
msgid ""
"REPLACEB:string @{old} with up to @{num} bytes starting at @{start} replaced "
"by @{new}"
msgstr ""

#: ../plugins/fn-string/functions.c:844
msgid "start:starting byte position"
msgstr ""

#: ../plugins/fn-string/functions.c:845
msgid "num:number of bytes to be replaced"
msgstr ""

#: ../plugins/fn-string/functions.c:847
msgid ""
"REPLACEB replaces the string of valid unicode characters starting at the "
"byte @{start} and ending at @{start}+@{num}-1 with the string @{new}."
msgstr ""

#: ../plugins/fn-string/functions.c:895
msgid "T:@{value} if and only if @{value} is text, otherwise empty"
msgstr ""

#: ../plugins/fn-string/functions.c:896
msgid "value:original value"
msgstr ""

#: ../plugins/fn-string/functions.c:918
msgid "TEXT:@{value} as a string formatted as @{format}"
msgstr ""

#: ../plugins/fn-string/functions.c:919
msgid "value:value to be formatted"
msgstr ""

#: ../plugins/fn-string/functions.c:920
msgid "format:desired format"
msgstr ""

#: ../plugins/fn-string/functions.c:972
msgid "TRIM:@{text} with only single spaces between words"
msgstr ""

#: ../plugins/fn-string/functions.c:1019
msgid "VALUE:numeric value of @{text}"
msgstr ""

#: ../plugins/fn-string/functions.c:1052
msgid "NUMBERVALUE:numeric value of @{text}"
msgstr ""

#: ../plugins/fn-string/functions.c:1054
msgid "separator:decimal separator"
msgstr ""

#: ../plugins/fn-string/functions.c:1055
msgid ""
"If @{text} does not look like a decimal number, NUMBERVALUE returns the "
"value VALUE would return (ignoring the given @{separator})."
msgstr ""

#: ../plugins/fn-string/functions.c:1111
msgid "SUBSTITUTE:@{text} with all occurrences of @{old} replaced by @{new}"
msgstr ""

#: ../plugins/fn-string/functions.c:1112 ../plugins/fn-string/functions.c:1522
msgid "text:original text"
msgstr ""

#: ../plugins/fn-string/functions.c:1113
msgid "old:string to be replaced"
msgstr ""

#: ../plugins/fn-string/functions.c:1115
msgid ""
"num:if @{num} is specified and a number only the @{num}th occurrence of @"
"{old} is replaced"
msgstr ""

#: ../plugins/fn-string/functions.c:1185
msgid "DOLLAR:@{num} formatted as currency"
msgstr ""

#: ../plugins/fn-string/functions.c:1187
msgid "decimals:decimals"
msgstr ""

#: ../plugins/fn-string/functions.c:1257
msgid ""
"SEARCH:the location of the @{search} string within @{text} after position @"
"{start}"
msgstr ""

#: ../plugins/fn-string/functions.c:1259 ../plugins/fn-string/functions.c:1328
msgid "search:search string"
msgstr ""

#: ../plugins/fn-string/functions.c:1260 ../plugins/fn-string/functions.c:1329
msgid "text:search field"
msgstr ""

#: ../plugins/fn-string/functions.c:1262 ../plugins/fn-string/functions.c:1331
msgid ""
"@{search} may contain wildcard characters (*) and question marks (?). A "
"question mark matches any single character, and a wildcard matches any "
"string including the empty string. To search for * or ?, precede the symbol "
"with ~."
msgstr ""

#: ../plugins/fn-string/functions.c:1267 ../plugins/fn-string/functions.c:1336
msgid "This search is not case sensitive."
msgstr ""

#: ../plugins/fn-string/functions.c:1268
msgid "If @{search} is not found, SEARCH returns #VALUE!"
msgstr ""

#: ../plugins/fn-string/functions.c:1269
msgid ""
"If @{start} is less than one or it is greater than the length of @{text}, "
"SEARCH returns #VALUE!"
msgstr ""

#: ../plugins/fn-string/functions.c:1326
msgid ""
"SEARCHB:the location of the @{search} string within @{text} after byte "
"position @{start}"
msgstr ""

#: ../plugins/fn-string/functions.c:1337
msgid "If @{search} is not found, SEARCHB returns #VALUE!"
msgstr ""

#: ../plugins/fn-string/functions.c:1338
msgid ""
"If @{start} is less than one or it is greater than the byte length of @"
"{text}, SEARCHB returns #VALUE!"
msgstr ""

#: ../plugins/fn-string/functions.c:1394
msgid ""
"ASC:text with full-width katakana and ASCII characters converted to half-"
"width"
msgstr ""

#: ../plugins/fn-string/functions.c:1396
msgid ""
"ASC converts full-width katakana and ASCII characters to half-width "
"equivalent characters, copying all others. "
msgstr ""

#: ../plugins/fn-string/functions.c:1397 ../plugins/fn-string/functions.c:1525
msgid ""
"The distinction between half-width and full-width characters is described in "
"http://www.unicode.org/reports/tr11/."
msgstr ""

#: ../plugins/fn-string/functions.c:1398 ../plugins/fn-string/functions.c:1527
msgid "For most strings, this function has the same effect as in Excel."
msgstr ""

#: ../plugins/fn-string/functions.c:1399
msgid ""
"While in obsolete encodings ASC used to translate between 2-byte and 1-byte "
"characters, this is not the case in UTF-8."
msgstr ""

#: ../plugins/fn-string/functions.c:1521
msgid ""
"JIS:text with half-width katakana and ASCII characters converted to full-"
"width"
msgstr ""

#: ../plugins/fn-string/functions.c:1523
msgid ""
"JIS converts half-width katakana and ASCII characters to full-width "
"equivalent characters, copying all others. "
msgstr ""

#: ../plugins/fn-string/functions.c:1528
msgid ""
"While in obsolete encodings JIS used to translate between 1-byte and 2-byte "
"characters, this is not the case in UTF-8."
msgstr ""

#: ../plugins/fn-tsa/functions.c:94
msgid ""
"Possible interpolation methods are:\n"
"0: linear;\n"
"1: linear with averaging;\n"
"2: staircase;\n"
"3: staircase with averaging;\n"
"4: natural cubic spline;\n"
"5: natural cubic spline with averaging."
msgstr ""

#: ../plugins/fn-tsa/functions.c:371
msgid ""
"INTERPOLATION:interpolated values corresponding to the given abscissa targets"
msgstr ""

#: ../plugins/fn-tsa/functions.c:372
msgid "abscissae:ordered abscissae of the given data points"
msgstr ""

#: ../plugins/fn-tsa/functions.c:373
msgid "ordinates:ordinates of the given data points"
msgstr ""

#: ../plugins/fn-tsa/functions.c:374
msgid "targets:abscissae of the interpolated data"
msgstr ""

#: ../plugins/fn-tsa/functions.c:375
msgid "interpolation:method of interpolation, defaults to 0 ('linear')"
msgstr ""

#: ../plugins/fn-tsa/functions.c:376 ../plugins/fn-tsa/functions.c:545
msgid "The output consists always of one column of numbers."
msgstr ""

#: ../plugins/fn-tsa/functions.c:378
msgid "The @{abscissae} must be given in increasing order."
msgstr ""

#: ../plugins/fn-tsa/functions.c:379
msgid ""
"If any of interpolation methods 1 ('linear with averaging'), 3 ('staircase "
"with averaging'), and 5 ('natural cubic spline with averaging') is used, the "
"number of returned values is one less than the number of targets and the "
"targets values must be given in increasing order."
msgstr ""

#: ../plugins/fn-tsa/functions.c:384 ../plugins/fn-tsa/functions.c:552
msgid "Strings and empty cells in @{abscissae} and @{ordinates} are ignored."
msgstr ""

#: ../plugins/fn-tsa/functions.c:385 ../plugins/fn-tsa/functions.c:553
msgid ""
"If several target data are provided they must be in the same column in "
"consecutive cells."
msgstr ""

#: ../plugins/fn-tsa/functions.c:538
msgid "PERIODOGRAM:periodogram of the given data"
msgstr ""

#: ../plugins/fn-tsa/functions.c:539
msgid "ordinates:ordinates of the given data"
msgstr ""

#: ../plugins/fn-tsa/functions.c:540
msgid "filter:windowing function to  be used, defaults to no filter"
msgstr ""

#: ../plugins/fn-tsa/functions.c:541
msgid ""
"abscissae:abscissae of the given data, defaults to regularly spaced abscissae"
msgstr ""

#: ../plugins/fn-tsa/functions.c:542
msgid "interpolation:method of interpolation, defaults to none"
msgstr ""

#: ../plugins/fn-tsa/functions.c:543
msgid "number:number of interpolated data points"
msgstr ""

#: ../plugins/fn-tsa/functions.c:544
msgid ""
"If an interpolation method is used, the number of returned values is one "
"less than the number of targets and the targets values must be given in "
"increasing order."
msgstr ""

#: ../plugins/fn-tsa/functions.c:547
msgid ""
"Possible window functions are:\n"
"0: no filter (rectangular window)\n"
"1: Bartlett (triangular window)\n"
"2: Hahn (cosine window)\n"
"3: Welch (parabolic window)"
msgstr ""

#: ../plugins/fn-tsa/functions.c:797
msgid "FOURIER:Fourier or inverse Fourier transform"
msgstr ""

#: ../plugins/fn-tsa/functions.c:798
msgid "Sequence:the data sequence to be transformed"
msgstr ""

#: ../plugins/fn-tsa/functions.c:799
msgid ""
"Inverse:if true, the inverse Fourier transform is calculated, defaults to "
"false"
msgstr ""

#: ../plugins/fn-tsa/functions.c:800
msgid ""
"Separate:if true, the real and imaginary parts are given separately, "
"defaults to false"
msgstr ""

#: ../plugins/fn-tsa/functions.c:801
msgid ""
"This array function returns the Fourier or inverse Fourier transform of the "
"given data sequence."
msgstr ""

#: ../plugins/fn-tsa/functions.c:802
msgid ""
"The output consists of one column of complex numbers if @{Separate} is false "
"and of two columns of real numbers if @{Separate} is true."
msgstr ""

#: ../plugins/fn-tsa/functions.c:803
msgid ""
"If @{Separate} is true the first output column contains the real parts and "
"the second column the imaginary parts."
msgstr ""

#: ../plugins/fn-tsa/functions.c:804
msgid ""
"If @{Sequence} is neither an n by 1 nor 1 by n array, this function returns "
"#NUM!"
msgstr ""

#: ../plugins/gda/plugin-gda.c:305
msgid "EXECSQL:result of executing @{sql} in the libgda data source @{dsn}"
msgstr ""

#: ../plugins/gda/plugin-gda.c:307 ../plugins/gda/plugin-gda.c:384
msgid "dsn:libgda data source"
msgstr ""

#: ../plugins/gda/plugin-gda.c:308 ../plugins/gda/plugin-gda.c:385
msgid "username:user name to access @{dsn}"
msgstr ""

#: ../plugins/gda/plugin-gda.c:309 ../plugins/gda/plugin-gda.c:386
msgid "password:password to access @{dsn} as @{username}"
msgstr ""

#: ../plugins/gda/plugin-gda.c:310
msgid "sql:SQL command"
msgstr ""

#: ../plugins/gda/plugin-gda.c:311 ../plugins/gda/plugin-gda.c:388
msgid "Before using EXECSQL, you need to set up a libgda data source."
msgstr ""

#: ../plugins/gda/plugin-gda.c:383
msgid "READDBTABLE:all rows of the table @{table} in @{dsn}"
msgstr ""

#: ../plugins/gda/plugin-gda.c:387
msgid "table:SQL table to retrieve"
msgstr ""

#: ../plugins/sample_datasource/sample_datasource.c:278
msgid "ATL_LAST:sample real-time data source"
msgstr ""

#: ../plugins/sample_datasource/sample_datasource.c:279
msgid "tag:tag to watch"
msgstr ""

#: ../plugins/sample_datasource/sample_datasource.c:280
#, fuzzy
msgid ""
"ATL_LAST is a sample implementation of a real time data source.  It takes a "
"string tag and monitors the named pipe ~/atl for changes to the value of "
"that tag."
msgstr ""
"@FUNCTION=atl_last\n"
"@SYNTAX=ATL_LAST (tagg)\n"
"@DESCRIPTION=ATL_LAST är en exempelimplementation av en realtidsdatakälla. "
"Den tar en strängtagg och bevakar det namngivna röret /tmp/atl för "
"förändringar till värdet av taggen.\n"
"\n"
"* Detta är inte avsett att vara allmänt tillgängligt och är normalt AV.\n"
"\n"
"@EXAMPLES=\n"
"ATL_LAST(\"IBM\")\n"
"@SEEALSO="

#: ../plugins/sample_datasource/sample_datasource.c:281
msgid "This is not intended to be generally enabled and is OFF by default."
msgstr ""

#~ msgid ""
#~ "@FUNCTION=PRICE\n"
#~ "@SYNTAX=PRICE(settle,mat,rate,yield,redemption_price,[frequency,basis])\n"
#~ "@DESCRIPTION=PRICE returns price per $100 face value of a security. This "
#~ "method can only be used if the security pays periodic interest.\n"
#~ "\n"
#~ "@frequency is the number of coupon payments per year. Allowed frequencies "
#~ "are: 1 = annual, 2 = semi, 4 = quarterly. @basis is the type of day "
#~ "counting system you want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @frequency is other than 1, 2, or 4, PRICE returns #NUM! error.\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis is not in between 0 and 4, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=PRICE\n"
#~ "@SYNTAX=PRICE(avräkning;mognad;avkastning;reduceringspris[;frekvens;"
#~ "bas])\n"
#~ "@DESCRIPTION=PRICE returnerar priset per $100 värde av en säkerhet. Denna "
#~ "metod kan endast användas om säkerheten betalar periodisk ränta.\n"
#~ "\n"
#~ "@frekvens är antalet betalningar per år. Tillåtna frekvenser är: 1 = "
#~ "årligen, 2 = halvårsvis, 4 = kvartalsvis. @bas är den typ av "
#~ "dagsräkningssystem som du vill använda:\n"
#~ "\n"
#~ "0  Amerikanskt 30/360\n"
#~ "1  verkliga dagar/verkliga dagar\n"
#~ "2  verkliga dagar/360\n"
#~ "3  verkliga dagar/365\n"
#~ "4  Europeiskt 30/360\n"
#~ "\n"
#~ "* Om @frekvens är en annan än 1, 2 eller 4 returnerar PRICE felvärdet "
#~ "#NUM!.\n"
#~ "* Om @bas utelämnas används amerikanskt 30/360-system.\n"
#~ "* Om @bas inte är mellan 0 och 4 returnerar PRICE felvärdet #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=YIELD\n"
#~ "@SYNTAX=YIELD(settlement,maturity,rate,price,redemption_price,frequency[,"
#~ "basis])\n"
#~ "@DESCRIPTION=YIELD returns the yield on a security that pays periodic "
#~ "interest.\n"
#~ "\n"
#~ "@frequency is the number of coupon payments per year. Allowed frequencies "
#~ "are: 1 = annual, 2 = semi, 4 = quarterly. @basis is the type of day "
#~ "counting system you want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @frequency is other than 1, 2, or 4, YIELD returns #NUM! error.\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis is not in between 0 and 4, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=YIELD\n"
#~ "@SYNTAX=YIELD(avräkning;mognad;räntesats;pris;reduceringspris;frekvens[;"
#~ "bas])\n"
#~ "@DESCRIPTION=Använd YIELD för att beräkna avkastningen på en säkerhet som "
#~ "betalar periodisk ränta.\n"
#~ "\n"
#~ "@frekvens är antalet betalningar per år. Tillåtna frekvenser är: 1 = "
#~ "årligen, 2 = halvårsvis, 4 = kvartalsvis. @bas är den typ av "
#~ "dagsräkningssystem som du vill använda:\n"
#~ "\n"
#~ "0  Amerikanskt 30/360\n"
#~ "1  verkliga dagar/verkliga dagar\n"
#~ "2  verkliga dagar/360\n"
#~ "3  verkliga dagar/365\n"
#~ "4  Europeiskt 30/360\n"
#~ "\n"
#~ "* Om @frekvens är en annan än 1, 2 eller 4 returnerar YIELD felvärdet "
#~ "#NUM!.\n"
#~ "* Om @bas utelämnas används amerikanskt 30/360-system.\n"
#~ "* Om @bas inte är mellan 0 och 4 returnerar YIELD felvärdet #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=YIELDDISC\n"
#~ "@SYNTAX=YIELDDISC(settlement,maturity,pr,redemption[,basis])\n"
#~ "@DESCRIPTION=YIELDDISC calculates the annual yield of a security that is "
#~ "discounted.\n"
#~ "\n"
#~ "@settlement is the settlement date of the security.  @maturity is the "
#~ "maturity date of the security. @pr is the price per $100 face value of "
#~ "the security. @redemption is the redemption value per $100 face value. "
#~ "@basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @frequency is other than 1, 2, or 4, YIELDDISC returns #NUM! error.\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis is not in between 0 and 4, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=YIELDDISC\n"
#~ "@SYNTAX=YIELDDISC(avräkning;mognad;pr;pris;reducering[;bas])\n"
#~ "@DESCRIPTION=YIELDDISC beräknar den årliga avkastningen av en säkerhet "
#~ "som är reducerad.\n"
#~ "\n"
#~ "@avräkning är avräkningsdatumet för säkerheten. @mognad är mognadsdatumet "
#~ "för säkerheten. @pr är priset per $100 värde av säkerheten. @reducering "
#~ "är reduceringsvärdet per $100 värde. @bas är den typ av "
#~ "dagsräkningssystem som du vill använda:\n"
#~ "\n"
#~ "0  Amerikanskt 30/360\n"
#~ "1  verkliga dagar/verkliga dagar\n"
#~ "2  verkliga dagar/360\n"
#~ "3  verkliga dagar/365\n"
#~ "4  Europeiskt 30/360\n"
#~ "\n"
#~ "* Om @frekvens är en annan än 1, 2 eller 4 returnerar YIELDDISC felvärdet "
#~ "#NUM!.\n"
#~ "* Om @bas utelämnas används amerikanskt 30/360-system.\n"
#~ "* Om @bas inte är mellan 0 och 4 returnerar YIELDDISC felvärdet #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=YIELDMAT\n"
#~ "@SYNTAX=YIELDMAT(settlement,maturity,issue,rate,pr[,basis])\n"
#~ "@DESCRIPTION=YIELDMAT calculates the annual yield of a security for which "
#~ "the interest is paid at maturity date.\n"
#~ "\n"
#~ "@settlement is the settlement date of the security. @maturity is the "
#~ "maturity date of the security. @issue is the issue date of the security. "
#~ "@rate is the interest rate set to the security. @pr is the price per $100 "
#~ "face value of the security. @basis is the type of day counting system you "
#~ "want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis is not in between 0 and 4, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=YIELDMAT\n"
#~ "@SYNTAX=YIELDMAT(avräkning;mognad;start;räntesats;pr[;bas])\n"
#~ "@DESCRIPTION=YIELDMAT beräknar den årliga avkastningen av en säkerhet för "
#~ "vilken ränta betalas på mognadsdatum.\n"
#~ "\n"
#~ "@avräkning är avräkningsdatumet för säkerheten. @mognad är mognadsdatumet "
#~ "för säkerheten. @start är startdatumet för säkerheten. @räntesats är "
#~ "räntesatsen som är angiven för säkerheten. @pr är priset per $100 värde "
#~ "av säkerheten. @bas är den typ av dagsräkningssystem som du vill "
#~ "använda:\n"
#~ "\n"
#~ "0  Amerikanskt 30/360\n"
#~ "1  verkliga dagar/verkliga dagar\n"
#~ "2  verkliga dagar/360\n"
#~ "3  verkliga dagar/365\n"
#~ "4  Europeiskt 30/360\n"
#~ "\n"
#~ "* Om @bas utelämnas används amerikanskt 30/360-system.\n"
#~ "* Om @bas inte är mellan 0 och 4 returnerar YIELDMAT felvärdet #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=ODDFPRICE\n"
#~ "@SYNTAX=ODDFPRICE(settlement,maturity,issue,first_coupon,rate,yld,"
#~ "redemption,frequency[,basis])\n"
#~ "@DESCRIPTION=ODDFPRICE returns the price per $100 face value of a "
#~ "security. The security should have an odd short or long first period.\n"
#~ "\n"
#~ "@settlement is the settlement date of the security. @maturity is the "
#~ "maturity date of the security. @issue is the issue date of the security. "
#~ "@frequency is the number of coupon payments per year. Allowed frequencies "
#~ "are: 1 = annual, 2 = semi, 4 = quarterly. @basis is the type of day "
#~ "counting system you want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @frequency is other than 1, 2, or 4, ODDFPRICE returns #NUM! error.\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis is not in between 0 and 4, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=ODDFPRICE\n"
#~ "@SYNTAX=ODDFPRICE(avräkning;mognad;start;första_bet;räntesats;avkastning;"
#~ "reducering;frekvens[;bas])\n"
#~ "@DESCRIPTION=ODDFPRICE returnerar priset per $100 värde av en säkerhet. "
#~ "Säkerheten måste ha en udda kort eller lång första period.\n"
#~ "\n"
#~ "@avräkning är avräkningsdatumet för säkerheten. @mognad är mognadsdatumet "
#~ "för säkerheten. @start är startdatumet för säkerheten. @frekvens är "
#~ "antalet betalningar per år. Tillåtna frekvenser är 1 = årligen, 2 = "
#~ "halvårsvis, 4 = kvartalsvis. @bas är den typ av dagsräkningssystem som du "
#~ "vill använda:\n"
#~ "\n"
#~ "0  Amerikanskt 30/360\n"
#~ "1  verkliga dagar/verkliga dagar\n"
#~ "2  verkliga dagar/360\n"
#~ "3  verkliga dagar/365\n"
#~ "4  Europeiskt 30/360\n"
#~ "\n"
#~ "* Om @frekvens är en annan än 1, 2 eller 4 returnerar ODDFPRICE felvärdet "
#~ "#NUM!.\n"
#~ "* Om @bas utelämnas används amerikanskt 30/360-system.\n"
#~ "* Om @bas inte är mellan 0 och 4 returnerar ODDFPRICE felvärdet #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=ODDFYIELD\n"
#~ "@SYNTAX=ODDFYIELD(settlement,maturity,issue,first_coupon,rate,pr,"
#~ "redemption,frequency[,basis])\n"
#~ "@DESCRIPTION=ODDFYIELD calculates the yield of a security having an odd "
#~ "first period.\n"
#~ "\n"
#~ "@settlement is the settlement date of the security. @maturity is the "
#~ "maturity date of the security. @frequency is the number of coupon "
#~ "payments per year. Allowed frequencies are: 1 = annual, 2 = semi, 4 = "
#~ "quarterly. @basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @frequency is other than 1, 2, or 4, ODDFYIELD returns #NUM! error.\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis is not in between 0 and 4, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=ODDFYIELD\n"
#~ "@SYNTAX=ODDFYIELD(avräkning;mognad;start;första_bet;räntesats;pr;"
#~ "reducering;frekvens[;bas])\n"
#~ "@DESCRIPTION=ODDFYIELD beräknar avkastningen på en säkerhet som har en "
#~ "udda första period.\n"
#~ "\n"
#~ "@avräkning är avräkningsdatumet för säkerheten. @mognad är mognadsdatumet "
#~ "för säkerheten. @frekvens är antalet betalningar per år. Tillåtna "
#~ "frekvenser är 1 = årligen, 2 = halvårsvis, 4 = kvartalsvis. @bas är den "
#~ "typ av dagsräkningssystem som du vill använda:\n"
#~ "\n"
#~ "0  Amerikanskt 30/360\n"
#~ "1  verkliga dagar/verkliga dagar\n"
#~ "2  verkliga dagar/360\n"
#~ "3  verkliga dagar/365\n"
#~ "4  Europeiskt 30/360\n"
#~ "\n"
#~ "* Om @frekvens är en annan än 1, 2 eller 4 returnerar ODDFYIELD felvärdet "
#~ "#NUM!.\n"
#~ "* Om @bas utelämnas används amerikanskt 30/360-system.\n"
#~ "* Om @bas inte är mellan 0 och 4 returnerar ODDFYIELD felvärdet #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=ODDLPRICE\n"
#~ "@SYNTAX=ODDLPRICE(settlement,maturity,last_interest,rate,yld,redemption,"
#~ "frequency[,basis])\n"
#~ "@DESCRIPTION=ODDLPRICE calculates the price per $100 face value of a "
#~ "security that has an odd last coupon period.\n"
#~ "\n"
#~ "@settlement is the settlement date of the security. @maturity is the "
#~ "maturity date of the security. @frequency is the number of coupon "
#~ "payments per year. Allowed frequencies are: 1 = annual, 2 = semi, 4 = "
#~ "quarterly. @basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @frequency is other than 1, 2, or 4, ODDLPRICE returns #NUM! error.\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis is not in between 0 and 4, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=ODDLPRICE\n"
#~ "@SYNTAX=ODDLPRICE(avräkning;mognad;senaste_ränta;räntesats;avkastning;"
#~ "reducering;frekvens[;bas])\n"
#~ "@DESCRIPTION=ODDLPRICE beräknar priset per $100 värde av en säkerhet som "
#~ "har en udda sista betalningsperiod.\n"
#~ "\n"
#~ "@avräkning är avräkningsdatumet för säkerheten. @mognad är mognadsdatumet "
#~ "för säkerheten. @frekvens är antalet betalningar per år. Tillåtna "
#~ "frekvenser är 1 = årligen, 2 = halvårsvis, 4 = kvartalsvis. @bas är den "
#~ "typ av dagsräkningssystem som du vill använda:\n"
#~ "\n"
#~ "0  Amerikanskt 30/360\n"
#~ "1  verkliga dagar/verkliga dagar\n"
#~ "2  verkliga dagar/360\n"
#~ "3  verkliga dagar/365\n"
#~ "4  Europeiskt 30/360\n"
#~ "\n"
#~ "* Om @frekvens är en annan än 1, 2 eller 4 returnerar ODDLPRICE felvärdet "
#~ "#NUM!.\n"
#~ "* Om @bas utelämnas används amerikanskt 30/360-system.\n"
#~ "* Om @bas inte är mellan 0 och 4 returnerar ODDLPRICE felvärdet #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=ODDLYIELD\n"
#~ "@SYNTAX=ODDLYIELD(settlement,maturity,last_interest,rate,pr,redemption,"
#~ "frequency[,basis])\n"
#~ "@DESCRIPTION=ODDLYIELD calculates the yield of a security having an odd "
#~ "last period.\n"
#~ "\n"
#~ "@settlement is the settlement date of the security. @maturity is the "
#~ "maturity date of the security. @frequency is the number of coupon "
#~ "payments per year. Allowed frequencies are: 1 = annual, 2 = semi, 4 = "
#~ "quarterly. @basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @frequency is other than 1, 2, or 4, ODDLYIELD returns #NUM! error.\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis is not in between 0 and 4, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=ODDLYIELD\n"
#~ "@SYNTAX=ODDLYIELD(avräkning;mognad;senaste_ränta;räntesats;pr;reducering;"
#~ "frekvens[;bas])\n"
#~ "@DESCRIPTION=ODDLYIELD beräknar avkastningen på en säkerhet som har en "
#~ "udda sista period.\n"
#~ "\n"
#~ "@avräkning är avräkningsdatumet för säkerheten. @mognad är mognadsdatumet "
#~ "för säkerheten. @frekvens är antalet betalningar per år. Tillåtna "
#~ "frekvenser är 1 = årligen, 2 = halvårsvis, 4 = kvartalsvis. @bas är den "
#~ "typ av dagsräkningssystem som du vill använda:\n"
#~ "\n"
#~ "0  Amerikanskt 30/360\n"
#~ "1  verkliga dagar/verkliga dagar\n"
#~ "2  verkliga dagar/360\n"
#~ "3  verkliga dagar/365\n"
#~ "4  Europeiskt 30/360\n"
#~ "\n"
#~ "* Om @frekvens är en annan än 1, 2 eller 4 returnerar ODDLYIELD felvärdet "
#~ "#NUM!.\n"
#~ "* Om @bas utelämnas används amerikanskt 30/360-system.\n"
#~ "* Om @bas inte är mellan 0 och 4 returnerar ODDLYIELD felvärdet #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=AMORDEGRC\n"
#~ "@SYNTAX=AMORDEGRC(cost,purchase_date,first_period,salvage,period,rate[,"
#~ "basis])\n"
#~ "@DESCRIPTION=AMORDEGRC: Calculates depreciation for each accounting "
#~ "period using French accounting conventions.   Assets purchased in the "
#~ "middle of a period take prorated depreciation into account.  This is "
#~ "similar to AMORLINC, except that a depreciation coefficient is applied in "
#~ "the calculation depending on the life of the assets.\n"
#~ "Named for AMORtissement DEGRessif Comptabilite\n"
#~ "\n"
#~ "@cost The value of the asset.\n"
#~ "@purchase_date The date the asset was purchased.\n"
#~ "@first_period The end of the first period.\n"
#~ "@salvage Asset value at maturity.\n"
#~ "@period The length of accounting periods.\n"
#~ "@rate rate of depreciation as a percentage.\n"
#~ "@basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis is not in between 0 and 4, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "AMORDEGRC(2400,DATE(1998,8,19),DATE(1998,12,30),300,1,0.14,1) = 733\n"
#~ "\n"
#~ "@SEEALSO=AMORLINC"
#~ msgstr ""
#~ "@FUNCTION=AMORDEGRC\n"
#~ "@SYNTAX=AMORDEGRC(värde;köpdatum;första_period;slutpris;period;hast[;"
#~ "bas])\n"
#~ "@DESCRIPTION=AMORDEGRC: Räknar ut värdeminskningen för varje "
#~ "redovisningsperiod enligt franska redovisningsregler. Tillgångar köpta "
#~ "mitt i en period räknar med den föregågna värdeminskningen. Detta är "
#~ "liknande AMORLINC, utom att värdeminskningskoefficienten används i "
#~ "beräkningen beroende på livslängden på tillgången.\n"
#~ "Namngiven efter AMORtissement DEGRessif Comptabilite\n"
#~ "\n"
#~ "@värde Värdet på tillgången.\n"
#~ "@köpdatum Datumet tillgången köptes.\n"
#~ "@första_period Slutet på första perioden.\n"
#~ "@slutpris Värdet på tillgången vid mognad.\n"
#~ "@period Längden på redovisningsperioderna.\n"
#~ "@hast Hastigheten på värdeminskningen i procent.\n"
#~ "@bas är den typ av dagsräkningssystem som du vill använda:\n"
#~ "\n"
#~ "0  Amerikanskt 30/360\n"
#~ "1  verkliga dagar/verkliga dagar\n"
#~ "2  verkliga dagar/360\n"
#~ "3  verkliga dagar/365\n"
#~ "4  Europeiskt 30/360\n"
#~ "\n"
#~ "* Om @bas utelämnas används amerikanskt 30/360-system.\n"
#~ "* Om @bas inte är mellan 0 och 4 returneras felvärdet #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "AMORDEGRC(2400;DATE(1998;8;19);DATE(1998;12;30);300;1;0.14;1) = 733\n"
#~ "\n"
#~ "@SEEALSO=AMORLINC"

#~ msgid ""
#~ "@FUNCTION=AMORLINC\n"
#~ "@SYNTAX=AMORLINC(cost,purchase_date,first_period,salvage,period,rate[,"
#~ "basis])\n"
#~ "@DESCRIPTION=AMORLINC: Calculates depreciation for each accounting period "
#~ "using French accounting conventions.   Assets purchased in the middle of "
#~ "a period take prorated depreciation into account.\n"
#~ "Named for AMORtissement LINeaire Comptabilite.\n"
#~ "\n"
#~ "@cost The value of the asset.\n"
#~ "@purchase_date The date the asset was purchased.\n"
#~ "@first_period The end of the first period.\n"
#~ "@salvage Asset value at maturity.\n"
#~ "@period The length of accounting periods.\n"
#~ "@rate rate of depreciation as a percentage.\n"
#~ "@basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis is not in between 0 and 4, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "AMORLINC(2400,DATE(1998,8,19),DATE(1998,12,31),300,1,0.15,1) = 360\n"
#~ "\n"
#~ "@SEEALSO=AMORDEGRC"
#~ msgstr ""
#~ "@FUNCTION=AMORLINC\n"
#~ "@SYNTAX=AMORLINC(värde;köpdatum;första_period;slutpris;period;hast[;"
#~ "bas])\n"
#~ "@DESCRIPTION=AMORLINC: Räknar ut värdeminskningen för varje "
#~ "redovisningsperiod enligt franska redovisningsregler. Tillgångar köpta "
#~ "mitt i en period räknar med den föregågna värdeminskningen. Namngiven "
#~ "efter AMORtissement LINeaire Comptabilite\n"
#~ "\n"
#~ "@värde Värdet på tillgången.\n"
#~ "@köpdatum Datumet tillgången köptes.\n"
#~ "@första_period Slutet på första perioden.\n"
#~ "@slutpris Värdet på tillgången vid mognad.\n"
#~ "@period Längden på redovisningsperioderna.\n"
#~ "@hast Hastigheten på värdeminskningen i procent.\n"
#~ "@bas är den typ av dagsräkningssystem som du vill använda:\n"
#~ "\n"
#~ "0  Amerikanskt 30/360\n"
#~ "1  verkliga dagar/verkliga dagar\n"
#~ "2  verkliga dagar/360\n"
#~ "3  verkliga dagar/365\n"
#~ "4  Europeiskt 30/360\n"
#~ "\n"
#~ "* Om @bas utelämnas används amerikanskt 30/360-system.\n"
#~ "* Om @bas inte är mellan 0 och 4 returneras felvärdet #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "AMORLINC(2400;DATE(1998;8;19);DATE(1998;12;31);300;1;0.15;1) = 360\n"
#~ "\n"
#~ "@SEEALSO=AMORDEGRC"

#~ msgid ""
#~ "@FUNCTION=COUPDAYBS\n"
#~ "@SYNTAX=COUPDAYBS(settlement,maturity,frequency[,basis,eom])\n"
#~ "@DESCRIPTION=COUPDAYBS returns the number of days from the beginning of "
#~ "the coupon period to the settlement date.\n"
#~ "\n"
#~ "@settlement is the settlement date of the security.\n"
#~ "@maturity is the maturity date of the security.\n"
#~ "@frequency is the number of coupon payments per year.\n"
#~ "@eom = TRUE handles end of month maturity dates special.\n"
#~ "Allowed frequencies are: 1 = annual, 2 = semi, 4 = quarterly, 6 = "
#~ "bimonthly, 12 = monthly.\n"
#~ "@basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  MSRB 30/360 (MSRB Rule G33 (e))\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "  5  European+ 30/360\n"
#~ "\n"
#~ "(See the gnumeric manual for a detailed description of these bases).\n"
#~ "\n"
#~ "* If @frequency is invalid, COUPDAYBS returns #NUM! error.\n"
#~ "* If @basis is omitted, MSRB 30/360 is applied.\n"
#~ "* If @basis is invalid, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COUPDAYBS (DATE(2002,11,29),DATE(2004,2,29),4,0) = 89\n"
#~ "COUPDAYBS (DATE(2002,11,29),DATE(2004,2,29),4,0,FALSE) = 0\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=COUPDAYBS\n"
#~ "@SYNTAX=COUPDAYBS(avräkning;mognad;frekvens[;bas;eom])\n"
#~ "@DESCRIPTION=COUPDAYBS returnerar antalet dagar från början på "
#~ "betalningsperioden till avräkningsdatumet.\n"
#~ "\n"
#~ "@avräkning är avräkningsdatumet för säkerheten.\n"
#~ "@mognad är mognadsdatumet för säkerheten.\n"
#~ "@frekvens är antalet betalningar per år.\n"
#~ "@eom=SANT behandlar mognadsdatum i slutet på månader speciellt.\n"
#~ "Tillåtna frekvenser är: 1 = årligen, 2 = halvårsvis, 4 = kvartalsvis, 6 = "
#~ "varannan månad, 12 = månatligen.\n"
#~ "@bas är den typ av dagsräkningssystem som du vill använda:\n"
#~ "\n"
#~ "0  MSRB 30/360 (MSRB-regel G33 (e))\n"
#~ "1  verkliga dagar/verkliga dagar\n"
#~ "2  verkliga dagar/360\n"
#~ "3  verkliga dagar/365\n"
#~ "4  Europeiskt 30/360\n"
#~ "5  Europeiskt+ 30/360\n"
#~ "\n"
#~ "(se gnumericmanualen för en detaljerad beskrivning av dessa baser)\n"
#~ "\n"
#~ "* Om @frekvens är ogiltig returnerar COUPDAYBS felvärdet #NUM!.\n"
#~ "* Om @bas utelämnas används MSRB 30/360-system.\n"
#~ "* Om @bas är ogiltig returneras felvärdet #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COUPDAYBS (DATE(2002;11;29);DATE(2004;2;29);4;0) = 89\n"
#~ "COUPDAYBS (DATE(2002;11;29);DATE(2004;2;29);4;0;FALSKT) = 0\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=COUPDAYS\n"
#~ "@SYNTAX=COUPDAYS(settlement,maturity,frequency[,basis,eom])\n"
#~ "@DESCRIPTION=COUPDAYS returns the number of days in the coupon period of "
#~ "the settlement date.\n"
#~ "\n"
#~ "@settlement is the settlement date of the security.\n"
#~ "@maturity is the maturity date of the security.\n"
#~ "@frequency is the number of coupon payments per year.\n"
#~ "@eom = TRUE handles end of month maturity dates special.\n"
#~ "Allowed frequencies are: 1 = annual, 2 = semi, 4 = quarterly, 6 = "
#~ "bimonthly, 12 = monthly.\n"
#~ "@basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  MSRB 30/360 (MSRB Rule G33 (e))\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "  5  European+ 30/360\n"
#~ "\n"
#~ "(See the gnumeric manual for a detailed description of these bases).\n"
#~ "\n"
#~ "* If @frequency is invalid, COUPDAYS returns #NUM! error.\n"
#~ "* If @basis is omitted, MSRB 30/360 is applied.\n"
#~ "* If @basis is invalid, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COUPDAYS (DATE(2002,11,29),DATE(2004,2,29),4,0) = 90\n"
#~ "COUPDAYS (DATE(2002,11,29),DATE(2004,2,29),4,0,FALSE) = 90\n"
#~ "COUPDAYS (DATE(2002,11,29),DATE(2004,2,29),4,1,FALSE) = 91\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=COUPDAYS\n"
#~ "@SYNTAX=COUPDAYS(avräkning;mognad;frekvens[;bas;eom])\n"
#~ "@DESCRIPTION=COUPDAYS returnerar antalet dagar från början på "
#~ "betalningsperioden till avräkningsdatumet.\n"
#~ "\n"
#~ "@avräkning är avräkningsdatumet för säkerheten.\n"
#~ "@mognad är mognadsdatumet för säkerheten.\n"
#~ "@frekvens är antalet betalningar per år.\n"
#~ "@eom=SANT behandlar mognadsdatum i slutet på månader speciellt.\n"
#~ "Tillåtna frekvenser är: 1 = årligen, 2 = halvårsvis, 4 = kvartalsvis, 6 = "
#~ "varannan månad, 12 = månatligen.\n"
#~ "@bas är den typ av dagsräkningssystem som du vill använda:\n"
#~ "\n"
#~ "0  MSRB 30/360 (MSRB-regel G33 (e))\n"
#~ "1  verkliga dagar/verkliga dagar\n"
#~ "2  verkliga dagar/360\n"
#~ "3  verkliga dagar/365\n"
#~ "4  Europeiskt 30/360\n"
#~ "5  Europeiskt+ 30/360\n"
#~ "\n"
#~ "(se gnumericmanualen för en detaljerad beskrivning av dessa baser)\n"
#~ "\n"
#~ "* Om @frekvens är ogiltig returnerar COUPDAYS felvärdet #NUM!.\n"
#~ "* Om @bas utelämnas används MSRB 30/360-system.\n"
#~ "* Om @bas är ogiltig returneras felvärdet #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COUPDAYS (DATE(2002;11;29);DATE(2004;2;29);4;0) = 90\n"
#~ "COUPDAYS (DATE(2002;11;29);DATE(2004;2;29);4;0;FALSKT) = 90\n"
#~ "COUPDAYS (DATE(2002;11;29);DATE(2004;2;29);4;1;FALSKT) = 91\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=COUPDAYSNC\n"
#~ "@SYNTAX=COUPDAYSNC(settlement,maturity,frequency[,basis,eom])\n"
#~ "@DESCRIPTION=COUPDAYSNC returns the number of days from the settlement "
#~ "date to the next coupon date.\n"
#~ "\n"
#~ "@settlement is the settlement date of the security.\n"
#~ "@maturity is the maturity date of the security.\n"
#~ "@frequency is the number of coupon payments per year.\n"
#~ "@eom = TRUE handles end of month maturity dates special.\n"
#~ "Allowed frequencies are: 1 = annual, 2 = semi, 4 = quarterly, 6 = "
#~ "bimonthly, 12 = monthly.\n"
#~ "@basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  MSRB 30/360 (MSRB Rule G33 (e))\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "  5  European+ 30/360\n"
#~ "\n"
#~ "(See the gnumeric manual for a detailed description of these bases).\n"
#~ "\n"
#~ "* If @frequency is invalid, COUPDAYSNC returns #NUM! error.\n"
#~ "* If @basis is omitted, MSRB 30/360 is applied.\n"
#~ "* If @basis is invalid, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COUPDAYSNC (DATE(2002,11,29),DATE(2004,2,29),4,0) = 1\n"
#~ "COUPDAYSNC (DATE(2002,11,29),DATE(2004,2,29),4,0,FALSE) = 89\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=COUPDAYSNC\n"
#~ "@SYNTAX=COUPDAYSNC(avräkning;mognad;frekvens[;bas;eom])\n"
#~ "@DESCRIPTION=COUPDAYSNC returnerar antalet dagar från avräkningsdatumet "
#~ "till nästa betalningsdatum.\n"
#~ "\n"
#~ "@avräkning är avräkningsdatumet för säkerheten.\n"
#~ "@mognad är mognadsdatumet för säkerheten.\n"
#~ "@frekvens är antalet betalningar per år.\n"
#~ "@eom=SANT gör att mognadsdatum i slutet av månader hanteras speciellt.\n"
#~ "Tillåtna frekvenser är: 1 = årligen, 2 = halvårsvis, 4 = kvartalsvis, 6 = "
#~ "varannan månad, 12 = månatligen.\n"
#~ "@bas är den typ av dagsräkningssystem som du vill använda:\n"
#~ "\n"
#~ "0  MSRB 30/360 (MSRB-regel G33 (e))\n"
#~ "1  verkliga dagar/verkliga dagar\n"
#~ "2  verkliga dagar/360\n"
#~ "3  verkliga dagar/365\n"
#~ "4  Europeiskt 30/360\n"
#~ "5  Europeiskt+ 30/360\n"
#~ "\n"
#~ "(se gnumericmanualen för en detaljerad beskrivning av dessa baser)\n"
#~ "\n"
#~ "* Om @frekvens är ogiltig returnerar COUPDAYSNC felvärdet #NUM!.\n"
#~ "* Om @bas utelämnas används MSRB 30/360-system.\n"
#~ "* Om @bas är ogiltig returneras felvärdet #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COUPDAYSNC (DATE(2002;11;29);DATE(2004;2;29);4;0) = 1\n"
#~ "COUPDAYSNC (DATE(2002;11;29);DATE(2004;2;29);4;0;FALSKT) = 89\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=COUPNCD\n"
#~ "@SYNTAX=COUPNCD(settlement,maturity,frequency[,basis,eom])\n"
#~ "@DESCRIPTION=COUPNCD returns the coupon date following settlement.\n"
#~ "\n"
#~ "@settlement is the settlement date of the security.\n"
#~ "@maturity is the maturity date of the security.\n"
#~ "@frequency is the number of coupon payments per year.\n"
#~ "@eom = TRUE handles end of month maturity dates special.\n"
#~ "Allowed frequencies are: 1 = annual, 2 = semi, 4 = quarterly, 6 = "
#~ "bimonthly, 12 = monthly.\n"
#~ "@basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  MSRB 30/360 (MSRB Rule G33 (e))\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "  5  European+ 30/360\n"
#~ "\n"
#~ "(See the gnumeric manual for a detailed description of these bases).\n"
#~ "\n"
#~ "* If @frequency is invalid, COUPNCD returns #NUM! error.\n"
#~ "* If @basis is omitted, MSRB 30/360 is applied.\n"
#~ "* If @basis is invalid, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COUPNCD (DATE(2002,11,29),DATE(2004,2,29),4,0) = 30-Nov-2002\n"
#~ "COUPNCD (DATE(2002,11,29),DATE(2004,2,29),4,0,FALSE) = 28-Feb-2003\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=COUPNCD\n"
#~ "@SYNTAX=COUPNCD(avräkning;mognad;frekvens[;bas;eom])\n"
#~ "@DESCRIPTION=COUPNCD returnerar betalningsdatumet som följer "
#~ "avräkningen.\n"
#~ "\n"
#~ "@avräkning är avräkningsdatumet för säkerheten.\n"
#~ "@mognad är mognadsdatumet för säkerheten.\n"
#~ "@frekvens är antalet betalningar per år.\n"
#~ "@eom = SANT behandlar mognadsdatum i slutet av månaden speciellt.\n"
#~ "Tillåtna frekvenser är: 1 = årligen, 2 = halvårsvis, 4 = kvartalsvis, 6 = "
#~ "varannan månad, 12 = månatligen.\n"
#~ "@bas är den typ av dagsräkningssystem som du vill använda:\n"
#~ "\n"
#~ "0  MSRB 30/360 (MSRB-regel G33 (e))\n"
#~ "1  verkliga dagar/verkliga dagar\n"
#~ "2  verkliga dagar/360\n"
#~ "3  verkliga dagar/365\n"
#~ "4  Europeiskt 30/360\n"
#~ "5  Europeiskt+ 30/360\n"
#~ "\n"
#~ "(se gnumericmanualen för en detaljerad beskrivning av dessa baser)\n"
#~ "\n"
#~ "* Om @frekvens är ogiltig returnerar COUPNCD felvärdet #NUM!.\n"
#~ "* Om @bas utelämnas används MSRB 30/360-system.\n"
#~ "* Om @bas är ogiltig returneras felvärdet #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COUPNCD (DATE(2002;11;29)DATE(2004;2;29);4;0) = 30-Nov-2002\n"
#~ "COUPNCD (DATE(2002;11;29);DATE(2004;2;29);4;0;FALSKT) = 28-Feb-2003\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=COUPPCD\n"
#~ "@SYNTAX=COUPPCD(settlement,maturity,frequency[,basis,eom])\n"
#~ "@DESCRIPTION=COUPPCD returns the coupon date preceding settlement.\n"
#~ "\n"
#~ "@settlement is the settlement date of the security.\n"
#~ "@maturity is the maturity date of the security.\n"
#~ "@frequency is the number of coupon payments per year.\n"
#~ "@eom = TRUE handles end of month maturity dates special.\n"
#~ "Allowed frequencies are: 1 = annual, 2 = semi, 4 = quarterly, 6 = "
#~ "bimonthly, 12 = monthly.\n"
#~ "@basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  MSRB 30/360 (MSRB Rule G33 (e))\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "  5  European+ 30/360\n"
#~ "\n"
#~ "(See the gnumeric manual for a detailed description of these bases).\n"
#~ "\n"
#~ "* If @frequency is invalid, COUPPCD returns #NUM! error.\n"
#~ "* If @basis is omitted, MSRB 30/360 is applied.\n"
#~ "* If @basis is invalid, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COUPPCD (DATE(2002,11,29),DATE(2004,2,29),4,0) = 31-Aug-2002\n"
#~ "COUPPCD (DATE(2002,11,29),DATE(2004,2,29),4,0,FALSE) = 29-Nov-2002\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=COUPPCD\n"
#~ "@SYNTAX=COUPPCD(avräkning;mognad;frekvens[;bas;eom])\n"
#~ "@DESCRIPTION=COUPPCD returnerar betalningsdatumet innan avräkningen.\n"
#~ "\n"
#~ "@avräkning är avräkningsdatumet för säkerheten.\n"
#~ "@mognad är mognadsdatumet för säkerheten.\n"
#~ "@frekvens är antalet betalningar per år.\n"
#~ "@eom = SANT behandlar mognadsdatum i slutet av månaden speciellt.\n"
#~ "Tillåtna frekvenser är: 1 = årligen, 2 = halvårsvis, 4 = kvartalsvis, 6 = "
#~ "varannan månad, 12 = månatligen.\n"
#~ "@bas är den typ av dagsräkningssystem som du vill använda:\n"
#~ "\n"
#~ "0  MSRB 30/360 (MSRB-regel G33 (e))\n"
#~ "1  verkliga dagar/verkliga dagar\n"
#~ "2  verkliga dagar/360\n"
#~ "3  verkliga dagar/365\n"
#~ "4  Europeiskt 30/360\n"
#~ "5  Europeiskt+ 30/360\n"
#~ "\n"
#~ "(se gnumericmanualen för en detaljerad beskrivning av dessa baser)\n"
#~ "\n"
#~ "* Om @frekvens är ogiltig returnerar COUPPCD felvärdet #NUM!.\n"
#~ "* Om @bas utelämnas används MSRB 30/360-system.\n"
#~ "* Om @bas är ogiltig returneras felvärdet #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COUPPCD (DATE(2002;11;29);DATE(2004;2;29);4;0) = 31-Aug-2002\n"
#~ "COUPPCD (DATE(2002;11;29);DATE(2004;2;29);4;0;FALSKT) = 29-Nov-2002\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=COUPNUM\n"
#~ "@SYNTAX=COUPNUM(settlement,maturity,frequency[,basis,eom])\n"
#~ "@DESCRIPTION=COUPNUM returns the numbers of coupons to be paid between "
#~ "the settlement and maturity dates, rounded up.\n"
#~ "\n"
#~ "@settlement is the settlement date of the security.\n"
#~ "@maturity is the maturity date of the security.\n"
#~ "@frequency is the number of coupon payments per year.\n"
#~ "@eom = TRUE handles end of month maturity dates special.\n"
#~ "Allowed frequencies are: 1 = annual, 2 = semi, 4 = quarterly. 6 = "
#~ "bimonthly, 12 = monthly.\n"
#~ "@basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  MSRB 30/360 (MSRB Rule G33 (e))\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "  5  European+ 30/360\n"
#~ "\n"
#~ "* If @frequency is other than 1, 2, 4, 6 or 12, COUPNUM returns #NUM! "
#~ "error.\n"
#~ "* If @basis is omitted, MSRB 30/360 is applied.\n"
#~ "* If @basis is not in between 0 and 5, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COUPNUM (DATE(2002,11,29),DATE(2004,2,29),4,0) = 6\n"
#~ "COUPNUM (DATE(2002,11,29),DATE(2004,2,29),4,0,FALSE) = 5\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=COUPNUM\n"
#~ "@SYNTAX=COUPNUM(avräkning;mognad;frekvens[;bas;eom])\n"
#~ "@DESCRIPTION=COUPNUM returnerar antalet betalningar som ska betalas "
#~ "mellan avräkning och mognadsdatumet, avrundade uppåt.\n"
#~ "\n"
#~ "@avräkning är avräkningsdatumet för säkerheten.\n"
#~ "@mognad är mognadsdatumet för säkerheten.\n"
#~ "@frekvens är antalet betalningar per år.\n"
#~ "@eom = SANT behandlar mognadsdatum i slutet av månaden speciellt.\n"
#~ "Tillåtna frekvenser är: 1 = årligen, 2 = halvårsvis, 4 = kvartalsvis 6 = "
#~ "varannan månad, 12 = månatligen.\n"
#~ "@bas är den typ av dagsräkningssystem som du vill använda:\n"
#~ "\n"
#~ "0  MSRB 30/360 (MSRB-regel G33 (e))\n"
#~ "1  verkliga dagar/verkliga dagar\n"
#~ "2  verkliga dagar/360\n"
#~ "3  verkliga dagar/365\n"
#~ "4  Europeiskt 30/360\n"
#~ "5  Europeiskt+ 30/360\n"
#~ "\n"
#~ "* Om @frekvens är en annan än 1, 2 eller 4 returnerar COUPNUM "
#~ "felvärdet#NUM!.\n"
#~ "* Om @bas utelämnas används MSRB 30/360-system.\n"
#~ "* Om @bas inte är mellan 0 och 5 returneras felvärdet #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COUPNUM (DATE(2002;11;29);DATE(2004;2;29);4;0) = 6\n"
#~ "COUPNUM (DATE(2002;11;29);DATE(2004;2;29);4;0;FALSKT) = 5\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=CUM_BIV_NORM_DIST\n"
#~ "@SYNTAX=CUM_BIV_NORM_DIST(a,b,rho)\n"
#~ "@DESCRIPTION=CUM_BIV_NORM_DIST calculates the cumulative bivariate normal "
#~ "distribution from parameters a, b & rho.\n"
#~ "The return value is the probability that two random variables with "
#~ "correlation @rho are respectively each less than @a and @b.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=NORMDIST,NORMSDIST,NORMSINV"
#~ msgstr ""
#~ "@FUNCTION=CUM_BIV_NORM_DIST\n"
#~ "@SYNTAX=CUM_BIV_NORM_DIST(a;b;rho)\n"
#~ "@DESCRIPTION=CUM_BIV_NORM_DIST beräknar den kumulativa bivariata "
#~ "normaldistributionen från parametrarna a, b och rho.\n"
#~ "Returvärdet är sannolikheten att två slumpmässiga variabler med "
#~ "korrelation @rho är mindre n @a och @b.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=NORMDIST,NORMSDIST,NORMSINV"

# FIXME: Någon som förstår detta?
#~ msgid ""
#~ "@FUNCTION=OPT_BS\n"
#~ "@SYNTAX=OPT_BS(call_put_flag,spot,strike,time,rate,volatility [,"
#~ "cost_of_carry])\n"
#~ "@DESCRIPTION=OPT_BS uses the Black-Scholes model to calculate the price "
#~ "of a European option using call_put_flag, @call_put_flag, 'c' or 'p' "
#~ "struck at @strike on an asset with spot price @spot.\n"
#~ "@time is the time to maturity of the option expressed in years.\n"
#~ "@rate is the risk-free interest rate.\n"
#~ "@volatility is the annualized volatility, in percent, of the asset for "
#~ "the period through to the exercise date. \n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "* The returned value will be expressed in the same units as @strike and "
#~ "@spot.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_VEGA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=opt_bs\n"
#~ "@SYNTAX=OPT_BS(fjäril;avista;slag;tid;ränta;flyktighet[;cost_of_carry])\n"
#~ "@DESCRIPTION=OPT_BS använder Black-Scholes modell för att beräkna priset "
#~ "på en europeisk option med @fjäril \"c\" eller \"p\" slagen vid @slag på "
#~ "en tillgång med avistan @avista.\n"
#~ "@tid är tiden till mognad av optionen i år.\n"
#~ "@ränta är den riskfria räntan.\n"
#~ "@flyktighet är den årliga flyktigheten, i procent, av tillgången för "
#~ "perioden fram till förfallodatumet.\n"
#~ "@cost_of_carry är värdeläckaget på den underliggande tillgången, för "
#~ "vanliga aktier är det den årliga utdelningen.\n"
#~ "* Det returnerade värdet kommer att uttryckas i samma enheter som @slag "
#~ "och @avista.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_VEGA, OPT_BS_GAMMA"

#~ msgid ""
#~ "@FUNCTION=OPT_BS_DELTA\n"
#~ "@SYNTAX=OPT_BS_DELTA(call_put_flag,spot,strike,time,rate,volatility[,"
#~ "cost_of_carry])\n"
#~ "@DESCRIPTION=OPT_BS_DELTA uses the Black-Scholes model to calculate the "
#~ "'delta' of a European option with call_put_flag, @call_put_flag, 'c' or "
#~ "'p' struck at @strike on an asset with spot price @spot.\n"
#~ "Where @time is the time to maturity of the option expressed in years.\n"
#~ "@rate is the risk-free interest rate.\n"
#~ "@volatility is the annualized volatility, in percent, of the asset for "
#~ "the period through to the exercise date. \n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "* The returned value will be expressed in the same units as @strike and "
#~ "@spot.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_VEGA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_BS_DELTA\n"
#~ "@SYNTAX=OPT_BS_DELTA(fjäril;avista;slag;tid;ränta;flyktighet[;"
#~ "cost_of_carry)]\n"
#~ "@DESCRIPTION=OPT_BS_DELTA använder Black-Scholes modell för att beräkna "
#~ "\"delta\" på en europeisk option med @fjäril \"c\" eller \"p\" slagen vid "
#~ "@slag på en tillgång med avistan @avista.\n"
#~ "@tid är tiden till mognad av optionen i år.\n"
#~ "@ränta är den riskfria räntan.\n"
#~ "@flyktighet är den årliga flyktigheten, i procent, av tillgången för "
#~ "perioden fram till förfallodatumet.\n"
#~ "@cost_of_carry är värdeläckaget på den underliggande tillgången, för "
#~ "vanliga aktier är det den årliga utdelningen.\n"
#~ "* Det returnerade värdet uttrycks som förändringen i optionsvärdet per "
#~ "enhet förändring i @avista.\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_VEGA, OPT_BS_GAMMA"

#~ msgid ""
#~ "@FUNCTION=OPT_BS_GAMMA\n"
#~ "@SYNTAX=OPT_BS_GAMMA(spot,strike,time,rate,volatility[,cost_of_carry])\n"
#~ "@DESCRIPTION=OPT_BS_GAMMA uses the Black-Scholes model to calculate the "
#~ "'gamma' of a European option struck at @strike on an asset with spot "
#~ "price @spot.\n"
#~ "\n"
#~ "(The gamma of an option is the second derivative of its price with "
#~ "respect to the price of the underlying asset, and is the same for calls "
#~ "and puts.)\n"
#~ "\n"
#~ "@time is the time to maturity of the option expressed in years.\n"
#~ "@rate is the risk-free interest rate to the exercise date, in percent.\n"
#~ "@volatility is the annualized volatility, in percent, of the asset for "
#~ "the period through to the exercise date.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "* The returned value will be expressed as the rate of change of delta per "
#~ "unit change in @spot.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_VEGA"
#~ msgstr ""
#~ "@FUNCTION=OPT_BS_GAMMA\n"
#~ "@SYNTAX=OPT_BS_GAMMA(avista;slag;tid;ränta;flyktighet[;cost_of_carry])\n"
#~ "@DESCRIPTION=OPT_BS_GAMMA använder Black-Scholes modell för att beräkna "
#~ "\"gamma\" på en europeisk option slagen vid @slag på en tillgång med "
#~ "avistan @avista.\n"
#~ "\n"
#~ "(gamma för en option är andraderivatan på dess pris avseende på "
#~ "avistapriset på den underliggande tillgången, och är densamma för köp och "
#~ "sälj.)\n"
#~ "\n"
#~ "@tid är tiden till mognad av optionen i år.\n"
#~ "@ränta är den riskfria räntan, i procent, till förfallodatumet.\n"
#~ "@flyktighet är den årliga flyktigheten, i procent, av tillgången för "
#~ "perioden fram till förfallodatumet.\n"
#~ "@cost_of_carry är värdeläckaget på den underliggande tillgången, för "
#~ "vanliga aktier är det den årliga utdelningen.\n"
#~ "* Det returnerade värdet uttrycks som förändringen av delta per enhet "
#~ "förändring i @avista.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_VEGA"

#~ msgid ""
#~ "@FUNCTION=OPT_BS_THETA\n"
#~ "@SYNTAX=OPT_BS_THETA(call_put_flag,spot,strike,time,rate,volatility[,"
#~ "cost_of_carry])\n"
#~ "@DESCRIPTION=OPT_BS_THETA uses the Black-Scholes model to calculate the "
#~ "'theta' of a European option with call_put_flag, @call_put_flag struck at "
#~ "@strike on an asset with spot price @spot.\n"
#~ "\n"
#~ "(The theta of an option is the rate of change of its price with respect "
#~ "to time to expiry.)\n"
#~ "\n"
#~ "@time is the time to maturity of the option expressed in years\n"
#~ "and @rate is the risk-free interest rate to the exercise date, in "
#~ "percent.\n"
#~ "@volatility is the annualized volatility, in percent, of the asset for "
#~ "the period through to the exercise date.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "* The returned value will be expressed as minus the rate of change of "
#~ "option value, per 365.25 days.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_VEGA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_BS_THETA\n"
#~ "@SYNTAX=OPT_BS_THETA(fjäril;avista;slag;tid;ränta;flyktighet[;"
#~ "cost_of_carry])\n"
#~ "@DESCRIPTION=OPT_BS_THETA använder Black-Scholes modell för att beräkna "
#~ "\"theta\" på en europeisk option med @fjäril slagen vid @slag på en "
#~ "tillgång med avistan @avista.\n"
#~ "\n"
#~ "(theta för en option är förändringstakten på dess pris med avseende på "
#~ "tiden till lösen.)\n"
#~ "\n"
#~ "@tid är tiden till mognad av optionen i år.\n"
#~ "@ränta är den riskfria räntan, i procent, till förfallodatumet.\n"
#~ "@flyktighet är den årliga flyktigheten, i procent, av tillgången för "
#~ "perioden fram till förfallodatumet.\n"
#~ "@cost_of_carry är värdeläckaget på den underliggande tillgången, för "
#~ "vanliga aktier är det den årliga utdelningen.\n"
#~ "* Det returnerade värdet uttrycks som minus förändringen av optionsvärdet "
#~ "per 365,25 dagar.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_VEGA, OPT_BS_GAMMA"

#~ msgid ""
#~ "@FUNCTION=OPT_BS_VEGA\n"
#~ "@SYNTAX=OPT_BS_VEGA(spot,strike,time,rate,volatility[,cost_of_carry])\n"
#~ "@DESCRIPTION=OPT_BS_VEGA uses the Black-Scholes model to calculate the "
#~ "'vega' of a European option struck at @strike on an asset with spot price "
#~ "@spot.\n"
#~ "(The vega of an option is the rate of change of its price with respect to "
#~ "volatility, and is the same for calls and puts.)\n"
#~ "@volatility is the annualized volatility, in percent, of the asset for "
#~ "the period through to the exercise date.\n"
#~ " @time is the time to maturity of the option expressed in years.\n"
#~ "@rate is the risk-free interest rate to the exercise date, in percent.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "\n"
#~ "* The returned value will be expressed as the rate of change of option "
#~ "value, per 100% volatility.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_BS_VEGA\n"
#~ "@SYNTAX=OPT_BS_VEGA(avista;slag;tid;ränta;flyktighet[;cost_of_carry])\n"
#~ "@DESCRIPTION=OPT_BS_VEGA använder Black-Scholes modell för att beräkna "
#~ "\"vega\" på en europeisk option slagen vid @slag på en tillgång med "
#~ "avistan @avista.\n"
#~ "(vega för en option är förändringstakten på dess pris med avseende på "
#~ "flyktighet och är densamma för köp och sälj.)\n"
#~ "@flyktighet är den årliga flyktigheten, i procent, av tillgången för "
#~ "perioden fram till förfallodatumet.\n"
#~ "@tid är tiden till mognad av optionen i år.\n"
#~ "@ränta är den riskfria räntan, i procent, till förfallodatumet.\n"
#~ "@cost_of_carry är värdeläckaget på den underliggande tillgången, för "
#~ "vanliga aktier är det den årliga utdelningen.\n"
#~ "\n"
#~ "* Det returnerade värdet uttrycks som förändringen av optionsvärdet per "
#~ "100% flyktighet.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#~ msgid ""
#~ "@FUNCTION=OPT_BS_RHO\n"
#~ "@SYNTAX=OPT_BS_RHO(call_put_flag,spot,strike,time,rate,volatility[,"
#~ "cost_of_carry])\n"
#~ "@DESCRIPTION=OPT_BS_RHO uses the Black-Scholes model to calculate the "
#~ "'rho' of a European option with call_put_flag, @call_put_flag struck at "
#~ "@strike on an asset with spot price @spot.\n"
#~ "@call_put_flag is 'c' or 'p' to indicate whether the option is a call or "
#~ "a put.\n"
#~ "\n"
#~ "(The rho of an option is the rate of change of its price with respect to "
#~ "the risk free interest rate.)\n"
#~ "@time is the time to maturity of the option expressed in years.\n"
#~ "@rate is the risk-free interest rate to the exercise date, in percent.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "* The returned value will be expressed as the rate of change of option "
#~ "value, per 100% change in @rate.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_THETA, OPT_BS_VEGA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_BS_RHO\n"
#~ "@SYNTAX=OPT_BS_RHO(fjäril;avista;slag;tid;ränta;flyktighet[;"
#~ "cost_of_carry])\n"
#~ "@DESCRIPTION=OPT_BS_RHO använder Black-Scholes modell för att beräkna "
#~ "\"rho\" på en europeisk option med @fjäril slagen vid @slag på en "
#~ "tillgång med avistan @avista.\n"
#~ "@fjäril är \"c\" eller \"p\" beroende på om optionen är köp- eller "
#~ "säljoption.\n"
#~ "\n"
#~ "(rho för en option är förändringstakten på dess pris med avseende på den "
#~ "riskfria räntesatsen.)\n"
#~ "@tid är tiden till mognad av optionen i år.\n"
#~ "@ränta är den riskfria räntan till förfallodatumet, i procent.\n"
#~ "@cost_of_carry är värdeläckaget på den underliggande tillgången, för "
#~ "vanliga aktier är det den årliga utdelningen.\n"
#~ "* Det returnerade värdet uttrycks som förändringen av optionsvärdet per "
#~ "100% förändring i ränta.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_THETA, OPT_BS_VEGA, OPT_BS_GAMMA"

#~ msgid ""
#~ "@FUNCTION=OPT_BS_CARRYCOST\n"
#~ "@SYNTAX=OPT_BS_CARRYCOST(call_put_flag,spot,strike,time,rate,volatility[,"
#~ "cost_of_carry])\n"
#~ "@DESCRIPTION=OPT_BS_CARRYCOST uses the Black-Scholes model to calculate "
#~ "the 'elasticity' of a European option struck at @strike on an asset with "
#~ "spot price @spot.\n"
#~ "@call_put_flag is 'c' or 'p' to indicate whether the option is a call or "
#~ "a put.\n"
#~ "\n"
#~ "(The elasticity of an option is the rate of change of its price with "
#~ "respect to its cost of carry.)\n"
#~ "\n"
#~ "@volatility is the annualized volatility, in percent, of the asset for "
#~ "the period through to the exercise date.  @time is the time to maturity "
#~ "of the option expressed in years.\n"
#~ "@rate is the risk-free interest rate to the exercise date, in percent.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "\n"
#~ "* The returned value will be expressed as the rate of change of option "
#~ "value, per 100% volatility.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_BS_CARRYCOST\n"
#~ "@SYNTAX=OPT_BS_CARRYCOST(fjäril;avista;slag;tid;ränta;flyktighet[;"
#~ "cost_of_carry])\n"
#~ "@DESCRIPTION=OPT_BS_CARRYCOST använder Black-Scholes modell för att "
#~ "beräkna \"elasticiteten\" på en europeisk option slagen vid @slag på en "
#~ "tillgång med avistan @avista.\n"
#~ "@fjäril är \"c\" eller \"p\" beroende på om optionen är köp- eller "
#~ "säljoption.\n"
#~ "\n"
#~ "(Elasticiteten för en option är förändringstakten på dess pris med "
#~ "avseende på cost_of_carry.)\n"
#~ "\n"
#~ "@flyktighet är den årliga flyktigheten, i procent, av tillgången för "
#~ "perioden fram till förfallodatumet.\n"
#~ "@tid är tiden till mognad av optionen i år.\n"
#~ "@ränta är den riskfria räntan till förfallodatumet, i procent.\n"
#~ "@cost_of_carry är värdeläckaget på den underliggande tillgången, för "
#~ "vanliga aktier är det den årliga utdelningen.\n"
#~ "\n"
#~ "* Det returnerade värdet uttrycks som förändringen av optionsvärdet per "
#~ "100% volatilitet.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

# FIXME: Någon som förstår detta?
#~ msgid ""
#~ "@FUNCTION=OPT_GARMAN_KOHLHAGEN\n"
#~ "@SYNTAX=OPT_GARMAN_KOHLHAGEN(call_put_flag,spot,strike,time,domestic_rate,"
#~ "foreign_rate,volatility[,cost_of_carry])\n"
#~ "@DESCRIPTION=OPT_GARMAN_KOHLHAGEN values the theoretical price of a "
#~ "European currency option struck at @strike on an asset with spot price "
#~ "@spot.\n"
#~ "@call_put_flag is 'c' or 'p' to indicate whether the option is a call or "
#~ "a put.\n"
#~ "@volatility is the annualized volatility, in percent, of the asset for "
#~ "the period through to the exercise date. \n"
#~ "@time the number of days to exercise.\n"
#~ "@domestic_rate is the domestic risk-free interest rate to the exercise "
#~ "date.\n"
#~ "@foreign_rate is the foreign risk-free interest rate to the exercise "
#~ "date, in percent.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "* The returned value will be expressed as the rate of change of option "
#~ "value, per 100% volatility.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_GARMAN_KOHLHAGEN\n"
#~ "@SYNTAX=OPT_GARMAN_KOHLHAGEN(fjäril;avista;slag;tid;inhemsk_ränta;"
#~ "utländsk_ränta;flyktighet[;cost_of_carry])\n"
#~ "@DESCRIPTION=OPT_GARMAN_KOHLHAGEN beräknar det teoretiska priset på en "
#~ "europeisk valutaoption slagen vid @slag på en tillgång med avistan "
#~ "@avista.\n"
#~ "@fjäril är \"c\" eller \"p\" beroende på om optionen är köp- eller "
#~ "säljoption.\n"
#~ "@flyktighet är den årliga flyktigheten, i procent, av tillgången för "
#~ "perioden fram till förfallodatumet.\n"
#~ "@tid är antalet dagar till förfallodatumet.\n"
#~ "@inhemsk_ränta är den inhemska riskfria räntesatsen till förfallodatumet "
#~ "i procent.\n"
#~ "@utländsk_ränta är den utländska  riskfria räntesatsen till "
#~ "förfallodatumet i procent.\n"
#~ "@cost_of_carry är värdeläckaget på den underliggande tillgången, för "
#~ "vanliga aktier är det den årliga utdelningen.\n"
#~ "* Det returnerade värdet uttrycks som förändringen av optionsvärdet per "
#~ "100% volatilitet.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#~ msgid ""
#~ "@FUNCTION=OPT_FRENCH\n"
#~ "@SYNTAX=OPT_FRENCH(call_put_flag,spot,strike,time,t2,rate,volatility[,"
#~ "cost_of_carry])\n"
#~ "@DESCRIPTION=OPT_FRENCH values the theoretical price of a European option "
#~ "adjusted for trading day volatility, struck at @strike on an asset with "
#~ "spot price @spot.\n"
#~ "@call_put_flag is 'c' or 'p' to indicate whether the option is a call or "
#~ "a put.\n"
#~ "@volatility is the annualized volatility, in percent, of the asset for "
#~ "the period through to the exercise date.\n"
#~ " @time the number of calendar days to exercise divided by calendar days "
#~ "in the year.\n"
#~ "@t2 is the number of trading days to exercise divided by trading days in "
#~ "the year.\n"
#~ "@rate is the risk-free interest rate.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, to the "
#~ "exercise date, in percent.\n"
#~ "For common stocks, this would be the dividend yield.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_FRENCH\n"
#~ "@SYNTAX=OPT_FRENCH(fjäril;avista;slag;tid;t2;ränta;flyktighet[;"
#~ "cost_of_carry])\n"
#~ "@DESCRIPTION=OPT_FRENCH beräknar det teoretiska priset på en europeisk "
#~ "option justerad för handelsdagsflyktighet, slagen vid @slag på en "
#~ "tillgång med avistan @avista.\n"
#~ "@fjäril är \"c\" eller \"p\" beroende på om optionen är köp- eller "
#~ "säljoption.\n"
#~ "@flyktighet är den årliga flyktigheten, i procent, av tillgången för "
#~ "perioden fram till förfallodatumet.\n"
#~ "@tid är antalet kalenderdagar till förfallodatumet delat med antalet "
#~ "handelsdagar under året.\n"
#~ "@t2 är antalet handelsdagar till förfallodatumet delat med antalet "
#~ "handelsdagar under året.\n"
#~ "@ränta är den riskfria räntan,\n"
#~ "@cost_of_carry är värdeläckaget på den underliggande tillgången, fram "
#~ "till förfallodatumet, i procent.\n"
#~ "för vanliga aktier är det den årliga utdelningen.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#~ msgid ""
#~ "@FUNCTION=OPT_JUMP_DIFF\n"
#~ "@SYNTAX=OPT_JUMP_DIFF(call_put_flag,spot,strike,time,rate,volatility,"
#~ "lambda,gamma)\n"
#~ "@DESCRIPTION=OPT_JUMP_DIFF models the theoretical price of an option "
#~ "according to the Jump Diffusion process (Merton).\n"
#~ "@call_put_flag is 'c' or 'p' to indicate whether the option is a call or "
#~ "a put.\n"
#~ "@spot is the spot price of the underlying asset.\n"
#~ "@strike is the strike price of the option.\n"
#~ "@time is the time to maturity of the option expressed in years.\n"
#~ "@rate is the annualized rate of interest.\n"
#~ "@volatility is the annualized volatility of the underlying asset.\n"
#~ "@lambda is expected number of 'jumps' per year.\n"
#~ "@gamma is proportion of volatility explained by the 'jumps.'\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_JUMP_DIFF\n"
#~ "@SYNTAX=OPT_JUMP_DIFF(fjäril;avista;slag;tid;ränta;flyktighet;lambda;"
#~ "gamma)\n"
#~ "@DESCRIPTION=OPT_JUMP_DIFF modellerar det teoretiska priset på en option "
#~ "enligt hopp-diffusionsprocessen (Merton).\n"
#~ "@fjäril är \"c\" eller \"p\" beroende på om optionen är köp- eller "
#~ "säljoption.\n"
#~ "@avista är avistapriset för den underliggande\n"
#~ "@slag är slagpriset på optionen\n"
#~ "@tid är tiden till mognad uttryckt i år\n"
#~ "@ränta är den årliga räntan\n"
#~ "@flyktighet är den årliga flyktigheten av den underliggande tillgången\n"
#~ "@lambda är förväntat antal \"hopp\" per år\n"
#~ "@gamma är andelen av volatiliteten som förklaras av \"hoppen\"\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OPT_MILTERSEN_SCHWARTZ\n"
#~ "@SYNTAX=OPT_MILTERSEN_SCHWARTZ(call_put_flag,p_t,f_t,x,t1,t2,v_s,v_e,v_f,"
#~ "rho_se,rho_sf,rho_ef,kappa_e,kappa_f)\n"
#~ "@DESCRIPTION=OPT_MILTERSEN_SCHWARTZ models the theoretical price of "
#~ "options on commodities futures according to Miltersen & Schwartz. \n"
#~ "@call_put_flag is 'c' or 'p' to indicate whether the option is a call or "
#~ "a put.\n"
#~ "@p_t is a zero coupon bond with expiry at option maturity.\n"
#~ "@f_t is the futures price.\n"
#~ "@x is the strike price.\n"
#~ "@t1 is the time to maturity of the option.\n"
#~ "@t2 is the time to maturity of the underlying commodity futures "
#~ "contract.\n"
#~ "@v_s is the volatility of the spot commodity price.\n"
#~ "@v_e is the volatility of the future convenience yield.\n"
#~ "@v_f is the volatility of the forward rate of interest.\n"
#~ "@rho_se is correlation between the spot commodity price and the "
#~ "convenience yield.\n"
#~ "@rho_sf is correlation between the spot commodity price and the forward "
#~ "interest rate.\n"
#~ "@rho_ef is correlation between the forward interest rate and the "
#~ "convenience yield.\n"
#~ "@kappa_e is the speed of mean reversion of the convenience yield.\n"
#~ "@kappa_f is the speed of mean reversion of the forward interest rate.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_MILTERSEN_SCHWARTZ\n"
#~ "@SYNTAX=OPT_MILTERSEN_SCHWARTZ(fjäril;p_t;f_t;x;t1;t2;v_s;v_e;v_f;rho_se;"
#~ "rho_sf;rho_ef;kappa_e;kappa_f)\n"
#~ "@DESCRIPTION=OPT_MILTERSEN_SCHWARTZ modellerar det teoretiska priset på "
#~ "en option enligt Miltersen & Schwartz.\n"
#~ "@fjäril är \"c\" eller \"p\" beroende på om optionen är köp- eller "
#~ "säljoption.\n"
#~ "@p_t är en nollkupongare med lösen vid optionsmognad \n"
#~ "@f_t är framtidspriset \n"
#~ "@x är slagpriset \n"
#~ "@t1 är tid till mognad för optionen \n"
#~ "@t2 är tid till mognad för det underliggande framtidskontraktet \n"
#~ "@v_s är volatiliteten för varans pris \n"
#~ "@v_e är volatiliteten för den framtida återbäringen \n"
#~ "@v_f är volatiliteten för den framtida räntan \n"
#~ "@rho_se är korrelationen mellan varans pris och återbäringen \n"
#~ "@rho_sf är korrelationen mellan varans pris och den framtida räntan \n"
#~ "@kappa_e is the speed of mean reversion of the convenience yield \n"
#~ "@kappa_f is the speed of mean reversion of the forward interest rate \n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OPT_RGW\n"
#~ "@SYNTAX=OPT_RGW(spot,strike,t1,t2,rate,d,volatility)\n"
#~ "@DESCRIPTION=OPT_RGW models the theoretical price of an American option "
#~ "according to the Roll-Geske-Whaley approximation where: \n"
#~ "@spot is the spot price of the underlying asset.\n"
#~ "@strike is the strike price at which the option is struck.\n"
#~ "@t1 is the time to the dividend payout.\n"
#~ "@t2 is the time to option expiration.\n"
#~ "@rate is the annualized rate of interest.\n"
#~ "@d is the amount of the dividend to be paid expressed in currency.\n"
#~ "@volatility is the annualized rate of volatility of the underlying "
#~ "asset.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_RGW\n"
#~ "@SYNTAX=OPT_RGW(fjäril;avista;slag;t1;t2;ränta;d;flyktighet)\n"
#~ "@DESCRIPTION=OPT_RGW modellerar det teoretiska priset på en amerikansk "
#~ "option enligt Roll Geske Whaley approximationen där: \n"
#~ "@fjäril är \"c\" eller \"p\" beroende på om optionen är köp- eller "
#~ "säljoption.\n"
#~ "@avista är avistapriset för den underliggande tillgången.\n"
#~ "@slag är slagpriset på optionen.\n"
#~ "@t1 är tiden till utdelningen.\n"
#~ "@t2 är tiden till förfallodatumet.\n"
#~ "@ränta är den årliga räntan\n"
#~ ".@d är storleken på utdelningen.\n"
#~ "@flyktighet är den årliga flyktigheten av den underliggande tillgången.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OPT_BAW_AMER\n"
#~ "@SYNTAX=OPT_BAW_AMER(call_put_flag,spot,strike,time,rate,cost_of_carry,"
#~ "volatility)\n"
#~ "@DESCRIPTION=OPT_BAW_AMER models the theoretical price of an option "
#~ "according to the Barone Adesie & Whaley approximation. \n"
#~ "@call_put_flag is 'c' or 'p' to indicate whether the option is a call or "
#~ "a put.\n"
#~ "@spot is the spot price of the underlying asset.\n"
#~ "@strike is the strike price at which the option is struck.\n"
#~ "@time is the number of days to maturity of the option.\n"
#~ "@rate is the annualized risk-free rate of interest.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "@volatility is the annualized volatility in price of the underlying "
#~ "asset.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_BAW_AMER\n"
#~ "@SYNTAX=OPT_BAW_AMER(fjäril;avista;slag;tid;ränta;cost_of_carry;"
#~ "flyktighet)\n"
#~ "@DESCRIPTION=OPT_BAW_AMER modellerar det teoretiska priset på en option "
#~ "enligt Barone Adesie & Whaley-approximationen.\n"
#~ "@fjäril är \"c\" eller \"p\" beroende på om optionen är köp- eller "
#~ "säljoption.\n"
#~ "@avista är avistapriset för den underliggande tillgången\n"
#~ "@slag är slagpriset på optionen\n"
#~ "@tid är tiden till förfallodatumet\n"
#~ "@ränta är den riskfria årliga räntan\n"
#~ "@cost_of_carry är värdeläckaget på den underliggande tillgången, för "
#~ "vanliga aktier är det den årliga utdelningen.\n"
#~ "@flyktighet är den årliga flyktigheten av tillgången\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

# FIXME: Någon som förstår detta?
#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OPT_BJER_STENS\n"
#~ "@SYNTAX=OPT_BJER_STENS(call_put_flag,spot,strike,time,rate,volatility[,"
#~ "cost_of_carry])\n"
#~ "@DESCRIPTION=OPT_BJER_STENS models the theoretical price of American "
#~ "options according to the Bjerksund & Stensland approximation technique.\n"
#~ "@call_put_flag is 'c' or 'p' to indicate whether the option is a call or "
#~ "a put.\n"
#~ "@spot is the spot price of the underlying asset.\n"
#~ "@strike is the strike price at which the option is struck.\n"
#~ "@time is the number of days to maturity of the option.\n"
#~ "@rate is the annualized risk-free rate of interest.\n"
#~ "@volatility is the annualized volatility in price of the underlying "
#~ "asset.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_BJER_STENS\n"
#~ "@SYNTAX=OPT_BJER_STENS(fjäril;avista;slag;tid;ränta;flyktighet[;"
#~ "cost_of_carry])\n"
#~ "@DESCRIPTION=OPT_BJER_STENS modellerar det teoretiska priset på "
#~ "amerikanska optioner enligt Bjerksund & Stenslands approximationsteknik.\n"
#~ "@fjäril är \"c\" eller \"p\" beroende på om optionen är köp- eller "
#~ "säljoption.\n"
#~ "@avista är avistapriset för den underliggande tillgången.\n"
#~ "@slag är slagpriset på optionen\n"
#~ ".@tid är tiden till förfallodatumet i dagar.\n"
#~ "@ränta är den riskfria årliga räntan.\n"
#~ "@flyktighet är den årliga flyktigheten av tillgången.\n"
#~ "@cost_of_carry är värdeläckaget på den underliggande tillgången, för "
#~ "vanliga aktier är det den årliga utdelningen.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OPT_EXEC\n"
#~ "@SYNTAX=OPT_EXEC(call_put_flag,spot,strike,time,rate,volatility,"
#~ "cost_of_carry,lambda)\n"
#~ "@DESCRIPTION=OPT_EXEC models the theoretical price of executive stock "
#~ "options @call_put_flag is 'c' or 'p' to indicate whether the option is a "
#~ "call or a put.\n"
#~ "One would expect this to always be a call option.\n"
#~ "@spot is the spot price of the underlying asset.\n"
#~ "@strike is the strike price at which the option is struck.\n"
#~ "@time is the number of days to maturity of the option.\n"
#~ "@rate is the annualized risk-free rate of interest.\n"
#~ "@volatility is the annualized volatility in price of the underlying "
#~ "asset.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "@lambda is the jump rate for executives. The model assumes executives "
#~ "forfeit their options if they leave the company.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_EXEC\n"
#~ "@SYNTAX=OPT_EXEC(fjäril;avista;slag;tid;ränta;flyktighet;cost_of_carry;"
#~ "lambda)\n"
#~ "@DESCRIPTION=OPT_EXEC modellerar det teoretiska priset på "
#~ "ledningsoptioner.\n"
#~ "@fjäril är \"c\" eller \"p\" beroende på om optionen är köp- eller "
#~ "säljoption.\n"
#~ "Man kan förvänta sig att detta alltid är en köpoption.\n"
#~ "@avista är avistapriset för den underliggande tillgången.\n"
#~ "@slag är slagpriset på optionen.\n"
#~ "@tid är tiden till förfallodatumet i dagar.\n"
#~ "@ränta är den riskfria årliga räntan.\n"
#~ "@flyktighet är den årliga flyktigheten av tillgången.\n"
#~ "@cost_of_carry är värdeläckaget på den underliggande tillgången, för "
#~ "vanliga aktier är det den årliga utdelningen.\n"
#~ "@lambda är avhoppsfrekvensen för ledningen. Modellen antar att ledningen "
#~ "släpper sina optioner om dom lämnar företaget.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OPT_FORWARD_START\n"
#~ "@SYNTAX=OPT_FORWARD_START(call_put_flag,spot,alpha,time1,time,rate,"
#~ "volatility,cost_of_carry)\n"
#~ "@DESCRIPTION=OPT_FORWARD_START models the theoretical price of forward "
#~ "start options\n"
#~ " @call_put_flag is 'c' or 'p' to indicate whether the option is a call or "
#~ "a put.\n"
#~ "@spot is the spot price of the underlying asset.\n"
#~ "@alpha is a fraction that set the strike price the future date @time1.\n"
#~ "@time1 is the number of days until the option starts.\n"
#~ "@time is the number of days to maturity of the option.\n"
#~ "@rate is the annualized risk-free rate of interest.\n"
#~ "@volatility is the annualized volatility in price of the underlying "
#~ "asset.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_FORWARD_START\n"
#~ "@SYNTAX=OPT_FORWARD_START(fjäril;avista;alfa;tid1;tid;ränta;flyktighet;"
#~ "cost_of_carry)\n"
#~ "@DESCRIPTION=OPT_FORWARD_START modellerar det teoretiska priset på "
#~ "framåtvisande startoptioner.\n"
#~ "@fjäril är \"c\" eller \"p\" beroende på om optionen är köp- eller "
#~ "säljoption.\n"
#~ "@avista är avistapriset för den underliggande tillgången.\n"
#~ "@alfa är andelen som sätter slagpriset för tid @tid1.\n"
#~ "@tid1 är tiden tills optionen börjar.\n"
#~ "@tid är tiden till förfallodatumet i dagar.\n"
#~ "@ränta är den riskfria årliga räntan.\n"
#~ "@flyktighet är den årliga flyktigheten av den underliggande tillgången.\n"
#~ "@cost_of_carry är värdeläckaget på den underliggande tillgången, för "
#~ "vanliga aktier är det den årliga utdelningen.\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OPT_TIME_SWITCH\n"
#~ "@SYNTAX=OPT_TIME_SWITCH(call_put_flag,spot,strike,a,time,m,dt,rate,"
#~ "cost_of_carry,volatility)\n"
#~ "@DESCRIPTION=OPT_TIME_SWITCH models the theoretical price of time switch "
#~ "options. (Pechtl 1995)\n"
#~ "The holder receives @a * @dt for each period dt that the asset price was "
#~ "greater than the strike price (for a call) or below it (for a put). \n"
#~ "@call_put_flag is 'c' or 'p' to indicate whether the option is a call or "
#~ "a put.\n"
#~ "@spot is the spot price of the underlying asset.\n"
#~ "@strike is the strike price at which the option is struck.\n"
#~ "@a is the amount received for each time period as discussed above.\n"
#~ "@time is the maturity of the option in years.\n"
#~ "@m is the number of time units the option has already met the condition.\n"
#~ "@dt is the agreed upon discrete time period (often a day) expressed as a "
#~ "fraction of a year.\n"
#~ "@rate is the annualized risk-free rate of interest.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_TIME_SWITCH\n"
#~ "@SYNTAX=OPT_TIME_SWITCH(fjäril;avista;slag;a;tid;m;dt;ränta;cost_of_carry;"
#~ "flyktighet)\n"
#~ "@DESCRIPTION=OPT_TIME_SWITCH modellerar det teoretiska priset på "
#~ "tidsbytesoptioner (Pechtl 1995).\n"
#~ "Ägaren får @a * @dt för varje period @dt som tillgångens pris var högre "
#~ "än slagpriset (för köp) eller under (för sälj). \n"
#~ "@fjäril är \"c\" eller \"p\" beroende på om optionen är köp- eller "
#~ "säljoption.\n"
#~ "@avista är avistapriset för den underliggande tillgången.\n"
#~ "@slag är slagpriset på optionen.\n"
#~ "@a är den erhållna summan för varje period enligt ovan.\n"
#~ "@tid är tiden till förfallodatumet i år.\n"
#~ "@m är antalet didsenheter som optionen redan har uppfyllt vilkoren.\n"
#~ "@dt är den överenskomna tidsperioden (ofta en dag) uttryckt som andel av "
#~ "ett år.\n"
#~ "@ränta är den riskfria årliga räntan.\n"
#~ "@flyktighet är den årliga flyktigheten av tillgången\n"
#~ "@cost_of_carry är värdeläckaget på den underliggande tillgången, för "
#~ "vanliga aktier är det den årliga utdelningen.\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OPT_SIMPLE_CHOOSER\n"
#~ "@SYNTAX=OPT_SIMPLE_CHOOSER(call_put_flag,spot,strike,time1,time2,rate,"
#~ "cost_of_carry,volatility)\n"
#~ "@DESCRIPTION=OPT_SIMPLE_CHOOSER models the theoretical price of simple "
#~ "chooser options.\n"
#~ "@call_put_flag is 'c' or 'p' to indicate whether the option is a call or "
#~ "a put.\n"
#~ "@spot is the spot price of the underlying asset.\n"
#~ "@strike is the strike price at which the option is struck.\n"
#~ "@time1 is the time in years until the holder chooses a put or a call "
#~ "option.\n"
#~ "@time2 is the time in years until the chosen option expires.\n"
#~ "@rate is the annualized risk-free rate of interest.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_SIMPLE_CHOOSER\n"
#~ "@SYNTAX=OPT_SIMPLE_CHOOSER(fjäril;avista;slag;tid1;tid2;ränta;"
#~ "cost_of_carry;flyktighet)\n"
#~ "@DESCRIPTION=OPT_SIMPLE_CHOOSER modellerar det teoretiska priset på enkla "
#~ "valoptioner.\n"
#~ "@fjäril är \"c\" eller \"p\" beroende på om optionen är köp- eller "
#~ "säljoption.\n"
#~ "@avista är avistapriset för den underliggande tillgången.\n"
#~ "@slag är slagpriset på optionen.\n"
#~ "@tid1 är tiden tills ägaren väljer en köp- eller säljoption angivet i "
#~ "år.\n"
#~ "@tid2 är tiden till förfallodatumet angivet i år.\n"
#~ "@ränta är den riskfria årliga räntan.\n"
#~ "@cost_of_carry är värdeläckaget på den underliggande tillgången, för "
#~ "vanliga aktier är det den årliga utdelningen.\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OPT_COMPLEX_CHOOSER\n"
#~ "@SYNTAX=OPT_COMPLEX_CHOOSER(call_put_flag,spot,strike_call,strike_put,"
#~ "time,time_call,time_put,rate,cost_of_carry,volatility)\n"
#~ "@DESCRIPTION=OPT_COMPLEX_CHOOSER models the theoretical price of complex "
#~ "chooser options.\n"
#~ "@call_put_flag is 'c' or 'p' to indicate whether the option is a call or "
#~ "a put.\n"
#~ "@spot is the spot price of the underlying asset.\n"
#~ "@strike_call is the strike price at which the option is struck, "
#~ "applicable if exercised as a call option.\n"
#~ "@strike_put is the strike price at which the option is struck, applicable "
#~ "if exercised as a put option.\n"
#~ "@time is the time in years until the holder chooses a put or a call "
#~ "option. \n"
#~ "@time_call is the time in years to maturity of the call option if "
#~ "chosen.\n"
#~ "@time_put is the time in years  to maturity of the put option if chosen.\n"
#~ "@rate is the annualized risk-free rate of interest.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "@volatility is the annualized volatility in price of the underlying "
#~ "asset.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_COMPLEX_CHOOSER\n"
#~ "@SYNTAX=OPT_COMPLEX_CHOOSER(fjäril;avista;slag_köp;slag_sälj;tid;tid_köp;"
#~ "tid_sälj;ränta;cost_of_carry;flyktighet)\n"
#~ "@DESCRIPTION=OPT_COMPLEX_CHOOSER modellerar det teoretiska priset på "
#~ "komplexa valoptioner.\n"
#~ "@fjäril är \"c\" eller \"p\" beroende på om optionen är köp- eller "
#~ "säljoption.\n"
#~ "@avista är avistapriset för den underliggande tillgången.\n"
#~ "@slag_köp är slagpriset på optionen; giltigt om den används som "
#~ "köpoption.\n"
#~ "@slag_sälj är slagpriset på optionen; giltigt om den används som "
#~ "säljoption.\n"
#~ "@tid är tiden tills ägaren väljer en köp- eller säljoption i år.\n"
#~ "@tid_köp är tiden till förfallodatumet,angivet i år, om vald som "
#~ "köpoption.\n"
#~ "@tid_sälj är tiden till förfallodatumet, angivet i år, om vald som "
#~ "säljoption.\n"
#~ "@ränta är den riskfria årliga räntan.\n"
#~ "@cost_of_carry är värdeläckaget på den underliggande tillgången, för "
#~ "vanliga aktier är det den årliga utdelningen.\n"
#~ "@flyktighet är den årliga flyktigheten av den underliggande tillgången.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OPT_ON_OPTIONS\n"
#~ "@SYNTAX=OPT_ON_OPTIONS(type_flag,spot,strike1,strike2,time1,time2,rate,"
#~ "cost_of_carry,volatility)\n"
#~ "@DESCRIPTION=OPT_ON_OPTIONS models the theoretical price of options on "
#~ "options.\n"
#~ "@type_flag is 'cc' for calls on calls, 'cp' for calls on puts, and so on "
#~ "for 'pc', and 'pp'.\n"
#~ "@spot is the spot price of the underlying asset.\n"
#~ "@strike1 is the strike price at which the option being valued is struck.\n"
#~ "@strike2 is the strike price at which the underlying option is struck.\n"
#~ "@time1 is the time in years to maturity of the option.\n"
#~ "@time2 is the time in years to the maturity of the underlying option.\n"
#~ "(@time2 >= @time1).\n"
#~ "@rate is the annualized risk-free rate of interest.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset of the "
#~ "underlying option.for common stocks, this would be the dividend yield.\n"
#~ "@volatility is the annualized volatility in price of the underlying asset "
#~ "of the underlying option.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_ON_OPTIONS\n"
#~ "@SYNTAX=OPT_ON_OPTIONS(typflagga;avista;slag1;slag2;tid1;tid2;ränta;"
#~ "cost_of_carry;flyktighet)\n"
#~ "@DESCRIPTION=OPT_ON_OPTIONS modellerar det teoretiska priset på optioner "
#~ "på optioner.\n"
#~ "@typflagga är \"cc\" för köp på köp, \"cp\" för sälj på köp och så vidare "
#~ "för \"pc\" och \"pp\".\n"
#~ "@avista är avistapriset för den underliggande tillgången.\n"
#~ "@slag1 är slagpriset på optionen som värderas.\n"
#~ "@slag2 är slagpriset på den underliggande optionen.\n"
#~ "@tid1 är tiden till förfallodatumet i år på optionen.\n"
#~ "@tid2 är tiden till förfallodatumet i år på den underliggande optionen.\n"
#~ "(@tid2 >= @tid1).\n"
#~ "@ränta är den riskfria årliga räntan.\n"
#~ "@cost_of_carry är värdeläckaget på den underliggande tillgången på den "
#~ "underliggande optionen, för vanliga aktier är det den årliga "
#~ "utdelningen.\n"
#~ "@flyktighet är den årliga flyktigheten av priset på den underliggande "
#~ "tillgången på den underliggande optionen\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OPT_EXTENDIBLE_WRITER\n"
#~ "@SYNTAX=OPT_EXTENDIBLE_WRITER(call_put_flag,spot,strike1,strike2,time1,"
#~ "time2,rate,cost_of_carry,volatility)\n"
#~ "@DESCRIPTION=OPT_EXTENDIBLE_WRITER models the theoretical price of "
#~ "extendible writer options. These are options that can be exercised at an "
#~ "initial period, @time1, or their maturity extended to @time2 if the "
#~ "option is out of the money at @time1.\n"
#~ "@call_put_flag is 'c' or 'p' to indicate whether the option is a call or "
#~ "a put.\n"
#~ "@spot is the spot price of the underlying asset.\n"
#~ "@strike1 is the strike price at which the option is struck.\n"
#~ "@strike2 is the strike price at which the option is re-struck if out of "
#~ "the money at @time1.\n"
#~ "@time1 is the initial maturity of the option in years.\n"
#~ "@time2 is the is the extended maturity in years if chosen.\n"
#~ "@rate is the annualized risk-free rate of interest.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "@volatility is the annualized volatility in price of the underlying "
#~ "asset.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_EXTENDIBLE_WRITER\n"
#~ "@SYNTAX=OPT_EXTENDIBLE_WRITER(fjäril;avista;slag1;slag2;tid1;tid2;ränta;"
#~ "cost_of_carry;flyktighet)\n"
#~ "@DESCRIPTION=OPT_EXTENDIBLE_WRITER modellerar det teoretiska priset på "
#~ "utökningsbara utgivaroptioner. Detta är optioner som kan lösas in vid en "
#~ "tidigare tidpunkt @tid1 eller utöka inlösentiden till @tid2 om optionen "
#~ "inte är värd någonting vid @tid1.\n"
#~ "@fjäril är \"c\" eller \"p\" beroende på om optionen är köp- eller "
#~ "säljoption.\n"
#~ "@avista är avistapriset för den underliggande tillgången.\n"
#~ "@slag1 är slagpriset på optionen.\n"
#~ "@slag2 är slagpriset då optionen slås igen om det inte finns pengar kvar "
#~ "vid @tid1.\n"
#~ "@tid1 är tiden till förfallodatumet i år på första inlösentiden.\n"
#~ "@tid2 är tiden till förfallodatumet i år på den utökade inlösentiden om "
#~ "vald.\n"
#~ "@ränta är den riskfria årliga räntan.\n"
#~ "@cost_of_carry är värdeläckaget på den underliggande tillgången, för "
#~ "vanliga aktier är det den årliga utdelningen.\n"
#~ "@flyktighet är den årliga flyktigheten av priset på den underliggande "
#~ "tillgången.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OPT_2_ASSET_CORRELATION\n"
#~ "@SYNTAX=OPT_2_ASSET_CORRELATION(call_put_flag,spot1,spot2,strike1,strike2,"
#~ "time,cost_of_carry1,cost_of_carry2,rate,volatility1,volatility2,rho)\n"
#~ "@DESCRIPTION=OPT_2_ASSET_CORRELATION models the theoretical price of  "
#~ "options on 2 assets with correlation @rho.\n"
#~ "The payoff for a call is max(@spot2 - @strike2,0) if @spot1 > @strike1 or "
#~ "0 otherwise.\n"
#~ "The payoff for a put is max (@strike2 - @spot2, 0) if @spot1 < @strike1 "
#~ "or 0 otherwise.\n"
#~ "@call_put_flag is 'c' or 'p' to indicate whether the option is a call or "
#~ "a put.\n"
#~ "@spot1 & @spot2 are the spot prices of the underlying assets.\n"
#~ "@strike1 & @strike2 are the strike prices at which the option is struck.\n"
#~ "@time is the initial maturity of the option in years.\n"
#~ "@rate is the annualized risk-free rate of interest.\n"
#~ "@cost_of_carry1 & @cost_of_carry2 are the leakage in value of the "
#~ "underlying assets, for common stocks, this would be the dividend yield.\n"
#~ "@volatility1 & @volatility2 are the annualized volatility in price of the "
#~ "underlying assets.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_2_ASSET_CORRELATION\n"
#~ "@SYNTAX=OPT_2_ASSET_CORRELATION(fjäril;avista1;avista2;slag1;slag2;tid;"
#~ "cost_of_carry1;cost_of_carry2;ränta;flyktighet1;flyktighet2;rho)\n"
#~ "@DESCRIPTION=OPT_2_ASSET_CORRELATION modellerar det teoretiska priset på "
#~ "optioner med två tillgångar med korrelation @rho.\n"
#~ "Utbetalninen för ett köp är max (@avista2 - @slag2; 0) om @avista1 > "
#~ "@slag1, annars 0.\n"
#~ " Utbetalninen för sälj är max (@slag2 - @avista2; 0) om @avista1 < "
#~ "@slag1, annars 0.\n"
#~ " @fjäril är \"c\" eller \"p\" beroende på om optionen är köp- eller "
#~ "säljoption.\n"
#~ "@avista1 och @avista2 är avistapriserna för de underliggande "
#~ "tillgångarna.\n"
#~ "@slag1 och @slag2 är slagpriserna på optionen.\n"
#~ "@tid är tiden till förfallodatumet i år.\n"
#~ "@ränta är den riskfria årliga räntan.\n"
#~ "@cost_of_carry1 och @cost_of_carry2 är värdeläckaget på de underliggande "
#~ "tillgångarna; för vanliga aktier är det den årliga utdelningen.\n"
#~ "@flyktighet1 och @flyktighet2 är den årliga flyktigheten av "
#~ "tillgångarna.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OPT_EURO_EXCHANGE\n"
#~ "@SYNTAX=OPT_EURO_EXCHANGE(spot1,spot2,qty1,qty2,time,rate,cost_of_carry1,"
#~ "cost_of_carry2,volatility1,volatility2,rho)\n"
#~ "@DESCRIPTION=OPT_EURO_EXCHANGE models the theoretical price of a European "
#~ "option to exchange one asset with quantity @qty2 and spot price @spot2 "
#~ "for another, with quantity @qty1 and spot price @spot1.\n"
#~ "@time is the initial maturity of the option in years.\n"
#~ "@rate is the annualized risk-free rate of interest.\n"
#~ "@cost_of_carry1 & @cost_of_carry2 are the leakage in value of the "
#~ "underlying assets, for common stocks, this would be the dividend yield.\n"
#~ "@volatility1 & @volatility2 are the annualized volatility in price of the "
#~ "underlying assets.\n"
#~ "@rho is the correlation between the two assets.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_AMER_EXCHANGE, OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, "
#~ "OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_EURO_EXCHANGE\n"
#~ "@SYNTAX=OPT_EURO_EXCHANGE(avista1;avista2;kvant1;kvant2;tid;ränta;"
#~ "cost_of_carry1;cost_of_carry2;flyktighet1;flyktighet2;rho)\n"
#~ "@DESCRIPTION=OPT_EURO_EXCHANGE modellerar det teoretiska priset på en "
#~ "Europeisk option att växla en tillgång med kvantitet @kvant2 och avista "
#~ "@avista2 för en annan, med kvantitet @kvant1 och avista @avista1.\n"
#~ "@tid är tiden till förfallodatumet i år.\n"
#~ "@ränta är den riskfria årliga räntan.\n"
#~ "@cost_of_carry1 och @cost_of_carry2 är värdeläckaget på de underliggande "
#~ "tillgångarna; för vanliga aktier är det den årliga utdelningen.\n"
#~ "@flyktighet1 och @flyktighet2 är den årliga flyktigheten i priset av de "
#~ "underliggande tillgångarna.\n"
#~ "@rho är korrelationen mellan de två tillgångarna.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_AMER_EXCHANGE, OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, "
#~ "OPT_BS_THETA, OPT_BS_GAMMA"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OPT_AMER_EXCHANGE\n"
#~ "@SYNTAX=OPT_AMER_EXCHANGE(spot1,spot2,qty1,qty2,time,rate,cost_of_carry1,"
#~ "cost_of_carry2,volatility1, volatility2, rho)\n"
#~ "@DESCRIPTION=OPT_AMER_EXCHANGE models the theoretical price of an "
#~ "American option to exchange one asset with quantity @qty2 and spot price "
#~ "@spot2 for another, with quantity @qty1 and spot price @spot1.\n"
#~ "@time is the initial maturity of the option in years.\n"
#~ "@rate is the annualized risk-free rate of interest.\n"
#~ "@cost_of_carry1 & @cost_of_carry2 are the leakage in value of the "
#~ "underlying assets, for common stocks, this would be the dividend yield.\n"
#~ "@volatility1 & @volatility2 are the annualized volatility in price of the "
#~ "underlying assets.\n"
#~ "@rho is the correlation between the two assets.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_EURO_EXCHANGE, OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, "
#~ "OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_AMER_EXCHANGE\n"
#~ "@SYNTAX=OPT_AMER_EXCHANGE(avista1;avista2;kvant1;kvant2;tid;ränta;"
#~ "cost_of_carry1;cost_of_carry2;flyktighet1;flyktighet2;rho)\n"
#~ "@DESCRIPTION=OPT_AMER_EXCHANGE modellerar det teoretiska priset på en "
#~ "amerikansk option att växla en tillgång med kvantitet @kvant2 och avista "
#~ "@avista2 för en annan, med kvantitet @kvant1 och avista @avista1.\n"
#~ "@tid är tiden till förfallodatumet i år.\n"
#~ "@ränta är den riskfria årliga räntan.\n"
#~ "@cost_of_carry1 och @cost_of_carry2 är värdeläckaget på de underliggande "
#~ "tillgångarna; för vanliga aktier är det den årliga utdelningen.\n"
#~ "@flyktighet1 och @flyktighet2 är den årliga flyktigheten i priset av de "
#~ "underliggande tillgångarna.\n"
#~ "@rho är korrelationen mellan de två tillgångarna.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_EURO_EXCHANGE, OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, "
#~ "OPT_BS_THETA, OPT_BS_GAMMA"

# FIXME: Någon som förstår detta?
#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OPT_SPREAD_APPROX\n"
#~ "@SYNTAX=OPT_SPREAD_APPROX(call_put_flag,fut_price1,fut_price2,strike,"
#~ "time, rate,volatility1,volatility2,rho)\n"
#~ "@DESCRIPTION=OPT_SPREAD_APPROX models the theoretical price of a European "
#~ "option on the spread between two futures contracts.\n"
#~ "@call_put_flag is 'c' or 'p' to indicate whether the option is a call or "
#~ "a put.\n"
#~ "@fut_price1 & @fut_price2 are the prices of the two futures contracts.\n"
#~ "@strike is the strike price at which the option is struck \n"
#~ "@time is the initial maturity of the option in years.\n"
#~ "@rate is the annualized risk-free rate of interest.\n"
#~ "@volatility1 & @volatility2 are the annualized volatility in price of the "
#~ "underlying futures contracts.\n"
#~ "@rho is the correlation between the two futures contracts.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_SPREAD_APPROX\n"
#~ "@SYNTAX=OPT_SPREAD_APPROX(fjäril;frampris1;frampris2;slag;tid;ränta;"
#~ "flyktighet1;flyktighet2;rho)\n"
#~ "@DESCRIPTION=OPT_SPREAD_APPROX modellerar det teoretiska priset på "
#~ "teoretiska priset på en europeisk option på spridningen mellan två "
#~ "framtidskontrakt.\n"
#~ "@fjäril är \"c\" eller \"p\" beroende på om optionen är köp- eller "
#~ "säljoption.\n"
#~ "@frampris1 och @frampris2 är priserna på framtidskontrakten.\n"
#~ "@slag är slagpriset på optionen.\n"
#~ "@tid är tiden till förfallodatumet i dagar.\n"
#~ "@ränta är den riskfria årliga räntan.\n"
#~ "@flyktighet1 och @flyktighet2 är den årliga flyktigheten av de "
#~ "underliggande kontrakten.\n"
#~ "@rho är korrelationen mellan de två kontrakten.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OPT_FLOAT_STRK_LKBK\n"
#~ "@SYNTAX=OPT_FLOAT_STRK_LKBK(call_put_flag,spot,spot_min,spot_max,time,"
#~ "rate,cost_of_carry,volatility)\n"
#~ "@DESCRIPTION=OPT_FLOAT_STRK_LKBK models the theoretical price of an "
#~ "option where the holder of the option may exercise on expiry at the most "
#~ "favourable price observed during the options life of the underlying "
#~ "asset.\n"
#~ "@call_put_flag is 'c' or 'p' to indicate whether the option is a call or "
#~ "a put.\n"
#~ "@spot is the spot price of the underlying asset.\n"
#~ "@spot_min is the minimum spot price of the underlying asset so far "
#~ "observed.\n"
#~ "@spot_max is the maximum spot price of the underlying asset so far "
#~ "observed.\n"
#~ "@time is the initial maturity of the option in years.\n"
#~ "@rate is the annualized risk-free rate of interest.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "@volatility is the annualized volatility in price of the underlying "
#~ "asset.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_FLOAT_STRK_LKBK\n"
#~ "@SYNTAX=OPT_FLOAT_STRK_LKBK(fjäril;avista;avista_min;avista_max;tid;ränta;"
#~ "cost_of_carry;flyktighet)\n"
#~ "@DESCRIPTION=OPT_FLOAT_STRK_LKBK modellerar det teoretiska priset på en "
#~ "option där optionens ägare kan nyttja den vid förfallodatumet till det "
#~ "mest fördelaktiga priset på den underliggande tillgången som observerats "
#~ "under optionens livstid.\n"
#~ "@fjäril är \"c\" eller \"p\" beroende på om optionen är köp- eller "
#~ "säljoption.\n"
#~ "@avista är avistapriset för den underliggande tillgången.\n"
#~ "@avista_min är det lägsta avistapriset för den underliggande tillgången "
#~ "som hittills observerats.\n"
#~ "@avista_max är det högsta avistapriset för den underliggande tillgången "
#~ "som hittills observerats.\n"
#~ "@tid är tiden till förfallodatumet.\n"
#~ "@ränta är den riskfria årliga räntan.\n"
#~ "@cost_of_carry är värdeläckaget på den underliggande tillgången, för "
#~ "vanliga aktier är det den årliga utdelningen.\n"
#~ "@flyktighet är den årliga flyktigheten av tillgången.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

# "en option" saknades i orginaltexten
#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OPT_FIXED_STRK_LKBK\n"
#~ "@SYNTAX=OPT_FIXED_STRK_LKBK(call_put_flag,spot,spot_min,spot_max,strike,"
#~ "time,rate,cost_of_carry,volatility)\n"
#~ "@DESCRIPTION=OPT_FIXED_STRK_LKBK models the theoretical price of an "
#~ "option where the holder of the option may exercise on expiry at the most "
#~ "favourable price observed during the options life of the underlying "
#~ "asset.\n"
#~ "@call_put_flag is 'c' or 'p' to indicate whether the option is a call or "
#~ "a put.\n"
#~ "@spot is the spot price of the underlying asset.\n"
#~ "@spot_min is the minimum spot price of the underlying asset so far "
#~ "observed.\n"
#~ "@spot_max is the maximum spot price of the underlying asset so far "
#~ "observed.\n"
#~ "@strike is the strike prices at which the option is struck.\n"
#~ "@time is the initial maturity of the option in years.\n"
#~ "@rate is the annualized risk-free rate of interest.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "@volatility is the annualized volatility in price of the underlying "
#~ "asset.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_FIXED_STRK_LKBK\n"
#~ "@SYNTAX=OPT_FIXED_STRK_LKBK(fjäril;avista;avista_min;avista_max;slag;tid;"
#~ "ränta;cost_of_carry;flyktighet)\n"
#~ "@DESCRIPTION=OPT_FIXED_STRK_LKBK modellerar det teoretiska priset på en "
#~ "option där optionens ägare kan nyttja den vid förfallodatumet till det "
#~ "mest fördelaktiga priset på den underliggande tillgången som observerats "
#~ "under optionens livstid.\n"
#~ "@fjäril är \"c\" eller \"p\" beroende på om optionen är köp- eller "
#~ "säljoption.\n"
#~ "@avista är avistapriset för den underliggande tillgången.\n"
#~ "@avista_min är det lägsta avistapriset för den underliggande tillgången "
#~ "som hittills observerats.\n"
#~ "@avista_max är det högsta avistapriset för den underliggande tillgången "
#~ "som hittills observerats.\n"
#~ "@tid är tiden till förfallodatumet.\n"
#~ "@ränta är den riskfria årliga räntan.\n"
#~ "@cost_of_carry är värdeläckaget på den underliggande tillgången, för "
#~ "vanliga aktier är det den årliga utdelningen.\n"
#~ "@flyktighet är den årliga flyktigheten av tillgången.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

# FIXME: Någon som förstår detta?
#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OPT_BINOMIAL\n"
#~ "@SYNTAX=OPT_BINOMIAL(amer_euro_flag,call_put_flag,num_time_steps, spot, "
#~ "strike, time, rate, volatility, cost_of_carry)\n"
#~ "@DESCRIPTION=OPT_ models the theoretical price of either an American or "
#~ "European style option using a binomial tree.\n"
#~ "@amer_euro_flag is either 'a' or 'e' to indicate whether the option being "
#~ "valued is an American or European style option respectively.\n"
#~ "@call_put_flag is 'c' or 'p' to indicate whether the option is a call or "
#~ "a put.\n"
#~ "@num_time_steps is the number of time steps used in the valuation, a "
#~ "greater number of time steps yields greater accuracy however is slower to "
#~ "calculate.\n"
#~ "@spot is the spot price of the underlying asset.\n"
#~ "@strike is the strike price at which the option is struck.\n"
#~ "@time is the initial maturity of the option in years.\n"
#~ "@rate is the annualized risk-free rate of interest.\n"
#~ "@volatility is the annualized volatility in price of the underlying "
#~ "asset.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_BINOMIAL\n"
#~ "@SYNTAX=OPT_BINOMIAL(amer_euro_flag;fjäril;tidssteg;avista;slag;tid;ränta;"
#~ "flyktighet;cost_of_carry)\n"
#~ "@DESCRIPTION=OPT_BINOMIAL modellerar det teoretiska priset på antingen en "
#~ "amerikansk eller europeisk option med hjälp av ett binomialträd.\n"
#~ "@amer_euro_flag är antingen \"a\" eller \"e\" för att indikera om "
#~ "optionen är amerikansk eller europeisk.\n"
#~ "@fjäril är \"c\" eller \"p\" beroende på om optionen är köp- eller "
#~ "säljoption.\n"
#~ "@tidssteg är antalet steg i värderingen; ett större antal leder till "
#~ "bättre noggrannhet, men tar längre tid att beräkna.\n"
#~ "@avista är avistapriset för den underliggande tillgången.\n"
#~ "@slag är slagpriset på optionen.\n"
#~ "@tid är tiden till förfallodatumet angivet i år.\n"
#~ "@ränta är den riskfria årliga räntan.\n"
#~ "@flyktighet är den årliga flyktigheten av den underliggande tillgången.\n"
#~ "@cost_of_carry är värdeläckaget på den underliggande tillgången, för "
#~ "vanliga aktier är det den årliga utdelningen.\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#~ msgid ""
#~ "@FUNCTION=COMPLEX\n"
#~ "@SYNTAX=COMPLEX(real,im[,suffix])\n"
#~ "@DESCRIPTION=COMPLEX returns a complex number of the form x + yi.\n"
#~ "\n"
#~ "@real is the real and @im is the imaginary part of the complex number.  "
#~ "@suffix is the suffix for the imaginary part.  If it is omitted, COMPLEX "
#~ "uses 'i' by default.\n"
#~ "\n"
#~ "* If @suffix is neither 'i' nor 'j', COMPLEX returns #VALUE! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COMPLEX(1,-1) equals 1-i.\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=COMPLEX\n"
#~ "@SYNTAX=COMPLEX(real;im[;suffix])\n"
#~ "@DESCRIPTION=COMPLEX returnerar ett komplext tal på formen x + yi.\n"
#~ "@real är realdelen och @im är imaginärdelen.  @suffix är suffixet som ska "
#~ "användas för imaginärdelen.  Om det inte anges används \"i\".\n"
#~ "\n"
#~ "* Om @suffix varken är \"i\" eller \"j\", returneras felvärdet #VÄRDE!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COMPLEX(1,-1) är lika med 1-i.\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=IMAGINARY\n"
#~ "@SYNTAX=IMAGINARY(inumber)\n"
#~ "@DESCRIPTION=IMAGINARY returns the imaginary part of a complex number.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMAGINARY returns #VALUE! "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMAGINARY(\"132-j\") equals -1.\n"
#~ "\n"
#~ "@SEEALSO=IMREAL"
#~ msgstr ""
#~ "@FUNCTION=IMAGINARY\n"
#~ "@SYNTAX=IMAGINARY(ital)\n"
#~ "@DESCRIPTION=IMAGINARY returnerar imaginärdelen av ett komplext tal.\n"
#~ "\n"
#~ "* Om @ital ej är ett godkänt komplext tal, returneras felvärdet #VÄRDE!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMAGINARY(\"132-j\") är lika med -1.\n"
#~ "\n"
#~ "@SEEALSO=IMREAL"

#~ msgid ""
#~ "@FUNCTION=IMABS\n"
#~ "@SYNTAX=IMABS(inumber)\n"
#~ "@DESCRIPTION=IMABS returns the absolute value of a complex number.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMABS returns #VALUE! "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMABS(\"2-j\") equals 2.23606798.\n"
#~ "\n"
#~ "@SEEALSO=IMAGINARY,IMREAL"
#~ msgstr ""
#~ "@FUNCTION=IMABS\n"
#~ "@SYNTAX=IMABS(ital)\n"
#~ "@DESCRIPTION=IMABS returnerar absolutbeloppet av ett komplext tal.\n"
#~ "\n"
#~ "* Om @ital ej är ett godkänt komplext tal, returneras felvärdet #VÄRDE!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMABS(\"2-j\") är lika med 2,23606798.\n"
#~ "\n"
#~ "@SEEALSO=IMAGINARY,IMREAL"

#~ msgid ""
#~ "@FUNCTION=IMREAL\n"
#~ "@SYNTAX=IMREAL(inumber)\n"
#~ "@DESCRIPTION=IMREAL returns the real part of a complex number.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMREAL returns #VALUE! "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "imreal(\"132-j\") equals 132.\n"
#~ "\n"
#~ "@SEEALSO=IMAGINARY"
#~ msgstr ""
#~ "@FUNCTION=IMREAL\n"
#~ "@SYNTAX=IMREAL(ital)\n"
#~ "@DESCRIPTION=IMREAL returnerar realdelen av ett komplext tal.\n"
#~ "\n"
#~ "* Om @ital ej är ett godkänt komplext tal, returneras felvärdet #VÄRDE!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "imreal(\"132-j\") är lika med 132.\n"
#~ "\n"
#~ "@SEEALSO=IMAGINARY"

#~ msgid ""
#~ "@FUNCTION=IMCONJUGATE\n"
#~ "@SYNTAX=IMCONJUGATE(inumber)\n"
#~ "@DESCRIPTION=IMCONJUGATE returns the complex conjugate of a complex "
#~ "number.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMCONJUGATE returns #VALUE! "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMCONJUGATE(\"1-j\") equals 1+j.\n"
#~ "\n"
#~ "@SEEALSO=IMAGINARY,IMREAL"
#~ msgstr ""
#~ "@FUNCTION=IMCONJUGATE\n"
#~ "@SYNTAX=IMCONJUGATE(ital)\n"
#~ "@DESCRIPTION=IMCONJUGATE returnerar komplexkonjugatet för ett komplext "
#~ "tal.\n"
#~ "\n"
#~ "* Om @ital ej är ett godkänt komplext tal, returneras felvärdet #VÄRDE!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "@EXAMPLES=\n"
#~ "IMCONJUGATE(\"1-j\") är lika med 1+j.\n"
#~ "\n"
#~ "@SEEALSO=IMAGINARY,IMREAL"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=IMINV\n"
#~ "@SYNTAX=IMINV(inumber)\n"
#~ "@DESCRIPTION=IMINV returns the inverse, or reciprocal, of the complex "
#~ "number z (@inumber), where\n"
#~ "\n"
#~ "\t1/z = (x - i y)/(x^2 + y^2).\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMINV returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMINV(\"1-j\") equals 0.5+0.5j.\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=IMINV\n"
#~ "@SYNTAX=IMINV(ital)\n"
#~ "@DESCRIPTION=IMINV returnerar inversen, eller reciproken, av det komplexa "
#~ "talet z (@ital), där\n"
#~ "\n"
#~ "\t1/z = (x - i y)/(x² + y²).\n"
#~ "\n"
#~ "* Om @ital ej är ett godkänt komplext tal, returneras felvärdet #VÄRDE!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMINV(\"1-j\") är lika med 0,5+0,5j.\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=IMNEG\n"
#~ "@SYNTAX=IMNEG(inumber)\n"
#~ "@DESCRIPTION=IMNEG returns the negative of the complex number z "
#~ "(@inumber), where\n"
#~ "\n"
#~ "\t-z = (-x) + i(-y).\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMNEG returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMNEG(\"1-j\") equals -1+j.\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=IMNEG\n"
#~ "@SYNTAX=IMEXP(ital)\n"
#~ "@DESCRIPTION=IMNEG returnerar det negativa av det komplexa talet z "
#~ "(@ital), där\n"
#~ "\n"
#~ "\t-z = (-x) + i(-y).\n"
#~ "\n"
#~ "* Om @ital ej är ett godkänt komplext tal, returneras felvärdet #VÄRDE!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMNEG(\"1-j\") är lika med -1+j.\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=IMCOS\n"
#~ "@SYNTAX=IMCOS(inumber)\n"
#~ "@DESCRIPTION=IMCOS returns the cosine of a complex number.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMCOS returns #VALUE! "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMCOS(\"1+j\") equals 0.833730-0.988898j.\n"
#~ "\n"
#~ "@SEEALSO=IMSIN,IMTAN"
#~ msgstr ""
#~ "@FUNCTION=IMCOS\n"
#~ "@SYNTAX=IMCOS(ital)\n"
#~ "@DESCRIPTION=IMCOS returnerar cosinus för ett komplext tal.\n"
#~ "\n"
#~ "* Om @ital ej är ett godkänt komplext tal, returneras felvärdet #VÄRDE!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMCOS(\"1+j\") är lika med 0,833730-0,988898j.\n"
#~ "\n"
#~ "@SEEALSO=IMSIN,IMTAN"

#~ msgid ""
#~ "@FUNCTION=IMTAN\n"
#~ "@SYNTAX=IMTAN(inumber)\n"
#~ "@DESCRIPTION=IMTAN returns the tangent of a complex number.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMTAN returns #VALUE! "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMTAN(\"2-j\") equals -0.2434582-1.1667363j.\n"
#~ "\n"
#~ "@SEEALSO=IMSIN,IMCOS"
#~ msgstr ""
#~ "@FUNCTION=IMTAN\n"
#~ "@SYNTAX=IMTAN(ital)\n"
#~ "@DESCRIPTION=IMTAN returnerar tangens för ett komplext tal.\n"
#~ "\n"
#~ "* Om @ital ej är ett godkänt komplext tal, returneras felvärdet #VÄRDE!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMTAN(\"2-j\") är lika med -0,2434582-1,1667363j.\n"
#~ "\n"
#~ "@SEEALSO=IMSIN,IMCOS"

#~ msgid ""
#~ "@FUNCTION=IMSEC\n"
#~ "@SYNTAX=IMSEC(inumber)\n"
#~ "@DESCRIPTION=IMSEC returns the complex secant of the complex number z "
#~ "(@inumber), where\n"
#~ "\n"
#~ "\tsec(z) = 1/cos(z).\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMSEC returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMSEC(\"2-j\") equals -0.413149-0.687527j.\n"
#~ "\n"
#~ "@SEEALSO=IMCSC,IMCOT"
#~ msgstr ""
#~ "@FUNCTION=IMSEC\n"
#~ "@SYNTAX=IMSEC(ital)\n"
#~ "@DESCRIPTION=IMSEC returnerar komplexa sekanten för komplexa talet z "
#~ "(@ital), där\n"
#~ "\n"
#~ "\tsec(z) = 1/cos(z).\n"
#~ "\n"
#~ "* Om @ital ej är ett godkänt komplext tal, returneras felvärdet #VÄRDE!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMSEC(\"2-j\") är lika med -0,413149-0,687527j.\n"
#~ "\n"
#~ "@SEEALSO=IMCSC,IMCOT"

#~ msgid ""
#~ "@FUNCTION=IMCSC\n"
#~ "@SYNTAX=IMCSC(inumber)\n"
#~ "@DESCRIPTION=IMCSC returns the complex cosecant of the complex number z "
#~ "(@inumber), where\n"
#~ "\n"
#~ "\tcsc(z) = 1/sin(z).\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMCSC returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMCSC(\"2-j\") equals 0.635494-0.221501j.\n"
#~ "\n"
#~ "@SEEALSO=IMSEC,IMCOT"
#~ msgstr ""
#~ "@FUNCTION=IMCSC\n"
#~ "@SYNTAX=IMCSC(ital)\n"
#~ "@DESCRIPTION=IMCSCH returnerar komplexa kosekanten för komplexa talet z "
#~ "(@ital), där\n"
#~ "\n"
#~ "\tcsc(z) = 1/sin(z).\n"
#~ "\n"
#~ "* Om @ital ej är ett godkänt komplext tal, returneras felvärdet #VÄRDE!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMCSCH(\"2-j\") är lika med 0,635494-0,221501j.\n"
#~ "\n"
#~ "@SEEALSO=IMSEC,IMCOT"

#~ msgid ""
#~ "@FUNCTION=IMCOT\n"
#~ "@SYNTAX=IMCOT(inumber)\n"
#~ "@DESCRIPTION=IMCOT returns the complex cotangent of the complex number z "
#~ "(@inumber), where\n"
#~ "\n"
#~ "\tcot(z) = 1/tan(z).\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMCOT returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMCOT(\"2-j\") equals -0.171384+0.821330j.\n"
#~ "\n"
#~ "@SEEALSO=IMSEC,IMCSC"
#~ msgstr ""
#~ "@FUNCTION=IMCOT\n"
#~ "@SYNTAX=IMCOT(ital)\n"
#~ "@DESCRIPTION=IMCOT returnerar komplexa cotangens för komplexa talet z "
#~ "(@ital), där\n"
#~ "\n"
#~ "\tcot(z) = 1/tan(z).\n"
#~ "\n"
#~ "* Om @ital ej är ett godkänt komplext tal, returneras felvärdet #VÄRDE!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMCOT(\"2-j\") är lika med -0,171384+0,821330j.\n"
#~ "\n"
#~ "@SEEALSO=IMSEC,IMCSC"

#~ msgid ""
#~ "@FUNCTION=IMEXP\n"
#~ "@SYNTAX=IMEXP(inumber)\n"
#~ "@DESCRIPTION=IMEXP returns the exponential of a complex number.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMEXP returns #VALUE! "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMEXP(\"2-j\") equals 3.992324-6.217676j.\n"
#~ "\n"
#~ "@SEEALSO=IMLN"
#~ msgstr ""
#~ "@FUNCTION=IMEXP\n"
#~ "@SYNTAX=IMEXP(ital)\n"
#~ "@DESCRIPTION=IMEXP returnerar exponentialen av ett komplext tal.\n"
#~ "\n"
#~ "* Om @ital ej är ett godkänt komplext tal, returneras felvärdet #VÄRDE!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMEXP(\"2-j\") är lika med 3,992324-6,217676j.\n"
#~ "\n"
#~ "@SEEALSO=IMLN"

#~ msgid ""
#~ "@FUNCTION=IMARGUMENT\n"
#~ "@SYNTAX=IMARGUMENT(inumber)\n"
#~ "@DESCRIPTION=IMARGUMENT returns the argument theta of a complex number, i."
#~ "e. the angle in radians from the real axis to the representation of the "
#~ "number in polar coordinates.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMARGUMENT returns #VALUE! "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARGUMENT(\"2-j\") equals -0.463647609.\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=IMARGUMENT\n"
#~ "@SYNTAX=IMARGUMENT(ital)\n"
#~ "@DESCRIPTION=IMARGUMENT returnerar argumentet theta för ett komplext tal, "
#~ "alltså vinkeln i radianer från reella axeln till talets representation i "
#~ "polära koordinater.\n"
#~ "\n"
#~ "* Om @ital ej är ett godkänt komplext tal, returneras felvärdet #VÄRDE!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARGUMENT(\"2-j\") är lika med -0,463647609.\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=IMLN\n"
#~ "@SYNTAX=IMLN(inumber)\n"
#~ "@DESCRIPTION=IMLN returns the natural logarithm of a complex number.\n"
#~ "\n"
#~ "The result will have an imaginary part between -pi and +pi.  The natural "
#~ "logarithm is not uniquely defined on complex numbers. You may need to add "
#~ "or subtract an even multiple of pi to the imaginary part.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMLN returns #VALUE! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMLN(\"3-j\") equals 1.15129-0.32175j.\n"
#~ "\n"
#~ "@SEEALSO=IMEXP,IMLOG2,IMLOG10"
#~ msgstr ""
#~ "@FUNCTION=IMLN\n"
#~ "@SYNTAX=IMLN(ital)\n"
#~ "@DESCRIPTION=IMLN returnerar den naturliga logaritmen för ett komplext "
#~ "tal.\n"
#~ "\n"
#~ "Resultatet har en imaginärdel mellan -pi och +pi. Den naturliga "
#~ "logaritmen är inte entydigt definierad för komplexa tal, och därför kan "
#~ "du behöva addera eller subtrahera en jämn multipel av pi på "
#~ "imaginärdelen.\n"
#~ "\n"
#~ "* Om @ital ej är ett godkänt komplext tal, returneras felvärdet #VÄRDE!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMLN(\"3-j\") är lika med 1,15129-0,32175j.\n"
#~ "\n"
#~ "@SEEALSO=IMEXP,IMLOG2,IMLOG10"

#~ msgid ""
#~ "@FUNCTION=IMLOG2\n"
#~ "@SYNTAX=IMLOG2(inumber)\n"
#~ "@DESCRIPTION=IMLOG2 returns the logarithm of a complex number in base 2.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMLOG2 returns #VALUE! "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMLOG2(\"3-j\") equals 1.66096-0.46419j.\n"
#~ "\n"
#~ "@SEEALSO=IMLN,IMLOG10"
#~ msgstr ""
#~ "@FUNCTION=IMLOG2\n"
#~ "@SYNTAX=IMLOG2(ital)\n"
#~ "@DESCRIPTION=IMLOG2 returnerar logaritmen i basen 2 för ett komplext "
#~ "tal.\n"
#~ "\n"
#~ "* Om @ital ej är ett godkänt komplext tal, returneras felvärdet #VÄRDE!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMLOG2(\"3-j\") är lika med 1,66096-0,46419j.\n"
#~ "\n"
#~ "@SEEALSO=IMLN,IMLOG10"

#~ msgid ""
#~ "@FUNCTION=IMLOG10\n"
#~ "@SYNTAX=IMLOG10(inumber)\n"
#~ "@DESCRIPTION=IMLOG10 returns the logarithm of a complex number in base "
#~ "10.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMLOG10 returns #VALUE! "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMLOG10(\"3-j\") equals 0.5-0.13973j.\n"
#~ "\n"
#~ "@SEEALSO=IMLN,IMLOG2"
#~ msgstr ""
#~ "@FUNCTION=IMLOG10\n"
#~ "@SYNTAX=IMLOG10(ital)\n"
#~ "@DESCRIPTION=IMLOG10 returnerar logaritmen i basen 10 för ett komplext "
#~ "tal.\n"
#~ "\n"
#~ "* Om @ital ej är ett godkänt komplext tal, returneras felvärdet #VÄRDE!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMLOG10(\"3-j\") är lika med 0,5-0,13973j.\n"
#~ "\n"
#~ "@SEEALSO=IMLN,IMLOG2"

#~ msgid ""
#~ "@FUNCTION=IMPOWER\n"
#~ "@SYNTAX=IMPOWER(inumber1,inumber2)\n"
#~ "@DESCRIPTION=IMPOWER returns a complex number raised to a power.  "
#~ "@inumber1 is the complex number to be raised to a power and @inumber2 is "
#~ "the power to which you want to raise it.\n"
#~ "\n"
#~ "* If @inumber1 or @inumber2 are not valid complex numbers, IMPOWER "
#~ "returns #VALUE! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMPOWER(\"4-j\",2) equals 15-8j.\n"
#~ "\n"
#~ "@SEEALSO=IMSQRT"
#~ msgstr ""
#~ "@FUNCTION=IMPOWER\n"
#~ "@SYNTAX=IMPOWER(ital1;ital2)\n"
#~ "@DESCRIPTION=IMPOWER returnerar ett komplext tal upphöjt med en exponent. "
#~ "@ital1 är det komplexa talet som ska upphöjas och @ital2 är exponenten "
#~ "med vilken det komplexa talet ska upphöjas.\n"
#~ "\n"
#~ "* Om @ital1 eller @ital2 ej är godkända komplexa tal, returneras "
#~ "felvärdet #VÄRDE!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMPOWER(\"4-j\";2) är lika med 15-8j.\n"
#~ "\n"
#~ "@SEEALSO=IMSQRT"

#~ msgid ""
#~ "@FUNCTION=IMDIV\n"
#~ "@SYNTAX=IMDIV(inumber1,inumber2)\n"
#~ "@DESCRIPTION=IMDIV returns the quotient of two complex numbers.\n"
#~ "\n"
#~ "* If @inumber1 or @inumber2 are not valid complex numbers, IMDIV returns "
#~ "#VALUE! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMDIV(\"2-j\",\"2+j\") equals 0.6-0.8j.\n"
#~ "\n"
#~ "@SEEALSO=IMPRODUCT"
#~ msgstr ""
#~ "@FUNCTION=IMDIV\n"
#~ "@SYNTAX=IMDIV(ital1;ital2)\n"
#~ "@DESCRIPTION=IMDIV returnerar kvoten av två komplexa tal.\n"
#~ "\n"
#~ "* Om @ital1 eller @ital2 ej är godkända komplexa tal, returneras "
#~ "felvärdet #VÄRDE!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMDIV(\"2-j\";\"2+j\") är lika med 0,6-0,8j.\n"
#~ "\n"
#~ "@SEEALSO=IMPRODUCT"

#~ msgid ""
#~ "@FUNCTION=IMSIN\n"
#~ "@SYNTAX=IMSIN(inumber)\n"
#~ "@DESCRIPTION=IMSIN returns the sine of a complex number.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMSIN returns #VALUE! "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMSIN(\"1+j\") equals 1.29846+0.63496j.\n"
#~ "\n"
#~ "@SEEALSO=IMCOS,IMTAN"
#~ msgstr ""
#~ "@FUNCTION=IMSIN\n"
#~ "@SYNTAX=IMSIN(ital)\n"
#~ "@DESCRIPTION=IMSIN returnerar sinus för ett komplext tal.\n"
#~ "\n"
#~ "* Om @ital ej är ett godkänt komplext tal, returneras felvärdet #VÄRDE!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMSIN(\"1+j\") är lika med 1,29846+0,63496j.\n"
#~ "\n"
#~ "@SEEALSO=IMCOS,IMTAN"

#~ msgid ""
#~ "@FUNCTION=IMSINH\n"
#~ "@SYNTAX=IMSINH(inumber)\n"
#~ "@DESCRIPTION=IMSINH returns the complex hyperbolic sine of the complex "
#~ "number z (@inumber), where\n"
#~ "\n"
#~ "\tsinh(z) = (exp(z) - exp(-z))/2.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMSINH returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMSINH(\"1+j\") equals 0.63496+1.29846j.\n"
#~ "\n"
#~ "@SEEALSO=IMCOSH,IMTANH"
#~ msgstr ""
#~ "@FUNCTION=IMSINH\n"
#~ "@SYNTAX=IMSINH(ital)\n"
#~ "@DESCRIPTION=IMSINH returnerar komplexa sinus hyperbolicus för komplexa "
#~ "talet z (@ital), där\n"
#~ "\n"
#~ "\tsinh(z) = (exp(z) - exp(-z))/2.\n"
#~ "\n"
#~ "* Om @ital ej är ett godkänt komplext tal, returneras felvärdet #VÄRDE!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMSINH(\"1+j\") är lika med 0,63496+1,29846j.\n"
#~ "\n"
#~ "@SEEALSO=IMCOSH,IMTANH"

#~ msgid ""
#~ "@FUNCTION=IMCOSH\n"
#~ "@SYNTAX=IMCOSH(inumber)\n"
#~ "@DESCRIPTION=IMCOSH returns the complex hyperbolic cosine of the complex "
#~ "number z (@inumber), where\n"
#~ "\n"
#~ "\tcosh(z) = (exp(z) + exp(-z))/2.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMCOSH returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMCOSH(\"1+j\") equals 0.83373+0.988898j.\n"
#~ "\n"
#~ "@SEEALSO=IMSINH,IMTANH"
#~ msgstr ""
#~ "@FUNCTION=IMCOSH\n"
#~ "@SYNTAX=IMCOSH(ital)\n"
#~ "@DESCRIPTION=IMCOSH returnerar komplexa cosinus hyperbolicus för komplexa "
#~ "talet z (@ital), där\n"
#~ "\n"
#~ "\tcosh(z) = (exp(z) + exp(-z))/2.\n"
#~ "\n"
#~ "* Om @ital ej är ett godkänt komplext tal, returneras felvärdet #VÄRDE!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMCOSH(\"1+j\") är lika med 0,83373+0,988898j.\n"
#~ "\n"
#~ "@SEEALSO=IMSINH,IMTANH"

#~ msgid ""
#~ "@FUNCTION=IMTANH\n"
#~ "@SYNTAX=IMTANH(inumber)\n"
#~ "@DESCRIPTION=IMTANH returns the complex hyperbolic tangent of the complex "
#~ "number z (@inumber), where\n"
#~ "\n"
#~ "\ttanh(z) = sinh(z)/cosh(z).\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMTANH returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMTANH(\"1+j\") equals 1.083923+0.2717526j.\n"
#~ "\n"
#~ "@SEEALSO=IMSINH,IMCOSH"
#~ msgstr ""
#~ "@FUNCTION=IMTANH\n"
#~ "@SYNTAX=IMTANH(ital)\n"
#~ "@DESCRIPTION=IMTANH returnerar komplexa tangens hyperbolicus för komplexa "
#~ "talet z (@ital), där\n"
#~ "\n"
#~ "\ttanh(z) = sinh(z)/cosh(z).\n"
#~ "\n"
#~ "* Om @ital ej är ett godkänt komplext tal, returneras felvärdet #VÄRDE!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMTANH(\"1+j\") är lika med 1,083923+0,2717526j.\n"
#~ "\n"
#~ "@SEEALSO=IMSINH,IMCOSH"

#~ msgid ""
#~ "@FUNCTION=IMSECH\n"
#~ "@SYNTAX=IMSECH(inumber)\n"
#~ "@DESCRIPTION=IMSECH returns the complex hyperbolic secant of the complex "
#~ "number z (@inumber), where\n"
#~ "\n"
#~ "\tsech(z) = 1/cosh(z).\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMSECH returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMSECH(\"1+j\") equals 0.498337-0.5910838j.\n"
#~ "\n"
#~ "@SEEALSO=IMCSCH,IMCOTH"
#~ msgstr ""
#~ "@FUNCTION=IMSECH\n"
#~ "@SYNTAX=IMSECH(ital)\n"
#~ "@DESCRIPTION=IMSECH returnerar komplexa hyperboliska sekanten för "
#~ "komplexa talet z (@ital), där\n"
#~ "\n"
#~ "\tsech(z) = 1/cosh(z).\n"
#~ "\n"
#~ "* Om @ital ej är ett godkänt komplext tal, returneras felvärdet #VÄRDE!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMSECH(\"1+j\") är lika med 0,498337-0,5910838j.\n"
#~ "\n"
#~ "@SEEALSO=IMCSCH,IMCOTH"

#~ msgid ""
#~ "@FUNCTION=IMCSCH\n"
#~ "@SYNTAX=IMCSCH(inumber)\n"
#~ "@DESCRIPTION=IMCSCH returns the complex hyperbolic cosecant of the "
#~ "complex number z (@inumber), where\n"
#~ "\n"
#~ "\tcsch(z) = 1/sinh(z).\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMCSCH returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMCSCH(\"1+j\") equals 0.303931-0.621518j.\n"
#~ "\n"
#~ "@SEEALSO=IMSECH,IMCOTH"
#~ msgstr ""
#~ "@FUNCTION=IMCSCH\n"
#~ "@SYNTAX=IMCSCH(ital)\n"
#~ "@DESCRIPTION=IMCSCH returnerar komplexa hyperboliska kosekanten för "
#~ "komplexa talet z (@ital), där\n"
#~ "\n"
#~ "\tcsch(z) = 1/sinh(z).\n"
#~ "\n"
#~ "* Om @ital ej är ett godkänt komplext tal, returneras felvärdet #VÄRDE!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMCSCH(\"1+j\") är lika med 0,303931-0,621518j.\n"
#~ "\n"
#~ "@SEEALSO=IMSECH,IMCOTH"

#~ msgid ""
#~ "@FUNCTION=IMCOTH\n"
#~ "@SYNTAX=IMCOTH(inumber)\n"
#~ "@DESCRIPTION=IMCOTH returns the complex hyperbolic cotangent of the "
#~ "complex number z (@inumber) where,\n"
#~ "\n"
#~ "\tcoth(z) = 1/tanh(z).\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMCOTH returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMCOTH(\"1+j\") equals 0.868014-0.217622j.\n"
#~ "\n"
#~ "@SEEALSO=IMSECH,IMCSCH"
#~ msgstr ""
#~ "@FUNCTION=IMCOTH\n"
#~ "@SYNTAX=IMCOTH(ital)\n"
#~ "@DESCRIPTION=IMCOTH returnerar komplexa cotangens hyperbolicus för "
#~ "komplexa talet z (@ital), där\n"
#~ "\n"
#~ "\tcoth(z) = 1/tanh(z).\n"
#~ "\n"
#~ "* Om @ital ej är ett godkänt komplext tal, returneras felvärdet #VÄRDE!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMCOTH(\"1+j\") är lika med 0,868014-0,217622j.\n"
#~ "\n"
#~ "@SEEALSO=IMSECH,IMCSCH"

#~ msgid ""
#~ "@FUNCTION=IMARCSIN\n"
#~ "@SYNTAX=IMARCSIN(inumber)\n"
#~ "@DESCRIPTION=IMARCSIN returns the complex arcsine of the complex number "
#~ "@inumber. The branch cuts are on the real axis, less than -1 and greater "
#~ "than 1.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMARCSIN returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCSIN(\"1+j\") equals 0.6662394+1.061275j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCCOS,IMARCTAN"
#~ msgstr ""
#~ "@FUNCTION=IMARCSIN\n"
#~ "@SYNTAX=IMARCSIN(ital)\n"
#~ "@DESCRIPTION=IMARCSIN returnerar komplexa arcussinus för det komplexa "
#~ "talet @ital. Grensnitten är på den reella axeln, mindre än -1 och större "
#~ "än 1.\n"
#~ "\n"
#~ "* Om @ital ej är ett godkänt komplext tal, returneras felvärdet #VÄRDE!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCSIN(\"1+j\") är lika med 0,6662394+1,061275j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCCOS,IMARCTAN"

#~ msgid ""
#~ "@FUNCTION=IMARCCOS\n"
#~ "@SYNTAX=IMARCCOS(inumber)\n"
#~ "@DESCRIPTION=IMARCCOS returns the complex arccosine of the complex number "
#~ "@inumber. The branch cuts are on the real axis, less than -1 and greater "
#~ "than 1.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMARCCOS returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCCOS(\"1+j\") equals 0.9045569-1.061275j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCSIN,IMARCTAN"
#~ msgstr ""
#~ "@FUNCTION=IMARCCOS\n"
#~ "@SYNTAX=IMARCCOS(ital)\n"
#~ "@DESCRIPTION=IMARCOS returnerar komplexa arcus cosinus för komplexa talet "
#~ "@ital. Grensnitten är på den reella axeln, mindre än -1 och större än 1.\n"
#~ "\n"
#~ "* Om @ital ej är ett godkänt komplext tal, returneras felvärdet #VÄRDE!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCCOS(\"1+j\") är lika med 0,9045569-1,061275j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCSIN,IMARCTAN"

#~ msgid ""
#~ "@FUNCTION=IMARCTAN\n"
#~ "@SYNTAX=IMARCTAN(inumber)\n"
#~ "@DESCRIPTION=IMARCTAN returns the complex arctangent of the complex "
#~ "number @inumber. The branch cuts are on the imaginary axis, below -i and "
#~ "above i.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMARCTAN returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCTAN(\"1+j\") equals 1.0172220+0.4023595j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCSIN,IMARCCOS"
#~ msgstr ""
#~ "@FUNCTION=IMARCTAN\n"
#~ "@SYNTAX=IMARCTAN(ital)\n"
#~ "@DESCRIPTION=IMARCTAN returnerar komplexa arcus tangens för komplexa "
#~ "talet @ital. Grensnitten är på den imaginära axeln, mindre än -i och "
#~ "större än i.\n"
#~ "\n"
#~ "* Om @ital ej är ett godkänt komplext tal, returneras felvärdet #VÄRDE!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCTAN(\"1+j\") är lika med 1,0172220+0,4023595j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCSIN,IMARCCOS"

#~ msgid ""
#~ "@FUNCTION=IMARCSEC\n"
#~ "@SYNTAX=IMARCSEC(inumber)\n"
#~ "@DESCRIPTION=IMARCSEC returns the complex arcsecant of the complex number "
#~ "z (@inumber), where\n"
#~ "\n"
#~ "\tarcsec(z) = arccos(1/z).\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMARCSEC returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCSEC(\"1+j\") equals 1.1185179+0.5306375j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCCSC,IMARCCOT"
#~ msgstr ""
#~ "@FUNCTION=IMARCSEC\n"
#~ "@SYNTAX=IMARCSEC(ital)\n"
#~ "@DESCRIPTION=IMARCSEC returnerar komplexa arcus-sekanten för komplexa "
#~ "talet z (@ital), där\n"
#~ "\n"
#~ "\tarcsec(z) = arccos(1/z).\n"
#~ "\n"
#~ "* Om @ital ej är ett godkänt komplext tal, returneras felvärdet #VÄRDE!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCSEC(\"1+j\") är lika med 1,1185179+0,5306375j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCCSC,IMARCOT"

#~ msgid ""
#~ "@FUNCTION=IMARCCSC\n"
#~ "@SYNTAX=IMARCCSC(inumber)\n"
#~ "@DESCRIPTION=IMARCCSC returns the complex arccosecant of the complex "
#~ "number z (@inumber), where\n"
#~ "\n"
#~ "\tarccsc(z) = arcsin(1/z).\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMARCCSC returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCCSC(\"1+j\") equals 0.45227845-0.5306375j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCSEC,IMARCCOT"
#~ msgstr ""
#~ "@FUNCTION=IMARCCSC\n"
#~ "@SYNTAX=IMARCCSC(ital)\n"
#~ "@DESCRIPTION=IMARCCSC returnerar komplexa arcus cosekant för komplexa "
#~ "talet z (@ital), där\n"
#~ "\n"
#~ "\tarccsc(z) = arcsin(1/z).\n"
#~ "\n"
#~ "* Om @ital ej är ett godkänt komplext tal, returneras felvärdet #VÄRDE!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCCSC(\"1+j\") är lika med 0,45227845-0,5306375j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCSEC,IMARCOT"

#~ msgid ""
#~ "@FUNCTION=IMARCCOT\n"
#~ "@SYNTAX=IMARCCOT(inumber)\n"
#~ "@DESCRIPTION=IMARCCOT returns the complex arccotangent of the complex "
#~ "number z (@inumber), where\n"
#~ "\n"
#~ "\tarccot(z) = arctan(1/z).\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMARCCOT returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCCOT(\"1+j\") equals 0.553574+0.4023595j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCSEC,IMARCCSC"
#~ msgstr ""
#~ "@FUNCTION=IMARCCOT\n"
#~ "@SYNTAX=IMARCCOT(ital)\n"
#~ "@DESCRIPTION=IMARCCOT returnerar komplexa arcus cotangens för komplexa "
#~ "talet z (@ital), där\n"
#~ "\n"
#~ "\tarccot(z) = arctan(1/z).\n"
#~ "\n"
#~ "* Om @ital ej är ett godkänt komplext tal, returneras felvärdet #VÄRDE!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCCOT(\"1+j\") är lika med 0,553574+0,4023595j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCSEC,IMARCSC"

#~ msgid ""
#~ "@FUNCTION=IMARCSINH\n"
#~ "@SYNTAX=IMARCSINH(inumber)\n"
#~ "@DESCRIPTION=IMARCSINH returns the complex hyperbolic arcsine of the "
#~ "complex number @inumber. The branch cuts are on the imaginary axis, below "
#~ "-i and above i.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMARCSINH returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCSINH(\"1+j\") equals 1.061275+0.6662394j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCCOSH,IMARCTANH"
#~ msgstr ""
#~ "@FUNCTION=IMARCSINH\n"
#~ "@SYNTAX=IMARCSINH(ital)\n"
#~ "@DESCRIPTION=IMARCSINH returnerar komplexa arcus sinus hyperbolicus för "
#~ "komplexa talet @ital. Grensnitten är på den imaginära axeln, under -i och "
#~ "över i.\n"
#~ "\n"
#~ "* Om @ital ej är ett godkänt komplext tal, returneras felvärdet #VÄRDE!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCSINH(\"1+j\") är lika med 1,061275+0,6662394j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCCOSH,IMARCTANH"

#~ msgid ""
#~ "@FUNCTION=IMARCCOSH\n"
#~ "@SYNTAX=IMARCCOSH(inumber)\n"
#~ "@DESCRIPTION=IMARCCOSH returns the complex hyperbolic arccosine of the "
#~ "complex number @inumber. The branch cut is on the real axis, less than "
#~ "1.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMARCCOSH returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCCOSH(\"1+j\") equals 1.06127506+0.904557j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCSINH,IMARCTANH"
#~ msgstr ""
#~ "@FUNCTION=IMARCCOSH\n"
#~ "@SYNTAX=IMARCCOSH(ital)\n"
#~ "@DESCRIPTION=IMARCCOSH returnerar komplexa arcus cosinus hyperbolicus för "
#~ "komplexa talet @ital. Grensnittet är på den reella axeln, mindre än 1.\n"
#~ "\n"
#~ "* Om @ital ej är ett godkänt komplext tal, returneras felvärdet #VÄRDE!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCCOSH(\"1+j\") är lika med 1,06127506+0,904557j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCSINH,IMARCTANH"

#~ msgid ""
#~ "@FUNCTION=IMARCTANH\n"
#~ "@SYNTAX=IMARCTANH(inumber)\n"
#~ "@DESCRIPTION=IMARCTANH returns the complex hyperbolic arctangent of the "
#~ "complex number @inumber. The branch cuts are on the real axis, less than -"
#~ "1 and greater than 1.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMARCTANH returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCTANH(\"1+j\") equals 0.4023595+1.0172220j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCSINH,IMARCCOSH"
#~ msgstr ""
#~ "@FUNCTION=IMARCTANH\n"
#~ "@SYNTAX=IMARCTANH(ital)\n"
#~ "@DESCRIPTION=IMARCTANH returnerar komplexa arcus tangens hyperbolicus för "
#~ "komplexa talet @ital. Grensnitten är på den reella axeln, mindre än -1 "
#~ "och större än 1.\n"
#~ "\n"
#~ "* Om @ital ej är ett godkänt komplext tal, returneras felvärdet #VÄRDE!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCTANH(\"1+j\") är lika med 0,4023595+1,0172220j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCSINH,IMARCCOSH"

#~ msgid ""
#~ "@FUNCTION=IMARCSECH\n"
#~ "@SYNTAX=IMARCSECH(inumber)\n"
#~ "@DESCRIPTION=IMARCSECH returns the complex hyperbolic arcsecant of the "
#~ "complex number z (@inumber), where\n"
#~ "\n"
#~ "\tarcsech(z) = arccosh(1/z).\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMARCSECH returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCSECH(\"1+j\") equals 0.5306375-1.118518j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCCSCH,IMARCCOTH"
#~ msgstr ""
#~ "@FUNCTION=IMARCSECH\n"
#~ "@SYNTAX=IMARCSECH(ital)\n"
#~ "@DESCRIPTION=IMARCSECH returnerar komplexa hyperboliska arcus sekanten "
#~ "för komplexa talet z (@ital), där\n"
#~ "\n"
#~ "\tarcsech(z) = arccosh(1/z).\n"
#~ "\n"
#~ "* Om @ital ej är ett godkänt komplext tal, returneras felvärdet #VÄRDE!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCSECH(\"1+j\") är lika med 0,5306375-1,118518j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCCSCH,IMARCCOTH"

#~ msgid ""
#~ "@FUNCTION=IMARCCSCH\n"
#~ "@SYNTAX=IMARCCSCH(inumber)\n"
#~ "@DESCRIPTION=IMARCCSCH returns the complex hyperbolic arccosecant of the "
#~ "complex number z (@inumber), where\n"
#~ "\n"
#~ "\tarccsch(z) = arcsinh(1/z).\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMARCCSCH returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCCSCH(\"1+j\") equals 0.5306375-0.452278j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCSECH,IMARCCOTH"
#~ msgstr ""
#~ "@FUNCTION=IMARCCSCH\n"
#~ "@SYNTAX=IMARCCSCH(ital)\n"
#~ "@DESCRIPTION=IMARCCSCH returnerar komplexa hyperboliska arcus sekanten "
#~ "för komplexa talet z (@ital), där\n"
#~ "\n"
#~ "\tarccsch(z) = arcsinh(1/z).\n"
#~ "\n"
#~ "* Om @ital ej är ett godkänt komplext tal, returneras felvärdet #VÄRDE!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCCSCH(\"1+j\") är lika med 0,5306375-0,452278j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCSECH,IMARCCOTH"

#~ msgid ""
#~ "@FUNCTION=IMARCCOTH\n"
#~ "@SYNTAX=IMARCCOTH(inumber)\n"
#~ "@DESCRIPTION=IMARCCOTH returns the complex hyperbolic arccotangent of the "
#~ "complex number z (@inumber), where\n"
#~ "\n"
#~ "\tarccoth(z) = arctanh(1/z).\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMARCCOTH returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCCOTH(\"1+j\") equals 0.40235948-0.5535744j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCSECH,IMARCCSCH"
#~ msgstr ""
#~ "@FUNCTION=IMARCCOTH\n"
#~ "@SYNTAX=IMARCCOTH(ital)\n"
#~ "@DESCRIPTION=IMARCCOTH returnerar komplexa arcus cotangens hyperbolicus "
#~ "för komplexa talet z (@ital), där\n"
#~ "\n"
#~ "\tarccoth(z) = arctanh(1/z).\n"
#~ "\n"
#~ "* Om @ital ej är ett godkänt komplext tal, returneras felvärdet #VÄRDE!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCCOTH(\"1+j\") är lika med 0,40235948-0,5535744j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCSECH,IMARCSCH"

#~ msgid ""
#~ "@FUNCTION=IMSQRT\n"
#~ "@SYNTAX=IMSQRT(inumber)\n"
#~ "@DESCRIPTION=IMSQRT returns the square root of a complex number.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMSQRT returns #VALUE! "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMSQRT(\"1+j\") equals 1.09868+0.4550899j.\n"
#~ "\n"
#~ "@SEEALSO=IMPOWER"
#~ msgstr ""
#~ "@FUNCTION=IMSQRT\n"
#~ "@SYNTAX=IMSQRT(ital)\n"
#~ "@DESCRIPTION=IMSQRT returnerar kvadratroten av ett komplext tal.\n"
#~ "\n"
#~ "* Om @ital ej är ett godkänt komplext tal, returneras felvärdet #VÄRDE!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMSQRT(\"1+j\") är lika med 1,09868+0,4550899j.\n"
#~ "\n"
#~ "@SEEALSO=IMPOWER"

#~ msgid ""
#~ "@FUNCTION=IMSUB\n"
#~ "@SYNTAX=IMSUB(inumber1,inumber2)\n"
#~ "@DESCRIPTION=IMSUB returns the difference of two complex numbers.\n"
#~ "\n"
#~ "* If @inumber1 or @inumber2 are not valid complex numbers, IMSUB returns "
#~ "#VALUE! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMSUB(\"3-j\",\"2+j\") equals 1-2j.\n"
#~ "\n"
#~ "@SEEALSO=IMSUM"
#~ msgstr ""
#~ "@FUNCTION=IMSUB\n"
#~ "@SYNTAX=IMSUB(ital1;ital2)\n"
#~ "@DESCRIPTION=IMSUB returnerar skillnaden mellan två komplexa tal.\n"
#~ "\n"
#~ "* Om @ital1 eller @ital2 ej är godkända komplexa tal, returneras "
#~ "felvärdet #VÄRDE!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMSUB(\"3-j\";\"2+j\") är lika med 1-2j.\n"
#~ "\n"
#~ "@SEEALSO=IMSUM"

#~ msgid ""
#~ "@FUNCTION=IMPRODUCT\n"
#~ "@SYNTAX=IMPRODUCT(inumber1[,inumber2,...])\n"
#~ "@DESCRIPTION=IMPRODUCT returns the product of given complex numbers.\n"
#~ "\n"
#~ "* If any of the @inumbers are not valid complex numbers, IMPRODUCT "
#~ "returns #VALUE! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMPRODUCT(\"2-j\",\"4-2j\") equals 6-8j.\n"
#~ "\n"
#~ "@SEEALSO=IMDIV"
#~ msgstr ""
#~ "@FUNCTION=IMPRODUCT\n"
#~ "@SYNTAX=IMPRODUCT(ital1[;ital2;...])\n"
#~ "@DESCRIPTION=IMPRODUCT returnerar produkten av de givna komplexa talen.\n"
#~ "\n"
#~ "* Om något @ital ej är ett godkänt komplext tal, returneras felvärdet "
#~ "#VÄRDE!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMPRODUCT(\"2-j\";\"4-2j\") är lika med 6-8j.\n"
#~ "\n"
#~ "@SEEALSO=IMDIV"

#~ msgid ""
#~ "@FUNCTION=IMSUM\n"
#~ "@SYNTAX=IMSUM(inumber1,inumber2)\n"
#~ "@DESCRIPTION=IMSUM returns the sum of two complex numbers.\n"
#~ "\n"
#~ "* If @inumber1 or @inumber2 are not valid complex numbers, IMSUM returns "
#~ "#VALUE! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMSUM(\"2-4j\",\"9-j\") equals 11-5j.\n"
#~ "\n"
#~ "@SEEALSO=IMSUB"
#~ msgstr ""
#~ "@FUNCTION=IMSUM\n"
#~ "@SYNTAX=IMSUM(ital1;ital2)\n"
#~ "@DESCRIPTION=IMSUM returnerar summan av två komplexa tal.\n"
#~ "\n"
#~ "* Om @ital1 eller @ital2 ej är godkända komplexa tal, returneras "
#~ "felvärdet #VÄRDE!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMSUM(\"2-4j\",\"9-j\") är lika med 11-5j.\n"
#~ "\n"
#~ "@SEEALSO=IMSUB"

#~ msgid ""
#~ "@FUNCTION=DAVERAGE\n"
#~ "@SYNTAX=DAVERAGE(database,field,criteria)\n"
#~ "@DESCRIPTION=DAVERAGE function returns the average of the values in a "
#~ "list or database that match conditions specified.\n"
#~ "\n"
#~ "@database is a range of cells in which rows of related information are "
#~ "records and columns of data are fields. The first row of a database "
#~ "contains labels for each column. \n"
#~ "\n"
#~ "@field specifies which column is used in the function.  If @field is an "
#~ "integer, for example 2, the second column is used. Field can also be the "
#~ "label of a column.  For example, ``Age'' refers to the column with the "
#~ "label ``Age'' in @database range. \n"
#~ "\n"
#~ "@criteria is the range of cells which contains the specified conditions.  "
#~ "The first row of a @criteria should contain the labels of the fields for "
#~ "which the criteria are for.  Cells below the labels specify conditions, "
#~ "for example, ``>3'' or ``<9''.  Equality condition can be given simply by "
#~ "specifying a value, e.g. ``3'' or ``John''. \n"
#~ "Each row in @criteria specifies a separate condition. If a row in "
#~ "@database matches a row in @criteria, then that row is counted. "
#~ "Technically speaking, this a boolean OR operation between the rows in "
#~ "@criteria.\n"
#~ "If @criteria specifies more than one column, then each of the conditions "
#~ "in the specified columns must be true for the row in @database to match. "
#~ "Technically speaking, this is a boolean AND operation between the columns "
#~ "in @criteria.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the range A1:C7 contain the following values:\n"
#~ "Name    Age     Salary\n"
#~ "John    34      54342\n"
#~ "Bill    35      22343\n"
#~ "Clark   29      34323\n"
#~ "Bob     43      47242\n"
#~ "Susan   37      42932\n"
#~ "Jill    45      45324\n"
#~ "\n"
#~ "In addition, the cells A9:B11 contain the following values:\n"
#~ "Age     Salary\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "DAVERAGE(A1:C7, \"Salary\", A9:A11) equals 42296.3333.\n"
#~ "DAVERAGE(A1:C7, \"Age\", A9:A11) equals 39.\n"
#~ "DAVERAGE(A1:C7, \"Salary\", A9:B11) equals 40782.5.\n"
#~ "DAVERAGE(A1:C7, \"Age\", A9:B11) equals 36.\n"
#~ "\n"
#~ "@SEEALSO=DCOUNT"
#~ msgstr ""
#~ "@FUNCTION=DAVERAGE\n"
#~ "@SYNTAX=DAVERAGE(databas;fält;kriteria)\n"
#~ "@DESCRIPTION=DAVERAGE funktionen returnerar medelvärdet av värdena i en "
#~ "lista eller databas som matchar dom uppställda kriterierna.\n"
#~ "\n"
#~ "@databas är ett område av celler där rader av relaterad information är "
#~ "poster och kolumner av data är fält. Den första raden i databasen "
#~ "innehåller etiketter för varje kolumn. \n"
#~ "\n"
#~ "@fält anger vilken kolumn som används i funktionen. Om @fält är ett "
#~ "heltal, 2 till exempel, så används den andra kolumnen. Fält kan också "
#~ "vara en kolumnetikett. Till exempel, ``Ålder'' anger kolumnen med "
#~ "etiketten ``Ålder'' i @databas området. \n"
#~ "\n"
#~ "@kriteria är det cellområde som innehåller de angivna villkoren. Den "
#~ "första raden i @kriteria ska innehålla etiketterna till fälten för vilka "
#~ "kriterierna skall gälla. Celler under etiketterna bestämmer villkoren, "
#~ "till exempel ``>3'' eller ``<9''. Likhetsvillkor anges enkelt genom att "
#~ "ange ett värde, t.ex. ``3'' eller ``Johan''.\n"
#~ "Varje rad i @kriteria anger ett separat villkor, d.v.s. om en rad i "
#~ "@databas matchar en rad i @kriteria så räknas raden in (det är alltså en "
#~ "Boolsk OR mellan raderna i @kriteria).\n"
#~ "Om @kriteria har mer än en kolumn så måste villkoren i varje kolumn "
#~ "matcha motsvarande kolumn i @databas. Tekniskt sett är det en Boolsk AND "
#~ "mellan kolumnerna i @kriteria).\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Låt oss anta att området A1:C7 innehåller föjande värden:\n"
#~ "Namn    Ålder   Lön\n"
#~ "Johan   34      54342\n"
#~ "Billy   35      22343\n"
#~ "Helen   29      34323\n"
#~ "Klas    43      47242\n"
#~ "Susanna 37      42932\n"
#~ "Maria   45      45324\n"
#~ "\n"
#~ "Dessutom innehåller cellerna A9:B11 följande värden:\n"
#~ "Ålder   Lön\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DAVERAGE(A1:C7, \"Lön\", A9:A11) är lika med 42296,3333.\n"
#~ "DAVERAGE(A1:C7, \"Ålder\", A9:A11) är lika med 39.\n"
#~ "DAVERAGE(A1:C7, \"Lön\", A9:B11) är lika med 40782,5.\n"
#~ "DAVERAGE(A1:C7, \"Ålder\", A9:B11) är lika med 36.\n"
#~ "\n"
#~ "@SEEALSO=DCOUNT"

#~ msgid ""
#~ "@FUNCTION=DCOUNT\n"
#~ "@SYNTAX=DCOUNT(database,field,criteria)\n"
#~ "@DESCRIPTION=DCOUNT function counts the cells that contain numbers in a "
#~ "database that match conditions specified.\n"
#~ "\n"
#~ "@database is a range of cells in which rows of related information are "
#~ "records and columns of data are fields. The first row of a database "
#~ "contains labels for each column. \n"
#~ "\n"
#~ "@field specifies which column is used in the function.  If @field is an "
#~ "integer, for example 2, the second column is used. Field can also be the "
#~ "label of a column.  For example, ``Age'' refers to the column with the "
#~ "label ``Age'' in @database range. \n"
#~ "\n"
#~ "@criteria is the range of cells which contains the specified conditions.  "
#~ "The first row of a @criteria should contain the labels of the fields for "
#~ "which the criteria are for.  Cells below the labels specify conditions, "
#~ "for example, ``>3'' or ``<9''.  Equality condition can be given simply by "
#~ "specifying a value, e.g. ``3'' or ``John''. \n"
#~ "Each row in @criteria specifies a separate condition. If a row in "
#~ "@database matches a row in @criteria, then that row is counted. "
#~ "Technically speaking, this a boolean OR operation between the rows in "
#~ "@criteria.\n"
#~ "If @criteria specifies more than one column, then each of the conditions "
#~ "in the specified columns must be true for the row in @database to match. "
#~ "Technically speaking, this is a boolean AND operation between the columns "
#~ "in @criteria.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the range A1:C7 contain the following values:\n"
#~ "Name    Age     Salary\n"
#~ "John    34      54342\n"
#~ "Bill    35      22343\n"
#~ "Clark   29      34323\n"
#~ "Bob     43      47242\n"
#~ "Susan   37      42932\n"
#~ "Jill    45      45324\n"
#~ "\n"
#~ "In addition, the cells A9:B11 contain the following values:\n"
#~ "Age     Salary\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "DCOUNT(A1:C7, \"Salary\", A9:A11) equals 3.\n"
#~ "DCOUNT(A1:C7, \"Salary\", A9:B11) equals 2.\n"
#~ "DCOUNT(A1:C7, \"Name\", A9:B11) equals 0.\n"
#~ "\n"
#~ "@SEEALSO=DAVERAGE"
#~ msgstr ""
#~ "@FUNCTION=DCOUNT\n"
#~ "@SYNTAX=DCOUNT(databas;fält;kriteria)\n"
#~ "@DESCRIPTION=DCOUNT funktionen räknar antalet celler som innehåller "
#~ "värden som matchar dom givna villkoren.\n"
#~ "\n"
#~ "@databas är ett område av celler där rader av relaterad information är "
#~ "poster och kolumner av data är fält. Den första raden i databasen "
#~ "innehåller etiketter för varje kolumn. \n"
#~ "\n"
#~ "@fält anger vilken kolumn som används i funktionen. Om @fält är ett "
#~ "heltal, 2 till exempel, så används den andra kolumnen. Fält kan också "
#~ "vara en kolumnetikett. Till exempel, ``Ålder'' anger kolumnen med "
#~ "etiketten ``Ålder'' i @databas området. \n"
#~ "\n"
#~ "@kriteria är det cellområde som innehåller de angivna villkoren. Den "
#~ "första raden i @kriteria ska innehålla etiketterna till fälten för vilka "
#~ "kriterierna skall gälla. Celler under etiketterna bestämmer villkoren, "
#~ "till exempel ``>3'' eller ``<9''. Likhetsvillkor anges enkelt genom att "
#~ "ange ett värde, t.ex. ``3'' eller ``Johan''.\n"
#~ "Varje rad i @kriteria anger ett separat villkor, d.v.s. om en rad i "
#~ "@databas matchar en rad i @kriteria så räknas raden in (det är alltså en "
#~ "Boolsk OR mellan raderna i @kriteria).\n"
#~ "Om @kriteria har mer än en kolumn så måste villkoren i varje kolumn "
#~ "matcha motsvarande kolumn i @databas. Tekniskt sett är det en Boolsk AND "
#~ "mellan kolumnerna i @kriteria).\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Låt oss anta att området A1:C7 innehåller föjande värden:\n"
#~ "Namn    Ålder   Lön\n"
#~ "Johan   34      54342\n"
#~ "Billy   35      22343\n"
#~ "Helen   29      34323\n"
#~ "Klas    43      47242\n"
#~ "Susanna 37      42932\n"
#~ "Maria   45      45324\n"
#~ "\n"
#~ "Dessutom innehåller cellerna A9:B11 följande värden:\n"
#~ "Ålder   Lön\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DCOUNT(A1:C7, \"Lön\", A9:A11) är lika med 3.\n"
#~ "DCOUNT(A1:C7, \"Lön\", A9:B11) är lika med 2.\n"
#~ "DCOUNT(A1:C7, \"Namn\", A9:B11) är lika med 0.\n"
#~ "\n"
#~ "@SEEALSO=DAVERAGE"

#~ msgid ""
#~ "@FUNCTION=DCOUNTA\n"
#~ "@SYNTAX=DCOUNTA(database,field,criteria)\n"
#~ "@DESCRIPTION=DCOUNTA function counts the cells that contain data in a "
#~ "database that match conditions specified.\n"
#~ "\n"
#~ "@database is a range of cells in which rows of related information are "
#~ "records and columns of data are fields. The first row of a database "
#~ "contains labels for each column. \n"
#~ "\n"
#~ "@field specifies which column is used in the function.  If @field is an "
#~ "integer, for example 2, the second column is used. Field can also be the "
#~ "label of a column.  For example, ``Age'' refers to the column with the "
#~ "label ``Age'' in @database range. \n"
#~ "\n"
#~ "@criteria is the range of cells which contains the specified conditions.  "
#~ "The first row of a @criteria should contain the labels of the fields for "
#~ "which the criteria are for.  Cells below the labels specify conditions, "
#~ "for example, ``>3'' or ``<9''.  Equality condition can be given simply by "
#~ "specifying a value, e.g. ``3'' or ``John''. \n"
#~ "Each row in @criteria specifies a separate condition. If a row in "
#~ "@database matches a row in @criteria, then that row is counted. "
#~ "Technically speaking, this a boolean OR operation between the rows in "
#~ "@criteria.\n"
#~ "If @criteria specifies more than one column, then each of the conditions "
#~ "in the specified columns must be true for the row in @database to match. "
#~ "Technically speaking, this is a boolean AND operation between the columns "
#~ "in @criteria.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the range A1:C7 contain the following values:\n"
#~ "Name    Age     Salary\n"
#~ "John    34      54342\n"
#~ "Bill    35      22343\n"
#~ "Clark   29      34323\n"
#~ "Bob     43      47242\n"
#~ "Susan   37      42932\n"
#~ "Jill    45      45324\n"
#~ "\n"
#~ "In addition, the cells A9:B11 contain the following values:\n"
#~ "Age     Salary\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "DCOUNTA(A1:C7, \"Salary\", A9:A11) equals 3.\n"
#~ "DCOUNTA(A1:C7, \"Salary\", A9:B11) equals 2.\n"
#~ "DCOUNTA(A1:C7, \"Name\", A9:B11) equals 2.\n"
#~ "\n"
#~ "@SEEALSO=DCOUNT"
#~ msgstr ""
#~ "@FUNCTION=DCOUNTA\n"
#~ "@SYNTAX=DCOUNTA(databas;fält;kriteria)\n"
#~ "@DESCRIPTION=DCOUNTA funktionen räknar de celler som innehåller data i en "
#~ "databas som matchar dom givna villkoren.\n"
#~ "\n"
#~ "@databas är ett område av celler där rader av relaterad information är "
#~ "poster och kolumner av data är fält. Den första raden i databasen "
#~ "innehåller etiketter för varje kolumn. \n"
#~ "\n"
#~ "@fält anger vilken kolumn som används i funktionen. Om @fält är ett "
#~ "heltal, 2 till exempel, så används den andra kolumnen. Fält kan också "
#~ "vara en kolumnetikett. Till exempel, ``Ålder'' anger kolumnen med "
#~ "etiketten ``Ålder'' i @databas området. \n"
#~ "\n"
#~ "@kriteria är det cellområde som innehåller de angivna villkoren. Den "
#~ "första raden i @kriteria ska innehålla etiketterna till fälten för vilka "
#~ "kriterierna skall gälla. Celler under etiketterna bestämmer villkoren, "
#~ "till exempel ``>3'' eller ``<9''. Likhetsvillkor anges enkelt genom att "
#~ "ange ett värde, t.ex. ``3'' eller ``Johan''.\n"
#~ "Varje rad i @kriteria anger ett separat villkor, d.v.s. om en rad i "
#~ "@databas matchar en rad i @kriteria så räknas raden in (det är alltså en "
#~ "Boolsk OR mellan raderna i @kriteria).\n"
#~ "Om @kriteria har mer än en kolumn så måste villkoren i varje kolumn "
#~ "matcha motsvarande kolumn i @databas. Tekniskt sett är det en Boolsk AND "
#~ "mellan kolumnerna i @kriteria).\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Låt oss anta att området A1:C7 innehåller föjande värden:\n"
#~ "Namn    Ålder   Lön\n"
#~ "Johan   34      54342\n"
#~ "Billy   35      22343\n"
#~ "Helen   29      34323\n"
#~ "Klas    43      47242\n"
#~ "Susanna 37      42932\n"
#~ "Maria   45      45324\n"
#~ "\n"
#~ "Dessutom innehåller cellerna A9:B11 följande värden:\n"
#~ "Ålder   Lön\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DCOUNTA(A1:C7, \"Lön\", A9:A11) är lika med 3.\n"
#~ "DCOUNTA(A1:C7, \"Lön\", A9:B11) är lika med 2.\n"
#~ "DCOUNTA(A1:C7, \"Namn\", A9:B11) är lika med 2.\n"
#~ "\n"
#~ "@SEEALSO=DCOUNT"

#~ msgid ""
#~ "@FUNCTION=DGET\n"
#~ "@SYNTAX=DGET(database,field,criteria)\n"
#~ "@DESCRIPTION=DGET function returns a single value from a column that "
#~ "match conditions specified.\n"
#~ "\n"
#~ "@database is a range of cells in which rows of related information are "
#~ "records and columns of data are fields. The first row of a database "
#~ "contains labels for each column. \n"
#~ "\n"
#~ "@field specifies which column is used in the function.  If @field is an "
#~ "integer, for example 2, the second column is used. Field can also be the "
#~ "label of a column.  For example, ``Age'' refers to the column with the "
#~ "label ``Age'' in @database range. \n"
#~ "\n"
#~ "@criteria is the range of cells which contains the specified conditions.  "
#~ "The first row of a @criteria should contain the labels of the fields for "
#~ "which the criteria are for.  Cells below the labels specify conditions, "
#~ "for example, ``>3'' or ``<9''.  Equality condition can be given simply by "
#~ "specifying a value, e.g. ``3'' or ``John''. \n"
#~ "Each row in @criteria specifies a separate condition. If a row in "
#~ "@database matches a row in @criteria, then that row is counted. "
#~ "Technically speaking, this a boolean OR operation between the rows in "
#~ "@criteria.\n"
#~ "If @criteria specifies more than one column, then each of the conditions "
#~ "in the specified columns must be true for the row in @database to match. "
#~ "Technically speaking, this is a boolean AND operation between the columns "
#~ "in @criteria.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the range A1:C7 contain the following values:\n"
#~ "Name    Age     Salary\n"
#~ "John    34      54342\n"
#~ "Bill    35      22343\n"
#~ "Clark   29      34323\n"
#~ "Bob     43      47242\n"
#~ "Susan   37      42932\n"
#~ "Jill    45      45324\n"
#~ "\n"
#~ "In addition, the cells A9:B11 contain the following values:\n"
#~ "Age     Salary\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "* If none of the items match the conditions, DGET returns #VALUE! error.\n"
#~ "* If more than one items match the conditions, DGET returns #NUM! error.\n"
#~ "\n"
#~ "DGET(A1:C7, \"Salary\", A9:A10) equals 34323.\n"
#~ "DGET(A1:C7, \"Name\", A9:A10) equals \"Clark\".\n"
#~ "\n"
#~ "@SEEALSO=DCOUNT"
#~ msgstr ""
#~ "@FUNCTION=DGET\n"
#~ "@SYNTAX=DGET(databas;fält;kriteria)\n"
#~ "@DESCRIPTION=DGET funktionen returnerar ett värde från kolumnen som "
#~ "matchar dom givna villkoren.\n"
#~ "\n"
#~ "@databas är ett område av celler där rader av relaterad information är "
#~ "poster och kolumner av data är fält. Den första raden i databasen "
#~ "innehåller etiketter för varje kolumn. \n"
#~ "\n"
#~ "@fält anger vilken kolumn som används i funktionen. Om @fält är ett "
#~ "heltal, 2 till exempel, så används den andra kolumnen. Fält kan också "
#~ "vara en kolumnetikett. Till exempel, ``Ålder'' anger kolumnen med "
#~ "etiketten ``Ålder'' i @databas området. \n"
#~ "\n"
#~ "@kriteria är det cellområde som innehåller de angivna villkoren. Den "
#~ "första raden i @kriteria ska innehålla etiketterna till fälten för vilka "
#~ "kriterierna skall gälla. Celler under etiketterna bestämmer villkoren, "
#~ "till exempel ``>3'' eller ``<9''. Likhetsvillkor anges enkelt genom att "
#~ "ange ett värde, t.ex. ``3'' eller ``Johan''.\n"
#~ "Varje rad i @kriteria anger ett separat villkor, d.v.s. om en rad i "
#~ "@databas matchar en rad i @kriteria så räknas raden in (det är alltså en "
#~ "Boolsk OR mellan raderna i @kriteria).\n"
#~ "Om @kriteria har mer än en kolumn så måste villkoren i varje kolumn "
#~ "matcha motsvarande kolumn i @databas. Tekniskt sett är det en Boolsk AND "
#~ "mellan kolumnerna i @kriteria).\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Låt oss anta att området A1:C7 innehåller föjande värden:\n"
#~ "Namn    Ålder   Lön\n"
#~ "Johan   34      54342\n"
#~ "Billy   35      22343\n"
#~ "Helen   29      34323\n"
#~ "Klas    43      47242\n"
#~ "Susanna 37      42932\n"
#~ "Maria   45      45324\n"
#~ "\n"
#~ "Dessutom innehåller cellerna A9:B11 följande värden:\n"
#~ "Ålder   Lön\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DGET(A1:C7, \"Lön\", A9:A10) är lika med 34323.\n"
#~ "DGET(A1:C7, \"Namn\", A9:A10) är lika med \"Helen\".\n"
#~ "\n"
#~ "@SEEALSO=DCOUNT"

#~ msgid ""
#~ "@FUNCTION=DMAX\n"
#~ "@SYNTAX=DMAX(database,field,criteria)\n"
#~ "@DESCRIPTION=DMAX function returns the largest number in a column that "
#~ "match conditions specified.\n"
#~ "\n"
#~ "@database is a range of cells in which rows of related information are "
#~ "records and columns of data are fields. The first row of a database "
#~ "contains labels for each column. \n"
#~ "\n"
#~ "@field specifies which column is used in the function.  If @field is an "
#~ "integer, for example 2, the second column is used. Field can also be the "
#~ "label of a column.  For example, ``Age'' refers to the column with the "
#~ "label ``Age'' in @database range. \n"
#~ "\n"
#~ "@criteria is the range of cells which contains the specified conditions.  "
#~ "The first row of a @criteria should contain the labels of the fields for "
#~ "which the criteria are for.  Cells below the labels specify conditions, "
#~ "for example, ``>3'' or ``<9''.  Equality condition can be given simply by "
#~ "specifying a value, e.g. ``3'' or ``John''. \n"
#~ "Each row in @criteria specifies a separate condition. If a row in "
#~ "@database matches a row in @criteria, then that row is counted. "
#~ "Technically speaking, this a boolean OR operation between the rows in "
#~ "@criteria.\n"
#~ "If @criteria specifies more than one column, then each of the conditions "
#~ "in the specified columns must be true for the row in @database to match. "
#~ "Technically speaking, this is a boolean AND operation between the columns "
#~ "in @criteria.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the range A1:C7 contain the following values:\n"
#~ "Name    Age     Salary\n"
#~ "John    34      54342\n"
#~ "Bill    35      22343\n"
#~ "Clark   29      34323\n"
#~ "Bob     43      47242\n"
#~ "Susan   37      42932\n"
#~ "Jill    45      45324\n"
#~ "\n"
#~ "In addition, the cells A9:B11 contain the following values:\n"
#~ "Age     Salary\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "DMAX(A1:C7, \"Salary\", A9:A11) equals 47242.\n"
#~ "DMAX(A1:C7, \"Age\", A9:A11) equals 45.\n"
#~ "DMAX(A1:C7, \"Age\", A9:B11) equals 43.\n"
#~ "\n"
#~ "@SEEALSO=DMIN"
#~ msgstr ""
#~ "@FUNCTION=DMAX\n"
#~ "@SYNTAX=DMAX(databas;fält;kriteria)\n"
#~ "@DESCRIPTION=DMAX funktionen returnerar det största värdet i en kolumn "
#~ "som matchar dom angivna villkoren.\n"
#~ "\n"
#~ "@databas är ett område av celler där rader av relaterad information är "
#~ "poster och kolumner av data är fält. Den första raden i databasen "
#~ "innehåller etiketter för varje kolumn. \n"
#~ "\n"
#~ "@fält anger vilken kolumn som används i funktionen. Om @fält är ett "
#~ "heltal, 2 till exempel, så används den andra kolumnen. Fält kan också "
#~ "vara en kolumnetikett. Till exempel, ``Ålder'' anger kolumnen med "
#~ "etiketten ``Ålder'' i @databas området. \n"
#~ "\n"
#~ "@kriteria är det cellområde som innehåller de angivna villkoren. Den "
#~ "första raden i @kriteria ska innehålla etiketterna till fälten för vilka "
#~ "kriterierna skall gälla. Celler under etiketterna bestämmer villkoren, "
#~ "till exempel ``>3'' eller ``<9''. Likhetsvillkor anges enkelt genom att "
#~ "ange ett värde, t.ex. ``3'' eller ``Johan''.\n"
#~ "Varje rad i @kriteria anger ett separat villkor, d.v.s. om en rad i "
#~ "@databas matchar en rad i @kriteria så räknas raden in (det är alltså en "
#~ "Boolsk OR mellan raderna i @kriteria).\n"
#~ "Om @kriteria har mer än en kolumn så måste villkoren i varje kolumn "
#~ "matcha motsvarande kolumn i @databas. Tekniskt sett är det en Boolsk AND "
#~ "mellan kolumnerna i @kriteria).\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Låt oss anta att området A1:C7 innehåller föjande värden:\n"
#~ "Namn    Ålder   Lön\n"
#~ "Johan   34      54342\n"
#~ "Billy   35      22343\n"
#~ "Helen   29      34323\n"
#~ "Klas    43      47242\n"
#~ "Susanna 37      42932\n"
#~ "Maria   45      45324\n"
#~ "\n"
#~ "Dessutom innehåller cellerna A9:B11 följande värden:\n"
#~ "Ålder   Lön\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DMAX(A1:C7, \"Lön\", A9:A11) är lika med 47242.\n"
#~ "DMAX(A1:C7, \"Ålder\", A9:A11) är lika med 45.\n"
#~ "DMAX(A1:C7, \"Ålder\", A9:B11) är lika med 43.\n"
#~ "\n"
#~ "@SEEALSO=DMIN"

#~ msgid ""
#~ "@FUNCTION=DMIN\n"
#~ "@SYNTAX=DMIN(database,field,criteria)\n"
#~ "@DESCRIPTION=DMIN function returns the smallest number in a column that "
#~ "match conditions specified.\n"
#~ "\n"
#~ "@database is a range of cells in which rows of related information are "
#~ "records and columns of data are fields. The first row of a database "
#~ "contains labels for each column. \n"
#~ "\n"
#~ "@field specifies which column is used in the function.  If @field is an "
#~ "integer, for example 2, the second column is used. Field can also be the "
#~ "label of a column.  For example, ``Age'' refers to the column with the "
#~ "label ``Age'' in @database range. \n"
#~ "\n"
#~ "@criteria is the range of cells which contains the specified conditions.  "
#~ "The first row of a @criteria should contain the labels of the fields for "
#~ "which the criteria are for.  Cells below the labels specify conditions, "
#~ "for example, ``>3'' or ``<9''.  Equality condition can be given simply by "
#~ "specifying a value, e.g. ``3'' or ``John''. \n"
#~ "Each row in @criteria specifies a separate condition. If a row in "
#~ "@database matches a row in @criteria, then that row is counted. "
#~ "Technically speaking, this a boolean OR operation between the rows in "
#~ "@criteria.\n"
#~ "If @criteria specifies more than one column, then each of the conditions "
#~ "in the specified columns must be true for the row in @database to match. "
#~ "Technically speaking, this is a boolean AND operation between the columns "
#~ "in @criteria.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the range A1:C7 contain the following values:\n"
#~ "Name    Age     Salary\n"
#~ "John    34      54342\n"
#~ "Bill    35      22343\n"
#~ "Clark   29      34323\n"
#~ "Bob     43      47242\n"
#~ "Susan   37      42932\n"
#~ "Jill    45      45324\n"
#~ "\n"
#~ "In addition, the cells A9:B11 contain the following values:\n"
#~ "Age     Salary\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "DMIN(A1:C7, \"Salary\", A9:B11) equals 34323.\n"
#~ "DMIN(A1:C7, \"Age\", A9:B11) equals 29.\n"
#~ "\n"
#~ "@SEEALSO=DMAX"
#~ msgstr ""
#~ "@FUNCTION=DMIN\n"
#~ "@SYNTAX=DMIN(databas;fält;kriteria)\n"
#~ "@DESCRIPTION=DMIN funktionen returnerar det minsta värdet i en kolumn som "
#~ "matchar dom angivna villkoren.\n"
#~ "\n"
#~ "@databas är ett område av celler där rader av relaterad information är "
#~ "poster och kolumner av data är fält. Den första raden i databasen "
#~ "innehåller etiketter för varje kolumn. \n"
#~ "\n"
#~ "@fält anger vilken kolumn som används i funktionen. Om @fält är ett "
#~ "heltal, 2 till exempel, så används den andra kolumnen. Fält kan också "
#~ "vara en kolumnetikett. Till exempel, ``Ålder'' anger kolumnen med "
#~ "etiketten ``Ålder'' i @databas området. \n"
#~ "\n"
#~ "@kriteria är det cellområde som innehåller de angivna villkoren. Den "
#~ "första raden i @kriteria ska innehålla etiketterna till fälten för vilka "
#~ "kriterierna skall gälla. Celler under etiketterna bestämmer villkoren, "
#~ "till exempel ``>3'' eller ``<9''. Likhetsvillkor anges enkelt genom att "
#~ "ange ett värde, t.ex. ``3'' eller ``Johan''.\n"
#~ "Varje rad i @kriteria anger ett separat villkor, d.v.s. om en rad i "
#~ "@databas matchar en rad i @kriteria så räknas raden in (det är alltså en "
#~ "Boolsk OR mellan raderna i @kriteria).\n"
#~ "Om @kriteria har mer än en kolumn så måste villkoren i varje kolumn "
#~ "matcha motsvarande kolumn i @databas. Tekniskt sett är det en Boolsk AND "
#~ "mellan kolumnerna i @kriteria).\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Låt oss anta att området A1:C7 innehåller föjande värden:\n"
#~ "Namn    Ålder   Lön\n"
#~ "Johan   34      54342\n"
#~ "Billy   35      22343\n"
#~ "Helen   29      34323\n"
#~ "Klas    43      47242\n"
#~ "Susanna 37      42932\n"
#~ "Maria   45      45324\n"
#~ "\n"
#~ "Dessutom innehåller cellerna A9:B11 följande värden:\n"
#~ "Ålder   Lön\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DMIN(A1:C7, \"Lön\", A9:B11) är lika med 34323.\n"
#~ "DMIN(A1:C7, \"Ålder\", A9:B11) är lika med 29.\n"
#~ "\n"
#~ "@SEEALSO=DMAX"

#~ msgid ""
#~ "@FUNCTION=DPRODUCT\n"
#~ "@SYNTAX=DPRODUCT(database,field,criteria)\n"
#~ "@DESCRIPTION=DPRODUCT function returns the product of numbers in a column "
#~ "that match conditions specified.\n"
#~ "\n"
#~ "@database is a range of cells in which rows of related information are "
#~ "records and columns of data are fields. The first row of a database "
#~ "contains labels for each column. \n"
#~ "\n"
#~ "@field specifies which column is used in the function.  If @field is an "
#~ "integer, for example 2, the second column is used. Field can also be the "
#~ "label of a column.  For example, ``Age'' refers to the column with the "
#~ "label ``Age'' in @database range. \n"
#~ "\n"
#~ "@criteria is the range of cells which contains the specified conditions.  "
#~ "The first row of a @criteria should contain the labels of the fields for "
#~ "which the criteria are for.  Cells below the labels specify conditions, "
#~ "for example, ``>3'' or ``<9''.  Equality condition can be given simply by "
#~ "specifying a value, e.g. ``3'' or ``John''. \n"
#~ "Each row in @criteria specifies a separate condition. If a row in "
#~ "@database matches a row in @criteria, then that row is counted. "
#~ "Technically speaking, this a boolean OR operation between the rows in "
#~ "@criteria.\n"
#~ "If @criteria specifies more than one column, then each of the conditions "
#~ "in the specified columns must be true for the row in @database to match. "
#~ "Technically speaking, this is a boolean AND operation between the columns "
#~ "in @criteria.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the range A1:C7 contain the following values:\n"
#~ "Name    Age     Salary\n"
#~ "John    34      54342\n"
#~ "Bill    35      22343\n"
#~ "Clark   29      34323\n"
#~ "Bob     43      47242\n"
#~ "Susan   37      42932\n"
#~ "Jill    45      45324\n"
#~ "\n"
#~ "In addition, the cells A9:B11 contain the following values:\n"
#~ "Age     Salary\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "DPRODUCT(A1:C7, \"Age\", A9:B11) equals 1247.\n"
#~ "\n"
#~ "@SEEALSO=DSUM"
#~ msgstr ""
#~ "@FUNCTION=DPRODUCT\n"
#~ "@SYNTAX=DPRODUCT(databas;fält;kriteria)\n"
#~ "@DESCRIPTION=DPRODUCT funktionen returnerar produkten av värdena i en "
#~ "kolumn som matchar dom angivna villkoren.\n"
#~ "\n"
#~ "@databas är ett område av celler där rader av relaterad information är "
#~ "poster och kolumner av data är fält. Den första raden i databasen "
#~ "innehåller etiketter för varje kolumn. \n"
#~ "\n"
#~ "@fält anger vilken kolumn som används i funktionen. Om @fält är ett "
#~ "heltal, 2 till exempel, så används den andra kolumnen. Fält kan också "
#~ "vara en kolumnetikett. Till exempel, ``Ålder'' anger kolumnen med "
#~ "etiketten ``Ålder'' i @databas området. \n"
#~ "\n"
#~ "@kriteria är det cellområde som innehåller de angivna villkoren. Den "
#~ "första raden i @kriteria ska innehålla etiketterna till fälten för vilka "
#~ "kriterierna skall gälla. Celler under etiketterna bestämmer villkoren, "
#~ "till exempel ``>3'' eller ``<9''. Likhetsvillkor anges enkelt genom att "
#~ "ange ett värde, t.ex. ``3'' eller ``Johan''.\n"
#~ "Varje rad i @kriteria anger ett separat villkor, d.v.s. om en rad i "
#~ "@databas matchar en rad i @kriteria så räknas raden in (det är alltså en "
#~ "Boolsk OR mellan raderna i @kriteria).\n"
#~ "Om @kriteria har mer än en kolumn så måste villkoren i varje kolumn "
#~ "matcha motsvarande kolumn i @databas. Tekniskt sett är det en Boolsk AND "
#~ "mellan kolumnerna i @kriteria).\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Låt oss anta att området A1:C7 innehåller föjande värden:\n"
#~ "Namn    Ålder   Lön\n"
#~ "Johan   34      54342\n"
#~ "Billy   35      22343\n"
#~ "Helen   29      34323\n"
#~ "Klas    43      47242\n"
#~ "Susanna 37      42932\n"
#~ "Maria   45      45324\n"
#~ "\n"
#~ "Dessutom innehåller cellerna A9:B11 följande värden:\n"
#~ "Ålder   Lön\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DPRODUCT(A1:C7, \"Ålder\", A9:B11) är lika med 1247.\n"
#~ "\n"
#~ "@SEEALSO=DSUM"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=DSTDEV\n"
#~ "@SYNTAX=DSTDEV(database,field,criteria)\n"
#~ "@DESCRIPTION=DSTDEV function returns the estimate of the standard "
#~ "deviation of a population based on a sample. The population consists of "
#~ "numbers that match conditions specified.\n"
#~ "\n"
#~ "@database is a range of cells in which rows of related information are "
#~ "records and columns of data are fields. The first row of a database "
#~ "contains labels for each column. \n"
#~ "\n"
#~ "@field specifies which column is used in the function.  If @field is an "
#~ "integer, for example 2, the second column is used. Field can also be the "
#~ "label of a column.  For example, ``Age'' refers to the column with the "
#~ "label ``Age'' in @database range. \n"
#~ "\n"
#~ "@criteria is the range of cells which contains the specified conditions.  "
#~ "The first row of a @criteria should contain the labels of the fields for "
#~ "which the criteria are for.  Cells below the labels specify conditions, "
#~ "for example, ``>3'' or ``<9''.  Equality condition can be given simply by "
#~ "specifying a value, e.g. ``3'' or ``John''. \n"
#~ "Each row in @criteria specifies a separate condition. If a row in "
#~ "@database matches a row in @criteria, then that row is counted. "
#~ "Technically speaking, this a boolean OR operation between the rows in "
#~ "@criteria.\n"
#~ "If @criteria specifies more than one column, then each of the conditions "
#~ "in the specified columns must be true for the row in @database to match. "
#~ "Technically speaking, this is a boolean AND operation between the columns "
#~ "in @criteria.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the range A1:C7 contain the following values:\n"
#~ "Name    Age     Salary\n"
#~ "John    34      54342\n"
#~ "Bill    35      22343\n"
#~ "Clark   29      34323\n"
#~ "Bob     43      47242\n"
#~ "Susan   37      42932\n"
#~ "Jill    45      45324\n"
#~ "\n"
#~ "In addition, the cells A9:B11 contain the following values:\n"
#~ "Age     Salary\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "DSTDEV(A1:C7, \"Age\", A9:B11) equals 9.89949.\n"
#~ "DSTDEV(A1:C7, \"Salary\", A9:B11) equals 9135.112506.\n"
#~ "\n"
#~ "@SEEALSO=DSTDEVP"
#~ msgstr ""
#~ "@FUNCTION=DSTDEV\n"
#~ "@SYNTAX=DSTDEV(databas;fält;kriteria)\n"
#~ "@DESCRIPTION=DSTDEV funktionen returnerar uppskattningen av "
#~ "standardavvikelsen av en population baserade på sampel. Populationen "
#~ "består av de värden som matchar dom angivna villkoren.\n"
#~ "\n"
#~ "@databas är ett område av celler där rader av relaterad information är "
#~ "poster och kolumner av data är fält. Den första raden i databasen "
#~ "innehåller etiketter för varje kolumn. \n"
#~ "\n"
#~ "@fält anger vilken kolumn som används i funktionen. Om @fält är ett "
#~ "heltal, 2 till exempel, så används den andra kolumnen. Fält kan också "
#~ "vara en kolumnetikett. Till exempel, ``Ålder'' anger kolumnen med "
#~ "etiketten ``Ålder'' i @databas området. \n"
#~ "\n"
#~ "@kriteria är det cellområde som innehåller de angivna villkoren. Den "
#~ "första raden i @kriteria ska innehålla etiketterna till fälten för vilka "
#~ "kriterierna skall gälla. Celler under etiketterna bestämmer villkoren, "
#~ "till exempel ``>3'' eller ``<9''. Likhetsvillkor anges enkelt genom att "
#~ "ange ett värde, t.ex. ``3'' eller ``Johan''.\n"
#~ "Varje rad i @kriteria anger ett separat villkor, d.v.s. om en rad i "
#~ "@databas matchar en rad i @kriteria så räknas raden in (det är alltså en "
#~ "Boolsk OR mellan raderna i @kriteria).\n"
#~ "Om @kriteria har mer än en kolumn så måste villkoren i varje kolumn "
#~ "matcha motsvarande kolumn i @databas. Tekniskt sett är det en Boolsk AND "
#~ "mellan kolumnerna i @kriteria).\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Låt oss anta att området A1:C7 innehåller föjande värden:\n"
#~ "Namn    Ålder   Lön\n"
#~ "Johan   34      54342\n"
#~ "Billy   35      22343\n"
#~ "Helen   29      34323\n"
#~ "Klas    43      47242\n"
#~ "Susanna 37      42932\n"
#~ "Maria   45      45324\n"
#~ "\n"
#~ "Dessutom innehåller cellerna A9:B11 följande värden:\n"
#~ "Ålder   Lön\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DSTDEV(A1:C7, \"Ålder\", A9:B11) är lika med 9,89949.\n"
#~ "DSTDEV(A1:C7, \"Lön\", A9:B11) är lika med 9135,112506.\n"
#~ "\n"
#~ "@SEEALSO=DSTDEVP"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=DSTDEVP\n"
#~ "@SYNTAX=DSTDEVP(database,field,criteria)\n"
#~ "@DESCRIPTION=DSTDEVP function returns the standard deviation of a "
#~ "population based on the entire population. The population consists of "
#~ "numbers that match conditions specified.\n"
#~ "\n"
#~ "@database is a range of cells in which rows of related information are "
#~ "records and columns of data are fields. The first row of a database "
#~ "contains labels for each column. \n"
#~ "\n"
#~ "@field specifies which column is used in the function.  If @field is an "
#~ "integer, for example 2, the second column is used. Field can also be the "
#~ "label of a column.  For example, ``Age'' refers to the column with the "
#~ "label ``Age'' in @database range. \n"
#~ "\n"
#~ "@criteria is the range of cells which contains the specified conditions.  "
#~ "The first row of a @criteria should contain the labels of the fields for "
#~ "which the criteria are for.  Cells below the labels specify conditions, "
#~ "for example, ``>3'' or ``<9''.  Equality condition can be given simply by "
#~ "specifying a value, e.g. ``3'' or ``John''. \n"
#~ "Each row in @criteria specifies a separate condition. If a row in "
#~ "@database matches a row in @criteria, then that row is counted. "
#~ "Technically speaking, this a boolean OR operation between the rows in "
#~ "@criteria.\n"
#~ "If @criteria specifies more than one column, then each of the conditions "
#~ "in the specified columns must be true for the row in @database to match. "
#~ "Technically speaking, this is a boolean AND operation between the columns "
#~ "in @criteria.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the range A1:C7 contain the following values:\n"
#~ "Name    Age     Salary\n"
#~ "John    34      54342\n"
#~ "Bill    35      22343\n"
#~ "Clark   29      34323\n"
#~ "Bob     43      47242\n"
#~ "Susan   37      42932\n"
#~ "Jill    45      45324\n"
#~ "\n"
#~ "In addition, the cells A9:B11 contain the following values:\n"
#~ "Age     Salary\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "DSTDEVP(A1:C7, \"Age\", A9:B11) equals 7.\n"
#~ "DSTDEVP(A1:C7, \"Salary\", A9:B11) equals 6459.5.\n"
#~ "\n"
#~ "@SEEALSO=DSTDEV"
#~ msgstr ""
#~ "@FUNCTION=DSTDEVP\n"
#~ "@SYNTAX=DSTDEVP(databas;fält;kriteria)\n"
#~ "@DESCRIPTION=DSTDEVP funktionen returnerar uppskattningen av "
#~ "standardavvikelsen av en population baserad på hela populationen. "
#~ "Populationen består av de värden som matchar dom angivna villkoren.\n"
#~ "\n"
#~ "@databas är ett område av celler där rader av relaterad information är "
#~ "poster och kolumner av data är fält. Den första raden i databasen "
#~ "innehåller etiketter för varje kolumn. \n"
#~ "\n"
#~ "@fält anger vilken kolumn som används i funktionen. Om @fält är ett "
#~ "heltal, 2 till exempel, så används den andra kolumnen. Fält kan också "
#~ "vara en kolumnetikett. Till exempel, ``Ålder'' anger kolumnen med "
#~ "etiketten ``Ålder'' i @databas området. \n"
#~ "\n"
#~ "@kriteria är det cellområde som innehåller de angivna villkoren. Den "
#~ "första raden i @kriteria ska innehålla etiketterna till fälten för vilka "
#~ "kriterierna skall gälla. Celler under etiketterna bestämmer villkoren, "
#~ "till exempel ``>3'' eller ``<9''. Likhetsvillkor anges enkelt genom att "
#~ "ange ett värde, t.ex. ``3'' eller ``Johan''.\n"
#~ "Varje rad i @kriteria anger ett separat villkor, d.v.s. om en rad i "
#~ "@databas matchar en rad i @kriteria så räknas raden in (det är alltså en "
#~ "Boolsk OR mellan raderna i @kriteria).\n"
#~ "Om @kriteria har mer än en kolumn så måste villkoren i varje kolumn "
#~ "matcha motsvarande kolumn i @databas. Tekniskt sett är det en Boolsk AND "
#~ "mellan kolumnerna i @kriteria).\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Låt oss anta att området A1:C7 innehåller föjande värden:\n"
#~ "Namn    Ålder   Lön\n"
#~ "Johan   34      54342\n"
#~ "Billy   35      22343\n"
#~ "Helen   29      34323\n"
#~ "Klas    43      47242\n"
#~ "Susanna 37      42932\n"
#~ "Maria   45      45324\n"
#~ "\n"
#~ "Dessutom innehåller cellerna A9:B11 följande värden:\n"
#~ "Ålder   Lön\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DSTDEVP(A1:C7, \"Ålder\", A9:B11) är lika med 7.\n"
#~ "DSTDEVP(A1:C7, \"Lön\", A9:B11) är lika med 6459,5.\n"
#~ "\n"
#~ "@SEEALSO=DSTDEV"

#~ msgid ""
#~ "@FUNCTION=DSUM\n"
#~ "@SYNTAX=DSUM(database,field,criteria)\n"
#~ "@DESCRIPTION=DSUM function returns the sum of numbers in a column that "
#~ "match conditions specified.\n"
#~ "\n"
#~ "@database is a range of cells in which rows of related information are "
#~ "records and columns of data are fields. The first row of a database "
#~ "contains labels for each column. \n"
#~ "\n"
#~ "@field specifies which column is used in the function.  If @field is an "
#~ "integer, for example 2, the second column is used. Field can also be the "
#~ "label of a column.  For example, ``Age'' refers to the column with the "
#~ "label ``Age'' in @database range. \n"
#~ "\n"
#~ "@criteria is the range of cells which contains the specified conditions.  "
#~ "The first row of a @criteria should contain the labels of the fields for "
#~ "which the criteria are for.  Cells below the labels specify conditions, "
#~ "for example, ``>3'' or ``<9''.  Equality condition can be given simply by "
#~ "specifying a value, e.g. ``3'' or ``John''. \n"
#~ "Each row in @criteria specifies a separate condition. If a row in "
#~ "@database matches a row in @criteria, then that row is counted. "
#~ "Technically speaking, this a boolean OR operation between the rows in "
#~ "@criteria.\n"
#~ "If @criteria specifies more than one column, then each of the conditions "
#~ "in the specified columns must be true for the row in @database to match. "
#~ "Technically speaking, this is a boolean AND operation between the columns "
#~ "in @criteria.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the range A1:C7 contain the following values:\n"
#~ "Name    Age     Salary\n"
#~ "John    34      54342\n"
#~ "Bill    35      22343\n"
#~ "Clark   29      34323\n"
#~ "Bob     43      47242\n"
#~ "Susan   37      42932\n"
#~ "Jill    45      45324\n"
#~ "\n"
#~ "In addition, the cells A9:B11 contain the following values:\n"
#~ "Age     Salary\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "DSUM(A1:C7, \"Age\", A9:B11) equals 72.\n"
#~ "DSUM(A1:C7, \"Salary\", A9:B11) equals 81565.\n"
#~ "\n"
#~ "@SEEALSO=DPRODUCT"
#~ msgstr ""
#~ "@FUNCTION=DSUM\n"
#~ "@SYNTAX=DSUM(databas;fält;kriteria)\n"
#~ "@DESCRIPTION=DSUM funktionen returnerar summan av en kolumn som matchar "
#~ "dom angivna villkoren.\n"
#~ "\n"
#~ "@databas är ett område av celler där rader av relaterad information är "
#~ "poster och kolumner av data är fält. Den första raden i databasen "
#~ "innehåller etiketter för varje kolumn. \n"
#~ "\n"
#~ "@fält anger vilken kolumn som används i funktionen. Om @fält är ett "
#~ "heltal, 2 till exempel, så används den andra kolumnen. Fält kan också "
#~ "vara en kolumnetikett. Till exempel, ``Ålder'' anger kolumnen med "
#~ "etiketten ``Ålder'' i @databas området. \n"
#~ "\n"
#~ "@kriteria är det cellområde som innehåller de angivna villkoren. Den "
#~ "första raden i @kriteria ska innehålla etiketterna till fälten för vilka "
#~ "kriterierna skall gälla. Celler under etiketterna bestämmer villkoren, "
#~ "till exempel ``>3'' eller ``<9''. Likhetsvillkor anges enkelt genom att "
#~ "ange ett värde, t.ex. ``3'' eller ``Johan''.\n"
#~ "Varje rad i @kriteria anger ett separat villkor, d.v.s. om en rad i "
#~ "@databas matchar en rad i @kriteria så räknas raden in (det är alltså en "
#~ "Boolsk OR mellan raderna i @kriteria).\n"
#~ "Om @kriteria har mer än en kolumn så måste villkoren i varje kolumn "
#~ "matcha motsvarande kolumn i @databas. Tekniskt sett är det en Boolsk AND "
#~ "mellan kolumnerna i @kriteria).\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Låt oss anta att området A1:C7 innehåller föjande värden:\n"
#~ "Namn    Ålder   Lön\n"
#~ "Johan   34      54342\n"
#~ "Billy   35      22343\n"
#~ "Helen   29      34323\n"
#~ "Klas    43      47242\n"
#~ "Susanna 37      42932\n"
#~ "Maria   45      45324\n"
#~ "\n"
#~ "Dessutom innehåller cellerna A9:B11 följande värden:\n"
#~ "Ålder   Lön\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DSUM(A1:C7, \"Ålder\", A9:B11) är lika med 72.\n"
#~ "DSUM(A1:C7, \"Lön\", A9:B11) är lika med 81565.\n"
#~ "\n"
#~ "@SEEALSO=DPRODUCT"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=DVAR\n"
#~ "@SYNTAX=DVAR(database,field,criteria)\n"
#~ "@DESCRIPTION=DVAR function returns the estimate of variance of a "
#~ "population based on a sample. The population consists of numbers that "
#~ "match conditions specified.\n"
#~ "\n"
#~ "@database is a range of cells in which rows of related information are "
#~ "records and columns of data are fields. The first row of a database "
#~ "contains labels for each column. \n"
#~ "\n"
#~ "@field specifies which column is used in the function.  If @field is an "
#~ "integer, for example 2, the second column is used. Field can also be the "
#~ "label of a column.  For example, ``Age'' refers to the column with the "
#~ "label ``Age'' in @database range. \n"
#~ "\n"
#~ "@criteria is the range of cells which contains the specified conditions.  "
#~ "The first row of a @criteria should contain the labels of the fields for "
#~ "which the criteria are for.  Cells below the labels specify conditions, "
#~ "for example, ``>3'' or ``<9''.  Equality condition can be given simply by "
#~ "specifying a value, e.g. ``3'' or ``John''. \n"
#~ "Each row in @criteria specifies a separate condition. If a row in "
#~ "@database matches a row in @criteria, then that row is counted. "
#~ "Technically speaking, this a boolean OR operation between the rows in "
#~ "@criteria.\n"
#~ "If @criteria specifies more than one column, then each of the conditions "
#~ "in the specified columns must be true for the row in @database to match. "
#~ "Technically speaking, this is a boolean AND operation between the columns "
#~ "in @criteria.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the range A1:C7 contain the following values:\n"
#~ "Name    Age     Salary\n"
#~ "John    34      54342\n"
#~ "Bill    35      22343\n"
#~ "Clark   29      34323\n"
#~ "Bob     43      47242\n"
#~ "Susan   37      42932\n"
#~ "Jill    45      45324\n"
#~ "\n"
#~ "In addition, the cells A9:B11 contain the following values:\n"
#~ "Age     Salary\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "DVAR(A1:C7, \"Age\", A9:B11) equals 98.\n"
#~ "DVAR(A1:C7, \"Salary\", A9:B11) equals 83450280.5.\n"
#~ "\n"
#~ "@SEEALSO=DVARP"
#~ msgstr ""
#~ "@FUNCTION=DVAR\n"
#~ "@SYNTAX=DVAR(databas;fält;kriteria)\n"
#~ "@DESCRIPTION=DVAR funktionen returnerar en uppskattning av variansen hos "
#~ "en population baserad på ett sampel. Populationen består av värden som "
#~ "matchar dom angivna villkoren.\n"
#~ "\n"
#~ "@databas är ett område av celler där rader av relaterad information är "
#~ "poster och kolumner av data är fält. Den första raden i databasen "
#~ "innehåller etiketter för varje kolumn. \n"
#~ "\n"
#~ "@fält anger vilken kolumn som används i funktionen. Om @fält är ett "
#~ "heltal, 2 till exempel, så används den andra kolumnen. Fält kan också "
#~ "vara en kolumnetikett. Till exempel, ``Ålder'' anger kolumnen med "
#~ "etiketten ``Ålder'' i @databas området. \n"
#~ "\n"
#~ "@kriteria är det cellområde som innehåller de angivna villkoren. Den "
#~ "första raden i @kriteria ska innehålla etiketterna till fälten för vilka "
#~ "kriterierna skall gälla. Celler under etiketterna bestämmer villkoren, "
#~ "till exempel ``>3'' eller ``<9''. Likhetsvillkor anges enkelt genom att "
#~ "ange ett värde, t.ex. ``3'' eller ``Johan''.\n"
#~ "Varje rad i @kriteria anger ett separat villkor, d.v.s. om en rad i "
#~ "@databas matchar en rad i @kriteria så räknas raden in (det är alltså en "
#~ "Boolsk OR mellan raderna i @kriteria).\n"
#~ "Om @kriteria har mer än en kolumn så måste villkoren i varje kolumn "
#~ "matcha motsvarande kolumn i @databas. Tekniskt sett är det en Boolsk AND "
#~ "mellan kolumnerna i @kriteria).\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Låt oss anta att området A1:C7 innehåller föjande värden:\n"
#~ "Namn    Ålder   Lön\n"
#~ "Johan   34      54342\n"
#~ "Billy   35      22343\n"
#~ "Helen   29      34323\n"
#~ "Klas    43      47242\n"
#~ "Susanna 37      42932\n"
#~ "Maria   45      45324\n"
#~ "\n"
#~ "Dessutom innehåller cellerna A9:B11 följande värden:\n"
#~ "Ålder   Lön\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DVAR(A1:C7, \"Ålder\", A9:B11) är lika med 98.\n"
#~ "DVAR(A1:C7, \"Lön\", A9:B11) är lika med 83450280,5.\n"
#~ "\n"
#~ "@SEEALSO=DVARP"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=DVARP\n"
#~ "@SYNTAX=DVARP(database,field,criteria)\n"
#~ "@DESCRIPTION=DVARP function returns the variance of a population based on "
#~ "the entire population. The population consists of numbers that match "
#~ "conditions specified.\n"
#~ "\n"
#~ "@database is a range of cells in which rows of related information are "
#~ "records and columns of data are fields. The first row of a database "
#~ "contains labels for each column. \n"
#~ "\n"
#~ "@field specifies which column is used in the function.  If @field is an "
#~ "integer, for example 2, the second column is used. Field can also be the "
#~ "label of a column.  For example, ``Age'' refers to the column with the "
#~ "label ``Age'' in @database range. \n"
#~ "\n"
#~ "@criteria is the range of cells which contains the specified conditions.  "
#~ "The first row of a @criteria should contain the labels of the fields for "
#~ "which the criteria are for.  Cells below the labels specify conditions, "
#~ "for example, ``>3'' or ``<9''.  Equality condition can be given simply by "
#~ "specifying a value, e.g. ``3'' or ``John''. \n"
#~ "Each row in @criteria specifies a separate condition. If a row in "
#~ "@database matches a row in @criteria, then that row is counted. "
#~ "Technically speaking, this a boolean OR operation between the rows in "
#~ "@criteria.\n"
#~ "If @criteria specifies more than one column, then each of the conditions "
#~ "in the specified columns must be true for the row in @database to match. "
#~ "Technically speaking, this is a boolean AND operation between the columns "
#~ "in @criteria.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the range A1:C7 contain the following values:\n"
#~ "Name    Age     Salary\n"
#~ "John    34      54342\n"
#~ "Bill    35      22343\n"
#~ "Clark   29      34323\n"
#~ "Bob     43      47242\n"
#~ "Susan   37      42932\n"
#~ "Jill    45      45324\n"
#~ "\n"
#~ "In addition, the cells A9:B11 contain the following values:\n"
#~ "Age     Salary\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "DVARP(A1:C7, \"Age\", A9:B11) equals 49.\n"
#~ "DVARP(A1:C7, \"Salary\", A9:B11) equals 41725140.25.\n"
#~ "\n"
#~ "@SEEALSO=DVAR"
#~ msgstr ""
#~ "@FUNCTION=DVARP\n"
#~ "@SYNTAX=DVARP(databas;fält;kriteria)\n"
#~ "@DESCRIPTION=DVARP funktionen returnerar en uppskattning av variansen hos "
#~ "en population baserad på hela populationen. Populationen består av värden "
#~ "som matchar dom angivna villkoren.\n"
#~ "\n"
#~ "@databas är ett område av celler där rader av relaterad information är "
#~ "poster och kolumner av data är fält. Den första raden i databasen "
#~ "innehåller etiketter för varje kolumn. \n"
#~ "\n"
#~ "@fält anger vilken kolumn som används i funktionen. Om @fält är ett "
#~ "heltal, 2 till exempel, så används den andra kolumnen. Fält kan också "
#~ "vara en kolumnetikett. Till exempel, ``Ålder'' anger kolumnen med "
#~ "etiketten ``Ålder'' i @databas området. \n"
#~ "\n"
#~ "@kriteria är det cellområde som innehåller de angivna villkoren. Den "
#~ "första raden i @kriteria ska innehålla etiketterna till fälten för vilka "
#~ "kriterierna skall gälla. Celler under etiketterna bestämmer villkoren, "
#~ "till exempel ``>3'' eller ``<9''. Likhetsvillkor anges enkelt genom att "
#~ "ange ett värde, t.ex. ``3'' eller ``Johan''.\n"
#~ "Varje rad i @kriteria anger ett separat villkor, d.v.s. om en rad i "
#~ "@databas matchar en rad i @kriteria så räknas raden in (det är alltså en "
#~ "Boolsk OR mellan raderna i @kriteria).\n"
#~ "Om @kriteria har mer än en kolumn så måste villkoren i varje kolumn "
#~ "matcha motsvarande kolumn i @databas. Tekniskt sett är det en Boolsk AND "
#~ "mellan kolumnerna i @kriteria).\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Låt oss anta att området A1:C7 innehåller föjande värden:\n"
#~ "Namn    Ålder   Lön\n"
#~ "Johan   34      54342\n"
#~ "Billy   35      22343\n"
#~ "Helen   29      34323\n"
#~ "Klas    43      47242\n"
#~ "Susanna 37      42932\n"
#~ "Maria   45      45324\n"
#~ "\n"
#~ "Dessutom innehåller cellerna A9:B11 följande värden:\n"
#~ "Ålder   Lön\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DVARP(A1:C7, \"Ålder\", A9:B11) är lika med 49.\n"
#~ "DVARP(A1:C7, \"Lön\", A9:B11) är lika med 41725140,25.\n"
#~ "\n"
#~ "@SEEALSO=DVAR"

#~ msgid ""
#~ "@FUNCTION=GETPIVOTDATA\n"
#~ "@SYNTAX=GETPIVOTDATA(pivot_table,field_name)\n"
#~ "@DESCRIPTION=GETPIVOTDATA function fetches summary data from a pivot "
#~ "table. @pivot_table is a cell range containing the pivot table. "
#~ "@field_name is the name of the field of which you want the summary data.\n"
#~ "\n"
#~ "* If the summary data is unavailable, GETPIVOTDATA returns #REF! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=GETPIVOTDATA\n"
#~ "@SYNTAX=GETPIVOTDATA(pivottabell;fältnamn)\n"
#~ "@DESCRIPTION=Funktionen GETPIVOTDATA hämtar sammanfattningsdata från en "
#~ "pivottabell. @pivottabell är cellområdet som innehåller pivottabellen. "
#~ "@fältnamn är namnet på fältet ur vilket du vill ha sammanfattningsdata.\n"
#~ "\n"
#~ "* Om sammanfattningsdata inte är tillgänglig returnerar GETPIVOTDATA "
#~ "felvärdet #REF!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=DATE\n"
#~ "@SYNTAX=DATE (year,month,day)\n"
#~ "@DESCRIPTION=DATE returns the number of days since the 1st of January of "
#~ "1900(the date serial number) for the given year, month and day.\n"
#~ "\n"
#~ "* If @month < 1 or @month > 12, the year will be corrected.  A similar "
#~ "correction takes place for days.\n"
#~ "* The @years should be at least 1900.  If @years < 1900, it is assumed to "
#~ "be 1900 + @years.\n"
#~ "* If the given date is not valid, DATE returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DATE(2001, 3, 30) returns 'Mar 30, 2001'.\n"
#~ " \n"
#~ "@SEEALSO=TODAY, NOW"
#~ msgstr ""
#~ "@FUNCTION=DATE\n"
#~ "SYNTAX=DATE (år;månad;dag)\n"
#~ "@DESCRIPTION=DATE returnerar antalet dagar sedan 1 januari 1900 (datumets "
#~ "serienummer) för angivet år, månad och dag.\n"
#~ "\n"
#~ "* Om @månad < 1 eller @månad > 12 kommer året att korrigeras. En liknande "
#~ "korrigering sker för dagarna.\n"
#~ "* @år skall vara minst 1900. Om @år < 1900 antas det vara 1900 + @år.\n"
#~ "* Om det angivna datumet inte är giltigt returnerar DATE felvärdet "
#~ "#NUM!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DATE(2001; 3; 30) returnerar \"Mar 30, 2001\".\n"
#~ "\n"
#~ "@SEEALSO=TODAY, NOW"

#~ msgid ""
#~ "@FUNCTION=UNIX2DATE\n"
#~ "@SYNTAX=UNIX2DATE(unixtime)\n"
#~ "@DESCRIPTION=UNIX2DATE converts a unix time into a spreadsheet date and "
#~ "time.\n"
#~ "\n"
#~ "A unix time is the number of seconds since midnight January 1, 1970.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=NOW, DATE, DATE2UNIX"
#~ msgstr ""
#~ "@FUNCTION=UNIX2DATE\n"
#~ "@SYNTAX=UNIX2DATE(unixtid)\n"
#~ "@DESCRIPTION=UNIX2DATE konverterar en unixtid till ett kalkylbladsdatum "
#~ "och tid.\n"
#~ "\n"
#~ "En unixtid är antalet sekunder sedan midnatt den 1 januari 1970.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=NOW, DATE, DATE2UNIX"

#~ msgid ""
#~ "@FUNCTION=DATE2UNIX\n"
#~ "@SYNTAX=DATE2UNIX(serial)\n"
#~ "@DESCRIPTION=DATE2UNIX converts a spreadsheet date and time serial number "
#~ "into a unix time.\n"
#~ "\n"
#~ "A unix time is the number of seconds since midnight January 1, 1970.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DATE2UNIX(\"01/01/2000\") equals 946656000.\n"
#~ "\n"
#~ "@SEEALSO=NOW, DATE, UNIX2DATE"
#~ msgstr ""
#~ "@FUNCTION=DATE2UNIX\n"
#~ "@SYNTAX=DATE2UNIX(serienummer)\n"
#~ "@DESCRIPTION=DATE2UNIX konverterar ett kalkylbladsdatum och "
#~ "tidsserienummer till en unixtid.\n"
#~ "\n"
#~ "En unixtid är antalet sekunder sedan midnatt den 1 januari 1970.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=NOW, DATE, UNIX2DATE"

#~ msgid ""
#~ "@FUNCTION=DATEVALUE\n"
#~ "@SYNTAX=DATEVALUE(date_str)\n"
#~ "@DESCRIPTION=DATEVALUE returns the serial number of the date.  @date_str "
#~ "is the string that contains the date. The value depends on the date "
#~ "convention.  The MS Excel 1900 convention dates things from Jan 1 1900 "
#~ "while the 1904 convention uses Jan 1 1904.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DATEVALUE(\"1/1/1999\") equals 36161 (in the 1900 convention).\n"
#~ "@SEEALSO=DATE"
#~ msgstr ""
#~ "@FUNCTION=DATEVALUE\n"
#~ "@SYNTAX=DATEVALUE(datum_str)\n"
#~ "@DESCRIPTION=DATEVALUE returnerar datumets serienummer. @datum_str är "
#~ "strängen som innehåller datumet. Värdet beror på datumkonventionen. MS "
#~ "Excel 1900-konventionen daterar saker från 1:a januari, 1900, medan 1904-"
#~ "konventionen använder 1:a januari, 1904.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DATEVALUE(\"1/1/1999\") är lika med 36161 (i 1900-konventionen).\n"
#~ "@SEEALSO=DATE"

#~ msgid ""
#~ "@FUNCTION=DATEDIF\n"
#~ "@SYNTAX=DATEDIF(date1,date2,interval)\n"
#~ "@DESCRIPTION=DATEDIF returns the difference between two dates.  @interval "
#~ "is one of six possible values:  \"y\", \"m\", \"d\", \"ym\", \"md\", and "
#~ "\"yd\".\n"
#~ "\n"
#~ "The first three options will return the number of complete years, months, "
#~ "or days, respectively, between the two dates specified.\n"
#~ "\n"
#~ "  \"ym\" will return the number of full months between the two dates, not "
#~ "including the difference in years.\n"
#~ "  \"md\" will return the number of full days between the two dates, not "
#~ "including the difference in months.\n"
#~ "  \"yd\" will return the number of full days between the two dates, not "
#~ "including the difference in years.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DATEDIF(DATE(2000,4,30),DATE(2003,8,4),\"d\") equals 1191.\n"
#~ "DATEDIF(DATE(2000,4,30),DATE(2003,8,4),\"y\") equals 3.\n"
#~ "\n"
#~ "@SEEALSO=DATE"
#~ msgstr ""
#~ "@FUNCTION=DATEDIF\n"
#~ "@SYNTAX=DATEDIF(datum1;datum2;intervall)\n"
#~ "@DESCRIPTION=DATEDIF returnerar skillnaden mellan två datum. @intervall "
#~ "är ett av sex möjliga värden:  \"y\", \"m\", \"d\", \"ym\", \"md\" och "
#~ "\"yd\".\n"
#~ "\n"
#~ "De första tre alternativen kommer att returnera antalet hela år, "
#~ "respektive månader eller dagar mellan de två angivna datumen.\n"
#~ "\n"
#~ "  \"ym\" kommer att returnera antalet hela månader mellan två datum, där "
#~ "skillnaden i år inte tas med.\n"
#~ "  \"md\" kommer att returnera antalet hela dagar mellan datumen, där "
#~ "skillnaden i månader inte tas med.\n"
#~ "  \"yd\" kommer att returnera antalet hela dagar mellan datumen, där "
#~ "skillnaden i år inte tas med.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DATEDIF(DATE(2000;4;30);DATE(2003;8;4);\"d\") är lika med 1191.\n"
#~ "DATEDIF(DATE(2000;4;30);DATE(2003;8;4);\"y\") är lika med 3.\n"
#~ "\n"
#~ "@SEEALSO=DATE"

#~ msgid ""
#~ "@FUNCTION=EDATE\n"
#~ "@SYNTAX=EDATE(date,months)\n"
#~ "@DESCRIPTION=EDATE returns the serial number of the date that is the "
#~ "specified number of months before or after a given date.  @date is the "
#~ "serial number of the initial date and @months is the number of months "
#~ "before (negative number) or after (positive number) the initial date.\n"
#~ "\n"
#~ "* If @months is not an integer, it is truncated.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "EDATE(DATE(2001,12,30),2) returns 'Feb 28, 2002'.\n"
#~ "\n"
#~ "@SEEALSO=DATE"
#~ msgstr ""
#~ "@FUNCTION=EDATE\n"
#~ "@SYNTAX=EDATE(datum;månader)\n"
#~ "@DESCRIPTION=EDATE returnerar serienumret för datumet som är det angivna "
#~ "antalet månader före eller efter ett givet datum.  @datum är serienumret "
#~ "för startdatumet och @månader är antalet månader före (negativt tal) "
#~ "eller efter (positivt tal) det ursprungliga datumet.\n"
#~ "\n"
#~ "* Om @månader inte är ett heltal, avrundas det till närmsta lägre "
#~ "heltal.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "EDATE(DATE(2001;12;30);2) returnerar \"2/28/02\".\n"
#~ "\n"
#~ "@SEEALSO=DATE"

#~ msgid ""
#~ "@FUNCTION=TODAY\n"
#~ "@SYNTAX=TODAY()\n"
#~ "@DESCRIPTION=TODAY returns the serial number for today (the number of "
#~ "days elapsed since the 1st of January of 1900).\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TODAY() returns 'Nov 6, 2001' on that particular day.\n"
#~ " \n"
#~ "@SEEALSO=NOW"
#~ msgstr ""
#~ "@FUNCTION=TODAY\n"
#~ "@SYNTAX=TODAY()\n"
#~ "@DESCRIPTION=TODAY returnerar serienumret för dagens datum (antalet dagar "
#~ "som har gått sedan den första januari 1900).\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TODAY() returnerar \"Nov 6, 2001\" just den dagen.\n"
#~ "\n"
#~ "@SEEALSO=NOW"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=NOW\n"
#~ "@SYNTAX=NOW ()\n"
#~ "@DESCRIPTION=NOW returns the serial number for the date and time at the "
#~ "time it is evaluated.\n"
#~ "\n"
#~ "Serial Numbers in Gnumeric are represented as follows: The integral part "
#~ "is the number of days since the 1st of January of 1900.  The decimal part "
#~ "represent the fraction of the day and is mapped into hour, minutes and "
#~ "seconds.\n"
#~ "\n"
#~ "For example: .0 represents the beginning of the day, and 0.5 represents "
#~ "noon.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "NOW().\n"
#~ "\n"
#~ "@SEEALSO=TODAY"
#~ msgstr ""
#~ "@FUNCTION=NOW\n"
#~ "@SYNTAX=NOW ()\n"
#~ "@DESCRIPTION=NOW returnerar serienumret för datumet och klockslaget då "
#~ "uttrycket evalueras.\n"
#~ "\n"
#~ "Serienummer i Gnumeric representeras enligt följande: Heltalsdelen är det "
#~ "antal dagar som passerat sedan 1 januari 1900. Decimaldelen representerar "
#~ "hur stor del av dagen som passerat, och avbildas i timmar, minuter och "
#~ "sekunder.\n"
#~ "\n"
#~ "Till exempel: 0,0 representerar början av dagen, och 0,5 mitt på dagen.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "NOW().\n"
#~ "\n"
#~ "@SEEALSO=TODAY"

#~ msgid ""
#~ "@FUNCTION=TIME\n"
#~ "@SYNTAX=TIME (hours,minutes,seconds)\n"
#~ "@DESCRIPTION=TIME returns a fraction representing the time of day.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TIME(3, 5, 23) equals 3:05AM.\n"
#~ "\n"
#~ "@SEEALSO=HOUR"
#~ msgstr ""
#~ "@FUNCTION=TIME\n"
#~ "@SYNTAX=TIME (timmar;minuter;sekunder)\n"
#~ "@DESCRIPTION=TIME returnerar ett tal mellan 0 och 1 som representerar det "
#~ "angivna klockslaget.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TIME(3; 5; 23) är lika med 3:05AM.\n"
#~ "\n"
#~ "@SEEALSO=HOUR"

#~ msgid ""
#~ "@FUNCTION=TIMEVALUE\n"
#~ "@SYNTAX=TIMEVALUE (timetext)\n"
#~ "@DESCRIPTION=TIMEVALUE returns a fraction representing the time of day, a "
#~ "number between 0 and 1.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TIMEVALUE(\"3:05\") equals 0.128472.\n"
#~ "TIMEVALUE(\"2:24:53 PM\") equals 0.600613.\n"
#~ "\n"
#~ "@SEEALSO=HOUR,MINUTE"
#~ msgstr ""
#~ "@FUNCTION=TIMEVALUE\n"
#~ "@SYNTAX=TIMEVALUE (tidstext)\n"
#~ "@DESCRIPTION=Returnerar ett tal mellan 0 och 1 som representerar det "
#~ "angivna klockslaget.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TIMEVALUE(\"3:05\") är lika med 0,128472.\n"
#~ "TIMEVALUE(\"2:24:53 PM\") är lika med 0,600613.\n"
#~ "\n"
#~ "@SEEALSO=HOUR,MINUTE"

#~ msgid ""
#~ "@FUNCTION=HOUR\n"
#~ "@SYNTAX=HOUR (date)\n"
#~ "@DESCRIPTION=HOUR converts a serial number to an hour.  The hour is "
#~ "returned as an integer in the range 0 (12:00 A.M.) to 23 (11:00 P.M.).\n"
#~ "\n"
#~ "* Note that Gnumeric will perform regular string to serial number "
#~ "conversion for you, so you can enter a date as a string.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "HOUR(0.128472) equals 3.\n"
#~ "\n"
#~ "@SEEALSO=MINUTE, NOW, TIME, SECOND"
#~ msgstr ""
#~ "@FUNCTION=HOUR\n"
#~ "@SYNTAX=HOUR (datum)\n"
#~ "@DESCRIPTION=HOUR konventerar från serienummer till timme. Resultatet ges "
#~ "i form av ett heltal i området 0 (12:00 AM) till 23 (11:00 PM).\n"
#~ "\n"
#~ "* Observera att datumet kan anges som en sträng, eftersom Gnumeric "
#~ "automatiskt konverterar strängen till ett serienummer.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "HOUR(0,128472) är lika med 3.\n"
#~ "\n"
#~ "@SEEALSO=MINUTE, NOW, TIME, SECOND"

#~ msgid ""
#~ "@FUNCTION=MINUTE\n"
#~ "@SYNTAX=MINUTE (date)\n"
#~ "@DESCRIPTION=MINUTE converts a serial number to a minute.  The minute is "
#~ "returned as an integer in the range 0 to 59.\n"
#~ "\n"
#~ "* Note that Gnumeric will perform regular string to serial number "
#~ "conversion for you, so you can enter a date as a string.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "MINUTE(0.128472) equals 5.\n"
#~ "\n"
#~ "@SEEALSO=HOUR, NOW, TIME, SECOND"
#~ msgstr ""
#~ "@FUNCTION=MINUTE\n"
#~ "@SYNTAX=MINUTE (datum)\n"
#~ "@DESCRIPTION=MINUTE konverterar från serienummer till minut. Resultatet "
#~ "ges i form av ett heltal i området 0 till 59.\n"
#~ "\n"
#~ "* Observera att datumet kan anges som en sträng, eftersom Gnumeric "
#~ "automatiskt konverterar strängen till ett serienummer.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "MINUTE(0,128472) är lika med 5.\n"
#~ "\n"
#~ "@SEEALSO=HOUR, NOW, TIME, SECOND"

#~ msgid ""
#~ "@FUNCTION=SECOND\n"
#~ "@SYNTAX=SECOND (date)\n"
#~ "@DESCRIPTION=SECOND converts a serial number to a second.  The second is "
#~ "returned as an integer in the range 0 to 59.\n"
#~ "\n"
#~ "* Note that Gnumeric will perform regular string to serial number "
#~ "conversion for you, so you can enter a date as a string.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "SECOND(0.600613) equals 53.\n"
#~ "\n"
#~ "@SEEALSO=HOUR, MINUTE, NOW, TIME"
#~ msgstr ""
#~ "@FUNCTION=SECOND\n"
#~ "@SYNTAX=SECOND (datum)\n"
#~ "@DESCRIPTION=SECOND konverterar från serienummer till sekund. Resultatet "
#~ "ges i form av ett heltal i området 0 till 59.\n"
#~ "\n"
#~ "* Observera att datumet kan anges som en sträng, eftersom Gnumeric "
#~ "automatiskt konverterar strängen till ett serienummer.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "SECOND(0,600613) är lika med 53.\n"
#~ "\n"
#~ "@SEEALSO=HOUR, MINUTE, NOW, TIME"

#~ msgid ""
#~ "@FUNCTION=YEAR\n"
#~ "@SYNTAX=YEAR (date)\n"
#~ "@DESCRIPTION=YEAR converts a serial number to a year.\n"
#~ "\n"
#~ "* Note that Gnumeric will perform regular string to serial number "
#~ "conversion for you, so you can enter a date as a string.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "YEAR(DATE(2003, 4, 30)) equals 2003.\n"
#~ "\n"
#~ "@SEEALSO=DAY, MONTH, TIME, NOW"
#~ msgstr ""
#~ "@FUNCTION=YEAR\n"
#~ "@SYNTAX=YEAR (datum)\n"
#~ "@DESCRIPTION=Konverterar från serienummer till år.\n"
#~ "\n"
#~ "* Observera att datumet kan anges som en sträng, eftersom Gnumeric "
#~ "automatiskt konverterar strängen till ett serienummer.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "YEAR(DATE(2003; 4; 30)) är lika med 2003.\n"
#~ "\n"
#~ "@SEEALSO=DAY, MONTH, TIME, NOW"

#~ msgid ""
#~ "@FUNCTION=MONTH\n"
#~ "@SYNTAX=MONTH (date)\n"
#~ "@DESCRIPTION=MONTH converts a serial number to a month.\n"
#~ "\n"
#~ "* Note that Gnumeric will perform regular string to serial number "
#~ "conversion for you, so you can enter a date as a string.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "MONTH(DATE(2003, 4, 30)) equals 4.\n"
#~ "\n"
#~ "@SEEALSO=DAY, TIME, NOW, YEAR"
#~ msgstr ""
#~ "@FUNCTION=MONTH\n"
#~ "@SYNTAX=MONTH (datum)\n"
#~ "@DESCRIPTION=MONTH konverterar från serienummer till månad.\n"
#~ "\n"
#~ "* Observera att datumet kan anges som en sträng, eftersom Gnumeric "
#~ "automatiskt konverterar strängen till ett serienummer.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "MONTH(DATE(2003; 4; 30)) är lika med 4.\n"
#~ "\n"
#~ "@SEEALSO=DAY, TIME, NOW, YEAR"

#~ msgid ""
#~ "@FUNCTION=DAY\n"
#~ "@SYNTAX=DAY (date)\n"
#~ "@DESCRIPTION=DAY converts a serial number to a day of month.\n"
#~ "\n"
#~ "* Note that Gnumeric will perform regular string to serial number "
#~ "conversion for you, so you can enter a date as a string.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DAY(\"10/24/1968\") equals 24.\n"
#~ "\n"
#~ "@SEEALSO=MONTH, TIME, NOW, YEAR"
#~ msgstr ""
#~ "@FUNCTION=DAY\n"
#~ "@SYNTAX=DAY (datum)\n"
#~ "@DESCRIPTION=DAY konverterar från serienummer till dag i månaden.\n"
#~ "\n"
#~ "* Observera att Gnumeric automatiskt konverterar strängen till ett "
#~ "serienummer åt dig, så du kan ange ett datum som en sträng.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DAY(\"10/24/1968\") är lika med 24.\n"
#~ "\n"
#~ "@SEEALSO=MONTH, TIME, NOW, YEAR"

#~ msgid ""
#~ "@FUNCTION=WEEKDAY\n"
#~ "@SYNTAX=WEEKDAY (date[, method])\n"
#~ "@DESCRIPTION=WEEKDAY converts a serial number to a weekday.\n"
#~ "\n"
#~ "This function returns an integer indicating the day of week.\n"
#~ "@METHOD indicates the numbering system.  It defaults to 1.\n"
#~ "\n"
#~ "  For @METHOD=1: Sunday is 1, Monday is 2, etc.\n"
#~ "  For @METHOD=2: Monday is 1, Tuesday is 2, etc.\n"
#~ "  For @METHOD=3: Monday is 0, Tuesday is 1, etc.\n"
#~ "\n"
#~ "* Note that Gnumeric will perform regular string to serial number "
#~ "conversion for you, so you can enter a date as a string.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "WEEKDAY(\"10/24/1968\") equals 5 (Thursday).\n"
#~ "\n"
#~ "@SEEALSO=DAY, MONTH, TIME, NOW, YEAR"
#~ msgstr ""
#~ "@FUNCTION=WEEKDAY\n"
#~ "@SYNTAX=WEEKDAY (datum[; metod])\n"
#~ "@DESCRIPTION=WEEKDAY konverterar ett serienummer till en veckodag.\n"
#~ "\n"
#~ "Denna funktion returnerar ett heltal som anger veckodagen.\n"
#~ "@METOD indikerar numreringssystemet. Som standard är det 1.\n"
#~ "\n"
#~ "  @METOD=1 ger: söndag är 1, måndag är 2 osv.\n"
#~ "  @METOD=2 ger: måndag är 1, tisdag är 2 osv.\n"
#~ "  @METOD=3 ger: måndag är 0, tisdag är 1 osv.\n"
#~ "\n"
#~ "* Observera att datumet kan anges som en sträng, eftersom Gnumeric "
#~ "automatiskt konverterar strängen till ett serienummer.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "WEEKDAY(\"10/24/1968\") är lika med 5 (torsdag).\n"
#~ "\n"
#~ "@SEEALSO=MONTH, TIME, NOW, YEAR"

#~ msgid ""
#~ "@FUNCTION=DAYS360 \n"
#~ "@SYNTAX=DAYS360 (date1,date2,method)\n"
#~ "@DESCRIPTION=DAYS360 returns the number of days from @date1 to @date2 "
#~ "following a 360-day calendar in which all months are assumed to have 30 "
#~ "days.\n"
#~ "\n"
#~ "* If @method is 1, the European method will be used.  In this case, if "
#~ "the day of the month is 31 it will be considered as 30.\n"
#~ "* If @method is 0 or omitted, the MS Excel (tm) US method will be used.  "
#~ "This is a somewhat complicated industry standard method where the last "
#~ "day of February is considered to be the 30th day of the month, but only "
#~ "for the first date.\n"
#~ "* If @method is 2, a saner version of the US method is used in which both "
#~ "dates get the same February treatment.\n"
#~ "* Note that Gnumeric will perform regular string to serial number "
#~ "conversion for you, so you can enter a date as a string.\n"
#~ "* This function is mostly Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DAYS360(DATE(2003, 2, 3), DATE(2007, 4, 2)) equals 1499.\n"
#~ "\n"
#~ "@SEEALSO=MONTH, TIME, NOW, YEAR"
#~ msgstr ""
#~ "@FUNCTION=DAYS360 \n"
#~ "@SYNTAX=DAYS360 (datum1;datum2;metod)\n"
#~ "@DESCRIPTION=DAYS360 returnerar antalet dagar mellan @datum1 och @datum2, "
#~ "enligt en 360-dagars kalender där alla månader har 30 dagar.\n"
#~ "\n"
#~ "* Om @metod är 1, används den europeiska metoden. Detta innebär att om "
#~ "det är den 31:a, räknas det som den 30:e.\n"
#~ "* Om @metod saknas eller är 0, används MS Excel (tm) US-metoden, vilken "
#~ "är en något komplicerad industristandard, där den sista dagen i februari "
#~ "betraktas som den trettionde dagen i månaden, men bara för första "
#~ "datumet.\n"
#~ "* Om @metod är 2, används en vettigare variant av US-metoden där båda "
#~ "behandlas lika för februari.\n"
#~ "* Observera att datumet kan anges som en sträng, eftersom Gnumeric "
#~ "automatiskt konverterar strängen till ett serienummer.\n"
#~ "* Denna funktion är i stort sett kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DAYS360(DATE(2003; 2; 3); DATE(2007; 4; 2)) är lika med 1499.\n"
#~ "\n"
#~ "@SEEALSO=MONTH, TIME, NOW, YEAR"

#~ msgid ""
#~ "@FUNCTION=EOMONTH\n"
#~ "@SYNTAX=EOMONTH (start_date,months)\n"
#~ "@DESCRIPTION=EOMONTH returns the last day of the month which is @months "
#~ "from the @start_date.\n"
#~ "\n"
#~ "* EOMONTH returns #NUM! if @start_date or @months are invalid.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "If A1 contains 12/21/00 then EOMONTH(A1,0)=12/31/00, EOMONTH(A1,5)"
#~ "=5/31/01, and EOMONTH(A1,2)=2/28/01\n"
#~ "\n"
#~ "@SEEALSO=MONTH"
#~ msgstr ""
#~ "@FUNCTION=EOMONTH\n"
#~ "@SYNTAX=EOMONTH (startdatum;månader)\n"
#~ "@DESCRIPTION=EOMONTH returnerar den sista dagen i måndaden som ligger "
#~ "@månader månader efter datumet @startdatum.\n"
#~ "\n"
#~ "* Returnerar #NUM! om @startdatum eller @månader är felaktiga.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Om A1 innehåller 00-12-21 är EOMONTH(A1;0)=00-12-31, EOMONTH(A1;5)=01-05-"
#~ "31 och EOMONTH(A1;2)=01-02-28\n"
#~ "\n"
#~ "@SEEALSO=MONTH"

#~ msgid ""
#~ "@FUNCTION=WORKDAY\n"
#~ "@SYNTAX=WORKDAY (start_date,days[,holidays])\n"
#~ "@DESCRIPTION=WORKDAY returns the date which is @days working days from "
#~ "the @start_date.  Weekends and holidays optionally supplied in @holidays "
#~ "are respected.\n"
#~ "\n"
#~ "* WORKDAY returns #NUM! if @start_date or @days are invalid.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DAY(WORKDAY(DATE(2001,1,5),30)) equals 16 and\n"
#~ "MONTH(WORKDAY(DATE(2001,1,5),30)) equals 2.\n"
#~ "\n"
#~ "@SEEALSO=NETWORKDAYS"
#~ msgstr ""
#~ "@FUNCTION=WORKDAY\n"
#~ "@SYNTAX=WORKDAY (startdatum;dagar[;helger])\n"
#~ "@DESCRIPTION=WORKDAY returnerar dagen som är @dagar arbetsdagar efter "
#~ "datumet @startdatum. Hänsyn tas till veckoslut och helgdagar som anges i "
#~ "@helger.\n"
#~ "\n"
#~ "* Returnerar #NUM! om @startdatum eller @dagar är felaktiga.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DAY(WORKDAY(DATE(2001;1;5);30)) är lika med 16 och\n"
#~ "MONTH(WORKDAY(DATE(2001;1;5);30)) är lika med 2.\n"
#~ "\n"
#~ "@SEEALSO=NETWORKDAYS"

#~ msgid ""
#~ "@FUNCTION=NETWORKDAYS\n"
#~ "@SYNTAX=NETWORKDAYS (start_date,end_date[,holidays])\n"
#~ "@DESCRIPTION=NETWORKDAYS returns the number of non-weekend non-holidays "
#~ "between @start_date and @end_date including these dates. Holidays are "
#~ "optionally supplied in @holidays.\n"
#~ "\n"
#~ "* NETWORKDAYS returns #NUM! if @start_date or @end_date are invalid.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "NETWORKDAYS(DATE(2001,1,2),DATE(2001,2,15)) equals 33.\n"
#~ "\n"
#~ "@SEEALSO=WORKDAY"
#~ msgstr ""
#~ "@FUNCTION=NETWORKDAYS\n"
#~ "@SYNTAX=NETWORKDAYS (startdatum;slutdatum[;helger])\n"
#~ "@DESCRIPTION=NETWORKDAYS returnerar antalet vardagar mellan @startdatum "
#~ "och @slutdatum, inklusive. Helger kan valfritt anges i @helger.\n"
#~ "\n"
#~ "* Returnerar #NUM om @startdatum eller @slutdatum är felaktiga.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "NETWORKDAYS(DATE(2001;1;2);DATE(2001;2;15)) är lika med 33.\n"
#~ "\n"
#~ "@SEEALSO=WORKDAY"

#~ msgid ""
#~ "@FUNCTION=ISOWEEKNUM\n"
#~ "@SYNTAX=ISOWEEKNUM (date)\n"
#~ "@DESCRIPTION=ISOWEEKNUM returns the ISO 8601 week number of @date.\n"
#~ "\n"
#~ "An ISO 8601 week starts on Monday. Weeks are numbered from 1. A week "
#~ "including days from two different years is assigned to the year which "
#~ "includes the most days. This means that Dec 31 could be in week 1 of the "
#~ "following year, and Jan 1 could be in week 52 or 53 of the previous year. "
#~ "ISOWEEKNUM returns the week number.\n"
#~ "\n"
#~ "* ISOWEEKNUM returns #NUM! if date is invalid.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "If A1 contains 12/21/00 then ISOWEEKNUM(A1)=51\n"
#~ "@SEEALSO=WEEKNUM, ISOYEAR"
#~ msgstr ""
#~ "@FUNCTION=ISOWEEKNUM\n"
#~ "@SYNTAX=ISOWEEKNUM (datum)\n"
#~ "@DESCRIPTION=ISOWEEKNUM returnerar ISO 8601-veckonumret för @datum.\n"
#~ "\n"
#~ "En ISO 8601-vecka börjar på en måndag. Veckor numreras från 1. En vecka "
#~ "som innehåller dagar från två olika år tilldelas det år som har flest "
#~ "dagar. Detta innebär att 31 december kan tillhöra vecka 1 nästföljande "
#~ "år, och 1 januari kan tillhöra vecka 52 eller 53 i föregående år. "
#~ "ISOWEEKNUM returnerar veckonumret, medan ISOYEAR returnerar året veckan "
#~ "ar tilldelad till.\n"
#~ "\n"
#~ "* Returnerar #NUM! om datumet är ogiltigt.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Om A1 innehåller 00-12-21 är ISOWEEKNUM(A1)=51\n"
#~ "@SEEALSO=WEEKNUM, ISOYEAR"

#~ msgid ""
#~ "@FUNCTION=ISOYEAR\n"
#~ "@SYNTAX=ISOYEAR (date)\n"
#~ "@DESCRIPTION=ISOYEAR returns the year of the ISO 8601 week number of "
#~ "@date.\n"
#~ "\n"
#~ "An ISO 8601 week starts on Monday. Weeks are numbered from 1. A week "
#~ "including days from two different years is assigned to the year which "
#~ "includes the most days. This means that Dec 31 could be in week 1 of the "
#~ "following year, and Jan 1 could be in week 52 or 53 of the previous year. "
#~ "ISOYEAR returns the year the week is assigned to.\n"
#~ "\n"
#~ "* ISOYEAR returns #NUM! if date is invalid.\n"
#~ "@EXAMPLES=\n"
#~ "If A1 contains 12/31/2001 then ISOYEAR(A1)=2002\n"
#~ "@SEEALSO=ISOWEEKNUM"
#~ msgstr ""
#~ "@FUNCTION=ISOYEAR\n"
#~ "@SYNTAX=ISOYEAR (datum)\n"
#~ "@DESCRIPTION=ISOYEAR returnerar året för ISO 8601-veckonumret för "
#~ "@datum.\n"
#~ "\n"
#~ "En ISO 8601-vecka börjar på en måndag. Veckor numreras från 1. En vecka "
#~ "som innehåller dagar från två olika år tilldelas det år som har flest "
#~ "dagar. Detta innebär att 31 december kan tillhöra vecka 1 nästföljande "
#~ "år, och 1 januari kan tillhöra vecka 52 eller 53 i föregående år. ISOYEAR "
#~ "returnerar året veckan tillhör, medan ISOWEEKNUM returnerar veckans "
#~ "nummer.\n"
#~ "\n"
#~ "* Returnerar #NUM! om datumet är ogiltigt.\n"
#~ "@EXAMPLES=\n"
#~ "Om A1 innehåller 00-12-31 är ISOYEAR(A1)=2002\n"
#~ "@SEEALSO=ISOWEEKNUM"

#~ msgid ""
#~ "@FUNCTION=WEEKNUM\n"
#~ "@SYNTAX=WEEKNUM (date[,method])\n"
#~ "@DESCRIPTION=WEEKNUM returns the week number of @date according to the "
#~ "given @method.\n"
#~ "\n"
#~ "@method defaults to 1.\n"
#~ "\n"
#~ "  For @method=1, week starts on Sunday, and days before first Sunday are "
#~ "in week 0.\n"
#~ "  For @method=2, week starts on Monday, and days before first Monday are "
#~ "in week 0.\n"
#~ "  For @method=150, the ISO 8601 week number is returned.\n"
#~ "\n"
#~ "* WEEKNUM returns #NUM! if @date or @method is invalid.\n"
#~ "* This function is Excel compatible, except that Excel does not support "
#~ "ISO 8601 week numbers.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "If A1 contains 12/21/00 then WEEKNUM(A1,2)=51\n"
#~ "@SEEALSO=ISOWEEKNUM"
#~ msgstr ""
#~ "@FUNCTION=WEEKNUM\n"
#~ "@SYNTAX=WEEKNUM (datum[;metod])\n"
#~ "@DESCRIPTION=WEEKNUM returnerar veckonumret för @datum enligt angiven "
#~ "@metod.\n"
#~ "\n"
#~ "@metod är som standard 1.\n"
#~ "\n"
#~ "  För metod=1 börjar veckan på söndag, och dagar innan första söndagen är "
#~ "i vecka 0.\n"
#~ "  För metod=2 börjar veckan på måndag, och dagar innan första måndagen är "
#~ "i vecka 0.\n"
#~ "  För metod=150 returneras ISO-veckonumret.\n"
#~ "\n"
#~ "* Returnerar #NUM! om datumet eller metoden är ogiltig.\n"
#~ "* Denna funktion är kompatibel med Excel, förutom det att Excel inte "
#~ "stöder ISO 8601-veckonummer.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Om A1 innehåller 00-12-21 är WEEKNUM(A1;2)=51\n"
#~ "@SEEALSO=ISOWEEKNUM"

#~ msgid ""
#~ "@FUNCTION=YEARFRAC\n"
#~ "@SYNTAX=YEARFRAC (start_date, end_date [,basis])\n"
#~ "@DESCRIPTION=YEARFRAC returns the number of full days between @start_date "
#~ "and @end_date according to the @basis.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=DATEDIF"
#~ msgstr ""
#~ "@FUNCTION=YEARFRAC\n"
#~ "@SYNTAX=WEEKNUM (startdatum;slutdatum[;bas])\n"
#~ "@DESCRIPTION=YEARFRAC returnerar antal hela dagar mellan @startdatum och "
#~ "@slutdatum i enlighet med @bas.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=DATEDIF"

#~ msgid ""
#~ "@FUNCTION=BASE\n"
#~ "@SYNTAX=BASE(number,base[,length])\n"
#~ "@DESCRIPTION=BASE function converts a number to a string representing "
#~ "that number in base @base.\n"
#~ "\n"
#~ "* @base must be an integer between 2 and 36.\n"
#~ "* This function is OpenOffice.Org compatible.\n"
#~ "* Optional argument @length specifies the minimum result length.  "
#~ "Leading  zeroes will be added to reach this length.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BASE(255,16,4) equals \"00FF\".\n"
#~ "\n"
#~ "@SEEALSO=DECIMAL"
#~ msgstr ""
#~ "@FUNCTION=OCT2DEC\n"
#~ "@SYNTAX=OCT2DEC(x)\n"
#~ "@DESCRIPTION=OCT2DEC omvandlar ett oktalt tal (eller sträng) till dess "
#~ "decimala motsvarighet.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "OCT2DEC(\"124\") är lika med 84.\n"
#~ "\n"
#~ "@SEEALSO=DEC2OCT, OCT2BIN, OCT2HEX"

#~ msgid ""
#~ "@FUNCTION=BIN2DEC\n"
#~ "@SYNTAX=BIN2DEC(x)\n"
#~ "@DESCRIPTION=BIN2DEC function converts a binary number in string or "
#~ "number to its decimal equivalent.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BIN2DEC(101) equals 5.\n"
#~ "\n"
#~ "@SEEALSO=DEC2BIN, BIN2OCT, BIN2HEX"
#~ msgstr ""
#~ "@FUNCTION=BIN2DEC\n"
#~ "@SYNTAX=BIN2DEC(x)\n"
#~ "@DESCRIPTION=BIN2DEC omvandlar ett binärt tal i en sträng eller ett tal "
#~ "till dess decimala motsvarighet.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BIN2DEC(101) är lika med 5.\n"
#~ "\n"
#~ "@SEEALSO=DEC2BIN, BIN2OCT, BIN2HEX"

#~ msgid ""
#~ "@FUNCTION=BIN2OCT\n"
#~ "@SYNTAX=BIN2OCT(number[,places])\n"
#~ "@DESCRIPTION=BIN2OCT function converts a binary number to an octal "
#~ "number. @places is an optional field, specifying to zero pad to that "
#~ "number of spaces.\n"
#~ "\n"
#~ "* If @places is too small or negative #NUM! error is returned.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BIN2OCT(110111) equals 67.\n"
#~ "\n"
#~ "@SEEALSO=OCT2BIN, BIN2DEC, BIN2HEX"
#~ msgstr ""
#~ "@FUNCTION=BIN2OCT\n"
#~ "@SYNTAX=BIN2OCT(tal[;siffror])\n"
#~ "@DESCRIPTION=BIN2OCT omvandlar ett binärt tal till ett oktalt tal. "
#~ "@siffror kan anges valfritt, och anger till vilken längd resultatet ska "
#~ "fyllas ut med nollor.\n"
#~ "\n"
#~ "* Om @siffror är för litet eller negativt, returneras felvärdet #NUM!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BIN2OCT(110111) är lika med 67.\n"
#~ "\n"
#~ "@SEEALSO=OCT2BIN, BIN2DEC, BIN2HEX"

#~ msgid ""
#~ "@FUNCTION=BIN2HEX\n"
#~ "@SYNTAX=BIN2HEX(number[,places])\n"
#~ "@DESCRIPTION=BIN2HEX function converts a binary number to a hexadecimal "
#~ "number.  @places is an optional field, specifying to zero pad to that "
#~ "number of spaces.\n"
#~ "\n"
#~ "* If @places is too small or negative #NUM! error is returned.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BIN2HEX(100111) equals 27.\n"
#~ "\n"
#~ "@SEEALSO=HEX2BIN, BIN2OCT, BIN2DEC"
#~ msgstr ""
#~ "@FUNCTION=BIN2HEX\n"
#~ "@SYNTAX=BIN2HEX(tal[;siffror])\n"
#~ "@DESCRIPTION=BIN2HEX omvandlar ett binärt tal till ett hexadecimalt tal. "
#~ "@siffror kan anges valfritt, och anger till vilken längd resultatet ska "
#~ "fyllas ut med nollor.\n"
#~ "\n"
#~ "* Om @siffror är för litet eller negativt, returneras felvärdet #NUM!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BIN2HEX(100111) är lika med 27.\n"
#~ "\n"
#~ "@SEEALSO=HEX2BIN, BIN2OCT, BIN2DEC"

#~ msgid ""
#~ "@FUNCTION=DEC2BIN\n"
#~ "@SYNTAX=DEC2BIN(number[,places])\n"
#~ "@DESCRIPTION=DEC2BIN function converts a decimal number to a binary "
#~ "number. @places is an optional field, specifying to zero pad to that "
#~ "number of spaces.\n"
#~ "\n"
#~ "* If @places is too small or negative #NUM! error is returned.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DEC2BIN(42) equals 101010.\n"
#~ "\n"
#~ "@SEEALSO=BIN2DEC, DEC2OCT, DEC2HEX"
#~ msgstr ""
#~ "@FUNCTION=DEC2BIN\n"
#~ "@SYNTAX=DEC2BIN(tal[;siffror])\n"
#~ "@DESCRIPTION=DEC2BIN omvandlar ett decimaltal till ett binärt tal. "
#~ "@siffror kan anges valfritt, och anger till vilken längd resultatet ska "
#~ "fyllas ut med nollor.\n"
#~ "\n"
#~ "* Om @siffror är för litet eller negativt, returneras felvärdet #NUM!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DEC2BIN(42) är lika med 101010.\n"
#~ "\n"
#~ "@SEEALSO=BIN2DEC, DEC2OCT, DEC2HEX"

#~ msgid ""
#~ "@FUNCTION=DEC2OCT\n"
#~ "@SYNTAX=DEC2OCT(number[,places])\n"
#~ "@DESCRIPTION=DEC2OCT function converts a decimal number to an octal "
#~ "number. @places is an optional field, specifying to zero pad to that "
#~ "number of spaces.\n"
#~ "\n"
#~ "* If @places is too small or negative #NUM! error is returned.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DEC2OCT(42) equals 52.\n"
#~ "\n"
#~ "@SEEALSO=OCT2DEC, DEC2BIN, DEC2HEX"
#~ msgstr ""
#~ "@FUNCTION=DEC2OCT\n"
#~ "@SYNTAX=DEC2OCT(tal[;siffror])\n"
#~ "@DESCRIPTION=DEC2OCT omvandlar ett decimaltal till ett oktalt tal. "
#~ "@siffror kan anges valfritt, och anger till vilken längd resultatet ska "
#~ "fyllas ut med nollor.\n"
#~ "\n"
#~ "* Om @siffror är för litet eller negativt, returneras felvärdet #NUM!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DEC2OCT(42) är lika med 52.\n"
#~ "\n"
#~ "@SEEALSO=OCT2DEC, DEC2BIN, DEC2HEX"

#~ msgid ""
#~ "@FUNCTION=DEC2HEX\n"
#~ "@SYNTAX=DEC2HEX(number[,places])\n"
#~ "@DESCRIPTION=DEC2HEX function converts a decimal number to a hexadecimal "
#~ "number. @places is an optional field, specifying to zero pad to that "
#~ "number of spaces.\n"
#~ "\n"
#~ "* If @places is too small or negative #NUM! error is returned.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DEC2HEX(42) equals 2A.\n"
#~ "\n"
#~ "@SEEALSO=HEX2DEC, DEC2BIN, DEC2OCT"
#~ msgstr ""
#~ "@FUNCTION=DEC2HEX\n"
#~ "@SYNTAX=DEC2HEX(tal[;siffror])\n"
#~ "@DESCRIPTION=DEC2HEX omvandlar ett decimaltal till ett hexadecimalt tal. "
#~ "@siffror kan anges valfritt, och anger till vilken längd resultatet ska "
#~ "fyllas ut med nollor.\n"
#~ "\n"
#~ "* Om @siffror är för litet eller negativt, returneras felvärdet #NUM!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DEC2HEX(42) är lika med 2A.\n"
#~ "\n"
#~ "@SEEALSO=HEX2DEC, DEC2BIN, DEC2OCT"

#~ msgid ""
#~ "@FUNCTION=DECIMAL\n"
#~ "@SYNTAX=DECIMAL(text,base)\n"
#~ "@DESCRIPTION=DECIMAL function converts a number in base @base to "
#~ "decimal.\n"
#~ "\n"
#~ "* @base must be an integer between 2 and 36.\n"
#~ "* This function is OpenOffice.Org compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DECIMAL(\"A1\",16) equals 161.\n"
#~ "\n"
#~ "@SEEALSO=BASE"
#~ msgstr ""
#~ "@FUNCTION=OCT2DEC\n"
#~ "@SYNTAX=OCT2DEC(x)\n"
#~ "@DESCRIPTION=OCT2DEC omvandlar ett oktalt tal (eller sträng) till dess "
#~ "decimala motsvarighet.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "OCT2DEC(\"124\") är lika med 84.\n"
#~ "\n"
#~ "@SEEALSO=DEC2OCT, OCT2BIN, OCT2HEX"

#~ msgid ""
#~ "@FUNCTION=OCT2DEC\n"
#~ "@SYNTAX=OCT2DEC(x)\n"
#~ "@DESCRIPTION=OCT2DEC function converts an octal number in a string or "
#~ "number to its decimal equivalent.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "OCT2DEC(\"124\") equals 84.\n"
#~ "\n"
#~ "@SEEALSO=DEC2OCT, OCT2BIN, OCT2HEX"
#~ msgstr ""
#~ "@FUNCTION=OCT2DEC\n"
#~ "@SYNTAX=OCT2DEC(x)\n"
#~ "@DESCRIPTION=OCT2DEC omvandlar ett oktalt tal (eller sträng) till dess "
#~ "decimala motsvarighet.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "OCT2DEC(\"124\") är lika med 84.\n"
#~ "\n"
#~ "@SEEALSO=DEC2OCT, OCT2BIN, OCT2HEX"

#~ msgid ""
#~ "@FUNCTION=OCT2BIN\n"
#~ "@SYNTAX=OCT2BIN(number[,places])\n"
#~ "@DESCRIPTION=OCT2BIN function converts an octal number to a binary "
#~ "number.  @places is an optional field, specifying to zero pad to that "
#~ "number of spaces.\n"
#~ "\n"
#~ "* If @places is too small or negative #NUM! error is returned.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "OCT2BIN(\"213\") equals 10001011.\n"
#~ "\n"
#~ "@SEEALSO=BIN2OCT, OCT2DEC, OCT2HEX"
#~ msgstr ""
#~ "@FUNCTION=DEC2BIN\n"
#~ "@SYNTAX=DEC2BIN(tal[;siffror])\n"
#~ "@DESCRIPTION=DEC2BIN omvandlar ett decimaltal till ett binärt tal. "
#~ "@siffror kan anges valfritt, och anger till vilken längd resultatet ska "
#~ "fyllas ut med nollor.\n"
#~ "\n"
#~ "* Om @siffror är för litet eller negativt, returneras felvärdet #NUM!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DEC2BIN(42) är lika med 101010.\n"
#~ "\n"
#~ "@SEEALSO=BIN2DEC, DEC2OCT, DEC2HEX"

#~ msgid ""
#~ "@FUNCTION=OCT2HEX\n"
#~ "@SYNTAX=OCT2HEX(number[,places])\n"
#~ "@DESCRIPTION=OCT2HEX function converts an octal number to a hexadecimal "
#~ "number.  @places is an optional field, specifying to zero pad to that "
#~ "number of spaces.\n"
#~ "\n"
#~ "* If @places is too small or negative #NUM! error is returned.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "OCT2HEX(132) equals 5A.\n"
#~ "\n"
#~ "@SEEALSO=HEX2OCT, OCT2BIN, OCT2DEC"
#~ msgstr ""
#~ "@FUNCTION=OCT2HEX\n"
#~ "@SYNTAX=OCT2HEX(tal[;siffror])\n"
#~ "@DESCRIPTION=OCT2HEX omvandlar ett oktalt tal till ett hexadecimalt tal. "
#~ "@siffror kan anges valfritt, och anger till vilken längd resultatet ska "
#~ "fyllas ut med nollor.\n"
#~ "\n"
#~ "* Om @siffror är för litet eller negativt, returneras felvärdet #NUM!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "OCT2HEX(132) är lika med 5A.\n"
#~ "\n"
#~ "@SEEALSO=HEX2OCT, OCT2BIN, OCT2DEC"

#~ msgid ""
#~ "@FUNCTION=HEX2BIN\n"
#~ "@SYNTAX=HEX2BIN(number[,places])\n"
#~ "@DESCRIPTION=HEX2BIN function converts a hexadecimal number to a binary "
#~ "number.  @places is an optional field, specifying to zero pad to that "
#~ "number of spaces.\n"
#~ "\n"
#~ "* If @places is too small or negative #NUM! error is returned.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "HEX2BIN(\"2A\") equals 101010.\n"
#~ "\n"
#~ "@SEEALSO=BIN2HEX, HEX2OCT, HEX2DEC"
#~ msgstr ""
#~ "@FUNCTION=HEX2BIN\n"
#~ "@SYNTAX=HEX2BIN(tal[;siffror])\n"
#~ "@DESCRIPTION=HEX2BIN omvandlar ett hexadecimalt tal till ett binärt tal. "
#~ "@siffror kan anges valfritt, och anger till vilken längd resultatet ska "
#~ "fyllas ut med nollor.\n"
#~ "\n"
#~ "* Om @siffror är för litet eller negativt, returneras felvärdet #NUM!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "HEX2BIN(\"2A\") är lika med 101010.\n"
#~ "\n"
#~ "@SEEALSO=BIN2HEX, HEX2OCT, HEX2DEC"

#~ msgid ""
#~ "@FUNCTION=HEX2OCT\n"
#~ "@SYNTAX=HEX2OCT(number[,places])\n"
#~ "@DESCRIPTION=HEX2OCT function converts a hexadecimal number to an octal "
#~ "number.  @places is an optional field, specifying to zero pad to that "
#~ "number of spaces.\n"
#~ "\n"
#~ "* If @places is too small or negative #NUM! error is returned.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "HEX2OCT(\"2A\") equals 52.\n"
#~ "\n"
#~ "@SEEALSO=OCT2HEX, HEX2BIN, HEX2DEC"
#~ msgstr ""
#~ "@FUNCTION=HEX2OCT\n"
#~ "@SYNTAX=HEX2OCT(tal[;siffror])\n"
#~ "@DESCRIPTION=HEX2OCT omvandlar ett hexadecimalt tal till ett oktalt tal. "
#~ "@siffror kan anges valfritt, och anger till vilken längd resultatet ska "
#~ "fyllas ut med nollor.\n"
#~ "\n"
#~ "* Om @siffror är för litet eller negativt, returneras felvärdet #NUM!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "HEX2OCT(\"2A\") är lika med 52.\n"
#~ "\n"
#~ "@SEEALSO=OCT2HEX, HEX2BIN, HEX2DEC"

#~ msgid ""
#~ "@FUNCTION=HEX2DEC\n"
#~ "@SYNTAX=HEX2DEC(x)\n"
#~ "@DESCRIPTION=HEX2DEC function converts a hexadecimal number to its "
#~ "decimal equivalent.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "HEX2DEC(\"2A\") equals 42.\n"
#~ "\n"
#~ "@SEEALSO=DEC2HEX, HEX2BIN, HEX2OCT"
#~ msgstr ""
#~ "@FUNCTION=HEX2DEC\n"
#~ "@SYNTAX=HEX2DEC(x)\n"
#~ "@DESCRIPTION=HEX2DEC omvandlar ett hexadecimalt tal till dess decimala "
#~ "motsvarighet.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "HEX2DEC(\"2A\") är lika med 42.\n"
#~ "\n"
#~ "@SEEALSO=DEC2HEX, HEX2BIN, HEX2OCT"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=BESSELI\n"
#~ "@SYNTAX=BESSELI(x,y)\n"
#~ "@DESCRIPTION=BESSELI function returns the Neumann, Weber or Bessel "
#~ "function.\n"
#~ "\n"
#~ "@x is where the function is evaluated. @y is the order of the Bessel "
#~ "function.\n"
#~ "\n"
#~ "* If @x or @y are not numeric a #VALUE! error is returned.\n"
#~ "* If @y < 0 a #NUM! error is returned.\n"
#~ "* This function extends the Excel function of the same name to non-"
#~ "integer orders.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BESSELI(0.7,3) equals 0.007367374.\n"
#~ "\n"
#~ "@SEEALSO=BESSELJ,BESSELK,BESSELY"
#~ msgstr ""
#~ "@FUNCTION=BESSELI\n"
#~ "@SYNTAX=BESSELI(x;y)\n"
#~ "@DESCRIPTION=Funktionen BESSELI returnerar Neumanns, Webers eller Bessels "
#~ "funktion.\n"
#~ "\n"
#~ "Funktionens värde beräknas i punkten @x. @y är funktionens ordningstal, "
#~ "som trunkeras om den inte är ett heltal.\n"
#~ "\n"
#~ "* Om @x eller @y inte är ett tal så returneras felvärdet #VÄRDE!.\n"
#~ "* Om @y < 0 så returneras felvärdet #NUM!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BESSELI(0,7;3) ger 0,007367374.\n"
#~ "\n"
#~ "@SEEALSO=BESSELJ,BESSELK,BESSELY"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=BESSELK\n"
#~ "@SYNTAX=BESSELK(x,y)\n"
#~ "@DESCRIPTION=BESSELK function returns the Neumann, Weber or Bessel "
#~ "function. @x is where the function is evaluated. @y is the order of the "
#~ "Bessel function.\n"
#~ "\n"
#~ "* If @x or @y are not numeric a #VALUE! error is returned.\n"
#~ "* If @y < 0 a #NUM! error is returned.\n"
#~ "* This function extends the Excel function of the same name to non-"
#~ "integer orders.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BESSELK(3,9) equals 397.95880.\n"
#~ "\n"
#~ "@SEEALSO=BESSELI,BESSELJ,BESSELY"
#~ msgstr ""
#~ "@FUNCTION=BESSELK\n"
#~ "@SYNTAX=BESSELK(x;y)\n"
#~ "@DESCRIPTION=Funktionen BESSELK returnerar Neumanns, Webers eller Bessels "
#~ "funktion. Funktionens värde beräknas i punkten @x. @y är funktionens "
#~ "ordningstal, som trunkeras om den inte är ett heltal.\n"
#~ "\n"
#~ "* Om @x eller @y inte är ett tal så returneras felvärdet #VÄRDE!.\n"
#~ "* Om @y < 0 returneras felvärdet #NUM!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BESSELK(3;9) ger 397,95880.\n"
#~ "\n"
#~ "@SEEALSO=BESSELI,BESSELJ,BESSELY"

#~ msgid ""
#~ "@FUNCTION=BESSELJ\n"
#~ "@SYNTAX=BESSELJ(x,y)\n"
#~ "@DESCRIPTION=BESSELJ function returns the Bessel function with @x is "
#~ "where the function is evaluated. @y is the order of the Bessel function, "
#~ "if non-integer it is truncated.\n"
#~ "\n"
#~ "* If @x or @y are not numeric a #VALUE! error is returned.\n"
#~ "* If @y < 0 a #NUM! error is returned.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BESSELJ(0.89,3) equals 0.013974004.\n"
#~ "\n"
#~ "@SEEALSO=BESSELI,BESSELK,BESSELY"
#~ msgstr ""
#~ "@FUNCTION=BESSELJ\n"
#~ "@SYNTAX=BESSELJ(x;y)\n"
#~ "@DESCRIPTION=Funktionen BESSELJ returnerar besselfunktionen med @x där "
#~ "funktionen evalueras. @y är funktionens ordningstal, som trunkeras om den "
#~ "inte är ett heltal.\n"
#~ "\n"
#~ "* Om @x eller @y inte är ett tal så returneras felvärdet #VÄRDE!.\n"
#~ "* Om @y < 0 returneras felvärdet #NUM!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BESSELJ(0,98;3) ger 0,013974004.\n"
#~ "\n"
#~ "@SEEALSO=BESSELJ,BESSELK,BESSELY"

#~ msgid ""
#~ "@FUNCTION=BESSELY\n"
#~ "@SYNTAX=BESSELY(x,y)\n"
#~ "@DESCRIPTION=BESSELY function returns the Neumann, Weber or Bessel "
#~ "function.\n"
#~ "\n"
#~ "@x is where the function is evaluated. @y is the order of the Bessel "
#~ "function, if non-integer it is truncated.\n"
#~ "\n"
#~ "* If @x or @y are not numeric a #VALUE! error is returned.\n"
#~ "* If @y < 0 a #NUM! error is returned.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BESSELY(4,2) equals 0.215903595.\n"
#~ "\n"
#~ "@SEEALSO=BESSELI,BESSELJ,BESSELK"
#~ msgstr ""
#~ "@FUNCTION=BESSELY\n"
#~ "@SYNTAX=BESSELY(x;y)\n"
#~ "@DESCRIPTION=Funktionen BESSELY returnerar Neumanns, Webers eller Bessels "
#~ "funktion.\n"
#~ "\n"
#~ "Funktionens värde beräknas i punkten @x. @y är funktionens ordningstal, "
#~ "som trunkeras om den inte är ett heltal.\n"
#~ "\n"
#~ "* Om @x eller @y inte är ett tal så returneras felvärdet #VÄRDE!.\n"
#~ "* Om @y < 0 returneras felvärdet #NUM!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BESSELI(4;2) ger 0,215903595.\n"
#~ "\n"
#~ "@SEEALSO=BESSELI,BESSELJ,BESSELK"

#~ msgid ""
#~ "@FUNCTION=ERF\n"
#~ "@SYNTAX=ERF([lower limit,]upper_limit)\n"
#~ "@DESCRIPTION=ERF returns the error function.  With a single argument ERF "
#~ "returns the error function, defined as\n"
#~ "\n"
#~ "\terf(x) = 2/sqrt(pi)* integral from 0 to x of exp(-t*t) dt.\n"
#~ "\n"
#~ "If two arguments are supplied, they are the lower and upper limits of the "
#~ "integral.\n"
#~ "\n"
#~ "* If either @lower_limit or @upper_limit is not numeric a #VALUE! error "
#~ "is returned.\n"
#~ "* This function is upward-compatible with that in Excel. (If two "
#~ "arguments are supplied, Excel will not allow either to be negative.)\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ERF(0.4) equals 0.428392355.\n"
#~ "ERF(1.6448536269515/SQRT(2)) equals 0.90.\n"
#~ "\n"
#~ "The second example shows that a random variable with a normal "
#~ "distribution has a 90 percent chance of falling within approximately "
#~ "1.645 standard deviations of the mean.\n"
#~ "@SEEALSO=ERFC"
#~ msgstr ""
#~ "@FUNCTION=ERF\n"
#~ "@SYNTAX=ERF([undre_gräns;]övre_gräns)\n"
#~ "@DESCRIPTION=ERF returnerar felfunktionen. Med ett ensamt argument "
#~ "returnerar ERF felfunktionen, definierad som\n"
#~ "\n"
#~ "\terf(x) = 2/sqrt(pi)* integralen från 0 till x av exp(-t*t) dt.\n"
#~ "\n"
#~ "Om två argument anges, är de den undre respektive övre gränsen för "
#~ "integralen.\n"
#~ "\n"
#~ "* Om antingen @undre_gräns eller @övre_gräns inte är tal returneras "
#~ "felvärdet #VÄRDE!.\n"
#~ "* Denna funktion är uppåtkompatibel med den i Excel. (Om två argument "
#~ "anges kommer Excel inte att låta någon av dem vara negativ.)\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ERF(0,4) är lika med 0,428392355.\n"
#~ "ERF(1,6448536269515/SQRT(2)) är lika med 0,90.\n"
#~ "\n"
#~ "Det andra exemplet visar att en slumpvariabel med en normalfördelning har "
#~ "en 90% chans att hamna inom uppskattningsvis 1,645 standardavvikelser av "
#~ "medelvärdet.\n"
#~ "@SEEALSO=ERFC"

#~ msgid ""
#~ "@FUNCTION=ERFC\n"
#~ "@SYNTAX=ERFC(x)\n"
#~ "@DESCRIPTION=ERFC function returns the complementary error function, "
#~ "defined as\n"
#~ "\n"
#~ "\t1 - erf(x).\n"
#~ "\n"
#~ "erfc(x) is calculated more accurately than 1 - erf(x) for arguments "
#~ "larger than about 0.5.\n"
#~ "\n"
#~ "* If @x is not numeric a #VALUE! error is returned.  \n"
#~ "@EXAMPLES=\n"
#~ "ERFC(6) equals 2.15197367e-17.\n"
#~ "\n"
#~ "@SEEALSO=ERF"
#~ msgstr ""
#~ "@FUNCTION=ERFC\n"
#~ "@SYNTAX=ERFC(x)\n"
#~ "@DESCRIPTION=Funktionen ERFC returnerar den kompletterande felfunktionen, "
#~ "definierad som\n"
#~ "\n"
#~ "\t1 - erf(x).\n"
#~ "\n"
#~ "erfc(x) är beräknad mer noggrannt än 1 - erf(x) för argument som är "
#~ "större än ungefär 0,5.\n"
#~ "\n"
#~ "* Om @x inte är ett tal returneras felvärdet #VÄRDE!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ERFC(6) är lika med 2,15197367e-17.\n"
#~ "\n"
#~ "@SEEALSO=ERF"

#~ msgid ""
#~ "@FUNCTION=DELTA\n"
#~ "@SYNTAX=DELTA(x[,y])\n"
#~ "@DESCRIPTION=DELTA function tests for numerical equivalence of two "
#~ "arguments, returning 1 in case of equality.\n"
#~ "\n"
#~ "* @y is optional, and defaults to 0.\n"
#~ "* If either argument is non-numeric returns a #VALUE! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DELTA(42.99,43) equals 0.\n"
#~ "\n"
#~ "@SEEALSO=EXACT,GESTEP"
#~ msgstr ""
#~ "@FUNCTION=DELTA\n"
#~ "@SYNTAX=DELTA(x[;y])\n"
#~ "@DESCRIPTION=Funktionen DELTA testar numerisk ekvivalens av två argument, "
#~ "och returnerar 1 om de är ekvivalenta.\n"
#~ "\n"
#~ "* @y är valfritt och är som standard 0.\n"
#~ "* Om något argument inte är numeriskt returneras felvärdet #VÄRDE!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DELTA(42,99;43) är lika med 0.\n"
#~ "\n"
#~ "@SEEALSO=EXACT,GESTEP"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=GESTEP\n"
#~ "@SYNTAX=GESTEP(x[,y])\n"
#~ "@DESCRIPTION=GESTEP function tests if @x is >= @y, returning 1 if it is "
#~ "so, and 0 otherwise. @y is optional, and defaults to 0.\n"
#~ "\n"
#~ "* If either argument is non-numeric returns a #VALUE! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "@EXAMPLES=\n"
#~ "GESTEP(5,4) equals 1.\n"
#~ "\n"
#~ "@SEEALSO=DELTA"
#~ msgstr ""
#~ "@FUNCTION=GESTEP\n"
#~ "@SYNTAX=GESTEP(x[;y])\n"
#~ "@DESCRIPTION=Funktionen GESTEP testar om @x är >= @y och returnerar 1 om "
#~ "det är så, och 0 annars. @y är valfritt och är som standard 0.\n"
#~ "\n"
#~ "* Om något av argumenten inte är ett tal returneras felvärdet #VÄRDE!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "GESTEP(5;4) är lika med 1.\n"
#~ "\n"
#~ "@SEEALSO=DELTA"

#~ msgid ""
#~ "@FUNCTION=INVSUMINV\n"
#~ "@SYNTAX=INVSUMINV(x1,x2,...)\n"
#~ "@DESCRIPTION=INVSUMINV sum calculates the inverse of the sum of "
#~ "inverses.\n"
#~ "\n"
#~ "The primary use of this is for calculating equivalent resistance for "
#~ "parallel resistors or equivalent capacitance of a series of capacitors.\n"
#~ "\n"
#~ "* All arguments must be non-negative, or else a #VALUE! result is "
#~ "returned.\n"
#~ "* If any argument is zero, the result is zero.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "INVSUMINV(2000,2000) equals 1000.\n"
#~ "\n"
#~ "@SEEALSO=HARMEAN"
#~ msgstr ""
#~ "@FUNCTION=INVSUMINV\n"
#~ "@SYNTAX=INVSUMINV(x1;x2;...)\n"
#~ "@DESCRIPTION=INVSUMINV beräknar inversen av summan av inverser.\n"
#~ "\n"
#~ "Det normala användningsområdet är att beräkna den ekvivalenta resistansen "
#~ "av parallella resistorer eller den ekvivalenta kapacitansen av parallella "
#~ "kondensatorer.\n"
#~ "\n"
#~ "* Alla argument måste vara icke-negativa annars returneras värdet "
#~ "#VÄRDE!.\n"
#~ "* Om något argument är noll, är resultatet noll.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "INVSUMINV(2000,2000) är lika med 1000.\n"
#~ "\n"
#~ "@SEEALSO=HARMEAN"

#~ msgid ""
#~ "@FUNCTION=PROBBLOCK\n"
#~ "@SYNTAX=PROBBLOCK(traffic,circuits)\n"
#~ "@DESCRIPTION=PROBBLOCK returns probability of blocking when a number of "
#~ "@traffic loads into a number of @circuits (servers).\n"
#~ "\n"
#~ "* @traffic cannot exceed @circuits\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "PROBBLOCK(24,30) returns 0.4012.\n"
#~ "\n"
#~ "@SEEALSO=OFFTRAF, DIMCIRC, OFFCAP"
#~ msgstr ""
#~ "@FUNCTION=PROBBLOCK\n"
#~ "@SYNTAX=PROBBLOCK(trafik;kopplingar)\n"
#~ "@DESCRIPTION=PROBBLOCK anger sannolikheten för att blocka när ett antal "
#~ "@trafik laddas in i ett antal @kopplingar (servrar).\n"
#~ "\n"
#~ "* @trafik kan inte vara större än @kopplingar\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "PROBBLOCK(24;30) returnerar 0,4012.\n"
#~ "\n"
#~ "@SEEALSO=OFFTRAF, DIMCIRC, OFFCAP"

#~ msgid ""
#~ "@FUNCTION=OFFTRAF\n"
#~ "@SYNTAX=OFFTRAF(traffic,circuits)\n"
#~ "@DESCRIPTION=OFFTRAF returns a predicted number of offered traffic from a "
#~ "number of carried @traffic (taken from measurements) on a number of "
#~ "@circuits.\n"
#~ "\n"
#~ "* @traffic cannot exceed @circuits\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "OFFTRAF(24,30) returns 25.527.\n"
#~ "\n"
#~ "@SEEALSO=PROBBLOCK, DIMCIRC, OFFCAP"
#~ msgstr ""
#~ "@FUNCTION=OFFTRAF\n"
#~ "@SYNTAX=OFFTRAF(trafik;kopplingar)\n"
#~ "@DESCRIPTION=OFFTRAF anger den uppskaddade mängden erbjuden trafik från "
#~ "ett antal avverkad @trafik (taget från mätningar) på ett antal "
#~ "@kopplingar.\n"
#~ "\n"
#~ "* @trafik kan inte vara större än  @kopplingar\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "OFFTRAF(24;30) returnerar 25,527.\n"
#~ "\n"
#~ "@SEEALSO=PROBBLOCK, DIMCIRC, OFFCAP"

#~ msgid ""
#~ "@FUNCTION=DIMCIRC\n"
#~ "@SYNTAX=DIMCIRC(traffic,gos)\n"
#~ "@DESCRIPTION=DIMCIRC returns a number of circuits required from a number "
#~ "of @traffic loads with @gos grade of service.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DIMCIRC(24,1%) returns 35.\n"
#~ "\n"
#~ "@SEEALSO=OFFCAP, OFFTRAF, PROBBLOCK"
#~ msgstr ""
#~ "@FUNCTION=DIMCIRC\n"
#~ "@SYNTAX=DIMCIRC(trafik;sk)\n"
#~ "@DESCRIPTION=DIMCIRC anger ett antal kopplingar som behövs av @trafik "
#~ "belastning med servicekvalitet @sk.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DIMCIRC(24;1%) returnerar 35.\n"
#~ "\n"
#~ "@SEEALSO=OFFCAP, OFFTRAF, PROBBLOCK"

#~ msgid ""
#~ "@FUNCTION=OFFCAP\n"
#~ "@SYNTAX=OFFCAP(circuits,gos)\n"
#~ "@DESCRIPTION=OFFCAP returns a number of traffic capacity given by a "
#~ "number of @circuits with @gos grade of service.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "OFFCAP(30,1%) returns 20.337.\n"
#~ "\n"
#~ "@SEEALSO=DIMCIRC, OFFTRAF, PROBBLOCK"
#~ msgstr ""
#~ "@FUNCTION=OFFCAP\n"
#~ "@SYNTAX=OFFCAP(kopplingar;sk)\n"
#~ "@DESCRIPTION=OFFCAP anger trafikkapaciteten given av antalet @kopplingar "
#~ "med servicekvalitet @sk.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "OFFCAP(30;1%) returns 20,337.\n"
#~ "\n"
#~ "@SEEALSO=DIMCIRC, OFFTRAF, PROBBLOCK"

# FIXME: rate!=hastighet här. Vad är par? - 'parvärde' (ev. siktvärde)
#
#~ msgid ""
#~ "@FUNCTION=ACCRINT\n"
#~ "@SYNTAX=ACCRINT(issue,first_interest,settlement,rate,par,frequency[,"
#~ "basis])\n"
#~ "@DESCRIPTION=ACCRINT calculates the accrued interest for a security that "
#~ "pays periodic interest.\n"
#~ "\n"
#~ "@issue is the issue date of the security.  @first_interest is the first "
#~ "interest date of the security.  @settlement is the settlement date of the "
#~ "security.  The settlement date is always after the issue date (the date "
#~ "when the security is bought). @rate is the annual rate of the security "
#~ "and @par is the par value of the security. @frequency is the number of "
#~ "coupon payments per year.\n"
#~ "\n"
#~ "Allowed frequencies are:\n"
#~ "  1 = annual,\n"
#~ "  2 = semi,\n"
#~ "  4 = quarterly.\n"
#~ "\n"
#~ "@basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @issue date, @first_interest date, or @settlement date is not valid, "
#~ "ACCRINT returns #NUM! error.\n"
#~ "* The dates must be @issue < @first_interest < @settlement, or ACCRINT "
#~ "returns #NUM! error.\n"
#~ "* If @rate <= 0 or @par <= 0 , ACCRINT returns #NUM! error.\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis < 0 or @basis > 4, ACCRINT returns #NUM! error.\n"
#~ "* If @issue date is after @settlement date or they are the same, ACCRINT "
#~ "returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=ACCRINTM"
#~ msgstr ""
#~ "@FUNCTION=ACCRINT\n"
#~ "@SYNTAX=ACCRINT(start;första_ränta;avräkning;hastighet;par;frekvens[;"
#~ "bas])\n"
#~ "@DESCRIPTION=ACCRINT beräknar den uppräknade räntan för en säkerhet som "
#~ "betalar periodisk ränta.\n"
#~ "\n"
#~ "@start är startdatumet för säkerheten. @första_ränta är datumet för den "
#~ "första räntan för säkerheten. @avräkning är avräkningsdatumet för "
#~ "säkerheten. Avräkningsdatumet är alltid efter startdatumet (datumet då "
#~ "säkerheten köps). @hastighet är den årliga hastigheten på säkerheten och "
#~ "@par är parvärdet på säkerheten. @frekvens är antalet kupongbetalningar "
#~ "per år.\n"
#~ "\n"
#~ "Tillåtna frekvenser är:i\n"
#~ "  1 = årlig,\n"
#~ "  2 = halvårsvis,\n"
#~ "  4 = kvartalsvis.\n"
#~ "\n"
#~ "@bas är den typ av dagsräkningssystem som du vill använda:\n"
#~ "\n"
#~ "0  Amerikanskt 30/360\n"
#~ "1  verkliga dagar/verkliga dagar\n"
#~ "2  verkliga dagar/360\n"
#~ "3  verkliga dagar/365\n"
#~ "4  Europeiskt 30/360\n"
#~ "\n"
#~ "* Om datumen @start, @första_ränta eller @avräkning inte är giltiga "
#~ "returnerar ACCRINT felvärdet #NUM!.\n"
#~ "* Datumen måste vara @start < @första_ränta < @avräkning, annars "
#~ "returnerar ACCRINT felvärdet #NUM!.\n"
#~ "* Om @hastighet <= 0 eller @par <= 0 returnerar ACCRINT felvärdet #NUM!.\n"
#~ "* Om @bas utelämnas används amerikanskt 30/360-system.\n"
#~ "* Om @bas < 0 eller @bas > 4 returnerar ACCRINT felvärdet #NUM!.\n"
#~ "* Om @start är efter @avräkning eller om de är identiska returnerar "
#~ "ACCRINT felvärdet #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=ACCRINTM"

#~ msgid ""
#~ "@FUNCTION=ACCRINTM\n"
#~ "@SYNTAX=ACCRINTM(issue,maturity,rate[,par,basis])\n"
#~ "@DESCRIPTION=ACCRINTM calculates and returns the accrued interest for a "
#~ "security from @issue to @maturity date.\n"
#~ "\n"
#~ "@issue is the issue date of the security.  @maturity is the maturity date "
#~ "of the security.  @rate is the annual rate of the security and @par is "
#~ "the par value of the security. If you omit @par, ACCRINTM applies $1,000 "
#~ "instead.  @basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @issue date or @maturity date is not valid, ACCRINTM returns #NUM! "
#~ "error.\n"
#~ "* If @rate <= 0 or @par <= 0, ACCRINTM returns #NUM! error.\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis < 0 or @basis > 4, ACCRINTM returns #NUM! error.\n"
#~ "* If @issue date is after @maturity date or they are the same, ACCRINTM "
#~ "returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=ACCRINT"
#~ msgstr ""
#~ "@FUNCTION=ACCRINTM\n"
#~ "@SYNTAX=ACCRINTM(start;mognad;hastighet[;par;bas])\n"
#~ "@DESCRIPTION=ACCRINTM beräknar och returnerar den uppräknade räntan för "
#~ "en säkerhet från @start till @mognad.\n"
#~ "\n"
#~ "@start är startdatumet för säkerheten. @mognad är mognadsdatumet för "
#~ "säkerheten. @hastighet är den årliga hastigheten på säkerheten och @par "
#~ "är parvärdet på säkerheten. Om du utelämnar @par använder ACCRINTM värdet "
#~ "$1 000 istället. @bas är den typ av dagsräkningssystem som du vill "
#~ "använda:\n"
#~ "\n"
#~ "0  Amerikanskt 30/360\n"
#~ "1  verkliga dagar/verkliga dagar\n"
#~ "2  verkliga dagar/360\n"
#~ "3  verkliga dagar/365\n"
#~ "4  Europeiskt 30/360\n"
#~ "\n"
#~ "Om datumen @start eller @mognad inte är giltiga returnerar ACCRINT "
#~ "felvärdet #NUM!.\n"
#~ "* Om @hastighet <= 0 eller @par <= 0 returnerar ACCRINT felvärdet #NUM!.\n"
#~ "* Om @bas utelämnas används amerikanskt 30/360-system.\n"
#~ "* Om @bas < 0 eller @bas > 4 returnerar ACCRINT felvärdet #NUM!.\n"
#~ "* Om @start är efter @mognad eller om de är identiska returnerar ACCRINT "
#~ "felvärdet #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=ACCRINT"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=INTRATE\n"
#~ "@SYNTAX=INTRATE(settlement,maturity,investment,redemption[,basis])\n"
#~ "@DESCRIPTION=INTRATE calculates and returns the interest rate of a fully "
#~ "vested security.\n"
#~ "\n"
#~ "@settlement is the settlement date of the security.  @maturity is the "
#~ "maturity date of the security. @investment is the price of the security "
#~ "paid at @settlement date and @redemption is the amount to be received at "
#~ "@maturity date.\n"
#~ "\n"
#~ "@basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @settlement date or @maturity date is not valid, INTRATE returns "
#~ "#NUM! error.\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis < 0 or @basis > 4, INTRATE returns #NUM! error.\n"
#~ "* If @settlement date is after @maturity date or they are the same, "
#~ "INTRATE returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "If you had a bond with a settlement date of April 15, 2000, maturity date "
#~ "September 30, 2000, investment of $100,000, redemption value $103,525, "
#~ "using the actual/actual basis, the bond discount rate is:\n"
#~ "=INTRATE(36631, 36799, 100000, 103525, 1) which equals 0.0648 or 6.48%\n"
#~ "@SEEALSO=RECEIVED, DATE"
#~ msgstr ""
#~ "@FUNCTION=INTRATE\n"
#~ "@SYNTAX=INTRATE(avräkning;mognad;investering;utlösande[;bas])\n"
#~ "@DESCRIPTION=INTRATE beräknar och returnerar räntesatsen för en helt fast "
#~ "säkerhet.\n"
#~ "\n"
#~ "@avräkning är avräkningsdatumet för säkerheten. @mognad är mognadsdatumet "
#~ "för säkerheten. @investering är priset för säkerheten som betalades vid "
#~ "@avräkning och @utlösande är summan som ska fås vid @mognad. \n"
#~ "\n"
#~ "@bas är den typ av dagsräkningssystem som du vill använda:\n"
#~ "\n"
#~ "0  Amerikanskt 30/360\n"
#~ "1  verkliga dagar/verkliga dagar\n"
#~ "2  verkliga dagar/360\n"
#~ "3  verkliga dagar/365\n"
#~ "4  Europeiskt 30/360\n"
#~ "\n"
#~ "* Om datumen @avräkning eller @mognad inte är giltiga returnerar INTRATE "
#~ "felvärdet #NUM!.\n"
#~ "* Om @bas utelämnas används amerikanskt 30/360-system.\n"
#~ "* Om @bas < 0 eller @bas > 4 returnerar INTRATE felvärdet #NUM!.\n"
#~ "* Om @avräkning är efter @mognad eller om de är identiska returnerar "
#~ "ACCRINT felvärdet #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "Om du hade en förbindelse med avräkningsdatumet 15 april 2000, "
#~ "mognadsdatumet 30 september 2000, en investering på 100.000 kr, "
#~ "utlösandevärdet 103.525 kr är (då verkliga/verkliga används) "
#~ "förbindelsereduceringshastigheten:\n"
#~ "=INTRATE(36631; 36799; 100000; 103525; 1) vilket är lika med 0,0648 eller "
#~ "6,48%\n"
#~ "@SEEALSO=RECEIVED, DATE"

#~ msgid ""
#~ "@FUNCTION=RECEIVED\n"
#~ "@SYNTAX=RECEIVED(settlement,maturity,investment,rate[,basis])\n"
#~ "@DESCRIPTION=RECEIVED calculates and returns the amount to be received at "
#~ "maturity date for a security bond.\n"
#~ "\n"
#~ "@settlement is the settlement date of the security.  @maturity is the "
#~ "maturity date of the security.  The amount of investment is specified in "
#~ "@investment.  @rate is the security's discount rate.\n"
#~ "\n"
#~ "@basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @settlement date or @maturity date is not valid, RECEIVED returns "
#~ "#NUM! error.\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis < 0 or @basis > 4, RECEIVED returns #NUM! error.\n"
#~ "* If @settlement date is after @maturity date or they are the same, "
#~ "RECEIVED returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=INTRATE"
#~ msgstr ""
#~ "@FUNCTION=RECEIVED\n"
#~ "@SYNTAX=RECEIVED(avräkning;mognad;investering;hastighet[;bas])\n"
#~ "@DESCRIPTION=RECEIVED beräknar och returnerar summan som ska fås vid "
#~ "@mognad för en given säkerhet.\n"
#~ "\n"
#~ "@avräkning är avräkningsdatumet för säkerheten. @mognad är mognadsdatumet "
#~ "för säkerheten. @investering är priset för säkerheten. @hastighet är "
#~ "säkerhetens reduceringshastighet. @bas är den typ av dagsräkningssystem "
#~ "som du vill använda:\n"
#~ "\n"
#~ "0  Amerikanskt 30/360\n"
#~ "1  verkliga dagar/verkliga dagar\n"
#~ "2  verkliga dagar/360\n"
#~ "3  verkliga dagar/365\n"
#~ "4  Europeiskt 30/360\n"
#~ "\n"
#~ "* Om datumen @avräkning eller @mognad inte är giltiga returnerar RECEIVED "
#~ "felvärdet #NUM!.\n"
#~ "* Om @bas utelämnas används amerikanskt 30/360-system.\n"
#~ "* Om @bas < 0 eller @bas > 4 returnerar RECEIVED felvärdet #NUM!.\n"
#~ "* Om @avräkning är efter @mognad eller om de är identiska returnerar "
#~ "RECEIVED felvärdet #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=INTRATE"

#~ msgid ""
#~ "@FUNCTION=PRICEDISC\n"
#~ "@SYNTAX=PRICEDISC(settlement,maturity,discount,redemption[,basis])\n"
#~ "@DESCRIPTION=PRICEDISC calculates and returns the price per $100 face "
#~ "value of a security bond.  The security does not pay interest at "
#~ "maturity.\n"
#~ "\n"
#~ "@settlement is the settlement date of the security. @maturity is the "
#~ "maturity date of the security.  @discount is the rate for which the "
#~ "security is discounted.  @redemption is the amount to be received on "
#~ "@maturity date.\n"
#~ "\n"
#~ "@basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @settlement date or @maturity date is not valid, PRICEDISC returns "
#~ "#NUM! error.\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis < 0 or @basis > 4, PRICEDISC returns #NUM! error.\n"
#~ "* If @settlement date is after @maturity date or they are the same, "
#~ "PRICEDISC returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=PRICEMAT"
#~ msgstr ""
#~ "@FUNCTION=PRICEDISC\n"
#~ "@SYNTAX=PRICEDISC(avräkning;mognad;reducering;utlösande[;bas])\n"
#~ "@DESCRIPTION=PRICEDISC beräknar och returnerar priset per $100 värde av "
#~ "en säkerhet. Säkerheten betalar inte ränta vid mognad.\n"
#~ "\n"
#~ "@avräkning är avräkningsdatumet för säkerheten. @mognad är mognadsdatumet "
#~ "för säkerheten. @reducering är hastigheten som säkerheten reduceras. "
#~ "@utlösande är summan som ska fås vid @mognad. @bas är den typ av "
#~ "dagsräkningssystem som du vill använda:\n"
#~ "\n"
#~ "0  Amerikanskt 30/360\n"
#~ "1  verkliga dagar/verkliga dagar\n"
#~ "2  verkliga dagar/360\n"
#~ "3  verkliga dagar/365\n"
#~ "4  Europeiskt 30/360\n"
#~ "\n"
#~ "* Om datumen @avräkning eller @mognad inte är giltiga returnerar "
#~ "PRICEDISC felvärdet #NUM!.\n"
#~ "* Om @bas utelämnas används amerikanskt 30/360-system.\n"
#~ "* Om @bas < 0 eller @bas > 4 returnerar PRICEDISC felvärdet #NUM!.\n"
#~ "* Om @avräkning är efter @mognad eller om de är identiska returnerar "
#~ "PRICEDISC felvärdet #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=PRICEMAT"

#~ msgid ""
#~ "@FUNCTION=PRICEMAT\n"
#~ "@SYNTAX=PRICEMAT(settlement,maturity,issue,rate,yield[,basis])\n"
#~ "@DESCRIPTION=PRICEMAT calculates and returns the price per $100 face "
#~ "value of a security.  The security pays interest at maturity.\n"
#~ "\n"
#~ "@settlement is the settlement date of the security.  @maturity is the "
#~ "maturity date of the security.  @issue is the issue date of the "
#~ "security.  @rate is the discount rate of the security. @yield is the "
#~ "annual yield of the security. @basis is the type of day counting system "
#~ "you want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @settlement date or @maturity date is not valid, PRICEMAT returns "
#~ "#NUM! error.\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis < 0 or @basis > 4, PRICEMAT returns #NUM! error.\n"
#~ "* If @settlement date is after @maturity date or they are the same, "
#~ "PRICEMAT returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=PRICEDISC"
#~ msgstr ""
#~ "@FUNCTION=PRICEMAT\n"
#~ "@SYNTAX=PRICEMAT(avräkning;mognad;start;hastighet;avkastning[;bas])\n"
#~ "@DESCRIPTION=PRICEMAT beräknar och returnerar priset per $100 värde av en "
#~ "säkerhet. Säkerheten betalar ränta vid mognad.\n"
#~ "\n"
#~ "@avräkning är avräkningsdatumet för säkerheten. @mognad är mognadsdatumet "
#~ "för säkerheten. @reducering är hastigheten som säkerheten reduceras. "
#~ "@avkastning är den årliga avkastningen för säkerhet. @utlösande är summan "
#~ "som ska fås vid @mognad. @bas är den typ av dagsräkningssystem som du "
#~ "vill använda:\n"
#~ "\n"
#~ "0  Amerikanskt 30/360\n"
#~ "1  verkliga dagar/verkliga dagar\n"
#~ "2  verkliga dagar/360\n"
#~ "3  verkliga dagar/365\n"
#~ "4  Europeiskt 30/360\n"
#~ "\n"
#~ "* Om datumen @avräkning eller @mognad inte är giltiga returnerar PRICEMAT "
#~ "felvärdet #NUM!.\n"
#~ "* Om @bas utelämnas används amerikanskt 30/360-system.\n"
#~ "* Om @bas < 0 eller @bas > 4 returnerar PRICEMAT felvärdet #NUM!.\n"
#~ "* Om @avräkning är efter @mognad eller om de är identiska returnerar "
#~ "PRICEMAT felvärdet #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=PRICEDISC"

#~ msgid ""
#~ "@FUNCTION=DISC\n"
#~ "@SYNTAX=DISC(settlement,maturity,par,redemption[,basis])\n"
#~ "@DESCRIPTION=DISC calculates and returns the discount rate for a "
#~ "security. @settlement is the settlement date of the security.\n"
#~ "\n"
#~ "@maturity is the maturity date of the security.  @par is the price per "
#~ "$100 face value of the security.  @redemption is the redemption value per "
#~ "$100 face value of the security.\n"
#~ "\n"
#~ "@basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @settlement date or @maturity date is not valid, DISC returns #NUM! "
#~ "error.\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis < 0 or @basis > 4, DISC returns #NUM! error.\n"
#~ "* If @settlement date is after @maturity date or they are the same, DISC "
#~ "returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=DISC\n"
#~ "@SYNTAX=DISC(avräkning;mognad;par;utlösande[;bas])\n"
#~ "@DESCRIPTION=DISC beräknar och returnerar reduceringshastigheten för en "
#~ "säkerhet.@avräkning är avräkningsdatumet för säkerheten.\n"
#~ "\n"
#~ "@mognad är mognadsdatumet för säkerheten. @par är priset per $100 av "
#~ "säkerheten. @utlösande är utlösandevärdet per $100 av värdet på "
#~ "säkerheten.\n"
#~ "\n"
#~ "@bas är den typ av dagsräkningssystem som du vill använda:\n"
#~ "\n"
#~ "0  Amerikanskt 30/360\n"
#~ "1  verkliga dagar/verkliga dagar\n"
#~ "2  verkliga dagar/360\n"
#~ "3  verkliga dagar/365\n"
#~ "4  Europeiskt 30/360\n"
#~ "\n"
#~ "* Om datumen @avräkning eller @mognad inte är giltiga returnerar DISC "
#~ "felvärdet #NUM!.\n"
#~ "* Om @bas utelämnas används amerikanskt 30/360-system.\n"
#~ "* Om @bas < 0 eller @bas > 4 returnerar DISC felvärdet #NUM!.\n"
#~ "* Om @avräkning är efter @mognad eller om de är identiska returnerar DISC "
#~ "felvärdet #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=EFFECT\n"
#~ "@SYNTAX=EFFECT(r,nper)\n"
#~ "@DESCRIPTION=EFFECT calculates the effective interest rate from a given "
#~ "nominal rate.\n"
#~ "\n"
#~ "Effective interest rate is calculated using this formula:\n"
#~ "\n"
#~ "    (1 + @r / @nper) ^ @nper - 1\n"
#~ "\n"
#~ "where:\n"
#~ "\n"
#~ "@r = nominal interest rate (stated in yearly terms)\n"
#~ "@nper = number of periods used for compounding\n"
#~ "\n"
#~ "* If @rate < 0, EFFECT returns #NUM! error.\n"
#~ "* If @nper <= 0, EFFECT returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "For example credit cards will list an APR (annual percentage rate) which "
#~ "is a nominal interest rate.\n"
#~ "For example if you wanted to find out how much you are actually paying "
#~ "interest on your credit card that states an APR of 19% that is compounded "
#~ "monthly you would type in:\n"
#~ "=EFFECT(.19,12) and you would get .2075 or 20.75%. That is the effective "
#~ "percentage you will pay on your loan.\n"
#~ "@SEEALSO=NOMINAL"
#~ msgstr ""
#~ "@FUNCTION=EFFECT\n"
#~ "@SYNTAX=EFFECT(r;antper)\n"
#~ "@DESCRIPTION=EFFECT beräknar den effektiva räntan från en given nominell "
#~ "räntesats.\n"
#~ "\n"
#~ "Effektiv ränta beräknas med följande formel:\n"
#~ "\n"
#~ "    (1 + @r / @antper) ^ @antper - 1\n"
#~ "\n"
#~ "där:\n"
#~ "\n"
#~ "@r = nominell räntesats (angiven i årliga villkor)\n"
#~ "@antper = antalet perioder som används för sammanräkning\n"
#~ "\n"
#~ "* Om @r < 0, returnerar EFFECT felvärdet #NUM!.\n"
#~ "* Om @antper <= 0, returnerar EFFECT felvärdet #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Kreditkort brukar till exempel ange en ÅPS (årlig procentsats) som är en "
#~ "nominell räntesats.\n"
#~ "Om du till exempel vill veta hur mycket ränta du verkligen betalar på "
#~ "ditt kreditkort som anger en ÅPS på 19% som sammanräknas månadsvis anger "
#~ "du:\n"
#~ "=EFFECT(0,19;12) och du kommer att få 0,2075 eller 20,75%. Det är den "
#~ "effektiva räntan som du kommer att betala på ditt lån.\n"
#~ "@SEEALSO=NOMINAL"

#~ msgid ""
#~ "@FUNCTION=NOMINAL\n"
#~ "@SYNTAX=NOMINAL(r,nper)\n"
#~ "@DESCRIPTION=NOMINAL calculates the nominal interest rate from a given "
#~ "effective rate.\n"
#~ "\n"
#~ "Nominal interest rate is given by a formula:\n"
#~ "\n"
#~ "@nper * (( 1 + @r ) ^ (1 / @nper) - 1 )\n"
#~ "where:\n"
#~ "\n"
#~ "@r = effective interest rate\n"
#~ "@nper = number of periods used for compounding\n"
#~ "\n"
#~ "* If @rate < 0, NOMINAL returns #NUM! error.\n"
#~ "* If @nper <= 0, NOMINAL returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=EFFECT"
#~ msgstr ""
#~ "@FUNCTION=NOMINAL\n"
#~ "@SYNTAX=NOMINAL(r;antper)\n"
#~ "@DESCRIPTION=NOMINAL beräknar den nominella räntesatsen från en given "
#~ "effektiv sats.\n"
#~ "\n"
#~ "Nominell räntesats ges av följande formel:\n"
#~ "\n"
#~ "@antper * (( 1 + @r ) ^ (1 / @antper) - 1 )\n"
#~ "där:\n"
#~ "\n"
#~ "@r = effektiv räntesats\n"
#~ "@antper = antalet perioder som används för sammanräkning\n"
#~ "\n"
#~ "* Om @r < 0, returnerar NOMINAL felvärdet #NUM!.\n"
#~ "* Om @antper <= 0, returnerar NOMINAL felvärdet #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=EFFECT"

#~ msgid ""
#~ "@FUNCTION=ISPMT\n"
#~ "@SYNTAX=ISPMT(rate,per,nper,pv)\n"
#~ "@DESCRIPTION=ISPMT function returns the interest paid on a given period.\n"
#~ "\n"
#~ "* If @per < 1 or @per > @nper, ISPMT returns #NUM! error. \n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=PV"
#~ msgstr ""
#~ "@FUNCTION=ISPMT\n"
#~ "@SYNTAX=ISPMT(räntesats;per;nper;pv)\n"
#~ "@DESCRIPTION=ISPMT returnerar den betalda räntan för en viss period.\n"
#~ "\n"
#~ "* Om @per < 1 eller @per > @nper, returnerar ISPMT felvärdet #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=PV"

#~ msgid ""
#~ "@FUNCTION=DB\n"
#~ "@SYNTAX=DB(cost,salvage,life,period[,month])\n"
#~ "@DESCRIPTION=DB calculates the depreciation of an asset for a given "
#~ "period using the fixed-declining balance method.  @cost is the initial "
#~ "value of the asset.  @salvage is the value after the depreciation.\n"
#~ "\n"
#~ "@life is the number of periods overall.  @period is the period for which "
#~ "you want the depreciation to be calculated.  @month is the number of "
#~ "months in the first year of depreciation.\n"
#~ "\n"
#~ "* If @month is omitted, it is assumed to be 12.\n"
#~ "* If @cost = 0, DB returns #NUM! error.\n"
#~ "* If @life <= 0, DB returns #NUM! error.\n"
#~ "* If @salvage / @cost < 0, DB returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=DDB,SLN,SYD"
#~ msgstr ""
#~ "@FUNCTION=DB\n"
#~ "@SYNTAX=DB(kostnad;rest;livslängd;period[;månad])\n"
#~ "@DESCRIPTION=DB beräknar avskrivningen för en tillgång över en given "
#~ "period med metoden fast degressiv avskrivning. @kostnad är det "
#~ "ursprungliga värdet av tillgången. @rest är värdet efter avskrivningen.\n"
#~ "\n"
#~ "@livslängd är det totala antalet perioder och @period är den period för "
#~ "vilken du vill beräkna avskrivningen. @månad är antalet månader under det "
#~ "första året av avskrivningen. \n"
#~ "\n"
#~ "* Om @månad utelämnas, antas antalet vara 12 månader.\n"
#~ "* Om @kostnad = 0 returneras felvärdet #NUM!.\n"
#~ "* Om @livslängd <= 0 returneras felvärdet #NUM!.\n"
#~ "* Om @rest / @kostnad < 0 returneras felvärdet #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=DDB,SLN,SYD"

#~ msgid ""
#~ "@FUNCTION=DDB\n"
#~ "@SYNTAX=DDB(cost,salvage,life,period[,factor])\n"
#~ "@DESCRIPTION=DDB returns the depreciation of an asset for a given period "
#~ "using the double-declining balance method or some other similar method "
#~ "you specify.\n"
#~ "\n"
#~ "@cost is the initial value of the asset, @salvage is the value after the "
#~ "last period, @life is the number of periods, @period is the period for "
#~ "which you want the depreciation to be calculated, and @factor is the "
#~ "factor at which the balance declines.\n"
#~ "\n"
#~ "* If @factor is omitted, it is assumed to be two (double-declining "
#~ "balance method).\n"
#~ "* If @life <= 0, DDB returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=SLN,SYD"
#~ msgstr ""
#~ "@FUNCTION=DDB\n"
#~ "@SYNTAX=DDB(kostnad;rest;livslängd;period[;faktor])\n"
#~ "@DESCRIPTION=DDB returnerar avskrivningen för en tillgång över en given "
#~ "period enligt metoden dubbel degressiv avskrivning eller någon liknande "
#~ "metod som du anger.\n"
#~ "\n"
#~ "@kostnad är det ursprungliga värdet av tillgången. @rest är värdet efter "
#~ "avskrivningen. @livslängd är det totala antalet perioder och @period är "
#~ "den period för vilken du vill beräkna avskrivningen. @faktor är den "
#~ "faktor med vilken balansräkningen minskar.\n"
#~ "\n"
#~ "* Om @faktor utelämnas, antas värdet 2 (dubbel degressiv avskrivning).\n"
#~ "* Om @livslängd <=0 returneras felvärdet #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=SLN,SYD"

#~ msgid ""
#~ "@FUNCTION=SLN\n"
#~ "@SYNTAX=SLN(cost,salvage_value,life)\n"
#~ "@DESCRIPTION=SLN function will determine the straight line depreciation "
#~ "of an asset for a single period.\n"
#~ "\n"
#~ "The formula is:\n"
#~ "\n"
#~ "Depreciation expense = ( @cost - @salvage_value ) / @life\n"
#~ "\n"
#~ "@cost is the cost of an asset when acquired (market value).\n"
#~ "@salvage_value is the amount you get when asset is sold at the end of the "
#~ "asset's useful life.\n"
#~ "@life is the anticipated life of an asset.\n"
#~ "\n"
#~ "* If @life <= 0, SLN returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "For example, lets suppose your company purchases a new machine for "
#~ "$10,000, which has a salvage value of $700 and will have a useful life of "
#~ "10 years. The SLN yearly depreciation is computed as follows:\n"
#~ "=SLN(10000, 700, 10)\n"
#~ "This will return the yearly depreciation figure of $930.\n"
#~ "@SEEALSO=SYD"
#~ msgstr ""
#~ "@FUNCTION=SLN\n"
#~ "@SYNTAX=SLN(kostnad;slutvärde;livslängd)\n"
#~ "@DESCRIPTION=Funktionen SLN bestämmer den raka värdeminskningen för en "
#~ "tillgång under en ensam period.\n"
#~ "\n"
#~ "Formeln som används för rak värdeminskning är:\n"
#~ "\n"
#~ "Värdeminskningskostnad = ( @kostnad - @slutvärde ) / @livslängd\n"
#~ "\n"
#~ "@kostnad = kostnaden för en tillgång då den införskaffas "
#~ "(marknadsvärde).\n"
#~ "@slutvärde = summan du får för tillgången då den säljs vid slutet av sin "
#~ "livslängd.\n"
#~ "@livslängd = uppskattad livsängd för en tillgång.\n"
#~ "\n"
#~ "* Om @livslängd <= 0 returneras felvärdet #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Låt oss anta att vårt företag köper en ny maskin för 100000 kr som har "
#~ "ett slutvärde på 7000 kr och en effektiv livslängd på 10 år. Den årliga "
#~ "SLN-värdeminskningen beräknas som följer:\n"
#~ "=SLN(100000; 7000; 10)\n"
#~ "Detta kommer att returnera det årliga värdeminskningsvärdet 9300 kr.\n"
#~ "@SEEALSO=SYD"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=SYD\n"
#~ "@SYNTAX=SYD(cost,salvage_value,life,period)\n"
#~ "@DESCRIPTION=SYD function calculates the sum-of-years digits depreciation "
#~ "for an asset based on its cost, salvage value, anticipated life and a "
#~ "particular period. This method accelerates the rate of the depreciation, "
#~ "so that more depreciation expense occurs in earlier periods than in later "
#~ "ones. The depreciable cost is the actual cost minus the salvage value. "
#~ "The useful life is the number of periods (typically years) over which the "
#~ "asset is depreciated.\n"
#~ "\n"
#~ "The Formula used for sum-of-years digits depreciation is:\n"
#~ "\n"
#~ "Depreciation expense =\n"
#~ "\n"
#~ "\t ( @cost - @salvage_value ) * (@life - @period + 1) * 2 / @life * "
#~ "(@life + 1).\n"
#~ "\n"
#~ "@cost is the cost of an asset when acquired (market value).\n"
#~ "@salvage_value is the amount you get when asset sold at the end of its "
#~ "useful life.\n"
#~ "@life is the anticipated life of an asset.\n"
#~ "@period is the period for which we need the expense.\n"
#~ "\n"
#~ "* If @life <= 0, SYD returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "For example say a company purchases a new computer for $5000 which has a "
#~ "salvage value of $200, and a useful life of five years. We would use the "
#~ "following to calculate the second year's depreciation using the SYD "
#~ "method:\n"
#~ "=SYD(5000, 200, 5, 2) which returns 1,280.00.\n"
#~ "@SEEALSO=SLN"
#~ msgstr ""
#~ "@FUNCTION=SYD\n"
#~ "@SYNTAX=SYD(kostnad;slutvärde;livslängd;period)\n"
#~ "@DESCRIPTION=Funktionen SYD beräknar \"sum-of-years digits\"-"
#~ "avskrivningen för en tillgång, baserat på dess kostnad, slutvärde, "
#~ "förväntad livslängd och en given period. Metoden accelererar "
#~ "värdeminskningen, så att störst värdeminskning sker i början. Den "
#~ "avskrivbara kostnaden är den faktiskta kostnaden minus slutvärdet. "
#~ "Livslängden är den period (anges ofta i år) som värdeminskningen pågår.\n"
#~ "\n"
#~ "Formeln som används för \"sum-of-years digits\"-avskrivningen är:\n"
#~ "\n"
#~ "Värdeminskning = \n"
#~ "\n"
#~ "\t (@kostnad - @slutvärde) * (@livslängd - @period + 1) * 2 / @livslängd "
#~ "* (@livslängd + 1).\n"
#~ "\n"
#~ "@kostnad = inköpskostnad (marknadsvärde).\n"
#~ "@slutvärde = summa som fås när tillgången säljs vid utgången av "
#~ "livslängden.\n"
#~ "@livslängd = förväntad livslängd för tillgången.\n"
#~ "@period = den period vilken vi behöver tillgången.\n"
#~ "\n"
#~ "* Om @livslängd <=0 returneras felvärdet #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att att ett företag köper in en ny dator till en kostnad av SEK "
#~ "50000, med ett slutvärde på SEK 2000, och en livslängd på tre år. För att "
#~ "beräkna avskrivningens värde för andra året gör vi då: \n"
#~ "=SYD(50000; 2000; 3; 2), vilket resulterar i 16000.\n"
#~ "@SEEALSO=SLN"

#~ msgid ""
#~ "@FUNCTION=DOLLARDE\n"
#~ "@SYNTAX=DOLLARDE(fractional_dollar,fraction)\n"
#~ "@DESCRIPTION=DOLLARDE converts a dollar price expressed as a fraction "
#~ "into a dollar price expressed as a decimal number.\n"
#~ "\n"
#~ "@fractional_dollar is the fractional number to be converted. @fraction is "
#~ "the denominator of the fraction.\n"
#~ "\n"
#~ "* If @fraction is non-integer it is truncated.\n"
#~ "* If @fraction <= 0, DOLLARDE returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=DOLLARFR"
#~ msgstr ""
#~ "@FUNCTION=DOLLARDE\n"
#~ "@SYNTAX=DOLLARDE(decimaltal;bråktal)\n"
#~ "@DESCRIPTION=DOLLARDE omvandlar ett pris i dollar uttryckt som ett "
#~ "bråktal till ett pris i dollar uttryckt som ett decimaltal.\n"
#~ "\n"
#~ "@decimaltal är talet som ska konverteras. @bråktal är nämnaren till "
#~ "bråket.\n"
#~ "\n"
#~ "* Om @bråktal inte är ett heltal, avkortas det. \n"
#~ "* Om @bråktal <=0 returneras felvärdet #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=DOLLARFR"

#~ msgid ""
#~ "@FUNCTION=DOLLARFR\n"
#~ "@SYNTAX=DOLLARFR(decimal_dollar,fraction)\n"
#~ "@DESCRIPTION=DOLLARFR converts a decimal dollar price into a dollar price "
#~ "expressed as a fraction.\n"
#~ "\n"
#~ "* If @fraction is non-integer it is truncated.\n"
#~ "* If @fraction <= 0, DOLLARFR returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=DOLLARDE"
#~ msgstr ""
#~ "@FUNCTION=DOLLARFR\n"
#~ "@SYNTAX=DOLLARFR(decimaltal;bråktal)\n"
#~ "@DESCRIPTION=DOLLARFR omvandlar ett pris i dollar uttryckt som ett "
#~ "decimaltal till ett pris i dollar uttryckt som ett bråktal.\n"
#~ "\n"
#~ "* Om @bråktal inte är ett heltal, avkortas det.i\n"
#~ "* Om @bråktal <= 0 returneras felvärdet #NUM!\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=DOLLARDE"

#~ msgid ""
#~ "@FUNCTION=MIRR\n"
#~ "@SYNTAX=MIRR(values,finance_rate,reinvest_rate)\n"
#~ "@DESCRIPTION=MIRR function returns the modified internal rate of return "
#~ "for a given periodic cash flow. \n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=NPV"
#~ msgstr ""
#~ "@FUNCTION=MIRR\n"
#~ "@SYNTAX=MIRR(värden;finanshastighet;återinvesteringshastighet)\n"
#~ "@DESCRIPTION=Funktionen MIRR returnerar den modifierade interna "
#~ "hastigheten för returnering av ett angivet periodiskt kontantflöde.\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=NPV"

#~ msgid ""
#~ "@FUNCTION=TBILLEQ\n"
#~ "@SYNTAX=TBILLEQ(settlement,maturity,discount)\n"
#~ "@DESCRIPTION=TBILLEQ function returns the bond-yield equivalent (BEY) for "
#~ "a treasury bill.  TBILLEQ is equivalent to\n"
#~ "\n"
#~ "\t(365 * @discount) / (360 - @discount * DSM),\n"
#~ "\n"
#~ "where DSM is the days between @settlement and @maturity.\n"
#~ "\n"
#~ "* If @settlement is after @maturity or the @maturity is set to over one "
#~ "year later than the @settlement, TBILLEQ returns #NUM! error.\n"
#~ "* If @discount is negative, TBILLEQ returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=TBILLPRICE,TBILLYIELD"
#~ msgstr ""
#~ "@FUNCTION=TBILLEQ\n"
#~ "@SYNTAX=TBILLEQ(avräkning;mognad;reducering)\n"
#~ "@DESCRIPTION=Funktionen TBILLEQ returnerar "
#~ "säkerhetsavkastningsekvivalenten (SAE) för en skattkammarväxel. TBILLEQ "
#~ "motsvarar\n"
#~ "\n"
#~ "\t(365 * @reducering) / (360 - @reducering * DSM),\n"
#~ "\n"
#~ "där DSM är dagarna mellan @avräkning och @mognad.\n"
#~ "\n"
#~ "* Om @avräkning är efter @mognad eller om @mognad är inställd till över "
#~ "ett år senare än @avräkning, returnerar TBILLEQ felvärdet #NUM!.\n"
#~ "* Om @avräkning är negativt returnerar TBILLEQ felvärdet #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=TBILLPRICE,TBILLYIELD"

#~ msgid ""
#~ "@FUNCTION=TBILLPRICE\n"
#~ "@SYNTAX=TBILLPRICE(settlement,maturity,discount)\n"
#~ "@DESCRIPTION=TBILLPRICE function returns the price per $100 value for a "
#~ "treasury bill where @settlement is the settlement date and @maturity is "
#~ "the maturity date of the bill.  @discount is the treasury bill's discount "
#~ "rate.\n"
#~ "\n"
#~ "* If @settlement is after @maturity or the @maturity is set to over one "
#~ "year later than the @settlement, TBILLPRICE returns #NUM! error.\n"
#~ "* If @discount is negative, TBILLPRICE returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=TBILLEQ,TBILLYIELD"
#~ msgstr ""
#~ "@FUNCTION=TBILLPRICE\n"
#~ "@SYNTAX=TBILLPRICE(avräkning;mognad;reducering)\n"
#~ "@DESCRIPTION=Funktionen TBILLPRICE returnerar priset per $100 värde för "
#~ "en skattkammarväxel där @avräkning är avräkningsdatumet och @mognad är "
#~ "mognadsdatumet för växeln. @reducering är skattkammarväxelns "
#~ "reduceringshastighet.\n"
#~ "\n"
#~ "* Om @avräkning är efter @mognad eller om @mognad är inställd till över "
#~ "ett år senare än @avräkning, returnerar TBILLPRICE felvärdet #NUM!.\n"
#~ "* Om @avräkning är negativt returnerar TBILLPRICE felvärdet #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=TBILLEQ,TBILLYIELD"

#~ msgid ""
#~ "@FUNCTION=TBILLYIELD\n"
#~ "@SYNTAX=TBILLYIELD(settlement,maturity,pr)\n"
#~ "@DESCRIPTION=TBILLYIELD function returns the yield for a treasury bill. "
#~ "@settlement is the settlement date and @maturity is the maturity date of "
#~ "the bill.  @discount is the treasury bill's discount rate.\n"
#~ "\n"
#~ "* If @settlement is after @maturity or the @maturity is set to over one "
#~ "year later than the @settlement, TBILLYIELD returns #NUM! error.\n"
#~ "* If @pr is negative, TBILLYIELD returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=TBILLEQ,TBILLPRICE"
#~ msgstr ""
#~ "@FUNCTION=TBILLYIELD\n"
#~ "@SYNTAX=TBILLYIELD(avräkning;mognad;pr)\n"
#~ "@DESCRIPTION=Funktionen TBILLYIELD returnerar avkastningen för en "
#~ "skattkammarväxel. @avräkning är avräkningsdatumet och @mognad är "
#~ "mognadsdatumet för växeln. @reducering är skattkammarväxelns "
#~ "reduceringshastighet.\n"
#~ "\n"
#~ "* Om @avräkning är efter @mognad eller om @mognad är inställd till över "
#~ "ett år senare än @avräkning, returnerar TBILLYIELD felvärdet #NUM!.\n"
#~ "* Om @avräkning är negativt returnerar TBILLYIELD felvärdet #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=TBILLEQ,TBILLPRICE"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=RATE\n"
#~ "@SYNTAX=RATE(nper,pmt,pv[,fv,type,guess])\n"
#~ "@DESCRIPTION=RATE calculates the rate of an investment.\n"
#~ "\n"
#~ "* If @pmt is omitted it defaults to 0\n"
#~ "* If @nper <= 0, RATE returns #NUM! error.\n"
#~ "* If @type != 0 and @type != 1, RATE returns #VALUE! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=PV,FV"
#~ msgstr ""
#~ "@FUNCTION=RATE\n"
#~ "@SYNTAX=RATE(nper;pmt;pv[;fv;typ;gissning])\n"
#~ "@DESCRIPTION=RATE beräknar räntesatsen för en investering.\n"
#~ "\n"
#~ "* Om @nper <=0  returneras TBILLYIELD felvärdet #NUM!.\n"
#~ "* Om @typ != 0 och @typ !=1 returneras felvärdet #VALUE!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=PV,FV"

#~ msgid ""
#~ "@FUNCTION=IRR\n"
#~ "@SYNTAX=IRR(values[,guess])\n"
#~ "@DESCRIPTION=IRR calculates and returns the internal rate of return of an "
#~ "investment.  This function is closely related to the net present value "
#~ "function (NPV).  The IRR is the interest rate for a series of cash flows "
#~ "where the net preset value is zero.\n"
#~ "\n"
#~ "@values contains the series of cash flows generated by the investment.  "
#~ "The payments should occur at regular intervals.  The optional @guess is "
#~ "the initial value used in calculating the IRR.  You do not have to use "
#~ "that, it is only provided for the Excel compatibility.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1:A8 contain the numbers -32432, 5324, "
#~ "7432, 9332, 12324, 4334, 1235, -3422.  Then\n"
#~ "IRR(A1:A8) returns 0.04375. \n"
#~ "@SEEALSO=FV,NPV,PV"
#~ msgstr ""
#~ "@FUNCTION=IRR\n"
#~ "@SYNTAX=IRR(värden[,gissning])\n"
#~ "@DESCRIPTION=IRR beräknar och returnerar den interna "
#~ "returneringshastigheten för en investering. Denna funktion är nära släkt "
#~ "med aktuellt nettovärde (NPV). IRR är den räntesats för en serie med "
#~ "pengaflöde där aktuellt nettovärde är noll.\n"
#~ "\n"
#~ "@värden innehåller den serie med pengaflöde som genereras av "
#~ "investeringen. Betalningarna bör inträffa med jämna mellanrum. Den "
#~ "valfria @gissningen är det ursprungliga värdet som används vid beräkning "
#~ "av IRR. Du behöver inte använda den, den tillhandahålls endast för "
#~ "kompatibilitet med Excel.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att cellerna A1:A8 innehåller talen -32432, 5324, 7432, 9332, "
#~ "12324, 4334, 1235, -3422. Då är\n"
#~ "IRR(A1:A8) lika med 0,04375. \n"
#~ "@SEEALSO=FV,NPV,PV"

#~ msgid ""
#~ "@FUNCTION=PV\n"
#~ "@SYNTAX=PV(rate,nper,pmt[,fv,type])\n"
#~ "@DESCRIPTION=PV calculates the present value of an investment. @rate is "
#~ "the periodic interest rate, @nper is the number of periods used for "
#~ "compounding. @pmt is the payment made each period, @fv is the future "
#~ "value and @type is when the payment is made.\n"
#~ "\n"
#~ "* If @type = 1 then the payment is made at the beginning of the period.\n"
#~ "* If @type = 0 (or omitted) it is made at the end of each period.\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=FV"
#~ msgstr ""
#~ "@FUNCTION=PV\n"
#~ "@SYNTAX=PV(ränta;nper;bet[;fv;typ])\n"
#~ "@DESCRIPTION=PV beräknar det nuvarande värdet av en investering. @ränta "
#~ "är en periodisk ränta, @nper är antalet perioder. @bet är betalningen "
#~ "varje period, @fv är det framtida värdet och @typ anger när betalning "
#~ "sker.\n"
#~ "\n"
#~ "* Om @typ = 1 sker betalning i början av perioden.\n"
#~ "* Om @typ = 0 (eller utelämnas) sker betalning i slutet av perioden.\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=FV"

#~ msgid ""
#~ "@FUNCTION=NPV\n"
#~ "@SYNTAX=NPV(rate,v1,v2,...)\n"
#~ "@DESCRIPTION=NPV calculates the net present value of an investment "
#~ "generating periodic payments.  @rate is the periodic interest rate and "
#~ "@v1, @v2, ... are the periodic payments.  If the schedule of the cash "
#~ "flows are not periodic use the XNPV function. \n"
#~ "@EXAMPLES=\n"
#~ "NPV(0.17,-10000,3340,2941,2493,3233,1732,2932) equals 186.30673.\n"
#~ "\n"
#~ "@SEEALSO=PV,XNPV"
#~ msgstr ""
#~ "@FUNCTION=NPV\n"
#~ "@SYNTAX=NPV(ränta;v1;v2;...)\n"
#~ "@DESCRIPTION=NPV beräknar det nuvarande nettovärdet av en investering, "
#~ "med periodiska betalningar. @ränta är den periodiska räntan och @v1; "
#~ "@v2; ... är de periodiska betalningarna. Om betalningschemat inte är "
#~ "periodiskt, använd funktionen XNPV.\n"
#~ "@EXAMPLES=\n"
#~ "NPV(0,17;-10000;3340;2941;2493;3233;1732;2932) är lika med 186,30673.\n"
#~ "\n"
#~ "@SEEALSO=PV,XNPV"

#~ msgid ""
#~ "@FUNCTION=XNPV\n"
#~ "@SYNTAX=XNPV(rate,values,dates)\n"
#~ "@DESCRIPTION=XNPV calculates the net present value of an investment.  The "
#~ "schedule of the cash flows is given in @dates array.  The first date "
#~ "indicates the beginning of the payment schedule.  @rate is the interest "
#~ "rate and @values are the payments.\n"
#~ "\n"
#~ "* If @values and @dates contain unequal number of values, XNPV returns "
#~ "the #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=NPV,PV"
#~ msgstr ""
#~ "@FUNCTION=XNPV\n"
#~ "@SYNTAX=XNPV(ränta;värden;datum)\n"
#~ "@DESCRIPTION=XNPV beräknar det nuvarande nettovärdet av en investering. "
#~ "Flödet av pengar anges i fältet @datum, där det första datumet indikerar "
#~ "början av betalningsschemat. @ränta och @värden anger räntan och de "
#~ "betalningar som görs.\n"
#~ "\n"
#~ "* Om @värden och @datum inte innehåller samma värden, returneras "
#~ "felvärdet #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=NPV,PV"

#~ msgid ""
#~ "@FUNCTION=XIRR\n"
#~ "@SYNTAX=XIRR(values,dates[,guess])\n"
#~ "@DESCRIPTION=XIRR calculates and returns the internal rate of return of "
#~ "an investment that has not necessarily periodic payments.  This function "
#~ "is closely related to the net present value function (NPV and XNPV).  The "
#~ "XIRR is the interest rate for a series of cash flows where the XNPV is "
#~ "zero.\n"
#~ "\n"
#~ "@values contains the series of cash flows generated by the investment.  "
#~ "@dates contains the dates of the payments.  The first date describes the "
#~ "payment day of the initial payment and thus all the other dates should be "
#~ "after this date. The optional @guess is the initial value used in "
#~ "calculating the XIRR.  You do not have to use that, it is only provided "
#~ "for the Excel compatibility.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1:A5 contain the numbers -6000, 2134, 1422, "
#~ "1933, and 1422, and the cells B1:B5 contain the dates \"1999-01-15\", "
#~ "\"1999-04-04\", \"1999-05-09\", \"2000-03-12\", and \"2000-05-1\". Then\n"
#~ "XIRR(A1:A5,B1:B5) returns 0.224838. \n"
#~ "@SEEALSO=IRR,XNPV"
#~ msgstr ""
#~ "@FUNCTION=XIRR\n"
#~ "@SYNTAX=XIRR(värden,datum[,gissning])\n"
#~ "@DESCRIPTION=XIRR beräknar och returnerar den interna "
#~ "returneringshastigheten för en investering som inte nödvändigtvis har "
#~ "periodiska betalningar. Denna funktion är nära släkt med aktuellt "
#~ "nettovärde (NPV och XNPV). XIRR är den räntesats för en serie med "
#~ "pengaflöde där XNPV är noll.\n"
#~ "\n"
#~ "@värden innehåller den serie med pengaflöde som genereras av "
#~ "investeringen. @datum innehåller datumen för betalningarna. Det första "
#~ "datumet är datumet för den första betalningen och därför måste alla andra "
#~ "värden vara efter detta datum. Den valfria @gissningen är det "
#~ "ursprungliga värdet som används vid beräkning av XIRR. Du behöver inte "
#~ "använda den, den tillhandahålls endast för kompatibilitet med Excel.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att cellerna A1:A5 innehåller talen -6000, 2134, 1422, 1933 och "
#~ "1422, och cellerna B1:B5 innehåller datumen \"1999-01-15\", \"1999-04-04"
#~ "\", \"1999-05-09\", \"2000-03-12\" och \"2000-05-01\". Då är\n"
#~ "XIRR(A1:A5;B1:B5) lika med 0,224838. \n"
#~ "@SEEALSO=IRR,XNPV"

#~ msgid ""
#~ "@FUNCTION=FV\n"
#~ "@SYNTAX=FV(rate,nper,pmt[,pv,type])\n"
#~ "@DESCRIPTION=FV computes the future value of an investment. This is based "
#~ "on periodic, constant payments and a constant interest rate. The interest "
#~ "rate per period is @rate, @nper is the number of periods in an annuity, "
#~ "@pmt is the payment made each period, @pv is the present value and @type "
#~ "is when the payment is made.\n"
#~ "\n"
#~ "* If @type = 1 then the payment is made at the beginning of the period.\n"
#~ "* If @type = 0 it is made at the end of each period.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=PV,PMT,PPMT"
#~ msgstr ""
#~ "@FUNCTION=FV\n"
#~ "@SYNTAX=FV(ränta;term;bet[;pv;typ])\n"
#~ "@DESCRIPTION=FV beräknar det framtida värdet av en investering. Detta är "
#~ "baserat på periodiska, konstanta betalningar och en konstant ränta. "
#~ "Räntan varje period är @ränta, @term är antalet perioder i en annuitet, "
#~ "@bet är betalningen varje period, @pv är det nuvarande värdet och @typ "
#~ "anger när betalningen sker.\n"
#~ "\n"
#~ "* Om @typ = 1 sker betalning i början av perioden.\n"
#~ "* Om @typ = 0  sker betalning i slutet av perioden.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=PV,PMT,PPMT"

#~ msgid ""
#~ "@FUNCTION=PMT\n"
#~ "@SYNTAX=PMT(rate,nper,pv[,fv,type])\n"
#~ "@DESCRIPTION=PMT returns the amount of payment for a loan based on a "
#~ "constant interest rate and constant payments (each payment is equal "
#~ "amount).\n"
#~ "\n"
#~ "@rate is the constant interest rate.\n"
#~ "@nper is the overall number of payments.\n"
#~ "@pv is the present value.\n"
#~ "@fv is the future value.\n"
#~ "@type is the type of the payment: 0 means at the end of the period and 1 "
#~ "means at the beginning of the period.\n"
#~ "\n"
#~ "* If @fv is omitted, Gnumeric assumes it to be zero.\n"
#~ "* If @type is omitted, Gnumeric assumes it to be zero.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=PPMT,PV,FV"
#~ msgstr ""
#~ "@FUNCTION=PMT\n"
#~ "@SYNTAX=PMT(ränta,antper,pv[,fv,typ])\n"
#~ "@DESCRIPTION=PMT returnerar betalningen för ett lån baserat på en fast "
#~ "ränta och fasta betalningar (varje betalning är lika stor).\n"
#~ "\n"
#~ "@ränta är den fasta räntesatsen.\n"
#~ "@antper är det totala antalet betalningar.\n"
#~ "@pv är det aktuella värdet.\n"
#~ "@fv är det framtida värdet.\n"
#~ "@typ är typen av betalning: 0 betyder slutet på perioden och 1 betyder "
#~ "början på perioden.\n"
#~ "\n"
#~ "* Om @fv utelämnas antar Gnumeric att den är noll.\n"
#~ "* Om @typ utelämnas antar Gnumeric att den är noll.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=PPMT,PV,FV"

#~ msgid ""
#~ "@FUNCTION=IPMT\n"
#~ "@SYNTAX=IPMT(rate,per,nper,pv[,fv,type])\n"
#~ "@DESCRIPTION=IPMT calculates the amount of a payment of an annuity going "
#~ "towards interest.\n"
#~ "\n"
#~ "Formula for IPMT is:\n"
#~ "\n"
#~ "IPMT(PER) = -PRINCIPAL(PER-1) * INTEREST_RATE\n"
#~ "\n"
#~ "where:\n"
#~ "\n"
#~ "PRINCIPAL(PER-1) = amount of the remaining principal from last period\n"
#~ "\n"
#~ "* If @fv is omitted, it is assumed to be 0.\n"
#~ "* If @type is omitted, it is assumed to be 0.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=PPMT,PV,FV"
#~ msgstr ""
#~ "@FUNCTION=IPMT\n"
#~ "@SYNTAX=IPMT(ränta,per,antper,pv,fv,typ)\n"
#~ "@DESCRIPTION=IPMT beräknar summan av en betalning på en livränta som går "
#~ "mot ränta.\n"
#~ "\n"
#~ "Formeln för IPMT är:\n"
#~ "\n"
#~ "IPMT(PER) = -KAPITAL(PER-1) * RÄNTESATS\n"
#~ "\n"
#~ "där:\n"
#~ "\n"
#~ "KAPITAL(PER-1) = summan av återstående kapital för föregående period\n"
#~ "\n"
#~ "* Om @fv utelämnas antas den vara 0.\n"
#~ "* Om @typ utelämnas antas den vara 0.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=PPMT,PV,FV"

#~ msgid ""
#~ "@FUNCTION=PPMT\n"
#~ "@SYNTAX=PPMT(rate,per,nper,pv[,fv,type])\n"
#~ "@DESCRIPTION=PPMT calculates the amount of a payment of an annuity going "
#~ "towards principal.\n"
#~ "\n"
#~ "Formula for it is:\n"
#~ "PPMT(per) = PMT - IPMT(per)\n"
#~ "where:\n"
#~ "\n"
#~ "PMT = Payment received on annuity\n"
#~ "IPMT(per) = amount of interest for period @per\n"
#~ "\n"
#~ "* If @fv is omitted, it is assumed to be 0.\n"
#~ "* If @type is omitted, it is assumed to be 0.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=IPMT,PV,FV"
#~ msgstr ""
#~ "@FUNCTION=PPMT\n"
#~ "@SYNTAX=PPMT(ränta,per,antper,pv[,fv,typ])\n"
#~ "@DESCRIPTION=PPMT beräknar summan av en betalning på en livränta som går "
#~ "mot kapital.\n"
#~ "\n"
#~ "Formeln för den är:\n"
#~ "PPMT(per) = PMT - IPMT(per)\n"
#~ "där:\n"
#~ "\n"
#~ "PMT = Betalning mottagen för livränta\n"
#~ "IPMT(per) = summan av räntan för period @per\n"
#~ "\n"
#~ "* Om @fv utelämnas antas den vara 0.\n"
#~ "* Om @typ utelämnas antas den vara 0.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=IPMT,PV,FV"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=NPER\n"
#~ "@SYNTAX=NPER(rate,pmt,pv[,fv,type])\n"
#~ "@DESCRIPTION=NPER calculates number of periods of an investment based on "
#~ "periodic constant payments and a constant interest rate.\n"
#~ "\n"
#~ "The interest rate per period is @rate, @pmt is the payment made each "
#~ "period, @pv is the present value, @fv is the future value and @type is "
#~ "when the payments are due. If @type = 1, payments are due at the "
#~ "beginning of the period, if @type = 0, payments are due at the end of the "
#~ "period.\n"
#~ "\n"
#~ "* If @rate <= 0, NPER returns #DIV0 error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "For example, if you deposit $10,000 in a savings account that earns an "
#~ "interest rate of 6%. To calculate how many years it will take to double "
#~ "your investment use NPER as follows:\n"
#~ "=NPER(0.06, 0, -10000, 20000,0)returns 11.895661046 which indicates that "
#~ "you can double your money just before the end of the 12th year.\n"
#~ "@SEEALSO=PPMT,PV,FV"
#~ msgstr ""
#~ "@FUNCTION=NPER\n"
#~ "@SYNTAX=NPER(ränta;bet;pv;fv;typ)\n"
#~ "@DESCRIPTION=NPER beräknar antalet perioder för en investering baserad på "
#~ "periodiska, konstanta betalningar och konstant ränta.\n"
#~ "\n"
#~ "Räntan varje period är @ränta, @bet är den betalning som görs varje "
#~ "period, @pv och @fv är det nuvarande värdet respektive framtida värdet "
#~ "och @typ anger när betalningarna sker. Om @typ = 1, ska betalning ske i "
#~ "början av perioden, if @typ = 0, sker betalning i slutet av perioden.\n"
#~ "\n"
#~ "* Om @ränta <= 0 returneras felvärdet #DIV0.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att du avsätter SEK 10000 på ett sparkonto med en ränta på 6%, För "
#~ "att beräkna hur lång tid det kommer att ta för investeringen att dubblas:"
#~ "i\n"
#~ "=NPER(0,06; 0; -10000; 20000; 0), vilket resulterar i 11,895661046. Detta "
#~ "motsvarar alltså att pengarna har fördubblats precis före det 12:e året.\n"
#~ "@SEEALSO=PPMT,PV,FV"

#~ msgid ""
#~ "@FUNCTION=DURATION\n"
#~ "@SYNTAX=DURATION(settlement,maturity,coup,yield,frequency[,basis])\n"
#~ "@DESCRIPTION=DURATION calculates the duration of a security.\n"
#~ "\n"
#~ "@settlement is the settlement date of the security.\n"
#~ "@maturity is the maturity date of the security.\n"
#~ "@coup The annual coupon rate as a percentage.\n"
#~ "@yield The annualized yield of the security as a percentage.\n"
#~ "@frequency is the number of coupon payments per year. Allowed frequencies "
#~ "are: 1 = annual, 2 = semi, 4 = quarterly. @basis is the type of day "
#~ "counting system you want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @frequency is other than 1, 2, or 4, DURATION returns #NUM! error.\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis is not in between 0 and 4, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=G_DURATION,MDURATION"
#~ msgstr ""
#~ "@FUNCTION=DURATION\n"
#~ "@SYNTAX=DURATION(avräkning;mognad;kupong;avkastning;frekvens[;bas])\n"
#~ "@DESCRIPTION=DURATION beräknar livslängden på en säkerhet.\n"
#~ "\n"
#~ "@avräkning är avräkningsdatumet för säkerheten.\n"
#~ "@mognad är mognadsdatumet som är angiven för säkerheten.\n"
#~ "@kupong är den årliga kupongräntan i procent.\n"
#~ " @avkastning är den årliga avkastningen i procent.\n"
#~ "@frekvens är antalet kupongbetalningar per år. Tillåtna värden är "
#~ "1=årlig, 2=halvårsvis, 4=kvartalsvis.\n"
#~ "@bas är den typ av dagsräkningssystem som du vill använda:\n"
#~ "\n"
#~ "0  Amerikanskt 30/360\n"
#~ "1  verkliga dagar/verkliga dagar\n"
#~ "2  verkliga dagar/360\n"
#~ "3  verkliga dagar/365\n"
#~ "4  Europeiskt 30/360\n"
#~ "\n"
#~ "* Om @frekvens är en annan än 1, 2 eller 4 returnerar DURATION felvärdet "
#~ "#NUM!.\n"
#~ "* Om @bas utelämnas används amerikanskt 30/360-system.\n"
#~ "* Om @bas inte är mellan 0 och 4 returneras felvärdet #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=G_DURATION,MDURATION"

#~ msgid ""
#~ "@FUNCTION=G_DURATION\n"
#~ "@SYNTAX=G_DURATION(rate,pv,fv)\n"
#~ "@DESCRIPTION=G_DURATION calculates number of periods needed for an "
#~ "investment to attain a desired value. This function is similar to FV and "
#~ "PV with a difference that we do not need give the direction of cash flows "
#~ "e.g. -100 for a cash outflow and +100 for a cash inflow.\n"
#~ "\n"
#~ "* If @rate <= 0, G_DURATION returns #DIV0 error.\n"
#~ "* If @fv = 0 or @pv = 0, G_DURATION returns #DIV0 error.\n"
#~ "* If @fv / @pv < 0, G_DURATION returns #VALUE error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=PPMT,PV,FV,DURATION,MDURATION"
#~ msgstr ""
#~ "@FUNCTION=G_DURATION\n"
#~ "@SYNTAX=G_DURATION(ränta;pv;fv)\n"
#~ "@DESCRIPTION=G_DURATION beräknar antalet perioder som behövs för att en "
#~ "investering ska nå ett önskat värde. Funktionen liknar FV och PV, med "
#~ "skillnaden att vi inte behöver ange i vilken riktning pengarna flödar, "
#~ "till exempel -100 för utåt och +100 för inåt.\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "* Om @ränta <= 0, returneras felvärdet #DIV0.\n"
#~ "* Om @fv = 0 eller @pv = 0, returneras velvärdet #DIV0.\n"
#~ "* Om @fv / @pv < 0 returneras felvärdet #VALUE.\n"
#~ "\n"
#~ "@SEEALSO=PPMT,PV,FV,DURATION,MDURATION"

#~ msgid ""
#~ "@FUNCTION=FVSCHEDULE\n"
#~ "@SYNTAX=FVSCHEDULE(principal,schedule)\n"
#~ "@DESCRIPTION=FVSCHEDULE returns the future value of given initial value "
#~ "after applying a series of compound periodic interest rates. The argument "
#~ "@principal is the present value; @schedule is an array of interest rates "
#~ "to apply. The @schedule argument must be a range of cells.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain interest rates 0.11, "
#~ "0.13, 0.09, 0.17, and 0.03.  Then\n"
#~ "FVSCHEDULE(3000,A1:A5) equals 4942.7911611.\n"
#~ "@SEEALSO=PV,FV"
#~ msgstr ""
#~ "@FUNCTION=FVSCHEDULE\n"
#~ "@SYNTAX=FVSCHEDULE(kapital;schema)\n"
#~ "@DESCRIPTION=FVSCHEDULE returnerar det framtida värdet av ett givet "
#~ "begynnelsevärde efter användande av en serie sammanslagna periodiska "
#~ "räntesatser. Argumentet @kapital är det nuvarande värdet; @schema är en "
#~ "vektor med räntesatser att använda. Argumentet @schema måste vara ett "
#~ "cellområde.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att cellerna A1; A2; ...; A5 innehåller räntesatserna 0,11, 0,13, "
#~ "0,09, 0,17 och 0,03. Då är\n"
#~ "FVSCHEDULE(3000;A1:A5) lika med 4942,7911611.\n"
#~ "@SEEALSO=PV,FV"

#~ msgid ""
#~ "@FUNCTION=EURO\n"
#~ "@SYNTAX=EURO(currency)\n"
#~ "@DESCRIPTION=EURO converts one Euro to a given national currency in the "
#~ "European monetary union.\n"
#~ "\n"
#~ "@currency is one of the following:\n"
#~ "\n"
#~ "    ATS\t(Austria)\n"
#~ "    BEF\t(Belgium)\n"
#~ "    DEM\t(Germany)\n"
#~ "    ESP\t(Spain)\n"
#~ "    EUR\t(Euro)\n"
#~ "    FIM\t(Finland)\n"
#~ "    FRF\t(France)\n"
#~ "    GRD\t(Greek)\n"
#~ "    IEP\t(Ireland)\n"
#~ "    ITL\t(Italy)\n"
#~ "    LUF\t(Luxembourg)\n"
#~ "    NLG\t(Netherlands)\n"
#~ "    PTE\t(Portugal)\n"
#~ "\n"
#~ "* If the given @currency is other than one of the above, EURO returns "
#~ "#NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "EURO(\"DEM\") returns 1.95583.\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=EURO\n"
#~ "@SYNTAX=EURO(valuta)\n"
#~ "@DESCRIPTION=EURO konverterar en euro till en given nationell valuta i "
#~ "den europeiska monetära unionen.\n"
#~ "\n"
#~ "@valuta är en av följande:\n"
#~ "\n"
#~ "    ATS\t(Österrike)\n"
#~ "    BEF\t(Belgien)\n"
#~ "    DEM\t(Tyskland)\n"
#~ "    ESP\t(Spanien)\n"
#~ "    FIM\t(Finland)\n"
#~ "    FRF\t(Frankrike)\n"
#~ "    GRD\t(Grekland)\n"
#~ "    IEP\t(Irland)\n"
#~ "    ITL\t(Italien)\n"
#~ "    LUF\t(Luxemburg)\n"
#~ "    NLG\t(Nederländerna)\n"
#~ "    PTE\t(Portugal)\n"
#~ "\n"
#~ "* Om angiven @valuta är en annan än ovanstående returnerar EURO felvärdet "
#~ "#NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "EURO(\"DEM\") returnerar 1,95583.\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=EUROCONVERT\n"
#~ "@SYNTAX=EUROCONVERT(n,source,target)\n"
#~ "@DESCRIPTION=EUROCONVERT converts the currency value @n of @source "
#~ "currency to a target currency @target. Both currencies are given as three-"
#~ "letter strings using the ISO code system names.  The following currencies "
#~ "are available:\n"
#~ "\n"
#~ "    ATS\t(Austria)\n"
#~ "    BEF\t(Belgium)\n"
#~ "    DEM\t(Germany)\n"
#~ "    ESP\t(Spain)\n"
#~ "    EUR\t(Euro)\n"
#~ "    FIM\t(Finland)\n"
#~ "    FRF\t(France)\n"
#~ "    GRD\t(Greek)\n"
#~ "    IEP\t(Ireland)\n"
#~ "    ITL\t(Italy)\n"
#~ "    LUF\t(Luxembourg)\n"
#~ "    NLG\t(Netherlands)\n"
#~ "    PTE\t(Portugal)\n"
#~ "\n"
#~ "* If the given @source or @target is other than one of the above, "
#~ "EUROCONVERT returns #VALUE! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "EUROCONVERT(2.1,\"DEM\",\"EUR\") returns 1.07.\n"
#~ "@SEEALSO=EURO"
#~ msgstr ""
#~ "@FUNCTION=EUROCONVERT\n"
#~ "@SYNTAX=EUROCONVERT(n;källa;mål)\n"
#~ "@DESCRIPTION=EUROCONVERT konverterar värdet @n i @källa valutan till "
#~ "målvalutan @mål. Båda valutorna ges som trebosktavssträngar i ISO:s "
#~ "kodsystem. Följande valutor är tillgängliga:\n"
#~ "\n"
#~ "    ATS\t(Österrike)\n"
#~ "    BEF\t(Belgien)\n"
#~ "    DEM\t(Tyskland)\n"
#~ "    ESP\t(Spanien)\n"
#~ "    FIM\t(Finland)\n"
#~ "    FRF\t(Frankrike)\n"
#~ "    GRD\t(Grekland)\n"
#~ "    IEP\t(Irland)\n"
#~ "    ITL\t(Italien)\n"
#~ "    LUF\t(Luxemburg)\n"
#~ "    NLG\t(Nederländerna)\n"
#~ "    PTE\t(Portugal)\n"
#~ "\n"
#~ "* Om angiven @källa eller @mål är en annan än ovanstående returnerar EURO "
#~ "felvärdet #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "EURO(2,1;\"DEM\";\"EUR\") returnerar 1,07.\n"
#~ "@SEEALSO=EURO"

#~ msgid ""
#~ "@FUNCTION=CUMIPMT\n"
#~ "@SYNTAX=CUMIPMT(rate,nper,pv,start_period,end_period,type)\n"
#~ "@DESCRIPTION=CUMIPMT returns the cumulative interest paid on a loan "
#~ "between @start_period and @end_period.\n"
#~ "\n"
#~ "* If @rate <= 0, CUMIPMT returns #NUM! error.\n"
#~ "* If @nper <= 0, CUMIPMT returns #NUM! error.\n"
#~ "* If @pv <= 0, CUMIPMT returns #NUM! error.\n"
#~ "* If @start_period < 1, CUMIPMT returns #NUM! error.\n"
#~ "* If @end_period < @start_period, CUMIPMT returns #NUM! error.\n"
#~ "* If @end_period > @nper, CUMIPMT returns #NUM! error.\n"
#~ "* If @type <> 0 and @type <> 1, CUMIPMT returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=CUMIPMT\n"
#~ "@SYNTAX=CUMIPMT(ränta;nper;pv;startperiod;slutperiod;typ)\n"
#~ "@DESCRIPTION=CUMIPMT returnerar den kumulativa räntan betalad på ett lån "
#~ "mellan @startperiod och @slutperiod.\n"
#~ "\n"
#~ "* Om @ränta <= 0 returnerar CUMIPMT felvärdet #NUM!.\n"
#~ "* Om @nper <= 0 returnerar CUMIPMT felvärdet #NUM!.\n"
#~ "* Om @pv <= 0 returnerar CUMIPMT felvärdet #NUM!.\n"
#~ "* Om @startperiod < 1 returnerar CUMIPMT felvärdet #NUM!.\n"
#~ "* Om @slutperiod < @startperiod returnerar CUMIPMT felvärdet #NUM!.\n"
#~ "* Om @slutperiod > @nper returnerar CUMIPMT felvärdet #NUM!.\n"
#~ "* Om @typ <> 0 och @typ <> 1 returnerar CUMIPMT felvärdet #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=CUMPRINC\n"
#~ "@SYNTAX=CUMPRINC(rate,nper,pv,start_period,end_period,type)\n"
#~ "@DESCRIPTION=CUMPRINC returns the cumulative principal paid on a loan "
#~ "between @start_period and @end_period.\n"
#~ "\n"
#~ "* If @rate <= 0, CUMPRINC returns #NUM! error.\n"
#~ "* If @nper <= 0, CUMPRINC returns #NUM! error.\n"
#~ "* If @pv <= 0, CUMPRINC returns #NUM! error.\n"
#~ "* If @start_period < 1, CUMPRINC returns #NUM! error.\n"
#~ "* If @end_period < @start_period, CUMPRINC returns #NUM! error.\n"
#~ "* If @end_period > @nper, CUMPRINC returns #NUM! error.\n"
#~ "* If @type <> 0 and @type <> 1, CUMPRINC returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=CUMPRINC\n"
#~ "@SYNTAX=CUMPRINC(ränta;nper;pv;startperiod;slutperiod;typ)\n"
#~ "@DESCRIPTION=CUMPRINC returnerar det kumulativa kapitalet betalad på ett "
#~ "lån mellan @startperiod och @slutperiod.\n"
#~ "\n"
#~ "* Om @ränta <= 0 returnerar CUMPRINC felvärdet #NUM!.\n"
#~ "* Om @nper <= 0 returnerar CUMPRINC felvärdet #NUM!.\n"
#~ "* Om @pv <= 0 returnerar CUMPRINC felvärdet #NUM!.\n"
#~ "* Om @startperiod < 1 returnerar CUMPRINC felvärdet #NUM!.\n"
#~ "* Om @slutperiod < @startperiod returnerar CUMPRINC felvärdet #NUM!.\n"
#~ "* Om @slutperiod > @nper returnerar CUMPRINC felvärdet #NUM!.\n"
#~ "* Om @typ <> 0 och @typ <> 1 returnerar CUMPRINC felvärdet #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=DB"

#~ msgid ""
#~ "@FUNCTION=MDURATION\n"
#~ "@SYNTAX=MDURATION(settlement,maturity,coupon,yield,frequency[,basis])\n"
#~ "@DESCRIPTION=MDURATION returns the Macauley duration for a security with "
#~ "par value 100.\n"
#~ "\n"
#~ "@basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  MSRB 30/360 (MSRB Rule G33 (e))\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "  5  European+ 30/360\n"
#~ "\n"
#~ "* If @settlement or @maturity are not valid dates, MDURATION returns "
#~ "#NUM! error.\n"
#~ "* If @frequency is other than 1, 2, or 4, MDURATION returns #NUM! error.\n"
#~ "* If @basis is omitted, MSRB 30/360 is applied.\n"
#~ "* If @basis is invalid, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=DURATION,G_DURATION"
#~ msgstr ""
#~ "@FUNCTION=MDURATION\n"
#~ "@SYNTAX=MDURATION(avräkning;mognad;kupong;avkastning;frekvens[;bas])\n"
#~ "@DESCRIPTION=MDURATION beräknar Macauleytiden för en säkerhet med "
#~ "parvärde 100\n"
#~ "\n"
#~ "@bas är den typ av dagsräkningssystem som du vill använda:\n"
#~ "\n"
#~ "0  MSRB 30/360 (MSRB regel G33 (e))\n"
#~ "1  verkliga dagar/verkliga dagar\n"
#~ "2  verkliga dagar/360\n"
#~ "3  verkliga dagar/365\n"
#~ "4  Europeiskt 30/360\n"
#~ "5  Europeiskt+ 30/360\n"
#~ "\n"
#~ "* Om @frekvens är en annan än 1, 2 eller 4 returnerar MDURATION felvärdet "
#~ "#NUM!.\n"
#~ "*Om @bas utelämnas används MSRB 30/360-system.\n"
#~ "* Om @bas inte är giltigt returneras felvärdet #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=DURATION,G_DURATION"

#~ msgid ""
#~ "@FUNCTION=VDB\n"
#~ "@SYNTAX=VDB(cost,salvage,life,start_period,end_period[,factor,switch])\n"
#~ "@DESCRIPTION=VDB calculates the depreciation of an asset for a given "
#~ "period or partial period using the double-declining balance method.\n"
#~ "\n"
#~ "* If @start_period < 0, VDB returns #NUM! error.\n"
#~ "* If @start_period > @end_period, VDB returns #NUM! error.\n"
#~ "* If @end_period > @life, VDB returns #NUM! error.\n"
#~ "* If @cost < 0, VDB returns #NUM! error.\n"
#~ "* If @salvage > @cost, VDB returns #NUM! error.\n"
#~ "* If @factor <= 0, VDB returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=DB"
#~ msgstr ""
#~ "@FUNCTION=VDB\n"
#~ "@SYNTAX=VDB(kostnad;bärgning;liv;startperiod;slutperiod[;faktor;växel])\n"
#~ "@DESCRIPTION=VDB beräknar värdeminskningen av en tillgång för en given "
#~ "period, eller del av period, genom att använda den dubbelavtagande "
#~ "balansmetoden.\n"
#~ "\n"
#~ "* Om @startperiod < 0 returnerar VDB felvärdet #NUM!.\n"
#~ "* Om @startperiod > @slutperiod returnerar VDB felvärdet #NUM!.\n"
#~ "* Om @slutperiod > @liv returnerar VDB felvärdet #NUM!.\n"
#~ "* Om @kostnad < 0 returnerar VDB felvärdet #NUM!.\n"
#~ "* Om @bärgning > @kostnad returnerar VDB felvärdet #NUM!.\n"
#~ "* Om @faktor <= 0 returnerar VDB felvärdet #NUM!. \n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=DB"

#~ msgid ""
#~ "@FUNCTION=CELL\n"
#~ "@SYNTAX=CELL(type,ref)\n"
#~ "@DESCRIPTION=CELL returns information about the formatting, location, or "
#~ "contents of a cell.\n"
#~ "\n"
#~ "@type specifies the type of information you want to obtain:\n"
#~ "\n"
#~ "  address    \tReturns the given cell reference as text.\n"
#~ "  col        \t\tReturns the number of the column in @ref.\n"
#~ "  contents   \tReturns the contents of the cell in @ref.\n"
#~ "  format     \t\tReturns the code of the format of the cell.\n"
#~ "  parentheses\tReturns 1 if @ref contains a negative value\n"
#~ "             \t\tand its format displays it with parentheses.\n"
#~ "  row        \t\tReturns the number of the row in @ref.\n"
#~ "  width      \t\tReturns the column width.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Cell(\"format\",A1) returns the code of the format of the cell A1.\n"
#~ "\n"
#~ "@SEEALSO=INDIRECT"
#~ msgstr ""
#~ "@FUNCTION=CELL\n"
#~ "@SYNTAX=CELL(typ;ref)\n"
#~ "@DESCRIPTION=CELL returnerar information om formateringen i, platsen för "
#~ "eller innehållet i en cell.\n"
#~ "\n"
#~ "@typ anger typen av informationen du vill erhålla:\n"
#~ "\n"
#~ "  address       \tReturnerar den givna cellreferensen som text.\n"
#~ "  col           \t\tReturnerar kolumnnumret för kolumnen i @ref.\n"
#~ "  contents      \tReturnerar innehållet i cellen i @ref.\n"
#~ "  format        \t\tReturnerar koden för formatet på cellen.\n"
#~ "  parentheses   \tReturnerar 1 om @ref innehåller ett negativt värde och\n"
#~ "                \t\tdess format visar det med parenteser.\n"
#~ "  row           \t\tReturnerar radnumret för raden i @ref.\n"
#~ "  width         \t\tReturnerar kolumnbredden.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CELL(\"format\";A1) returnerar koden för formatet på cellen A1.\n"
#~ "\n"
#~ "@SEEALSO=INDIRECT"

#~ msgid ""
#~ "@FUNCTION=EXPRESSION\n"
#~ "@SYNTAX=EXPRESSION(cell)\n"
#~ "@DESCRIPTION=EXPRESSION returns expression in @cell as a string, or empty "
#~ "if the cell is not an expression.\n"
#~ "@EXAMPLES=\n"
#~ "entering '=EXPRESSION(A3)' in A2 = empty (assuming there is nothing in "
#~ "A3).\n"
#~ "entering '=EXPRESSION(A2)' in A1 = 'EXPRESSION(A3)'.\n"
#~ "\n"
#~ "@SEEALSO=TEXT"
#~ msgstr ""
#~ "@FUNCTION=EXPRESSION\n"
#~ "@SYNTAX=EXPRESSION(cell)\n"
#~ "@DESCRIPTION=EXPRESSION returnerar uttrycket i @cell som en sträng, eller "
#~ "tom om cellen inte är ett uttryck.\n"
#~ "@EXAMPLES=\n"
#~ "i A2 är EXPRESSION(A3) lika med tom (om det inte är någonting i A3).\n"
#~ "i A1 är EXPRESSION(A2) lika med \"EXPRESSION(A3)\".\n"
#~ "\n"
#~ "@SEEALSO=TEXT"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=GET.FORMULA\n"
#~ "@SYNTAX=GET.FORMULA(cell)\n"
#~ "@DESCRIPTION=EXPRESSION returns expression in @cell as a string, or empty "
#~ "if the cell is not an expression.\n"
#~ "@EXAMPLES=\n"
#~ "entering '=GET.FORMULA(A3)' in A2 = empty (assuming there is nothing in "
#~ "A3).\n"
#~ "entering '=GET.FORMULA(A2)' in A1 = '=GET.FORMULA(A3)'.\n"
#~ "\n"
#~ "@SEEALSO=EXPRESSION"
#~ msgstr ""
#~ "@FUNCTION=EXPRESSION\n"
#~ "@SYNTAX=EXPRESSION(cell)\n"
#~ "@DESCRIPTION=EXPRESSION returnerar uttrycket i @cell som en sträng, eller "
#~ "tom om cellen inte är ett uttryck.\n"
#~ "@EXAMPLES=\n"
#~ "i A2 är EXPRESSION(A3) lika med tom (om det inte är någonting i A3).\n"
#~ "i A1 är EXPRESSION(A2) lika med \"EXPRESSION(A3)\".\n"
#~ "\n"
#~ "@SEEALSO=TEXT"

#~ msgid ""
#~ "@FUNCTION=COUNTBLANK\n"
#~ "@SYNTAX=COUNTBLANK(range)\n"
#~ "@DESCRIPTION=COUNTBLANK returns the number of blank cells in a @range.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COUNTBLANK(A1:A20) returns the number of blank cell in A1:A20.\n"
#~ "\n"
#~ "@SEEALSO=COUNT"
#~ msgstr ""
#~ "@FUNCTION=COUNTBLANK\n"
#~ "@SYNTAX=COUNTBLANK(område)\n"
#~ "@DESCRIPTION=COUNTBLANK räknar antalet blanka celler i @område.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COUNTBLANK(A1:A20) returnerar antalet tomma celler i A1:A20.\n"
#~ "\n"
#~ "@SEEALSO=COUNT"

#~ msgid ""
#~ "@FUNCTION=ISERROR\n"
#~ "@SYNTAX=ISERROR(value)\n"
#~ "@DESCRIPTION=ISERROR returns a TRUE value if the expression has an "
#~ "error.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISERROR(NA()) equals TRUE.\n"
#~ "\n"
#~ "@SEEALSO=ERROR"
#~ msgstr ""
#~ "@FUNCTION=ISERROR\n"
#~ "@SYNTAX=ISERROR(värde)\n"
#~ "@DESCRIPTION=ISERROR returnerar värdet SANT om uttrycket innehåller ett "
#~ "fel.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISERROR(NA()) är lika med SANT.\n"
#~ "\n"
#~ "@SEEALSO=ERROR"

#~ msgid ""
#~ "@FUNCTION=ISNA\n"
#~ "@SYNTAX=ISNA(value)\n"
#~ "@DESCRIPTION=ISNA returns TRUE if the value is the #N/A error value.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISNA(NA()) equals TRUE.\n"
#~ "\n"
#~ "@SEEALSO=NA"
#~ msgstr ""
#~ "@FUNCTION=ISNA\n"
#~ "@SYNTAX=ISNA(värde)\n"
#~ "@DESCRIPTION=ISNA returnerar SANT om värdet är felvärdet #-.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISNA(NA()) är lika med SANT.\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=ISERR\n"
#~ "@SYNTAX=ISERR(value)\n"
#~ "@DESCRIPTION=ISERR returns TRUE if the value is any error value except #N/"
#~ "A.\n"
#~ "\n"
#~ "* This function is Excel compatible. \n"
#~ "@EXAMPLES=\n"
#~ "ISERR(NA()) return FALSE.\n"
#~ "\n"
#~ "@SEEALSO=ISERROR"
#~ msgstr ""
#~ "@FUNCTION=ISERR\n"
#~ "@SYNTAX=ISERR(värde)\n"
#~ "@DESCRIPTION=ISERR returnerar SANT om värdet är något felvärde förutom "
#~ "#-.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISERR(NA()) returnerar FALSKT.\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=NA\n"
#~ "@SYNTAX=NA()\n"
#~ "@DESCRIPTION=NA returns the error value #N/A.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "NA() equals #N/A error.\n"
#~ "\n"
#~ "@SEEALSO=ISNA"
#~ msgstr ""
#~ "@FUNCTION=NA\n"
#~ "@SYNTAX=NA()\n"
#~ "@DESCRIPTION=NA returnerar felvärdet #-.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "NA() är lika med felvärdet #-.\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=ERROR\n"
#~ "@SYNTAX=ERROR(text)\n"
#~ "@DESCRIPTION=ERROR return the specified error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ERROR(\"#OWN ERROR\").\n"
#~ "\n"
#~ "@SEEALSO=ISERROR"
#~ msgstr ""
#~ "@FUNCTION=ERROR\n"
#~ "@SYNTAX=ERROR(text)\n"
#~ "@DESCRIPTION=ERROR returnerar det angivna felvärdet.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ERROR(\"#EGET FEL\").\n"
#~ "\n"
#~ "@SEEALSO=ISERROR"

#~ msgid ""
#~ "@FUNCTION=ISBLANK\n"
#~ "@SYNTAX=ISBLANK(value)\n"
#~ "@DESCRIPTION=ISBLANK returns TRUE if the value is blank.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISBLANK(A1).\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=ISBLANK\n"
#~ "@SYNTAX=ISBLANK(värde)\n"
#~ "@DESCRIPTION=ISBLANK returnerar SANT om värdet är tomt.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISBLANK(A1).\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=ISEVEN\n"
#~ "@SYNTAX=ISEVEN(value)\n"
#~ "@DESCRIPTION=ISEVEN returns TRUE if the number is even.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISEVEN(4) equals TRUE.\n"
#~ "\n"
#~ "@SEEALSO=ISODD"
#~ msgstr ""
#~ "@FUNCTION=ISEVEN\n"
#~ "@SYNTAX=ISEVEN(värde)\n"
#~ "@DESCRIPTION=ISEVEN returnerar SANT om talet är jämnt.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISEVEN(4) är lika med SANT.\n"
#~ "\n"
#~ "@SEEALSO=ISODD"

#~ msgid ""
#~ "@FUNCTION=ISLOGICAL\n"
#~ "@SYNTAX=ISLOGICAL(value)\n"
#~ "@DESCRIPTION=ISLOGICAL returns TRUE if the value is a logical value.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISLOGICAL(A1).\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=ISLOGICAL\n"
#~ "@SYNTAX=ISLOGICAL(värde)\n"
#~ "@DESCRIPTION=ISLOGICAL returnerar SANT om värdet är ett logiskt värde.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISLOGICAL(A1).\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=ISNONTEXT\n"
#~ "@SYNTAX=ISNONTEXT(value)\n"
#~ "@DESCRIPTION=ISNONTEXT Returns TRUE if the value is not text.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISNONTEXT(\"text\") equals FALSE.\n"
#~ "\n"
#~ "@SEEALSO=ISTEXT"
#~ msgstr ""
#~ "@FUNCTION=ISNONTEXT\n"
#~ "@SYNTAX=ISNONTEXT(värde)\n"
#~ "@DESCRIPTION=ISNONTEXT returnerar SANT om värdet inte består av text.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISNONTEXT(\"text\") är lika med FALSKT.\n"
#~ "\n"
#~ "@SEEALSO=ISTEXT"

#~ msgid ""
#~ "@FUNCTION=ISNUMBER\n"
#~ "@SYNTAX=ISNUMBER(value)\n"
#~ "@DESCRIPTION=ISNUMBER returns TRUE if the value is a number.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISNUMBER(\"text\") equals FALSE.\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=ISNUMBER\n"
#~ "@SYNTAX=ISNUMBER(värde)\n"
#~ "@DESCRIPTION=ISNUMBER returnerar SANT om värdet är ett tal.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISNUMBER(\"text\") är lika med FALSKT.\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=ISODD\n"
#~ "@SYNTAX=ISODD(value)\n"
#~ "@DESCRIPTION=ISODD returns TRUE if the number is odd.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISODD(3) equals TRUE.\n"
#~ "\n"
#~ "@SEEALSO=ISEVEN"
#~ msgstr ""
#~ "@FUNCTION=ISODD\n"
#~ "@SYNTAX=ISODD(värde)\n"
#~ "@DESCRIPTION=ISODD returnerar SANT om talet är udda.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISODD(3) är lika med SANT.\n"
#~ "\n"
#~ "@SEEALSO=ISEVEN"

#~ msgid ""
#~ "@FUNCTION=ISREF\n"
#~ "@SYNTAX=ISREF(value)\n"
#~ "@DESCRIPTION=ISREF returns TRUE if the value is a reference.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISREF(A1) equals TRUE.\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=ISREF\n"
#~ "@SYNTAX=ISREF(värde)\n"
#~ "@DESCRIPTION=ISREF returnerar SANT om värdet är en referens.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISREF(A1) är lika med SANT.\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=ISTEXT\n"
#~ "@SYNTAX=ISTEXT(value)\n"
#~ "@DESCRIPTION=ISTEXT returns TRUE if the value is text.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISTEXT(\"text\") equals TRUE.\n"
#~ "\n"
#~ "@SEEALSO=ISNONTEXT"
#~ msgstr ""
#~ "@FUNCTION=ISTEXT\n"
#~ "@SYNTAX=ISTEXT(värde)\n"
#~ "@DESCRIPTION=ISTEXT returnerar SANT om värdet består av text.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISTEXT(\"text\") är lika med SANT.\n"
#~ "\n"
#~ "@SEEALSO=ISNONTEXT"

#~ msgid ""
#~ "@FUNCTION=N\n"
#~ "@SYNTAX=N(value)\n"
#~ "@DESCRIPTION=N returns a value converted to a number.  Strings containing "
#~ "text are converted to the zero value.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "N(\"42\") equals 42.\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=N\n"
#~ "@SYNTAX=N(värde)\n"
#~ "@DESCRIPTION=N returnerar ett värde omvandlat till ett tal. Strängar som "
#~ "innehåller text resulterar i värdet noll.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "N(\"42\") är lika med 42.\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=TYPE\n"
#~ "@SYNTAX=TYPE(value)\n"
#~ "@DESCRIPTION=TYPE returns a number indicating the data type of a value.\n"
#~ "\n"
#~ "1  == number\n"
#~ "2  == text\n"
#~ "4  == boolean\n"
#~ "16 == error\n"
#~ "64 == array\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TYPE(3) equals 1.\n"
#~ "TYPE(\"text\") equals 2.\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=TYPE\n"
#~ "@SYNTAX=TYPE(värde)\n"
#~ "@DESCRIPTION=TYPE returnerar ett tal som anger datatypen för ett värde.\n"
#~ "\n"
#~ "1  == nummer\n"
#~ "2  == text\n"
#~ "4  == boolsk\n"
#~ "16 == felvärde\n"
#~ "64 == fält\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TYPE(3) är lika med 1.\n"
#~ "TYPE(\"text\") är lika med 2.\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=GETENV\n"
#~ "@SYNTAX=GETENV(string)\n"
#~ "@DESCRIPTION=GETENV retrieves a value from the execution environment.\n"
#~ "\n"
#~ "* If the variable specified by @string does not exist, #N/A! will be "
#~ "returned.  Note, that variable names are case sensitive.\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=GETENV\n"
#~ "@SYNTAX=GETENV(sträng)\n"
#~ "@DESCRIPTION=GETENV hämtar ett värde från exekveringsmiljön.\n"
#~ "\n"
#~ "* Om variabeln som anges med @sträng inte finns kommer felvärdet #-! att "
#~ "returneras. Observera att variabelnamn är skiftlägeskänsliga.\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=AND\n"
#~ "@SYNTAX=AND(b1, b2, ...)\n"
#~ "@DESCRIPTION=AND implements the logical AND function: the result is TRUE "
#~ "if all of the expressions evaluate to TRUE, otherwise it returns FALSE.\n"
#~ "\n"
#~ "@b1 through @bN are expressions that should evaluate to TRUE or FALSE.  "
#~ "If an integer or floating point value is provided, zero is considered "
#~ "FALSE and anything else is TRUE.\n"
#~ "\n"
#~ "* If the values contain strings or empty cells those values are ignored.\n"
#~ "* If no logical values are provided, then the error #VALUE! is returned.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "AND(TRUE,TRUE) equals TRUE.\n"
#~ "AND(TRUE,FALSE) equals FALSE.\n"
#~ "\n"
#~ "Let us assume that A1 holds number five and A2 number one.  Then\n"
#~ "AND(A1>3,A2<2) equals TRUE.\n"
#~ "\n"
#~ "@SEEALSO=OR, NOT"
#~ msgstr ""
#~ "@FUNCTION=AND\n"
#~ "@SYNTAX=AND(b1; b2; ...)\n"
#~ "@DESCRIPTION=AND implementerar den logiska funktionen OCH: resultatet är "
#~ "SANT om alla uttryck evalueras till SANT, annars returnerar den FALSKT.\n"
#~ "\n"
#~ "@b1 till @bN är uttryck som måste evaluera till SANT eller FALSKT. Om ett "
#~ "heltal- eller flyttalsvärde anges betraktas noll som FALSKT och allting "
#~ "annat som SANT.\n"
#~ "\n"
#~ "* Om värdena innehåller strängar eller tomma celler ignoreras dessa "
#~ "värden.\n"
#~ "Om inga logiska värden anges returneras felvärdet #VÄRDE!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "AND(SANT;SANT) är lika med SANT.\n"
#~ "AND(SANT;FALSKT) är lika med FALSKT.\n"
#~ "\n"
#~ "Antag att A1 innehåller talet fem och A2 innehåller ett. Då är\n"
#~ "AND(A1>3;A2<2) lika med SANT.\n"
#~ "\n"
#~ "@SEEALSO=OR, NOT"

#~ msgid ""
#~ "@FUNCTION=NOT\n"
#~ "@SYNTAX=NOT(number)\n"
#~ "@DESCRIPTION=NOT implements the logical NOT function: the result is TRUE "
#~ "if the @number is zero;  otherwise the result is FALSE.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "NOT(0) equals TRUE.\n"
#~ "NOT(TRUE) equals FALSE.\n"
#~ "\n"
#~ "@SEEALSO=AND, OR"
#~ msgstr ""
#~ "@FUNCTION=NOT\n"
#~ "@SYNTAX=NOT(tal)\n"
#~ "@DESCRIPTION=NOT implementerar den logiska funktionen ICKE: resultatet är "
#~ "SANT om @tal är noll, annars FALSKT.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "NOT(0) är lika med SANT.\n"
#~ "NOT(SANT) är lika med FALSKT.\n"
#~ "\n"
#~ "@SEEALSO=AND, OR"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OR\n"
#~ "@SYNTAX=OR(b1, b2, ...)\n"
#~ "@DESCRIPTION=OR implements the logical OR function: the result is TRUE if "
#~ "any of the values evaluated to TRUE.\n"
#~ "\n"
#~ "@b1 through @bN are expressions that should evaluate to TRUE or FALSE. If "
#~ "an integer or floating point value is provided, zero is considered FALSE "
#~ "and anything else is TRUE.\n"
#~ "\n"
#~ "* If the values contain strings or empty cells those values are ignored.\n"
#~ "* If no logical values are provided, then the error #VALUE! is returned.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "OR(TRUE,FALSE) equals TRUE.\n"
#~ "OR(3>4,4<3) equals FALSE.\n"
#~ "\n"
#~ "@SEEALSO=AND, NOT"
#~ msgstr ""
#~ "@FUNCTION=OR\n"
#~ "@SYNTAX=OR(b1; b2; ...)\n"
#~ "@DESCRIPTION=OR implementerar den logiska ELLER-funktionen: resultatet är "
#~ "SANT om något av värdena evalueras till SANT.\n"
#~ "\n"
#~ "@b1 till @bN är uttryck som måste evaluera till SANT eller FALSKT. Om ett "
#~ "heltal- eller flyttalsvärde anges betraktas noll som FALSKT och allting "
#~ "annat som SANT.\n"
#~ "\n"
#~ "* Om värdena innehåller strängar eller tomma celler ignoreras dessa "
#~ "värden.\n"
#~ "* Om inga logiska värden anges returneras felvärdet #VÄRDE!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "OR(SANT;FALSKT) är lika med SANT.\n"
#~ "OR(3>4;4<3) är lika med SANT.\n"
#~ "\n"
#~ "@SEEALSO=AND, NOT"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=XOR\n"
#~ "@SYNTAX=XOR(b1, b2, ...)\n"
#~ "@DESCRIPTION=XOR implements the logical exclusive OR function: the result "
#~ "is TRUE if an odd number of the values evaluated to TRUE.\n"
#~ "\n"
#~ "@b1 through @bN are expressions that should evaluate to TRUE or FALSE. If "
#~ "an integer or floating point value is provided, zero is considered FALSE "
#~ "and anything else is TRUE.\n"
#~ "\n"
#~ "* If the values contain strings or empty cells those values are ignored.\n"
#~ "* If no logical values are provided, then the error #VALUE! is returned.\n"
#~ "@EXAMPLES=\n"
#~ "XOR(TRUE,FALSE) equals TRUE.\n"
#~ "XOR(3>4,4<3) equals FALSE.\n"
#~ "\n"
#~ "@SEEALSO=OR, AND, NOT"
#~ msgstr ""
#~ "@FUNCTION=XOR\n"
#~ "@SYNTAX=XOR(b1; b2; ...)\n"
#~ "@DESCRIPTION=XOR implementerar den logiska exklusiva ELLER-funktionen: "
#~ "resultatet är SANT om ett udda antal av värdena evalueras till SANT.\n"
#~ "\n"
#~ "@b1 till @bN är uttryck som måste evaluera till SANT eller FALSKT. Om ett "
#~ "heltal- eller flyttalsvärde anges betraktas noll som FALSKT och allting "
#~ "annat som SANT.\n"
#~ "\n"
#~ "* Om värdena innehåller strängar eller tomma celler ignoreras dessa "
#~ "värden.\n"
#~ "* Om inga logiska värden anges returneras felvärdet #VÄRDE!.\n"
#~ "@EXAMPLES=\n"
#~ "XOR(SANT;FALSKT) är lika med SANT.\n"
#~ "XOR(3>4;4<3) är lika med SANT.\n"
#~ "\n"
#~ "@SEEALSO=OR, AND, NOT"

#~ msgid ""
#~ "@FUNCTION=IF\n"
#~ "@SYNTAX=IF(condition[,if-true,if-false])\n"
#~ "@DESCRIPTION=IF function can be used to evaluate conditionally other "
#~ "expressions. IF evaluates @condition.  If @condition returns a non-zero "
#~ "value the result of the IF expression is the @if-true expression, "
#~ "otherwise IF evaluates to the value of @if-false.\n"
#~ "\n"
#~ "* If omitted @if-true defaults to TRUE and @if-false to FALSE.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IF(FALSE,TRUE,FALSE) equals FALSE.\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=IF\n"
#~ "@SYNTAX=IF(villkor[;om-sant;om-falskt])\n"
#~ "@DESCRIPTION=Använd IF-satsen för att evaluera andra satser villkorat. IF "
#~ "evaluerar @villkor. Om @villkor returnerar ett värde som inte är noll är "
#~ "resultatet från IF-satsen det i @om-sant, annars är resultatet från IF-"
#~ "satsen det i uttrycket @om-falskt.\n"
#~ "\n"
#~ "* Om det utelämnas är @om-sant SANT och @om-falskt FALSKT.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IF(FALSKT;SANT;FALSKT) är lika med FALSKT.\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=TRUE\n"
#~ "@SYNTAX=TRUE()\n"
#~ "@DESCRIPTION=TRUE returns boolean value true.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TRUE() equals TRUE.\n"
#~ "\n"
#~ "@SEEALSO=FALSE"
#~ msgstr ""
#~ "@FUNCTION=TRUE\n"
#~ "@SYNTAX=TRUE()\n"
#~ "@DESCRIPTION=TRUE returnerar det booleska värdet SANT.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TRUE() är lika med SANT.\n"
#~ "\n"
#~ "@SEEALSO=FALSE"

#~ msgid ""
#~ "@FUNCTION=FALSE\n"
#~ "@SYNTAX=FALSE()\n"
#~ "@DESCRIPTION=FALSE returns boolean value false.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FALSE() equals FALSE.\n"
#~ "\n"
#~ "@SEEALSO=TRUE"
#~ msgstr ""
#~ "@FUNCTION=FALSE\n"
#~ "@SYNTAX=FALSE()\n"
#~ "@DESCRIPTION=FALSE returnerar det booleska värdet falskt.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FALSE() är lika med FALSKT.\n"
#~ "\n"
#~ "@SEEALSO=TRUE"

#~ msgid ""
#~ "@FUNCTION=ADDRESS\n"
#~ "@SYNTAX=ADDRESS(row_num,col_num[,abs_num,a1,text])\n"
#~ "@DESCRIPTION=ADDRESS returns a cell address as text for specified row and "
#~ "column numbers.\n"
#~ "\n"
#~ "@a1 is a logical value that specifies the reference style.  If @a1 is "
#~ "TRUE or omitted, ADDRESS returns an A1-style reference, i.e. $D$4.  "
#~ "Otherwise ADDRESS returns an R1C1-style reference, i.e. R4C4.\n"
#~ "\n"
#~ "@text specifies the name of the worksheet to be used as the external "
#~ "reference.\n"
#~ "\n"
#~ "* If @abs_num is 1 or omitted, ADDRESS returns absolute reference.\n"
#~ "* If @abs_num is 2 ADDRESS returns absolute row and relative column.\n"
#~ "* If @abs_num is 3 ADDRESS returns relative row and absolute column.\n"
#~ "* If @abs_num is 4 ADDRESS returns relative reference.\n"
#~ "* If @abs_num is greater than 4 ADDRESS returns #VALUE! error.\n"
#~ "* If @row_num or @col_num is less than one, ADDRESS returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ADDRESS(5,4) equals \"$D$5\".\n"
#~ "ADDRESS(5,4,4) equals \"D5\".\n"
#~ "ADDRESS(5,4,3,FALSE) equals \"R[5]C4\".\n"
#~ "\n"
#~ "@SEEALSO=COLUMNNUMBER"
#~ msgstr ""
#~ "@FUNCTION=ADDRESS\n"
#~ "@SYNTAX=ADDRESS(radnummer;kolumnnummer[;absolutnummer;a1;text])\n"
#~ "@DESCRIPTION=ADDRESS returnerar en celladress som text för angivna rad- "
#~ "och kolumnnummer.\n"
#~ "\n"
#~ "@a1 är ett logiskt värde som anger typen av referens. Om @a1 är SANT "
#~ "eller utelämnas returnerar ADDRESS en referens av A1-typ, exempelvis $D"
#~ "$4. Annars returnerar ADDRESS en referens av R1C1-typ, exempelvis R4C4.\n"
#~ "\n"
#~ "@text anger namnet på arbetsbladet som ska användas som extern referens.\n"
#~ "\n"
#~ "* Om @absolutnummer är 1 eller utelämnas returnerar ADDRESS en absolut "
#~ "referens.\n"
#~ "* Om @absolutnummer är 2 returnerar ADDRESS absolut rad och relativ "
#~ "kolumn.\n"
#~ "* Om @absolutnummer är 3 returnerar ADDRESS relativ rad och absolut "
#~ "kolumn.\n"
#~ "* Om @absolutnummer är 4 returnerar ADDRESS en relativ referens.\n"
#~ "* Om @absolutnummer är större än 4 returnerar ADDRESS felvärdet #VÄRDE!.\n"
#~ "* Om @radnummer eller @kolumnnummer är mindre än ett returnerar ADDRESS "
#~ "felvärdet #VÄRDE!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ADDRESS(5;4) är lika med \"$D$5\".\n"
#~ "ADDRESS(5;4;4) är lika med \"D5\".\n"
#~ "ADDRESS(5;4;3;FALSKT) är lika med \"R[5]C4\".\n"
#~ "\n"
#~ "@SEEALSO=COLUMNNUMBER"

#~ msgid ""
#~ "@FUNCTION=AREAS\n"
#~ "@SYNTAX=AREAS(reference)\n"
#~ "@DESCRIPTION=AREAS returns the number of areas in @reference. \n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "AREAS((A1,B2,C3)) equals 3.\n"
#~ "\n"
#~ "@SEEALSO=ADDRESS,INDEX,INDIRECT,OFFSET"
#~ msgstr ""
#~ "@FUNCTION=AREAS\n"
#~ "@SYNTAX=AREAS(referens)\n"
#~ "@DESCRIPTION=AREAS returnerar antalet områden i @referens.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "AREAS((A1;B2;C3)) är lika med 3.\n"
#~ "\n"
#~ "@SEEALSO=ADDRESS,INDEX,INDIRECT,OFFSET"

#~ msgid ""
#~ "@FUNCTION=CHOOSE\n"
#~ "@SYNTAX=CHOOSE(index[,value1][,value2]...)\n"
#~ "@DESCRIPTION=CHOOSE returns the value of index @index. @index is rounded "
#~ "to an integer if it is not.\n"
#~ "\n"
#~ "* If @index < 1 or @index > number of values, CHOOSE returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CHOOSE(3,\"Apple\",\"Orange\",\"Grape\",\"Perry\") equals \"Grape\".\n"
#~ "\n"
#~ "@SEEALSO=IF"
#~ msgstr ""
#~ "@FUNCTION=CHOOSE\n"
#~ "@SYNTAX=CHOOSE(index[;värde1][;värde2]...)\n"
#~ "@DESCRIPTION=CHOOSE returnerar värdet på indexet @index. @index avrundas "
#~ "till ett heltal om det inte är det.\n"
#~ "\n"
#~ "* Om @index < 1 eller @index > antalet värden returneras felvärdet "
#~ "#VÄRDE!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CHOOSE(3;\"Äpple\";\"Apelsin\";\"Grapefrukt\";\"Persika\") är lika med "
#~ "\"Grapefrukt\".\n"
#~ "\n"
#~ "@SEEALSO=IF"

#~ msgid ""
#~ "@FUNCTION=VLOOKUP\n"
#~ "@SYNTAX=VLOOKUP(value,range,column[,approximate,as_index])\n"
#~ "@DESCRIPTION=VLOOKUP function finds the row in range that has a first "
#~ "column similar to @value.  If @approximate is not true it finds the row "
#~ "with an exact equivalence.  If @approximate is true, then the values must "
#~ "be sorted in order of ascending value for correct function; in this case "
#~ "it finds the row with value less than @value.  It returns the value in "
#~ "the row found at a 1-based offset in @column columns into the @range.  "
#~ "@as_index returns the 0-based offset that matched rather than the value.\n"
#~ "\n"
#~ "* VLOOKUP returns #NUM! if @column < 0.\n"
#~ "* VLOOKUP returns #REF! if @column falls outside @range.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=HLOOKUP"
#~ msgstr ""
#~ "@FUNCTION=VLOOKUP\n"
#~ "@SYNTAX=VLOOKUP(värde;område;kolumn[,uppskatta;som_index])\n"
#~ "@DESCRIPTION=Funktionen VLOOKUP söker den rad i området som har en första "
#~ "kolumn liknande den i @värde. Om @uppskatta inte är sant söker den raden "
#~ "med en exakt likhet. Om @uppskatta är sant måste värdena vara sorterade "
#~ "med minsta värdet först för att funktionen ska fungera korrekt; i detta "
#~ "fall söker den raden med värde mindre än @värde. Den returnerar värdet på "
#~ "raden som hittas på ett 1-baserat avstånd i @kolumn kolumner in i "
#~ "@område. @som_index returnerar 0-baserade avståndet som matchade istället "
#~ "för värdet.\n"
#~ "\n"
#~ "* Returnerar #NUM! om @kolumn < 0.\n"
#~ "* Returnerar #REF! om @kolumn är utanför @område.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=HLOOKUP"

#~ msgid ""
#~ "@FUNCTION=HLOOKUP\n"
#~ "@SYNTAX=HLOOKUP(value,range,row[,approximate,as_index])\n"
#~ "@DESCRIPTION=HLOOKUP function finds the col in range that has a first row "
#~ "cell similar to @value.  If @approximate is not true it finds the col "
#~ "with an exact equivalence.  If @approximate is true, then the values must "
#~ "be sorted in order of ascending value for correct function; in this case "
#~ "it finds the col with value less than @value it returns the value in the "
#~ "col found at a 1-based offset in @row rows into the @range.  @as_index "
#~ "returns the 0-based offset that matched rather than the value.\n"
#~ "\n"
#~ "* HLOOKUP returns #NUM! if @row < 0.\n"
#~ "* HLOOKUP returns #REF! if @row falls outside @range.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=VLOOKUP"
#~ msgstr ""
#~ "@FUNCTION=HLOOKUP\n"
#~ "@SYNTAX=HLOOKUP(värde;område;rad[,uppskatta;som_index])\n"
#~ "@DESCRIPTION=Funktionen HLOOKUP söker den kolumn i området som har en "
#~ "första rad liknande den i @värde. Om @uppskatta inte är sant söker den "
#~ "kolumnen med en exakt likhet. Om @uppskatta är sant måste värdena vara "
#~ "sorterade med minsta värdet först för att funktionen ska fungera korrekt; "
#~ "i detta fall söker den kolumnen med värde mindre än @värde. Den "
#~ "returnerar värdet på kolumnen som hittas på ett 1-baserat avstånd i @rad "
#~ "rader in i @område. @som_index returnerar 0-baserade avståndet som "
#~ "matchade istället för värdet\n"
#~ "\n"
#~ "* Returnerar #NUM! om @rad < 0.\n"
#~ "* Returnerar #REF! om @rad är utanför @område.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=VLOOKUP"

#~ msgid ""
#~ "@FUNCTION=LOOKUP\n"
#~ "@SYNTAX=LOOKUP(value,vector1[,vector2])\n"
#~ "@DESCRIPTION=LOOKUP function finds the row index of @value in @vector1 "
#~ "and returns the contents of @vector2 at that row index. Alternatively a "
#~ "single array can be used for @vector1. If the area is longer than it is "
#~ "wide then the sense of the search is rotated. \n"
#~ "\n"
#~ "* If LOOKUP can't find @value it uses the largest value less than "
#~ "@value.\n"
#~ "* The data must be sorted.\n"
#~ "* If @value is smaller than the first value it returns #N/A.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=VLOOKUP,HLOOKUP"
#~ msgstr ""
#~ "@FUNCTION=LOOKUP\n"
#~ "@SYNTAX=LOOKUP(värde;vektor1;vektor2)\n"
#~ "@DESCRIPTION=Funktionen LOOKUP söker radindexet med @värde i @vektor1 och "
#~ "returnerar innehållet i @vektor2 vid det radindexet. Om området är längre "
#~ "än det är brett roteras känsligheten för sökningen. Alternativt kan en "
#~ "ensam vektor användas.\n"
#~ "\n"
#~ "* Om LOOKUP inte kan hitta @värde använder den det näst största värdet "
#~ "som är mindre än värde. \n"
#~ "* Data måste vara sorterade.\n"
#~ "* Om @värde är mindre än det första värdet returneras #-\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=VLOOKUP,HLOOKUP"

#~ msgid ""
#~ "@FUNCTION=MATCH\n"
#~ "@SYNTAX=MATCH(seek,vector[,type])\n"
#~ "@DESCRIPTION=MATCH function finds the row index of @seek in @vector and "
#~ "returns it.\n"
#~ "\n"
#~ "If the area is longer than it is wide then the sense of the search is "
#~ "rotated. Alternatively a single array can be used.\n"
#~ "\n"
#~ "* The @type parameter, which defaults to +1, controls the search:\n"
#~ "* If @type = 1, MATCH finds largest value <= @seek.\n"
#~ "* If @type = 0, MATCH finds first value == @seek.\n"
#~ "* If @type = -1, MATCH finds smallest value >= @seek.\n"
#~ "* For @type = 0, the data can be in any order.  * For @type = -1 and "
#~ "@type = +1, the data must be sorted.  (And in these cases, MATCH uses a "
#~ "binary search to locate the index.)\n"
#~ "* If @seek could not be found, #N/A is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=LOOKUP"
#~ msgstr ""
#~ "@FUNCTION=MATCH\n"
#~ "@SYNTAX=MATCH(sökning;vektor[,typ])\n"
#~ "@DESCRIPTION=Funktionen MATCH söker radindexet för @sökning i @vektor och "
#~ "returnerar det.\n"
#~ "\n"
#~ "Om området är längre än det är brett roteras känsligheten för sökningen. "
#~ "Alternativt kan en ensam vektor användas.\n"
#~ "\n"
#~ "* Parametern @typ, vilken som standard är +1, styr sökningen:\n"
#~ "* Om @typ = 1  söks största värdet <= @sökning.\n"
#~ "* Om @typ = 0  söks första värdet == @sökning.\n"
#~ "* Om @typ = -1 söks minsta värdet >= @sökning.\n"
#~ "* För typ = 0 kan data vara i vilken ordning som helst. * För @typ = -1 "
#~ "och @typ = +1 måste data vara sorterat (och i detta fall använder MATCH "
#~ "en binärsökning för att hitta indexet).\n"
#~ "* Om @sökning inte kan hittas returneras #-.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=LOOKUP"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=INDIRECT\n"
#~ "@SYNTAX=INDIRECT(ref_text[,format])\n"
#~ "@DESCRIPTION=INDIRECT function returns the contents of the cell pointed "
#~ "to by the @ref_text string. The string specifies a single cell reference "
#~ "the format of which is either A1 or R1C1 style. The boolean @format "
#~ "controls how @ref_text is to be interpreted: TRUE (the default) for A1 "
#~ "style and FALSE for R1C1 style.\n"
#~ "\n"
#~ "* If @ref_text is not a valid reference in the style controlled by "
#~ "@format, returns #REF! \n"
#~ "@EXAMPLES=\n"
#~ "If A1 contains 3.14 and A2 contains \"A1\", then\n"
#~ "INDIRECT(A2) equals 3.14.\n"
#~ "\n"
#~ "If B1 contains 23 and A1 contains \"R1C2\", then\n"
#~ "INDIRECT(A1,FALSE) equals 23.\n"
#~ "@SEEALSO=AREAS,INDEX,CELL"
#~ msgstr ""
#~ "@FUNCTION=INDIRECT\n"
#~ "@SYNTAX=INDIRECT(ref_text;[format])\n"
#~ "@DESCRIPTION=Funktionen INDIRECT returnerar innehållet i cellen som "
#~ "refereras i strängen @ref_text. Strängen anger en ensam cellreferens av "
#~ "typen A1 eller R1C1. Stilen anges i @format boolean, vars standardvärde "
#~ "är det första av ovanstående.\n"
#~ "\n"
#~ "* Om @ref_text inte är en giltig referens returneras #REF!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Om A1 innehåller 3,14 och A2 innehåller A1 är\n"
#~ "INDIRECT(A2) lika med 3,14.\n"
#~ "\n"
#~ "@SEEALSO=AREAS,INDEX,CELL"

#~ msgid ""
#~ "@FUNCTION=INDEX\n"
#~ "@SYNTAX=INDEX(array[,row, col, area])\n"
#~ "@DESCRIPTION=INDEX gives a reference to a cell in the given @array.The "
#~ "cell is pointed out by @row and @col, which count the rows and columns in "
#~ "the array.\n"
#~ "\n"
#~ "* If @row and @col are omitted the are assumed to be 1.\n"
#~ "* If the reference falls outside the range of the @array, INDEX returns a "
#~ "#REF! error.\n"
#~ "\n"
#~ "@EXAMPLES=Let us assume that the cells A1, A2, ..., A5 contain numbers "
#~ "11.4, 17.3, 21.3, 25.9, and 40.1. Then INDEX(A1:A5,4,1,1) equals 25.9\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=INDEX\n"
#~ "@SYNTAX=INDEX(vektor;[rad; kolumn; område])\n"
#~ "@DESCRIPTION=INDEX ger en referens till en cell i angiven @vektor. Cellen "
#~ "pekas ut med @rad och @kolumn, vilka räknar antalet rader och kolumner i "
#~ "vektorn.\n"
#~ "\n"
#~ "* Om @rad och @kolumn utelämnas antas de vara 1.\n"
#~ "* Om referensen hamnar utanför intervallet för @vektor returnerar INDEX "
#~ "felvärdet #REF!.\n"
#~ "\n"
#~ "@EXAMPLES=Antag att cellerna A1; A2; ...; A5 innehåller talen 11,4; 17,3; "
#~ "21,3; 25,9 och 40,1. Då är INDEX(A1:A5;4;1;1) lika med 25,9\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=COLUMNNUMBER\n"
#~ "@SYNTAX=COLUMNNUMBER(name)\n"
#~ "@DESCRIPTION=COLUMNNUMBER function returns an integer corresponding to "
#~ "the column name supplied as a string.\n"
#~ "\n"
#~ "* If @name is invalid, COLUMNNUMBER returns the #VALUE! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COLUMNNUMBER(\"E\") equals 5.\n"
#~ "\n"
#~ "@SEEALSO=ADDRESS"
#~ msgstr ""
#~ "@FUNCTION=COLUMNNUMBER\n"
#~ "@SYNTAX=COLUMNNUMBER(namn)\n"
#~ "@DESCRIPTION=COLUMNNUMBER returnerar ett heltal som motsvarar kolumnen "
#~ "som angetts som en sträng.\n"
#~ "\n"
#~ "* Om @namn inte är giltigt, returnerar COLUMNNUMBER felvärdet #VÄRDE!\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COLUMNNUMBER(\"E\") är lika med 5.\n"
#~ "\n"
#~ "@SEEALSO=ADDRESS"

#~ msgid ""
#~ "@FUNCTION=COLUMNS\n"
#~ "@SYNTAX=COLUMNS(reference)\n"
#~ "@DESCRIPTION=COLUMNS function returns the number of columns in area or "
#~ "array reference.\n"
#~ "\n"
#~ "* If @reference is neither an array nor a reference nor a range, COLUMNS "
#~ "returns #VALUE! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COLUMNS(H2:J3) equals 3.\n"
#~ "\n"
#~ "@SEEALSO=COLUMN,ROW,ROWS"
#~ msgstr ""
#~ "@FUNCTION=COLUMNS\n"
#~ "@SYNTAX=COLUMNS(referens)\n"
#~ "@DESCRIPTION=COLUMNS returnerar antalet kolumner som finns inom det "
#~ "område eller den fältreferens som anges.\n"
#~ "\n"
#~ "* Om @referens inte är ett fält, en referens eller ett område, returneras "
#~ "felvärdet #VÄRDE!\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COLUMNS(H2:J3) är lika med 3.\n"
#~ "\n"
#~ "@SEEALSO=COLUMN,ROW,ROWS"

#~ msgid ""
#~ "@FUNCTION=OFFSET\n"
#~ "@SYNTAX=OFFSET(range,row,col[,height[,width]])\n"
#~ "@DESCRIPTION=OFFSET function returns a cell range. The cell range starts "
#~ "at offset (@row,@col) from @range, and is of height @height and width "
#~ "@width.\n"
#~ "\n"
#~ "* If @range is neither a reference nor a range, OFFSET returns #VALUE!.\n"
#~ "* If either @height or @width is omitted, the height or width of the "
#~ "reference is used.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=COLUMN,COLUMNS,ROWS,INDEX,INDIRECT,ADDRESS"
#~ msgstr ""
#~ "@FUNCTION=OFFSET\n"
#~ "@SYNTAX=OFFSET(område;rad;kolumn;höjd;bredd)\n"
#~ "@DESCRIPTION=Funktionen OFFSET returnerar ett cellområde. Cellområdet "
#~ "börjar vid offset (@rad;@kolumn) från @område, och är av höjden @höjd och "
#~ "bredden @bredd.\n"
#~ "\n"
#~ "* Om @område varken är en referens eller ett område returneras #VÄRDE!.\n"
#~ "* Om antingen @höjd eller @bredd utelämnas används höjden eller bredden "
#~ "på referensen.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=COLUMN,COLUMNS,ROWS,INDEX,INDIRECT,ADDRESS"

#~ msgid ""
#~ "@FUNCTION=ROWS\n"
#~ "@SYNTAX=ROWS(reference)\n"
#~ "@DESCRIPTION=ROWS function returns the number of rows in area or array "
#~ "reference.\n"
#~ "\n"
#~ "* If @reference is neither an array nor a reference nor a range, ROWS "
#~ "returns #VALUE! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ROWS(H7:I13) equals 7.\n"
#~ "\n"
#~ "@SEEALSO=COLUMN,COLUMNS,ROW"
#~ msgstr ""
#~ "@FUNCTION=ROWS\n"
#~ "@SYNTAX=ROWS(referens)\n"
#~ "@DESCRIPTION=ROWS returnerar antalet rader som finns inom det område "
#~ "eller den fältreferens som anges.\n"
#~ "\n"
#~ "* Om @referens inte är ett fält, en referens eller ett område, returneras "
#~ "felvärdet #VÄRDE!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ROWS(H7:I13) är lika med 7.\n"
#~ "\n"
#~ "@SEEALSO=COLUMN,COLUMNS,ROW"

#~ msgid ""
#~ "@FUNCTION=HYPERLINK\n"
#~ "@SYNTAX=HYPERLINK(link_location[,optional_label])\n"
#~ "@DESCRIPTION=HYPERLINK function currently returns its 2nd argument, or if "
#~ "that is omitted the 1st argument.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "HYPERLINK(\"www.gnome.org\",\"GNOME\").\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=HYPERLINK\n"
#~ "@SYNTAX=HYPERLINK(länkplats[; valfri_etikett])\n"
#~ "@DESCRIPTION=Funktionen HYPERLINK returnerar sitt andra argument, eller "
#~ "om det är utelämnat, sitt första argument.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "HYPERLINK(\"www.gnome.org\";\"GNOME\").\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=TRANSPOSE\n"
#~ "@SYNTAX=TRANSPOSE(matrix)\n"
#~ "@DESCRIPTION=TRANSPOSE function returns the transpose of the input "
#~ "@matrix.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=MMULT"
#~ msgstr ""
#~ "@FUNCTION=TRANSPOSE\n"
#~ "@SYNTAX=TRANSPOSE(matris)\n"
#~ "@DESCRIPTION=TRANSPOSE returnerar transponeringen av @matris.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=MMULT"

#~ msgid ""
#~ "@FUNCTION=GCD\n"
#~ "@SYNTAX=GCD(number1,number2,...)\n"
#~ "@DESCRIPTION=GCD returns the greatest common divisor of given numbers.\n"
#~ "\n"
#~ "* If any of the arguments is less than one, GCD returns #NUM! error.\n"
#~ "* If any of the arguments is non-integer, it is truncated.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "GCD(470,770) equals 10.\n"
#~ "GCD(470,770,1495) equals 5.\n"
#~ "\n"
#~ "@SEEALSO=LCM"
#~ msgstr ""
#~ "@FUNCTION=GCD\n"
#~ "@SYNTAX=GCD(tal1;tal2;...)\n"
#~ "@DESCRIPTION=GCD returnerar den största gemensamma delaren för deangivna "
#~ "talen.\n"
#~ "\n"
#~ "* Om något av argumenten är mindre än ett, returnerar GCD felvärdet "
#~ "#NUM!\n"
#~ "* Om något av argumenten är icke-heltal, kortas det av.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "GCD(470;770) är lika med 10.\n"
#~ "GCD(470;770;1495) är lika med 5.\n"
#~ "\n"
#~ "@SEEALSO=LCM"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=LCM\n"
#~ "@SYNTAX=LCM(number1,number2,...)\n"
#~ "@DESCRIPTION=LCM returns the least common multiple of integers.  The "
#~ "least common multiple is the smallest positive number that is a multiple "
#~ "of all integer arguments given.\n"
#~ "\n"
#~ "* If any of the arguments is less than one, LCM returns #NUM!.\n"
#~ "* If any of the arguments is non-integer, it is truncated.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LCM(2,13) equals 26.\n"
#~ "LCM(4,7,5) equals 140.\n"
#~ "\n"
#~ "@SEEALSO=GCD"
#~ msgstr ""
#~ "@FUNCTION=LCM\n"
#~ "@SYNTAX=LCM(tal1;tal2;...)\n"
#~ "@DESCRIPTION=LCM returnerar den minsta gemensamma multipeln för angivna "
#~ "heltalen. Den minsta gemensamma multipeln är det minsta positiva tal som "
#~ "är en multipel av alla de angivna talen.\n"
#~ "\n"
#~ "* Om något av argumenten är mindre än 1, returneras felvärdet #NUM!\n"
#~ "* Om något av argumenten är icke-heltal, kortas det av.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LCM(2;13) är lika med 26.\n"
#~ "LCM(4;7;5) är lika med 140.\n"
#~ "\n"
#~ "@SEEALSO=GCD"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=HYPOT\n"
#~ "@SYNTAX=HYPOT(number1,number2,...)\n"
#~ "@DESCRIPTION=HYPOT returns the square root of the sum of the squares of "
#~ "the arguments.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "HYPOT(3,4) equals 5.\n"
#~ "\n"
#~ "@SEEALSO=MIN,MAX"
#~ msgstr ""
#~ "@FUNCTION=HYPOT\n"
#~ "@SYNTAX=HYPOT(tal1;tal2;...)\n"
#~ "@DESCRIPTION=Funktionen HYPOT returnerar kvadratroten av summan av "
#~ "kvadraterna av argumenten.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "HYPOT(3;4) är lika med 5.\n"
#~ "\n"
#~ "@SEEALSO=MIN,MAX"

#~ msgid ""
#~ "@FUNCTION=ABS\n"
#~ "@SYNTAX=ABS(b1)\n"
#~ "@DESCRIPTION=ABS implements the Absolute Value function:  the result is "
#~ "to drop the negative sign (if present).  This can be done for integers "
#~ "and floating point numbers.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ABS(7) equals 7.\n"
#~ "ABS(-3.14) equals 3.14.\n"
#~ "\n"
#~ "@SEEALSO=CEIL, CEILING, FLOOR, INT, MOD"
#~ msgstr ""
#~ "@FUNCTION=ABS\n"
#~ "@SYNTAX=ABS(b1)\n"
#~ "@DESCRIPTION=ABS ger absolutvärdet av argumentet, vilket innebär att ett "
#~ "eventuellt minustecken tas bort. Argumentet kan vara ett heltal eller "
#~ "flyttal.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ABS(7) är lika med 7.\n"
#~ "ABS(-3,14) är lika med 3,14.\n"
#~ "\n"
#~ "@SEEALSO=CEIL, CEILING, FLOOR, INT, MOD"

#~ msgid ""
#~ "@FUNCTION=ACOS\n"
#~ "@SYNTAX=ACOS(x)\n"
#~ "@DESCRIPTION=ACOS function calculates the arc cosine of @x; that is the "
#~ "value whose cosine is @x.\n"
#~ "\n"
#~ "* The value it returns is in radians.\n"
#~ "* If @x falls outside the range -1 to 1, ACOS returns the #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ACOS(0.1) equals 1.470629.\n"
#~ "ACOS(-0.1) equals 1.670964.\n"
#~ "\n"
#~ "@SEEALSO=COS, SIN, DEGREES, RADIANS"
#~ msgstr ""
#~ "@FUNCTION=ACOS\n"
#~ "@SYNTAX=ACOS(x)\n"
#~ "@DESCRIPTION=Funktionen ACOS beräknar arcus cosinus av @x; det vill säga "
#~ "det värde vars cosinus är @x.\n"
#~ "\n"
#~ "* Resultatet anges i radianer.\n"
#~ "* Om @x ligger utanför området -1 till 1, returnerar ACOS felvärdet "
#~ "#NUM!. \n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ACOS(0,1) är lika med 1,470629.\n"
#~ "ACOS(-0,1) är lika med 1,670964.\n"
#~ "\n"
#~ "@SEEALSO=COS, SIN, DEGREES, RADIANS"

#~ msgid ""
#~ "@FUNCTION=ACOSH\n"
#~ "@SYNTAX=ACOSH(x)\n"
#~ "@DESCRIPTION=ACOSH  function  calculates  the inverse hyperbolic cosine "
#~ "of @x; that is the value whose hyperbolic cosine is @x.\n"
#~ "\n"
#~ "* If @x is less than 1.0, ACOSH() returns the #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ " \n"
#~ "@EXAMPLES=\n"
#~ "ACOSH(2) equals 1.31696.\n"
#~ "ACOSH(5.3) equals 2.35183.\n"
#~ "\n"
#~ "@SEEALSO=ACOS, ASINH, DEGREES, RADIANS "
#~ msgstr ""
#~ "@FUNCTION=ACOSH\n"
#~ "@SYNTAX=ACOSH(x)\n"
#~ "@DESCRIPTION=Funktionen ACOSH beräknar inversen till cosinus hyperbolicus "
#~ "av @x; det vill säga det värde vars cosinus hyperbolicus är @x.\n"
#~ "\n"
#~ "* Om @x är mindre än 1,0, returnerar ACOSH() felvärdet #NUM!\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ACOSH(2) är lika med 1,31696.\n"
#~ "ACOSH(5,3) är lika med 2,35183.\n"
#~ "\n"
#~ "@SEEALSO=ACOS, ASINH, DEGREES, RADIANS "

#~ msgid ""
#~ "@FUNCTION=ASIN\n"
#~ "@SYNTAX=ASIN(x)\n"
#~ "@DESCRIPTION=ASIN function calculates the arc sine of @x; that is the "
#~ "value whose sine is @x.\n"
#~ "\n"
#~ "* If @x falls outside the range -1 to 1, ASIN returns the #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ASIN(0.5) equals 0.523599.\n"
#~ "ASIN(1) equals 1.570797.\n"
#~ "\n"
#~ "@SEEALSO=SIN, COS, ASINH, DEGREES, RADIANS"
#~ msgstr ""
#~ "@FUNCTION=ASIN\n"
#~ "@SYNTAX=ASIN(x)\n"
#~ "@DESCRIPTION=Funktionen ASIN beräknar arcus sinus av @x; det vill säga "
#~ "det värde vars sinus är @x.\n"
#~ "\n"
#~ "* Om @x ligger utanför området -1 till 1, returnerar ASIN felvärdet "
#~ "#NUM!\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ASIN(0,5) är lika med 0,523599.\n"
#~ "ASIN(1) är lika med 1,570797.\n"
#~ "\n"
#~ "@SEEALSO=SIN, COS, ASINH, DEGREES, RADIANS"

#~ msgid ""
#~ "@FUNCTION=ASINH\n"
#~ "@SYNTAX=ASINH(x)\n"
#~ "@DESCRIPTION=ASINH function calculates the inverse hyperbolic sine of @x; "
#~ "that is the value whose hyperbolic sine is @x.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ASINH(0.5) equals 0.481212.\n"
#~ "ASINH(1.0) equals 0.881374.\n"
#~ "\n"
#~ "@SEEALSO=ASIN, ACOSH, SIN, COS, DEGREES, RADIANS"
#~ msgstr ""
#~ "@FUNCTION=ASINH\n"
#~ "@SYNTAX=ASINH(x)\n"
#~ "@DESCRIPTION=Funktionen ASINH beräknar inversen till sinus hyperbolicus "
#~ "av @x; det vill säga det värde vars SINH är @x.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ASINH(0,5) är lika med 0,481212.\n"
#~ "ASINH(1,0) är lika med 0,881374.\n"
#~ "\n"
#~ "@SEEALSO=ASIN, ACOSH, SIN, COS, DEGREES, RADIANS"

#~ msgid ""
#~ "@FUNCTION=ATAN\n"
#~ "@SYNTAX=ATAN(x)\n"
#~ "@DESCRIPTION=ATAN function calculates the arc tangent of @x; that is the "
#~ "value whose tangent is @x.\n"
#~ "\n"
#~ "* Return value is in radians.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ATAN(0.5) equals 0,463648.\n"
#~ "ATAN(1) equals 0,785398.\n"
#~ "\n"
#~ "@SEEALSO=TAN, COS, SIN, DEGREES, RADIANS"
#~ msgstr ""
#~ "@FUNCTION=ATAN\n"
#~ "@SYNTAX=ATAN(x)\n"
#~ "@DESCRIPTION=Funktionen ATAN beräknar arcus tangens av @x; det vill säga "
#~ "det värde vars tangens är @x.\n"
#~ "\n"
#~ "* Resultatet ges i radianer.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ATAN(0,5) är lika med 0,463648.\n"
#~ "ATAN(1) är lika med 0,785398.\n"
#~ "\n"
#~ "@SEEALSO=TAN, COS, SIN, DEGREES, RADIANS"

#~ msgid ""
#~ "@FUNCTION=ATANH\n"
#~ "@SYNTAX=ATANH(x)\n"
#~ "@DESCRIPTION=ATANH function calculates the inverse hyperbolic tangent of "
#~ "@x; that is the value whose hyperbolic tangent is @x.\n"
#~ "\n"
#~ "* If the absolute value of @x is greater than 1.0, ATANH returns #NUM! "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ATANH(0.5) equals 0.549306.\n"
#~ "ATANH(0.8) equals 1.098612.\n"
#~ "\n"
#~ "@SEEALSO=ATAN, TAN, SIN, COS, DEGREES, RADIANS"
#~ msgstr ""
#~ "@FUNCTION=ATANH\n"
#~ "@SYNTAX=ATANH(x)\n"
#~ "@DESCRIPTION=Funktionen ATANH beräknar inversen till tangens "
#~ "hyperbolicus; det vill säga det värde vars TANH är @x.\n"
#~ "\n"
#~ "* Om absolutvärdet av @x är större än 1,0 returnerar ATANH felvärdet "
#~ "#NUM!\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ATANH(0,5) är lika med 0,549306.\n"
#~ "ATANH(0,8) är lika med 1,098612.\n"
#~ "\n"
#~ "@SEEALSO=ATAN, TAN, SIN, COS, DEGREES, RADIANS"

#~ msgid ""
#~ "@FUNCTION=ATAN2\n"
#~ "@SYNTAX=ATAN2(b1,b2)\n"
#~ "@DESCRIPTION=ATAN2 function calculates the arc tangent of the two "
#~ "variables @b1 and @b2.  It is similar to calculating the arc tangent of "
#~ "@b2 / @b1, except that the signs of both arguments are used to determine "
#~ "the quadrant of the result.\n"
#~ "\n"
#~ "* The result is in radians.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ATAN2(0.5,1.0) equals 1.107149.\n"
#~ "ATAN2(-0.5,2.0) equals 1.815775.\n"
#~ "\n"
#~ "@SEEALSO=ATAN, ATANH, COS, SIN, DEGREES, RADIANS"
#~ msgstr ""
#~ "@FUNCTION=ATAN2\n"
#~ "@SYNTAX=ATAN2(b1;b2)\n"
#~ "@DESCRIPTION=Funktionen ATAN2 beräknar arcus tangens av variablerna @b1 "
#~ "och @b2. Det är likvärdigt med att beräkna arcus tangens av @b2 / @b1, "
#~ "med undantaget att de båda argumentens tecken används för att bestämma "
#~ "vilken kvadrant resultatet ska ligga i.\n"
#~ "\n"
#~ "* Resultatet ges i radianer.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ATAN2(0,5;1,0) är lika med 1,107149.\n"
#~ "ATAN2(-0,5;2,0) är lika med 1,815775.\n"
#~ "\n"
#~ "@SEEALSO=ATAN, ATANH, COS, SIN, DEGREES, RADIANS"

#~ msgid ""
#~ "@FUNCTION=CEIL\n"
#~ "@SYNTAX=CEIL(x)\n"
#~ "@DESCRIPTION=CEIL function rounds @x up to the next nearest integer.\n"
#~ "\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CEIL(0.4) equals 1.\n"
#~ "CEIL(-1.1) equals -1.\n"
#~ "CEIL(-2.9) equals -2.\n"
#~ "\n"
#~ "@SEEALSO=CEILING, FLOOR, ABS, INT, MOD"
#~ msgstr ""
#~ "@FUNCTION=CEIL\n"
#~ "@SYNTAX=CEIL(x)\n"
#~ "@DESCRIPTION=Funktionen CEIL avrundar @x uppåt till närmsta heltal.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CEIL(0,4) är lika med 1.\n"
#~ "CEIL(-1,1) är lika med -1.\n"
#~ "CEIL(-2,9) är lika med -2.\n"
#~ "\n"
#~ "@SEEALSO=CEILING, FLOOR, ABS, INT"

#~ msgid ""
#~ "@FUNCTION=COUNTIF\n"
#~ "@SYNTAX=COUNTIF(range,criteria)\n"
#~ "@DESCRIPTION=COUNTIF function counts the number of cells in the given "
#~ "@range that meet the given @criteria.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 23, 27, 28, "
#~ "33, and 39.  Then\n"
#~ "COUNTIF(A1:A5,\"<=28\") equals 3.\n"
#~ "COUNTIF(A1:A5,\"<28\") equals 2.\n"
#~ "COUNTIF(A1:A5,\"28\") equals 1.\n"
#~ "COUNTIF(A1:A5,\">28\") equals 2.\n"
#~ "\n"
#~ "@SEEALSO=COUNT,SUMIF"
#~ msgstr ""
#~ "@FUNCTION=COUNTIF\n"
#~ "@SYNTAX=COUNTIF(område;kriterium)\n"
#~ "@DESCRIPTION=Funktionen COUNTIF räknar antalet celler i ett givet @område "
#~ "som möter ett givet @kriterium.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel. \n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att cellerna A1; A2; ...; A5 innehåller talen 23, 27, 28, 33 och "
#~ "39. Då blir\n"
#~ "COUNTIF(A1:A5;\"<=28\") 3,\n"
#~ "COUNTIF(A1:A5;\"<28\") 2,\n"
#~ "COUNTIF(A1:A5;\"28\") 1 och\n"
#~ "COUNTIF(A1:A5;\">28\") 2.\n"
#~ "\n"
#~ "@SEEALSO=COUNT,SUMIF"

#~ msgid ""
#~ "@FUNCTION=SUMIF\n"
#~ "@SYNTAX=SUMIF(range,criteria[,actual_range])\n"
#~ "@DESCRIPTION=SUMIF function sums the values in the given @range that meet "
#~ "the given @criteria.  If @actual_range is given, SUMIF sums the values in "
#~ "the @actual_range whose corresponding components in @range meet the given "
#~ "@criteria.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 23, 27, 28, "
#~ "33, and 39.  Then\n"
#~ "SUMIF(A1:A5,\"<=28\") equals 78.\n"
#~ "SUMIF(A1:A5,\"<28\") equals 50.\n"
#~ "In addition, if the cells B1, B2, ..., B5 hold numbers 5, 3, 2, 6, and 7 "
#~ "then:\n"
#~ "SUMIF(A1:A5,\"<=27\",B1:B5) equals 8.\n"
#~ "\n"
#~ "@SEEALSO=COUNTIF, SUM"
#~ msgstr ""
#~ "@FUNCTION=SUMIF\n"
#~ "@SYNTAX=SUMIF(område;villkor[;verkligt_område])\n"
#~ "@DESCRIPTION=Funktionen SUMIF summerar de värden i @område, som uppfyller "
#~ "det givna villkoret. Om @verkligt_område är givet, summerar SUMIF värdena "
#~ "i @verkligt_område, vars motsvarande värden i @område uppfyller det givna "
#~ "villkoret.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att att cellerna A1; A2; ...; A5 innehåller talen 23, 27, 28, 33, "
#~ "and 39. Då är \n"
#~ "SUMIF(A1:A5;\"<=28\") lika med 78.\n"
#~ "SUMIF(A1:A5;\"<28\") lika med 50.\n"
#~ "Om dessutom cellerna B1, B2, ..., B5 innehåller talen 5, 3, 2, 6 och 7 "
#~ "är:\n"
#~ "SUMIF(A1:A5;\"<=27\";B1:B5) lika med 8.\n"
#~ "\n"
#~ "@SEEALSO=COUNTIF,SUM"

#~ msgid ""
#~ "@FUNCTION=CEILING\n"
#~ "@SYNTAX=CEILING(x[,significance])\n"
#~ "@DESCRIPTION=CEILING function rounds @x up to the nearest multiple of "
#~ "@significance.\n"
#~ "\n"
#~ "* If @x or @significance is non-numeric CEILING returns #VALUE! error.\n"
#~ "* If @x and @significance have different signs CEILING returns #NUM! "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CEILING(2.43,1) equals 3.\n"
#~ "CEILING(123.123,3) equals 126.\n"
#~ "\n"
#~ "@SEEALSO=CEIL, FLOOR, ABS, INT, MOD"
#~ msgstr ""
#~ "@FUNCTION=CEILING\n"
#~ "@SYNTAX=CEILING(x;signifikans)\n"
#~ "@DESCRIPTION=Funktionen CEILING avrundar @x uppåt till den minsta "
#~ "multipeln av @signifikans.\n"
#~ "\n"
#~ "* Om @x eller @signifikans är icke-numerisk returnerar CEILING felvärdet "
#~ "#VÄRDE!\n"
#~ "* Om @x och @signifikans har olika tecken returneras felvärdet #NUM!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CEILING(2,43;1) är lika med 3.\n"
#~ "CEILING(123,123;3) är lika med 126.\n"
#~ "\n"
#~ "@SEEALSO=CEIL, FLOOR, ABS, INT, MOD"

#~ msgid ""
#~ "@FUNCTION=COS\n"
#~ "@SYNTAX=COS(x)\n"
#~ "@DESCRIPTION=COS function returns the cosine of @x, where @x is given in "
#~ "radians.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COS(0.5) equals 0.877583.\n"
#~ "COS(1) equals 0.540302.\n"
#~ "\n"
#~ "@SEEALSO=COSH, SIN, SINH, TAN, TANH, RADIANS, DEGREES"
#~ msgstr ""
#~ "@FUNCTION=COS\n"
#~ "@SYNTAX=COS(x)\n"
#~ "@DESCRIPTION=Funktionen COS returnerar cosinus av @x, där @x anges i "
#~ "radianer.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COS(0,5) är lika med 0,877583.\n"
#~ "COS(1) är lika med 0,540302.\n"
#~ "\n"
#~ "@SEEALSO=COSH, SIN, SINH, TAN, TANH, RADIANS, DEGREES"

#~ msgid ""
#~ "@FUNCTION=COSH\n"
#~ "@SYNTAX=COSH(x)\n"
#~ "@DESCRIPTION=COSH function returns the hyperbolic cosine of @x, which is "
#~ "defined mathematically as\n"
#~ "\n"
#~ "\t(exp(@x) + exp(-@x)) / 2.\n"
#~ "\n"
#~ "* @x is in radians.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COSH(0.5) equals 1.127626.\n"
#~ "COSH(1) equals 1.543081.\n"
#~ "\n"
#~ "@SEEALSO=COS, SIN, SINH, TAN, TANH, RADIANS, DEGREES, EXP"
#~ msgstr ""
#~ "@FUNCTION=COSH\n"
#~ "@SYNTAX=COSH(x)\n"
#~ "@DESCRIPTION=Funktionen COSH returnerar cosinus hyperbolicus för @x, "
#~ "vilken matematiskt definieras såsom\n"
#~ "\n"
#~ "\t(exp(@x) + exp(-@x)) / 2.\n"
#~ "\n"
#~ "* @x anges i radianer.\n"
#~ "Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COSH(0,5) är lika med 1,127626.\n"
#~ "COSH(1) är lika med 1,543081.\n"
#~ "\n"
#~ "@SEEALSO=COS, SIN, SINH, TAN, TANH, RADIANS, DEGREES, EXP"

#~ msgid ""
#~ "@FUNCTION=DEGREES\n"
#~ "@SYNTAX=DEGREES(x)\n"
#~ "@DESCRIPTION=DEGREES computes the number of degrees equivalent to @x "
#~ "radians.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DEGREES(2.5) equals 143.2394.\n"
#~ "\n"
#~ "@SEEALSO=RADIANS, PI"
#~ msgstr ""
#~ "@FUNCTION=DEGREES\n"
#~ "@SYNTAX=DEGREES(x)\n"
#~ "@DESCRIPTION=DEGREES omvandlar @x radianer till grader.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DEGREES(2,5) är lika med 143,2394.\n"
#~ "\n"
#~ "@SEEALSO=RADIANS, PI"

#~ msgid ""
#~ "@FUNCTION=EXP\n"
#~ "@SYNTAX=EXP(x)\n"
#~ "@DESCRIPTION=EXP computes the value of e (the base of natural logarithms) "
#~ "raised to the power of @x.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "EXP(2) equals 7.389056.\n"
#~ "\n"
#~ "@SEEALSO=LOG, LOG2, LOG10"
#~ msgstr ""
#~ "@FUNCTION=EXP\n"
#~ "@SYNTAX=EXP(x)\n"
#~ "@DESCRIPTION=EXP beräknar värdet av e (basen för den naturliga "
#~ "logaritmen) upphöjt till @x.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "EXP(2) är lika med 7,389056.\n"
#~ "\n"
#~ "@SEEALSO=LOG, LOG2, LOG10"

#~ msgid ""
#~ "@FUNCTION=EXPM1\n"
#~ "@SYNTAX=EXPM1(x)\n"
#~ "@DESCRIPTION=EXPM1 computes EXP(@x)-1 with higher resulting precision "
#~ "than the direct formula.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "EXPM1(0.01) equals 0.01005.\n"
#~ "\n"
#~ "@SEEALSO=EXP, LN1P"
#~ msgstr ""
#~ "@FUNCTION=EXPM1\n"
#~ "@SYNTAX=EXPM1(x)\n"
#~ "@DESCRIPTION=EXPM1 beräknar EXP(@x)-1 med större precision än den direkta "
#~ "ekvationen.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "EXPM1(0.01) är lika med 0.01005.\n"
#~ "\n"
#~ "@SEEALSO=EXP, LN1P"

#~ msgid ""
#~ "@FUNCTION=FACT\n"
#~ "@SYNTAX=FACT(x)\n"
#~ "@DESCRIPTION=FACT computes the factorial of @x. ie, @x!\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FACT(3) equals 6.\n"
#~ "FACT(9) equals 362880.\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=FACT\n"
#~ "@SYNTAX=FACT(x)\n"
#~ "@DESCRIPTION=FACT beräknar fakulteten av @x, det vill säga @x!\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FACT(3) är lika med 6.\n"
#~ "FACT(9) är lika med 362880.\n"
#~ "\n"
#~ "@SEEALSO="

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=BETA\n"
#~ "@SYNTAX=BETA(a,b)\n"
#~ "@DESCRIPTION=BETA function returns the value of the mathematical beta "
#~ "function extended to all real numbers except 0 and negative integers.\n"
#~ "\n"
#~ "* If @a, @b, or (@a + @b) are non-positive integers, BETA returns #NUM! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BETA(2,3) equals 0.083333.\n"
#~ "BETA(-0.5,0.5) equals #NUM!.\n"
#~ "\n"
#~ "@SEEALSO=BETALN,GAMMALN"
#~ msgstr ""
#~ "@FUNCTION=BETA\n"
#~ "@SYNTAX=BETA(a;b)\n"
#~ "@DESCRIPTION=BETA returnerar den matematiska beta-funktionen för alla "
#~ "reella tal utom noll och negativa heltal..\n"
#~ "\n"
#~ "* Om @a, @b eller (@a + @b) är icke-positiva heltal returnerar BETA "
#~ "felvärdet #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BETA(2;3) är lika med 0,083333.\n"
#~ "BETA(-0,5;0,5) är lika med #NUM!.\n"
#~ "\n"
#~ "@SEEALSO=BETALN,GAMMA"

#~ msgid ""
#~ "@FUNCTION=BETALN\n"
#~ "@SYNTAX=BETALN(a,b)\n"
#~ "@DESCRIPTION=BETALN function returns the natural logarithm of the "
#~ "absolute value of the beta function.\n"
#~ "\n"
#~ "* If @a, @b, or (@a + @b) are non-positive integers, BETALN returns "
#~ "#NUM! \n"
#~ "@EXAMPLES=\n"
#~ "BETALN(2,3) equals -2.48.\n"
#~ "BETALN(-0.5,0.5) equals #NUM!.\n"
#~ "\n"
#~ "@SEEALSO=BETA,GAMMALN"
#~ msgstr ""
#~ "@FUNCTION=BETALN\n"
#~ "@SYNTAX=BETALN(räntesats;per;nper;pv)\n"
#~ "@DESCRIPTION=BETALN returnerar den naturliga logaritmen av "
#~ "absolutbeloppet av beta-funktionen.\n"
#~ "\n"
#~ "* If @a, @b, or (@a + @b) are non-positive integers, BETA returns #NUM! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BETALN(2;3) är lika med -2.48.\n"
#~ "BETALN(-0,5;0,5) är lika med #NUM!.\n"
#~ "\n"
#~ "@SEEALSO=BETA,GAMMALN"

#~ msgid ""
#~ "@FUNCTION=COMBIN\n"
#~ "@SYNTAX=COMBIN(n,k)\n"
#~ "@DESCRIPTION=COMBIN computes the number of combinations.\n"
#~ "\n"
#~ "* Performing this function on a non-integer or a negative number returns "
#~ "#NUM! error.\n"
#~ "* If @n is less than @k COMBIN returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COMBIN(8,6) equals 28.\n"
#~ "COMBIN(6,2) equals 15.\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=COMBIN\n"
#~ "@SYNTAX=COMBIN(n;k)\n"
#~ "@DESCRIPTION=COMBIN beräknar antalet kombinationer.\n"
#~ "\n"
#~ "* Om argumenten inte är positiva heltal returneras felvärdet #NUM!.\n"
#~ "* Om @n är mindre än @k returneras felvärdet #NUM!..\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COMBIN(8;6) är lika med 28.\n"
#~ "COMBIN(6;2) är lika med 15.\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=INT\n"
#~ "@SYNTAX=INT(a)\n"
#~ "@DESCRIPTION=INT function returns the largest integer that is not bigger "
#~ "than its argument.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "INT(7.2) equals 7.\n"
#~ "INT(-5.5) equals -6.\n"
#~ "\n"
#~ "@SEEALSO=CEIL, CEILING, FLOOR, ABS, MOD"
#~ msgstr ""
#~ "@FUNCTION=INT\n"
#~ "@SYNTAX=INT(a)\n"
#~ "@DESCRIPTION=Funktionen INT returnerar det största heltal som inte är "
#~ "större än sitt argument.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "INT(7,2) är lika med 7.\n"
#~ "INT(-5,5) är lika med -6.\n"
#~ "\n"
#~ "@SEEALSO=CEIL, CEILING, FLOOR, ABS, MOD"

#~ msgid ""
#~ "@FUNCTION=LOG\n"
#~ "@SYNTAX=LOG(x[,base])\n"
#~ "@DESCRIPTION=LOG computes the logarithm of @x in the given base @base.  "
#~ "If no @base is given LOG returns the logarithm in base 10. @base must be "
#~ "> 0. and cannot equal 1.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LOG(2) equals 0.30103.\n"
#~ "LOG(8192,2) equals 13.\n"
#~ "\n"
#~ "@SEEALSO=LN, LOG2, LOG10"
#~ msgstr ""
#~ "@FUNCTION=LOG\n"
#~ "@SYNTAX=LOG(x[;bas])\n"
#~ "@DESCRIPTION=LOG beräknar logaritmen av @x för den givna basen @bas. Om "
#~ "ingen bas anges används 10. @bas måste vara > 0 och kan inte vara lika "
#~ "med 1.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LOG(2) är lika med 0,30103.\n"
#~ "LOG(8192;2) är lika med 13.\n"
#~ "\n"
#~ "@SEEALSO=LN, LOG2, LOG10"

#~ msgid ""
#~ "@FUNCTION=LN\n"
#~ "@SYNTAX=LN(x)\n"
#~ "@DESCRIPTION=LN returns the natural logarithm of @x.\n"
#~ "\n"
#~ "* If @x <= 0, LN returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LN(7) equals 1.94591.\n"
#~ "\n"
#~ "@SEEALSO=EXP, LOG2, LOG10"
#~ msgstr ""
#~ "@FUNCTION=LN\n"
#~ "@SYNTAX=LN(x)\n"
#~ "@DESCRIPTION=LN returnerar den naturliga logaritmen av @x.\n"
#~ "\n"
#~ "* Om @x <= 0 returneras felvärdet #NUM!\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LN(7) är lika med 1,94591.\n"
#~ "\n"
#~ "@SEEALSO=EXP, LOG2, LOG10"

#~ msgid ""
#~ "@FUNCTION=LN1P\n"
#~ "@SYNTAX=LN1P(x)\n"
#~ "@DESCRIPTION=LN1P computes LN(1+@x) with higher resulting precision than "
#~ "the direct formula.\n"
#~ "\n"
#~ "* If @x <= -1, LN1P returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LN1P(0.01) equals 0.00995.\n"
#~ "\n"
#~ "@SEEALSO=LN, EXPM1"
#~ msgstr ""
#~ "@FUNCTION=LN1P\n"
#~ "@SYNTAX=LN1P(x)\n"
#~ "@DESCRIPTION=LN1P beräknar LN(1+@x) med högre precision än den direkta "
#~ "ekvationen.\n"
#~ "\n"
#~ "* Om @x <= -1 returernas felvärdet #NUM!\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LN1P(0.01) är lika med 0.00995.\n"
#~ "\n"
#~ "@SEEALSO=LN, EXPM1"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=POWER\n"
#~ "@SYNTAX=POWER(x,y)\n"
#~ "@DESCRIPTION=POWER returns the value of @x raised to the power @y.\n"
#~ "\n"
#~ "\n"
#~ "* If both @x and @y equal 0, POWER returns #NUM! error.\n"
#~ "* If @x = 0 and @y < 0, POWER returns #DIV/0! error.\n"
#~ "* If @x < 0 and @y is non-integer, POWER returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "POWER(2,7) equals 128.\n"
#~ "POWER(3,3.141) equals 31.523749.\n"
#~ "\n"
#~ "@SEEALSO=EXP"
#~ msgstr ""
#~ "@FUNCTION=POWER\n"
#~ "@SYNTAX=POWER(x;y)\n"
#~ "@DESCRIPTION=POWER returnerar värdet av @x upphöjt till @y.\n"
#~ "\n"
#~ "Om både @x och @y är noll returneras felvärdet #NUM!.\n"
#~ "Om @x = 0 och @y < 0 returneras felvärdet #DIV/0!.\n"
#~ "Om @x <0 och @y inte är ett heltal returneras felvärdet #NUM!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "POWER(2;7) är lika med 128.\n"
#~ "POWER(3;3,141) är lika med 31,523749.\n"
#~ "\n"
#~ "@SEEALSO=EXP"

#~ msgid ""
#~ "@FUNCTION=LOG2\n"
#~ "@SYNTAX=LOG2(x)\n"
#~ "@DESCRIPTION=LOG2 computes the base-2 logarithm of @x.\n"
#~ "\n"
#~ "* If @x <= 0, LOG2 returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LOG2(1024) equals 10.\n"
#~ "\n"
#~ "@SEEALSO=EXP, LOG10, LOG"
#~ msgstr ""
#~ "@FUNCTION=LOG2\n"
#~ "@SYNTAX=LOG2(x)\n"
#~ "@DESCRIPTION=LOG2 beräknar logaritmen av @x i basen 2.\n"
#~ "\n"
#~ "* Om @x <= 0 returernas felvärdet #NUM!\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LOG2(1024) är lika med 10.\n"
#~ "\n"
#~ "@SEEALSO=EXP, LOG10, LOG"

#~ msgid ""
#~ "@FUNCTION=LOG10\n"
#~ "@SYNTAX=LOG10(x)\n"
#~ "@DESCRIPTION=LOG10 computes the base-10 logarithm of @x.\n"
#~ "\n"
#~ "* If @x <= 0, LOG10 returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ " \n"
#~ "@EXAMPLES=\n"
#~ "LOG10(7) equals 0.845098.\n"
#~ "\n"
#~ "@SEEALSO=EXP, LOG2, LOG"
#~ msgstr ""
#~ "@FUNCTION=LOG10\n"
#~ "@SYNTAX=LOG10(x)\n"
#~ "@DESCRIPTION=LOG10 beräknar logaritmen av @x i basen 10.\n"
#~ "\n"
#~ "* Om @x <= 0 returneras felvärdet #NUM!\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LOG10(7) är lika med 0,845098.\n"
#~ "\n"
#~ "@SEEALSO=EXP, LOG2, LOG"

#~ msgid ""
#~ "@FUNCTION=MOD\n"
#~ "@SYNTAX=MOD(number,divisor)\n"
#~ "@DESCRIPTION=MOD function returns the remainder when @divisor is divided "
#~ "into @number.\n"
#~ "\n"
#~ "* MOD returns #DIV/0! if @divisor is zero.\n"
#~ "* This function is Excel compatible.\n"
#~ " \n"
#~ "@EXAMPLES=\n"
#~ "MOD(23,7) equals 2.\n"
#~ "\n"
#~ "@SEEALSO=CEIL, CEILING, FLOOR, ABS, INT, ABS"
#~ msgstr ""
#~ "@FUNCTION=MOD\n"
#~ "@SYNTAX=MOD(tal;divisor)\n"
#~ "@DESCRIPTION=Funktionen MOD returnerar resten när @tal delas med "
#~ "@divisor.\n"
#~ "\n"
#~ "* MOD returnerar #DIV/0! om @divisor är noll.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "MOD(23;7) är lika med 2.\n"
#~ "\n"
#~ "@SEEALSO=CEIL, CEILING, FLOOR, ABS, INT, ABS"

#~ msgid ""
#~ "@FUNCTION=RADIANS\n"
#~ "@SYNTAX=RADIANS(x)\n"
#~ "@DESCRIPTION=RADIANS computes the number of radians equivalent to @x "
#~ "degrees.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RADIANS(180) equals 3.14159.\n"
#~ "\n"
#~ "@SEEALSO=PI,DEGREES"
#~ msgstr ""
#~ "@FUNCTION=RADIANS\n"
#~ "@SYNTAX=RADIANS(x)\n"
#~ "@DESCRIPTION=RADIANS omvandlar @x grader till radianer.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RADIANS(180) är lika med 3,14159.\n"
#~ "\n"
#~ "@SEEALSO=PI,DEGREES"

#~ msgid ""
#~ "@FUNCTION=SIN\n"
#~ "@SYNTAX=SIN(x)\n"
#~ "@DESCRIPTION=SIN function returns the sine of @x, where @x is given in "
#~ "radians.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "SIN(0.5) equals 0.479426.\n"
#~ "\n"
#~ "@SEEALSO=COS, COSH, SINH, TAN, TANH, RADIANS, DEGREES"
#~ msgstr ""
#~ "@FUNCTION=SIN\n"
#~ "@SYNTAX=SIN(x)\n"
#~ "@DESCRIPTION=Funktionen SIN returnerar sinus av @x, där @x anges i "
#~ "radianer.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "SIN(0,5) är lika med 0,479426.\n"
#~ "\n"
#~ "@SEEALSO=COS, COSH, SINH, TAN, TANH, RADIANS, DEGREES"

#~ msgid ""
#~ "@FUNCTION=SINH\n"
#~ "@SYNTAX=SINH(x)\n"
#~ "@DESCRIPTION=SINH function returns the hyperbolic sine of @x, which is "
#~ "defined mathematically as\n"
#~ "\n"
#~ "\t(exp(@x) - exp(-@x)) / 2.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "SINH(0.5) equals 0.521095.\n"
#~ "\n"
#~ "@SEEALSO=SIN, COS, COSH, TAN, TANH, DEGREES, RADIANS, EXP"
#~ msgstr ""
#~ "@FUNCTION=SINH\n"
#~ "@SYNTAX=SINH(x)\n"
#~ "@DESCRIPTION=Funktionen SINH beräknar sinus hyperbolicus av @x, vilket "
#~ "matematiskt definieras som\n"
#~ "\n"
#~ "\t(exp(@x) - exp(-@x)) / 2.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "SINH(0,5) är lika med 0,521095.\n"
#~ "@SEEALSO=SIN, COS, COSH, TAN, TANH, DEGREES, RADIANS, EXP"

#~ msgid ""
#~ "@FUNCTION=SQRT\n"
#~ "@SYNTAX=SQRT(x)\n"
#~ "@DESCRIPTION=SQRT function returns the square root of @x.\n"
#~ "\n"
#~ "* If @x is negative, SQRT returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "SQRT(2) equals 1.4142136.\n"
#~ "\n"
#~ "@SEEALSO=POWER"
#~ msgstr ""
#~ "@FUNCTION=SQRT\n"
#~ "@SYNTAX=SQRT(x)\n"
#~ "@DESCRIPTION=Funktionen SQRT returnerar kvadratroten av @x.\n"
#~ "\n"
#~ "* Om @x är negativt returneras felvärdet #NUM!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "SQRT(2) är lika med 1,4142136.\n"
#~ "\n"
#~ "@SEEALSO=POWER"

#~ msgid ""
#~ "@FUNCTION=SUMSQ\n"
#~ "@SYNTAX=SUMSQ(value1, value2, ...)\n"
#~ "@DESCRIPTION=SUMSQ returns the sum of the squares of all the values and "
#~ "cells referenced in the argument list.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ " \n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11, 15, 17, "
#~ "21, and 43.  Then\n"
#~ "SUMSQ(A1:A5) equals 2925.\n"
#~ "\n"
#~ "@SEEALSO=SUM, COUNT"
#~ msgstr ""
#~ "@FUNCTION=SUMSQ\n"
#~ "@SYNTAX=SUMSQ(värde1; värde2; ...)\n"
#~ "@DESCRIPTION=SUMSQ beräknar summan av kvadraterna på alla värden och "
#~ "celler som refereras till i argumentlistan.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att cellerna A1; A2; ...; A5 innehåller talen 11, 15, 17, 21, och "
#~ "43. Då är\n"
#~ "SUMSQ(A1:A5) lika med 2925.\n"
#~ "\n"
#~ "@SEEALSO=SUM, COUNT"

#~ msgid ""
#~ "@FUNCTION=MULTINOMIAL\n"
#~ "@SYNTAX=MULTINOMIAL(value1, value2, ...)\n"
#~ "@DESCRIPTION=MULTINOMIAL returns the ratio of the factorial of a sum of "
#~ "values to the product of factorials.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ " \n"
#~ "@EXAMPLES=\n"
#~ "MULTINOMIAL(2,3,4) equals 1260.\n"
#~ "\n"
#~ "@SEEALSO=SUM"
#~ msgstr ""
#~ "@FUNCTION=MULTINOMIAL\n"
#~ "@SYNTAX=MULTINOMIAL(värde1; värde2; ...)\n"
#~ "@DESCRIPTION=MULTINOMIAL beräknar förhållandet (fakulteten av en summa av "
#~ "värden) / (produkten av fakulteterna av värdena).\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "MULTINOMIAL(2;3;4) är lika med 1260.\n"
#~ "\n"
#~ "@SEEALSO=SUM"

#~ msgid ""
#~ "@FUNCTION=G_PRODUCT\n"
#~ "@SYNTAX=G_PRODUCT(value1, value2, ...)\n"
#~ "@DESCRIPTION=G_PRODUCT returns the product of all the values and cells "
#~ "referenced in the argument list.\n"
#~ "\n"
#~ "* Empty cells are ignored and the empty product is 1.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "G_PRODUCT(2,5,9) equals 90.\n"
#~ "\n"
#~ "@SEEALSO=SUM, COUNT"
#~ msgstr ""
#~ "@FUNCTION=G_PRODUCT\n"
#~ "@SYNTAX=G_PRODUCT(värde1; värde2; ...)\n"
#~ "@DESCRIPTION=G_PRODUCT returnerar produkten av alla värden och celler som "
#~ "refereras till i argumentlistan.\n"
#~ "\n"
#~ "* Tomma celler ignoreras och produkten av tomma celler är 1.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "G_PRODUCT(2;5;9) är lika med 90.\n"
#~ "\n"
#~ "@SEEALSO=SUM, COUNT"

#~ msgid ""
#~ "@FUNCTION=TAN\n"
#~ "@SYNTAX=TAN(x)\n"
#~ "@DESCRIPTION=TAN function returns the tangent of @x, where @x is given in "
#~ "radians.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TAN(3) equals -0.1425465.\n"
#~ "\n"
#~ "@SEEALSO=TANH, COS, COSH, SIN, SINH, DEGREES, RADIANS"
#~ msgstr ""
#~ "@FUNCTION=TAN\n"
#~ "@SYNTAX=TAN(x)\n"
#~ "@DESCRIPTION=Funktionen TAN returnerar tangens av @x, där @x anges i "
#~ "radianer.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TAN(3) är lika med -0,1425465.\n"
#~ "\n"
#~ "@SEEALSO=TANH, COS, COSH, SIN, SINH, DEGREES, RADIANS"

#~ msgid ""
#~ "@FUNCTION=TANH\n"
#~ "@SYNTAX=TANH(x)\n"
#~ "@DESCRIPTION=TANH function returns the hyperbolic tangent of @x, which is "
#~ "defined mathematically as \n"
#~ "\n"
#~ "\tsinh(@x) / cosh(@x).\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TANH(2) equals 0.96402758.\n"
#~ "\n"
#~ "@SEEALSO=TAN, SIN, SINH, COS, COSH, DEGREES, RADIANS"
#~ msgstr ""
#~ "@FUNCTION=TANH\n"
#~ "@SYNTAX=TANH(x)\n"
#~ "@DESCRIPTION=Funktionen TANH returnerar tangens hyperbolicus av @x, "
#~ "vilket matematiskt definierat som\n"
#~ "\n"
#~ "\tsinh(@x) / cosh(@x).\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TANH(2) är lika med 0,96402758.\n"
#~ "\n"
#~ "@SEEALSO=TAN, SIN, SINH, COS, COSH, DEGREES, RADIANS"

#~ msgid ""
#~ "@FUNCTION=PI\n"
#~ "@SYNTAX=PI()\n"
#~ "@DESCRIPTION=PI functions returns the value of pi.\n"
#~ "\n"
#~ "* This function is called with no arguments.\n"
#~ "* This function is Excel compatible, except that it returns pi with a "
#~ "better precision.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "PI() equals about 3.141593.\n"
#~ "\n"
#~ "@SEEALSO=SQRTPI"
#~ msgstr ""
#~ "@FUNCTION=PI\n"
#~ "@SYNTAX=PI()\n"
#~ "@DESCRIPTION=Funktionen PI returnerar värdet av pi.\n"
#~ "\n"
#~ "* Denna funktion anropas utan argument.\n"
#~ "* Denna funktion är kompatibel med Excel, förutom att den returnerar pi "
#~ "med bättre precision.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "PI() är ungefär lika med 3,141593.\n"
#~ "\n"
#~ "@SEEALSO=SQRTPI"

#~ msgid ""
#~ "@FUNCTION=TRUNC\n"
#~ "@SYNTAX=TRUNC(number[,digits])\n"
#~ "@DESCRIPTION=TRUNC function returns the value of @number truncated to the "
#~ "number of digits specified.\n"
#~ "\n"
#~ "* If @digits is omitted or negative then @digits defaults to zero.\n"
#~ "* If @digits is not an integer, it is truncated.\n"
#~ "* This function is Excel compatible.\n"
#~ " \n"
#~ "@EXAMPLES=\n"
#~ "TRUNC(3.12) equals 3.\n"
#~ "TRUNC(4.15,1) equals 4.1.\n"
#~ "\n"
#~ "@SEEALSO=INT"
#~ msgstr ""
#~ "@FUNCTION=TRUNC\n"
#~ "@SYNTAX=TRUNC(tal[;siffror])\n"
#~ "@DESCRIPTION=Funktionen TRUNC returnerar värdet av @tal avhugget till det "
#~ "givna antalet decimaler.\n"
#~ "\n"
#~ "* Om @siffror inte anges eller är negativt sätts @siffror till noll.\n"
#~ "* Om @siffror inte är ett heltal, trunkeras det.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TRUNC(3,12) är lika med 3.\n"
#~ "TRUNC(4,15;1) är lika med 4,1.\n"
#~ "\n"
#~ "@SEEALSO=INT"

#~ msgid ""
#~ "@FUNCTION=EVEN\n"
#~ "@SYNTAX=EVEN(number)\n"
#~ "@DESCRIPTION=EVEN function returns the number rounded up to the nearest "
#~ "even integer.  Negative numbers are rounded down.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ " \n"
#~ "@EXAMPLES=\n"
#~ "EVEN(5.4) equals 6.\n"
#~ "EVEN(-5.4) equals -6.\n"
#~ "\n"
#~ "@SEEALSO=ODD"
#~ msgstr ""
#~ "@FUNCTION=EVEN\n"
#~ "@SYNTAX=EVEN(tal)\n"
#~ "@DESCRIPTION=Funktionen EVEN returnerar @tal avrundat uppåt till närmsta "
#~ "jämna heltal.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "EVEN(5,4) är lika med 6.\n"
#~ "\n"
#~ "@SEEALSO=ODD"

#~ msgid ""
#~ "@FUNCTION=ODD\n"
#~ "@SYNTAX=ODD(number)\n"
#~ "@DESCRIPTION=ODD function returns the @number rounded up to the nearest "
#~ "odd integer.  Negative numbers are rounded down.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ " \n"
#~ "@EXAMPLES=\n"
#~ "ODD(4.4) equals 5.\n"
#~ "ODD(-4.4) equals -5.\n"
#~ "\n"
#~ "@SEEALSO=EVEN"
#~ msgstr ""
#~ "@FUNCTION=ODD\n"
#~ "@SYNTAX=ODD(tal)\n"
#~ "@DESCRIPTION=Funktionen ODD returnerar @tal avrundat uppåt till närmsta "
#~ "udda heltal.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ODD(4,4) är lika med 5.\n"
#~ "\n"
#~ "@SEEALSO=EVEN"

#~ msgid ""
#~ "@FUNCTION=FACTDOUBLE\n"
#~ "@SYNTAX=FACTDOUBLE(number)\n"
#~ "@DESCRIPTION=FACTDOUBLE function returns the double factorial of a "
#~ "@number, i.e., x!!.\n"
#~ "\n"
#~ "* If @number is not an integer, it is truncated.\n"
#~ "* If @number is negative FACTDOUBLE returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ " \n"
#~ "@EXAMPLES=\n"
#~ "FACTDOUBLE(5) equals 15.\n"
#~ "\n"
#~ "@SEEALSO=FACT"
#~ msgstr ""
#~ "@FUNCTION=FACTDOUBLE\n"
#~ "@SYNTAX=FACTDOUBLE(tal)\n"
#~ "@DESCRIPTION=Funktionen FACTDOUBLE beräknar semifakulteten för @tal, dvs "
#~ "x!!.\n"
#~ "\n"
#~ "* Om @tal inte är ett heltal, trunkeras det.\n"
#~ "* Om @tal är negativt, returneras felvärdet #NUM!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FACTDOUBLE(5) är lika med 15.\n"
#~ "\n"
#~ "@SEEALSO=FACT"

#~ msgid ""
#~ "@FUNCTION=FIB\n"
#~ "@SYNTAX=FIB(number)\n"
#~ "@DESCRIPTION=FIB function computes Fibonacci numbers.\n"
#~ "\n"
#~ "* If @number is not an integer, it is truncated.\n"
#~ "* If @number is negative or zero FIB returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FIB(12) equals 144.\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=FIB\n"
#~ "@SYNTAX=FIB(tal)\n"
#~ "@DESCRIPTION=Funktionen FIB beräknar Fibonacci-tal\n"
#~ "\n"
#~ "* Om @tal inte är ett heltal, trunkeras det.\n"
#~ "* Om @tal är negativt eller noll, returneras felvärdet #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FIB(12) är lika med 144.\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=QUOTIENT\n"
#~ "@SYNTAX=QUOTIENT(numerator,denominator)\n"
#~ "@DESCRIPTION=QUOTIENT function returns the integer portion of a "
#~ "division.  @numerator is the divided number and @denominator is the "
#~ "divisor.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ " \n"
#~ "@EXAMPLES=\n"
#~ "QUOTIENT(23,5) equals 4.\n"
#~ "\n"
#~ "@SEEALSO=MOD"
#~ msgstr ""
#~ "@FUNCTION=QUOTIENT\n"
#~ "@SYNTAX=QUOTIENT(täljare;nämnare)\n"
#~ "@DESCRIPTION=Funktionen QUOTIENT returnerar heltalsdelen av ett bråk. "
#~ "@täljare är värdet som delas, och @nämnare är värdet det delas med.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "QUOTIENT(23;5) är lika med 4.\n"
#~ "\n"
#~ "@SEEALSO=MOD"

#~ msgid ""
#~ "@FUNCTION=SIGN\n"
#~ "@SYNTAX=SIGN(number)\n"
#~ "@DESCRIPTION=SIGN function returns 1 if the @number is positive, zero if "
#~ "the @number is 0, and -1 if the @number is negative.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ " \n"
#~ "@EXAMPLES=\n"
#~ "SIGN(3) equals 1.\n"
#~ "SIGN(-3) equals -1.\n"
#~ "SIGN(0) equals 0.\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=SIGN\n"
#~ "@SYNTAX=SIGN(tal)\n"
#~ "@DESCRIPTION=Funktionen SIGN returnerar 1 om @tal är positivt, 0 om det "
#~ "är 0, och -1 om @tal är negativt.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "SIGN(3) är lika med 1.\n"
#~ "SIGN(-3) är lika med -1.\n"
#~ "SIGN(0) är lika med 0.\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=SQRTPI\n"
#~ "@SYNTAX=SQRTPI(number)\n"
#~ "@DESCRIPTION=SQRTPI function returns the square root of a @number "
#~ "multiplied by pi.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "SQRTPI(2) equals 2.506628275.\n"
#~ "\n"
#~ "@SEEALSO=PI"
#~ msgstr ""
#~ "@FUNCTION=SQRTPI\n"
#~ "@SYNTAX=SQRTPI(tal)\n"
#~ "@DESCRIPTION=Funktionen SQRTPI beräknar kvadratroten av ett @tal "
#~ "multiplicarat med pi.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "SQRTPI(2) är lika med 2,506628275.\n"
#~ "\n"
#~ "@SEEALSO=PI"

#~ msgid ""
#~ "@FUNCTION=ROUNDDOWN\n"
#~ "@SYNTAX=ROUNDDOWN(number[,digits])\n"
#~ "@DESCRIPTION=ROUNDDOWN function rounds a given @number towards 0.\n"
#~ "\n"
#~ "@number is the number you want rounded toward 0 and @digits is the number "
#~ "of digits to which you want to round that number.\n"
#~ "\n"
#~ "* If @digits is greater than zero, @number is rounded toward 0 to the "
#~ "given number of digits.\n"
#~ "* If @digits is zero or omitted, @number is rounded toward 0 to the next "
#~ "integer.\n"
#~ "* If @digits is less than zero, @number is rounded toward 0 to the left "
#~ "of the decimal point.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ROUNDDOWN(5.5) equals 5.\n"
#~ "ROUNDDOWN(-3.3) equals -3.\n"
#~ "ROUNDDOWN(1501.15,1) equals 1501.1.\n"
#~ "ROUNDDOWN(1501.15,-2) equals 1500.0.\n"
#~ "\n"
#~ "@SEEALSO=ROUND,ROUNDUP"
#~ msgstr ""
#~ "@FUNCTION=ROUNDDOWN\n"
#~ "@SYNTAX=ROUNDDOWN(tal[;siffor])\n"
#~ "@DESCRIPTION=Funktionen ROUNDDOWN avrundar @tal nedåt. @siffor är antalet "
#~ "siffror som @tal skall avrundas till.\n"
#~ "\n"
#~ "* Om @siffror är större än noll avrundas @tal till det angivna antalet "
#~ "siffror.\n"
#~ "* Om @siffror är noll eller utelämnat, avrundas @tal nedåt till närmsta "
#~ "heltal.\n"
#~ "* Om @siffror är mindre än noll, avrundas @tal nedåt till vänster om "
#~ "decimaltecknet.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ROUNDDOWN(5,5) är lika med 5.\n"
#~ "ROUNDDOWN(-3,3) är lika med -4.\n"
#~ "ROUNDDOWN(1501,15;1) är lika med 1501,1.\n"
#~ "ROUNDDOWN(1501,15;-2) är lika med 1500,0.\n"
#~ "\n"
#~ " @SEEALSO=ROUND,ROUNDUP"

#~ msgid ""
#~ "@FUNCTION=ROUND\n"
#~ "@SYNTAX=ROUND(number[,digits])\n"
#~ "@DESCRIPTION=ROUND function rounds a given number.\n"
#~ "\n"
#~ "@number is the number you want rounded and @digits is the number of "
#~ "digits to which you want to round that number.\n"
#~ "\n"
#~ "* If @digits is greater than zero, @number is rounded to the given number "
#~ "of digits.\n"
#~ "* If @digits is zero or omitted, @number is rounded to the nearest "
#~ "integer.\n"
#~ "* If @digits is less than zero, @number is rounded to the left of the "
#~ "decimal point.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ROUND(5.5) equals 6.\n"
#~ "ROUND(-3.3) equals -3.\n"
#~ "ROUND(1501.15,1) equals 1501.2.\n"
#~ "ROUND(1501.15,-2) equals 1500.0.\n"
#~ "\n"
#~ "@SEEALSO=ROUNDDOWN,ROUNDUP"
#~ msgstr ""
#~ "@FUNCTION=ROUND\n"
#~ "@SYNTAX=ROUND(tal[;siffror])\n"
#~ "@DESCRIPTION=Funktionen ROUND avrundar ett givet värde.\n"
#~ "\n"
#~ "@tal är värdet du vill avrunda och @siffror är det antal siffror till "
#~ "vilket du vill avrunda det.\n"
#~ "\n"
#~ "* Om @siffror är större än noll avrundas @tal till det angivna antalet "
#~ "siffror.\n"
#~ "* Om @siffror är mindre än noll eller utelämnat, avrundas @tal till "
#~ "närmsta heltal.\n"
#~ "* Om @siffror är mindre än noll, avrundas @tal till vänster om "
#~ "decimaltecknet.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ROUND(5,5) är lika med 6.\n"
#~ "ROUND(-3,3) är lika med -3.\n"
#~ "ROUND(1501,15;1) är lika med 1501,2.\n"
#~ "ROUND(1501,15;-2) är lika med 1500,0.\n"
#~ "\n"
#~ "@SEEALSO=ROUNDDOWN,ROUNDUP"

#~ msgid ""
#~ "@FUNCTION=ROUNDUP\n"
#~ "@SYNTAX=ROUNDUP(number[,digits])\n"
#~ "@DESCRIPTION=ROUNDUP function rounds a given number away from 0.\n"
#~ "\n"
#~ "@number is the number you want rounded away from 0 and @digits is the "
#~ "number of digits to which you want to round that number.\n"
#~ "\n"
#~ "* If @digits is greater than zero, @number is rounded away from 0 to the "
#~ "given number of digits.\n"
#~ "* If @digits is zero or omitted, @number is rounded away from 0 to the "
#~ "next integer.\n"
#~ "* If @digits is less than zero, @number is rounded away from 0 to the "
#~ "left of the decimal point.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ROUNDUP(5.5) equals 6.\n"
#~ "ROUNDUP(-3.3) equals -4.\n"
#~ "ROUNDUP(1501.15,1) equals 1501.2.\n"
#~ "ROUNDUP(1501.15,-2) equals 1600.0.\n"
#~ "\n"
#~ "@SEEALSO=ROUND,ROUNDDOWN"
#~ msgstr ""
#~ "@FUNCTION=ROUNDUP\n"
#~ "@SYNTAX=ROUNDUP(tal[;siffror])\n"
#~ "@DESCRIPTION=Funktionen ROUNDUP avrundar värdet uppåt.i\n"
#~ "\n"
#~ "@tal är värdet du vill avrunda och @siffror är det antal siffror till "
#~ "vilket du vill avrunda det.\n"
#~ "\n"
#~ "* Om @siffror är större än noll avrundas @tal till det angivna antalet "
#~ "siffror.\n"
#~ "* Om @siffror är noll eller utelämnat, avrundas @tal uppåt till närmsta "
#~ "heltal.\n"
#~ "* Om @siffror är mindre än noll, avrundas @tal uppåt till vänster om "
#~ "decimaltecknet.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ROUNDUP(5,5) är lika med 6.\n"
#~ "ROUNDUP(-3,3) är lika med -3.\n"
#~ "ROUNDUP(1501,15;1) är lika med 1501,2.\n"
#~ "ROUNDUP(1501,15;-2) är lika med 1600,0.\n"
#~ "\n"
#~ "@SEEALSO=ROUND,ROUNDDOWN"

#~ msgid ""
#~ "@FUNCTION=MROUND\n"
#~ "@SYNTAX=MROUND(number,multiple)\n"
#~ "@DESCRIPTION=MROUND function rounds a given number to the desired "
#~ "multiple.\n"
#~ "\n"
#~ "@number is the number you want rounded and @multiple is the the multiple "
#~ "to which you want to round the number.\n"
#~ "\n"
#~ "* If @number and @multiple have different sign, MROUND returns #NUM! "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "MROUND(1.7,0.2) equals 1.8.\n"
#~ "MROUND(321.123,0.12) equals 321.12.\n"
#~ "\n"
#~ "@SEEALSO=ROUNDDOWN,ROUND,ROUNDUP"
#~ msgstr ""
#~ "@FUNCTION=MROUND\n"
#~ "@SYNTAX=MROUND(tal;multipel)\n"
#~ "@DESCRIPTION=Funktionen MROUND avrundar ett givet tal till den angivna "
#~ "multipeln.\n"
#~ "\n"
#~ "@tal är talet du vill avrunda och @multipel är den multipel som du vill "
#~ "avrunda talet till.\n"
#~ "\n"
#~ "* Om @tal och @multipel har olika tecken returnerar MROUND felvärdet "
#~ "#NUM!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "MROUND(1,7;0,2) är lika med 1,8.\n"
#~ "ROUND(321,123;0,12) är lika med 321,12.\n"
#~ "\n"
#~ "@SEEALSO=ROUNDDOWN,ROUND,ROUNDUP"

#~ msgid ""
#~ "@FUNCTION=ROMAN\n"
#~ "@SYNTAX=ROMAN(number[,type])\n"
#~ "@DESCRIPTION=ROMAN function returns an arabic number in the roman numeral "
#~ "style, as text. @number is the number you want to convert and @type is "
#~ "the type of roman numeral you want.\n"
#~ "\n"
#~ "* If @type is 0 or it is omitted, ROMAN returns classic roman numbers.\n"
#~ "* Type 1 is more concise than classic type, type 2 is more concise than "
#~ "type 1, and type 3 is more concise than type 2.  Type 4 is simplified "
#~ "type.\n"
#~ "* If @number is negative or greater than 3999, ROMAN returns #VALUE! "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ROMAN(999) equals CMXCIX.\n"
#~ "ROMAN(999,1) equals LMVLIV.\n"
#~ "ROMAN(999,2) equals XMIX.\n"
#~ "ROMAN(999,3) equals VMIV.\n"
#~ "ROMAN(999,4) equals IM.\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=ROMAN\n"
#~ "@SYNTAX=ROMAN(tal[;typ])\n"
#~ "@DESCRIPTION=Funktionen ROMAN returnerar ett arabiskt tal som ett "
#~ "romerskt tal, i textformat. @tal är det tal som skall omvandlas och @typ "
#~ "är den typ av romerskt tal du vill omvandla till.\n"
#~ "\n"
#~ "* Om @typ är 0 eller inte är angiven, returneras klassiska romerska tal.\n"
#~ "* Typ 1 är mer concis är den klassiska stilen, typ 2 är mer concis än typ "
#~ "1 och typ 3 är mer concis än typ 2. Typ 4 är en förenklad stil. \n"
#~ "* Om @tal är negativt eller större än 3999, returnerar ROMAN felvärdet "
#~ "#VÄRDE!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ROMAN(999) är lika med CMXCIX.\n"
#~ "ROMAN(999;1) är lika med LMVLIV.\n"
#~ "ROMAN(999;2) är lika med XMIX.\n"
#~ "ROMAN(999;3) är lika med VMIV.\n"
#~ "ROMAN(999;4) är lika med IM.\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=SUMX2MY2\n"
#~ "@SYNTAX=SUMX2MY2(array1,array2)\n"
#~ "@DESCRIPTION=SUMX2MY2 function returns the sum of the difference of "
#~ "squares of corresponding values in two arrays. @array1 is the first array "
#~ "or range of data points and @array2 is the second array or range of data "
#~ "points. The equation of SUMX2MY2 is SUM (x^2-y^2).\n"
#~ "\n"
#~ "* Strings and empty cells are simply ignored.\n"
#~ "* If @array1 and @array2 have different number of data points, SUMX2MY2 "
#~ "returns #N/A error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11, 15, 17, "
#~ "21, and 43 and the cells B1, B2, ..., B5 hold numbers 13, 22, 31, 33, and "
#~ "39.  Then\n"
#~ "SUMX2MY2(A1:A5,B1:B5) equals -1299.\n"
#~ "\n"
#~ "@SEEALSO=SUMSQ,SUMX2PY2"
#~ msgstr ""
#~ "@FUNCTION=SUMX2MY2\n"
#~ "@SYNTAX=SUMX2MY2(fält1;fält2)\n"
#~ "@DESCRIPTION=Funktionen SUMX2MY2 returnerar summan av skillnaderna mellan "
#~ "kvadraterna av talen i de två fälten @fält1 och @fält2. Ekvationen för "
#~ "SUMX2MY2 är SUM (x²-y²).\n"
#~ "\n"
#~ "* Strängar och tomma celler ignoreras.\n"
#~ "* Om @fält1 och @fält2 har olika antal värden returneras felvärdet #-.\n"
#~ "Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att cellerna A1; A2; ...; A5 innehåller talen 11, 15, 17, 21, och "
#~ "43 och cellerna B1; B2; ...; B5 innehåller talen 13, 22, 31, 33, samt 39. "
#~ "Då är\n"
#~ "SUMX2MY2(A1:A5;B1:B5) lika med -1299.\n"
#~ "\n"
#~ "@SEEALSO=SUMSQ,SUMX2PY2"

#~ msgid ""
#~ "@FUNCTION=SUMX2PY2\n"
#~ "@SYNTAX=SUMX2PY2(array1,array2)\n"
#~ "@DESCRIPTION=SUMX2PY2 function returns the sum of the sum of squares of "
#~ "corresponding values in two arrays. @array1 is the first array or range "
#~ "of data points and @array2 is the second array or range of data points. "
#~ "The equation of SUMX2PY2 is SUM (x^2+y^2).\n"
#~ "\n"
#~ "* Strings and empty cells are simply ignored.\n"
#~ "* If @array1 and @array2 have different number of data points, SUMX2PY2 "
#~ "returns #N/A error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11, 15, 17, "
#~ "21, and 43 and the cells B1, B2, ..., B5 hold numbers 13, 22, 31, 33, and "
#~ "39.  Then\n"
#~ "SUMX2PY2(A1:A5,B1:B5) equals 7149.\n"
#~ "\n"
#~ "@SEEALSO=SUMSQ,SUMX2MY2"
#~ msgstr ""
#~ "@FUNCTION=SUMX2PY2\n"
#~ "@SYNTAX=SUMX2PY2(fält1;fält2)\n"
#~ "@DESCRIPTION=Funktionen SUMX2PY2 returnerar summan av summorna av "
#~ "kvadraterna av de motsvarande talen i de två fälten @fält1 och @fält2. "
#~ "Ekvationen för SUMX2PY2 är SUM (x²+y²).\n"
#~ "\n"
#~ "* Strängar och tomma celler ignoreras.\n"
#~ "* Om @fält1 och @fält2 har olika antal värden returneras felvärdet #-.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att cellerna A1; A2; ...; A5 innehåller talen 11, 15, 17, 21, och "
#~ "43 samt att cellerna B1; B2; ...; B5 innehåller talen 13, 22, 31, 33, och "
#~ "39. Då är\n"
#~ "SUMX2PY2(A1:A5;B1:B5) lika med 7149.\n"
#~ "\n"
#~ "@SEEALSO=SUMSQ,SUMX2MY2"

#~ msgid ""
#~ "@FUNCTION=SUMXMY2\n"
#~ "@SYNTAX=SUMXMY2(array1,array2)\n"
#~ "@DESCRIPTION=SUMXMY2 function returns the sum of squares of differences "
#~ "of corresponding values in two arrays. @array1 is the first array or "
#~ "range of data points and @array2 is the second array or range of data "
#~ "points. The equation of SUMXMY2 is SUM (x-y)^2.\n"
#~ "\n"
#~ "* Strings and empty cells are simply ignored.\n"
#~ "* If @array1 and @array2 have different number of data points, SUMXMY2 "
#~ "returns #N/A error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11, 15, 17, "
#~ "21, and 43 and the cells B1, B2, ..., B5 hold numbers 13, 22, 31, 33, and "
#~ "39.  Then\n"
#~ "SUMXMY2(A1:A5,B1:B5) equals 409.\n"
#~ "\n"
#~ "@SEEALSO=SUMSQ,SUMX2MY2,SUMX2PY2"
#~ msgstr ""
#~ "@FUNCTION=SUMXMY2\n"
#~ "@SYNTAX=SUMXMY2(fält1;fält2)\n"
#~ "@DESCRIPTION=Funktionen SUMXMY2 returnerar summan av kvadraterna av "
#~ "skillnaderna mellan de motsvarande talen i två fält. @fält1 är det första "
#~ "fältet eller intervallet med datapunkter och @fält2 är det andra fältet "
#~ "med datapunkter. Ekvationen för SUMXMY2 är SUM (x-y)².\n"
#~ "\n"
#~ "* Strängar och tomma celler ignoreras.\n"
#~ "* Om @fält1 och @fält2 har olika antal värden returneras felvärdet #-.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att cellerna A1; A2; ...; A5 innehåller talen 11, 15, 17, 21, och "
#~ "43 och att cellerna B1; B2; ...; B5 innehåller talen 13, 22, 31, 33, samt "
#~ "39. Då är\n"
#~ "SUMXMY2(A1:A5;B1:B5) lika med 409.\n"
#~ "\n"
#~ "@SEEALSO=SUMSQ,SUMX2MY2,SUMX2PY2"

#~ msgid ""
#~ "@FUNCTION=SERIESSUM\n"
#~ "@SYNTAX=SERIESSUM(x,n,m,coefficients)\n"
#~ "@DESCRIPTION=SERIESSUM function returns the sum of a power series.  @x is "
#~ "the base of the power series, @n is the initial power to raise @x, @m is "
#~ "the increment to the power for each term in the series, and @coefficients "
#~ "are the coefficients by which each successive power of @x is multiplied.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 1.23, 2.32, "
#~ "2.98, 3.42, and 4.33.  Then\n"
#~ "SERIESSUM(3,1,2.23,A1:A5) equals 251416.43018.\n"
#~ "\n"
#~ "@SEEALSO=COUNT,SUM"
#~ msgstr ""
#~ "@FUNCTION=SERIESSUM\n"
#~ "@SYNTAX=SERIESSUM(x;n;m;koefficienter)\n"
#~ "@DESCRIPTION=Funktionen SERIESSUM returnerar summan av en "
#~ "exponentialserie. @x är basen i serien, @n är den första exponenten, @m "
#~ "är ökningen i exponenten och @koefficienter är koefficienterna som "
#~ "termerna multipliceras med.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att cellerna A1; A2; ...; A5 innehåller talen 1,23, 2,32, 2,98, "
#~ "3,42 och 4,33. Då är\n"
#~ "SERIESSUM(3;1;2,23;A1:A5) lika med 251416,43018.\n"
#~ "\n"
#~ "@SEEALSO=COUNT,SUM"

#~ msgid ""
#~ "@FUNCTION=MINVERSE\n"
#~ "@SYNTAX=MINVERSE(matrix)\n"
#~ "@DESCRIPTION=MINVERSE function returns the inverse matrix of @matrix.\n"
#~ "\n"
#~ "* If @matrix cannot be inverted, MINVERSE returns #NUM! error.\n"
#~ "* If @matrix does not contain equal number of columns and rows, MINVERSE "
#~ "returns #VALUE! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=MMULT, MDETERM"
#~ msgstr ""
#~ "@FUNCTION=MINVERSE\n"
#~ "@SYNTAX=MINVERSE(matris)\n"
#~ "@DESCRIPTION=Funktionen MINVERSE returnerar inversen av den givna "
#~ "matrisen @matris.\n"
#~ "\n"
#~ "* Om @matris inte kan inverteras, returneras felvärdet #NUM!.\n"
#~ "* Om @matris inte har lika antal rader som kolumner, returneras felvärdet "
#~ "#VÄRDE!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=MMULT, MDETERM"

#~ msgid ""
#~ "@FUNCTION=MMULT\n"
#~ "@SYNTAX=MMULT(array1,array2)\n"
#~ "@DESCRIPTION=MMULT function returns the matrix product of two arrays. The "
#~ "result is an array with the same number of rows as @array1 and the same "
#~ "number of columns as @array2.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=TRANSPOSE,MINVERSE"
#~ msgstr ""
#~ "@FUNCTION=MMULT\n"
#~ "@SYNTAX=MMULT(fält1;fält2)\n"
#~ "@DESCRIPTION=Funktionen MMULT beräknar produkten av två matriser. "
#~ "Resultatet är ett fält med samma antal rader som @fält1 och samma antal "
#~ "kolumner som @fält2.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=TRANSPOSE,MINVERSE"

#~ msgid ""
#~ "@FUNCTION=MDETERM\n"
#~ "@SYNTAX=MDETERM(matrix)\n"
#~ "@DESCRIPTION=MDETERM function returns the determinant of a given matrix.\n"
#~ "\n"
#~ "* If the @matrix does not contain equal number of columns and rows, "
#~ "MDETERM returns #VALUE! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that A1, ..., A4 contain numbers 2, 3, 7, and 3, B1, ..., "
#~ "B4 4, 2, 4, and 1, C1, ..., C4 9, 4, 3, and 2, and D1, ..., D4 7, 3, 6, "
#~ "and 5. Then\n"
#~ "MDETERM(A1:D4) equals 148.\n"
#~ "\n"
#~ "@SEEALSO=MMULT, MINVERSE"
#~ msgstr ""
#~ "@FUNCTION=MDETERM\n"
#~ "@SYNTAX=MDETERM(matris)\n"
#~ "@DESCRIPTION=Funktionen MDETERM returnerar determinanten av en given "
#~ "@matris.\n"
#~ "\n"
#~ "* Om @matris inte innehåller samma antal rader och kolumner returnerar "
#~ "MDETERM felvärdet #VÄRDE!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att att A1, ..., A4 innehåller talen 2, 3, 7, och 3, B1, ..., B4 4, "
#~ "2, 4, och 1, C1, ..., C4 9, 4, 3, och 2, och D1, ..., D4 7, 3, 6, och 5. "
#~ "Då är\n"
#~ "MDETERM(A1:D4) lika med 148.\n"
#~ "\n"
#~ "@SEEALSO=MMULT, MINVERSE"

#~ msgid ""
#~ "@FUNCTION=RAND\n"
#~ "@SYNTAX=RAND()\n"
#~ "@DESCRIPTION=RAND returns a random number between zero and one.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RAND() returns a random number greater than zero but less than one.\n"
#~ "\n"
#~ "@SEEALSO=RANDBETWEEN"
#~ msgstr ""
#~ "@FUNCTION=RAND\n"
#~ "@SYNTAX=RAND()\n"
#~ "@DESCRIPTION=RAND returnerar ett slumptal mellan 0 och 1.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RAND() returnerar ett slumptal större än noll men mindre än ett.\n"
#~ "\n"
#~ "@SEEALSO=RANDBETWEEN"

#~ msgid ""
#~ "@FUNCTION=RANDUNIFORM\n"
#~ "@SYNTAX=RANDUNIFORM(a,b)\n"
#~ "@DESCRIPTION=RANDUNIFORM returns a random variate from the uniform (flat) "
#~ "distribution from a to b. The distribution is,\n"
#~ "\n"
#~ "\tp(x) dx = {1 over (b-a)} dx : for a <= x < b.\n"
#~ "p(x) dx = 0 : for x < a or b <= x.\n"
#~ "* If @a > @b RANDUNIFORM returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDUNIFORM(1.4,4.2) returns a random number greater than or equal to 1.4 "
#~ "but less than 4.2.\n"
#~ "\n"
#~ "@SEEALSO=RANDBETWEEN,RAND"
#~ msgstr ""
#~ "@FUNCTION=RANDUNIFORM\n"
#~ "@SYNTAX=RANDUNIFORM(a;b)\n"
#~ "@DESCRIPTION=RANDUNIFORM returnerar ett slumptal från den "
#~ "rektangelfördelade (platta) fördelningen från a till b. Fördelningen är \n"
#~ "\n"
#~ "\tp(x) dx = {1 över (b-a)} dx: för a <=x < b.\n"
#~ "p(x) dx = 0: för x < a eller b <= x.\n"
#~ "\n"
#~ "* Om @a > @b returnerar RANDUNIFORM felvärdet #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDUNIFORM(1,4;4,2) returnerar ett slumptal som är större än eller lika "
#~ "med 1,4 men mindre än 4,2.\n"
#~ "\n"
#~ "@SEEALSO=RANDBETWEEN,RAND"

#~ msgid ""
#~ "@FUNCTION=RANDDISCRETE\n"
#~ "@SYNTAX=RANDDISCRETE(val_range[,prob_range])\n"
#~ "@DESCRIPTION=RANDDISCRETE returns one of the values in the @val_range. "
#~ "The probabilities for each value are given in the @prob_range.\n"
#~ "\n"
#~ "* If @prob_range is omitted, the uniform discrete distribution is "
#~ "assumed.\n"
#~ "* If the sum of all values in @prob_range is other than one, RANDDISCRETE "
#~ "returns #NUM! error.\n"
#~ "* If @val_range and @prob_range are not the same size, RANDDISCRETE "
#~ "returns #NUM! error.\n"
#~ "* If @val_range or @prob_range is not a range, RANDDISCRETE returns "
#~ "#VALUE! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDDISCRETE(A1:A6) returns one of the values in the range A1:A6.\n"
#~ "\n"
#~ "@SEEALSO=RANDBETWEEN,RAND"
#~ msgstr ""
#~ "@FUNCTION=RANDDISCRETE\n"
#~ "@SYNTAX=RANDDISCRETE(@värdeområde[,@sannolikhetsområde])\n"
#~ "@DESCRIPTION=RANDDISCRETE returnerar ett av värdena i @värdeområde."
#~ "Sannolikheten för varje värde ges i @sannolikhetsområde.\n"
#~ "\n"
#~ "* Om @sannolikhetsområde utelämnas antas en rektangelfördelad "
#~ "distribution.\n"
#~ "* Om summan av alla värden i @sannolikhetsområde inte är ett returneras "
#~ "felvärdet #NUM!.\n"
#~ "* Om @värdeområde och @sannolikhetsområde inte har samma storlek "
#~ "returneras felvärdet #NUM!.\n"
#~ "* Om @värdeområde eller @sannolikhetsområde inte är fält returneras "
#~ "felvärdet #VÄRDE!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDDISCRETE(A1:A6) returnerar ett av värdena i fältet A1:A6.\n"
#~ "\n"
#~ "@SEEALSO=RANDBETWEEN,RAND"

#~ msgid ""
#~ "@FUNCTION=RANDEXP\n"
#~ "@SYNTAX=RANDEXP(b)\n"
#~ "@DESCRIPTION=RANDEXP returns a exponentially-distributed random number.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDEXP(0.5).\n"
#~ "\n"
#~ "@SEEALSO=RAND,RANDBETWEEN"
#~ msgstr ""
#~ "@FUNCTION=RANDEXP\n"
#~ "@SYNTAX=RANDEXP(b)\n"
#~ "@DESCRIPTION=RANDEXP returnerar ett exponentialfördelat slumptal.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDEXP(0,5).\n"
#~ "\n"
#~ "@SEEALSO=RAND,RANDBETWEEN"

#~ msgid ""
#~ "@FUNCTION=RANDPOISSON\n"
#~ "@SYNTAX=RANDPOISSON(lambda)\n"
#~ "@DESCRIPTION=RANDPOISSON returns a Poisson-distributed random number.\n"
#~ "\n"
#~ "* If @lambda < 0 RANDPOISSON returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDPOISSON(3).\n"
#~ "\n"
#~ "@SEEALSO=RAND,RANDBETWEEN"
#~ msgstr ""
#~ "@FUNCTION=RANDPOISSON\n"
#~ "@SYNTAX=RANDPOISSON(lambda)\n"
#~ "@DESCRIPTION=RANDPOISSON returnerar ett Poissonfördelat slumptal.\n"
#~ "\n"
#~ "* Om @lambda < 0 returneras felvärdet #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDPOISSON(3).\n"
#~ "\n"
#~ "@SEEALSO=RAND,RANDBETWEEN"

#~ msgid ""
#~ "@FUNCTION=RANDBINOM\n"
#~ "@SYNTAX=RANDBINOM(p,trials)\n"
#~ "@DESCRIPTION=RANDBINOM returns a binomially-distributed random number.\n"
#~ "\n"
#~ "* If @p < 0 or @p > 1 RANDBINOM returns #NUM! error.\n"
#~ "* If @trials < 0 RANDBINOM returns #NUM! error. \n"
#~ "@EXAMPLES=\n"
#~ "RANDBINOM(0.5,2).\n"
#~ "\n"
#~ "@SEEALSO=RAND,RANDBETWEEN"
#~ msgstr ""
#~ "@FUNCTION=RANDBINOM\n"
#~ "@SYNTAX=RANDBINOM(p;försök)\n"
#~ "@DESCRIPTION=RANDBINOM returnerar ett binomialfördelat slumptal.\n"
#~ "\n"
#~ "* Om @p < 0 eller @p > 1 returnerar RANDBINOM felvärdet #NUM!.\n"
#~ "* Om @försök < 0 returnerar RANDBINOM felvärdet #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDBINOM(0,5;2).\n"
#~ "\n"
#~ "@SEEALSO=RAND,RANDBETWEEN"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=RANDBETWEEN\n"
#~ "@SYNTAX=RANDBETWEEN(bottom,top)\n"
#~ "@DESCRIPTION=RANDBETWEEN function returns a random integer number between "
#~ "and including @bottom and @top.\n"
#~ "\n"
#~ "* If @bottom is non-integer, it is rounded up.\n"
#~ "* If @top is non-integer, it is rounded down.\n"
#~ "* If @bottom > @top, RANDBETWEEN returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDBETWEEN(3,7).\n"
#~ "\n"
#~ "@SEEALSO=RAND,RANDUNIFORM"
#~ msgstr ""
#~ "@FUNCTION=RANDBETWEEN\n"
#~ "@SYNTAX=RANDBETWEEN(lägst;högst)\n"
#~ "@DESCRIPTION=RANDBETWEEN returnerar ett slumpheltal mellan och inklusive "
#~ "@lägst och @högst.\n"
#~ "\n"
#~ "* Om @lägst eller @högst inte är heltal, trunkeras de.\n"
#~ "* Om @lägst > @högst, returnerar RANDBETWEEN felvärdet #NUM!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDBETWEEN(3;7).\n"
#~ "\n"
#~ "@SEEALSO=RAND,RANDUNIFORM"

#~ msgid ""
#~ "@FUNCTION=RANDNEGBINOM\n"
#~ "@SYNTAX=RANDNEGBINOM(p,failures)\n"
#~ "@DESCRIPTION=RANDNEGBINOM returns a negative binomially-distributed "
#~ "random number.\n"
#~ "\n"
#~ "* If @p < 0 or @p > 1, RANDNEGBINOM returns #NUM! error.\n"
#~ "* If @failures < 1, RANDNEGBINOM returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDNEGBINOM(0.5,2).\n"
#~ "\n"
#~ "@SEEALSO=RAND,RANDBETWEEN"
#~ msgstr ""
#~ "@FUNCTION=RANDNEGBINOM\n"
#~ "@SYNTAX=RANDNEGBINOM(p;misslyckanden)\n"
#~ "@DESCRIPTION=RANDNEGBINOM returnerar ett negativt binomialfördelat "
#~ "slumptal.\n"
#~ "\n"
#~ "* Om @p < 0 eller @p > 1, returnerar RANDNEGBINOM felvärdet #NUM!.\n"
#~ "* Om @misslyckanden < 1, returnerar RANDNEGBINOM felvärdet #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDNEGBINOM(0,5;2).\n"
#~ "\n"
#~ "@SEEALSO=RAND,RANDBETWEEN"

#~ msgid ""
#~ "@FUNCTION=RANDBERNOULLI\n"
#~ "@SYNTAX=RANDBERNOULLI(p)\n"
#~ "@DESCRIPTION=RANDBERNOULLI returns a Bernoulli-distributed random "
#~ "number.\n"
#~ "\n"
#~ "* If @p < 0 or @p > 1 RANDBERNOULLI returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDBERNOULLI(0.5).\n"
#~ "\n"
#~ "@SEEALSO=RAND,RANDBETWEEN"
#~ msgstr ""
#~ "@FUNCTION=RANDBERNOULLI\n"
#~ "@SYNTAX=RANDBERNOULLI(p)\n"
#~ "@DESCRIPTION=RANDBERNOULLI returnerar ett Bernoullifördelat slumptal.\n"
#~ "\n"
#~ "* Om @p < 0 eller @p > 1 returnerar RANDBERNOULLI felvärdet #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDBERNOULLI(0,5).\n"
#~ "\n"
#~ "@SEEALSO=RAND,RANDBETWEEN"

#~ msgid ""
#~ "@FUNCTION=RANDNORM\n"
#~ "@SYNTAX=RANDNORM(mean,stdev)\n"
#~ "@DESCRIPTION=RANDNORM returns a normal-distributed random number.\n"
#~ "\n"
#~ "* If @stdev < 0 RANDNORM returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDNORM(0,1).\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=RANDNORM\n"
#~ "@SYNTAX=RANDNORM(medelvärde;stdav)\n"
#~ "@DESCRIPTION=RANDNORM returnerar ett normalfördelat slumptal.\n"
#~ "\n"
#~ "* Om @stdav < 0 returnerar RANDNORM felvärdet #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDNORM(0;1).\n"
#~ "\n"
#~ "@SEEALSO=RAND"

#~ msgid ""
#~ "@FUNCTION=RANDCAUCHY\n"
#~ "@SYNTAX=RANDCAUCHY(a)\n"
#~ "@DESCRIPTION=RANDCAUCHY returns a Cauchy-distributed random number with "
#~ "scale parameter a. The Cauchy distribution is also known as the Lorentz "
#~ "distribution.\n"
#~ "\n"
#~ "* If @a < 0 RANDCAUCHY returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDCAUCHY(1).\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=RANDCAUCHY\n"
#~ "@SYNTAX=RANDCAUCHY(a)\n"
#~ "@DESCRIPTION=RANDCAUCHY returnerar ett cauchy-fördelat slumptal med "
#~ "skalparametern a. Cauchy-distributionen är också känd som Lorenz-"
#~ "distributionen.\n"
#~ "\n"
#~ "* Om @a < 0 returnerar RANDCAUCHY felvärdet #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDCAUCHY(1).\n"
#~ "\n"
#~ "@SEEALSO=RAND"

#~ msgid ""
#~ "@FUNCTION=RANDLOGNORM\n"
#~ "@SYNTAX=RANDLOGNORM(zeta,sigma)\n"
#~ "@DESCRIPTION=RANDLOGNORM returns a lognormal-distributed random number.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDLOGNORM(1,2).\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=RANDLOGNORM\n"
#~ "@SYNTAX=RANDLOGNORM(zeta;sigma)\n"
#~ "@DESCRIPTION=RANDLOGNORM returnerar ett lognormalfördelat slumptal.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDLOGNORM(1;2).\n"
#~ "\n"
#~ "@SEEALSO=RAND"

#~ msgid ""
#~ "@FUNCTION=RANDWEIBULL\n"
#~ "@SYNTAX=RANDWEIBULL(a,b)\n"
#~ "@DESCRIPTION=RANDWEIBULL returns a Weibull-distributed random number.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDWEIBULL(1,2).\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=RANDWEIBULL\n"
#~ "@SYNTAX=RANDWEIBULL(a;b)\n"
#~ "@DESCRIPTION=RANDWEIBULL returnerar ett Weibull-fördelat slumptal.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDWEIBULL(1;2).\n"
#~ "\n"
#~ "@SEEALSO=RAND"

#~ msgid ""
#~ "@FUNCTION=RANDLAPLACE\n"
#~ "@SYNTAX=RANDLAPLACE(a)\n"
#~ "@DESCRIPTION=RANDLAPLACE returns a Laplace-distributed random number. "
#~ "Laplace distribution is also known as two-sided exponential probability "
#~ "distribution.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDLAPLACE(1).\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=RANDLAPLACE\n"
#~ "@SYNTAX=RANDLAPLACE(a)\n"
#~ "@DESCRIPTION=RANDLAPLACE returnerar ett Laplace-fördelat slumptal.\n"
#~ "Laplace-distributionen är också känd som en tvåsidig exponentiell "
#~ "sannolikhetsfunktion.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDLAPLACE(1).\n"
#~ "\n"
#~ "@SEEALSO=RAND"

#~ msgid ""
#~ "@FUNCTION=RANDRAYLEIGH\n"
#~ "@SYNTAX=RANDRAYLEIGH(sigma)\n"
#~ "@DESCRIPTION=RANDRAYLEIGH returns a Rayleigh-distributed random number.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDRAYLEIGH(1).\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=RANDRAYLEIGH\n"
#~ "@SYNTAX=RANDRAYLEIGH(sigma)\n"
#~ "@DESCRIPTION=RANDRAYLEIGH returnerar ett Rayleigh-fördelat slumptal.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDRAYLEIGH(1).\n"
#~ "\n"
#~ "@SEEALSO=RAND"

#~ msgid ""
#~ "@FUNCTION=RANDRAYLEIGHTAIL\n"
#~ "@SYNTAX=RANDRAYLEIGHTAIL(a,sigma)\n"
#~ "@DESCRIPTION=RANDRAYLEIGHTAIL returns  a random variate from the tail of "
#~ "the Rayleigh distribution with scale parameter sigma and a lower limit of "
#~ "a. The distribution is,\n"
#~ "\n"
#~ "\tp(x) dx = {x over sigma^2} exp ((a^2 - x^2) /(2 sigma^2)) dx,\n"
#~ "\n"
#~ "for x > a.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDRAYLEIGHTAIL(0.3,1).\n"
#~ "\n"
#~ "@SEEALSO=RAND,RANDRAYLEIGH"
#~ msgstr ""
#~ "@FUNCTION=RANDRAYLEIGHTAIL\n"
#~ "@SYNTAX=RANDRAYLEIGHTAIL(a;sigma)\n"
#~ "@DESCRIPTION=RANDRAYLEIGHTAIL returnerar ett slumpvariat från svansen på "
#~ "Rayleigh-fördelningen med skalparametrar sigma och en undre gräns a. "
#~ "Fördelningen är\n"
#~ "\n"
#~ "\tp(x) dx = {x over sigma²} exp ((a² - x²) /(2 sigma²)) dx, \n"
#~ "\n"
#~ "för x > a. \n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDRAYLEIGHTAIL(0,3;1).\n"
#~ "\n"
#~ "@SEEALSO=RAND,RANDRAYLEIGH"

#~ msgid ""
#~ "@FUNCTION=RANDGAMMA\n"
#~ "@SYNTAX=RANDGAMMA(a,b)\n"
#~ "@DESCRIPTION=RANDGAMMA returns a Gamma-distributed random number.\n"
#~ "\n"
#~ "* If @a <= 0 RANDGAMMA returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDGAMMA(1,2).\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=RANDGAMMA\n"
#~ "@SYNTAX=RANDGAMMA(a;b)\n"
#~ "@DESCRIPTION=RANDGAMMA returnerar ett gammafördelat slumptal.\n"
#~ "\n"
#~ "* Om @a <= 0 returnerar RANDGAMMA felvärdet #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDGAMMA(1;2).\n"
#~ "\n"
#~ "@SEEALSO=RAND"

#~ msgid ""
#~ "@FUNCTION=RANDPARETO\n"
#~ "@SYNTAX=RANDPARETO(a,b)\n"
#~ "@DESCRIPTION=RANDPARETO returns a Pareto-distributed random number.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDPARETO(1,2).\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=RANDPARETO\n"
#~ "@SYNTAX=RANDPARETO(a;b)\n"
#~ "@DESCRIPTION=RANDPARETO returnerar ett Pareto-fördelat slumptal.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDPARETO(1;2).\n"
#~ "\n"
#~ "@SEEALSO=RAND"

#~ msgid ""
#~ "@FUNCTION=RANDFDIST\n"
#~ "@SYNTAX=RANDFDIST(nu1,nu2)\n"
#~ "@DESCRIPTION=RANDFDIST returns a F-distributed random number.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDFDIST(1,2).\n"
#~ "\n"
#~ "@SEEALSO=RAND,RANDGAMMA"
#~ msgstr ""
#~ "@FUNCTION=RANDFDIST\n"
#~ "@SYNTAX=RANDFDIST(nu1;nu2)\n"
#~ "@DESCRIPTION=RANDFDIST returnerar ett F-fördelat slumptal.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDFDIST(1;2).\n"
#~ "\n"
#~ "@SEEALSO=RAND,RANDGAMMA"

#~ msgid ""
#~ "@FUNCTION=RANDBETA\n"
#~ "@SYNTAX=RANDBETA(a,b)\n"
#~ "@DESCRIPTION=RANDBETA returns a Beta-distributed random number.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDBETA(1,2).\n"
#~ "\n"
#~ "@SEEALSO=RAND,RANDGAMMA"
#~ msgstr ""
#~ "@FUNCTION=RANDBETA\n"
#~ "@SYNTAX=RANDBETA(a;b)\n"
#~ "@DESCRIPTION=RANDBETA returnerar ett betafördelat slumptal.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDBETA(1;2).\n"
#~ "\n"
#~ "@SEEALSO=RAND,RANDGAMMA"

#~ msgid ""
#~ "@FUNCTION=RANDLOGISTIC\n"
#~ "@SYNTAX=RANDLOGISTIC(a)\n"
#~ "@DESCRIPTION=RANDLOGISTIC returns a logistic-distributed random number.  "
#~ "The distribution function is,\n"
#~ "\n"
#~ "\tp(x) dx = { exp(-x/a) over a (1 + exp(-x/a))^2 } dx for -infty < x < "
#~ "+infty.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDLOGISTIC(1).\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=RANDLOGISTIC\n"
#~ "@SYNTAX=RANDLOGISTIC(a)\n"
#~ "@DESCRIPTION=RANDLOGISTIC returnerar ett logistikfördelat slumptal. "
#~ "Distributionsfunktionen är\n"
#~ "\n"
#~ "\tp(x) dx = { exp(-x/a) över ett (1 + exp(-x/a))² } dx för -oändl < x < "
#~ "+oändl.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDLOGISTIC(1).\n"
#~ "\n"
#~ "@SEEALSO=RAND"

#~ msgid ""
#~ "@FUNCTION=RANDGEOM\n"
#~ "@SYNTAX=RANDGEOM(p)\n"
#~ "@DESCRIPTION=RANDGEOM returns a geometric-distributed random number. The "
#~ "number of independent trials with probability @p until the first success. "
#~ "The probability distribution for geometric variates is, \n"
#~ "\n"
#~ "\tp(k) =  p (1-p)^(k-1), for k >= 1.\n"
#~ "\n"
#~ "* If @p < 0 or @p > 1 RANDGEOM returns #NUM! error. \n"
#~ "@EXAMPLES=\n"
#~ "RANDGEOM(0.4).\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=RANDGEOM\n"
#~ "@SYNTAX=RANDGEOM(p)\n"
#~ "@DESCRIPTION=RANDGEOM returnerar ett geometriskt fördelat slumptal. "
#~ "Antalet oberoende försök med sannolikheten @p till första lyckade försök. "
#~ "Sannolikhetsdistributionen för geometriska varianser är\n"
#~ "\n"
#~ "\tp(k) =  p (1-p)^(k-1), för k >= 1. \n"
#~ "\n"
#~ "* Om @p < 0 eller @p > 1 returnerar RANDGEOM felvärdet #NUM!.\n"
#~ "@EXAMPLES=\n"
#~ "RANDGEOM(0,4).\n"
#~ "\n"
#~ "@SEEALSO=RAND"

#~ msgid ""
#~ "@FUNCTION=RANDHYPERG\n"
#~ "@SYNTAX=RANDHYPERG(n1,n2,t)\n"
#~ "@DESCRIPTION=RANDHYPERG returns a hypergeometric-distributed random "
#~ "number. The probability distribution for hypergeometric random variates "
#~ "is,\n"
#~ "\n"
#~ "\tp(k) =  C(n_1,k) C(n_2, t-k) / C(n_1 + n_2,k), \n"
#~ "\n"
#~ "where C(a,b) = a!/(b!(a-b)!). \n"
#~ "\n"
#~ "The domain of k is max(0,t-n_2), ..., max(t,n_1).\n"
#~ "@EXAMPLES=\n"
#~ "RANDHYPERG(21,1,9).\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=RANDHYPERG\n"
#~ "@SYNTAX=RANDHYPERG(n1;n2;t)\n"
#~ "@DESCRIPTION=RANDHYPERG returnerar ett hypergeometriskt distribuerat "
#~ "slumptal. Sannolikhetsdistributionen för hypergeometriska slumptal är\n"
#~ "\n"
#~ "\tp(k) =  C(n_1,k) C(n_2, t-k) / C(n_1 + n_2,k),\n"
#~ "\n"
#~ "där C(a,b) = a!/(b!(a-b)!). \n"
#~ "\n"
#~ "Domänen för k är max(0,t-n_2), ..., max(t,n_1).\n"
#~ "@EXAMPLES=\n"
#~ "RANDHYPERG(21;1;9).\n"
#~ "\n"
#~ "@SEEALSO=RAND"

#~ msgid ""
#~ "@FUNCTION=RANDLOG\n"
#~ "@SYNTAX=RANDLOG(p)\n"
#~ "@DESCRIPTION=RANDLOG returns a logarithmic-distributed random number.\n"
#~ "\n"
#~ "* If @p < 0 or @p > 1 RANDLOG returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDLOG(0.72).\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=RANDLOG\n"
#~ "@SYNTAX=RANDLOG(p)\n"
#~ "@DESCRIPTION=RANDLOG returnerar ett logaritmfördelat slumptal.\n"
#~ "\n"
#~ "* Om @p < 0 eller @p > 1 returnerar RANDLOG felvärdet #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDLOG(0,72).\n"
#~ "\n"
#~ "@SEEALSO=RAND"

#~ msgid ""
#~ "@FUNCTION=RANDCHISQ\n"
#~ "@SYNTAX=RANDCHISQ(nu)\n"
#~ "@DESCRIPTION=RANDCHISQ returns a Chi-Square-distributed random number.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDCHISQ(0.5).\n"
#~ "\n"
#~ "@SEEALSO=RAND,RANDGAMMA"
#~ msgstr ""
#~ "@FUNCTION=RANDCHISQ\n"
#~ "@SYNTAX=RANDCHISQ(nu)\n"
#~ "@DESCRIPTION=RANDCHISQ returnerar ett Chi-rektangelfördelat slumptal.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDCHISQ(0,5).\n"
#~ "\n"
#~ "@SEEALSO=RAND,RANDGAMMA"

#~ msgid ""
#~ "@FUNCTION=RANDTDIST\n"
#~ "@SYNTAX=RANDTDIST(nu)\n"
#~ "@DESCRIPTION=RANDTDIST returns a T-distributed random number.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDTDIST(0.5).\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=RANDTDIST\n"
#~ "@SYNTAX=RANDTDIST(nu)\n"
#~ "@DESCRIPTION=RANDTDIST returnerar ett T-fördelat slumptal.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDTDIST(0,5).\n"
#~ "\n"
#~ "@SEEALSO=RAND"

#~ msgid ""
#~ "@FUNCTION=RANDGUMBEL\n"
#~ "@SYNTAX=RANDGUMBEL(a,b[,type])\n"
#~ "@DESCRIPTION=RANDGUMBEL returns a Type I or Type II Gumbel-distributed "
#~ "random number. @type is either 1 or 2 and specifies the type of the "
#~ "distribution (Type I or Type II).\n"
#~ "\n"
#~ "* If @type is neither 1 nor 2, RANDGUMBEL returns #NUM! error.\n"
#~ "* If @type is omitted, Type I is assumed.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDGUMBEL(0.5,1,2).\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=RANDGUMBEL\n"
#~ "@SYNTAX=RANDGUMBEL(a;b[;typ])\n"
#~ "@DESCRIPTION=RANDGUMBEL returnerar ett Gumbelfördelat slumptal av typ I "
#~ "eller typ II. @typ är antingen 1 eller 2 och anger typen av fördelning "
#~ "(typ I eller typ II).\n"
#~ "\n"
#~ "* Om @typ är vare sig 1 eller 2 returnerar RANDGUMBEL felvärdet #NUM!.\n"
#~ "* Om @typ utelämnas antas typ 1.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDGUMBEL(0,5;1;2).\n"
#~ "\n"
#~ "@SEEALSO=RAND"

#~ msgid ""
#~ "@FUNCTION=RANDLEVY\n"
#~ "@SYNTAX=RANDLEVY(c,alpha[,beta])\n"
#~ "@DESCRIPTION=RANDLEVY returns a Levy-distributed random number. If @beta "
#~ "is omitted, it is assumed to be 0.\n"
#~ "\n"
#~ "* For @alpha = 1, @beta=0, we get the Lorentz distribution.\n"
#~ "* For @alpha = 2, @beta=0, we get the normal distribution.\n"
#~ "\n"
#~ "* If @alpha <= 0 or @alpha > 2, RANDLEVY returns #NUM! error.\n"
#~ "* If @beta < -1 or @beta > 1, RANDLEVY returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDLEVY(0.5,0.1,1).\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=RANDLEVY\n"
#~ "@SYNTAX=RANDLEVY(c;alfa[;beta])\n"
#~ "@DESCRIPTION=RANDLEVY returnerar ett Levy-fördelat slumptal. Om @beta "
#~ "utelämnas antas det vara 0.\n"
#~ "\n"
#~ "* Med @alfa = 1, @beta=0, får vi Lorentz-fördelningen.\n"
#~ "* Med @alfa = 2, @beta=0, får vi normalfördelningen. \n"
#~ "\n"
#~ "* Om @alfa <= 0 eller @alfa > 2 returnerar RANDLEVY felvärdet #NUM!.\n"
#~ "* Om @beta < -1 eller @beta > 1 returnerar RANDLEVY felvärdet #NUM!. \n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDLEVY(0,5;0,1;1).\n"
#~ "\n"
#~ "@SEEALSO=RAND"

#~ msgid ""
#~ "@FUNCTION=RANDEXPPOW\n"
#~ "@SYNTAX=RANDEXPPOW(a,b)\n"
#~ "@DESCRIPTION=RANDEXPPOW returns a random variate from the exponential "
#~ "power distribution with scale parameter @a and exponent @b. The "
#~ "distribution is,\n"
#~ "\n"
#~ "\tp(x) dx = {1 over 2 a Gamma(1+1/b)} exp(-|x/a|^b) dx, for x >= 0.\n"
#~ "\n"
#~ "* For @b = 1 this reduces to the Laplace distribution.\n"
#~ "* For @b = 2 it has the same form as a normal distribution with sigma = a/"
#~ "sqrt(2).\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDEXPPOW(0.5,0.1).\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=RANDEXPPOW\n"
#~ "@SYNTAX=RANDEXPPOW(a;b)\n"
#~ "@DESCRIPTION=RANDEXPPOW returnerar ett slumpvariat för "
#~ "exponentialfördelningen med skalparameter @a och exponenten @b. "
#~ "Fördelningen är\n"
#~ "\n"
#~ "\tp(x) dx = {1 över 2 a Gamma(1+1/b)} exp(-|x/a|^b) dx, för x >= 0.\n"
#~ "\n"
#~ "* För @b = 1 reduceras detta till Laplace-fördelningen.\n"
#~ "* För @b = 2 har det samma form som en normalfördelning, men med sigma = "
#~ "a/sqrt{2}. \n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDEXPPOW(0,5;0,1).\n"
#~ "\n"
#~ "@SEEALSO=RAND"

#~ msgid ""
#~ "@FUNCTION=RANDLANDAU\n"
#~ "@SYNTAX=RANDLANDAU()\n"
#~ "@DESCRIPTION=RANDLANDAU returns a random variate from the Landau "
#~ "distribution. The probability distribution for Landau random variates is "
#~ "defined analytically by the complex integral,\n"
#~ "\n"
#~ "\tp(x) = (1/(2 pi i)) int_{c-i infty}^{c+i infty} ds exp(s log(s) + x "
#~ "s).\n"
#~ "\n"
#~ "For numerical purposes it is more convenient to use the following "
#~ "equivalent form of the integral,\n"
#~ "\n"
#~ "\tp(x) = (1/pi) int_0^ infty dt exp(-t log(t) - x t) sin(pi t).\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDLANDAU().\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=RANDLANDAU\n"
#~ "@SYNTAX=RANDLANDAU()\n"
#~ "@DESCRIPTION=RANDLANDAU returnerar ett slumptal från Landaufördelningen. "
#~ "Sannolikhetsfördelningen för Landauslumptal är analytiskt definierat av "
#~ "den komplexa integralen\n"
#~ "\n"
#~ "\tp(x) = (1/(2 pi i)) int_{c-i oändl}^{c+i oändl} ds exp(s log(s) + x "
#~ "s).\n"
#~ "\n"
#~ "Av numeriska skäl är det mer bekvämt att använda följande ekvivalenta "
#~ "form av integralen:\n"
#~ "\n"
#~ "\tp(x) = (1/pi) int_0^ oändl dt exp(-t log(t) - x t) sin(pi t).\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDLANDAU().\n"
#~ "\n"
#~ "@SEEALSO=RAND"

#~ msgid ""
#~ "@FUNCTION=RANDNORMTAIL\n"
#~ "@SYNTAX=RANDNORMTAIL(a,sigma)\n"
#~ "@DESCRIPTION=RANDNORMTAIL returns a random variates from the upper tail "
#~ "of a normal distribution with standard deviation @sigma. The values "
#~ "returned are larger than the lower limit @a, which must be positive. The "
#~ "method is based on Marsaglia's famous rectangle-wedge-tail algorithm (Ann "
#~ "Math Stat 32, 894-899 (1961)), with this aspect explained in Knuth, v2, "
#~ "3rd ed, p139, 586 (exercise 11).\n"
#~ "\n"
#~ "The probability distribution for normal tail random variates is,\n"
#~ "\n"
#~ "\tp(x) dx = {1 over N(a;sigma)} exp (- x^2/(2 sigma^2)) dx,\n"
#~ "\n"
#~ "for x > a where N(a;sigma) is the normalization constant, N(a;sigma) = "
#~ "(1/2) erfc(a / sqrt(2 sigma^2)).\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDNORMTAIL(0.5,0.1).\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=RANDNORMTAIL\n"
#~ "@SYNTAX=RANDNORMTAIL(a;sigma)\n"
#~ "@DESCRIPTION=RANDNORMTAIL returnerar ett slumptal från den övre svansen "
#~ "av en normalfördelning med standardavvikelsen @sigma. De returnerade "
#~ "värdena är större än den lägre gränsen @a, som måste vara positiv. "
#~ "Metoden baseras på Marsaglias berömda rektangel-kil-svans-algoritm (Ann "
#~ "Math Stat 32, 894-899 (1961)), med detta förklarat i Knuth, v2, tredje "
#~ "utgåvan, s. 139, 586 (övning 11).\n"
#~ "\n"
#~ "Sannolikhetsfördelningen för gaussiska svansslumptal är\n"
#~ "\n"
#~ "\tp(x) dx = {1 över N (a;sigma)} exp (- x²/(2 sigma²)) dx,\n"
#~ "\n"
#~ "för x > a där N(a;sigma) är normaliseringskonstanten, N(a;sigma) = (1/2) "
#~ "erfc(a / sqrt(2 sigma²)). \n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDNORMTAIL(0,5;0,1).\n"
#~ "\n"
#~ "@SEEALSO=RAND"

#~ msgid ""
#~ "@FUNCTION=VARP\n"
#~ "@SYNTAX=VARP(b1, b2, ...)\n"
#~ "@DESCRIPTION=VARP calculates the variance of an entire population.\n"
#~ "VARP is also known as the N-variance.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "VARP(A1:A5) equals 94.112.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,DVAR,DVARP,STDEV,VAR"
#~ msgstr ""
#~ "@FUNCTION=VARP\n"
#~ "@SYNTAX=VARP(b1; b2; ...)\n"
#~ "@DESCRIPTION=VARP beräknar variansen hos en hel population.\n"
#~ "* VARP är även känt som N-variansen.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att att cellerna A1; A2; ...; A5 innehåller talen  11,4; 17,3; "
#~ "21,3; 25,9 och 40,1. Då är\n"
#~ "VARP(A1:A5) lika med 94,112.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,DVAR,DVARP,STDEV,VAR"

#~ msgid ""
#~ "@FUNCTION=VAR\n"
#~ "@SYNTAX=VAR(b1, b2, ...)\n"
#~ "@DESCRIPTION=VAR calculates sample variance of the given sample. To get "
#~ "the true variance of a complete population use VARP.\n"
#~ "VAR is also known as the N-1-variance. Under reasonable conditions, it is "
#~ "the maximum-likelihood estimator for the true variance.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "VAR(A1:A5) equals 117.64.\n"
#~ "\n"
#~ "@SEEALSO=VARP,STDEV"
#~ msgstr ""
#~ "@FUNCTION=VAR\n"
#~ "@SYNTAX=VAR(b1; b2; ...)\n"
#~ "@DESCRIPTION=VAR uppskattar variansen hos ett stickprov. För att få den "
#~ "exakta variansen av en komplett population, använd VARP.\n"
#~ "* VAR är även känd som N-1-variansen.  Under normala förhållanden är den "
#~ "en maximum-likelihood-uppskattning for variansen.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel. \n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att cellerna A1; A2; ...; A5 innehåller talen 11,4; 17,3; 21,3; "
#~ "25,9 och 40,1. Då är\n"
#~ "VAR(A1:A5) lika med 117,64.\n"
#~ "\n"
#~ "@SEEALSO=VARP,STDEV"

#~ msgid ""
#~ "@FUNCTION=STDEV\n"
#~ "@SYNTAX=STDEV(b1, b2, ...)\n"
#~ "@DESCRIPTION=STDEV returns the sample standard deviation of the given "
#~ "sample.\n"
#~ "To obtain the population standard deviation of a whole population use "
#~ "STDEVP.\n"
#~ "STDEV is also known as the N-1-standard deviation.\n"
#~ "Under reasonable conditions, it is the maximum-likelihood estimator for "
#~ "the true population standard deviation.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "STDEV(A1:A5) equals 10.84619749.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,DSTDEV,DSTDEVP,STDEVA,STDEVPA,VAR"
#~ msgstr ""
#~ "@FUNCTION=STDEV\n"
#~ "@SYNTAX=STDEV(b1; b2; ...)\n"
#~ "@DESCRIPTION=STDEV returnerar standardavvikelsen av det givna "
#~ "stickprovet.\n"
#~ "För att få den exakta standardavvikelsen av en komplett population, "
#~ "använd STDEVP.\n"
#~ "* STDEV är även känd som N-1-standardavvikelsen.\n"
#~ "Under normala förhållanden är den en maximum-likelihood-uppskattning for "
#~ "standardavvikelsen.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel. \n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att cellerna A1; A2; ...; A5 innehåller talen 11,4; 17,3; 21,3; "
#~ "25,9 och 40,1. Då är\n"
#~ "STDEV(A1:A5) lika med 10,84619749.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,DSTDEV,DSTDEVP,STDEVA,STDEVPA,VAR"

#~ msgid ""
#~ "@FUNCTION=STDEVP\n"
#~ "@SYNTAX=STDEVP(b1, b2, ...)\n"
#~ "@DESCRIPTION=STDEVP returns the population standard deviation of the "
#~ "given population. \n"
#~ "This is also known as the N-standard deviation\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "STDEVP(A1:A5) equals 9.701133954.\n"
#~ "\n"
#~ "@SEEALSO=STDEV,STDEVA,STDEVPA"
#~ msgstr ""
#~ "@FUNCTION=STDEVP\n"
#~ "@SYNTAX=STDEVP(b1; b2; ...)\n"
#~ "@DESCRIPTION=STDEVP beräknar standardavvikelsen av en population.\n"
#~ "Detta är även känt som N-standardavvikelsen\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att cellerna A1; A2; ...; A5 innehåller talen 11,4; 17,3; 21,3; "
#~ "25,9 och 40,1. Då är\n"
#~ "STDEVP(A1:A5) lika med 9,701133954.\n"
#~ "\n"
#~ "@SEEALSO=STDEV,STDEVA,STDEVPA"

#~ msgid ""
#~ "@FUNCTION=RANK\n"
#~ "@SYNTAX=RANK(x,ref[,order])\n"
#~ "@DESCRIPTION=RANK returns the rank of a number in a list of numbers.  @x "
#~ "is the number whose rank you want to find, @ref is the list of numbers, "
#~ "and @order specifies how to rank numbers.  If @order is 0, numbers are "
#~ "ranked in descending order, otherwise numbers are ranked in ascending "
#~ "order.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "RANK(17.3,A1:A5) equals 4.\n"
#~ "\n"
#~ "@SEEALSO=PERCENTRANK"
#~ msgstr ""
#~ "@FUNCTION=RANK\n"
#~ "@SYNTAX=RANK(x;ref[;ordning])\n"
#~ "@DESCRIPTION=RANK beräknar rangen av ett tal i en lista av tal.  @x är "
#~ "talets vars rang efterfrågas, @ref är listan av tal, och @ordning anger "
#~ "hur talen rangordnas. Om @ordning är 0, ordnas talen i sjunkade ordning, "
#~ "annars i stigande.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att cellerna A1; A2; ...; A5 innehåller talen 11,4; 17,3; 21,3; "
#~ "25,9 och 40,1. Då är\n"
#~ "RANK(17,3;A1:A5) lika med 4.\n"
#~ "\n"
#~ "@SEEALSO=PERCENTRANK"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=TRIMMEAN\n"
#~ "@SYNTAX=TRIMMEAN(ref,fraction)\n"
#~ "@DESCRIPTION=TRIMMEAN returns the mean of the interior of a data set. "
#~ "@ref is the list of numbers whose mean you want to calculate and "
#~ "@fraction is the fraction of the data set excluded from the mean. For "
#~ "example, if @fraction=0.2 and the data set contains 40 numbers, 8 numbers "
#~ "are trimmed from the data set (40 x 0.2): the 4 largest and the 4 "
#~ "smallest.  To avoid a bias, the number of points to be excluded is always "
#~ "rounded down to the nearest even number.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "TRIMMEAN(A1:A5,0.2) equals 23.2.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,GEOMEAN,HARMEAN,MEDIAN,MODE"
#~ msgstr ""
#~ "@FUNCTION=TRIMMEAN\n"
#~ "@SYNTAX=TRIMMEAN(ref;del)\n"
#~ "@DESCRIPTION=TRIMMEAN returnerar medelvärdet av interiören av en "
#~ "datamängd. @ref är listan med tal vars medelvärde du vill beräkna och "
#~ "@del är delen av datamängden som du vill utelämna från medelvärdet. Om "
#~ "@del=0,2 och datamängden innehåller 40 tal kommer till exempel 8 tal att "
#~ "tas bort från datamängden (40 × 0,2), 4 från det översta och 4 från det "
#~ "nedersta av mängden.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att cellerna A1; A2; ...; A5 innehåller talen 11,4; 17,3; 21,3; "
#~ "25,9 och 40,1. Då är\n"
#~ "TRIMMEAN(A1:A5;0,2) lika med 23,2.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,GEOMEAN,HARMEAN,MEDIAN,MODE"

#~ msgid ""
#~ "@FUNCTION=COVAR\n"
#~ "@SYNTAX=COVAR(array1,array2)\n"
#~ "@DESCRIPTION=COVAR returns the covariance of two data sets.\n"
#~ "\n"
#~ "* Strings and empty cells are simply ignored.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1, and the cells B1, B2, ... B5 23.2, 25.8, 29.9, "
#~ "33.5, and 42.7.  Then\n"
#~ "COVAR(A1:A5,B1:B5) equals 65.858.\n"
#~ "\n"
#~ "@SEEALSO=CORREL,FISHER,FISHERINV"
#~ msgstr ""
#~ "@FUNCTION=COVAR\n"
#~ "@SYNTAX=COVAR(fält1;fält2)\n"
#~ "@DESCRIPTION=COVAR beräknar kovariansen för två datamängder.\n"
#~ "\n"
#~ "* Strängar och tomma celler ignoreras.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att cellerna A1; A2; ...; A5 innehåller talen 11,4; 17,3; 21,3; "
#~ "25,9 och 40,1, samt att cellerna B1; B2; ... B5 innehåller 23,2; 25,8; "
#~ "29,9; 33,5 och 42,7. Då är\n"
#~ "COVAR(A1:A5;B1:B5) lika med 65,858.\n"
#~ "\n"
#~ "@SEEALSO=CORREL,FISHER,FISHERINV"

#~ msgid ""
#~ "@FUNCTION=CORREL\n"
#~ "@SYNTAX=CORREL(array1,array2)\n"
#~ "@DESCRIPTION=CORREL returns the correlation coefficient of two data "
#~ "sets.\n"
#~ "\n"
#~ "* Strings and empty cells are simply ignored.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1, and the cells B1, B2, ... B5 23.2, 25.8, 29.9, "
#~ "33.5, and 42.7.  Then\n"
#~ "CORREL(A1:A5,B1:B5) equals 0.996124788.\n"
#~ "\n"
#~ "@SEEALSO=COVAR,FISHER,FISHERINV"
#~ msgstr ""
#~ "@FUNCTION=CORREL\n"
#~ "@SYNTAX=CORREL(fält1;fält2)\n"
#~ "@DESCRIPTION=CORREL beräknar korrelationskoefficienten för två "
#~ "datamängder.\n"
#~ "\n"
#~ "* Strängar och tomma celler ignoreras.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att cellerna A1; A2; ...; A5 innehåller talen 11,4; 17,3; 21,3; "
#~ "25,9 och 40,1, samt att cellerna B1; B2; ... B5 innehåller 23,2; 25,8; "
#~ "29,9; 33,5 och 42,7. Då är\n"
#~ "CORREL(A1:A5;B1:B5) lika med 0,996124788.\n"
#~ "\n"
#~ "@SEEALSO=COVAR,FISHER,FISHERINV"

#~ msgid ""
#~ "@FUNCTION=NEGBINOMDIST\n"
#~ "@SYNTAX=NEGBINOMDIST(f,t,p)\n"
#~ "@DESCRIPTION=NEGBINOMDIST function returns the negative binomial "
#~ "distribution. @f is the number of failures, @t is the threshold number of "
#~ "successes, and @p is the probability of a success.\n"
#~ "\n"
#~ "* If @f or @t is a non-integer it is truncated.\n"
#~ "* If (@f + @t -1) <= 0 NEGBINOMDIST returns #NUM! error.\n"
#~ "* If @p < 0 or @p > 1 NEGBINOMDIST returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "NEGBINOMDIST(2,5,0.55) equals 0.152872629.\n"
#~ "\n"
#~ "@SEEALSO=BINOMDIST,COMBIN,FACT,HYPGEOMDIST,PERMUT"
#~ msgstr ""
#~ "@FUNCTION=NEGBINOMDIST\n"
#~ "@SYNTAX=NEGBINOMDIST(f;t;p)\n"
#~ "@DESCRIPTION=Funktionen NEGBINOMDIST returnerar den negativa "
#~ "binomialfördelningen. @f är antalet misslyckade försök, @t är "
#~ "tröskelvärdet för antalet lyckade försök, och @p är sannolikheten för ett "
#~ "lyckat försök.\n"
#~ "\n"
#~ "* Om @f eller @t inte är heltal trunkeras de.\n"
#~ "* Om (@f + @t -1) <= 0 returnerar NEGBINOMDIST felvärdet #NUM!.\n"
#~ "* Om @p < 0 eller @p > 1 returnerar NEGBINOMDIST felvärdet #NUM!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "NEGBINOMDIST(2;5;0,55) är lika med 0,152872629.\n"
#~ "\n"
#~ "@SEEALSO=BINOMDIST,COMBIN,FACT,HYPGEOMDIST,PERMUT"

#~ msgid ""
#~ "@FUNCTION=NORMSDIST\n"
#~ "@SYNTAX=NORMSDIST(x)\n"
#~ "@DESCRIPTION=NORMSDIST function returns the standard normal cumulative "
#~ "distribution. @x is the value for which you want the distribution.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "NORMSDIST(2) equals 0.977249868.\n"
#~ "\n"
#~ "@SEEALSO=NORMDIST"
#~ msgstr ""
#~ "@FUNCTION=NORMSDIST\n"
#~ "@SYNTAX=NORMSDIST(x)\n"
#~ "@DESCRIPTION=Funktionen NORMSDIST returnerar normalkumulativa "
#~ "standardfördelningen. @x är värdet för vilket du vill ha fördelningen.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "NORMSDIST(2) är lika med 0,977249868.\n"
#~ "\n"
#~ "@SEEALSO=NORMDIST"

#~ msgid ""
#~ "@FUNCTION=NORMSINV\n"
#~ "@SYNTAX=NORMSINV(p)\n"
#~ "@DESCRIPTION=NORMSINV function returns the inverse of the standard normal "
#~ "cumulative distribution. @p is the given probability corresponding to the "
#~ "normal distribution.\n"
#~ "\n"
#~ "* If @p < 0 or @p > 1 NORMSINV returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "NORMSINV(0.2) equals -0.841621234.\n"
#~ "\n"
#~ "@SEEALSO=NORMDIST,NORMINV,NORMSDIST,STANDARDIZE,ZTEST"
#~ msgstr ""
#~ "@FUNCTION=NORMSINV\n"
#~ "@SYNTAX=NORMSINV(p)\n"
#~ "@DESCRIPTION=Funktionen NORMSINV returnerar inversen av den "
#~ "normalkumulativa standardfördelningen. @p är den givna sannolikheten som "
#~ "motsvarar normalfördelningen.\n"
#~ "\n"
#~ "* Om @p < 0 eller @p > 1 returnerar NORMSINV felvärdet #NUM!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "NORMSINV(0,2) är lika med -0,841621234.\n"
#~ "\n"
#~ "@SEEALSO=NORMDIST,NORMINV,NORMSDIST,STANDARDIZE,ZTEST"

#~ msgid ""
#~ "@FUNCTION=LOGNORMDIST\n"
#~ "@SYNTAX=LOGNORMDIST(x,mean,stddev)\n"
#~ "@DESCRIPTION=LOGNORMDIST function returns the lognormal distribution. @x "
#~ "is the value for which you want the distribution, @mean is the mean of "
#~ "the distribution, and @stddev is the standard deviation of the "
#~ "distribution.\n"
#~ "\n"
#~ "* If @stddev = 0 LOGNORMDIST returns #DIV/0! error.\n"
#~ "* If @x <= 0, @mean < 0 or @stddev < 0 LOGNORMDIST returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LOGNORMDIST(3,1,2) equals 0.519662338.\n"
#~ "\n"
#~ "@SEEALSO=NORMDIST"
#~ msgstr ""
#~ "@FUNCTION=LOGNORMDIST\n"
#~ "@SYNTAX=LOGNORMDIST(x;medel;stdav)\n"
#~ "@DESCRIPTION=Funktionen LOGNORMDIST returnerar lognormfördelningen. @x är "
#~ "punkten för vilken fördelningen ska beräknas, @medel är fördelningens "
#~ "väntevärde och @stdav dess standardavvikelse.\n"
#~ "\n"
#~ "* Om @stdav = 0 ger LOGNORMDIST felvärdet #DIV/0!\n"
#~ "* Om @x <= 0, @medel < 0 eller @stdav < 0 ger LOGNORMDIST felvärdet "
#~ "#NUM!\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LOGNORMDIST(3;1;2) returnerar 0,519662338.\n"
#~ "\n"
#~ "@SEEALSO=NORMDIST"

#~ msgid ""
#~ "@FUNCTION=LOGINV\n"
#~ "@SYNTAX=LOGINV(p,mean,stddev)\n"
#~ "@DESCRIPTION=LOGINV function returns the inverse of the lognormal "
#~ "cumulative distribution. @p is the given probability corresponding to the "
#~ "normal distribution, @mean is the arithmetic mean of the distribution, "
#~ "and @stddev is the standard deviation of the distribution.\n"
#~ "\n"
#~ "* If @p < 0 or @p > 1 or @stddev <= 0 LOGINV returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LOGINV(0.5,2,3) equals 7.389056099.\n"
#~ "\n"
#~ "@SEEALSO=EXP,LN,LOG,LOG10,LOGNORMDIST"
#~ msgstr ""
#~ "@FUNCTION=LOGINV\n"
#~ "@SYNTAX=LOGINV(p;medel;stdav)\n"
#~ "@DESCRIPTION=Funktionen LOGINV returnerar inversen av den kumulativa "
#~ "lognormalfördelningen. @p är den givna sannolikheten som motsvarar "
#~ "normalfördelningen, @medel är det aritmetiska medelvärdet av "
#~ "fördelningen, och @stdav är standardavvikelsen för fördelningen.\n"
#~ "\n"
#~ "* Om @p < 0 eller @p > 1 eller @stdav <= 0 returnerar LOGINV felvärdet "
#~ "#NUM!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LOGINV(0,5;2;3) är lika med 7,389056099.\n"
#~ "\n"
#~ "@SEEALSO=EXP,LN,LOG,LOG10,LOGNORMDIST"

#~ msgid ""
#~ "@FUNCTION=FISHERINV\n"
#~ "@SYNTAX=FISHERINV(x)\n"
#~ "@DESCRIPTION=FISHERINV function returns the inverse of the Fisher "
#~ "transformation at @x.\n"
#~ "\n"
#~ "* If @x is non-number FISHERINV returns #VALUE! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FISHERINV(2) equals 0.96402758.\n"
#~ "\n"
#~ "@SEEALSO=FISHER"
#~ msgstr ""
#~ "@FUNCTION=FISHERINV\n"
#~ "@SYNTAX=FISHERINV(x)\n"
#~ "@DESCRIPTION=Funktionen FISHERINV returnerar inversen av "
#~ "Fishertransformeringen vid @x.\n"
#~ "\n"
#~ "* Om @x inte är ett tal returnerar FISHERINV felvärdet #VÄRDE!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FISHERINV(2) är lika med 0,96402758.\n"
#~ "\n"
#~ "@SEEALSO=FISHER"

#~ msgid ""
#~ "@FUNCTION=MODE\n"
#~ "@SYNTAX=MODE(n1, n2, ...)\n"
#~ "@DESCRIPTION=MODE returns the most common number of the data set. If the "
#~ "data set has many most common numbers MODE returns the first one of "
#~ "them.\n"
#~ "\n"
#~ "* Strings and empty cells are simply ignored.\n"
#~ "* If the data set does not contain any duplicates MODE returns #N/A "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "11.4, 25.9, and 40.1.  Then\n"
#~ "MODE(A1:A5) equals 11.4.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,MEDIAN"
#~ msgstr ""
#~ "@FUNCTION=MODE\n"
#~ "@SYNTAX=MODE(n1; n2; ...)\n"
#~ "@DESCRIPTION=MODE returnerar det vanligast förekommande talet i en serie. "
#~ "Om serien har flera sådana tal ges det första av dem.\n"
#~ "\n"
#~ "* Strängar och tomma celler ignoreras.\n"
#~ "* Om serien inte har några dubletter ger MODE felvärdet #-.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att cellerna A1; A2; ...; A5 innehåller talen 11,4; 17,3; 11,4; "
#~ "25,9 och 40,1. Då är\n"
#~ "MODE(A1:A5) lika med 11,4.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,MEDIAN"

#~ msgid ""
#~ "@FUNCTION=HARMEAN\n"
#~ "@SYNTAX=HARMEAN(b1, b2, ...)\n"
#~ "@DESCRIPTION=HARMEAN returns the harmonic mean of the N data points (that "
#~ "is, N divided by the sum of the inverses of the data points).\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "HARMEAN(A1:A5) equals 19.529814427.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,GEOMEAN,MEDIAN,MODE,TRIMMEAN"
#~ msgstr ""
#~ "@FUNCTION=HARMEAN\n"
#~ "@SYNTAX=HARMEAN(b1; b2; ...)\n"
#~ "@DESCRIPTION=HARMEAN beräknar det harmoniska medelvärdet av de N stycken "
#~ "datapunkterna (det vill säga N delat med summan av inverserna av "
#~ "datapunkterna).\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att cellerna A1; A2; ...; A5 innehåller talen 11,4; 17,3; 21,3; "
#~ "25,9 och 40,1. Då är\n"
#~ "HARMEAN(A1:A5) lika med 19,529814427.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,GEOMEAN,MEDIAN,MODE,TRIMMEAN"

#~ msgid ""
#~ "@FUNCTION=GEOMEAN\n"
#~ "@SYNTAX=GEOMEAN(b1, b2, ...)\n"
#~ "@DESCRIPTION=GEOMEAN returns the geometric mean of the given arguments. "
#~ "This is equal to the Nth root of the product of the terms.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "GEOMEAN(A1:A5) equals 21.279182482.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,HARMEAN,MEDIAN,MODE,TRIMMEAN"
#~ msgstr ""
#~ "@FUNCTION=GEOMEAN\n"
#~ "@SYNTAX=GEOMEAN(b1; b2; ...)\n"
#~ "@DESCRIPTION=GEOMEAN beräknar det geometriska medelvärdet för de givna "
#~ "argumenten; detta är lika med N:te roten av produkten av termerna.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att cellerna A1; A2; ...; A5 innehåller talen 11,4; 17,3; 21,3; "
#~ "25,9 och 40,1. Då är\n"
#~ "GEOMEAN(A1:A5) lika med 21,279182482.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,HARMEAN,MEDIAN,MODE,TRIMMEAN"

#~ msgid ""
#~ "@FUNCTION=COUNT\n"
#~ "@SYNTAX=COUNT(b1, b2, ...)\n"
#~ "@DESCRIPTION=COUNT returns the total number of integer or floating point "
#~ "arguments passed.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "COUNT(A1:A5) equals 5.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE"
#~ msgstr ""
#~ "@FUNCTION=COUNT\n"
#~ "@SYNTAX=COUNT(b1; b2; ...)\n"
#~ "@DESCRIPTION=COUNT returnerar totala antalet heltal eller flyttal som "
#~ "anges som argument.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att cellerna A1; A2; ...; A5 innehåller talen 11,4; 17,3; 21,3; "
#~ "25,9 och 40,1. Då är\n"
#~ "COUNT(A1:A5) lika med 5.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE"

#~ msgid ""
#~ "@FUNCTION=COUNTA\n"
#~ "@SYNTAX=COUNTA(b1, b2, ...)\n"
#~ "@DESCRIPTION=COUNTA returns the number of arguments passed not including "
#~ "empty cells.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers and strings "
#~ "11.4, \"missing\", \"missing\", 25.9, and 40.1.  Then\n"
#~ "COUNTA(A1:A5) equals 5.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,COUNT,DCOUNT,DCOUNTA,PRODUCT,SUM"
#~ msgstr ""
#~ "@FUNCTION=COUNTA\n"
#~ "@SYNTAX=COUNTA(b1; b2; ...)\n"
#~ "@DESCRIPTION=COUNTA returnerar antalet argument som anges, exklusive "
#~ "tomma celler.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att cellerna A1; A2; ...; A5 innehåller talen och strängarna 11,4; "
#~ "\"saknad\"; \"saknad\"; 25,9; och 40,1. Då är\n"
#~ "COUNTA(A1:A5) lika med 5.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,COUNT,DCOUNT,DCOUNTA,PRODUCT,SUM"

#~ msgid ""
#~ "@FUNCTION=AVERAGE\n"
#~ "@SYNTAX=AVERAGE(value1, value2,...)\n"
#~ "@DESCRIPTION=AVERAGE computes the average of all the values and cells "
#~ "referenced in the argument list.  This is equivalent to the sum of the "
#~ "arguments divided by the count of the arguments.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "AVERAGE(A1:A5) equals 23.2.\n"
#~ "\n"
#~ "@SEEALSO=SUM, COUNT"
#~ msgstr ""
#~ "@FUNCTION=AVERAGE\n"
#~ "@SYNTAX=AVERAGE(värde1; värde2;...)\n"
#~ "@DESCRIPTION=AVERAGE beräknar medelvärdet av alla värden och celler "
#~ "refererade till i argumentlistan. Detta är likvärdigt med att summera "
#~ "alla argument och dela med antalet argument.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att cellerna A1; A2; ...; A5 innehåller talen 11,4; 17,3; 21,3; "
#~ "25,9 och 40,1. Då är\n"
#~ "AVERAGE(A1:A5) lika med 23,2.\n"
#~ "\n"
#~ "@SEEALSO=SUM, COUNT"

#~ msgid ""
#~ "@FUNCTION=MIN\n"
#~ "@SYNTAX=MIN(b1, b2, ...)\n"
#~ "@DESCRIPTION=MIN returns the value of the element of the values passed "
#~ "that has the smallest value, with negative numbers considered smaller "
#~ "than positive numbers.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "MIN(A1:A5) equals 11.4.\n"
#~ "\n"
#~ "@SEEALSO=MAX,ABS"
#~ msgstr ""
#~ "@FUNCTION=MIN\n"
#~ "@SYNTAX=MIN(b1; b2; ...)\n"
#~ "@DESCRIPTION=MIN returnerar det värde av argumenten som är det minsta. "
#~ "Negativa tal räknas som mindre än positiva tal.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att cellerna A1; A2; ...; A5 innehåller talen 11,4; 17,3; 21,3; "
#~ "25,9 och 40,1. Då är\n"
#~ "MIN(A1:A5) lika med 11,4.\n"
#~ "\n"
#~ "@SEEALSO=MAX,ABS"

#~ msgid ""
#~ "@FUNCTION=MAX\n"
#~ "@SYNTAX=MAX(b1, b2, ...)\n"
#~ "@DESCRIPTION=MAX returns the value of the element of the values passed "
#~ "that has the largest value, with negative numbers considered smaller than "
#~ "positive numbers.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "MAX(A1:A5) equals 40.1.\n"
#~ "\n"
#~ "@SEEALSO=MIN,ABS"
#~ msgstr ""
#~ "@FUNCTION=MAX\n"
#~ "@SYNTAX=MAX(b1; b2; ...)\n"
#~ "@DESCRIPTION=MAX returnerar det värde av argumenten som är det största. "
#~ "Negativa tal räknas som  mindre än positiva tal.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att cellerna A1; A2; ...; A5 innehåller talen 11,4; 17,3; 21,3; "
#~ "25,9 och 40,1. Då är\n"
#~ "MAX(A1:A5) lika med 40,1.\n"
#~ "\n"
#~ "@SEEALSO=MIN,ABS"

#~ msgid ""
#~ "@FUNCTION=SKEW\n"
#~ "@SYNTAX=SKEW(n1, n2, ...)\n"
#~ "@DESCRIPTION=SKEW returns an unbiased estimate for skewness of a "
#~ "distribution.\n"
#~ "\n"
#~ "Note, that this is only meaningful if the underlying distribution really "
#~ "has a third moment.  The skewness of a symmetric (e.g., normal) "
#~ "distribution is zero.\n"
#~ "\n"
#~ "* Strings and empty cells are simply ignored.\n"
#~ "* If less than three numbers are given, SKEW returns #DIV/0! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "SKEW(A1:A5) equals 0.976798268.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,VAR,SKEWP,KURT"
#~ msgstr ""
#~ "@FUNCTION=SKEW\n"
#~ "@SYNTAX=SKEW(n1; n2; ...)\n"
#~ "@DESCRIPTION=SKEW returnerar en neutral uppskattning av snedfördelningen "
#~ "hos en fördelning.\n"
#~ "\n"
#~ "Observera att detta endast är meningsfullt om den underliggande "
#~ "fördelningen verkligen har ett tredje moment. Snedfördelningen hos en "
#~ "symmetrisk fördelning (t.ex. normalfördelningen) är noll.\n"
#~ "\n"
#~ "* Strängar och tomma celler ignoreras.\n"
#~ "* Om mindre än tre tal anges returnerar SKEW felvärdet #DIV/0!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att cellerna A1; A2; ...; A5 innehåller talen 11,4; 17,3; 21,3; "
#~ "25,9 och 40,1. Då är\n"
#~ "SKEW(A1:A5) lika med 0,976798268.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,VAR,SKEWP,KURT"

#~ msgid ""
#~ "@FUNCTION=SKEWP\n"
#~ "@SYNTAX=SKEWP(n1, n2, ...)\n"
#~ "@DESCRIPTION=SKEWP returns the population skewness of a data set.\n"
#~ "\n"
#~ "* Strings and empty cells are simply ignored.\n"
#~ "* If less than two numbers are given, SKEWP returns #DIV/0! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "SKEWP(A1:A5) equals 0.655256198.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,VARP,SKEW,KURTP"
#~ msgstr ""
#~ "@FUNCTION=SKEWP\n"
#~ "@SYNTAX=SKEWP(n1; n2; ...)\n"
#~ "@DESCRIPTION=SKEWP returnerar en populations snedfördelning i en "
#~ "datamängd.\n"
#~ "\n"
#~ "* Strängar och tomma celler ignoreras.\n"
#~ "* Om färre än två tal anges returnerar SKEWP felvärdet #DIV/0!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att cellerna A1; A2; ...; A5 innehåller talen 11,4; 17,3; 21,3; "
#~ "25,9 och 40,1. Då är\n"
#~ "SKEWP(A1:A5) lika med 0,655256198.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,VARP,SKEW,KURTP"

#~ msgid ""
#~ "@FUNCTION=EXPONDIST\n"
#~ "@SYNTAX=EXPONDIST(x,y,cumulative)\n"
#~ "@DESCRIPTION=EXPONDIST function returns the exponential distribution. If "
#~ "the @cumulative boolean is false it will return:\n"
#~ "\n"
#~ "\t@y * exp (-@y*@x),\n"
#~ "\n"
#~ "otherwise it will return\n"
#~ "\n"
#~ "\t1 - exp (-@y*@x).\n"
#~ "\n"
#~ "* If @x < 0 or @y <= 0 this will return an error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "EXPONDIST(2,4,0) equals 0.001341851.\n"
#~ "\n"
#~ "@SEEALSO=POISSON"
#~ msgstr ""
#~ "@FUNCTION=EXPONDIST\n"
#~ "@SYNTAX=EXPONDIST(x;y;kumulativ)\n"
#~ "@DESCRIPTION=Funktionen EXPONDIST returnerar exponentialfördelningen. Om "
#~ "flaggan @kumulativ är falsk returnerar funktionen\n"
#~ "\n"
#~ "\t@y * exp (-@y*@x), \n"
#~ "\n"
#~ "annars fås\n"
#~ "\n"
#~ "\t1 - exp (-@y*@x).\n"
#~ "\n"
#~ "* Om @x < 0 eller @y <= 0 fås ett fel.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "EXPONDIST(2;4;0) ger 0,001341851.\n"
#~ "@SEEALSO=POISSON"

#~ msgid ""
#~ "@FUNCTION=BERNOULLI\n"
#~ "@SYNTAX=BERNOULLI(k,p)\n"
#~ "@DESCRIPTION=BERNOULLI returns the probability p(k) of obtaining @k from "
#~ "a Bernoulli distribution with probability parameter @p.\n"
#~ "\n"
#~ "* If @k != 0 and @k != 1 BERNOULLI returns #NUM! error.\n"
#~ "* If @p < 0 or @p > 1 BERNOULLI returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BERNOULLI(0,0.5).\n"
#~ "\n"
#~ "@SEEALSO=RANDBERNOULLI"
#~ msgstr ""
#~ "@FUNCTION=BERNOULLI\n"
#~ "@SYNTAX=BERNOULLI(k;p)\n"
#~ "@DESCRIPTION=BERNOULLI returnerar sannolikheten p(k) för att få @k från "
#~ "en Bernoullifördelning med sannolikhetsparametern @p.\n"
#~ "\n"
#~ "* Om @k != 0 och @k != 1 returnerar BERNOULLI felvärdet #NUM!.\n"
#~ "* Om @p < 0 eller @p > 1 returnerar BERNOULLI felvärdet #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BERNOULLI(0;0,5).\n"
#~ "\n"
#~ "@SEEALSO=RANDBERNOULLI"

#~ msgid ""
#~ "@FUNCTION=GAMMALN\n"
#~ "@SYNTAX=GAMMALN(x)\n"
#~ "@DESCRIPTION=GAMMALN function returns the natural logarithm of the gamma "
#~ "function.\n"
#~ "\n"
#~ "* If @x is non-number then GAMMALN returns #VALUE! error.\n"
#~ "* If @x <= 0 then GAMMALN returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "GAMMALN(23) equals 48.471181352.\n"
#~ "\n"
#~ "@SEEALSO=POISSON"
#~ msgstr ""
#~ "@FUNCTION=GAMMALN\n"
#~ "@SYNTAX=GAMMALN(x)\n"
#~ "@DESCRIPTION=Funktionen GAMMALN returnerar den naturliga logaritmen för "
#~ "gammafunktionen.\n"
#~ "\n"
#~ "* Om @x inte är ett tal returnerar GAMMALN felvärdet #VÄRDE!.\n"
#~ "* Om @x <= 0 returnerar GAMMALN felvärdet #NUM!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "GAMMALN(23) är lika med 48,471181352.\n"
#~ "\n"
#~ "@SEEALSO=POISSON"

#~ msgid ""
#~ "@FUNCTION=GAMMADIST\n"
#~ "@SYNTAX=GAMMADIST(x,alpha,beta,cum)\n"
#~ "@DESCRIPTION=GAMMADIST function returns the gamma distribution. If @cum "
#~ "is TRUE, GAMMADIST returns the incomplete gamma function, otherwise it "
#~ "returns the probability mass function.\n"
#~ "\n"
#~ "* If @x < 0 GAMMADIST returns #NUM! error.\n"
#~ "* If @alpha <= 0 or @beta <= 0, GAMMADIST returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "GAMMADIST(1,2,3,0) equals 0.07961459.\n"
#~ "\n"
#~ "@SEEALSO=GAMMAINV"
#~ msgstr ""
#~ "@FUNCTION=GAMMADIST\n"
#~ "@SYNTAX=GAMMADIST(x;alfa;beta;kum)\n"
#~ "@DESCRIPTION=Funktionen GAMMADIST returnerar gammafördelningen. Om @kum "
#~ "är SANT returnerar GAMMADIST den ofullständiga gammafördelningen, annars "
#~ "returnerar den sannolikhetsmassfunktionen.\n"
#~ "\n"
#~ "* Om @x < 0 returnerar GAMMADIST felvärdet #NUM!.\n"
#~ "* Om @alfa <= 0 eller @beta <= 0 returnerar GAMMADIST felvärdet #NUM!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "GAMMADIST(1;2;3;0) är lika med 0,07961459.\n"
#~ "\n"
#~ "@SEEALSO=GAMMAINV"

#~ msgid ""
#~ "@FUNCTION=GAMMAINV\n"
#~ "@SYNTAX=GAMMAINV(p,alpha,beta)\n"
#~ "@DESCRIPTION=GAMMAINV function returns the inverse of the cumulative "
#~ "gamma distribution.\n"
#~ "\n"
#~ "* If @p < 0 or @p > 1 GAMMAINV returns #NUM! error.\n"
#~ "* If @alpha <= 0 or @beta <= 0 GAMMAINV returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "GAMMAINV(0.34,2,4) equals 4.829093908.\n"
#~ "\n"
#~ "@SEEALSO=GAMMADIST"
#~ msgstr ""
#~ "@FUNCTION=GAMMAINV\n"
#~ "@SYNTAX=GAMMAINV(p;alfa;beta)\n"
#~ "@DESCRIPTION=Funktionen GAMMAINV returnerar inversen av den kumulativa "
#~ "gammafördelningen.\n"
#~ "\n"
#~ "* Om @p < 0 eller @p > 1 returnerar GAMMAINV felvärdet #NUM!.\n"
#~ "* Om @alfa <= 0 eller @beta <= 0 returnerar GAMMAINV felvärdet #NUM!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "GAMMAINV(0,34;2;4) är lika med 4,829093908.\n"
#~ "\n"
#~ "@SEEALSO=GAMMADIST"

#~ msgid ""
#~ "@FUNCTION=CHIDIST\n"
#~ "@SYNTAX=CHIDIST(x,dof)\n"
#~ "@DESCRIPTION=CHIDIST function returns the one-tailed probability of the "
#~ "chi-squared distribution. @dof is the number of degrees of freedom.\n"
#~ "\n"
#~ "* If @dof is non-integer it is truncated.\n"
#~ "* If @dof < 1 CHIDIST returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CHIDIST(5.3,2) equals 0.070651213.\n"
#~ "\n"
#~ "@SEEALSO=CHIINV,CHITEST"
#~ msgstr ""
#~ "@FUNCTION=CHIDIST\n"
#~ "@SYNTAX=CHIDIST(x;fri)\n"
#~ "@DESCRIPTION=Funktionen CHIDIST returnerar den ensvansade sannolikheten i "
#~ "den chi-rotade fördelningen. @fri är antalet frihetsgrader.\n"
#~ "\n"
#~ "* Om @fri inte är ett heltal trunkeras det.\n"
#~ "* Om @fri < 1 returnerar CHIDIST felvärdet #NUM!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CHIDIST(5,3;2) equals 0,070651213.\n"
#~ "\n"
#~ "@SEEALSO=CHIINV,CHITEST"

#~ msgid ""
#~ "@FUNCTION=CHIINV\n"
#~ "@SYNTAX=CHIINV(p,dof)\n"
#~ "@DESCRIPTION=CHIINV function returns the inverse of the one-tailed "
#~ "probability of the chi-squared distribution.\n"
#~ "\n"
#~ "* If @p < 0 or @p > 1 or @dof < 1 CHIINV returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CHIINV(0.98,7) equals 1.564293004.\n"
#~ "\n"
#~ "@SEEALSO=CHIDIST,CHITEST"
#~ msgstr ""
#~ "@FUNCTION=CHIINV\n"
#~ "@SYNTAX=CHIINV(p;fri)\n"
#~ "@DESCRIPTION=Funktionen CHIINV returnerar inversen av den ensvansade "
#~ "sannolikheten av den chi-rotade fördelningen.\n"
#~ "\n"
#~ "* Om @p < 0 eller @p > 1 eller @fri < 1 returnerar CHIINV felvärdet "
#~ "#NUM!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CHIINV(0,98;7) är lika med 1,564293004.\n"
#~ "\n"
#~ "@SEEALSO=CHIDIST,CHITEST"

#~ msgid ""
#~ "@FUNCTION=CHITEST\n"
#~ "@SYNTAX=CHITEST(actual_range,theoretical_range)\n"
#~ "@DESCRIPTION=CHITEST function returns the test for independence of chi-"
#~ "squared distribution.\n"
#~ "\n"
#~ "@actual_range is a range that contains the observed data points. "
#~ "@theoretical_range is a range that contains the expected values of the "
#~ "data points.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=CHIDIST,CHIINV"
#~ msgstr ""
#~ "@FUNCTION=CHITEST\n"
#~ "@SYNTAX=CHITEST(verkligt_intervall;teoretiskt_intervall)\n"
#~ "@DESCRIPTION=Funktionen CHITEST returnerar testet av oberoende hos den "
#~ "chi-rotade fördelningen.\n"
#~ "\n"
#~ "@verkligt_intervall är ett intervall som innehåller de observerade "
#~ "datapunkterna. @teoretiskt_intervall är ett intervall som innehåller de "
#~ "förväntade värdena på datapunkterna.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=CHIDIST,CHIINV"

#~ msgid ""
#~ "@FUNCTION=BETADIST\n"
#~ "@SYNTAX=BETADIST(x,alpha,beta[,a,b])\n"
#~ "@DESCRIPTION=BETADIST function returns the cumulative beta distribution. "
#~ "@a is the optional lower bound of @x and @b is the optional upper bound "
#~ "of @x.\n"
#~ "* If @a is not given, BETADIST uses 0.\n"
#~ "* If @b is not given, BETADIST uses 1.\n"
#~ "* If @x < @a or @x > @b BETADIST returns #NUM! error.\n"
#~ "* If @alpha <= 0 or @beta <= 0, BETADIST returns #NUM! error.\n"
#~ "* If @a >= @b BETADIST returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BETADIST(0.12,2,3) equals 0.07319808.\n"
#~ "\n"
#~ "@SEEALSO=BETAINV"
#~ msgstr ""
#~ "@FUNCTION=BETADIST\n"
#~ "@SYNTAX=BETADIST(x;alfa;beta[;a;b])\n"
#~ "@DESCRIPTION=Funktionen BETADIST returnerar den kumulativa "
#~ "betafördelningen. @a är den valfria lägre gränsen hos @x och @b är den "
#~ "valfria övre gränsen hos @x.\n"
#~ "* Om @a inte är angivet använder BETADIST 0.\n"
#~ "* Om @b inte är angivet använder BETADIST 1.\n"
#~ "* Om @x < @a eller @x > @b returnerar BETADIST felvärdet #NUM!.\n"
#~ "* Om @alfa <= 0 eller @beta <= 0 returnerar BETADIST felvärdet #NUM!.\n"
#~ "* Om @a >= @b returnerar BETADIST felvärdet #NUM!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BETADIST(0,12;2;3) är lika med 0,07319808.\n"
#~ "\n"
#~ "@SEEALSO=BETAINV"

#~ msgid ""
#~ "@FUNCTION=BETAINV\n"
#~ "@SYNTAX=BETAINV(p,alpha,beta[,a,b])\n"
#~ "@DESCRIPTION=BETAINV function returns the inverse of cumulative beta "
#~ "distribution.  @a is the optional lower bound of @x and @b is the "
#~ "optional upper bound of @x.\n"
#~ "\n"
#~ "* If @a is not given, BETAINV uses 0.\n"
#~ "* If @b is not given, BETAINV uses 1.\n"
#~ "* If @p < 0 or @p > 1 BETAINV returns #NUM! error.\n"
#~ "* If @alpha <= 0 or @beta <= 0, BETAINV returns #NUM! error.\n"
#~ "* If @a >= @b BETAINV returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BETAINV(0.45,1.6,1) equals 0.607096629.\n"
#~ "\n"
#~ "@SEEALSO=BETADIST"
#~ msgstr ""
#~ "@FUNCTION=BETAINV\n"
#~ "@SYNTAX=BETAINV(p;alfa;beta[;a;b])\n"
#~ "@DESCRIPTION=Funktionen BETAINV returnerar inversen på den kumulativa "
#~ "betafördelningen. @a är den valfria lägre gränsen på @x och @b är den "
#~ "valfria övre gränsen på @x.\n"
#~ "\n"
#~ "* Om @a inte är angiven använder BETAINV 0.\n"
#~ "* Om @b inte är angiven använder BETAINV 1.\n"
#~ "* Om @p < 0 eller @p > 1 returnerar BETAINV felvärdet #NUM!.\n"
#~ "* Om @alfa <= 0 eller @beta <= 0 returnerar BETAINV felvärdet #NUM!.\n"
#~ "* Om @a >= @b returnerar BETAINV felvärdet #NUM!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BETAINV(0,45;1,6;1) är lika med 0,607096629.\n"
#~ "\n"
#~ "@SEEALSO=BETADIST"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=TDIST\n"
#~ "@SYNTAX=TDIST(x,dof,tails)\n"
#~ "@DESCRIPTION=TDIST function returns the Student's t-distribution. @dof is "
#~ "the degree of freedom and @tails is 1 or 2 depending on whether you want "
#~ "one-tailed or two-tailed distribution.\n"
#~ "@tails = 1 returns the size of the right tail.\n"
#~ "\n"
#~ "* If @dof < 1 TDIST returns #NUM! error.\n"
#~ "* If @tails is neither 1 or 2 TDIST returns #NUM! error.\n"
#~ "* This function is Excel compatible for non-negative @x.\n"
#~ "\n"
#~ "Warning: the parameterization of this function is different from what is "
#~ "used for, e.g., NORMSDIST.  This is a common source of mistakes, but "
#~ "necessary for compatibility.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TDIST(2,5,1) equals 0.050969739.\n"
#~ "TDIST(-2,5,1) equals 0.949030261.\n"
#~ "TDIST(0,5,2) equals 1.\n"
#~ "\n"
#~ "@SEEALSO=TINV,TTEST"
#~ msgstr ""
#~ "@FUNCTION=TDIST\n"
#~ "@SYNTAX=TDIST(x;fri;svansar)\n"
#~ "@DESCRIPTION=Funktionen TDIST returnerar Students t-fördelning. @fri är "
#~ "antalet frihetsgrader och @svansar är 1 eller 2 beroende på om du vill ha "
#~ "en ensidig eller tvåsidig fördelning.\n"
#~ "@svansar = 1 returnerar storleken på den högra svansen.\n"
#~ "\n"
#~ "* Om @fri < 1 returneras felvärdet #NUM!.\n"
#~ "* Om @svansar varken är 1 eller 2 returneras felvärdet #NUM!.\n"
#~ "* Denna funktion är kompatibel med Excel för icke-negativa @x.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TDIST(2;5;1) är lika med 0,050969739.\n"
#~ "TDIST(-2;5;1) är lika med 0,949030261.\n"
#~ "TDIST(0;5;2) är lika med 1.\n"
#~ "\n"
#~ "@SEEALSO=TINV,TTEST"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=TINV\n"
#~ "@SYNTAX=TINV(p,dof)\n"
#~ "@DESCRIPTION=TINV function returns the inverse of the two-tailed "
#~ "Student's t-distribution.\n"
#~ "\n"
#~ "* If @p < 0 or @p > 1 or @dof < 1 TINV returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "Warning: the parameterization of this function is different from what is "
#~ "used for, e.g., NORMSINV.  This is a common source of mistakes, but "
#~ "necessary for compatibility.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TINV(0.4,32) equals 0.852998454.\n"
#~ "\n"
#~ "@SEEALSO=TDIST,TTEST"
#~ msgstr ""
#~ "@FUNCTION=TINV\n"
#~ "@SYNTAX=TINV(p;fri)\n"
#~ "@DESCRIPTION=Funktionen TINV returnerar inversen av Students tvåsidiga t-"
#~ "fördelning.\n"
#~ "\n"
#~ "* Om @p < 0 eller om @p > 1 eller om @fri < 1 returneras felvärdet "
#~ "#NUM!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TINV(0,4;32) är lika med 0,852998454.\n"
#~ "\n"
#~ "@SEEALSO=TDIST,TTEST"

#~ msgid ""
#~ "@FUNCTION=FDIST\n"
#~ "@SYNTAX=FDIST(x,dof1,dof2)\n"
#~ "@DESCRIPTION=FDIST function returns the F probability distribution. @dof1 "
#~ "is the numerator degrees of freedom and @dof2 is the denominator degrees "
#~ "of freedom.\n"
#~ "\n"
#~ "* If @x < 0 FDIST returns #NUM! error.\n"
#~ "* If @dof1 < 1 or @dof2 < 1, FDIST returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FDIST(2,5,5) equals 0.232511319.\n"
#~ "\n"
#~ "@SEEALSO=FINV"
#~ msgstr ""
#~ "@FUNCTION=FDIST\n"
#~ "@SYNTAX=FDIST(x;fri1;fri2)\n"
#~ "@DESCRIPTION=Funktionen FDIST returnerar F-sannolikhetsfördelningen. "
#~ "@fri1 är antalet frihetsgrader hos täljaren och @fri2 är antalet "
#~ "frihetsgrader hos nämnaren.\n"
#~ "\n"
#~ "* Om @x < 0 returnerar FDIST felvärdet #NUM!.\n"
#~ "* Om @fri1 < 1 eller @fri2 < 1 returnerar FDIST felvärdet #NUM!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FDIST(2;5;5) är lika med 0,232511319.\n"
#~ "\n"
#~ "@SEEALSO=FINV"

#~ msgid ""
#~ "@FUNCTION=LANDAU\n"
#~ "@SYNTAX=LANDAU(x)\n"
#~ "@DESCRIPTION=LANDAU returns the probability density p(x) at @x for the "
#~ "Landau distribution using an approximation method. \n"
#~ "@EXAMPLES=\n"
#~ "LANDAU(0.34).\n"
#~ "\n"
#~ "@SEEALSO=RANDLANDAU"
#~ msgstr ""
#~ "@FUNCTION=LANDAU\n"
#~ "@SYNTAX=LANDAU(x)\n"
#~ "@DESCRIPTION=LANDAU returnerar sannolikhetstätheten p(x) vid @x för "
#~ "Landaufördelningen med hjälp av en approximationsmetod.\n"
#~ "@EXAMPLES=\n"
#~ "LANDAU(0,34).\n"
#~ "\n"
#~ "@SEEALSO=RANDLANDAU"

#~ msgid ""
#~ "@FUNCTION=FINV\n"
#~ "@SYNTAX=FINV(p,dof1,dof2)\n"
#~ "@DESCRIPTION=FINV function returns the inverse of the F probability "
#~ "distribution.\n"
#~ "\n"
#~ "* If @p < 0 or @p > 1 FINV returns #NUM! error.\n"
#~ "* If @dof1 < 1 or @dof2 < 1 FINV returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FINV(0.2,2,4) equals 2.472135955.\n"
#~ "\n"
#~ "@SEEALSO=FDIST"
#~ msgstr ""
#~ "@FUNCTION=FINV\n"
#~ "@SYNTAX=FINV(p;fri1;fri2)\n"
#~ "@DESCRIPTION=Funktionen FINV returnerar inversen av F-"
#~ "sannolikhetsfördelningen.\n"
#~ "\n"
#~ "* Om @p < 0 eller @p > 1 returnerar FINV felvärdet #NUM!.\n"
#~ "* Om @fri1 < 1 eller @fri2 < 1 returnerar FINV felvärdet #NUM!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FINV(0,2;2;4) är lika med 2,472135955.\n"
#~ "\n"
#~ "@SEEALSO=FDIST"

#~ msgid ""
#~ "@FUNCTION=BINOMDIST\n"
#~ "@SYNTAX=BINOMDIST(n,trials,p,cumulative)\n"
#~ "@DESCRIPTION=BINOMDIST function returns the binomial distribution. @n is "
#~ "the number of successes, @trials is the total number of independent "
#~ "trials, @p is the probability of success in trials, and @cumulative "
#~ "describes whether to return the sum of the binomial function from 0 to "
#~ "@n.\n"
#~ "\n"
#~ "* If @n or @trials are non-integer they are truncated.\n"
#~ "* If @n < 0 or @trials < 0 BINOMDIST returns #NUM! error.\n"
#~ "* If @n > @trials BINOMDIST returns #NUM! error.\n"
#~ "* If @p < 0 or @p > 1 BINOMDIST returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BINOMDIST(3,5,0.8,0) equals 0.2048.\n"
#~ "\n"
#~ "@SEEALSO=POISSON"
#~ msgstr ""
#~ "@FUNCTION=BINOMDIST\n"
#~ "@SYNTAX=BINOMDIST(n;försök;p;kumulativ)\n"
#~ "@DESCRIPTION=Funktionen BINOMDIST returnerar binomialfördelningen. @n är "
#~ "antalet försök, @försök det totala antalet oberoende försök, @p är "
#~ "sannolikheten för att försöken lyckas, och @kumulativ beskriver huruvida "
#~ "summan av binomialfunktionen från 0 till @n ska returneras.\n"
#~ "\n"
#~ "* Om @n eller @försök inte är heltal trunkeras de.\n"
#~ "* Om @n < 0 eller @försök < 0 returnerar BINOMDIST felvärdet #NUM!.\n"
#~ "* Om @n > @försök returnerar BINOMDIST felvärdet #NUM!.\n"
#~ "* Om @p < 0 eller @p > 1 returnerar BINOMDIST felvärdet #NUM!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BINOMDIST(3;5;0,8;0) är lika med 0,2048.\n"
#~ "\n"
#~ "@SEEALSO=POISSON"

#~ msgid ""
#~ "@FUNCTION=CAUCHY\n"
#~ "@SYNTAX=CAUCHY(x,a,cum)\n"
#~ "@DESCRIPTION=CAUCHY returns the Cauchy distribution with scale parameter "
#~ "@a. If @cum is TRUE, CAUCHY returns the cumulative distribution.\n"
#~ "\n"
#~ "* If @a < 0 CAUCHY returns #NUM! error.\n"
#~ "* If @cum != TRUE and @cum != FALSE CAUCHY returns #VALUE! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CAUCHY(0.43,1,TRUE) returns 0.370735.\n"
#~ "\n"
#~ "@SEEALSO=RANDCAUCHY"
#~ msgstr ""
#~ "@FUNCTION=CAUCHY\n"
#~ "@SYNTAX=CAUCHY(x;a;kum)\n"
#~ "@DESCRIPTION=CAUCHY returnerar Cauchyfördelningen med skalparametern @a.\n"
#~ "Om @kum är SANT returnerar CAUCHY den kumulativa fördelningen.\n"
#~ "\n"
#~ "* Om @a < 0 returnerar CAUCHY felvärdet #NUM!.\n"
#~ "* Om @kum != SANT och @kum != FALSKT returnerar CAUCHY felvärdet "
#~ "#VALUE!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CAUCHY(0,43;1;SANT) returnerar 0,370735.\n"
#~ "\n"
#~ "@SEEALSO=RANDCAUCHY"

#~ msgid ""
#~ "@FUNCTION=CRITBINOM\n"
#~ "@SYNTAX=CRITBINOM(trials,p,alpha)\n"
#~ "@DESCRIPTION=CRITBINOM function returns the smallest value for which the "
#~ "cumulative is greater than or equal to a given value. @n is the number of "
#~ "trials, @p is the probability of success in trials, and @alpha is the "
#~ "criterion value.\n"
#~ "\n"
#~ "* If @trials is a non-integer it is truncated.\n"
#~ "* If @trials < 0 CRITBINOM returns #NUM! error.\n"
#~ "* If @p < 0 or @p > 1 CRITBINOM returns #NUM! error.\n"
#~ "* If @alpha < 0 or @alpha > 1 CRITBINOM returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CRITBINOM(10,0.5,0.75) equals 6.\n"
#~ "\n"
#~ "@SEEALSO=BINOMDIST"
#~ msgstr ""
#~ "@FUNCTION=CRITBINOM\n"
#~ "@SYNTAX=CRITBINOM(försök;p;alfa)\n"
#~ "@DESCRIPTION=Funktionen CRITBINOM returnerar det minsta värde för vilket "
#~ "det kumulativa är större än eller lika med ett givet värde. @n är antalet "
#~ "försök, @p är sannolikheten för att försök lyckas, och @alfa är "
#~ "kriteriet.\n"
#~ "\n"
#~ "* Om @försök inte är ett hetal trunkeras det.\n"
#~ "* Om @försök < 0 returnerar CRITBINOM felvärdet #NUM!.\n"
#~ "* Om @p < 0 eller @p > 1 returnerar CRITBINOM felet #NUM!.\n"
#~ "* Om @alfa < 0 eller @alfa > 1 returnerar CRITBINOM felvärdet #NUM!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CRITBINOM(10;0,5;0,75) är lika med 6.\n"
#~ "\n"
#~ "@SEEALSO=BINOMDIST"

#~ msgid ""
#~ "@FUNCTION=PERMUT\n"
#~ "@SYNTAX=PERMUT(n,k)\n"
#~ "@DESCRIPTION=PERMUT function returns the number of permutations. @n is "
#~ "the number of objects, @k is the number of objects in each permutation.\n"
#~ "\n"
#~ "* If @n = 0 PERMUT returns #NUM! error.\n"
#~ "* If @n < @k PERMUT returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "PERMUT(7,3) equals 210.\n"
#~ "\n"
#~ "@SEEALSO=COMBIN"
#~ msgstr ""
#~ "@FUNCTION=PERMUT\n"
#~ "@SYNTAX=PERMUT(n;k)\n"
#~ "@DESCRIPTION=Funktionen PERMUT returnerar antalet permutationer. @n är "
#~ "antalet objekt, @k är antalet objekt i varje permutation.\n"
#~ "\n"
#~ "* Om @n = 0 returnerar PERMUT felvärdet #NUM!.\n"
#~ "* Om @n < @k returnerar PERMUT felvärdet #NUM!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "PERMUT(7;3) är lika med 210.\n"
#~ "\n"
#~ "@SEEALSO=COMBIN"

#~ msgid ""
#~ "@FUNCTION=HYPGEOMDIST\n"
#~ "@SYNTAX=HYPGEOMDIST(x,n,M,N[,cumulative])\n"
#~ "@DESCRIPTION=HYPGEOMDIST function returns the hypergeometric "
#~ "distribution. @x is the number of successes in the sample, @n is the "
#~ "number of trials, @M is the number of successes overall, and @N is the "
#~ "population size.\n"
#~ "\n"
#~ "If the optional argument @cumulative is TRUE, the cumulative left tail "
#~ "will be returned.\n"
#~ "\n"
#~ "* If @x,@n,@M or @N is a non-integer it is truncated.\n"
#~ "* If @x,@n,@M or @N < 0 HYPGEOMDIST returns #NUM! error.\n"
#~ "* If @x > @M or @n > @N HYPGEOMDIST returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "HYPGEOMDIST(1,2,3,10) equals 0.4666667.\n"
#~ "\n"
#~ "@SEEALSO=BINOMDIST,POISSON"
#~ msgstr ""
#~ "@FUNCTION=HYPGEOMDIST\n"
#~ "@SYNTAX=HYPGEOMDIST(x;n;M;N[,kumulativ])\n"
#~ "@DESCRIPTION=Funktionen HYPGEOMDIST returnerar den hypergeometriska "
#~ "fördelningen. @x är antalet lyckade försök i provet, @n är antalet "
#~ "försök, @M är det totala antalet lyckade försök, och @N är "
#~ "populationsstorleken.\n"
#~ "\n"
#~ "Om det valfria argumentet @kumulativ är SANT returneras den ackumulerade "
#~ "vänstra svansen.\n"
#~ "\n"
#~ "* Om @x, @n, @M eller @N inte är heltal trunkeras de.\n"
#~ "* Om @x, @n, @M eller @N < 0 returnerar HYPGEOMDIST felvärdet #NUM!.\n"
#~ "* Om @x > @M eller @n > @N returnerar HYPGEOMDIST felvärdet #NUM!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "HYPGEOMDIST(1;2;3;10) är lika med 0,4666667.\n"
#~ "\n"
#~ "@SEEALSO=BINOMDIST,POISSON"

#~ msgid ""
#~ "@FUNCTION=CONFIDENCE\n"
#~ "@SYNTAX=CONFIDENCE(x,stddev,size)\n"
#~ "@DESCRIPTION=CONFIDENCE function returns the confidence interval for a "
#~ "mean. @x is the significance level, @stddev is the population standard "
#~ "deviation, and @size is the size of the sample.\n"
#~ "\n"
#~ "* If @size is non-integer it is truncated.\n"
#~ "* If @size < 0 CONFIDENCE returns #NUM! error.\n"
#~ "* If @size is 0 CONFIDENCE returns #DIV/0! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CONFIDENCE(0.05,1,33) equals 0.341185936.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE"
#~ msgstr ""
#~ "@FUNCTION=CONFIDENCE\n"
#~ "@SYNTAX=CONFIDENCE(x;stdav;storlek)\n"
#~ "@DESCRIPTION=Funktionen CONFIDENCE returnerar konfidensintervallet för "
#~ "ett medelvärde. @x är signifikansnivån, @stdav är standardavvikelsen för "
#~ "fördelningen, och @storlek är storleken på provet.\n"
#~ "\n"
#~ "* Om @storlek inte är ett heltal trunkeras det.\n"
#~ "* Om @storlek < 0 returnerar CONFIDENCE felvärdet #NUM!.\n"
#~ "* Om @storlek är 0 returnerar CONFIDENCE felvärdet #DIV/0!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CONFIDENCE(0,05;1;33) är lika med 0,341185936.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE"

#~ msgid ""
#~ "@FUNCTION=STANDARDIZE\n"
#~ "@SYNTAX=STANDARDIZE(x,mean,stddev)\n"
#~ "@DESCRIPTION=STANDARDIZE function returns a normalized value. @x is the "
#~ "number to be normalized, @mean is the mean of the distribution, @stddev "
#~ "is the standard deviation of the distribution.\n"
#~ "\n"
#~ "* If @stddev is 0 STANDARDIZE returns #DIV/0! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "STANDARDIZE(3,2,4) equals 0.25.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE"
#~ msgstr ""
#~ "@FUNCTION=STANDARDIZE\n"
#~ "@SYNTAX=STANDARDIZE(x;medel;stdav)\n"
#~ "@DESCRIPTION=Funktionen STANDARDIZE beräknat ett normaliserat värde av "
#~ "@x. @medel är medelvärdet av fördelningen, @stdav är standardavvikelsen "
#~ "för fördelningen.\n"
#~ "\n"
#~ "* Om @stdav är 0 returnernar STANDARDIZE felvärdet #DIV/0!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "STANDARDIZE(3;2;4) är lika med 0,25.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE"

#~ msgid ""
#~ "@FUNCTION=WEIBULL\n"
#~ "@SYNTAX=WEIBULL(x,alpha,beta,cumulative)\n"
#~ "@DESCRIPTION=WEIBULL function returns the Weibull distribution. If the "
#~ "@cumulative boolean is true it will return:\n"
#~ "\n"
#~ "\t1 - exp (-(@x/@beta)^@alpha),\n"
#~ "\n"
#~ "otherwise it will return\n"
#~ "\n"
#~ "\t(@alpha/@beta^@alpha) * @x^(@alpha-1) * exp(-(@x/@beta^@alpha)).\n"
#~ "\n"
#~ "* If @x < 0 WEIBULL returns #NUM! error.\n"
#~ "* If @alpha <= 0 or @beta <= 0 WEIBULL returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "WEIBULL(3,2,4,0) equals 0.213668559.\n"
#~ "\n"
#~ "@SEEALSO=POISSON"
#~ msgstr ""
#~ "@FUNCTION=WEIBULL\n"
#~ "@SYNTAX=WEIBULL(x;alfa;beta;kumulativ)\n"
#~ "@DESCRIPTION=Funktionen WEIBULL returnerar Weibulls fördelning. Om "
#~ "flaggan @kumulativ är sann fås\n"
#~ "\n"
#~ "\t1 - exp (-(@x/@beta)^@alfa),\n"
#~ "\n"
#~ "annars fås\n"
#~ "\n"
#~ "\t(@alfa/@beta^@alfa) * @x^(@alfa-1) * exp(-(@x/@beta^@alfa)).\n"
#~ "\n"
#~ "* Om @x < 0 ger WEIBULL felvärdet #NUM!\n"
#~ "* Om @alfa <= 0 eller @beta <= 0 ger WEIBULL felvärdet #NUM!\n"
#~ "* Denna funktion är kompatibel med Excel\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "WEIBULL(3;2;4;0) ger 0,213668559.\n"
#~ "@SEEALSO=POISSON"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=NORMDIST\n"
#~ "@SYNTAX=NORMDIST(x,mean,stddev,cumulative)\n"
#~ "@DESCRIPTION=The NORMDIST function returns the value of the probability "
#~ "density function or the cumulative distribution function for the normal "
#~ "distribution with the mean given by @mean, and the standard deviation "
#~ "given by @stddev. If @cumulative is FALSE, NORMDIST returns the value of "
#~ "the probability density function at the value @x. If @cumulative is TRUE, "
#~ "NORMDIST returns the value of the cumulative distribution function at "
#~ "@x.\n"
#~ "\n"
#~ "* If @stddev is 0 NORMDIST returns #DIV/0! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "NORMDIST(2,1,2,0) equals 0.176032663.\n"
#~ "\n"
#~ "@SEEALSO=POISSON"
#~ msgstr ""
#~ "@FUNCTION=NORMDIST\n"
#~ "@SYNTAX=NORMDIST(x;medel;stdav;kumulativ)\n"
#~ "@DESCRIPTION=Funktionen NORMDIST returnerar den kumulativa "
#~ "normalfördelningen. @x är värdet för vilket du önskar fördelningen, "
#~ "@medel är medelvärdet av fördelningen, @stdav är standardavvikelsen.\n"
#~ "\n"
#~ "* Om @stdav är 0 returnerar NORMDIST felvärdet #DIV/0!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "NORMDIST(2;1;2;0) är lika med 0,176032663.\n"
#~ "\n"
#~ "@SEEALSO=POISSON"

#~ msgid ""
#~ "@FUNCTION=NORMINV\n"
#~ "@SYNTAX=NORMINV(p,mean,stddev)\n"
#~ "@DESCRIPTION=NORMINV function returns the inverse of the normal "
#~ "cumulative distribution. @p is the given probability corresponding to the "
#~ "normal distribution, @mean is the arithmetic mean of the distribution, "
#~ "and @stddev is the standard deviation of the distribution.\n"
#~ "\n"
#~ "* If @p < 0 or @p > 1 or @stddev <= 0 NORMINV returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "NORMINV(0.76,2,3) equals 4.118907689.\n"
#~ "\n"
#~ "@SEEALSO=NORMDIST,NORMSDIST,NORMSINV,STANDARDIZE,ZTEST"
#~ msgstr ""
#~ "@FUNCTION=NORMINV\n"
#~ "@SYNTAX=NORMINV(p;medel;stdav)\n"
#~ "@DESCRIPTION=Funktionen NORMINV returnerar inversen av kumulativa "
#~ "normalfördelningen. @p är givna sannolikheten som motsvarar "
#~ "normalfördelningen, @medel är det aritmetiska medelvärdet av "
#~ "fördelningen, och @stdav är standardavvikelsen för fördelningen.\n"
#~ "\n"
#~ "* Om @p < 0 eller @p > 1 eller @stdav <= 0 returnerar NORMINV felvärdet "
#~ "#NUM!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "NORMINV(0,76;2;3) är lika med 4,118907689.\n"
#~ "\n"
#~ "@SEEALSO=NORMDIST,NORMSDIST,NORMSINV,STANDARDIZE,ZTEST"

#~ msgid ""
#~ "@FUNCTION=KURT\n"
#~ "@SYNTAX=KURT(n1, n2, ...)\n"
#~ "@DESCRIPTION=KURT returns an unbiased estimate of the kurtosis of a data "
#~ "set.\n"
#~ "Note, that this is only meaningful if the underlying distribution really "
#~ "has a fourth moment.  The kurtosis is offset by three such that a normal "
#~ "distribution will have zero kurtosis.\n"
#~ "\n"
#~ "* Strings and empty cells are simply ignored.\n"
#~ "* If fewer than four numbers are given or all of them are equal KURT "
#~ "returns #DIV/0! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "KURT(A1:A5) equals 1.234546305.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,VAR,SKEW,KURTP"
#~ msgstr ""
#~ "@FUNCTION=KURT\n"
#~ "@SYNTAX=KURT(n1; n2; ...)\n"
#~ "@DESCRIPTION=KURT returnerar en opartisk uppskattning av kurtositeten hos "
#~ "en datamängd.\n"
#~ "Observera att detta endast är meningsfullt om den underliggande "
#~ "fördelningen verkligen har ett fjärde moment. Kurtositeten är förskjuten "
#~ "med tre så att en normalfördelning kommer att ha noll kurtositet.\n"
#~ "\n"
#~ "* Strängar och tomma celler ignoreras.\n"
#~ "* Om färre än fyra tal anges eller om alla är lika returnerar KURT "
#~ "felvärdet #DIV/0!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att cellerna A1; A2; ...; A5 innehåller talen 11,4; 17,3; 21,3; "
#~ "25,9 och 40,1. Då är\n"
#~ "KURT(A1:A5) lika med 1,234546305.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,VAR,SKEW,KURTP"

#~ msgid ""
#~ "@FUNCTION=KURTP\n"
#~ "@SYNTAX=KURTP(n1, n2, ...)\n"
#~ "@DESCRIPTION=KURTP returns the population kurtosis of a data set.\n"
#~ "\n"
#~ "* Strings and empty cells are simply ignored.\n"
#~ "* If fewer than two numbers are given or all of them are equal KURTP "
#~ "returns #DIV/0! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "KURTP(A1:A5) equals -0.691363424.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,VARP,SKEWP,KURT"
#~ msgstr ""
#~ "@FUNCTION=KURTP\n"
#~ "@SYNTAX=KURTP(n1; n2; ...)\n"
#~ "@DESCRIPTION=KURTP returnerar populationskurtositeten hos en datamängd.\n"
#~ "\n"
#~ "* Strängar och tomma celler ignoreras.\n"
#~ "* Om färre än två tal anges eller alla är lika returnerar KURTP felvärdet "
#~ "#DIV/0!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att cellerna A1; A2; ...; A5 innehåller talen 11,4; 17,3; 21,3; "
#~ "25,9 och 40,1. Då är\n"
#~ "KURTP(A1:A5) lika med -0,691363424.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,VARP,SKEWP,KURT"

#~ msgid ""
#~ "@FUNCTION=AVEDEV\n"
#~ "@SYNTAX=AVEDEV(n1, n2, ...)\n"
#~ "@DESCRIPTION=AVEDEV returns the average of the absolute deviations of a "
#~ "data set from their mean.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "AVEDEV(A1:A5) equals 7.84.\n"
#~ "\n"
#~ "@SEEALSO=STDEV"
#~ msgstr ""
#~ "@FUNCTION=AVEDEV\n"
#~ "@SYNTAX=AVEDEV(n1; n2; ...)\n"
#~ "@DESCRIPTION=AVEDEV returnerar medelvärdet av de absoluta avvikelserna av "
#~ "en datamängd från deras medelvärde.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att cellerna A1; A2; ...; A5 innehåller talen 11,4; 17,3; 21,3; "
#~ "25,9 och 40,1. Då är\n"
#~ "AVEDEV(A1:A5) lika med 7,84.\n"
#~ "\n"
#~ "@SEEALSO=STDEV"

#~ msgid ""
#~ "@FUNCTION=DEVSQ\n"
#~ "@SYNTAX=DEVSQ(n1, n2, ...)\n"
#~ "@DESCRIPTION=DEVSQ returns the sum of squares of deviations of a data set "
#~ "from the sample mean.\n"
#~ "\n"
#~ "* Strings and empty cells are simply ignored.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "DEVSQ(A1:A5) equals 470.56.\n"
#~ "\n"
#~ "@SEEALSO=STDEV"
#~ msgstr ""
#~ "@FUNCTION=DEVSQ\n"
#~ "@SYNTAX=DEVSQ(n1; n2; ...)\n"
#~ "@DESCRIPTION=DEVSQ returnerar summan av kvadraterna av avvikelserna av en "
#~ "datamängd från provmedelvärdet.\n"
#~ "\n"
#~ "* Strängar och tomma celler ignoreras.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att cellerna A1; A2; ...; A5 innehåller talen 11,4; 17,3; 21,3; "
#~ "25,9 och 40,1. Då är\n"
#~ "DEVSQ(A1:A5) lika med 470,56.\n"
#~ "\n"
#~ "@SEEALSO=STDEV"

#~ msgid ""
#~ "@FUNCTION=FISHER\n"
#~ "@SYNTAX=FISHER(x)\n"
#~ "@DESCRIPTION=FISHER function returns the Fisher transformation at @x.\n"
#~ "\n"
#~ "* If @x is not a number, FISHER returns #VALUE! error.\n"
#~ "* If @x <= -1 or @x >= 1, FISHER returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FISHER(0.332) equals 0.345074339.\n"
#~ "\n"
#~ "@SEEALSO=SKEW"
#~ msgstr ""
#~ "@FUNCTION=FISHER\n"
#~ "@SYNTAX=FISHER(x)\n"
#~ "@DESCRIPTION=Funktionen FISHER returnerar Fisher-transformeringen vid "
#~ "@x.\n"
#~ "\n"
#~ "* Om @x inte är ett tal returnerar FISHER felvärdet #VÄRDE!.\n"
#~ "* Om @x <= -1 eller @x >= 1 returnerar FISHER felvärdet #NUM!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FISHER(0,332) är lika med 0,345074339.\n"
#~ "\n"
#~ "@SEEALSO=SKEW"

#~ msgid ""
#~ "@FUNCTION=POISSON\n"
#~ "@SYNTAX=POISSON(x,mean,cumulative)\n"
#~ "@DESCRIPTION=POISSON function returns the Poisson distribution. @x is the "
#~ "number of events, @mean is the expected numeric value @cumulative "
#~ "describes whether to return the sum of the Poisson function from 0 to "
#~ "@x.\n"
#~ "\n"
#~ "* If @x is a non-integer it is truncated.\n"
#~ "* If @x < 0 POISSON returns #NUM! error.\n"
#~ "* If @mean <= 0 POISSON returns the #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "POISSON(3,6,0) equals 0.089235078.\n"
#~ "\n"
#~ "@SEEALSO=NORMDIST, WEIBULL"
#~ msgstr ""
#~ "@FUNCTION=POISSON\n"
#~ "@SYNTAX=POISSON(x;medel;kumulativ)\n"
#~ "@DESCRIPTION=Funktionen POISSON returnerar poissonfördelningen. @x är "
#~ "antalet händelser, @medel är det förväntade numeriska värdet @kumulativ "
#~ "beskriver huruvida summan av poissonfunktionen från 0 till @x ska "
#~ "returneras.\n"
#~ "\n"
#~ "* Om @x inte är ett heltal trunkeras det.\n"
#~ "* Om @x < 0 returnerar POISSON felvärdet #NUM!.\n"
#~ "* Om @medel <= 0 returnerar POISSON felvärdet #NUM!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "POISSON(3;6;0) är lika med 0,089235078.\n"
#~ "\n"
#~ "@SEEALSO=NORMDIST, WEIBULL"

#~ msgid ""
#~ "@FUNCTION=PEARSON\n"
#~ "@SYNTAX=PEARSON(array1,array2)\n"
#~ "@DESCRIPTION=PEARSON returns the Pearson correlation coefficient of two "
#~ "data sets.\n"
#~ "\n"
#~ "* Strings and empty cells are simply ignored.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=INTERCEPT,LINEST,RSQ,SLOPE,STEYX"
#~ msgstr ""
#~ "@FUNCTION=PEARSON\n"
#~ "@SYNTAX=PEARSON(vektor1;vektor2)\n"
#~ "@DESCRIPTION=PEARSON returnerar Pearsons korrelationskoefficient för två "
#~ "datamängder.\n"
#~ "\n"
#~ "* Strängar och tomma celler ignoreras.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=INTERCEPT,LINEST,RSQ,SLOPE,STEYX"

#~ msgid ""
#~ "@FUNCTION=RSQ\n"
#~ "@SYNTAX=RSQ(array1,array2)\n"
#~ "@DESCRIPTION=RSQ returns the square of the Pearson correlation "
#~ "coefficient of two data sets.\n"
#~ "\n"
#~ "* Strings and empty cells are simply ignored.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=CORREL,COVAR,INTERCEPT,LINEST,LOGEST,PEARSON,SLOPE,STEYX,TREND"
#~ msgstr ""
#~ "@FUNCTION=RSQ\n"
#~ "@SYNTAX=RSQ(vektor1;vektor2)\n"
#~ "@DESCRIPTION=RSQ returnerar kvadraten av Pearson-"
#~ "korrelationskoefficienten för två datamängder.\n"
#~ "\n"
#~ "* Strängar och tomma celler ignoreras.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=CORREL,COVAR,INTERCEPT,LINEST,LOGEST,PEARSON,SLOPE,STEYX,TREND"

#~ msgid ""
#~ "@FUNCTION=MEDIAN\n"
#~ "@SYNTAX=MEDIAN(n1, n2, ...)\n"
#~ "@DESCRIPTION=MEDIAN returns the median of the given data set.\n"
#~ "\n"
#~ "* Strings and empty cells are simply ignored.\n"
#~ "* If even numbers are given MEDIAN returns the average of the two numbers "
#~ "in the middle.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "MEDIAN(A1:A5) equals 21.3.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,COUNT,COUNTA,DAVERAGE,MODE,SSMEDIAN,SUM"
#~ msgstr ""
#~ "@FUNCTION=MEDIAN\n"
#~ "@SYNTAX=MEDIAN(n1; n2; ...)\n"
#~ "@DESCRIPTION=MEDIAN beräknar medianen ur en given datamängd.\n"
#~ "\n"
#~ "* Strängar och tomma celler ignoreras.\n"
#~ "* Om ett jämnt antal tal anges, returnerar MEDIAN medelvärdet av\n"
#~ "det två mellersta talen.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att cellerna A1; A2; ...; A5 innehåller talen 11,4; 17,3; 21,3; "
#~ "25,9 och 40,1. Då är\n"
#~ "MEDIAN(A1:A5) lika med 21,3.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,COUNT,COUNTA,DAVERAGE,MODE,SSMEDIAN,SUM"

#~ msgid ""
#~ "@FUNCTION=SSMEDIAN\n"
#~ "@SYNTAX=SSMEDIAN(array[,interval)]\n"
#~ "@DESCRIPTION=The SSMEDIAN function returns the median for grouped data as "
#~ "commonly determined in the social sciences. The data points given in "
#~ "@array are assumed to be the result of grouping data into intervals of "
#~ "length @interval\n"
#~ "\n"
#~ "* If @interval is not given, SSMEDIAN uses 1.\n"
#~ "* If @array is empty, SSMEDIAN returns #NUM! error.\n"
#~ "* If @interval <= 0, SSMEDIAN returns #NUM! error.\n"
#~ "* SSMEDIAN does not check whether the data points are at least @interval "
#~ "apart.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, A3 contain numbers 7, 8, 8.  Then\n"
#~ "SSMEDIAN(A1:A3, 1) equals 7.75.\n"
#~ "\n"
#~ "@SEEALSO=MEDIAN"
#~ msgstr ""
#~ "@FUNCTION=SSMEDIAN\n"
#~ "@SYNTAX=SSMEDIAN(vektor[;intervall])\n"
#~ "@DESCRIPTION=Funktionen SSMEDIAN returnerar medianen för grupperade data "
#~ "som normalt använt i socialvetenskaperna. Datapunkterna som ges i @vektor "
#~ "antas vara resultatet av att gruppera data i intervall av längden "
#~ "@intervall.\n"
#~ "\n"
#~ "* Om @vektor är tom returnerar SSMEDIAN felvärdet #NUM!.\n"
#~ "* Om @intervall <= 0 returnerar SSMEDIAN felvärdet #NUM!.\n"
#~ "* SSMEDIAN kontrollerar inte om datapunkterna är åtskilda med minst "
#~ "@intervall.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att cellerna A1; A2; A3 innehåller talen 7; 8; 8. Då är\n"
#~ "SSMEDIAN(A1:A3; 1) lika med 7,75.\n"
#~ "\n"
#~ "@SEEALSO=MEDIAN"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=LARGE\n"
#~ "@SYNTAX=LARGE(n, k)\n"
#~ "@DESCRIPTION=LARGE returns the k-th largest value in a data set.\n"
#~ "\n"
#~ "* If data set is empty LARGE returns #NUM! error.\n"
#~ "* If @k <= 0 or @k is greater than the number of data items given LARGE "
#~ "returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "LARGE(A1:A5,2) equals 25.9.\n"
#~ "LARGE(A1:A5,4) equals 17.3.\n"
#~ "\n"
#~ "@SEEALSO=PERCENTILE,PERCENTRANK,QUARTILE,SMALL"
#~ msgstr ""
#~ "@FUNCTION=LARGE\n"
#~ "@SYNTAX=LARGE(n1; n2; ...; k)\n"
#~ "@DESCRIPTION=LARGE returnerar det k:te största värdet ur en datamängd.\n"
#~ "\n"
#~ "* Om mängden är tom returneras felvärdet #NUM!.\n"
#~ "* Om @k <= 0 eller @k är större än antalet angivna tal, returneras\n"
#~ "felvärdet #NUM!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att cellerna A1; A2; ...; A5 innehåller talen 11,4; 17,3; 21,3; "
#~ "25,9 och 40,1. Då är\n"
#~ "LARGE(A1:A5;2) lika med 25,9.\n"
#~ "LARGE(A1:A5;4) lika med 17,3.\n"
#~ "\n"
#~ "@SEEALSO=PERCENTILE,PERCENTRANK,QUARTILE,SMALL"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=SMALL\n"
#~ "@SYNTAX=SMALL(n, k)\n"
#~ "@DESCRIPTION=SMALL returns the k-th smallest value in a data set.\n"
#~ "\n"
#~ "* If data set is empty SMALL returns #NUM! error.\n"
#~ "* If @k <= 0 or @k is greater than the number of data items given SMALL "
#~ "returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "SMALL(A1:A5,2) equals 17.3.\n"
#~ "SMALL(A1:A5,4) equals 25.9.\n"
#~ "\n"
#~ "@SEEALSO=PERCENTILE,PERCENTRANK,QUARTILE,LARGE"
#~ msgstr ""
#~ "@FUNCTION=SMALL\n"
#~ "@SYNTAX=SMALL(n1; n2; ...; k)\n"
#~ "@DESCRIPTION=SMALL returnerar det k:te minsta värdet ur en datamängd.\n"
#~ "\n"
#~ "* Om mängden är tom returneras felvärdet #NUM!.\n"
#~ "* Om @k <= 0 eller @k är större än antalet angivna tal, returneras "
#~ "felvärdet #NUM!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att cellerna A1; A2; ...; A5 innehåller talen 11,4; 17,3; 21,3; "
#~ "25,9 och 40,1. Då är\n"
#~ "SMALL(A1:A5;2) lika med 17,3.\n"
#~ "SMALL(A1:A5;4) lika med 25,9.\n"
#~ "\n"
#~ "@SEEALSO=PERCENTILE,PERCENTRANK,QUARTILE,LARGE"

#~ msgid ""
#~ "@FUNCTION=PROB\n"
#~ "@SYNTAX=PROB(x_range,prob_range,lower_limit[,upper_limit])\n"
#~ "@DESCRIPTION=PROB function returns the probability that values in a range "
#~ "or an array are between two limits. If @upper_limit is not given, PROB "
#~ "returns the probability that values in @x_range are equal to "
#~ "@lower_limit.\n"
#~ "\n"
#~ "* If the sum of the probabilities in @prob_range is not equal to 1 PROB "
#~ "returns #NUM! error.\n"
#~ "* If any value in @prob_range is <=0 or > 1, PROB returns #NUM! error.\n"
#~ "* If @x_range and @prob_range contain a different number of data entries, "
#~ "PROB returns #N/A error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=BINOMDIST,CRITBINOM"
#~ msgstr ""
#~ "@FUNCTION=PROB\n"
#~ "@SYNTAX=PROB(x-område;sannolikhetsområde;undre_gräns[;övre_gräns])\n"
#~ "@DESCRIPTION=Funktionen PROB returnerar sannolikheten att värdena i ett "
#~ "område eller en vektor är mellan två gränser. Om @övre_gräns inte är "
#~ "angivet returnerar PROB sannolikheten att värdena i @x-område är lika med "
#~ "@undre_gräns.\n"
#~ "\n"
#~ "* Om summan av sannolikheterna i @sannolikhetsområde inte är lika med 1 "
#~ "returnerar PROB felvärdet #NUM!.\n"
#~ "* Om något värde i @sannolikhetsområde är <= 0 eller > 1 returnerar\n"
#~ "PROB felvärdet #NUM!.\n"
#~ "* Om @x-område och @sannolikhetsområde innehåller olika antal dataposter\n"
#~ "returnerar PROB felvärdet #-.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=BINOMDIST,CRITBINOM"

#~ msgid ""
#~ "@FUNCTION=STEYX\n"
#~ "@SYNTAX=STEYX(known_y's,known_x's)\n"
#~ "@DESCRIPTION=STEYX function returns the standard error of the predicted y-"
#~ "value for each x in the regression.\n"
#~ "\n"
#~ "* If @known_y's and @known_x's are empty or have a different number of "
#~ "arguments then STEYX returns #N/A error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1, and the cells B1, B2, ... B5 23.2, 25.8, 29.9, "
#~ "33.5, and 42.7.  Then\n"
#~ "STEYX(A1:A5,B1:B5) equals 1.101509979.\n"
#~ "\n"
#~ "@SEEALSO=PEARSON,RSQ,SLOPE"
#~ msgstr ""
#~ "@FUNCTION=STEYX\n"
#~ "@SYNTAX=STEYX(kända_y;kända_x)\n"
#~ "@DESCRIPTION=Funktionen STEYX returnerar standardfelet för det spådda y-"
#~ "värdet för varje x i en regression.\n"
#~ "\n"
#~ "* Om @kända_y och @kända_x är tomma eller har olika antal argument "
#~ "returnerar STEYX felvärdet #-.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att cellerna A1; A2; ...; A5 innehåller talen 11,4; 17,3; 21,3; "
#~ "25,9 och 40,1; och cellerna B1; B2; ... B5 23,2; 25,8; 29,9; 33,5 och "
#~ "42,7. Då är\n"
#~ "STEYX(A1:A5;B1:B5) lika med 1,101509979.\n"
#~ "\n"
#~ "@SEEALSO=PEARSON,RSQ,SLOPE"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=ZTEST\n"
#~ "@SYNTAX=ZTEST(ref,x[,stddev])\n"
#~ "@DESCRIPTION=ZTEST returns the two-tailed probability of a z-test.\n"
#~ "\n"
#~ "@ref is the data set and @x is the value to be tested.\n"
#~ "@stddev is optionally an assumed standard deviation.\n"
#~ "\n"
#~ "* If @ref contains less than two data items ZTEST returns #DIV/0! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "ZTEST(A1:A5,20) equals 0.254717826.\n"
#~ "\n"
#~ "@SEEALSO=CONFIDENCE,NORMDIST,NORMINV,NORMSDIST,NORMSINV,STANDARDIZE"
#~ msgstr ""
#~ "@FUNCTION=ZTEST\n"
#~ "@SYNTAX=ZTEST(ref;x)\n"
#~ "@DESCRIPTION=ZTEST returnerar den tvåsvansade sannolikheten av ett z-"
#~ "test.\n"
#~ "\n"
#~ "@ref är datamängden och @x är det värde som ska testas.\n"
#~ "\n"
#~ "* Om @ref innehåller färre än två dataposter returnerar ZTEST felvärdet "
#~ "#DIV/0!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att cellerna A1; A2; ...; A5 innehåller talen 11,4; 17,3; 21,3; "
#~ "25,9 och 40,1. Då är\n"
#~ "ZTEST(A1:A5;20) lika med 0,254717826.\n"
#~ "\n"
#~ "@SEEALSO=CONFIDENCE,NORMDIST,NORMINV,NORMSDIST,NORMSINV,STANDARDIZE"

#~ msgid ""
#~ "@FUNCTION=AVERAGEA\n"
#~ "@SYNTAX=AVERAGEA(number1,number2,...)\n"
#~ "@DESCRIPTION=AVERAGEA returns the average of the given arguments.  "
#~ "Numbers, text and logical values are included in the calculation too. If "
#~ "the cell contains text or the argument evaluates to FALSE, it is counted "
#~ "as value zero (0).  If the argument evaluates to TRUE, it is counted as "
#~ "one (1).  Note that empty cells are not counted.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers and strings "
#~ "11.4, 17.3, \"missing\", 25.9, and 40.1.  Then\n"
#~ "AVERAGEA(A1:A5) equals 18.94.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE"
#~ msgstr ""
#~ "@FUNCTION=AVERAGEA\n"
#~ "@SYNTAX=AVERAGEA(tal1;tal2;...)\n"
#~ "@DESCRIPTION=AVERAGEA returnerar medelvärdet av alla argument. Tal, text "
#~ "och logiska värden inkluderas även de i beräkningen. Om cellen innehåller "
#~ "text eller om argumenten evalueras till FALSKT, räknas de som noll (0). "
#~ "Om ett argument evalueras till SANT, räknas det som 1. Observera att "
#~ "tomma celler inte räknas.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att cellerna A1; A2; ...; A5 innehåller talen och strängarna 11,4; "
#~ "17,3; \"saknas\"; 25,9 och 40,1. Då är\n"
#~ "AVERAGEA(A1:A5) lika med 18,94.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE"

#~ msgid ""
#~ "@FUNCTION=MAXA\n"
#~ "@SYNTAX=MAXA(number1,number2,...)\n"
#~ "@DESCRIPTION=MAXA returns the largest value of the given arguments.  "
#~ "Numbers, text and logical values are included in the calculation too. If "
#~ "the cell contains text or the argument evaluates to FALSE, it is counted "
#~ "as value zero (0).  If the argument evaluates to TRUE, it is counted as "
#~ "one (1).  Note that empty cells are not counted.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers and strings "
#~ "11.4, 17.3, \"missing\", 25.9, and 40.1.  Then\n"
#~ "MAXA(A1:A5) equals 40.1.\n"
#~ "\n"
#~ "@SEEALSO=MAX,MINA"
#~ msgstr ""
#~ "@FUNCTION=MAXA\n"
#~ "@SYNTAX=MAXA(tal1;tal2;...)\n"
#~ "@DESCRIPTION=MAXA returnerar det största värdet bland alla argument. Tal, "
#~ "text och logiska värden inkluderas även de i beräkningen. Om cellen "
#~ "innehåller text eller om argumenten evalueras till FALSKT, räknas de som "
#~ "noll (0). Om ett argument evalueras till SANT, räknas det som 1. "
#~ "Observera att tomma celler inte räknas.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att cellerna A1; A2; ...; A5 innehåller talen och strängarna 11,4; "
#~ "17,3; \"saknas\"; 25,9 och 40,1. Då är\n"
#~ "MAXA(A1:A5) lika med 40,1.\n"
#~ "\n"
#~ "@SEEALSO=MAX,MINA"

#~ msgid ""
#~ "@FUNCTION=MINA\n"
#~ "@SYNTAX=MINA(number1,number2,...)\n"
#~ "@DESCRIPTION=MINA returns the smallest value of the given arguments.  "
#~ "Numbers, text and logical values are included in the calculation too. If "
#~ "the cell contains text or the argument evaluates to FALSE, it is counted "
#~ "as value zero (0).  If the argument evaluates to TRUE, it is counted as "
#~ "one (1).  Note that empty cells are not counted.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers and strings "
#~ "11.4, 17.3, \"missing\", 25.9, and 40.1.  Then\n"
#~ "MINA(A1:A5) equals 0.\n"
#~ "\n"
#~ "@SEEALSO=MIN,MAXA"
#~ msgstr ""
#~ "@FUNCTION=MINA\n"
#~ "@SYNTAX=MINA(tal1;tal2;...)\n"
#~ "@DESCRIPTION=MINA returnerar det största värdet bland alla argument. Tal, "
#~ "text och logiska värden inkluderas även de i beräkningen. Om cellen "
#~ "innehåller text eller om argumenten evalueras till FALSKT, räknas de som "
#~ "noll (0). Om ett argument evalueras till SANT, räknas det som 1. "
#~ "Observera att tomma celler inte räknas.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att cellerna A1; A2; ...; A5 innehåller talen och strängarna 11,4; "
#~ "17,3; \"saknas\"; 25,9 och 40,1. Då är\n"
#~ "MINA(A1:A5) lika med 0.\n"
#~ "\n"
#~ "@SEEALSO=MIN,MAXA"

#~ msgid ""
#~ "@FUNCTION=VARA\n"
#~ "@SYNTAX=VARA(number1,number2,...)\n"
#~ "@DESCRIPTION=VARA calculates sample variance of the given sample.\n"
#~ "To get the true variance of a complete population use VARPA.\n"
#~ "VARA is also known as the N-1-variance.\n"
#~ "Under reasonable conditions, it is the maximum-likelihood estimator for "
#~ "the true variance.\n"
#~ "Numbers, text and logical values are included in the calculation too. If "
#~ "the cell contains text or the argument evaluates to FALSE, it is counted "
#~ "as value zero (0).  If the argument evaluates to TRUE, it is counted as "
#~ "one (1).  Note that empty cells are not counted.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers and strings "
#~ "11.4, 17.3, \"missing\", 25.9, and 40.1.  Then\n"
#~ "VARA(A1:A5) equals 228.613.\n"
#~ "\n"
#~ "@SEEALSO=VAR,VARPA"
#~ msgstr ""
#~ "@FUNCTION=VARA\n"
#~ "@SYNTAX=VARA(tal1;tal2;...)\n"
#~ "@DESCRIPTION=VARA returnerar variansen baserat på det givna provet.\n"
#~ "Använd VARPA för att få den riktiga variansen av en komplett population.\n"
#~ "VARA är även känd som N-1-varians.\n"
#~ "Med rimliga betingelser är detta maximum-likelihood uppskattningen av den "
#~ "riktiga variansen.\n"
#~ "Tal, text och logiska värden inkluderas även de i beräkningen. Om cellen "
#~ "innehåller text eller om argumenten evalueras till FALSKT, räknas de som "
#~ "noll (0). Om ett argument evalueras till SANT, räknas det som 1. "
#~ "Observera att tomma celler inte räknas.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att cellerna A1; A2; ...; A5 innehåller talen och strängarna 11,4; "
#~ "17,3; \"saknas\"; 25,9 och 40,1. Då är\n"
#~ "VARA(A1:A5) lika med 228,613.\n"
#~ "\n"
#~ "@SEEALSO=VAR,VARPA"

#~ msgid ""
#~ "@FUNCTION=VARPA\n"
#~ "@SYNTAX=VARPA(number1,number2,...)\n"
#~ "@DESCRIPTION=VARPA calculates the variance of an entire population.\n"
#~ "VARPA is also known as the N-variance.\n"
#~ "Numbers, text and logical values are included in the calculation too.  If "
#~ "the cell contains text or the argument evaluates to FALSE, it is counted "
#~ "as value zero (0).  If the argument evaluates to TRUE, it is counted as "
#~ "one (1).  Note that empty cells are not counted.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers and strings "
#~ "11.4, 17.3, \"missing\", 25.9, and 40.1.  Then\n"
#~ "VARPA(A1:A5) equals 182.8904.\n"
#~ "\n"
#~ "@SEEALSO=VARA,VARP"
#~ msgstr ""
#~ "@FUNCTION=VARPA\n"
#~ "@SYNTAX=VARPA(tal1;tal2;...)\n"
#~ "@DESCRIPTION=VARPA returnerar variansen baserat på hela populationen.\n"
#~ "VARPA är även känd som N-variansen.\n"
#~ "Tal, text och logiska värden inkluderas även de i beräkningen. Om cellen "
#~ "innehåller text eller om argumenten evalueras till FALSKT, räknas de som "
#~ "noll (0). Om ett argument evalueras till SANT, räknas det som 1. "
#~ "Observera att tomma celler inte räknas.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att cellerna A1; A2; ...; A5 innehåller talen och strängarna 11,4; "
#~ "17,3; \"saknas\"; 25,9 och 40,1. Då är\n"
#~ "VARPA(A1:A5) lika med 182,8904.\n"
#~ "\n"
#~ "@SEEALSO=VARA,VARP"

#~ msgid ""
#~ "@FUNCTION=STDEVA\n"
#~ "@SYNTAX=STDEVA(number1,number2,...)\n"
#~ "@DESCRIPTION=STDEVA returns the sample standard deviation of the given "
#~ "sample.\n"
#~ "To obtain the population standard deviation of a whole population use "
#~ "STDEVPA.\n"
#~ "STDEVA is also known as the N-1-standard deviation.\n"
#~ "Under reasonable conditions, it is the maximum-likelihood estimator for "
#~ "the true population standard deviation.\n"
#~ "Numbers, text and logical values are included in the calculation too.  If "
#~ "the cell contains text or the argument evaluates to FALSE, it is counted "
#~ "as value zero (0).  If the argument evaluates to TRUE, it is counted as "
#~ "one (1).  Note that empty cells are not counted.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers and strings "
#~ "11.4, 17.3, \"missing\", 25.9, and 40.1.  Then\n"
#~ "STDEVA(A1:A5) equals 15.119953704.\n"
#~ "\n"
#~ "@SEEALSO=STDEV,STDEVPA"
#~ msgstr ""
#~ "@FUNCTION=STDEVA\n"
#~ "@SYNTAX=STDEVA(tal1;tal2;...)\n"
#~ "@DESCRIPTION=STDEVA returnerar standardavvikelsen baserat på det givna "
#~ "provet.\n"
#~ "Använd STDEVPA för att få standardavvikelsen av en komplett population.\n"
#~ "STDEVA är även känd som N-1-standardavvikelsen.\n"
#~ "Med rimliga betingelser är detta maximum-likelihood uppskattningen av den "
#~ "riktiga standardavvikelsen.\n"
#~ "Tal, text och logiska värden inkluderas även de i beräkningen. Om cellen "
#~ "innehåller text eller om argumenten evalueras till FALSKT, räknas de som "
#~ "noll (0). Om ett argument evalueras till SANT, räknas det som 1. "
#~ "Observera att tomma celler inte räknas.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att cellerna A1; A2; ...; A5 innehåller talen och strängarna 11,4; "
#~ "17,3; \"saknas\"; 25,9 och 40,1. Då är\n"
#~ "STDEVA(A1:A5) lika med 15,119953704.\n"
#~ "\n"
#~ "@SEEALSO=STDEV,STDEVPA"

#~ msgid ""
#~ "@FUNCTION=STDEVPA\n"
#~ "@SYNTAX=STDEVPA(number1,number2,...)\n"
#~ "@DESCRIPTION=STDEVPA returns the population standard deviation of an "
#~ "entire population.\n"
#~ "This is also known as the N-standard deviation\n"
#~ "Numbers, text and logical values are included in the calculation too.  If "
#~ "the cell contains text or the argument evaluates to FALSE, it is counted "
#~ "as value zero (0).  If the argument evaluates to TRUE, it is counted as "
#~ "one (1).  Note that empty cells are not counted.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers and strings "
#~ "11.4, 17.3, \"missing\", 25.9, and 40.1.  Then\n"
#~ "STDEVPA(A1:A5) equals 13.523697719.\n"
#~ "\n"
#~ "@SEEALSO=STDEVA,STDEVP"
#~ msgstr ""
#~ "@FUNCTION=STDEVPA\n"
#~ "@SYNTAX=STDEVPA(tal1;tal2;...)\n"
#~ "@DESCRIPTION=STDEVPA returnerar standardavvikelsen baserat på hela "
#~ "populationen.\n"
#~ "Detta är även känt som N-standardavvikelsen.\n"
#~ "Tal, text och logiska värden inkluderas även de i beräkningen. Om cellen "
#~ "innehåller text eller om argumenten evalueras till FALSKT, räknas de som "
#~ "noll (0). Om ett argument evalueras till SANT, räknas det som 1. "
#~ "Observera att tomma celler inte räknas.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att cellerna A1; A2; ...; A5 innehåller talen och strängarna 11,4; "
#~ "17,3; \"saknas\"; 25,9 och 40,1. Då är\n"
#~ "STDEVPA(A1:A5) lika med 13,523697719.\n"
#~ "\n"
#~ "@SEEALSO=STDEVA,STDEVP"

#~ msgid ""
#~ "@FUNCTION=PERCENTRANK\n"
#~ "@SYNTAX=PERCENTRANK(array,x[,significance])\n"
#~ "@DESCRIPTION=PERCENTRANK function returns the rank of a data point in a "
#~ "data set.  @array is the range of numeric values, @x is the data point "
#~ "which you want to rank, and the optional @significance specifies the "
#~ "number of significant digits for the returned value, truncating the "
#~ "remainder.  If @significance is omitted, PERCENTRANK uses three digits.\n"
#~ "\n"
#~ "* If @array contains no data points, PERCENTRANK returns #NUM! error.\n"
#~ "* If @significance is less than one, PERCENTRANK returns #NUM! error.\n"
#~ "* If @x exceeds the largest value or is less than the smallest value in "
#~ "@array, PERCENTRANK returns #NUM! error.\n"
#~ "* If @x does not match any of the values in @array or @x matches more "
#~ "than once, PERCENTRANK interpolates the returned value.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=LARGE,MAX,MEDIAN,MIN,PERCENTILE,QUARTILE,SMALL"
#~ msgstr ""
#~ "@FUNCTION=PERCENTRANK\n"
#~ "@SYNTAX=PERCENTRANK(vektor;x[;signifikans])\n"
#~ "@DESCRIPTION=Funktionen PERCENTRANK returnerar rangen för en datapunkt i "
#~ "en datamängd. @vektor är området med numeriska värden, @x är datapunkten "
#~ "som du vill ha rangen för, och @signifikans (som är valfri) är antalet "
#~ "signifikanta siffror för det returnerade värdet, där resten trunkeras. Om "
#~ "@signifikans utelämnas använder PERCENTRANK tre siffror.\n"
#~ "\n"
#~ "* Om @vektor inte innehåller några datapunkter returnerar PERCENTRANK "
#~ "felvärdet #NUM!.\n"
#~ "* Om @signifikans är mindre än ett returnerar PERCENTRANK felvärdet "
#~ "#NUM!.\n"
#~ "* Om @x är större än det största värdet eller ar mindre än det minsta "
#~ "värdet i @vektor returnerar PERCENTRANK felvärdet #NUM!.\n"
#~ "* Om @x inte matchar något värde i @vektor eller om @x matchar mer än en "
#~ "gång interpolerar PERCENTRANK det returnerade värdet.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=LARGE,MAX,MEDIAN,MIN,PERCENTILE,QUARTILE,SMALL"

#~ msgid ""
#~ "@FUNCTION=PERCENTILE\n"
#~ "@SYNTAX=PERCENTILE(array,k)\n"
#~ "@DESCRIPTION=PERCENTILE function returns the 100*@k-th percentile of the "
#~ "given data points (that is, a number x such that a fraction @k of the "
#~ "data points are less than x).\n"
#~ "\n"
#~ "* If @array is empty, PERCENTILE returns #NUM! error.\n"
#~ "* If @k < 0 or @k > 1, PERCENTILE returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "PERCENTILE(A1:A5,0.42) equals 20.02.\n"
#~ "\n"
#~ "@SEEALSO=QUARTILE"
#~ msgstr ""
#~ "@FUNCTION=PERCENTILE\n"
#~ "@SYNTAX=PERCENTILE(vektor;k)\n"
#~ "@DESCRIPTION=Funktionen PERCENTILE returnerar den 100*@k:e percentilen av "
#~ "de givna datapunkterna (dvs ett tal x sådant att bråkdelen @k av "
#~ "datapunkterna är mindre än x).\n"
#~ "\n"
#~ "* Om @vektor är tom returnerar PERCENTILE felvärdet #NUM!.\n"
#~ "* Om @k < 0 eller @k > 1 returnerar PERCENTILE felvärdet #NUM!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att cellerna A1; A2; ...; A5 innehåller talen 11,4; 17,3; 21,3; "
#~ "25,9 och 40,1. Då är\n"
#~ "PERCENTILE(A1:A5;0,42) lika med 20,02.\n"
#~ "\n"
#~ "@SEEALSO=QUARTILE"

#~ msgid ""
#~ "@FUNCTION=QUARTILE\n"
#~ "@SYNTAX=QUARTILE(array,quart)\n"
#~ "@DESCRIPTION=QUARTILE function returns the quartile of the given data "
#~ "points.\n"
#~ "\n"
#~ "If @quart is equal to: QUARTILE returns:\n"
#~ "0                      the smallest value of @array.\n"
#~ "1                      the first quartile\n"
#~ "2                      the second quartile\n"
#~ "3                      the third quartile\n"
#~ "4                      the largest value of @array.\n"
#~ "\n"
#~ "* If @array is empty, QUARTILE returns #NUM! error.\n"
#~ "* If @quart < 0 or @quart > 4, QUARTILE returns #NUM! error.\n"
#~ "* If @quart is not an integer, it is truncated.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "QUARTILE(A1:A5,1) equals 17.3.\n"
#~ "\n"
#~ "@SEEALSO=LARGE,MAX,MEDIAN,MIN,PERCENTILE,SMALL"
#~ msgstr ""
#~ "@FUNCTION=QUARTILE\n"
#~ "@SYNTAX=QUARTILE(vektor;kvart)\n"
#~ "@DESCRIPTION=Funktionen QUARTILE returnerar kvartilen av de givna "
#~ "datapunkterna.\n"
#~ "\n"
#~ "Om @kvart är lika med: returnerar QUARTILE:\n"
#~ "0                      det minsta värdet i @vektor.\n"
#~ "1                      den första kvartilen\n"
#~ "2                      den andra kvartilen\n"
#~ "3                      den tredje kvartilen\n"
#~ "4                      det största värdet i @vektor.\n"
#~ "\n"
#~ "* Om @vektor är tom returnerar QUARTILE felvärdet #NUM!.\n"
#~ "* Om @kvart < 0 eller @kvart > 4 returnerar QUARTILE felvärdet #NUM!.\n"
#~ "* Om @kvart inte är ett heltal trunkeras det.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att cellerna A1; A2; ...; A5 innehåller talen 11,4; 17,3; 21,3; "
#~ "25,9 och 40,1. Då är\n"
#~ "QUARTILE(A1:A5;1) lika med 17,3.\n"
#~ "\n"
#~ "@SEEALSO=LARGE,MAX,MEDIAN,MIN,PERCENTILE,SMALL"

#~ msgid ""
#~ "@FUNCTION=FTEST\n"
#~ "@SYNTAX=FTEST(array1,array2)\n"
#~ "@DESCRIPTION=FTEST function returns the two-tailed probability that the "
#~ "variances in the given two data sets are not significantly different.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1, and the cells B1, B2, ... B5 23.2, 25.8, 29.9, "
#~ "33.5, and 42.7.  Then\n"
#~ "FTEST(A1:A5,B1:B5) equals 0.510815017.\n"
#~ "\n"
#~ "@SEEALSO=FDIST,FINV"
#~ msgstr ""
#~ "@FUNCTION=FTEST\n"
#~ "@SYNTAX=FTEST(vektor1;vektor2)\n"
#~ "@DESCRIPTION=Funktionen FTEST returnerar den tvåsvansade sannolikheten "
#~ "att varianserna i de två givna datamängderna inte är signifikant olika.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att cellerna A1; A2; ...; A5 innehåller talen 11,4; 17,3; 21,3; "
#~ "25,9 och 40,1; och cellerna B1; B2; ... B5 23,2; 25,8; 29,9; 33,5 och "
#~ "42,7. Då är\n"
#~ "FTEST(A1:A5;B1:B5) lika med 0,510815017.\n"
#~ "\n"
#~ "@SEEALSO=FDIST,FINV"

#~ msgid ""
#~ "@FUNCTION=TTEST\n"
#~ "@SYNTAX=TTEST(array1,array2,tails,type)\n"
#~ "@DESCRIPTION=TTEST function returns the probability of a Student's t-"
#~ "Test. \n"
#~ "@array1 is the first data set and @array2 is the second data set.  If "
#~ "@tails is one, TTEST uses the one-tailed distribution and if @tails is "
#~ "two, TTEST uses the two-tailed distribution.  @type determines the kind "
#~ "of the test:\n"
#~ "\n"
#~ "\t1  Paired test\n"
#~ "\t2  Two-sample equal variance\n"
#~ "\t3  Two-sample unequal variance\n"
#~ "\n"
#~ "* If the data sets contain a different number of data points and the test "
#~ "is paired (@type one), TTEST returns the #N/A error.\n"
#~ "* @tails and @type are truncated to integers.\n"
#~ "* If @tails is not one or two, TTEST returns #NUM! error.\n"
#~ "* If @type is any other than one, two, or three, TTEST returns #NUM! "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1, and the cells B1, B2, ... B5 23.2, 25.8, 29.9, "
#~ "33.5, and 42.7.  Then\n"
#~ "TTEST(A1:A5,B1:B5,1,1) equals 0.003127619.\n"
#~ "TTEST(A1:A5,B1:B5,2,1) equals 0.006255239.\n"
#~ "TTEST(A1:A5,B1:B5,1,2) equals 0.111804322.\n"
#~ "TTEST(A1:A5,B1:B5,1,3) equals 0.113821797.\n"
#~ "\n"
#~ "@SEEALSO=FDIST,FINV"
#~ msgstr ""
#~ "@FUNCTION=TTEST\n"
#~ "@SYNTAX=TTEST(vektor1;vektor2;svansar;typ)\n"
#~ "@DESCRIPTION=Funktionen TTEST returnerar sannolikheten för en Students t-"
#~ "test.\n"
#~ "@vektor1 är den första datamängden och @vektor2 är den andra datamängden. "
#~ "Om @svansar är ett använder TTEST den ensvansade fördelningen och om "
#~ "@svansar är två använder TTEST den tvåsvansade fördelningen. @typ avgör "
#~ "typen av test:\n"
#~ "\n"
#~ "\t1  Parat test\n"
#~ "\t2  Tvåprovs lika varians\n"
#~ "\t3  Tvåprovs olika varians\n"
#~ "\n"
#~ "* Om datamängderna innehåller olika antal datapunkter och testet är parat "
#~ "(@typ ett) returnerar TTEST felvärdet #-.\n"
#~ "* @svansar och @typ trunkeras till heltal.\n"
#~ "* Om @svansar inte är ett eller två returnerar TTEST felvärdet #NUM!.\n"
#~ "* Om @typ varken är ett, två eller tre returnerar TTEST felvärdet #NUM!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att cellerna A1; A2; ...; A5 innehåller talen 11,4; 17,3; 21,3; "
#~ "25,9 och 40,1; och cellerna B1; B2; ... B5 23,2; 25,8; 29,9; 33,5 och "
#~ "42,7. Då är\n"
#~ "TTEST(A1:A5;B1:B5;1;1) lika med 0,003127619.\n"
#~ "TTEST(A1:A5;B1:B5;2;1) lika med 0,006255239.\n"
#~ "TTEST(A1:A5;B1:B5;1;2) lika med 0,111804322.\n"
#~ "TTEST(A1:A5;B1:B5;1;3) lika med 0,113821797.\n"
#~ "\n"
#~ "@SEEALSO=FDIST,FINV"

#~ msgid ""
#~ "@FUNCTION=FREQUENCY\n"
#~ "@SYNTAX=FREQUENCY(data_array,bins_array)\n"
#~ "@DESCRIPTION=FREQUENCY function counts how often given values occur "
#~ "within a range of values.  The results are given as an array.\n"
#~ "\n"
#~ "@data_array is a data array for which you want to count the frequencies.  "
#~ "@bin_array is an array containing the intervals into which you want to "
#~ "group the values in data_array.  If the @bin_array is empty, FREQUENCY "
#~ "returns the number of data points in @data_array.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=FREQUENCY\n"
#~ "@SYNTAX=FREQUENCY(datavektor;högvektor)\n"
#~ "@DESCRIPTION=Funktionen FREQUENCY räknar hur ofta givna värden förekommer "
#~ "inom ett område med värden. Resultaten ges som en vektor.\n"
#~ "\n"
#~ "@datavektor är den datavektor för vilken du vill räkna frekvenserna. "
#~ "@högvektor är en vektor som innehåller intervallen i vilka du vill "
#~ "gruppera värdena i @datavektor. Om @högvektor är tom returnerar FREQUENCY "
#~ "antalet datapunkter i @datavektor.\n"
#~ "Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=LINEST\n"
#~ "@SYNTAX=LINEST(known_y's[,known_x's[,const[,stat]]])\n"
#~ "@DESCRIPTION=LINEST function calculates the ``least squares'' line that "
#~ "best fit to your data in @known_y's.  @known_x's contains the "
#~ "corresponding x's where y=mx+b.\n"
#~ "\n"
#~ "LINEST returns an array having two columns and one row.  The slope (m) of "
#~ "the regression line y=mx+b is given in the first column and the y-"
#~ "intercept (b) in the second.\n"
#~ "\n"
#~ "If @stat is TRUE, extra statistical information will be returned. Extra "
#~ "statistical information is written below the regression line coefficients "
#~ "in the result array.  Extra statistical information consists of four rows "
#~ "of data.  In the first row the standard error values for the coefficients "
#~ "m1, (m2, ...), b are represented.  The second row contains the square of "
#~ "R and the standard error for the y estimate.  The third row contains the "
#~ "F-observed value and the degrees of freedom.  The last row contains the "
#~ "regression sum of squares and the residual sum of squares.\n"
#~ "\n"
#~ "* If @known_x's is omitted, an array {1, 2, 3, ...} is used.\n"
#~ "* If @known_y's and @known_x's have unequal number of data points, LINEST "
#~ "returns #NUM! error.\n"
#~ "* If @const is FALSE, the line will be forced to go through the origin, i."
#~ "e., b will be zero. The default is TRUE.\n"
#~ "* The default of @stat is FALSE.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=LOGEST,TREND"
#~ msgstr ""
#~ "@FUNCTION=LINEST\n"
#~ "@SYNTAX=LINEST(kända_y[;kända_x[;konstant[;stat]]])\n"
#~ "@DESCRIPTION=Funktionen LINEST beräknar den \"minsta kvadraten\"-linje "
#~ "som bäst passar din data i @kända_y. @kända_x innehåller motsvarande x "
#~ "där y=mx+b.\n"
#~ "\n"
#~ "LINEST returnerar en vektor som har två kolumner och en rad. Lutningen "
#~ "(m) på regressionslinjen y=mx+b anges i den första kolumnen och  y-"
#~ "avståndet (b) i den andra.\n"
#~ "\n"
#~ "Om @stat är SANT kommer extra statistisk information att returneras. "
#~ "Extra statistisk information skrivs under regressionslinjens "
#~ "koefficienter i resultatvektorn. Extra statistisk information består av "
#~ "fyra rader med data. I den första raden visas standardfelvärdena för "
#~ "koefficienterna m1; (m2; ...) och b. Den andra raden innehåller kvadraten "
#~ "av R och standardfelet för y-uppskattningen. Den tredje raden innehåller "
#~ "det observerade F-värdet och frihetsgraderna. Den sista raden innehåller "
#~ "regressionssumman av kvadraterna och den resterande summan av "
#~ "kvadraterna.\n"
#~ "\n"
#~ "* Om @kända_x utelämnas används en vektor med {1; 2; 3; ...}.\n"
#~ "* Om @kända_y och @kända_x har olika antal datapunkter returnerar LINEST "
#~ "felvärdet #NUM!.\n"
#~ "* Om @konstant är FALSKT kommer linjen att tvingas gå igenom origo; dvs b "
#~ "kommer att vara noll. Standardvärdet är SANT.\n"
#~ "* Standardvärdet för @stat är FALSKT.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=LOGEST,TREND"

#~ msgid ""
#~ "@FUNCTION=LOGREG\n"
#~ "@SYNTAX=LOGREG(known_y's[,known_x's[,const[,stat]]])\n"
#~ "@DESCRIPTION=LOGREG function transforms your x's to z=ln(x) and applies "
#~ "the ``least squares'' method to fit the linear equation\n"
#~ "y = m * z + b \n"
#~ "to your y's and z's --- equivalent to fitting the equation\n"
#~ "y = m * ln(x) + b \n"
#~ "to y's and x's. \n"
#~ "\n"
#~ "If @known_x's is omitted, an array {1, 2, 3, ...} is used. LOGREG returns "
#~ "an array having two columns and one row. m is given in the first column "
#~ "and b in the second. \n"
#~ "\n"
#~ "If @known_y's and @known_x's have unequal number of data points, LOGREG "
#~ "returns #NUM! error.\n"
#~ "\n"
#~ "If @const is FALSE, the curve will be forced to go through [1; 0], i.e., "
#~ "b will be zero. The default is TRUE.\n"
#~ "\n"
#~ "If @stat is TRUE, extra statistical information will be returned which "
#~ "applies to the state AFTER transformation to z. Extra statistical "
#~ "information is written below m and b in the result array.  Extra "
#~ "statistical information consists of four rows of data.  In the first row "
#~ "the standard error values for the coefficients m, b are represented.  The "
#~ "second row contains the square of R and the standard error for the y "
#~ "estimate. The third row contains the F-observed value and the degrees of "
#~ "freedom.  The last row contains the regression sum of squares and the "
#~ "residual sum of squares.The default of @stat is FALSE.\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=LOGFIT,LINEST,LOGEST"
#~ msgstr ""
#~ "@FUNCTION=LOGREG\n"
#~ "@SYNTAX=LOGREG(kända_y[;kända_x[;konstant[;stat]]])\n"
#~ "@DESCRIPTION=Funktionen LOGREG transformerar dina x till z=ln(x) och "
#~ "tillämpar \"minsta kvadratmetoden\" för att passa den linjära funktionen\n"
#~ "y = m * z + b \n"
#~ "till dina y and z --- ekvivalent med att passa till funktionen\n"
#~ "y = m * ln(x) + b \n"
#~ "till y och x. \n"
#~ "\n"
#~ "Om @kända_x utelämnas används en vektor {1; 2; 3; ...}. LOGREG returnerar "
#~ "en vektor med två kolumner och en rad. m ges i den första kolumnen och b "
#~ "i den andra. \n"
#~ "\n"
#~ "Om @kända_y och @kända_x har olika antal datapunkter returnerar LOGREG "
#~ "felvärdet #NUM!.\n"
#~ "\n"
#~ "Om @konstant är FALSKT kommer linjen att tvingas gå igenom [1; 0], dvs b "
#~ "kommer att vara noll. Standardvärdet är SANT.\n"
#~ "\n"
#~ "Om @stat är SANT kommer extra statistisk information att returneras som "
#~ "är applicerbara på tillståndet EFTER transformationen till z. Extra "
#~ "statistisk information skrivs under regressionslinjens koefficienter i "
#~ "resultatvektorn. Extra statistisk information består av fyra rader med "
#~ "data. I den första raden visas standardfelvärdena för koefficienterna m1; "
#~ "b. Den andra raden innehåller kvadraten av R och standardfelet för y-"
#~ "uppskattningen. Den tredje raden innehåller det observerade F-värdet och "
#~ "frihetsgraderna. Den sista raden innehåller regressionssumman av "
#~ "kvadraterna och den resterande summan av kvadraterna. Standardvärdet för "
#~ "@stat är FALSKT.\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=LOGFIT,LINEST,LOGEST"

#~ msgid ""
#~ "@FUNCTION=LOGFIT\n"
#~ "@SYNTAX=LOGFIT(known_y's,known_x's)\n"
#~ "@DESCRIPTION=LOGFIT function applies the ``least squares'' method to fit "
#~ "the logarithmic equation\n"
#~ "y = a + b * ln(sign * (x - c)) ,   sign = +1 or -1 \n"
#~ "to your data. The graph of the equation is a logarithmic curve moved "
#~ "horizontally by c and possibly mirrored across the y-axis (if sign = -"
#~ "1).\n"
#~ "\n"
#~ "LOGFIT returns an array having five columns and one row. `Sign' is given "
#~ "in the first column, `a', `b', and `c' are given in columns 2 to 4. "
#~ "Column 5 holds the sum of squared residuals.\n"
#~ "\n"
#~ "An error is returned when there are less than 3 different x's or y's, or "
#~ "when the shape of the point cloud is too different from a ``logarithmic'' "
#~ "one.\n"
#~ "\n"
#~ "You can use the above formula \n"
#~ "= a + b * ln(sign * (x - c)) \n"
#~ "or rearrange it to \n"
#~ "= (exp((y - a) / b)) / sign + c \n"
#~ "to compute unknown y's or x's, respectively. \n"
#~ "\n"
#~ "Technically, this is non-linear fitting by trial-and-error. The accuracy "
#~ "of `c' is: width of x-range -> rounded to the next smaller (10^integer), "
#~ "times 0.000001. There might be cases in which the returned fit is not the "
#~ "best possible.\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=LOGREG,LINEST,LOGEST"
#~ msgstr ""
#~ "@FUNCTION=LOGFIT\n"
#~ "@SYNTAX=LOGFIT(kända_y;kända_x)\n"
#~ "@DESCRIPTION=Funktionen LOGFIT tillämpar \"minsta kvadratmetoden\" för "
#~ "att passa den logaritmiska funktionen\n"
#~ "y = a + b * ln(tecken * (x - c)) ,   tecken = +1 eller -1 \n"
#~ "till dina data. Ekvationens graf är en logaritmisk kurva flyttad "
#~ "horisontellt av c och möjligen speglad i y-axeln (on tecken = -1).\n"
#~ "\n"
#~ "LOGFIT returnerar ett fält med fem kolumner och en rad. \"tecken\" ges i "
#~ "första kolumnen, \"a\", \"b\" och \"c\" ges i kolumnerna 2 till 4. Kolumn "
#~ "5 innehåller summan av dom kvadrerade residualerna.\n"
#~ "\n"
#~ "Ett fel returneras när det finns mindre än tre x eller y, eller när "
#~ "punktmolnets form är för olik en \"logaritmisk\" form.\n"
#~ "\n"
#~ "Du kan använda det ovanstående uttrycket \n"
#~ "= a + b * ln(tecken * (x - c)) \n"
#~ "eller arrangera om det till \n"
#~ "= (exp((y - a) / b)) / tecken + c \n"
#~ "för att beräkna okända y eller x.\n"
#~ "\n"
#~ "Tekniskt sett är detta iterativ icke-linjär passning. Noggrannheten på \"c"
#~ "\" är: x-områdets bredd -> avrundat till närmaste mindre tiopotens gånger "
#~ "0,000001. Det kan finnas fall då den uppgivna passningen inte är den "
#~ "bästa möjliga.\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=LOGREG,LINEST,LOGEST"

#~ msgid ""
#~ "@FUNCTION=TREND\n"
#~ "@SYNTAX=TREND(known_y's[,known_x's[,new_x's[,const]]])\n"
#~ "@DESCRIPTION=TREND function estimates future values of a given data set "
#~ "using the ``least squares'' line that best fit to your data. @known_y's "
#~ "is the y-values where y=mx+b and @known_x's contains the corresponding x-"
#~ "values.  @new_x's contains the x-values for which you want to estimate "
#~ "the y-values. If @const is FALSE, the line will be forced to go through "
#~ "the origin, i.e., b will be zero.\n"
#~ "\n"
#~ "* If @known_x's is omitted, an array {1, 2, 3, ...} is used.\n"
#~ "* If @new_x's is omitted, it is assumed to be the same as @known_x's.\n"
#~ "* If @const is omitted, it is assumed to be TRUE.\n"
#~ "* If @known_y's and @known_x's have unequal number of data points, TREND "
#~ "returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1, and the cells B1, B2, ... B5 23.2, 25.8, 29.9, "
#~ "33.5, and 42.7.  Then\n"
#~ "TREND(A1:A5,B1:B5) equals {12.1, 15.7, 21.6, 26.7, 39.7}.\n"
#~ "\n"
#~ "@SEEALSO=LINEST"
#~ msgstr ""
#~ "@FUNCTION=TREND\n"
#~ "@SYNTAX=TREND(kända_y[;kända_x;[nya_x[;konst]]])\n"
#~ "@DESCRIPTION=Funktionen TREND beräknar framtida värden för en given "
#~ "datamängd genom att använda den \"minsta kvadrater\"-linje som bäst "
#~ "passar din data. @kända_y är de y-värden där y=mx+b och @kända_x "
#~ "innehåller motsvarande x-värden. @nya_x innehåller x-värdena för vilka du "
#~ "vill uppskatta y-värden. Om @konst är FALSKT, kommer linjen tvingas att "
#~ "gå igenom origo, alltså b blir noll.\n"
#~ "\n"
#~ "* Om @kända_x utelämnas används en vektor med {1; 2; 3; ...}.\n"
#~ "* Om @nya_x utelämnas antas det vara samma som @kända_x.\n"
#~ "* Om @konst utelämnas antas den vara SANT.\n"
#~ "* Om @kända_y och @kända_x har olika antal datapunkter returnerar TREND \n"
#~ "felvärdet #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att cellerna A1; A2; ...; A5 innehåller talen 11,4; 17,3; 21,3; "
#~ "25,9 och 40,1; och cellerna B1; B2; ... B5 23,2; 25,8; 29,9; 33,5 och "
#~ "42,7. Då är\n"
#~ "TREND(A1:A5;B1:B5) lika med {12.1, 15.7, 21.6, 26.7, 39.7}.\n"
#~ "\n"
#~ "@SEEALSO=LINEST"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=LOGEST\n"
#~ "@SYNTAX=LOGEST(known_y's[,known_x's,const,stat])\n"
#~ "@DESCRIPTION=LOGEST function applies the ``least squares'' method to fit "
#~ "an exponential curve of the form\n"
#~ "\n"
#~ "\ty = b * m{1}^x{1} * m{2}^x{2}... to your data.\n"
#~ "\n"
#~ "If @stat is TRUE, extra statistical information will be returned. Extra "
#~ "statistical information is written below the regression line coefficients "
#~ "in the result array.  Extra statistical information consists of four rows "
#~ "of data.  In the first row the standard error values for the coefficients "
#~ "m1, (m2, ...), b are represented.  The second row contains the square of "
#~ "R and the standard error for the y estimate.  The third row contains the "
#~ "F-observed value and the degrees of freedom.  The last row contains the "
#~ "regression sum of squares and the residual sum of squares.\n"
#~ "\n"
#~ "* If @known_x's is omitted, an array {1, 2, 3, ...} is used. LOGEST "
#~ "returns an array { m{n},m{n-1}, ...,m{1},b }.\n"
#~ "* If @known_y's and @known_x's have unequal number of data points, LOGEST "
#~ "returns #NUM! error.\n"
#~ "* If @const is FALSE, the line will be forced to go through (0,1),i.e., b "
#~ "will be one.  The default is TRUE.\n"
#~ "* The default of @stat is FALSE.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=GROWTH,TREND"
#~ msgstr ""
#~ "@FUNCTION=LOGEST\n"
#~ "@SYNTAX=LOGEST(kända_y[;kända_x;konstant;stat])\n"
#~ "@DESCRIPTION=Funktionen LOGEST tillämpar \"minsta kvadratmetoden\" för "
#~ "att passa en exponential funktion av formen\n"
#~ "\n"
#~ "\ty = b * m{1}^x{1} * m{2}^x{2}... till dina data.\n"
#~ "\n"
#~ "Om @stat är SANT kommer extra statistisk information att returneras. "
#~ "Extra statistisk information skrivs under regressionslinjens "
#~ "koefficienter i resultatvektorn. Extra statistisk information består av "
#~ "fyra rader med data. I den första raden visas standardfelvärdena för "
#~ "koefficienterna m1; (m2; ...); b. Den andra raden innehåller kvadraten av "
#~ "R och standardfelet för y-uppskattningen. Den tredje raden innehåller det "
#~ "observerade F-värdet och frihetsgraderna. Den sista raden innehåller "
#~ "regressionssumman av kvadraterna och den resterande summan av "
#~ "kvadraterna.\n"
#~ "\n"
#~ "* Om @kända_x utelämnas används en vektor {1; 2; 3; ...}. LOGEST "
#~ "returnerar en vektor { m{n};m{n-1}; ...;m{1};b }.\n"
#~ "* Om @kända_y och @kända_x har olika antal datapunkter returnerar LOGEST "
#~ "felvärdet #NUM!.\n"
#~ "* Om @konstant är FALSKT kommer linjen att tvingas gå igenom (0;1), dvs b "
#~ "kommer att vara ett. Standardvärdet är SANT.\n"
#~ "* Standardvärdet för @stat är FALSKT.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=GROWTH,TREND"

#~ msgid ""
#~ "@FUNCTION=GROWTH\n"
#~ "@SYNTAX=GROWTH(known_y's[,known_x's,new_x's,const])\n"
#~ "@DESCRIPTION=GROWTH function applies the ``least squares'' method to fit "
#~ "an exponential curve to your data and predicts the exponential growth by "
#~ "using this curve. \n"
#~ "GROWTH returns an array having one column and a row for each data point "
#~ "in @new_x.\n"
#~ "\n"
#~ "* If @known_x's is omitted, an array {1, 2, 3, ...} is used.\n"
#~ "* If @new_x's is omitted, it is assumed to be the same as @known_x's.\n"
#~ "* If @known_y's and @known_x's have unequal number of data points, GROWTH "
#~ "returns #NUM! error.\n"
#~ "* If @const is FALSE, the line will be forced to go through the origin, i."
#~ "e., b will be zero. The default is TRUE.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=LOGEST,GROWTH,TREND"
#~ msgstr ""
#~ "@FUNCTION=GROWTH\n"
#~ "@SYNTAX=GROWTH(kända_y[;kända_x;nya_x;konstant])\n"
#~ "@DESCRIPTION=Funktionen GROWTH tillämpar \"minsta kvadratmetoden\" för "
#~ "att anpassa en exponentialkurva till din data och förutspår den "
#~ "exponentiella tillväxten genom att använda denna kurva.\n"
#~ "GROWTH returnerar en vektor som har en kolumn och en rad för varje "
#~ "datapunkt i @nya_x.\n"
#~ "\n"
#~ "* Om @kända_x utelämnas används en vektor {1; 2; 3; ...}.\n"
#~ "* Om @nya_x utelämnas antas den vara samma som @kända_x.\n"
#~ "* Om @kända_y och @kända_x har olika antal datapunkter returnerar GROWTH "
#~ "felvärdet #NUM!.\n"
#~ "* Om @konstant är FALSKT kommer linjen att tvingas gå igenom origo, dvs b "
#~ "kommer att vara noll. Standardvärdet är SANT.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=LOGEST,GROWTH,TREND"

#~ msgid ""
#~ "@FUNCTION=FORECAST\n"
#~ "@SYNTAX=FORECAST(x,known_y's,known_x's)\n"
#~ "@DESCRIPTION=FORECAST function estimates a future value according to "
#~ "existing values using simple linear regression.  The estimated future "
#~ "value is a y-value for a given x-value (@x).\n"
#~ "\n"
#~ "* If @known_x or @known_y contains no data entries or different number of "
#~ "data entries, FORECAST returns #N/A error.\n"
#~ "* If the variance of the @known_x is zero, FORECAST returns #DIV/0 "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1, and the cells B1, B2, ... B5 23.2, 25.8, 29.9, "
#~ "33.5, and 42.7.  Then\n"
#~ "FORECAST(7,A1:A5,B1:B5) equals -10.859397661.\n"
#~ "\n"
#~ "@SEEALSO=INTERCEPT,TREND"
#~ msgstr ""
#~ "@FUNCTION=FORECAST\n"
#~ "@SYNTAX=FORECAST(x;kända_y;kända_x)\n"
#~ "@DESCRIPTION=Funktionen FORECAST uppskattar ett framtida värde enligt de "
#~ "befintliga värdena genom att använda enkel linjär regression. Det "
#~ "uppskattade framtida värdet är ett y-värde för ett givet x-värde (@x).\n"
#~ "\n"
#~ "* Om @kända_x eller @kända_y innehåller olika antal datapunkter "
#~ "returnerar FORECAST felvärdet #-.\n"
#~ "* Om variansen hos @kända_x är noll returnerar FORECAST felvärdet "
#~ "#DIV/0.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att cellerna A1; A2; ...; A5 innehåller talen 11,4; 17,3; 21,3; "
#~ "25,9 och 40,1; och cellerna B1; B2; ... B5 23,2; 25,8; 29,9; 33,5 och "
#~ "42,7. Då är\n"
#~ "FORECAST(7;A1:A5;B1:B5) lika med -10,859397661.\n"
#~ "\n"
#~ "@SEEALSO=INTERCEPT,TREND"

#~ msgid ""
#~ "@FUNCTION=INTERCEPT\n"
#~ "@SYNTAX=INTERCEPT(known_y's,known_x's)\n"
#~ "@DESCRIPTION=INTERCEPT function calculates the point where the linear "
#~ "regression line intersects the y-axis.\n"
#~ "\n"
#~ "* If @known_x or @known_y contains no data entries or different number of "
#~ "data entries, INTERCEPT returns #N/A error.\n"
#~ "* If the variance of the @known_x is zero, INTERCEPT returns #DIV/0 "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1, and the cells B1, B2, ... B5 23.2, 25.8, 29.9, "
#~ "33.5, and 42.7.  Then\n"
#~ "INTERCEPT(A1:A5,B1:B5) equals -20.785117212.\n"
#~ "\n"
#~ "@SEEALSO=FORECAST,TREND"
#~ msgstr ""
#~ "@FUNCTION=INTERCEPT\n"
#~ "@SYNTAX=INTERCEPT(kända_y;kända_x)\n"
#~ "@DESCRIPTION=Funktionen INTERCEPT beräknar den punkt där den linjära "
#~ "regressionslinjen skär y-axeln.\n"
#~ "\n"
#~ "* Om @kända_x eller @kända_y inte innehåller några datapunkter eller "
#~ "innehåller olika antal datapunkter returnerar INTERCEPT felvärdet #-.\n"
#~ "* Om variansen hos @kända_x är noll returnerar INTERCEPT felvärdet "
#~ "#DIV/0.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att cellerna A1; A2; ...; A5 innehåller talen 11,4; 17,3; 21,3; "
#~ "25,9 och 40,1; och cellerna B1; B2; ... B5 23,2; 25,8; 29,9; 33,5 och "
#~ "42,7. Då är\n"
#~ "INTERCEPT(A1:A5;B1:B5) lika med -20,785117212.\n"
#~ "\n"
#~ "@SEEALSO=FORECAST,TREND"

#~ msgid ""
#~ "@FUNCTION=SLOPE\n"
#~ "@SYNTAX=SLOPE(known_y's,known_x's)\n"
#~ "@DESCRIPTION=SLOPE returns the slope of the linear regression line.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1, and the cells B1, B2, ... B5 23.2, 25.8, 29.9, "
#~ "33.5, and 42.7.  Then\n"
#~ "SLOPE(A1:A5,B1:B5) equals 1.417959936.\n"
#~ "\n"
#~ "@SEEALSO=STDEV,STDEVPA"
#~ msgstr ""
#~ "@FUNCTION=SLOPE\n"
#~ "@SYNTAX=SLOPE(kända_y;kända_x)\n"
#~ "@DESCRIPTION=SLOPE returnerar lutningen på den linjära "
#~ "regressionslinjen.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att cellerna A1; A2; ...; A5 innehåller talen 11,4; 17,3; 21,3; "
#~ "25,9 och 40,1; och cellerna B1; B2; ... B5 23,2; 25,8; 29,9; 33,5 och "
#~ "42,7. Då är\n"
#~ "SLOPE(A1:A5;B1:B5) lika med 1,417959936.\n"
#~ "\n"
#~ "@SEEALSO=STDEV,STDEVPA"

#~ msgid ""
#~ "@FUNCTION=SUBTOTAL\n"
#~ "@SYNTAX=SUBTOTAL(function_nbr,ref1,ref2,...)\n"
#~ "@DESCRIPTION=SUBTOTAL function returns a subtotal of given list of "
#~ "arguments. @function_nbr is the number that specifies which function to "
#~ "use in calculating the subtotal.\n"
#~ "\n"
#~ "The following functions are available:\n"
#~ "\n"
#~ "\t1   AVERAGE\n"
#~ "\t2   COUNT\n"
#~ "\t3   COUNTA\n"
#~ "\t4   MAX\n"
#~ "\t5   MIN\n"
#~ "\t6   PRODUCT\n"
#~ "\t7   STDEV\n"
#~ "\t8   STDEVP\n"
#~ "\t9   SUM\n"
#~ "\t10   VAR\n"
#~ "\t11   VARP\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 23, 27, 28, "
#~ "33, and 39.  Then\n"
#~ "SUBTOTAL(1,A1:A5) equals 30.\n"
#~ "SUBTOTAL(6,A1:A5) equals 22378356.\n"
#~ "SUBTOTAL(7,A1:A5) equals 6.164414003.\n"
#~ "SUBTOTAL(9,A1:A5) equals 150.\n"
#~ "SUBTOTAL(11,A1:A5) equals 30.4.\n"
#~ "\n"
#~ "@SEEALSO=COUNT,SUM"
#~ msgstr ""
#~ "@FUNCTION=SUBTOTAL\n"
#~ "@SYNTAX=SUBTOTAL(funktionsnr;ref1;ref2;...)\n"
#~ "@DESCRIPTION=Funktionen SUBTOTAL tillämpar en funktion på de angivna "
#~ "argumenten. @funktionsnr är ett tal som anger vilken funktion som skall "
#~ "användas.\n"
#~ "\n"
#~ "Följande funktioner finns tillgängliga:\n"
#~ "\n"
#~ "\t1   AVERAGE\n"
#~ "\t2   COUNT\n"
#~ "\t3   COUNTA \n"
#~ "\t4   MAX\n"
#~ "\t5   MIN\n"
#~ "\t6   PRODUCT\n"
#~ "\t7   STDEV\n"
#~ "\t8   STDEVP\n"
#~ "\t9   SUM\n"
#~ "\t10   VAR\n"
#~ "\t11   VARP\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att cellerna A1; A2; ...; A5 innehåller talen 23; 27; 28; 33; och "
#~ "39. Då gäller:\n"
#~ "SUBTOTAL(1;A1:A5) är lika med 30.\n"
#~ "SUBTOTAL(6;A1:A5) är lika med 22378356.\n"
#~ "SUBTOTAL(7;A1:A5) är lika med 6,164414003.\n"
#~ "SUBTOTAL(9;A1:A5) är lika med 150.\n"
#~ "SUBTOTAL(11;A1:A5) är lika med 30,4.\n"
#~ "\n"
#~ "@SEEALSO=COUNT,SUM"

#~ msgid ""
#~ "@FUNCTION=CRONBACH\n"
#~ "@SYNTAX=CRONBACH(ref1,ref2,...)\n"
#~ "@DESCRIPTION=CRONBACH returns Cronbach's alpha for the given cases.\n"
#~ "@ref1 is a data set, @ref2 the second data set, etc..\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=CRONBACH\n"
#~ "@SYNTAX=CRONBACH(ref1;ref2;...)\n"
#~ "@DESCRIPTION=Funktionen CRONBACH returnerar Cronbachs alfa för de givna "
#~ "fallen.\n"
#~ "@ref1 är en datamängd, @ref2 är den andra datamängden, osv...\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=GEOMDIST\n"
#~ "@SYNTAX=GEOMDIST(k,p,cum)\n"
#~ "@DESCRIPTION=GEOMDIST returns the probability p(k) of obtaining @k from a "
#~ "geometric distribution with probability parameter @p.\n"
#~ "\n"
#~ "* If @k < 0 GEOMDIST returns #NUM! error.\n"
#~ "* If @p < 0 or @p > 1 GEOMDIST returns #NUM! error.\n"
#~ "* If @cum != TRUE and @cum != FALSE GEOMDIST returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "GEOMDIST(2,10.4,TRUE).\n"
#~ "\n"
#~ "@SEEALSO=RANDGEOM"
#~ msgstr ""
#~ "@FUNCTION=GEOMDIST\n"
#~ "@SYNTAX=GEOMDIST(k;p;kum)\n"
#~ "@DESCRIPTION=GEOMDIST returnerar sannolikheten p(k) för att @k fås från "
#~ "en geometrisk fördelning med sannolikhetsparametern @p.\n"
#~ "\n"
#~ "* Om @k < 0 returnerar GEOMDIST felvärdet #NUM!.\n"
#~ "* Om @p < 0 eller @p > 1 returnerar GEOMDIST felvärdet #NUM!.\n"
#~ "* Om @kum != SANT och @kum != FALSKT returnerar GEOMDIST felvärdet "
#~ "#NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "GEOMDIST(2;10,4;SANT).\n"
#~ "\n"
#~ "@SEEALSO=RANDGEOM"

#~ msgid ""
#~ "@FUNCTION=LOGISTIC\n"
#~ "@SYNTAX=LOGISTIC(x,a)\n"
#~ "@DESCRIPTION=LOGISTIC returns the probability density p(x) at @x for a "
#~ "logistic distribution with scale parameter @a.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LOGISTIC(0.4,1).\n"
#~ "\n"
#~ "@SEEALSO=RANDLOGISTIC"
#~ msgstr ""
#~ "@FUNCTION=LOGISTIC\n"
#~ "@SYNTAX=LOGISTIC(x;a)\n"
#~ "@DESCRIPTION=LOGISTIC returnerar sannolikhetstätheten p(x) vid @x för en "
#~ "logistisk fördelning med skalparametern @a.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LOGISTIC(0,4;1).\n"
#~ "\n"
#~ "@SEEALSO=RANDLOGISTIC"

#~ msgid ""
#~ "@FUNCTION=PARETO\n"
#~ "@SYNTAX=PARETO(x,a,b)\n"
#~ "@DESCRIPTION=PARETO returns the probability density p(x) at @x for a "
#~ "Pareto distribution with exponent @a and scale @b.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "PARETO(0.6,1,2).\n"
#~ "\n"
#~ "@SEEALSO=RANDPARETO"
#~ msgstr ""
#~ "@FUNCTION=PARETO\n"
#~ "@SYNTAX=PARETO(x;a;b)\n"
#~ "@DESCRIPTION=PARETO returnerar sannolikhetstätheten p(x) vid @x för en "
#~ "Paretofördelning med exponenten @a och skalan @b.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "PARETO(0,6;1;2).\n"
#~ "\n"
#~ "@SEEALSO=RANDPARETO"

#~ msgid ""
#~ "@FUNCTION=RAYLEIGH\n"
#~ "@SYNTAX=RAYLEIGH(x,sigma)\n"
#~ "@DESCRIPTION=RAYLEIGH returns the probability density p(x) at @x for a "
#~ "Rayleigh distribution with scale parameter @sigma.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RAYLEIGH(0.4,1).\n"
#~ "\n"
#~ "@SEEALSO=RANDRAYLEIGH"
#~ msgstr ""
#~ "@FUNCTION=RAYLEIGH\n"
#~ "@SYNTAX=RAYLEIGH(x;sigma)\n"
#~ "@DESCRIPTION=RAYLEIGH returnerar sannolikhetstätheten p(x) vid @x för en "
#~ "Rayleighfördelning med skalparametern @sigma.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RAYLEIGH(0,4;1).\n"
#~ "\n"
#~ "@SEEALSO=RANDRAYLEIGH"

#~ msgid ""
#~ "@FUNCTION=RAYLEIGHTAIL\n"
#~ "@SYNTAX=RAYLEIGHTAIL(x,a,sigma)\n"
#~ "@DESCRIPTION=RAYLEIGHTAIL returns the probability density p(x) at @x for "
#~ "a Rayleigh tail distribution with scale parameter @sigma and lower limit "
#~ "@a.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RAYLEIGHTAIL(0.6,0.3,1).\n"
#~ "\n"
#~ "@SEEALSO=RANDRAYLEIGHTAIL"
#~ msgstr ""
#~ "@FUNCTION=RAYLEIGHTAIL\n"
#~ "@SYNTAX=RAYLEIGHTAIL(x;a;sigma)\n"
#~ "@DESCRIPTION=RAYLEIGHTAIL returnerar sannolikhetstätheten p(x) vid @x för "
#~ "en Rayleighsvansfördelning med skalparametern @sigma och lägre gräns @a.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RAYLEIGHTAIL(0,6;0,3;1).\n"
#~ "\n"
#~ "@SEEALSO=RANDRAYLEIGHTAIL"

#~ msgid ""
#~ "@FUNCTION=LAPLACE\n"
#~ "@SYNTAX=LAPLACE(x,a)\n"
#~ "@DESCRIPTION=LAPLACE returns the probability density p(x) at @x for "
#~ "Laplace distribution with mean @a. \n"
#~ "@EXAMPLES=\n"
#~ "LAPLACE(0.4,1).\n"
#~ "\n"
#~ "@SEEALSO=RANDLAPLACE"
#~ msgstr ""
#~ "@FUNCTION=LAPLACE\n"
#~ "@SYNTAX=LAPLACE(x;a)\n"
#~ "@DESCRIPTION=LAPLACE returnerar sannolikhetstäthet p(x) vid @x för "
#~ "Laplacefördelningen med medelvärde @a.\n"
#~ "@EXAMPLES=\n"
#~ "LAPLACE(0,4;1).\n"
#~ "\n"
#~ "@SEEALSO=RANDLAPLACE"

#~ msgid ""
#~ "@FUNCTION=CHAR\n"
#~ "@SYNTAX=CHAR(x)\n"
#~ "@DESCRIPTION=CHAR returns the ASCII character represented by the number "
#~ "@x.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CHAR(65) equals A.\n"
#~ "\n"
#~ "@SEEALSO=CODE"
#~ msgstr ""
#~ "@FUNCTION=CHAR\n"
#~ "@SYNTAX=CHAR(x)\n"
#~ "@DESCRIPTION=CHAR returnerar ASCII-tecknet som representeras av talet "
#~ "@x.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CHAR(65) är lika med A.\n"
#~ "\n"
#~ "@SEEALSO=CODE"

#~ msgid ""
#~ "@FUNCTION=UNICHAR\n"
#~ "@SYNTAX=UNICHAR(x)\n"
#~ "@DESCRIPTION=UNICHAR returns the Unicode character represented by the "
#~ "number @x.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "UNICHAR(65) equals A.\n"
#~ "UNICHAR(960) equals a small Greek pi.\n"
#~ "\n"
#~ "@SEEALSO=CHAR,UNICODE,CODE"
#~ msgstr ""
#~ "@FUNCTION=UNICHAR\n"
#~ "@SYNTAX=UNICHAR(x)\n"
#~ "@DESCRIPTION=UNICHAR returnerar Unicode-tecknet som representeras av "
#~ "talet @x.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "UNICHAR(65) är lika med A.\n"
#~ "UNICHAR(960) är lika med ett litet grekiskt pi.\n"
#~ "\n"
#~ "@SEEALSO=CHAR,UNICODE,CODE"

#~ msgid ""
#~ "@FUNCTION=CODE\n"
#~ "@SYNTAX=CODE(char)\n"
#~ "@DESCRIPTION=CODE returns the ASCII number for the character @char.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CODE(\"A\") equals 65.\n"
#~ "\n"
#~ "@SEEALSO=CHAR"
#~ msgstr ""
#~ "@FUNCTION=CODE\n"
#~ "@SYNTAX=CODE(tecken)\n"
#~ "@DESCRIPTION=CODE returnerar ASCII-koden för tecknet @tecken.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CODE(\"A\") är lika med 65.\n"
#~ "\n"
#~ "@SEEALSO=CHAR"

#~ msgid ""
#~ "@FUNCTION=UNICODE\n"
#~ "@SYNTAX=UNICODE(char)\n"
#~ "@DESCRIPTION=UNICODE returns the Unicode number for the character @char.\n"
#~ "\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "UNICODE(\"A\") equals 65.\n"
#~ "\n"
#~ "@SEEALSO=UNICHAR,CODE,CHAR"
#~ msgstr ""
#~ "@FUNCTION=UNICODE\n"
#~ "@SYNTAX=UNICODE(tecken)\n"
#~ "@DESCRIPTION=UNICODE returnerar Unicode-koden för tecknet @tecken.\n"
#~ "\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "UNICODE(\"A\") är lika med 65.\n"
#~ "\n"
#~ "@SEEALSO=UNICHAR,CODE,CHAR"

#~ msgid ""
#~ "@FUNCTION=EXACT\n"
#~ "@SYNTAX=EXACT(string1, string2)\n"
#~ "@DESCRIPTION=EXACT returns true if @string1 is exactly equal to @string2 "
#~ "(this routine is case sensitive).\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "EXACT(\"key\",\"key\") equals TRUE.\n"
#~ "EXACT(\"key\",\"Key\") equals FALSE.\n"
#~ "\n"
#~ "@SEEALSO=LEN, SEARCH, DELTA"
#~ msgstr ""
#~ "@FUNCTION=EXACT\n"
#~ "@SYNTAX=EXACT(sträng1; sträng2)\n"
#~ "@DESCRIPTION=EXACT returnerar SANT om @sträng1 är exakt lika med @sträng2 "
#~ "(skiljer på stora/små bokstäver).\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "EXACT(\"nyckel\";\"nyckel\") är lika med SANT.\n"
#~ "EXACT(\"nyckel\";\"Nyckel\") är lika med FALSKT.\n"
#~ "\n"
#~ "@SEEALSO=LEN, SEARCH, DELTA"

#~ msgid ""
#~ "@FUNCTION=LEN\n"
#~ "@SYNTAX=LEN(string)\n"
#~ "@DESCRIPTION=LEN returns the length in characters of the string @string.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LEN(\"Helsinki\") equals 8.\n"
#~ "\n"
#~ "@SEEALSO=CHAR, CODE, LENB"
#~ msgstr ""
#~ "@FUNCTION=LEN\n"
#~ "@SYNTAX=LEN(sträng)\n"
#~ "@DESCRIPTION=LEN returnerar längden i antal tecken av strängen @sträng.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LEN(\"Helsingfors\") är lika med 11.\n"
#~ "\n"
#~ "@SEEALSO=CHAR, CODE, LENB"

#~ msgid ""
#~ "@FUNCTION=LENB\n"
#~ "@SYNTAX=LENB(string)\n"
#~ "@DESCRIPTION=LENB returns the length in bytes of the string @string.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LENB(\"Helsinki\") equals 8.\n"
#~ "\n"
#~ "@SEEALSO=CHAR, CODE, LEN"
#~ msgstr ""
#~ "@FUNCTION=LENB\n"
#~ "@SYNTAX=LENB(sträng)\n"
#~ "@DESCRIPTION=LEN returnerar längden i bytes av strängen @sträng.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LEN(\"Helsingfors\") är lika med 11.\n"
#~ "\n"
#~ "@SEEALSO=CHAR, CODE, LEN"

#~ msgid ""
#~ "@FUNCTION=LEFT\n"
#~ "@SYNTAX=LEFT(text[,num_chars])\n"
#~ "@DESCRIPTION=LEFT returns the leftmost @num_chars characters or the left "
#~ "character if @num_chars is not specified.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LEFT(\"Directory\",3) equals \"Dir\".\n"
#~ "\n"
#~ "@SEEALSO=MID, RIGHT"
#~ msgstr ""
#~ "@FUNCTION=LEFT\n"
#~ "@SYNTAX=LEFT(text[;antal_tecken])\n"
#~ "@DESCRIPTION=LEFT returnerar de @antal_tecken vänstra tecknen av @text, "
#~ "eller det tecken som är längst till vänster om @antal_tecken inte är "
#~ "angivet.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LEFT(\"Katalog\";3) är lika med \"Kat\".\n"
#~ "\n"
#~ "@SEEALSO=MID, RIGHT"

#~ msgid ""
#~ "@FUNCTION=LOWER\n"
#~ "@SYNTAX=LOWER(text)\n"
#~ "@DESCRIPTION=LOWER returns a lower-case version of the string in @text.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LOWER(\"J. F. Kennedy\") equals \"j. f. kennedy\".\n"
#~ "\n"
#~ "@SEEALSO=UPPER"
#~ msgstr ""
#~ "@FUNCTION=LOWER\n"
#~ "@SYNTAX=LOWER(text)\n"
#~ "@DESCRIPTION=LOWER omvandlar strängen @text till gemener.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LOWER(\"J. F. Kennedy\") är lika med \"j. f. kennedy\".\n"
#~ "\n"
#~ "@SEEALSO=UPPER"

#~ msgid ""
#~ "@FUNCTION=MID\n"
#~ "@SYNTAX=MID(string, position, length)\n"
#~ "@DESCRIPTION=MID returns a substring from @string starting at @position "
#~ "for @length characters.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "MID(\"testing\",2,3) equals \"est\".\n"
#~ "\n"
#~ "@SEEALSO=LEFT, RIGHT"
#~ msgstr ""
#~ "@FUNCTION=MID\n"
#~ "@SYNTAX=MID(sträng; position; längd)\n"
#~ "@DESCRIPTION=MID returnerar en substräng av @sträng med början på "
#~ "position @position och med längd @längd.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "MID(\"testar\";2;3) är lika med \"est\".\n"
#~ "\n"
#~ "@SEEALSO=LEFT, RIGHT"

#~ msgid ""
#~ "@FUNCTION=RIGHT\n"
#~ "@SYNTAX=RIGHT(text[,num_chars])\n"
#~ "@DESCRIPTION=RIGHT returns the rightmost @num_chars characters or the "
#~ "right character if @num_chars is not specified.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RIGHT(\"end\") equals \"d\".\n"
#~ "RIGHT(\"end\",2) equals \"nd\".\n"
#~ "\n"
#~ "@SEEALSO=MID, LEFT"
#~ msgstr ""
#~ "@FUNCTION=RIGHT\n"
#~ "@SYNTAX=RIGHT(text[;antal_tecken])\n"
#~ "@DESCRIPTION=RIGHT returnerar de @antal_tecken högra tecknen av @text, "
#~ "eller det tecken som är längst till höger om @antal_tecken inte är "
#~ "angivet.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RIGHT(\"slut\") är lika med \"t\".\n"
#~ "RIGHT(\"slut\";2) är lika med \"ut\".\n"
#~ "\n"
#~ "@SEEALSO=MID, LEFT"

#~ msgid ""
#~ "@FUNCTION=UPPER\n"
#~ "@SYNTAX=UPPER(text)\n"
#~ "@DESCRIPTION=UPPER returns a upper-case version of the string in @text.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "UPPER(\"cancelled\") equals \"CANCELLED\".\n"
#~ "\n"
#~ "@SEEALSO=LOWER"
#~ msgstr ""
#~ "@FUNCTION=UPPER\n"
#~ "@SYNTAX=UPPER(text)\n"
#~ "@DESCRIPTION=UPPER omvandlar strängen @text till versaler.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "UPPER(\"avbruten\") är lika med \"AVBRUTEN\".\n"
#~ "\n"
#~ "@SEEALSO=LOWER"

#~ msgid ""
#~ "@FUNCTION=CONCATENATE\n"
#~ "@SYNTAX=CONCATENATE(string1[,string2...])\n"
#~ "@DESCRIPTION=CONCATENATE returns the string obtained by concatenation of "
#~ "the given strings.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CONCATENATE(\"aa\",\"bb\") equals \"aabb\".\n"
#~ "\n"
#~ "@SEEALSO=LEFT, MID, RIGHT"
#~ msgstr ""
#~ "@FUNCTION=CONCATENATE\n"
#~ "@SYNTAX=CONCATENATE(sträng1[;sträng2...])\n"
#~ "@DESCRIPTION=CONCATENATE returnerar den sträng som fås av att slå ihop "
#~ "strängarna @sträng1,...\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CONCATENATE(\"aa\";\"bb\") är lika med \"aabb\".\n"
#~ "\n"
#~ "@SEEALSO=LEFT, MID, RIGHT"

#~ msgid ""
#~ "@FUNCTION=REPT\n"
#~ "@SYNTAX=REPT(string,num)\n"
#~ "@DESCRIPTION=REPT returns @num repetitions of @string.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ " \n"
#~ "@EXAMPLES=\n"
#~ "REPT(\".\",3) equals \"...\".\n"
#~ "\n"
#~ "@SEEALSO=CONCATENATE"
#~ msgstr ""
#~ "@FUNCTION=REPT\n"
#~ "@SYNTAX=REPT(sträng;antal)\n"
#~ "@DESCRIPTION=REPT returnerar @sträng @antal gånger.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "REPT(\".\";3) är lika med \"...\".\n"
#~ "\n"
#~ "@SEEALSO=CONCATENATE"

#~ msgid ""
#~ "@FUNCTION=CLEAN\n"
#~ "@SYNTAX=CLEAN(string)\n"
#~ "@DESCRIPTION=CLEAN removes any non-printable characters from @string.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CLEAN(\"one\"\\&char(7)) equals \"one\".\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=CLEAN\n"
#~ "@SYNTAX=CLEAN(sträng)\n"
#~ "@DESCRIPTION=CLEAN tömmer @sträng på eventuella icke-utskrivbara tecken.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CLEAN(\"en\"\\&char(7)) är lika med \"en\".\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=FIND\n"
#~ "@SYNTAX=FIND(string1,string2[,start])\n"
#~ "@DESCRIPTION=FIND returns position of @string1 in @string2 (case-"
#~ "sensitive), searching only from character @start onwards (assuming 1 if "
#~ "omitted).\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FIND(\"ac\",\"Jack\") equals 2.\n"
#~ "\n"
#~ "@SEEALSO=EXACT, LEN, MID, SEARCH"
#~ msgstr ""
#~ "@FUNCTION=FIND\n"
#~ "@SYNTAX=FIND(sträng1;sträng2[;start])\n"
#~ "@DESCRIPTION=FIND söker efter @sträng1 i @sträng2 (med hänsyn till "
#~ "versaler/gemener), med start från @start (1, om inte angiven). "
#~ "Returvärdet är den funna positionen.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FIND(\"ak\";\"Jakob\") är lika med 2.\n"
#~ "\n"
#~ "@SEEALSO=EXACT, LEN, MID, SEARCH"

#~ msgid ""
#~ "@FUNCTION=FIXED\n"
#~ "@SYNTAX=FIXED(num,[decimals, no_commas])\n"
#~ "@DESCRIPTION=FIXED returns @num as a formatted string with @decimals "
#~ "numbers after the decimal point, omitting commas if requested by "
#~ "@no_commas.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FIXED(1234.567,2) equals \"1,234.57\".\n"
#~ "\n"
#~ "@SEEALSO=TEXT, VALUE, DOLLAR"
#~ msgstr ""
#~ "@FUNCTION=FIXED\n"
#~ "@SYNTAX=FIXED(tal;[decimaler;utan_avskiljare])\n"
#~ "@DESCRIPTION=FIXED returnerar @tal som en formaterad sträng med "
#~ "@decimaler siffor efter decimaltecknet, utan tusentalsavskiljare om så "
#~ "anges i @utan_avskiljare.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FIXED(1234,567;2) är lika med \"1 234,57\".\n"
#~ "\n"
#~ "@SEEALSO=TEXT, VALUE, DOLLAR"

#~ msgid ""
#~ "@FUNCTION=PROPER\n"
#~ "@SYNTAX=PROPER(string)\n"
#~ "@DESCRIPTION=PROPER returns @string with initial of each word "
#~ "capitalised.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "PROPER(\"j. f. kennedy\") equals \"J. F. Kennedy\".\n"
#~ "\n"
#~ "@SEEALSO=LOWER, UPPER"
#~ msgstr ""
#~ "@FUNCTION=PROPER\n"
#~ "@SYNTAX=PROPER(sträng)\n"
#~ "@DESCRIPTION=PROPER returnerar @sträng med versaler i början av alla "
#~ "ord.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "PROPER(\"j. f. kennedy\") är lika med \"J. F. Kennedy\".\n"
#~ "\n"
#~ "@SEEALSO=LOWER, UPPER"

#~ msgid ""
#~ "@FUNCTION=REPLACE\n"
#~ "@SYNTAX=REPLACE(old,start,num,new)\n"
#~ "@DESCRIPTION=REPLACE returns @old with @new replacing @num characters "
#~ "from @start.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "REPLACE(\"testing\",2,3,\"*****\") equals \"t*****ing\".\n"
#~ "\n"
#~ "@SEEALSO=MID, SEARCH, SUBSTITUTE, TRIM"
#~ msgstr ""
#~ "@FUNCTION=REPLACE\n"
#~ "@SYNTAX=REPLACE(gammal_sträng;start;antal;ny_sträng)\n"
#~ "@DESCRIPTION=REPLACE ersätter @antal tecken i @gammal_sträng från och med "
#~ "@start med @ny_sträng.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "REPLACE(\"testar\";2;3;\"*****\") är lika med \"t*****ar\".\n"
#~ "\n"
#~ "@SEEALSO=MID, SEARCH, SUBSTITUTE, TRIM"

#~ msgid ""
#~ "@FUNCTION=T\n"
#~ "@SYNTAX=T(value)\n"
#~ "@DESCRIPTION=T returns @value if and only if it is text, otherwise a "
#~ "blank string.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "T(\"text\") equals \"text\".\n"
#~ "T(64) returns an empty cell.\n"
#~ "\n"
#~ "@SEEALSO=CELL, N, VALUE"
#~ msgstr ""
#~ "@FUNCTION=T\n"
#~ "@SYNTAX=T(värde)\n"
#~ "@DESCRIPTION=T returnerar @värde om och bara om det är text, annars en "
#~ "tom sträng.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "T(\"text\") är lika med \"text\".\n"
#~ "T(64) returnerar en tom cell.\n"
#~ "\n"
#~ "@SEEALSO=CELL, N, VALUE"

#~ msgid ""
#~ "@FUNCTION=TEXT\n"
#~ "@SYNTAX=TEXT(value,format_text)\n"
#~ "@DESCRIPTION=TEXT returns @value as a string with the specified format.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TEXT(3.223,\"$0.00\") equals \"$3.22\".\n"
#~ "TEXT(date(1999,4,15),\"mmmm, dd, yy\") equals \"April, 15, 99\".\n"
#~ "\n"
#~ "@SEEALSO=DOLLAR, FIXED, VALUE"
#~ msgstr ""
#~ "@FUNCTION=TEXT\n"
#~ "@SYNTAX=TEXT(värde;format_text)\n"
#~ "@DESCRIPTION=TEXT returnerar @värde som en sträng med det angivna "
#~ "formatet.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TEXT(3,223;\"$0,00\") är lika med \"$3,22\".\n"
#~ "TEXT(date(1999;4;15);\"mmmm, dd, yy\") är lika med \"April, 15, 99\".\n"
#~ "\n"
#~ "@SEEALSO=DOLLAR, FIXED, VALUE"

#~ msgid ""
#~ "@FUNCTION=TRIM\n"
#~ "@SYNTAX=TRIM(text)\n"
#~ "@DESCRIPTION=TRIM returns @text with only single spaces between words.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TRIM(\"  a bbb  cc\") equals \"a bbb cc\".\n"
#~ "\n"
#~ "@SEEALSO=CLEAN, MID, REPLACE, SUBSTITUTE"
#~ msgstr ""
#~ "@FUNCTION=TRIM\n"
#~ "@SYNTAX=TRIM(text)\n"
#~ "@DESCRIPTION=TRIM returnerar @text med endast ett mellanslag mellan "
#~ "orden.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TRIM(\"  a bbb  cc\") är lika med \"a bbb cc\".\n"
#~ "\n"
#~ "@SEEALSO=CLEAN, MID, REPLACE, SUBSTITUTE"

#~ msgid ""
#~ "@FUNCTION=VALUE\n"
#~ "@SYNTAX=VALUE(text)\n"
#~ "@DESCRIPTION=VALUE returns numeric value of @text.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "VALUE(\"$1,000\") equals 1000.\n"
#~ "\n"
#~ "@SEEALSO=DOLLAR, FIXED, TEXT"
#~ msgstr ""
#~ "@FUNCTION=VALUE\n"
#~ "@SYNTAX=VALUE(text)\n"
#~ "@DESCRIPTION=VALUE returnerar det numeriska värdet av @text.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "VALUE(\"1 000 kr\") är lika med 1000.\n"
#~ "\n"
#~ "@SEEALSO=DOLLAR, FIXED, TEXT"

#~ msgid ""
#~ "@FUNCTION=SUBSTITUTE\n"
#~ "@SYNTAX=SUBSTITUTE(text, old, new [,num])\n"
#~ "@DESCRIPTION=SUBSTITUTE replaces @old with @new in @text.  Substitutions "
#~ "are only applied to instance @num of @old in @text, otherwise every one "
#~ "is changed.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "SUBSTITUTE(\"testing\",\"test\",\"wait\") equals \"waiting\".\n"
#~ "\n"
#~ "@SEEALSO=REPLACE, TRIM"
#~ msgstr ""
#~ "@FUNCTION=SUBSTITUTE\n"
#~ "@SYNTAX=SUBSTITUTE(text; gammal; ny [;nr])\n"
#~ "@DESCRIPTION=SUBSTITUTE ersätter delsträngen @gammal med @ny i strängen "
#~ "@text. Ersättning sker bara för förekomst @nr av delsträngen. Om @nr är "
#~ "uteslutet ersätts alla förekomster.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "SUBSTITUTE(\"testar\";\"test\";\"vänt\") är lika med \"väntar\".\n"
#~ "\n"
#~ "@SEEALSO=REPLACE, TRIM"

#~ msgid ""
#~ "@FUNCTION=DOLLAR\n"
#~ "@SYNTAX=DOLLAR(num[,decimals])\n"
#~ "@DESCRIPTION=DOLLAR returns @num formatted as currency.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DOLLAR(12345) equals \"$12,345.00\".\n"
#~ "\n"
#~ "@SEEALSO=FIXED, TEXT, VALUE"
#~ msgstr ""
#~ "@FUNCTION=DOLLAR\n"
#~ "@SYNTAX=DOLLAR(tal;[decimaler])\n"
#~ "@DESCRIPTION=DOLLAR returnerar @tal i valutaformat.\n"
#~ "\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DOLLAR(12345) är lika med \"$12 345,00\".\n"
#~ "\n"
#~ "@SEEALSO=FIXED, TEXT, VALUE"

#~ msgid ""
#~ "@FUNCTION=SEARCH\n"
#~ "@SYNTAX=SEARCH(search_string,text[,start_num])\n"
#~ "@DESCRIPTION=SEARCH returns the location of the @search_ string within "
#~ "@text. The search starts  with the @start_num character of text @text.  "
#~ "If @start_num is omitted, it is assumed to be one.  The search is not "
#~ "case sensitive.\n"
#~ "\n"
#~ "@search_string can contain wildcard characters (*) and question marks "
#~ "(?). A question mark matches any character and a wildcard matches any "
#~ "string including the empty string.  If you want the actual wildcard or "
#~ "question mark to be found, use tilde (~) before the character.\n"
#~ "\n"
#~ "* If @search_string is not found, SEARCH returns #VALUE! error.\n"
#~ "* If @start_num is less than one or it is greater than the length of "
#~ "@text, SEARCH returns #VALUE! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "SEARCH(\"c\",\"Cancel\") equals 1.\n"
#~ "SEARCH(\"c\",\"Cancel\",2) equals 4.\n"
#~ "\n"
#~ "@SEEALSO=FIND"
#~ msgstr ""
#~ "@FUNCTION=SEARCH\n"
#~ "@SYNTAX=SEARCH(söksträng;text[;startposition])\n"
#~ "@DESCRIPTION=SEARCH returnerar positionen av ett tecken eller en sträng "
#~ "inuti en annan sträng. @söksträng är det tecken eller den sträng som "
#~ "skall sökas efter, och @text är den sträng som skall sökas igenom. "
#~ "Sökningen startas på @startposition i @text. Om @start_position "
#~ "utelämnas, börjar sökningen på position 1. Textsökningen tar ej hänsyn "
#~ "till versaler/gemener.\n"
#~ "\n"
#~ "@söksträng kan innehålla jokertecken (*) och frågetecken (?) för att "
#~ "styra sökningen. Ett frågetecken betyder vilket tecken som helst och "
#~ "jokertecken betyder vilken sträng som helst, inklusive en tom sträng. Om "
#~ "du vill söka efter en asterisk (*) eller ett frågetecken använder du ett "
#~ "tildetecken (~) framför tecknet.\n"
#~ "\n"
#~ "* Om @söksträng inte hittas returneras felvärdet #VÄRDE!\n"
#~ "* Om @startposition är mindre än ett eller större än längden av @text, "
#~ "returneras #VÄRDE!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "SEARCH(\"a\";\"Avsluta\") är lika med 1.\n"
#~ "SEARCH(\"a\";\"Avsluta\";2) är lika med 7.\n"
#~ "\n"
#~ "@SEEALSO=FIND"

#~ msgid ""
#~ "@FUNCTION=EXECSQL\n"
#~ "@SYNTAX=EXECSQL(dsn,username,password,sql)\n"
#~ "@DESCRIPTION=The EXECSQL function lets you execute a command in a "
#~ "database server, and show the results returned in current sheet. It uses "
#~ "libgda as the means for accessing the databases.\n"
#~ "For using it, you need first to set up a libgda data source.\n"
#~ "@EXAMPLES=\n"
#~ "To get all the data from the table \"Customers\" present in the "
#~ "\"mydatasource\" GDA data source, you would use:\n"
#~ "EXECSQL(\"mydatasource\",\"username\",\"password\",\"SELECT * FROM "
#~ "customers\")\n"
#~ "@SEEALSO=READDBTABLE"
#~ msgstr ""
#~ "@FUNCTION=EXECSQL\n"
#~ "@SYNTAX=EXECSQL(dsn,användare,lösenord,sql)\n"
#~ "@DESCRIPTION=Funktionen EXECSQL låter dig köra ett kommando i en "
#~ "databasserver, och visar svaren i det aktuella bladet. Det använder "
#~ "libgda för åtkomst till databaserna.\n"
#~ "För att använda det behöver du först sätta upp en libgda-källa.\n"
#~ "@EXAMPLES=\n"
#~ "För att hämta alla data i tabellen \"Kunder\" i \"mindatakälla\" GDA-"
#~ "datakällan så använder du:\n"
#~ "EXECSQL(\"mindatakälla\",\"användare\",\"lösenord\",\"SELECT * FROM kunder"
#~ "\")\n"
#~ "@SEEALSO=READDBTABLE"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=READDBTABLE\n"
#~ "@SYNTAX=READDBTABLE(dsn,username,password,table)\n"
#~ "@DESCRIPTION=The READDBTABLE function lets you get the contents of a "
#~ "table, as stored in a database. For using it, you need first to set up a "
#~ "libgda data source.\n"
#~ "Note that this function returns all the rows in the given table. If you "
#~ "want to get data from more than one table or want a more precise "
#~ "selection (conditions), use the EXECSQL function.\n"
#~ "@EXAMPLES=\n"
#~ "To get all the data from the table \"Customers\" present in the "
#~ "\"mydatasource\" GDA data source, you would use:\n"
#~ "READDBTABLE(\"mydatasource\",\"username\",\"password\",\"customers\")\n"
#~ "@SEEALSO=EXECSQL"
#~ msgstr ""
#~ "@FUNCTION=READDBTABLE\n"
#~ "@SYNTAX=READDBTABLE(dsn,användare,lösenord,tabell)\n"
#~ "@DESCRIPTION=Funktionen READDBTABLE låter dig hämta innehållet i en "
#~ "tabell som den är sparad i databasen. För att använda den måste du först "
#~ "sätta upp en libgda-datakälla.\n"
#~ "Notera att funktionen returnerar alla rader i den givna tabellen. Om du "
#~ "vill hämta data från mer än en tabell eller om du vill ha ett mer exakt "
#~ "urval (villkor), använd istället funktionen EXECSQL.\n"
#~ "@EXAMPLES=\n"
#~ "För att hämta alla data i tabellen \"Kunder\" i \"mindatakälla\" GDA-"
#~ "datakällan så använder du:\n"
#~ "READDBTABLE(\"mindatakälla\",\"användare\",\"lösenord\",\"kunder\")\n"
#~ "@SEEALSO=EXECSQL"

#~ msgid ""
#~ "@FUNCTION=NT_PHI\n"
#~ "@SYNTAX=NT_PHI(n)\n"
#~ "@DESCRIPTION=NT_PHI function calculates the number of integers less than "
#~ "or equal to @n that are relatively prime to @n.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=NT_D, ITHPRIME, NT_SIGMA"
#~ msgstr ""
#~ "@FUNCTION=NT_PHI\n"
#~ "@SYNTAX=NT_PHI(n)\n"
#~ "@DESCRIPTION=Funktionen NT_PHI beräknar antalet heltal som mindre än "
#~ "eller lika med @n som är relativt prima med @n.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=NT_D, ITHPRIME, NT_SIGMA"

#~ msgid ""
#~ "@FUNCTION=NT_D\n"
#~ "@SYNTAX=NT_D(n)\n"
#~ "@DESCRIPTION=NT_D function calculates the number of divisors of @n.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=ITHPRIME, NT_PHI, NT_SIGMA"
#~ msgstr ""
#~ "@FUNCTION=NT_D\n"
#~ "@SYNTAX=NT_D(n)\n"
#~ "@DESCRIPTION=Funktionen NT_D beräknar antalet delare av @n.\n"
#~ "Denna funktion tar endast ett argument.\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=ITHPRIME, NT_PHI, NT_SIGMA"

#~ msgid ""
#~ "@FUNCTION=NT_SIGMA\n"
#~ "@SYNTAX=NT_SIGMA(n)\n"
#~ "@DESCRIPTION=NT_SIGMA function calculates the sum of the divisors of @n.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=NT_D, ITHPRIME, NT_PHI"
#~ msgstr ""
#~ "@FUNCTION=NT_SIGMA\n"
#~ "@SYNTAX=NT_SIGMA(n)\n"
#~ "@DESCRIPTION=Funktionen NT_SIGMA beräknar summan av @n:s delare.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=NT_D, ITHPRIME, NT_PHI"

#~ msgid ""
#~ "@FUNCTION=ITHPRIME\n"
#~ "@SYNTAX=ITHPRIME(i)\n"
#~ "@DESCRIPTION=ITHPRIME function returns the @ith prime.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=NT_D, NT_SIGMA"
#~ msgstr ""
#~ "@FUNCTION=ITHPRIME\n"
#~ "@SYNTAX=ITHPRIME(i)\n"
#~ "@DESCRIPTION=Funktionen ITHPRIME returnerar det @i:e primtalet.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=NT_D, NT_SIGMA"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=ISPRIME\n"
#~ "@SYNTAX=ISPRIME(i)\n"
#~ "@DESCRIPTION=ISPRIME function returns TRUE if @i is prime and FALSE "
#~ "otherwise.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=ITHPRIME, NT_D, NT_SIGMA"
#~ msgstr ""
#~ "@FUNCTION=ISPRIME\n"
#~ "@SYNTAX=ISPRIME(i)\n"
#~ "@DESCRIPTION=Funktionen ISPRIME returnerar SANT om @i är ett primtal och "
#~ "FALSKT annars.\n"
#~ "\n"
#~ "@SEEALSO=ITHPRIME, NT_D, NT_SIGMA"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=PFACTOR\n"
#~ "@SYNTAX=PFACTOR(n)\n"
#~ "@DESCRIPTION=PFACTOR function returns the smallest prime factor of its "
#~ "argument.\n"
#~ "\n"
#~ "The argument must be at least 2, or else a #VALUE! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=ITHPRIME"
#~ msgstr ""
#~ "@FUNCTION=PFACTOR\n"
#~ "@SYNTAX=PFACTOR(n)\n"
#~ "@DESCRIPTION=PFACTOR anger den minsta primfaktorn för sitt argument. \n"
#~ "\n"
#~ "Argumentet måste vara minst 2, annars returneras #VÄRDE!.\n"
#~ "\n"
#~ "@SEEALSO=ITHPRIME"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=NT_PI\n"
#~ "@SYNTAX=NT_PI(n)\n"
#~ "@DESCRIPTION=NT_PI function returns the number of primes less than or "
#~ "equal to @n.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=ITHPRIME, NT_PHI, NT_D, NT_SIGMA"
#~ msgstr ""
#~ "@FUNCTION=NT_PI\n"
#~ "@SYNTAX=NT_PI(n)\n"
#~ "@DESCRIPTION=Funktionen NT_PI returnerar antalet primtal som är mindre än "
#~ "eller lika med @n.\n"
#~ "\n"
#~ "@SEEALSO=ITHPRIME, NT_PHI, NT_D, NT_SIGMA"

#~ msgid ""
#~ "@FUNCTION=BITOR\n"
#~ "@SYNTAX=BITOR(a,b)\n"
#~ "@DESCRIPTION=BITOR function returns bitwise or-ing of its arguments.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=BITXOR,BITAND"
#~ msgstr ""
#~ "@FUNCTION=BITOR\n"
#~ "@SYNTAX=BITOR(a;b)\n"
#~ "@DESCRIPTION=Funktionen BITOR returnerar bitvis-eller av sina argument.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=BITXOR,BITAND"

#~ msgid ""
#~ "@FUNCTION=BITXOR\n"
#~ "@SYNTAX=BITXOR(a,b)\n"
#~ "@DESCRIPTION=BITXOR function returns bitwise exclusive or-ing of its "
#~ "arguments.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=BITOR,BITAND"
#~ msgstr ""
#~ "@FUNCTION=BITXOR\n"
#~ "@SYNTAX=BITXOR(a;b)\n"
#~ "@DESCRIPTION=Funktionen BITXOR returnerar bitvis exklusiv-eller av sina "
#~ "argument.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=BITOR,BITAND"

#~ msgid ""
#~ "@FUNCTION=BITAND\n"
#~ "@SYNTAX=BITAND(a,b)\n"
#~ "@DESCRIPTION=BITAND function returns bitwise and-ing of its arguments.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=BITOR,BITXOR"
#~ msgstr ""
#~ "@FUNCTION=BITAND\n"
#~ "@SYNTAX=BITAND(a;b)\n"
#~ "@DESCRIPTION=Funktionen BITAND returnerar bitvis-och av dess argument.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=BITOR,BITXOR"

#~ msgid ""
#~ "@FUNCTION=BITLSHIFT\n"
#~ "@SYNTAX=BITLSHIFT(x,n)\n"
#~ "@DESCRIPTION=BITLSHIFT function returns @x bit-shifted left by @n bits.\n"
#~ "\n"
#~ "* If @n is negative, a right shift will in effect be performed.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=BITRSHIFT"
#~ msgstr ""
#~ "@FUNCTION=BITLSHIFT\n"
#~ "@SYNTAX=BITLSHIFT(x;n)\n"
#~ "@DESCRIPTION=Funktionen BITLSHIFT returnerar @x bitskiftat till vänster "
#~ "med @n bitar.\n"
#~ "\n"
#~ "* Om @n är negativt kommer ett högerskift att utföras.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=BITRSHIFT"

#~ msgid ""
#~ "@FUNCTION=BITRSHIFT\n"
#~ "@SYNTAX=BITRSHIFT(x,n)\n"
#~ "@DESCRIPTION=BITRSHIFT function returns @x bit-shifted right by @n bits.\n"
#~ "\n"
#~ "* If @n is negative, a left shift will in effect be performed.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=BITLSHIFT"
#~ msgstr ""
#~ "@FUNCTION=BITRSHIFT\n"
#~ "@SYNTAX=BITRSHIFT(x;n)\n"
#~ "@DESCRIPTION=Funktionen BITRSHIFT returnerar @x bitskiftat till höger med "
#~ "@n bitar.\n"
#~ "\n"
#~ "* Om @n är negativt kommer ett vänsterskift att utföras.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=BITLSHIFT"

#~ msgid ""
#~ "@FUNCTION=COLUMN\n"
#~ "@SYNTAX=COLUMN([reference])\n"
#~ "@DESCRIPTION=COLUMN function returns the column number of the current "
#~ "cell unless @reference is given. In that case, it returns an array of the "
#~ "column numbers of all cells in @reference. \n"
#~ "* If @reference is neither an array nor a reference nor a range, COLUMN "
#~ "returns #VALUE! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COLUMN() in E1 equals 5.\n"
#~ "\n"
#~ "@SEEALSO=COLUMNS,ROW,ROWS"
#~ msgstr ""
#~ "@FUNCTION=COLUMN\n"
#~ "@SYNTAX=COLUMN([referens])\n"
#~ "@DESCRIPTION=Funktionen COLUMN returnerar kolumnnumret för den aktuella "
#~ "cellen om inte @referens anges. I det fallet returneras en vektor med "
#~ "kolumnnummer för alla celler i @referens. \n"
#~ "* Om @referens inte är ett fält, en referens eller ett område, returneras "
#~ "felvärdet #VÄRDE!\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COLUMN() i E1 är lika med 5.\n"
#~ "\n"
#~ "@SEEALSO=COLUMNS,ROW,ROWS"

#~ msgid ""
#~ "@FUNCTION=ROW\n"
#~ "@SYNTAX=ROW([reference])\n"
#~ "@DESCRIPTION=ROW function returns an array of the row numbers taking a "
#~ "default argument of the containing cell position.\n"
#~ "\n"
#~ "* If @reference is neither an array nor a reference nor a range, ROW "
#~ "returns #VALUE! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ROW() in G13 equals 13.\n"
#~ "\n"
#~ "@SEEALSO=COLUMN,COLUMNS,ROWS"
#~ msgstr ""
#~ "@FUNCTION=ROW\n"
#~ "@SYNTAX=ROW([referens])\n"
#~ "@DESCRIPTION=ROW returnerar ett fält med radnummer. Om @referens inte "
#~ "anges, används den cell som formeln finns i.\n"
#~ "\n"
#~ "* Om @referens inte är ett fält, en referens eller ett område, returneras "
#~ "felvärdet #VÄRDE!\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ROW() i G13 är lika med 13.\n"
#~ "\n"
#~ "@SEEALSO=COLUMN,COLUMNS,ROWS"

#~ msgid ""
#~ "@FUNCTION=FLOOR\n"
#~ "@SYNTAX=FLOOR(x[,significance])\n"
#~ "@DESCRIPTION=FLOOR function rounds @x down to the next nearest multiple "
#~ "of @significance.\n"
#~ "\n"
#~ "* @significance defaults to 1.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FLOOR(0.5) equals 0.\n"
#~ "FLOOR(5,2) equals 4.\n"
#~ "FLOOR(-5,-2) equals -4.\n"
#~ "FLOOR(-5,2) equals #NUM!.\n"
#~ "\n"
#~ "@SEEALSO=CEIL, CEILING, ABS, INT, MOD"
#~ msgstr ""
#~ "@FUNCTION=FLOOR\n"
#~ "@SYNTAX=FLOOR(x[;signifikans])\n"
#~ "@DESCRIPTION=Funktionen FLOOR avrundar @x nedåt till närmsta multipel av "
#~ "@signifikans.\n"
#~ "\n"
#~ "* @signifikans är 1 om inget anges.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FLOOR(0,5) är lika med 0.\n"
#~ "FLOOR(5;2) är lika med 4.\n"
#~ "FLOOR(-5;-2) är lika med -4.\n"
#~ "FLOOR(-5;2) är lika med #NUM!.\n"
#~ "\n"
#~ "@SEEALSO=CEIL, CEILING, ABS, INT, MOD"

#~ msgid ""
#~ "@FUNCTION=SUMPRODUCT\n"
#~ "@SYNTAX=SUMPRODUCT(range1,range2,...)\n"
#~ "@DESCRIPTION=SUMPRODUCT function multiplies corresponding data entries in "
#~ "the given arrays or ranges, and then returns the sum of those products.  "
#~ "If an array entry is not numeric, the value zero is used instead.\n"
#~ "\n"
#~ "* If arrays or range arguments do not have the same dimensions, "
#~ "SUMPRODUCT returns #VALUE! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11, 15, 17, "
#~ "21, and 43 and the cells B1, B2, ..., B5 hold numbers 13, 22, 31, 33, and "
#~ "39.  Then\n"
#~ "SUMPRODUCT(A1:A5,B1:B5) equals 3370.\n"
#~ "\n"
#~ "@SEEALSO=SUM,PRODUCT"
#~ msgstr ""
#~ "@FUNCTION=SUMPRODUCT\n"
#~ "@SYNTAX=SUMPRODUCT(intervall1;intervall2;...)\n"
#~ "@DESCRIPTION=Funktionen SUMPRODUCT multiplicerar motsvarande dataposter i "
#~ "de givna fälten eller intervallen, och returnerar sedan summan av dessa "
#~ "produkter. Om en fältpost inte är ett tal används värdet noll i stället.\n"
#~ "\n"
#~ "* Om fält- eller intervallargumenten inte har samma dimensioner "
#~ "returnerar SUMPRODUCT felvärdet #VÄRDE!.\n"
#~ "* Denna funktion är kompatibel med Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Antag att att cellerna A1; A2; ...; A5 innehåller talen 11, 15, 17, 21 "
#~ "och 43 och cellerna B1; B2; ...; B5 innehåller talen 13, 22, 31, 33 och "
#~ "39. Då är\n"
#~ "SUMPRODUCT(A1:A5;B1:B5) lika med 3370.\n"
#~ "\n"
#~ "@SEEALSO=SUM,PRODUCT"
