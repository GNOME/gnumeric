# Copyright © 2001, 2002, 2003, 2004, 2005 gnumeric
# Distributed under the same licence as the gnumeric package
# Duarte Loreto <happyguy_pt@hotmail.com>, 2001, 2002, 2003, 2004, 2005
# Pedro Albuquerque <palbuquerque73@gmail.com>, 2015.
# Tiago Santos <tiagofsantos81@sapo.pt>, 2014 - 2016.
#
msgid ""
msgstr ""
"Project-Id-Version: 2.10\n"
"Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?"
"product=gnumeric&keywords=I18N+L10N&component=General\n"
"POT-Creation-Date: 2016-08-25 11:13+0000\n"
"PO-Revision-Date: 2016-09-23 21:10+0100\n"
"Last-Translator: Tiago Santos <tiagofsantos81@sapo.pt>\n"
"Language-Team: Português <palbuquerque73@gmail.com>\n"
"Language: pt\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\\n;\n"
"X-Generator: Poedit 1.8.7.1\n"

#: ../plugins/fn-christian-date/functions.c:140
msgid ""
"EASTERSUNDAY:Easter Sunday in the Gregorian calendar according to the Roman "
"rite of the Christian Church"
msgstr ""
"DOMINGO.PÁSCOA: domingo de Páscoa no calendário gregoriano de acordo com o "
"ritual da Igeja Católica"

#: ../plugins/fn-christian-date/functions.c:142
msgid ""
"year:year between 1582 and 9956, defaults to the year of the next Easter "
"Sunday"
msgstr ""
"ano: ano entre 1582 e 9956, predefinição para o ano do próximo domingo de "
"Páscoa"

#: ../plugins/fn-christian-date/functions.c:143
#: ../plugins/fn-christian-date/functions.c:166
#: ../plugins/fn-christian-date/functions.c:186
#: ../plugins/fn-christian-date/functions.c:205
#: ../plugins/fn-christian-date/functions.c:224
msgid ""
"Two digit years are adjusted as elsewhere in Gnumeric. Dates before 1904 may "
"also be prohibited."
msgstr ""
"Anos com dois dígitos são ajustados algures no Gnumeric. Datas antes de 1904 "
"podem também ser proibidas."

#: ../plugins/fn-christian-date/functions.c:146
msgid ""
"The 1-argument version of EASTERSUNDAY is compatible with OpenOffice for "
"years after 1904. This function is not specified in ODF/OpenFormula."
msgstr ""
"A versão de argumento único de DOMINGO.PÁSCOA é compatível com o OpenOffice "
"para anos após 1904. Esta função não está especificada em ODF/OpenFormula."

#: ../plugins/fn-christian-date/functions.c:163
msgid ""
"ASHWEDNESDAY:Ash Wednesday in the Gregorian calendar according to the Roman "
"rite of the Christian Church"
msgstr ""
"QUARTA.DE.CINZAS: quarta feira de cinzas no calendário gregoriano de acordo "
"com o ritual da Igreja Católica"

#: ../plugins/fn-christian-date/functions.c:165
msgid ""
"year:year between 1582 and 9956, defaults to the year of the next Ash "
"Wednesday"
msgstr ""
"ano: ano entre 1582 e 9956, predefinição para o ano da próxima quarta feira "
"de cinzas"

#: ../plugins/fn-christian-date/functions.c:183
msgid ""
"PENTECOSTSUNDAY:Pentecost Sunday in the Gregorian calendar according to the "
"Roman rite of the Christian Church"
msgstr ""
"DOMINGO.DE.PENTECOSTES: domingo no calendário gregoriano de acordo com o "
"ritual da Igreja Católica"

#: ../plugins/fn-christian-date/functions.c:185
msgid ""
"year:year between 1582 and 9956, defaults to the year of the next Pentecost "
"Sunday"
msgstr ""
"ano: ano entre 1582 e 9956, predefinição para o ano do próximo domingo de "
"Pentecostes"

#: ../plugins/fn-christian-date/functions.c:202
msgid ""
"GOODFRIDAY:Good Friday in the Gregorian calendar according to the Roman rite "
"of the Christian Church"
msgstr ""
"SEXTA.SANTA: sexta feira santa no calendário gregoriano de acordo com o "
"ritual da Igreja Católica"

#: ../plugins/fn-christian-date/functions.c:204
msgid ""
"year:year between 1582 and 9956, defaults to the year of the next Good Friday"
msgstr ""
"ano: ano entre 1582 e 9956, predefinição para o ano da próxima sexta feira "
"santa"

#: ../plugins/fn-christian-date/functions.c:221
msgid ""
"ASCENSIONTHURSDAY:Ascension Thursday in the Gregorian calendar according to "
"the Roman rite of the Christian Church"
msgstr ""
"QUINTA.ASCENÇÃO: quinta feira da ascenção no calendário gregoriano de acordo "
"com o ritual da Igreja Católica"

#: ../plugins/fn-christian-date/functions.c:223
msgid ""
"year:year between 1582 and 9956, defaults to the year of the next Ascension "
"Thursday"
msgstr ""
"ano: ano entre 1582 e 9956, predefinição para o ano da próxima quinta feira "
"da ascenção"

#: ../plugins/fn-complex/functions.c:85
msgid "COMPLEX:a complex number of the form @{x} + @{y}@{i}"
msgstr "COMPLEXO:um número complexo na forma @{x} + @{y}@{i}"

#: ../plugins/fn-complex/functions.c:86
msgid "x:real part"
msgstr "x: parte real"

#: ../plugins/fn-complex/functions.c:87
msgid "y:imaginary part"
msgstr "y: parte imaginária"

#: ../plugins/fn-complex/functions.c:88
msgid ""
"i:the suffix for the complex number, either \"i\" or \"j\"; defaults to \"i\""
msgstr ""
"i:o sufixo do número complexo, ou \"i\" ou \"j\"; predefiniçlão é \"i\""

#: ../plugins/fn-complex/functions.c:89
msgid "If @{i} is neither \"i\" nor \"j\", COMPLEX returns #VALUE!"
msgstr "Se @{i} não for \"i\" nem \"j\", COMPLEXO devolve #VALOR!"

#: ../plugins/fn-complex/functions.c:90 ../plugins/fn-complex/functions.c:114
#: ../plugins/fn-complex/functions.c:141 ../plugins/fn-complex/functions.c:165
#: ../plugins/fn-complex/functions.c:192 ../plugins/fn-complex/functions.c:260
#: ../plugins/fn-complex/functions.c:285 ../plugins/fn-complex/functions.c:384
#: ../plugins/fn-complex/functions.c:438 ../plugins/fn-complex/functions.c:462
#: ../plugins/fn-complex/functions.c:487 ../plugins/fn-complex/functions.c:512
#: ../plugins/fn-complex/functions.c:543 ../plugins/fn-complex/functions.c:574
#: ../plugins/fn-complex/functions.c:1038
#: ../plugins/fn-complex/functions.c:1144
#: ../plugins/fn-complex/functions.c:1173
#: ../plugins/fn-complex/functions.c:1242 ../plugins/fn-date/functions.c:84
#: ../plugins/fn-date/functions.c:197 ../plugins/fn-date/functions.c:219
#: ../plugins/fn-date/functions.c:354 ../plugins/fn-date/functions.c:389
#: ../plugins/fn-date/functions.c:406 ../plugins/fn-date/functions.c:431
#: ../plugins/fn-date/functions.c:492 ../plugins/fn-date/functions.c:511
#: ../plugins/fn-date/functions.c:534 ../plugins/fn-date/functions.c:557
#: ../plugins/fn-date/functions.c:579 ../plugins/fn-date/functions.c:603
#: ../plugins/fn-date/functions.c:627 ../plugins/fn-date/functions.c:662
#: ../plugins/fn-date/functions.c:726 ../plugins/fn-date/functions.c:764
#: ../plugins/fn-eng/functions.c:238 ../plugins/fn-eng/functions.c:263
#: ../plugins/fn-eng/functions.c:287 ../plugins/fn-eng/functions.c:316
#: ../plugins/fn-eng/functions.c:342 ../plugins/fn-eng/functions.c:365
#: ../plugins/fn-eng/functions.c:415 ../plugins/fn-eng/functions.c:442
#: ../plugins/fn-eng/functions.c:465 ../plugins/fn-eng/functions.c:488
#: ../plugins/fn-eng/functions.c:511 ../plugins/fn-eng/functions.c:531
#: ../plugins/fn-eng/functions.c:1476 ../plugins/fn-eng/functions.c:1499
#: ../plugins/fn-info/functions.c:97 ../plugins/fn-info/functions.c:1285
#: ../plugins/fn-info/functions.c:1351 ../plugins/fn-info/functions.c:1440
#: ../plugins/fn-info/functions.c:1458 ../plugins/fn-info/functions.c:1480
#: ../plugins/fn-info/functions.c:1507 ../plugins/fn-info/functions.c:1534
#: ../plugins/fn-info/functions.c:1571 ../plugins/fn-info/functions.c:1587
#: ../plugins/fn-info/functions.c:1609 ../plugins/fn-info/functions.c:1626
#: ../plugins/fn-info/functions.c:1644 ../plugins/fn-info/functions.c:1661
#: ../plugins/fn-info/functions.c:1683 ../plugins/fn-info/functions.c:1703
#: ../plugins/fn-info/functions.c:1722 ../plugins/fn-info/functions.c:1759
#: ../plugins/fn-logical/functions.c:52 ../plugins/fn-logical/functions.c:103
#: ../plugins/fn-logical/functions.c:131 ../plugins/fn-logical/functions.c:373
#: ../plugins/fn-logical/functions.c:391 ../plugins/fn-math/functions.c:195
#: ../plugins/fn-math/functions.c:258 ../plugins/fn-math/functions.c:359
#: ../plugins/fn-math/functions.c:377 ../plugins/fn-math/functions.c:399
#: ../plugins/fn-math/functions.c:459 ../plugins/fn-math/functions.c:485
#: ../plugins/fn-math/functions.c:509 ../plugins/fn-math/functions.c:528
#: ../plugins/fn-math/functions.c:563 ../plugins/fn-math/functions.c:630
#: ../plugins/fn-math/functions.c:654 ../plugins/fn-math/functions.c:679
#: ../plugins/fn-math/functions.c:700 ../plugins/fn-math/functions.c:720
#: ../plugins/fn-math/functions.c:741 ../plugins/fn-math/functions.c:761
#: ../plugins/fn-math/functions.c:781 ../plugins/fn-math/functions.c:803
#: ../plugins/fn-math/functions.c:832 ../plugins/fn-math/functions.c:869
#: ../plugins/fn-math/functions.c:940 ../plugins/fn-math/functions.c:959
#: ../plugins/fn-math/functions.c:993 ../plugins/fn-math/functions.c:1034
#: ../plugins/fn-math/functions.c:1144 ../plugins/fn-math/functions.c:1201
#: ../plugins/fn-math/functions.c:1234 ../plugins/fn-math/functions.c:1256
#: ../plugins/fn-math/functions.c:1294 ../plugins/fn-math/functions.c:1318
#: ../plugins/fn-math/functions.c:1450 ../plugins/fn-math/functions.c:1493
#: ../plugins/fn-math/functions.c:1511 ../plugins/fn-math/functions.c:1625
#: ../plugins/fn-math/functions.c:1643 ../plugins/fn-math/functions.c:1690
#: ../plugins/fn-math/functions.c:1714 ../plugins/fn-math/functions.c:1760
#: ../plugins/fn-math/functions.c:1793 ../plugins/fn-math/functions.c:1830
#: ../plugins/fn-math/functions.c:1865 ../plugins/fn-math/functions.c:1900
#: ../plugins/fn-math/functions.c:1937 ../plugins/fn-math/functions.c:2016
#: ../plugins/fn-math/functions.c:2041 ../plugins/fn-math/functions.c:2068
#: ../plugins/fn-math/functions.c:2094 ../plugins/fn-math/functions.c:2118
#: ../plugins/fn-math/functions.c:2159 ../plugins/fn-math/functions.c:2204
#: ../plugins/fn-math/functions.c:2331 ../plugins/fn-math/functions.c:2579
#: ../plugins/fn-math/functions.c:2623 ../plugins/fn-math/functions.c:2666
#: ../plugins/fn-math/functions.c:2709 ../plugins/fn-math/functions.c:2766
#: ../plugins/fn-math/functions.c:2956 ../plugins/fn-math/functions.c:3054
#: ../plugins/fn-math/functions.c:3099 ../plugins/fn-random/functions.c:48
#: ../plugins/fn-random/functions.c:249 ../plugins/fn-stat/functions.c:85
#: ../plugins/fn-stat/functions.c:112 ../plugins/fn-stat/functions.c:138
#: ../plugins/fn-stat/functions.c:165 ../plugins/fn-stat/functions.c:275
#: ../plugins/fn-stat/functions.c:323 ../plugins/fn-stat/functions.c:353
#: ../plugins/fn-stat/functions.c:383 ../plugins/fn-stat/functions.c:416
#: ../plugins/fn-stat/functions.c:440 ../plugins/fn-stat/functions.c:484
#: ../plugins/fn-stat/functions.c:534 ../plugins/fn-stat/functions.c:563
#: ../plugins/fn-stat/functions.c:592 ../plugins/fn-stat/functions.c:612
#: ../plugins/fn-stat/functions.c:639 ../plugins/fn-stat/functions.c:736
#: ../plugins/fn-stat/functions.c:762 ../plugins/fn-stat/functions.c:787
#: ../plugins/fn-stat/functions.c:812 ../plugins/fn-stat/functions.c:837
#: ../plugins/fn-stat/functions.c:862 ../plugins/fn-stat/functions.c:896
#: ../plugins/fn-stat/functions.c:935 ../plugins/fn-stat/functions.c:987
#: ../plugins/fn-stat/functions.c:1055 ../plugins/fn-stat/functions.c:1087
#: ../plugins/fn-stat/functions.c:1117 ../plugins/fn-stat/functions.c:1144
#: ../plugins/fn-stat/functions.c:1174 ../plugins/fn-stat/functions.c:1262
#: ../plugins/fn-stat/functions.c:1299 ../plugins/fn-stat/functions.c:1340
#: ../plugins/fn-stat/functions.c:1425 ../plugins/fn-stat/functions.c:1462
#: ../plugins/fn-stat/functions.c:1628 ../plugins/fn-stat/functions.c:1660
#: ../plugins/fn-stat/functions.c:1756 ../plugins/fn-stat/functions.c:1783
#: ../plugins/fn-stat/functions.c:1813 ../plugins/fn-stat/functions.c:1848
#: ../plugins/fn-stat/functions.c:1881 ../plugins/fn-stat/functions.c:1910
#: ../plugins/fn-stat/functions.c:1942 ../plugins/fn-stat/functions.c:1974
#: ../plugins/fn-stat/functions.c:2006 ../plugins/fn-stat/functions.c:2039
#: ../plugins/fn-stat/functions.c:2087 ../plugins/fn-stat/functions.c:2111
#: ../plugins/fn-stat/functions.c:2135 ../plugins/fn-stat/functions.c:2162
#: ../plugins/fn-stat/functions.c:2191 ../plugins/fn-stat/functions.c:2210
#: ../plugins/fn-stat/functions.c:2236 ../plugins/fn-stat/functions.c:2367
#: ../plugins/fn-stat/functions.c:2410 ../plugins/fn-stat/functions.c:2459
#: ../plugins/fn-stat/functions.c:2539 ../plugins/fn-stat/functions.c:2597
#: ../plugins/fn-stat/functions.c:2656 ../plugins/fn-stat/functions.c:2680
#: ../plugins/fn-stat/functions.c:2705 ../plugins/fn-stat/functions.c:2735
#: ../plugins/fn-stat/functions.c:2760 ../plugins/fn-stat/functions.c:2788
#: ../plugins/fn-stat/functions.c:2813 ../plugins/fn-stat/functions.c:3043
#: ../plugins/fn-stat/functions.c:3085 ../plugins/fn-stat/functions.c:3131
#: ../plugins/fn-stat/functions.c:3174 ../plugins/fn-stat/functions.c:3218
#: ../plugins/fn-stat/functions.c:3284 ../plugins/fn-stat/functions.c:3453
#: ../plugins/fn-stat/functions.c:4396 ../plugins/fn-stat/functions.c:4453
#: ../plugins/fn-stat/functions.c:4501 ../plugins/fn-stat/functions.c:4566
#: ../plugins/fn-string/functions.c:68 ../plugins/fn-string/functions.c:140
#: ../plugins/fn-string/functions.c:251 ../plugins/fn-string/functions.c:270
#: ../plugins/fn-string/functions.c:287 ../plugins/fn-string/functions.c:307
#: ../plugins/fn-string/functions.c:371 ../plugins/fn-string/functions.c:391
#: ../plugins/fn-string/functions.c:518 ../plugins/fn-string/functions.c:587
#: ../plugins/fn-string/functions.c:607 ../plugins/fn-string/functions.c:628
#: ../plugins/fn-string/functions.c:649 ../plugins/fn-string/functions.c:728
#: ../plugins/fn-string/functions.c:772 ../plugins/fn-string/functions.c:803
#: ../plugins/fn-string/functions.c:841 ../plugins/fn-string/functions.c:898
#: ../plugins/fn-string/functions.c:944 ../plugins/fn-string/functions.c:1046
#: ../plugins/fn-string/functions.c:1070 ../plugins/fn-string/functions.c:1123
#: ../plugins/fn-string/functions.c:1170 ../plugins/fn-string/functions.c:1266
#: ../plugins/fn-string/functions.c:1337 ../plugins/fn-string/functions.c:1420
msgid "This function is Excel compatible."
msgstr "Esta função é compatível Excel."

#: ../plugins/fn-complex/functions.c:111
msgid "IMAGINARY:the imaginary part of the complex number @{z}"
msgstr "IMAGINÁRIO: a parte imaginária do número complexo @{z}"

#: ../plugins/fn-complex/functions.c:112 ../plugins/fn-complex/functions.c:139
#: ../plugins/fn-complex/functions.c:163 ../plugins/fn-complex/functions.c:190
#: ../plugins/fn-complex/functions.c:214 ../plugins/fn-complex/functions.c:236
#: ../plugins/fn-complex/functions.c:258 ../plugins/fn-complex/functions.c:283
#: ../plugins/fn-complex/functions.c:308 ../plugins/fn-complex/functions.c:333
#: ../plugins/fn-complex/functions.c:357 ../plugins/fn-complex/functions.c:382
#: ../plugins/fn-complex/functions.c:408 ../plugins/fn-complex/functions.c:433
#: ../plugins/fn-complex/functions.c:460 ../plugins/fn-complex/functions.c:485
#: ../plugins/fn-complex/functions.c:572 ../plugins/fn-complex/functions.c:596
#: ../plugins/fn-complex/functions.c:619 ../plugins/fn-complex/functions.c:643
#: ../plugins/fn-complex/functions.c:667 ../plugins/fn-complex/functions.c:690
#: ../plugins/fn-complex/functions.c:714 ../plugins/fn-complex/functions.c:737
#: ../plugins/fn-complex/functions.c:763 ../plugins/fn-complex/functions.c:789
#: ../plugins/fn-complex/functions.c:815 ../plugins/fn-complex/functions.c:838
#: ../plugins/fn-complex/functions.c:862 ../plugins/fn-complex/functions.c:885
#: ../plugins/fn-complex/functions.c:911 ../plugins/fn-complex/functions.c:938
#: ../plugins/fn-complex/functions.c:965 ../plugins/fn-complex/functions.c:988
#: ../plugins/fn-complex/functions.c:1012
#: ../plugins/fn-complex/functions.c:1036
#: ../plugins/fn-complex/functions.c:1061
#: ../plugins/fn-complex/functions.c:1085
#: ../plugins/fn-complex/functions.c:1110
msgid "z:a complex number"
msgstr "z: um número complexo"

#: ../plugins/fn-complex/functions.c:113 ../plugins/fn-complex/functions.c:140
#: ../plugins/fn-complex/functions.c:164 ../plugins/fn-complex/functions.c:191
#: ../plugins/fn-complex/functions.c:215 ../plugins/fn-complex/functions.c:237
#: ../plugins/fn-complex/functions.c:259 ../plugins/fn-complex/functions.c:284
#: ../plugins/fn-complex/functions.c:310 ../plugins/fn-complex/functions.c:335
#: ../plugins/fn-complex/functions.c:359 ../plugins/fn-complex/functions.c:383
#: ../plugins/fn-complex/functions.c:410 ../plugins/fn-complex/functions.c:437
#: ../plugins/fn-complex/functions.c:461 ../plugins/fn-complex/functions.c:486
#: ../plugins/fn-complex/functions.c:573 ../plugins/fn-complex/functions.c:597
#: ../plugins/fn-complex/functions.c:620 ../plugins/fn-complex/functions.c:644
#: ../plugins/fn-complex/functions.c:668 ../plugins/fn-complex/functions.c:691
#: ../plugins/fn-complex/functions.c:715 ../plugins/fn-complex/functions.c:740
#: ../plugins/fn-complex/functions.c:766 ../plugins/fn-complex/functions.c:792
#: ../plugins/fn-complex/functions.c:816 ../plugins/fn-complex/functions.c:839
#: ../plugins/fn-complex/functions.c:863 ../plugins/fn-complex/functions.c:888
#: ../plugins/fn-complex/functions.c:915 ../plugins/fn-complex/functions.c:942
#: ../plugins/fn-complex/functions.c:966 ../plugins/fn-complex/functions.c:989
#: ../plugins/fn-complex/functions.c:1013
#: ../plugins/fn-complex/functions.c:1037
#: ../plugins/fn-complex/functions.c:1062
#: ../plugins/fn-complex/functions.c:1086
msgid "If @{z} is not a valid complex number, #VALUE! is returned."
msgstr "Se @{i} não for um número complexo válido, devolve #VALOR!"

#: ../plugins/fn-complex/functions.c:138
msgid "IMABS:the absolute value of the complex number @{z}"
msgstr "ABSIM: o valor absoluto do número complexo @{z}"

#: ../plugins/fn-complex/functions.c:162
msgid "IMREAL:the real part of the complex number @{z}"
msgstr "REALIM: a parte real do número complexo @{z}"

#: ../plugins/fn-complex/functions.c:189
msgid "IMCONJUGATE:the complex conjugate of the complex number @{z}"
msgstr "CONJIM: o conjugado complexo do número complexo @{z}"

#: ../plugins/fn-complex/functions.c:213
msgid "IMINV:the reciprocal, or inverse, of the complex number @{z}"
msgstr "INVIM: o recíproco, ou inverso do número complexo @{z}"

#: ../plugins/fn-complex/functions.c:235
msgid "IMNEG:the negative of the complex number @{z}"
msgstr "NEGIM: o negativo do número complexo @{z}"

#: ../plugins/fn-complex/functions.c:257
msgid "IMCOS:the cosine of the complex number @{z}"
msgstr "COSIM: o cosseno do número complexo @{z}"

#: ../plugins/fn-complex/functions.c:282
msgid "IMTAN:the tangent of the complex number @{z}"
msgstr "TANIM: a tangente do número complexo @{z}"

#: ../plugins/fn-complex/functions.c:307
msgid "IMSEC:the secant of the complex number @{z}"
msgstr "SECIM: a secante do número complexo @{z}"

#: ../plugins/fn-complex/functions.c:309
msgid "IMSEC(@{z}) = 1/IMCOS(@{z})."
msgstr "SECIM(@{z}) = 1/COSIM(@{z})."

#: ../plugins/fn-complex/functions.c:332
msgid "IMCSC:the cosecant of the complex number @{z}"
msgstr "CSCIM: a cossecante do número complexo @{z}"

#: ../plugins/fn-complex/functions.c:334
msgid "IMCSC(@{z}) = 1/IMSIN(@{z})."
msgstr "CSCIM(@{z}) = 1/SENIM(@{z})."

#: ../plugins/fn-complex/functions.c:356
msgid "IMCOT:the cotangent of the complex number @{z}"
msgstr "COTIM: a cotangente do número complexo @{z}"

#: ../plugins/fn-complex/functions.c:358
msgid "IMCOT(@{z}) = IMCOS(@{z})/IMSIN(@{z})."
msgstr "COTIM(@{z}) = COSIM(@{z})/SENIM(@{z})."

#: ../plugins/fn-complex/functions.c:381
msgid "IMEXP:the exponential of the complex number @{z}"
msgstr "EXPIM: a exponencial do número complexo @{z}"

#: ../plugins/fn-complex/functions.c:407
msgid "IMARGUMENT:the argument theta of the complex number @{z} "
msgstr "ARGIM: o argumento teta do número complexo @{z}"

#: ../plugins/fn-complex/functions.c:409
msgid ""
"The argument theta of a complex number is its angle in radians from the real "
"axis."
msgstr ""
"O argumento teta de um número complexo é o seu ângulo em radianos a partir  "
"do número complexo @{z}do eixo real."

#: ../plugins/fn-complex/functions.c:411
msgid ""
"If @{z} is 0, 0 is returned.  This is different from Excel which returns an "
"error."
msgstr "Se @{z} é 0,0 é devolvido. Isto difere do Excel que devolve um erro."

#: ../plugins/fn-complex/functions.c:432
msgid "IMLN:the natural logarithm of the complex number @{z}"
msgstr "LNIM: o logaritmo natural do número complexo @{z}"

#: ../plugins/fn-complex/functions.c:434
msgid ""
"The result will have an imaginary part between -π and +π.\n"
"The natural logarithm is not uniquely defined on complex numbers. You may "
"need to add or subtract an even multiple of π to the imaginary part."
msgstr ""
"O resultado terá uma parte imaginária entre -n e +n.\n"
"O logaritmo natural não tem uma definição única em números complexos. Pode "
"precisar de adicionar ou subtrair um múltiplo par de n à parte imaginária."

#: ../plugins/fn-complex/functions.c:459
msgid "IMLOG2:the base-2 logarithm of the complex number @{z}"
msgstr "LOG2IM: o loga<ritmo base 2 do número complexo @{z}"

#: ../plugins/fn-complex/functions.c:484
msgid "IMLOG10:the base-10 logarithm of the complex number @{z}"
msgstr "LOG10IM: o logaritmo base 10 do número complexo @{z}"

#: ../plugins/fn-complex/functions.c:508
msgid "IMPOWER:the complex number @{z1} raised to the @{z2}th power"
msgstr "POTIM:  o número complexo @{z1} elevado à potência @{z2}"

#: ../plugins/fn-complex/functions.c:509 ../plugins/fn-complex/functions.c:540
#: ../plugins/fn-complex/functions.c:1141
#: ../plugins/fn-complex/functions.c:1170
#: ../plugins/fn-complex/functions.c:1239
msgid "z1:a complex number"
msgstr "z1: um número complexo"

#: ../plugins/fn-complex/functions.c:510 ../plugins/fn-complex/functions.c:541
#: ../plugins/fn-complex/functions.c:1142
#: ../plugins/fn-complex/functions.c:1171
#: ../plugins/fn-complex/functions.c:1240
msgid "z2:a complex number"
msgstr "z2: um número complexo"

#: ../plugins/fn-complex/functions.c:511 ../plugins/fn-complex/functions.c:542
#: ../plugins/fn-complex/functions.c:1143
msgid "If @{z1} or @{z2} is not a valid complex number, #VALUE! is returned."
msgstr ""
"Se @{z1} ou @{z2} não forem números complexos válidos, devolve #VALOR!."

#: ../plugins/fn-complex/functions.c:539
msgid "IMDIV:the quotient of two complex numbers @{z1}/@{z2}"
msgstr "DIVIM: o quociente de dois números complexos @{z1}/@{z2}"

#: ../plugins/fn-complex/functions.c:571
msgid "IMSIN:the sine of the complex number @{z}"
msgstr "SENIM: o seno do número complexo @{z}"

#: ../plugins/fn-complex/functions.c:595
msgid "IMSINH:the hyperbolic sine of the complex number @{z}"
msgstr "SENHIM: o seno hiperbólico do número complexo @{z}"

#: ../plugins/fn-complex/functions.c:618
msgid "IMCOSH:the hyperbolic cosine of the complex number @{z}"
msgstr "COSHIM: o cosseno hiperbólico do número complexo @{z}"

#: ../plugins/fn-complex/functions.c:642
msgid "IMTANH:the hyperbolic tangent of the complex number @{z}"
msgstr "TANHIM: a tangente hiperbólica do número complexo @{z}"

#: ../plugins/fn-complex/functions.c:666
msgid "IMSECH:the hyperbolic secant of the complex number @{z}"
msgstr "SECHIM: a secante hiperbólica do número complexo @{z}"

#: ../plugins/fn-complex/functions.c:689
msgid "IMCSCH:the hyperbolic cosecant of the complex number @{z}"
msgstr "CSCHIM: a cossecante hiperbólica do número complexo @{z}"

#: ../plugins/fn-complex/functions.c:713
msgid "IMCOTH:the hyperbolic cotangent of the complex number @{z}"
msgstr "COTHIM:a cotangente hiperbólica do número complexo @{z}"

#: ../plugins/fn-complex/functions.c:736
msgid "IMARCSIN:the complex arcsine of the complex number @{z}"
msgstr "ARCSENIM: o arco seno complexo do número complexo @{z}"

#: ../plugins/fn-complex/functions.c:738
msgid ""
"IMARCSIN returns the complex arcsine of the complex number @{z}. The branch "
"cuts are on the real axis, less than -1 and greater than 1."
msgstr ""
"ARCSENIM devolve o arco seno complexo do número complexo @{z}. Os cortes de "
"ramo são no eixo real, menor que -1 e maior que 1."

#: ../plugins/fn-complex/functions.c:762
msgid "IMARCCOS:the complex arccosine of the complex number "
msgstr "ARCCOSIM: o arco cosseno complexo do número complexo @{z}"

#: ../plugins/fn-complex/functions.c:764
msgid ""
"IMARCCOS returns the complex arccosine of the complex number @{z}. The "
"branch cuts are on the real axis, less than -1 and greater than 1."
msgstr ""
"ARCCOSIM devolve o arco cosseno complexo do número complexo @{z}. Os cortes "
"de ramo são no eixo real, menor que -1 e maior que 1."

#: ../plugins/fn-complex/functions.c:788
msgid "IMARCTAN:the complex arctangent of the complex number "
msgstr "ARCTANIM: o arco tangente complexo do número complexo @{z}"

#: ../plugins/fn-complex/functions.c:790
msgid ""
"IMARCTAN returns the complex arctangent of the complex number @{z}. The "
"branch cuts are on the imaginary axis, below -i and above i."
msgstr ""
"ARCTANIM devolve o arco tangente complexo do número complexo @{z}. Os cortes "
"de ramo são no eixo imaginário, menor que -i e maior que i."

#: ../plugins/fn-complex/functions.c:814
msgid "IMARCSEC:the complex arcsecant of the complex number @{z}"
msgstr "ARCSECIM:o arco secante complexo do número complexo @{z}"

#: ../plugins/fn-complex/functions.c:837
msgid "IMARCCSC:the complex arccosecant of the complex number @{z}"
msgstr "ARCCSCIM: a arco cossecante complexo do número complexo @{z}"

#: ../plugins/fn-complex/functions.c:861
msgid "IMARCCOT:the complex arccotangent of the complex number @{z}"
msgstr "ARCCOTIM: o arco cotangente complexo do número complexo @{z}"

#: ../plugins/fn-complex/functions.c:884
msgid "IMARCSINH:the complex hyperbolic arcsine of the complex number @{z}"
msgstr "ARCSENHIM:o arco seno hiperbólico complexo do número complexo @{z}"

#: ../plugins/fn-complex/functions.c:886
msgid ""
"IMARCSINH returns the complex hyperbolic arcsine of the complex number "
"@{z}.  The branch cuts are on the imaginary axis, below -i and above i."
msgstr ""
"ARCSENHIM devolve o arco seno hiperbólico complexo do número complexo @{z}. "
"Os cortes de ramo são no eixo imaginário, menor que -i e maior que i."

#: ../plugins/fn-complex/functions.c:910
msgid "IMARCCOSH:the complex hyperbolic arccosine of the complex number @{z}"
msgstr "ARCCOSHIM: o arco cosseno hiperbólico complexo do número complexo @{z}"

#: ../plugins/fn-complex/functions.c:912
msgid ""
"IMARCCOSH returns the complex hyperbolic arccosine of the complex number "
"@{z}. The branch cut is on the real axis, less than 1."
msgstr ""
"ARCCOSHIM devolve o arco cosseno hiperbólico complexo do número complexo "
"@{z}. Os cortes de ramo são no eixo real, menor que 1."

#: ../plugins/fn-complex/functions.c:937
msgid "IMARCTANH:the complex hyperbolic arctangent of the complex number @{z}"
msgstr "ARCTANHIM:o arco tangente hiperbólico complexo do número complexo @{z}"

#: ../plugins/fn-complex/functions.c:939
msgid ""
"IMARCTANH returns the complex hyperbolic arctangent of the complex number "
"@{z}. The branch cuts are on the real axis, less than -1 and greater than 1."
msgstr ""
"ARCTANHIM devolve o arco tangente hiperbólico complexo do número complexo "
"@{z}. Os cortes de ramo são no eixo real, menor que -1 e maior que 1."

#: ../plugins/fn-complex/functions.c:964
msgid "IMARCSECH:the complex hyperbolic arcsecant of the complex number @{z}"
msgstr "ARCSECHIM:o arco secante hiperbólico complexo do número complexo @{z}"

#: ../plugins/fn-complex/functions.c:987
msgid "IMARCCSCH:the complex hyperbolic arccosecant of the complex number @{z}"
msgstr "ARCCSCHIM: o arcossecante hiperbólico complexo do número complexo @{z}"

#: ../plugins/fn-complex/functions.c:1011
msgid ""
"IMARCCOTH:the complex hyperbolic arccotangent of the complex number @{z}"
msgstr ""
"ARCCOTHIM: o arco cotangente hiperbólico complexo do número complexo @{z}"

#: ../plugins/fn-complex/functions.c:1035
msgid "IMSQRT:the square root of the complex number @{z}"
msgstr "RAIZQIM: a raiz quadrada do número complexo @{z}"

#: ../plugins/fn-complex/functions.c:1060
msgid "IMFACT:the factorial of the complex number @{z}"
msgstr "FACTIM: o fatorial do número complexo @{z}"

#: ../plugins/fn-complex/functions.c:1084
msgid "IMGAMMA:the gamma function of the complex number @{z}"
msgstr "GAMAIM: a função gama do número complexo @{z}"

#: ../plugins/fn-complex/functions.c:1108
msgid "IMIGAMMA:the incomplete Gamma function"
msgstr "GAMAIIM: a função gama incompleta"

#: ../plugins/fn-complex/functions.c:1109
msgid "a:a complex number"
msgstr "A: um número complexo"

#: ../plugins/fn-complex/functions.c:1111 ../plugins/fn-math/functions.c:1059
msgid ""
"lower:if true (the default), the lower incomplete gamma function, otherwise "
"the upper incomplete gamma function"
msgstr ""
"inferior: se verdadeiro (predefinição), a função gama inferior incompleta , "
"senão a função gama superior incompleta."

#: ../plugins/fn-complex/functions.c:1112 ../plugins/fn-math/functions.c:1060
msgid ""
"regularize:if true (the default), the regularized version of the incomplete "
"gamma function"
msgstr ""
"regularizar: se verdadeiro (predefinição), a versão regularizada da função "
"gama incompleta."

#: ../plugins/fn-complex/functions.c:1113 ../plugins/fn-math/functions.c:1062
msgid ""
"The regularized incomplete gamma function is the unregularized incomplete "
"gamma function divided by gamma(@{a})"
msgstr ""
"A versão regularizada da função gama incompleta é a função gama incompleta "
"não regularizada dividida por gama(@{a})"

#: ../plugins/fn-complex/functions.c:1140
msgid "IMSUB:the difference of two complex numbers"
msgstr "SUBTRIM: a diferença entre dois números complexos"

#: ../plugins/fn-complex/functions.c:1169
msgid "IMPRODUCT:the product of the given complex numbers"
msgstr "PRODIM: o produto dos números complexos indicados"

#: ../plugins/fn-complex/functions.c:1172
#: ../plugins/fn-complex/functions.c:1241
msgid ""
"If any of @{z1}, @{z2},... is not a valid complex number, #VALUE! is "
"returned."
msgstr ""
"Se algum dos @{z1}, @{z2},... não for um número complexi válido, devolve "
"#VALUE!."

#: ../plugins/fn-complex/functions.c:1238
msgid "IMSUM:the sum of the given complex numbers"
msgstr "SOMAIM: a soma dos números complexos indicados"

#: ../plugins/fn-database/functions.c:46
msgid ""
"database:a range in which rows of related information are records and "
"columns of data are fields"
msgstr ""
"basededados: um intervalo no qual linhas de informação relacionada são "
"registos e colunas de dados são campos"

#: ../plugins/fn-database/functions.c:49
msgid "field:a string or integer specifying which field is to be used"
msgstr "campo: uma cadeia ou inteiro especificando que campo deve ser usado"

#: ../plugins/fn-database/functions.c:51
msgid "criteria:a range containing conditions"
msgstr "critério: um intervalo contendo condições"

#: ../plugins/fn-database/functions.c:53
msgid ""
"@{database} is a range in which rows of related information are records and "
"columns of data are fields. The first row of a database contains labels for "
"each column."
msgstr ""
"@{basededados} é um intervalo no qual linhas de informação relacionada são "
"registos e colunas de dados são campos. A primeira linha de uma base de "
"dados contém rótulos para cada coluna."

#: ../plugins/fn-database/functions.c:58
msgid ""
"@{field} is a string or integer specifying which field is to be used. If "
"@{field} is an integer n then the nth column will be used. If @{field} is a "
"string, then the column with the matching label will be used."
msgstr ""
"@{campo} é uma cadeia ou um inteiro especificando que campo deve ser usado. "
"Se @{campo} for um inteiro n, então a n-ésima coluna será usada. Se @{campo} "
"for uma cadeia, será usada a coluna com o rótulo correspondente."

#: ../plugins/fn-database/functions.c:63
msgid ""
"@{criteria} is a range containing conditions. The first row of a @{criteria} "
"should contain labels. Each label specifies to which field the conditions "
"given in that column apply. Each cell below the label specifies a condition "
"such as \">3\" or \"<9\". An equality condition can be given by simply "
"specifying a value, e. g. \"3\" or \"Jody\". For a record to be considered "
"it must satisfy all conditions in at least one of the rows of @{criteria}."
msgstr ""
"@{critério} é um intervalo contendo condições. A primeira linha de um "
"@{critério} deve conter rótulos. Cada rótulo especifica a que campo a "
"condição indicada nessa coluna se aplica. Cada célula abaixo do rótulo "
"especifica uma condição, tal como \">3\" ou \"<9\". Pode indicar uma "
"condição de igualdade simplesmente especificando um valor, por exemplo, "
"\"3\" ou \"Jorge\". Para que um registo seja considerado, tem de satisfazer "
"todas as condições em pelo menos uma das linhas de @{critério}."

#: ../plugins/fn-database/functions.c:74
msgid ""
"Let us assume that the range A1:C7 contain the following values:\n"
"\n"
"Name    \tAge     \tSalary\n"
"John    \t34      \t54342\n"
"Bill    \t35      \t22343\n"
"Clark   \t29      \t34323\n"
"Bob     \t43      \t47242\n"
"Susan   \t37      \t42932\n"
"Jill    \t\t45      \t45324\n"
"\n"
"In addition, the cells A9:B11 contain the following values:\n"
"Age     \tSalary\n"
"<30\n"
">40     \t>46000\n"
msgstr ""
"Vamos presumir que o intervalo A1:C7 contém os seguintes valores:\n"
"\n"
"Nome    \tIdade   \tSalário\n"
"João    \t34      \t54342\n"
"José    \t35      \t22343\n"
"Paulo   \t29      \t34323\n"
"Simão   \t43      \t47242\n"
"Pedro   \t37      \t42932\n"
"Madalena\t45      \t45324\n"
"\n"
"Além disto, as células A9:B11 contêm os seguintes valores:\n"
"Idade   \tSalário\n"
"<30\n"
">40     \t>46000\n"

#: ../plugins/fn-database/functions.c:350
msgid ""
"DAVERAGE:average of the values in @{field} in @{database} belonging to "
"records that match @{criteria}"
msgstr ""
"BDMÉDIA: média dos valores em @{campo} na @{basededados} pertencendo a "
"registos que cumpram o @{critério}"

#: ../plugins/fn-database/functions.c:359
msgid "DAVERAGE(A1:C7, \"Salary\", A9:A11) equals 42296.3333."
msgstr "BDMÉDIA(A1:C7, \"Salário\", A9:A11) devolve 42296,3333."

#: ../plugins/fn-database/functions.c:360
msgid "DAVERAGE(A1:C7, \"Age\", A9:A11) equals 39."
msgstr "BDMÉDIA(A1:C7, \"Idade\", A9:A11) devolve 39."

#: ../plugins/fn-database/functions.c:361
msgid "DAVERAGE(A1:C7, \"Salary\", A9:B11) equals 40782.5."
msgstr "BDMÉDIA(A1:C7, \"Salário\", A9:B11) devolve 40782,5."

#: ../plugins/fn-database/functions.c:362
msgid "DAVERAGE(A1:C7, \"Age\", A9:B11) equals 36."
msgstr "BDMÉDIA(A1:C7, \"Idade\", A9:B11) devolve 36."

#: ../plugins/fn-database/functions.c:386
msgid ""
"DCOUNT:count of numbers in @{field} in @{database} belonging to records that "
"match @{criteria}"
msgstr ""
"BDCONTAR: total de números em @{campo} na @{basededados} pertencendo a "
"registos que cumpram o @{critério}"

#: ../plugins/fn-database/functions.c:395
msgid "DCOUNT(A1:C7, \"Salary\", A9:A11) equals 3."
msgstr "BDCONTAR(A1:C7, \"Salário\", A9:A11) devolve 3."

#: ../plugins/fn-database/functions.c:396
msgid "DCOUNT(A1:C7, \"Salary\", A9:B11) equals 2."
msgstr "BDCONTAR(A1:C7, \"Salário\", A9:B11) devolve 2."

#: ../plugins/fn-database/functions.c:397
msgid "DCOUNT(A1:C7, \"Name\", A9:B11) equals 0."
msgstr "BDCONTAR(A1:C7, \"Nome\", A9:B11) devolve 0."

#: ../plugins/fn-database/functions.c:430
msgid ""
"DCOUNTA:count of cells with data in @{field} in @{database} belonging to "
"records that match @{criteria}"
msgstr ""
"BDCONTAR.VAL: total de células com dados em @{campo} na @{basededados} "
"pertencendo a registos que cumpram o @{critério}"

#: ../plugins/fn-database/functions.c:439
msgid "DCOUNTA(A1:C7, \"Salary\", A9:A11) equals 3."
msgstr "BDCONTAR.VAL(A1:C7, \"Salário\", A9:A11) devolve 3."

#: ../plugins/fn-database/functions.c:440
msgid "DCOUNTA(A1:C7, \"Salary\", A9:B11) equals 2."
msgstr "BDCONTAR.VAL(A1:C7, \"Salário\", A9:B11) devolve 2."

#: ../plugins/fn-database/functions.c:441
msgid "DCOUNTA(A1:C7, \"Name\", A9:B11) equals 2."
msgstr "BDCONTAR.VAL(A1:C7, \"Nome\", A9:B11) devolve 2."

#: ../plugins/fn-database/functions.c:463
msgid ""
"DGET:a value from @{field} in @{database} belonging to records that match "
"@{criteria}"
msgstr ""
"BDOBTER: um valor de @{campo} na @{basededados} pertencendo a registos que "
"cumpram o @{critério}"

#: ../plugins/fn-database/functions.c:472
msgid "If none of the records match the conditions, DGET returns #VALUE!"
msgstr "Se nenhum dos registos cumprir as condições, BDOBTER devolve #VALOR!."

#: ../plugins/fn-database/functions.c:473
msgid "If more than one record match the conditions, DGET returns #NUM!"
msgstr "Se mais de registo cumprir as condições, BDOBTER devolve #NUM!."

#: ../plugins/fn-database/functions.c:474
msgid "DGET(A1:C7, \"Salary\", A9:A10) equals 34323."
msgstr "BDOBTER(A1:C7, \"Salário\", A9:A10) devolve 34323."

#: ../plugins/fn-database/functions.c:475
msgid "DGET(A1:C7, \"Name\", A9:A10) equals \"Clark\"."
msgstr "BDOBTER(A1:C7, \"Nome\", A9:A10) devolve \"Paulo\"."

#: ../plugins/fn-database/functions.c:505
msgid ""
"DMAX:largest number in @{field} in @{database} belonging to a record that "
"match @{criteria}"
msgstr ""
"BDMÁX: o maior número num @{campo} na @{basededados} pertencendo a um "
"registo que cumpra o @{critério}"

#: ../plugins/fn-database/functions.c:514
msgid "DMAX(A1:C7, \"Salary\", A9:A11) equals 47242."
msgstr "BDMÁX(A1:C7, \"Salário\", A9:A11) devolve 47242."

#: ../plugins/fn-database/functions.c:515
msgid "DMAX(A1:C7, \"Age\", A9:A11) equals 45."
msgstr "BDMÁX(A1:C7, \"Idade\", A9:A11) devolve 45."

#: ../plugins/fn-database/functions.c:516
msgid "DMAX(A1:C7, \"Age\", A9:B11) equals 43."
msgstr "BDMÁX(A1:C7, \"Idade\", A9:B11) devolve 43."

#: ../plugins/fn-database/functions.c:541
msgid ""
"DMIN:smallest number in @{field} in @{database} belonging to a record that "
"match @{criteria}"
msgstr ""
"BDMÍN: o menor número num @{campo} na @{basededados} pertencendo a um "
"registo que cumpra o @{critério}"

#: ../plugins/fn-database/functions.c:550
msgid "DMIN(A1:C7, \"Salary\", A9:B11) equals 34323."
msgstr "BDMÍN(A1:C7, \"Salário\", A9:B11) devolve 34323."

#: ../plugins/fn-database/functions.c:551
msgid "DMIN(A1:C7, \"Age\", A9:B11) equals 29."
msgstr "BDMÍN(A1:C7, \"Idade\", A9:B11) devolve 29."

#: ../plugins/fn-database/functions.c:574
msgid ""
"DPRODUCT:product of all values in @{field} in @{database} belonging to "
"records that match @{criteria}"
msgstr ""
"BDMULTIPL: o produto de todos os valores no @{campo} na @{basededados} "
"pertencendo a registos que cumpram o @{critério}"

#: ../plugins/fn-database/functions.c:583
msgid "DPRODUCT(A1:C7, \"Age\", A9:B11) equals 1247."
msgstr "BDMULTIPL(A1:C7, \"Idade\", A9:B11) devolve 1247."

#: ../plugins/fn-database/functions.c:607
msgid ""
"DSTDEV:sample standard deviation of the values in @{field} in @{database} "
"belonging to records that match @{criteria}"
msgstr ""
"BSDESVPAD: desvio padrão da amostra dos valores no @{campo} na "
"@{basededados} pertencendo a registos que cumpram o @{critério}"

#: ../plugins/fn-database/functions.c:616
msgid "DSTDEV(A1:C7, \"Age\", A9:B11) equals 9.89949."
msgstr "BSDESVPAD(A1:C7, \"Idade\", A9:B11) devolve 9,89949."

#: ../plugins/fn-database/functions.c:617
msgid "DSTDEV(A1:C7, \"Salary\", A9:B11) equals 9135.112506."
msgstr "BSDESVPAD(A1:C7, \"Salário\", A9:B11) devolve 9135,112506."

#: ../plugins/fn-database/functions.c:640
msgid ""
"DSTDEVP:standard deviation of the population of values in @{field} in "
"@{database} belonging to records that match @{criteria}"
msgstr ""
"BDDESVPADP: desvio padrão da população dos valores no @{campo} na "
"@{basededados} pertencendo a registos que cumpram o @{critério}"

#: ../plugins/fn-database/functions.c:650
msgid "DSTDEVP(A1:C7, \"Age\", A9:B11) equals 7."
msgstr "BDDESVPADP(A1:C7, \"Idade\", A9:B11) devolve 7."

#: ../plugins/fn-database/functions.c:651
msgid "DSTDEVP(A1:C7, \"Salary\", A9:B11) equals 6459.5."
msgstr "BDDESVPADP(A1:C7, \"Salário\", A9:B11) devolve 6459,5."

#: ../plugins/fn-database/functions.c:674
msgid ""
"DSUM:sum of the values in @{field} in @{database} belonging to records that "
"match @{criteria}"
msgstr ""
"BSOMA: soma dos valores no @{campo} na @{basededados} pertencendo a registos "
"que cumpram o @{critério}"

#: ../plugins/fn-database/functions.c:683
msgid "DSUM(A1:C7, \"Age\", A9:B11) equals 72."
msgstr "BSOMA(A1:C7, \"Idade\", A9:B11) devolve 72."

#: ../plugins/fn-database/functions.c:684
msgid "DSUM(A1:C7, \"Salary\", A9:B11) equals 81565."
msgstr "BSOMA(A1:C7, \"Salário\", A9:B11) devolve 81565."

#: ../plugins/fn-database/functions.c:708
msgid ""
"DVAR:sample variance of the values in @{field} in @{database} belonging to "
"records that match @{criteria}"
msgstr ""
"BDVAR:variância da amostra dos valores no @{campo} na @{basededados} "
"pertencendo a registos que cumpram o @{critério}"

#: ../plugins/fn-database/functions.c:717
msgid "DVAR(A1:C7, \"Age\", A9:B11) equals 98."
msgstr "BDVAR(A1:C7, \"Idade\", A9:B11) devolve 98."

#: ../plugins/fn-database/functions.c:718
msgid "DVAR(A1:C7, \"Salary\", A9:B11) equals 83450280.5."
msgstr "BDVAR(A1:C7, \"Salário\", A9:B11) devolve 83450280,5."

#: ../plugins/fn-database/functions.c:741
msgid ""
"DVARP:variance of the population of values in @{field} in @{database} "
"belonging to records that match @{criteria}"
msgstr ""
"BDVARP: variância da população dos valores no @{campo} na @{basededados} "
"pertencendo a registos que cumpram o @{critério}"

#: ../plugins/fn-database/functions.c:751
msgid "DVARP(A1:C7, \"Age\", A9:B11) equals 49."
msgstr "BDVARP(A1:C7, \"Idade\", A9:B11) devolve 49."

#: ../plugins/fn-database/functions.c:752
msgid "DVARP(A1:C7, \"Salary\", A9:B11) equals 41725140.25."
msgstr "BDVARP(A1:C7, \"Salário\", A9:B11) devolve 41725140,25."

#: ../plugins/fn-database/functions.c:775
msgid "GETPIVOTDATA:summary data from a pivot table"
msgstr "OBTER.DADOS.PIVOT: dados resumo para uma tabel pivô"

#: ../plugins/fn-database/functions.c:776
msgid "pivot_table:cell range containing the pivot table"
msgstr "tabela_pivô: intervalo de células contendo a tabela pivô"

#: ../plugins/fn-database/functions.c:777
msgid "field_name:name of the field for which the summary data is requested"
msgstr "nome_campo: nome do campo para o qual os dados resumo são pedidos"

#: ../plugins/fn-database/functions.c:778
msgid "If the summary data is unavailable, GETPIVOTDATA returns #REF!"
msgstr ""
"Se os dados resumo estiverem indisponíveis, OBTER.DADOS.PIVOT devolve #REF!."

#: ../plugins/fn-date/functions.c:74
msgid "DATE:create a date serial value"
msgstr "DATA: cria um valor série de data"

#: ../plugins/fn-date/functions.c:75
msgid "year:year of date"
msgstr "ano: ano da data"

#: ../plugins/fn-date/functions.c:76
msgid "month:month of year"
msgstr "mês: mês do ano"

#: ../plugins/fn-date/functions.c:77
msgid "day:day of month"
msgstr "dia: dia do mês"

#: ../plugins/fn-date/functions.c:78
msgid ""
"The DATE function creates date serial values.  1-Jan-1900 is serial value 1, "
"2-Jan-1900 is serial value 2, and so on.  For compatibility reasons, a "
"serial value is reserved for the non-existing date 29-Feb-1900."
msgstr ""
"A função DATA cria valores série de dadtas. 1-jan-1900 é o valor série 1, 2-"
"jan-1900 é o valor série 2, etc.. Por motivos de compatibilidade, é "
"reservado um valor série para a data nao existente 29-fev-1900."

#: ../plugins/fn-date/functions.c:79
msgid ""
"If @{month} or @{day} is less than 1 or too big, then the year and/or month "
"will be adjusted."
msgstr ""
"Se @{mês} ou @{dia} forem menores que 1 ou demasiado grandes, o ano e/ou o "
"mês serão ajustados."

#: ../plugins/fn-date/functions.c:80
msgid ""
"For spreadsheets created with the Mac version of Excel, serial 1 is 1-"
"Jan-1904."
msgstr ""
"Para folhas criadas com a versão Mac do Excel, o valor série 1 é 1-jan-1904."

#: ../plugins/fn-date/functions.c:137
msgid "UNIX2DATE:date value corresponding to the Unix timestamp @{t}"
msgstr ""
"UNIX.PARA.DATA: valor de data correspondendo ao selo de tempo Unix @{t}"

#: ../plugins/fn-date/functions.c:138
msgid "t:Unix time stamp"
msgstr "t: selo de tempo Unix"

#: ../plugins/fn-date/functions.c:139
msgid ""
"The UNIX2DATE function translates Unix timestamps into the corresponding "
"date.  A Unix timestamp is the number of seconds since midnight (0:00) of "
"January 1st, 1970 GMT."
msgstr ""
"A função UNIX.PARA.DATA traduz selos de tempo Unix para as datas "
"correspondentes. Um selo de tempo Unix é o número de segundos desde a meia "
"noite (o:oo) de 1 de janeiro de 1970 GMT."

#: ../plugins/fn-date/functions.c:167
msgid "DATE2UNIX:the Unix timestamp corresponding to a date @{d}"
msgstr "DATA.PARA.UNIX:o selo de tempo Unix correspondente a uma data @{d}"

#: ../plugins/fn-date/functions.c:168
msgid "d:date"
msgstr "d: data"

#: ../plugins/fn-date/functions.c:169
msgid ""
"The DATE2UNIX function translates a date into a Unix timestamp. A Unix "
"timestamp is the number of seconds since midnight (0:00) of January 1st, "
"1970 GMT."
msgstr ""
"A função DATA.PARA.UNIX traduz uma data num selo de tempo Unix. Um selo de "
"tempo Unix é o número de segundos desde a meia noite (o:oo) de 1 de janeiro "
"de 1970 GMT."

#: ../plugins/fn-date/functions.c:193
msgid "DATEVALUE:the date part of a date and time serial value"
msgstr "DATA.VALOR: a parte de data de um valor série de data e hora"

#: ../plugins/fn-date/functions.c:194 ../plugins/fn-date/functions.c:489
msgid "serial:date and time serial value"
msgstr "série: valor série de data e hora"

#: ../plugins/fn-date/functions.c:195
msgid ""
"DATEVALUE returns the date serial value part of a date and time serial value."
msgstr ""
"A função DATA.VALOR devolve o valor série da parte de data num valor série "
"de data e hora."

#: ../plugins/fn-date/functions.c:211
msgid "DATEDIF:difference between dates"
msgstr "DIF.DATAS: diferença entre datas"

#: ../plugins/fn-date/functions.c:212 ../plugins/fn-date/functions.c:719
#: ../plugins/fn-date/functions.c:1048 ../plugins/fn-date/functions.c:1360
#: ../plugins/fn-date/functions.c:1390
msgid "start_date:starting date serial value"
msgstr "data_inicial: valor série da data inicial"

#: ../plugins/fn-date/functions.c:213 ../plugins/fn-date/functions.c:720
#: ../plugins/fn-date/functions.c:1049 ../plugins/fn-date/functions.c:1361
#: ../plugins/fn-date/functions.c:1389
msgid "end_date:ending date serial value"
msgstr "data_final: valor série da data final"

#: ../plugins/fn-date/functions.c:214
msgid "interval:counting unit"
msgstr "intervalo: unidade de contagem"

#: ../plugins/fn-date/functions.c:215
msgid ""
"DATEDIF returns the distance from @{start_date} to @{end_date} according to "
"the unit specified by @{interval}."
msgstr ""
"A função DIF.DATAS devolve a distância entre @{data_inicial} e @{data_final} "
"de acordo com a unidade especificada em @{intervalo}."

#: ../plugins/fn-date/functions.c:216
msgid ""
"If @{interval} is \"y\", \"m\", or \"d\" then the distance is measured in "
"complete years, months, or days respectively."
msgstr ""
"Se @{intervalo} for \"a\", \"m\" ou \"d\", a distância é medida em anos, "
"meses ou dias completos, respetivamente."

#: ../plugins/fn-date/functions.c:217
msgid ""
"If @{interval} is \"ym\" or \"yd\" then the distance is measured in complete "
"months or days, respectively, but excluding any difference in years."
msgstr ""
"Se @{intervalo} for \"am\" ou \"ad\", a distância é medida em meses ou dias "
"completos, respetivamente, mas excluindo qualquer diferença em anos."

#: ../plugins/fn-date/functions.c:218
msgid ""
"If @{interval} is \"md\" then the distance is measured in complete days but "
"excluding any difference in months."
msgstr ""
"Se @{intervalo} for \"md\", a distância é medida em dias completos, mas "
"excluindo qualquer diferença em meses."

#: ../plugins/fn-date/functions.c:350
msgid "EDATE:adjust a date by a number of months"
msgstr "DATAMÊS: ajusta uma data um certo número de meses"

#: ../plugins/fn-date/functions.c:351 ../plugins/fn-date/functions.c:577
#: ../plugins/fn-date/functions.c:601 ../plugins/fn-date/functions.c:625
#: ../plugins/fn-date/functions.c:649 ../plugins/fn-date/functions.c:761
#: ../plugins/fn-date/functions.c:801 ../plugins/fn-date/functions.c:1261
#: ../plugins/fn-date/functions.c:1285 ../plugins/fn-date/functions.c:1321
msgid "date:date serial value"
msgstr "data: valor série de data"

#: ../plugins/fn-date/functions.c:352 ../plugins/fn-date/functions.c:762
msgid "months:signed number of months"
msgstr "meses: número de meses a ajustar"

#: ../plugins/fn-date/functions.c:353
msgid ""
"EDATE returns @{date} moved forward or backward the number of months "
"specified by @{months}."
msgstr ""
"A função DATAMÊS devolve @{data} movida para o futuro ou para o passado "
"@{meses} meses."

#: ../plugins/fn-date/functions.c:387
msgid "TODAY:the date serial value of today"
msgstr "HOJE: o valor série da data de hoje"

#: ../plugins/fn-date/functions.c:388
msgid ""
"The TODAY function returns the date serial value of the day it is computed.  "
"Recomputing on a later date will produce a different value."
msgstr ""
"A função HOJE devolve o valor série da data do dia em que é calculada. "
"Recalcular noutro dia produz um valor diferente."

#: ../plugins/fn-date/functions.c:404
msgid "NOW:the date and time serial value of the current time"
msgstr "AGORA: o valor série de data e hora atuais"

#: ../plugins/fn-date/functions.c:405
msgid ""
"The NOW function returns the date and time serial value of the moment it is "
"computed.  Recomputing later will produce a different value."
msgstr ""
"A função AGORA devolve o valor série da data e hora no momento em que é "
"calculada. Recalcular noutra altura produz um resultado diferente."

#: ../plugins/fn-date/functions.c:421
msgid "TIME:create a time serial value"
msgstr "HORA: cria um valor série das horas"

#: ../plugins/fn-date/functions.c:422
msgid "hour:hour of the day"
msgstr "hora: hora do dia"

#: ../plugins/fn-date/functions.c:423
msgid "minute:minute within the hour"
msgstr "minuto: minuto dentro da hora"

#: ../plugins/fn-date/functions.c:424
msgid "second:second within the minute"
msgstr "segundo: segundo dentro do minuto"

#: ../plugins/fn-date/functions.c:425
msgid ""
"The TIME function computes the fractional day after midnight at the time "
"given by @{hour}, @{minute}, and @{second}."
msgstr ""
"A função HORA calcula o dia fracional após a meia noite na hora dada por "
"@{hora}, @{minuto} e @{segundo}."

#: ../plugins/fn-date/functions.c:426
msgid ""
"While the return value is automatically formatted to look like a time "
"between 0:00 and 24:00, the underlying serial time value is a number between "
"0 and 1."
msgstr ""
"Enquanto o resultado é automaticamente formatado como 0:00 e 24:00, o valor "
"série subjacente é um número entre 0 e 1."

#: ../plugins/fn-date/functions.c:428
msgid ""
"If any of @{hour}, @{minute}, and @{second} is negative, #NUM! is returned"
msgstr "Se @{hora}, @{minuto} ou @{segundo} forem negativos, devolve \"NUM!."

#: ../plugins/fn-date/functions.c:458
msgid "ODF.TIME:create a time serial value"
msgstr "HORA.ODF: cria um valor série das horas"

#: ../plugins/fn-date/functions.c:459
msgid "hour:hour"
msgstr "hora: hora"

#: ../plugins/fn-date/functions.c:460
msgid "minute:minute"
msgstr "minuto: minuto"

#: ../plugins/fn-date/functions.c:461
msgid "second:second"
msgstr "segundo: segundo"

#: ../plugins/fn-date/functions.c:462
msgid ""
"The ODF.TIME function computes the time given by @{hour}, @{minute}, and "
"@{second} as a fraction of a day."
msgstr ""
"A função HORA.ODF calcula a hora dada por @{hora}, @{minuto} e @{segundo} "
"como uma fração do dia."

#: ../plugins/fn-date/functions.c:463
msgid ""
"While the return value is automatically formatted to look like a time "
"between 0:00 and 24:00, the underlying serial time value can be any number."
msgstr ""
"Enquanto o resultado é automaticamente formatado como 0:00 e 24:00, o valor "
"série subjacente pode ser qualquer número."

#: ../plugins/fn-date/functions.c:467 ../plugins/fn-date/functions.c:810
#: ../plugins/fn-date/functions.c:1057 ../plugins/fn-date/functions.c:1392
#: ../plugins/fn-eng/functions.c:213 ../plugins/fn-eng/functions.c:317
#: ../plugins/fn-eng/functions.c:386 ../plugins/fn-eng/functions.c:833
#: ../plugins/fn-financial/functions.c:1312 ../plugins/fn-math/functions.c:564
#: ../plugins/fn-math/functions.c:1145 ../plugins/fn-math/functions.c:1172
#: ../plugins/fn-math/functions.c:1548 ../plugins/fn-math/functions.c:1568
#: ../plugins/fn-math/functions.c:2252 ../plugins/fn-math/functions.c:2916
#: ../plugins/fn-math/functions.c:3116 ../plugins/fn-stat/functions.c:1695
#: ../plugins/fn-stat/functions.c:2598 ../plugins/fn-stat/functions.c:4969
#: ../plugins/fn-string/functions.c:308 ../plugins/fn-string/functions.c:392
#: ../plugins/fn-string/functions.c:519 ../plugins/fn-string/functions.c:1207
#: ../plugins/fn-string/functions.c:1523 ../plugins/fn-string/functions.c:1653
msgid "This function is OpenFormula compatible."
msgstr "Esta função é compatível com OpenFormula."

#: ../plugins/fn-date/functions.c:488
msgid "TIMEVALUE:the time part of a date and time serial value"
msgstr "HORA.VALOR: a parte de hora de um valor série de data e hora"

#: ../plugins/fn-date/functions.c:490
msgid "TIMEVALUE returns the time-of-day part of a date and time serial value."
msgstr ""
"A função HORA.VALOR devolve a parte hora do dia de um valor série de data e "
"hora."

#: ../plugins/fn-date/functions.c:507
msgid "HOUR:compute hour part of fractional day"
msgstr "HORA: calcula a parte horária de um dia fracional"

#: ../plugins/fn-date/functions.c:508 ../plugins/fn-date/functions.c:531
#: ../plugins/fn-date/functions.c:554
msgid "time:time of day as fractional day"
msgstr "hora: hora do dia como dia fracional"

#: ../plugins/fn-date/functions.c:509
msgid ""
"The HOUR function computes the hour part of the fractional day given by "
"@{time}."
msgstr ""
"A função HORA calcula a parte horária do dia fracional indicada por @{hora}."

#: ../plugins/fn-date/functions.c:530
msgid "MINUTE:compute minute part of fractional day"
msgstr "MINUTO: calcula a parte minutos de um dia fracional"

#: ../plugins/fn-date/functions.c:532
msgid ""
"The MINUTE function computes the minute part of the fractional day given by "
"@{time}."
msgstr ""
"A função MINUTO calcula a parte de minutos do dia fracional indicada por "
"@{hora}."

#: ../plugins/fn-date/functions.c:553
msgid "SECOND:compute seconds part of fractional day"
msgstr "SEGUNDO: calcula a parte segundos de um dia fracional"

#: ../plugins/fn-date/functions.c:555
msgid ""
"The SECOND function computes the seconds part of the fractional day given by "
"@{time}."
msgstr ""
"A função SEGUNDO calcula a parte de segundos do dia fracional indicada por "
"@{hora}."

#: ../plugins/fn-date/functions.c:576
msgid "YEAR:the year part of a date serial value"
msgstr "ANO: a parte ano de um valor série de data"

#: ../plugins/fn-date/functions.c:578
msgid "The YEAR function returns the year part of @{date}."
msgstr "A função ANO devolve a parte ano indicada por @{data}."

#: ../plugins/fn-date/functions.c:600
msgid "MONTH:the month part of a date serial value"
msgstr "MÊS: a parte mês de um valor série de data"

#: ../plugins/fn-date/functions.c:602
msgid "The MONTH function returns the month part of @{date}."
msgstr "A função MÊS devolve a parte mês indicada por @{data}."

#: ../plugins/fn-date/functions.c:624
msgid "DAY:the day-of-month part of a date serial value"
msgstr "DIA: a parte dia do mês de um valor série de data"

#: ../plugins/fn-date/functions.c:626
msgid "The DAY function returns the day-of-month part of @{date}."
msgstr "A função DIA devolve a parte dia do mês indicada por @{data}."

#: ../plugins/fn-date/functions.c:648
msgid "WEEKDAY:day-of-week"
msgstr "DIA.SEMANA: dia da semana"

#: ../plugins/fn-date/functions.c:650 ../plugins/fn-date/functions.c:1322
msgid "method:numbering system, defaults to 1"
msgstr "método: sistema de numeração, a predefinição é 1"

#: ../plugins/fn-date/functions.c:651
msgid ""
"The WEEKDAY function returns the day-of-week of @{date}.  The value of "
"@{method} determines how days are numbered; it defaults to 1. "
msgstr ""
"A função DIA.SEMANA devolve o dia da semana de @{data}. O valor de @{método} "
"determina como os dias são numerados; a predefinição é 1."

#: ../plugins/fn-date/functions.c:652
msgid "If @{method} is 1, then Sunday is 1, Monday is 2, etc."
msgstr "Se @{método} for 1, domingo é 1, segunda é 2, etc."

#: ../plugins/fn-date/functions.c:653
msgid "If @{method} is 2, then Monday is 1, Tuesday is 2, etc."
msgstr "Se @{método} for 2, segunda é 1, terça é 2, etc."

#: ../plugins/fn-date/functions.c:654
msgid "If @{method} is 3, then Monday is 0, Tuesday is 1, etc."
msgstr "Se @{método} for 3, segunda é 0, terça é 1, etc."

#: ../plugins/fn-date/functions.c:655
msgid "If @{method} is 11, then Monday is 1, Tuesday is 2, etc."
msgstr "Se @{método} for11, segunda é 1, terça é 2, etc."

#: ../plugins/fn-date/functions.c:656
msgid "If @{method} is 12, then Tuesday is 1, Wednesday is 2, etc."
msgstr "Se @{método} for 12, terça é 1, quarta é 2, etc."

#: ../plugins/fn-date/functions.c:657
msgid "If @{method} is 13, then Wednesday is 1, Thursday is 2, etc."
msgstr "Se @{método} for 13, quarta é 1, quinta é 2, etc."

#: ../plugins/fn-date/functions.c:658
msgid "If @{method} is 14, then Thursday is 1, Friday is 2, etc."
msgstr "Se @{método} for 14, quinta é 1, sexta é 2, etc."

#: ../plugins/fn-date/functions.c:659
msgid "If @{method} is 15, then Friday is 1, Saturday is 2, etc."
msgstr "Se @{método} for 15, sexta é 1, sábado é 2, etc."

#: ../plugins/fn-date/functions.c:660
msgid "If @{method} is 16, then Saturday is 1, Sunday is 2, etc."
msgstr "Se @{método} for 16, sábado é 1, domingo é 2, etc."

#: ../plugins/fn-date/functions.c:661
msgid "If @{method} is 17, then Sunday is 1, Monday is 2, etc."
msgstr "Se @{método} for 17, domingo é 1, segunda é 2, etc."

#: ../plugins/fn-date/functions.c:718
msgid "DAYS360:days between dates"
msgstr "DIAS360: dias entre datas"

#: ../plugins/fn-date/functions.c:721
msgid "method:counting method"
msgstr "método: método de contagem"

#: ../plugins/fn-date/functions.c:722
msgid "DAYS360 returns the number of days from @{start_date} to @{end_date}."
msgstr ""
"A função DIAS360 devolve o número de dias desde @{data_inicial} até "
"@{data_final}."

#: ../plugins/fn-date/functions.c:723
msgid ""
"If @{method} is 0, the default, the MS Excel (tm) US method will be used. "
"This is a somewhat complicated industry standard method where the last day "
"of February is considered to be the 30th day of the month, but only for "
"@{start_date}."
msgstr ""
"Se @{método} for 0, a predefinição, será usado o método MS Excel (tm) EUA. É "
"um método industrial algo complicado em que o último dia de fevereiro é "
"considerado como sendo o dia 30 do mês, mas só para @{data_inicial}."

#: ../plugins/fn-date/functions.c:724
msgid ""
"If @{method} is 1, the European method will be used.  In this case, if the "
"day of the month is 31 it will be considered as 30"
msgstr ""
"Se @{método} for 1, será usado o método europeu. Neste caso, se o dia do mês "
"é 31, será considerado como 30."

#: ../plugins/fn-date/functions.c:725
msgid ""
"If @{method} is 2, a saner version of the US method is used in which both "
"dates get the same February treatment."
msgstr ""
"Se @{método} for 2, será usada uma versão mais sã do método americano, na "
"qual ambas as datas obtêm o mesmo tratamento de fevereiro."

#: ../plugins/fn-date/functions.c:760
msgid "EOMONTH:end of month"
msgstr "FIM.MÊS: fim do mês"

#: ../plugins/fn-date/functions.c:763
msgid ""
"EOMONTH returns the date serial value of the end of the month specified by "
"@{date} adjusted forward or backward the number of months specified by "
"@{months}."
msgstr ""
"A função FIM.MÊS devolve o valor série do fim do mês especificado por "
"@{data}, ajustado para o passado ou para o futuro @{meses} meses."

#: ../plugins/fn-date/functions.c:800
msgid "WORKDAY:add working days"
msgstr "DIA.TRABALHO: adiciona dias de trabalho"

#: ../plugins/fn-date/functions.c:802
msgid "days:number of days to add"
msgstr "dias: número de dias a adicionar"

#: ../plugins/fn-date/functions.c:803 ../plugins/fn-date/functions.c:1050
msgid "holidays:array of holidays"
msgstr "feriados: matriz de feriados"

#: ../plugins/fn-date/functions.c:804 ../plugins/fn-date/functions.c:1051
msgid ""
"weekend:array of 0s and 1s, indicating whether a weekday (S, M, T, W, T, F, "
"S) is on the weekend, defaults to {1,0,0,0,0,0,1}"
msgstr ""
"fim_de_semana: matriz de 0 e 1, indicando se um dia de semana (D, S, T, Q, "
"Q, S, S) está no fim de semana, a predefinição é {1,0,0,0,0,0,1}."

#: ../plugins/fn-date/functions.c:806
msgid ""
"WORKDAY adjusts @{date} by @{days} skipping over weekends and @{holidays} in "
"the process."
msgstr ""
"A função DIA.TRABALHO ajusta a @{data} em @{dias} saltando sobre fins de "
"semana e @{feriados}."

#: ../plugins/fn-date/functions.c:807
msgid "@{days} may be negative."
msgstr "@{dias} pode ser negativo."

#: ../plugins/fn-date/functions.c:808 ../plugins/fn-date/functions.c:1055
msgid ""
"If an entry of @{weekend} is non-zero, the corresponding weekday is not a "
"work day."
msgstr ""
"Se uma entrada de @{fim_de_semana} não for 0, o correspondente dia da semana "
"não é dia de trabalho."

#: ../plugins/fn-date/functions.c:809 ../plugins/fn-date/functions.c:1056
msgid "This function is Excel compatible if the last argument is omitted."
msgstr "Esta função é compatível com Excel se for omitido o último argumento."

#: ../plugins/fn-date/functions.c:1047
msgid "NETWORKDAYS:number of workdays in range"
msgstr "DIASTRABALHOTOTAL: número de dias de trabalho no intervalo"

#: ../plugins/fn-date/functions.c:1053
msgid ""
"NETWORKDAYS calculates the number of days from @{start_date} to @{end_date} "
"skipping weekends and @{holidays} in the process."
msgstr ""
"A função DIASTRABALHOTOTAL calcula o número de dias entre @{data_inicial} e "
"@{data_final}, saltando fins de semana e @{feriados}."

#: ../plugins/fn-date/functions.c:1260
msgid "ISOWEEKNUM:ISO week number"
msgstr "NUM.SEM.ISO: número ISO da semana"

#: ../plugins/fn-date/functions.c:1262
msgid ""
"ISOWEEKNUM calculates the week number according to the ISO 8601 standard.  "
"Weeks start on Mondays and week 1 contains the first Thursday of the year."
msgstr ""
"A função NUM.SEM.ISO calcula o número da semana de acordo com a norma ISO "
"8601. As semanas começam à segunda e a semana 1 contém a primeira quinta "
"feira do ano."

#: ../plugins/fn-date/functions.c:1263 ../plugins/fn-date/functions.c:1287
msgid ""
"January 1 of a year is sometimes in week 52 or 53 of the previous year.  "
"Similarly, December 31 is sometimes in week 1 of the following year."
msgstr ""
"1 de janeiro de um ano está, por vezes, na semana 52 ou 53 do ano anterior. "
"Da mesma forma, 31 de dezembro pode estar na semana 1 do ano seguinte."

#: ../plugins/fn-date/functions.c:1284
msgid "ISOYEAR:year corresponding to the ISO week number"
msgstr "ANO.ISO: ano correspondente ao número ISO da semana"

#: ../plugins/fn-date/functions.c:1286
msgid ""
"ISOYEAR calculates the year to go with week number according to the ISO 8601 "
"standard."
msgstr ""
"A função ANO.ISO calcula o ano para o número da semana de acordo com a norma "
"ISO 8601."

#: ../plugins/fn-date/functions.c:1320
msgid "WEEKNUM:week number"
msgstr "NUM.SEMANA: número da semana"

#: ../plugins/fn-date/functions.c:1323
msgid ""
"WEEKNUM calculates the week number according to @{method} which defaults to "
"1."
msgstr ""
"A função NUM.SEMANA calcula o número da semana de acordo com @{método}, "
"predefinido para 1."

#: ../plugins/fn-date/functions.c:1324
msgid ""
"If @{method} is 1, then weeks start on Sundays and January 1 is in week 1."
msgstr ""
"Se @{método} for 1, a semana começa ao domingo e 1 de janeiro está na semana "
"1."

#: ../plugins/fn-date/functions.c:1325
msgid ""
"If @{method} is 2, then weeks start on Mondays and January 1 is in week 1."
msgstr ""
"Se @{método for 2, a semana começa à segunda e 1 de janeiro está na semana 1."

#: ../plugins/fn-date/functions.c:1326
msgid "If @{method} is 150, then the ISO 8601 numbering is used."
msgstr "Se @{método} for 150, será usada a numeração ISO 8601."

#: ../plugins/fn-date/functions.c:1359
msgid "YEARFRAC:fractional number of years between dates"
msgstr "FRAÇÃOANO: número fracional de anos entre datas"

#: ../plugins/fn-date/functions.c:1362 ../plugins/fn-financial/functions.c:454
#: ../plugins/fn-financial/functions.c:492
#: ../plugins/fn-financial/functions.c:530
#: ../plugins/fn-financial/functions.c:571
#: ../plugins/fn-financial/functions.c:608
#: ../plugins/fn-financial/functions.c:652
#: ../plugins/fn-financial/functions.c:1895
#: ../plugins/fn-financial/functions.c:2261
#: ../plugins/fn-financial/functions.c:2311
#: ../plugins/fn-financial/functions.c:2418
#: ../plugins/fn-financial/functions.c:2464
#: ../plugins/fn-financial/functions.c:2506
#: ../plugins/fn-financial/functions.c:2656
#: ../plugins/fn-financial/functions.c:2751
#: ../plugins/fn-financial/functions.c:2829
#: ../plugins/fn-financial/functions.c:2906
#: ../plugins/fn-financial/functions.c:2962
#: ../plugins/fn-financial/functions.c:3005
#: ../plugins/fn-financial/functions.c:3029
#: ../plugins/fn-financial/functions.c:3053
#: ../plugins/fn-financial/functions.c:3077
#: ../plugins/fn-financial/functions.c:3103
#: ../plugins/fn-financial/functions.c:3129
#: ../plugins/fn-financial/functions.c:3243
msgid "basis:calendar basis"
msgstr "base: calendário base"

#: ../plugins/fn-date/functions.c:1363
msgid ""
"YEARFRAC calculates the number of days from @{start_date} to @{end_date} "
"according to the calendar specified by @{basis}, which defaults to 0, and "
"expresses the result as a fractional number of years."
msgstr ""
"A função FRAÇÃOANO calcula o número de dias entre @{data_inicial} e "
"@{data_final} de acordo com o calendário especificado por @{base}, "
"predefinido como 0 e expressa o resultado como um número fracional de anos."

#: ../plugins/fn-date/functions.c:1388
msgid "DAYS:difference between dates in days"
msgstr "DIAS: diferença entre datas, em dias"

#: ../plugins/fn-date/functions.c:1391
msgid ""
"DAYS returns the positive or negative number of days from @{start_date} to "
"@{end_date}."
msgstr ""
"A função DIAS devolve o número positivo ou negativo de dias entre "
"@{data_inicial} e @{data_final}."

#. Some common decriptors
#: ../plugins/fn-derivatives/options.c:46
msgid "call_put_flag:'c' for a call and 'p' for a put"
msgstr "call_put_flag:\"c\" para uma chamada e \"p\" para um posto"

#: ../plugins/fn-derivatives/options.c:47
msgid "spot:spot price"
msgstr "local: preço local"

#: ../plugins/fn-derivatives/options.c:48
msgid "strike:strike price"
msgstr "golpe: preço do golpe"

#: ../plugins/fn-derivatives/options.c:49
msgid "time:time to maturity in years"
msgstr "prazo: prazo de maturidade, em anos"

#: ../plugins/fn-derivatives/options.c:50
msgid "time:time to maturity in days"
msgstr "prazo: prazo de maturidade, em dias"

#: ../plugins/fn-derivatives/options.c:51
msgid "time_payout:time to dividend payout"
msgstr "prazo_pag: prazo até receber dividendos"

#: ../plugins/fn-derivatives/options.c:52
msgid "time_exp:time to expiration"
msgstr "prazo_exp: prazo de expiração"

#: ../plugins/fn-derivatives/options.c:53
msgid "rate:risk-free interest rate to the exercise date in percent"
msgstr ""
"taxa: taxa de juro isenta de risco para a data do exercício, em percentagem"

#: ../plugins/fn-derivatives/options.c:54
msgid "rate:annualized interest rate"
msgstr "taxa: taxa de juro anual"

#: ../plugins/fn-derivatives/options.c:55
msgid "rate:annualized risk-free interest rate"
msgstr "taxa: taxa de juro anual isenta de risco"

#: ../plugins/fn-derivatives/options.c:56
msgid ""
"volatility:annualized volatility of the asset in percent for the period "
"through to the exercise date"
msgstr ""
"volatilidade: volatilidade anual do ativo em percentagem para o período "
"durante a data do exercício"

#: ../plugins/fn-derivatives/options.c:57
msgid "volatility:annualized volatility of the asset"
msgstr "volatilidade: volatilidade anual do ativo"

#: ../plugins/fn-derivatives/options.c:58
msgid "d:amount of the dividend to be paid expressed in currency"
msgstr "d:montante do dividendo a ser pago, expresso em moeda"

#: ../plugins/fn-derivatives/options.c:59
msgid ""
"cost_of_carry:net cost of holding the underlying asset (for common stocks, "
"the risk free rate less the dividend yield), defaults to 0"
msgstr ""
"custo_posse: custo líquido de manter o ativo subjacente (para ações comuns, "
"A taxa livre de risco menos o rendimento dos dividendos), predefinido para 0"

#: ../plugins/fn-derivatives/options.c:60
msgid "cost_of_carry:net cost of holding the underlying asset"
msgstr "custo_posse: custo líquido de manter o ativo subjacente"

#: ../plugins/fn-derivatives/options.c:62
msgid ""
"The returned value will be expressed in the same units as @{strike} and "
"@{spot}."
msgstr ""
"O valor devolvido está expresso nas mesmas unidades de @{golpe} e @{local}."

#: ../plugins/fn-derivatives/options.c:192
msgid "CUM_BIV_NORM_DIST:cumulative bivariate normal distribution"
msgstr "DIST.NORM.CUM.BIV: distribuição normal cumulativa bivariada"

#: ../plugins/fn-derivatives/options.c:193
msgid "a:limit for first random variable"
msgstr "a: limite para a primeira variável aleatória"

#: ../plugins/fn-derivatives/options.c:194
msgid "b:limit for second random variable"
msgstr "b: limite para a segunda variável aleatória"

#: ../plugins/fn-derivatives/options.c:195
msgid "rho:correlation of the two random variables"
msgstr "ro: correlação das duas variáveis aleatórias"

#: ../plugins/fn-derivatives/options.c:196
msgid ""
"CUM_BIV_NORM_DIST calculates the probability that two standard normal "
"distributed random variables with correlation @{rho} are respectively each "
"less than @{a} and @{b}."
msgstr ""
"A função DIST.NORM.CUM.BIV calcula a probabilidade de duas variáveis "
"aleatórias normalmente distribuídas com correlação @{ro} serem "
"respetivamente cada menor que @{a} e @{b}."

#: ../plugins/fn-derivatives/options.c:245
msgid "OPT_BS:price of a European option"
msgstr "OPT_BS: preço de uma opção europeia"

#: ../plugins/fn-derivatives/options.c:253
msgid ""
"OPT_BS uses the Black-Scholes model to calculate the price of a European "
"option struck at @{strike} on an asset with spot price @{spot}."
msgstr ""
"OPT-BS usa o modelo Black Scholes para calcular o preço de uma opção "
"Europeia atingido em @{golpe} num ativo com preço @{local}."

#: ../plugins/fn-derivatives/options.c:302
msgid "OPT_BS_DELTA:delta of a European option"
msgstr "OPT_BS_DELTA:delta de uma opção europeia"

#: ../plugins/fn-derivatives/options.c:310
msgid ""
"OPT_BS_DELTA uses the Black-Scholes model to calculate the 'delta' of a "
"European option struck at @{strike} on an asset with spot price @{spot}."
msgstr ""
"OPT_BS_DELTA usa o modelo Black Scholes para calcular o intervalo de uma "
"opção Europeia atingido em @{golpe} num ativo com preço @{local}."

#: ../plugins/fn-derivatives/options.c:344
msgid "OPT_BS_GAMMA:gamma of a European option"
msgstr "OPT_BS_GAMMA:gama de uma opção europeia"

#: ../plugins/fn-derivatives/options.c:351
msgid ""
"OPT_BS_GAMMA uses the Black-Scholes model to calculate the 'gamma' of a "
"European option struck at @{strike} on an asset with spot price @{spot}. The "
"gamma of an option is the second derivative of its price with respect to the "
"price of the underlying asset."
msgstr ""
"OPT_BS_GAMA: usa o modelo Black Scholes para calcular o gama de uma opção "
"Europeia atingido em @{golpe} num ativo com preço @{local}. O gama de uma "
"oipção é a segunda derivativa do seu preço respeitante ao preço do ativo "
"subjacente."

#: ../plugins/fn-derivatives/options.c:356
msgid ""
"Gamma is expressed as the rate of change of delta per unit change in @{spot}."
msgstr ""
"O gama é expresso como a taxa de alteração delta por unidade alterada em "
"@{local}."

#: ../plugins/fn-derivatives/options.c:358
msgid "Gamma is the same for calls and puts."
msgstr "O gama é o mesmo para chamadas e posições."

#: ../plugins/fn-derivatives/options.c:401
msgid "OPT_BS_THETA:theta of a European option"
msgstr "OPT_BS_THETA:teta de uma opção europeia"

#: ../plugins/fn-derivatives/options.c:409
msgid ""
"OPT_BS_THETA uses the Black-Scholes model to calculate the 'theta' of a "
"European option struck at @{strike} on an asset with spot price @{spot}. The "
"theta of an option is the rate of change of its price with respect to time "
"to expiry."
msgstr ""
"OPT_BS_TETA usa o modelo Black Scholes para calcular o \"teta\" de uma opção "
"Europeia atingido em @{golpe} num ativo com preço @{local}. O teta de uma "
"opção é a taxa de alteração do seu preço respeitante ao prazo de expiração."

#: ../plugins/fn-derivatives/options.c:414
msgid ""
"Theta is expressed as the negative of the rate of change of the option "
"value, per 365.25 days."
msgstr ""
"O teta é expresso como negativo da taxa de alteração do valor da opção, por "
"365,25 dias."

#: ../plugins/fn-derivatives/options.c:445
msgid "OPT_BS_VEGA:vega of a European option"
msgstr "OPT_BS_VEGA:vega de uma opção europeia"

#: ../plugins/fn-derivatives/options.c:452
msgid ""
"OPT_BS_VEGA uses the Black-Scholes model to calculate the 'vega' of a "
"European option struck at @{strike} on an asset with spot price @{spot}. The "
"vega of an option is the rate of change of its price with respect to "
"volatility."
msgstr ""
"OPT_BS_VEGA usa o modelo Black Scholes para calcular o \"vega\" de uma opção "
"Europeia atingido em @{golpe} num ativo com preço @{local}. O vega de uma "
"opção é a taxa de alteração do seu preço respeitante à volatilidade."

#: ../plugins/fn-derivatives/options.c:457
msgid "Vega is the same for calls and puts."
msgstr "O vega é o mesmo para chamadas e posições."

#: ../plugins/fn-derivatives/options.c:459
#, no-c-format
msgid ""
"Vega is expressed as the rate of change of option value, per 100% volatility."
msgstr ""
"O vega é expresso como a taxa de alteração do valor da opção, por 100% de "
"volatilidade."

#: ../plugins/fn-derivatives/options.c:510
msgid "OPT_BS_RHO:rho of a European option"
msgstr "OPT_BS_RO:rho de uma opção europeia"

#: ../plugins/fn-derivatives/options.c:518
msgid ""
"OPT_BS_RHO uses the Black-Scholes model to calculate the 'rho' of a European "
"option struck at @{strike} on an asset with spot price @{spot}. The rho of "
"an option is the rate of change of its price with respect to the risk free "
"interest rate."
msgstr ""
"OPT_BS_RO usa o modelo Black Scholes para calcular o \"ro\" de uma opção "
"Europeia atingido em @{golpe} num ativo com preço @{local}. O ro de uma "
"opção é a taxa de alteração do seu preço respeitante à taxa de juro isenta "
"de risco."

#: ../plugins/fn-derivatives/options.c:524
#, no-c-format
msgid ""
"Rho is expressed as the rate of change of the option value, per 100% change "
"in @{rate}."
msgstr ""
"Ro é expreso como a taxa de alteração do valor da opção, por 100% de "
"alteração na @{taxa}."

#: ../plugins/fn-derivatives/options.c:566
msgid "OPT_BS_CARRYCOST:elasticity of a European option"
msgstr "OPT_BS_CUSTO_POSSE: elasticidade de uma opção europeia"

#: ../plugins/fn-derivatives/options.c:574
msgid ""
"OPT_BS_CARRYCOST uses the Black-Scholes model to calculate the 'elasticity' "
"of a European option struck at @{strike} on an asset with spot price "
"@{spot}. The elasticity of an option is the rate of change of its price with "
"respect to its @{cost_of_carry}."
msgstr ""
"OPT_BS_CUSTO_POSSE usa o modelo Black Scholes para calcular a elasticidade "
"de uma opção Europeia atingido em @{golpe} num ativo com preço @{local}. A "
"elasticidade de uma opção é a taxa de alteração do seu preço respeitante ao "
"seu {custo_posse}."

#: ../plugins/fn-derivatives/options.c:580
#, no-c-format
msgid ""
"Elasticity is expressed as the rate of change of the option value, per 100% "
"volatility."
msgstr ""
"A elasticidade é expressa como a taxa de alteração do valor da opção, por "
"100 % de volatilidade."

#: ../plugins/fn-derivatives/options.c:624
msgid "OPT_GARMAN_KOHLHAGEN:theoretical price of a European currency option"
msgstr "OPT_GARMAN_KOHLHAGEN:preço teórico de uma opção europeia de moeda"

#: ../plugins/fn-derivatives/options.c:628
msgid "time:number of days to exercise"
msgstr "tempo: número de dias do exercício"

#: ../plugins/fn-derivatives/options.c:629
msgid ""
"domestic_rate:domestic risk-free interest rate to the exercise date in "
"percent"
msgstr ""
"taxa_doméstica: taxa de juro doméstica isenta de risco para a data do "
"exercício em percentagem"

#: ../plugins/fn-derivatives/options.c:630
msgid ""
"foreign_rate:foreign risk-free interest rate to the exercise date in percent"
msgstr ""
"taxa_estrangeira: taxa de juro estrangeira isenta de risco para a data do "
"exercício em percentagem"

#: ../plugins/fn-derivatives/options.c:632
msgid ""
"OPT_GARMAN_KOHLHAGEN values the theoretical price of a European currency "
"option struck at @{strike} on an asset with spot price @{spot}."
msgstr ""
"OPT_GARMAN_KOHLHAGEN avalia o preço teórico de uma opção europeia de moeda "
"atingido em @{golpe} num ativo com preço @{local}."

#: ../plugins/fn-derivatives/options.c:678
msgid ""
"OPT_FRENCH:theoretical price of a European option adjusted for trading day "
"volatility"
msgstr ""
"OPT_FRANCÊS: preço teórico de uma opção europeia ajustado para a "
"volatilidade do dia de comércio"

#: ../plugins/fn-derivatives/options.c:682
msgid ""
"time:ratio of the number of calendar days to exercise and the number of "
"calendar days in the year"
msgstr ""
"tempo: proporção entre o número de dias de calendário do exercício e o "
"número de dias do ano"

#: ../plugins/fn-derivatives/options.c:683
msgid ""
"ttime:ratio of the number of trading days to exercise and the number of "
"trading days in the year"
msgstr ""
"tempot: proporção entre o número de dias de comércio do exercício e o número "
"de dias de comércio do ano"

#: ../plugins/fn-derivatives/options.c:687
msgid ""
"OPT_FRENCH values the theoretical price of a European option adjusted for "
"trading day volatility, struck at @{strike} on an asset with spot price "
"@{spot}."
msgstr ""
"OPT_FRANCÊS avalia o preço teórico de uma opção europeia ajustado para a "
"volatilidade do dia de comércio, atingido em @{golpe} num ativo com preço "
"@{local}."

#: ../plugins/fn-derivatives/options.c:731
msgid ""
"OPT_JUMP_DIFF:theoretical price of an option according to the Jump Diffusion "
"process"
msgstr ""
"OPT_JUMP_DIF: preço teórico de uma opção de acorda com o processo Jump "
"Diffusion"

#: ../plugins/fn-derivatives/options.c:736
msgid "rate:the annualized rate of interest"
msgstr "taxa: a taxa de juro anual"

#: ../plugins/fn-derivatives/options.c:738
msgid "lambda:expected number of 'jumps' per year"
msgstr "lâmbda: número de \"saltos\" esperado por ano"

#: ../plugins/fn-derivatives/options.c:739
msgid "gamma:proportion of volatility explained by the 'jumps'"
msgstr "gama: proporção de volatilidade explicada pelos \"saltos\""

#: ../plugins/fn-derivatives/options.c:740
msgid ""
"OPT_JUMP_DIFF models the theoretical price of an option according to the "
"Jump Diffusion process (Merton)."
msgstr ""
"OPT_JUMP_DIF modela o preço teórico de uma opção de acordo com o processo "
"Jump Diffusion (Merton)."

#: ../plugins/fn-derivatives/options.c:818
msgid ""
"OPT_MILTERSEN_SCHWARTZ:theoretical price of options on commodities futures "
"according to Miltersen & Schwartz"
msgstr ""
"OPT_MILTERSEN_SCHWARTZ: preço teórico de opções em mercadorias futuras de "
"acordo com Miltersen & Schwartz"

#: ../plugins/fn-derivatives/options.c:820
msgid "p_t:zero coupon bond with expiry at option maturity"
msgstr "p_t: ação com zero cupões com expiração na maturidade da opção"

#: ../plugins/fn-derivatives/options.c:821
msgid "f_t:futures price"
msgstr "f_T: preço futuro"

#: ../plugins/fn-derivatives/options.c:823
msgid "t1:time to maturity of the option"
msgstr "t1: tempo até à maturidade da opção"

#: ../plugins/fn-derivatives/options.c:824
msgid "t2:time to maturity of the underlying commodity futures contract"
msgstr ""
"t2: tempo até à maturidade do contrato subjacente ao futuro da mercadoria"

#: ../plugins/fn-derivatives/options.c:825
msgid "v_s:volatility of the spot commodity price"
msgstr "v_s: volatilidade do preço da mercadoria local"

#: ../plugins/fn-derivatives/options.c:826
msgid "v_e:volatility of the future convenience yield"
msgstr "v_E: volatilidade do rendimento da conveniência futura"

#: ../plugins/fn-derivatives/options.c:827
msgid "v_f:volatility of the forward rate of interest"
msgstr "v_f: volatilidade da taxa de juro adiantada"

#: ../plugins/fn-derivatives/options.c:828
msgid ""
"rho_se:correlation between the spot commodity price and the convenience yield"
msgstr ""
"ro_se: correlação entre o preço local da mercadoria e o rendimento da "
"conveniência"

#: ../plugins/fn-derivatives/options.c:829
msgid ""
"rho_sf:correlation between the spot commodity price and the forward interest "
"rate"
msgstr ""
"ro_sf: correlação entre o preço local da mercadoria e a taxa de juro "
"adiantada"

#: ../plugins/fn-derivatives/options.c:830
msgid ""
"rho_ef:correlation between the forward interest rate and the convenience "
"yield"
msgstr ""
"ro_ef: correlação entre a taxa de juro adiantada e o rendimento da "
"conveniência"

#: ../plugins/fn-derivatives/options.c:831
msgid "kappa_e:speed of mean reversion of the convenience yield"
msgstr "kapa_e: velocidade da reversão média do rendimento da conveniência"

#: ../plugins/fn-derivatives/options.c:832
msgid "kappa_f:speed of mean reversion of the forward interest rate"
msgstr "kapa_f: velocidade da reversão média da taxa de juro avançada"

#: ../plugins/fn-derivatives/options.c:915
msgid ""
"OPT_RGW:theoretical price of an American option according to the Roll-Geske-"
"Whaley approximation"
msgstr ""
"OPT_RGW: preço teórico de uma opção americana de acordo com a aproximação "
"Roll-Geske_Whaley"

#: ../plugins/fn-derivatives/options.c:958
msgid ""
"OPT_BAW_AMER:theoretical price of an option according to the Barone Adesie & "
"Whaley approximation"
msgstr ""
"OPT_BAW_AMER:preço teórico de uma opção de acordo com a aproximação Barone "
"Adesie & Whaley"

#: ../plugins/fn-derivatives/options.c:1130
msgid ""
"OPT_BJER_STENS:theoretical price of American options according to the "
"Bjerksund & Stensland approximation technique"
msgstr ""
"OPT_BJER_STENS:preço teórico de opções americanas de acordo com a técnica de "
"aproximação de Bjerksund & Stensland"

#: ../plugins/fn-derivatives/options.c:1204
msgid "OPT_EXEC:theoretical price of executive stock options"
msgstr "OPT_EXEC: preço teórico de opções de ações de executivos"

#: ../plugins/fn-derivatives/options.c:1212
msgid "lambda:jump rate for executives"
msgstr "lâmbda: taxa de salto para executivos"

#: ../plugins/fn-derivatives/options.c:1213
msgid ""
"The model assumes executives forfeit their options if they leave the company."
msgstr ""
"O modelo assume que executivos desistem das suas opções se sairem da empresa."

#: ../plugins/fn-derivatives/options.c:1242
msgid "OPT_FORWARD_START:theoretical price of forward start options"
msgstr "OPT_INÍCIO_ADIANTADO: preço teórico de opções de início adiantado"

#: ../plugins/fn-derivatives/options.c:1245
msgid ""
"alpha:fraction setting the strike price at the future date @{time_start}"
msgstr ""
"alfa: fração que define o preço de golpe na data futura @{tempo_inicial}"

#: ../plugins/fn-derivatives/options.c:1246
msgid "time_start:time until the option starts in days"
msgstr "tempo_inicial: tempo até que a opção inicie, em dias"

#: ../plugins/fn-derivatives/options.c:1294
msgid "OPT_TIME_SWITCH:theoretical price of time switch options"
msgstr "OPT_TROCA_TEMPO: preço teórico das opções de troca de tempo"

#: ../plugins/fn-derivatives/options.c:1298
msgid "a:amount received for each time period"
msgstr "a: montante recebido por cada período de tempo"

#: ../plugins/fn-derivatives/options.c:1300
msgid "m:number of time units the option has already met the condition"
msgstr "m: número de unidades de tempo em que a opção já cumpriu a condição"

#: ../plugins/fn-derivatives/options.c:1301
msgid "dt:agreed upon discrete time period expressed as a fraction of a year"
msgstr ""
"dt: acordo com um período de tempo discreto expresso como fração do ano"

#: ../plugins/fn-derivatives/options.c:1306
msgid ""
"OPT_TIME_SWITCH models the theoretical price of time switch options. (Pechtl "
"1995). The holder receives @{a} * @{dt} for each period that the asset price "
"was greater than @{strike} (for a call) or below it (for a put)."
msgstr ""
"OPT_TROCA_TEMPO modela o preço teórico das opções de troca de tempo (Pechtl "
"1995). O detentor recebe @{a} * @{dt} por cada período em que o preço do "
"ativo foi superior a @{golpe} (para uma chamada) ou inferior (para uma "
"posição)."

#: ../plugins/fn-derivatives/options.c:1336
msgid "OPT_SIMPLE_CHOOSER:theoretical price of a simple chooser option"
msgstr "OPT_ESCOLHA_SIMPLES: preço teórico de uma opção de escolha simples"

#: ../plugins/fn-derivatives/options.c:1340
msgid "time1:time in years until the holder chooses a put or a call option"
msgstr ""
"tempo1: tempo em anos até que o detentor escolha uma opção de posição ou "
"chamada"

#: ../plugins/fn-derivatives/options.c:1341
msgid "time2:time in years until the chosen option expires"
msgstr "tempo2: tempo em anos até que a opção escolhida expire"

#: ../plugins/fn-derivatives/options.c:1385
msgid "OPT_COMPLEX_CHOOSER:theoretical price of a complex chooser option"
msgstr "OPT_ESCOLHA_COMPLEXA: preço teórico de uma opção de escolha complexa"

#: ../plugins/fn-derivatives/options.c:1387
msgid "strike_call:strike price, if exercised as a call option"
msgstr "chamada_golpe: preço do golpe, se exercido como opção de chamada"

#: ../plugins/fn-derivatives/options.c:1388
msgid "strike_put:strike price, if exercised as a put option"
msgstr "posição_golpe: preço de golpe, se exercido como opção de posição"

#: ../plugins/fn-derivatives/options.c:1389
msgid "time:time in years until the holder chooses a put or a call option"
msgstr ""
"tempo: tempo em anos até que o detentor escolha uma opção de posição ou "
"chamada"

#: ../plugins/fn-derivatives/options.c:1390
msgid "time_call:time in years to maturity of the call option if chosen"
msgstr ""
"chamada_tempo: tempo em anos até à maturidade da opção de chamada, se "
"escolhida"

#: ../plugins/fn-derivatives/options.c:1391
msgid "time_put:time in years  to maturity of the put option if chosen"
msgstr ""
"posição_tempo: tempo em anos até à maturidade da opção de posição, se "
"escolhida"

#: ../plugins/fn-derivatives/options.c:1486
msgid "OPT_ON_OPTIONS:theoretical price of options on options"
msgstr "OPT_EM_OPÇÕES: preço teórico de opções em opções"

#: ../plugins/fn-derivatives/options.c:1487
msgid ""
"type_flag:'cc' for calls on calls, 'cp' for calls on puts, and so on for "
"'pc', and 'pp'"
msgstr ""
"bandeira_tipo: \"cc\" para chamadas em chamadas, \"cp\" para chamadas em "
"posições e igual para \"pc\" e \"pp\""

#: ../plugins/fn-derivatives/options.c:1489
msgid "strike1:strike price at which the option being valued is struck"
msgstr "golpe1: preço do golpe em que a opção em valorização é atingida"

#: ../plugins/fn-derivatives/options.c:1490
msgid "strike2:strike price at which the underlying option is struck"
msgstr "golpe2: preço do golpe em que a opção subjacente é atingida"

#: ../plugins/fn-derivatives/options.c:1491
msgid "time1:time in years to maturity of the option"
msgstr "tempo1: tempo em anos até à maturidade da opção"

#: ../plugins/fn-derivatives/options.c:1492
msgid "time2:time in years to the maturity of the underlying option"
msgstr "tempo2: tempo em anos até à maturidade da opção subjacente"

#: ../plugins/fn-derivatives/options.c:1494
msgid ""
"cost_of_carry:net cost of holding the underlying asset of the underlying "
"option"
msgstr ""
"custo_posse: preço líquido por manter o ativo subjacente da opção subjacente"

#: ../plugins/fn-derivatives/options.c:1495
msgid ""
"volatility:annualized volatility in price of the underlying asset of the "
"underlying option"
msgstr ""
"volatilidade: volatilidade anual em preço do ativo subjacente da opção "
"subjacente"

#: ../plugins/fn-derivatives/options.c:1496
msgid ""
"For common stocks, @{cost_of_carry} is the risk free rate less the dividend "
"yield."
msgstr ""
"Para ações comuns, @{custo_posse} é a taxa isenta de risco menos o dividendo "
"do rendimento."

#: ../plugins/fn-derivatives/options.c:1497
msgid "@{time2} ≥ @{time1}"
msgstr "@{tempo2} ≥ @{tempo1}"

#: ../plugins/fn-derivatives/options.c:1563
msgid "OPT_EXTENDIBLE_WRITER:theoretical price of extendible writer options"
msgstr ""
"OPT_ESCRITOR_EXTENSÍVEL: preço teórico de opções de escritor extensível"

#: ../plugins/fn-derivatives/options.c:1566
msgid "strike1:strike price at which the option is struck"
msgstr "golpe1: preço de golpe em que a opção é atingida"

#: ../plugins/fn-derivatives/options.c:1567
msgid ""
"strike2:strike price at which the option is re-struck if out of the money at "
"@{time1}"
msgstr ""
"golpe2: preço de golpe em que a opção é reatingida se sem dinheiro em "
"@{tempo1}"

#: ../plugins/fn-derivatives/options.c:1568
msgid "time1:initial maturity of the option in years"
msgstr "tempo1: maturidade inicial da opção em anos"

#: ../plugins/fn-derivatives/options.c:1569
msgid "time2:extended maturity in years if chosen"
msgstr "tempo2: maturidade estendida em anos se escolhida"

#: ../plugins/fn-derivatives/options.c:1573
msgid ""
"OPT_EXTENDIBLE_WRITER models the theoretical price of extendible writer "
"options. These are options that have their maturity extended to @{time2} if "
"the option is out of the money at @{time1}."
msgstr ""
"OPT_ESCRITOR_EXTENSÍVEL modela o preço teórico de opções de escritor "
"extensível. Estas são opções que têm a sua maturidade estendida até "
"@{tempo2} se a opção estiver sem dinheiro em @{tempo1}."

#: ../plugins/fn-derivatives/options.c:1615
msgid ""
"OPT_2_ASSET_CORRELATION:theoretical price of options on 2 assets with "
"correlation @{rho}"
msgstr ""
"OPT_2ATIVOS_CORRELAÇÃO: preço teórico de opções em 2 ativos com correlação "
"@{ro}"

#: ../plugins/fn-derivatives/options.c:1617
msgid "spot1:spot price of the underlying asset of the first option"
msgstr "local1: preço local do ativo subjacente da primeira opção"

#: ../plugins/fn-derivatives/options.c:1618
msgid "spot2:spot price of the underlying asset of the second option"
msgstr "local 2: preço local do ativo subjacente da segunda opção"

#: ../plugins/fn-derivatives/options.c:1619
msgid "strike1:strike prices of the first option"
msgstr "golpe1: preços de golpe da primeira opção"

#: ../plugins/fn-derivatives/options.c:1620
msgid "strike2:strike prices of the second option"
msgstr "golpe2: preços de golpe da segunda opção"

#: ../plugins/fn-derivatives/options.c:1622
msgid ""
"cost_of_carry1:net cost of holding the underlying asset of the first option "
"(for common stocks, the risk free rate less the dividend yield)"
msgstr ""
"custo_posse1: custo líquido de manutenção do ativo subjacente da primeira "
"opção (para ações comuns, a taxa isenta de risco menos o rendimento do "
"dividendo)"

#: ../plugins/fn-derivatives/options.c:1624
msgid ""
"cost_of_carry2:net cost of holding the underlying asset of the second option "
"(for common stocks, the risk free rate less the dividend yield)"
msgstr ""
"custo_posse2: custo líquido de manutenção do ativo subjacente da segunda "
"opção (para ações comuns, a taxa isenta de risco menos o rendimento do "
"dividendo)"

#: ../plugins/fn-derivatives/options.c:1627
msgid ""
"volatility1:annualized volatility in price of the underlying asset of the "
"first option"
msgstr ""
"volatilidade1: volatilidade anual em preço do ativo subjacente da primeira "
"opção"

#: ../plugins/fn-derivatives/options.c:1628
msgid ""
"volatility2:annualized volatility in price of the underlying asset of the "
"second option"
msgstr ""
"volatilidade2: volatilidade anual em preço do ativo subjacente da segunda "
"opção"

#: ../plugins/fn-derivatives/options.c:1629
msgid "rho:correlation between the two underlying assets"
msgstr "ro: correlação entre dois ativos subjacentes"

#: ../plugins/fn-derivatives/options.c:1630
msgid ""
"OPT_2_ASSET_CORRELATION models the theoretical price of options on 2 assets "
"with correlation @{rho}. The payoff for a call is max(@{spot2} - "
"@{strike2},0) if @{spot1} > @{strike1} or 0 otherwise. The payoff for a put "
"is max (@{strike2} - @{spot2}, 0) if @{spot1} < @{strike1} or 0 otherwise."
msgstr ""
"OPT_2ATIVOS_CORRELAÇÃO modela o preço teórico de opções em 2 ativos com "
"correlação @{ro}. O pagamento de uma chamada é MÀXIMO(@{local2} - "
"@{golpe2},0) se @{local1} > @{golpe1} ou então 0. O pagamento de uma posição "
"é MÀXIMO(@{golpe2} - @{local2},0) se @{local1} < @{golpe1} ou então 0. "

#: ../plugins/fn-derivatives/options.c:1665
msgid ""
"OPT_EURO_EXCHANGE:theoretical price of a European option to exchange assets"
msgstr ""
"OPT_EURO_TROCA: um preço teórico du uma opção europeia para trocar ativos"

#: ../plugins/fn-derivatives/options.c:1666
#: ../plugins/fn-derivatives/options.c:1710
msgid "spot1:spot price of asset 1"
msgstr "local1: preço local do ativo 1"

#: ../plugins/fn-derivatives/options.c:1667
#: ../plugins/fn-derivatives/options.c:1711
msgid "spot2:spot price of asset 2"
msgstr "local2: preço local do ativo 2"

#: ../plugins/fn-derivatives/options.c:1668
#: ../plugins/fn-derivatives/options.c:1712
msgid "qty1:quantity of asset 1"
msgstr "qtd1: quantidade do ativo 1"

#: ../plugins/fn-derivatives/options.c:1669
#: ../plugins/fn-derivatives/options.c:1713
msgid "qty2:quantity of asset 2"
msgstr "qtd2: quantidade do ativo 2"

#: ../plugins/fn-derivatives/options.c:1672
#: ../plugins/fn-derivatives/options.c:1716
msgid ""
"cost_of_carry1:net cost of holding asset 1 (for common stocks, the risk free "
"rate less the dividend yield)"
msgstr ""
"custo_posse1: custo líquido de manutenção do ativo 1 (para ações comuns, a "
"taxa isenta de risco menos o rendimento do dividendo)"

#: ../plugins/fn-derivatives/options.c:1674
#: ../plugins/fn-derivatives/options.c:1718
msgid ""
"cost_of_carry2:net cost of holding asset 2 (for common stocks, the risk free "
"rate less the dividend yield)"
msgstr ""
"custo_posse2: custo líquido de manutenção do ativo 2 (para ações comuns, a "
"taxa isenta de risco menos o rendimento do dividendo)"

#: ../plugins/fn-derivatives/options.c:1676
#: ../plugins/fn-derivatives/options.c:1720
msgid "volatility1:annualized volatility in price of asset 1"
msgstr "volatilidade1: volatilidade anual em preço do ativo 1"

#: ../plugins/fn-derivatives/options.c:1677
#: ../plugins/fn-derivatives/options.c:1721
msgid "volatility2:annualized volatility in price of asset 2"
msgstr "volatilidade2: volatilidade anual em preço do ativo 2"

#: ../plugins/fn-derivatives/options.c:1678
#: ../plugins/fn-derivatives/options.c:1722
msgid "rho:correlation between the prices of the two assets"
msgstr "ro: correlação entre os preços dos dois ativos"

#: ../plugins/fn-derivatives/options.c:1679
msgid ""
"OPT_EURO_EXCHANGE models the theoretical price of a European option to "
"exchange one asset with quantity @{qty2} and spot price @{spot2} for another "
"with quantity @{qty1} and spot price @{spot1}."
msgstr ""
"OPT_EURO_TROCA modela o um preço teórico du uma opção europeia para trocar "
"um ativo com a quantidade @{qtd2} e preço local @{local2} por outro com a "
"quantidade @{qtd1} e preço local @{local1}."

#: ../plugins/fn-derivatives/options.c:1709
msgid ""
"OPT_AMER_EXCHANGE:theoretical price of an American option to exchange assets"
msgstr ""
"OPT_AMER_TROCA: preço teórico de uma opção americana para trocar ativos"

#: ../plugins/fn-derivatives/options.c:1723
msgid ""
"OPT_AMER_EXCHANGE models the theoretical price of an American option to "
"exchange one asset with quantity @{qty2} and spot price @{spot2} for another "
"with quantity @{qty1} and spot price @{spot1}."
msgstr ""
"OPT_AMER_TROCA modela o um preço teórico du uma opção americana para trocar "
"um ativo com a quantidade @{qtd2} e preço local @{local2} por outro com a "
"quantidade @{qtd1} e preço local @{local1}."

#: ../plugins/fn-derivatives/options.c:1753
msgid ""
"OPT_SPREAD_APPROX:theoretical price of a European option on the spread "
"between two futures contracts"
msgstr ""
"OPT_SPREAD_APROX:preço teórico de uma opção europeia no spread entre dois "
"contratos futuros"

#: ../plugins/fn-derivatives/options.c:1755
msgid "fut_price1:price of the first futures contract"
msgstr "preço_futuro1: preço do primeiro contrato futuro"

#: ../plugins/fn-derivatives/options.c:1756
msgid "fut_price2:price of the second futures contract"
msgstr "preço_futuro2: preço do segundo contrato futuro"

#: ../plugins/fn-derivatives/options.c:1760
msgid ""
"volatility1:annualized volatility in price of the first underlying futures "
"contract"
msgstr ""
"volatilidade1: volatilidade anual em preço do primeiro contrato futuro "
"subjacente"

#: ../plugins/fn-derivatives/options.c:1761
msgid ""
"volatility2:annualized volatility in price of the second underlying futures "
"contract"
msgstr ""
"volatilidade2: volatilidade anual em preço do segundo contrato futuro "
"subjacente"

#: ../plugins/fn-derivatives/options.c:1762
msgid "rho:correlation between the two futures contracts"
msgstr "ro: correlação entre os dois contratos futuros"

#: ../plugins/fn-derivatives/options.c:1808
msgid ""
"OPT_FLOAT_STRK_LKBK:theoretical price of floating-strike lookback option"
msgstr "OPT_GOLPE_FLUT: preço teórico de uma opção de golpe flutuante"

#: ../plugins/fn-derivatives/options.c:1811
#: ../plugins/fn-derivatives/options.c:1875
msgid "spot_min:minimum spot price of the underlying asset so far observed"
msgstr ""
"local_mínimo: preço local mínimo do ativo subjacente até agora observado"

#: ../plugins/fn-derivatives/options.c:1812
#: ../plugins/fn-derivatives/options.c:1876
msgid "spot_max:maximum spot price of the underlying asset so far observed"
msgstr ""
"local_máximo: preço local máximo do ativo subjacente até agora observado"

#: ../plugins/fn-derivatives/options.c:1817
msgid ""
"OPT_FLOAT_STRK_LKBK determines the theoretical price of a floating-strike "
"lookback option where the holder of the option may exercise on expiry at the "
"most favourable price observed during the options life of the underlying "
"asset."
msgstr ""
"OPT_GOLPE_FLUT determina o preço teórico de uma opção de golpe flutuante em "
"que o detentor da opção pode exercer na expiração o preço mais favorável "
"observado durante a vida do ativo subjacente"

#: ../plugins/fn-derivatives/options.c:1872
msgid "OPT_FIXED_STRK_LKBK:theoretical price of a fixed-strike lookback option"
msgstr "OPT_GOLPE_FIXO: preço teórico de uma opção de golpe fixo"

#: ../plugins/fn-derivatives/options.c:1882
msgid ""
"OPT_FIXED_STRK_LKBK determines the theoretical price of a fixed-strike "
"lookback option where the holder of the option may exercise on expiry at the "
"most favourable price observed during the options life of the underlying "
"asset."
msgstr ""
"OPT_GOLPE_FIXO determina o preço teórico de uma opção de golpe fixo em que o "
"detentor da opção pode exercer na expiração o preço mais favorável observado "
"durante a vida do ativo subjacente."

#: ../plugins/fn-derivatives/options.c:1956
msgid ""
"OPT_BINOMIAL:theoretical price of either an American or European style "
"option using a binomial tree"
msgstr ""
"OPT_BINOMIAL: o preço teórico de uma opção estilo americano ou europeu "
"usando uma árvore binomial"

#: ../plugins/fn-derivatives/options.c:1957
msgid ""
"amer_euro_flag:'a' for an American style option or 'e' for a European style "
"option"
msgstr ""
"bandeira_amer_euro: \"a\" para uma opção de estilo americano ou \"e\" para "
"uma de estilo europeu"

#: ../plugins/fn-derivatives/options.c:1959
msgid "num_time_steps:number of time steps used in the valuation"
msgstr "num_passos_tempo: número de passos usados na avaliação"

#: ../plugins/fn-derivatives/options.c:1966
msgid ""
"A larger @{num_time_steps} yields greater accuracy but  OPT_BINOMIAL is "
"slower to calculate."
msgstr ""
"Um @{num_passos_tempo} rende mais precisão mas OPT_BINOMIAL torna-se mais "
"lenta a calcular."

#: ../plugins/fn-eng/functions.c:207
msgid "BASE:string of digits representing the number @{n} in base @{b}"
msgstr "BASE: cadeia de dígitos representando o númeor @{n} em base @{b}"

#: ../plugins/fn-eng/functions.c:208 ../plugins/fn-math/functions.c:1447
#: ../plugins/fn-numtheory/numtheory.c:612
#: ../plugins/fn-numtheory/numtheory.c:642
msgid "n:integer"
msgstr "n:inteiro"

#: ../plugins/fn-eng/functions.c:209
msgid "b:base (2 ≤ @{b} ≤ 36)"
msgstr "b:base (2 ≤ @{b} ≤ 36)"

#: ../plugins/fn-eng/functions.c:210
msgid "length:minimum length of the resulting string"
msgstr "comprimento: comprimento mínimo da cadeia resultante"

#: ../plugins/fn-eng/functions.c:211
msgid ""
"BASE converts @{n} to its string representation in base @{b}. Leading zeroes "
"will be added to reach the minimum length given by @{length}."
msgstr ""
"BASE converte @{n} na sua representação em base @{b}. Serão adicionados "
"zeros à esquerda para atingir o comprimento @{comprimento}"

#: ../plugins/fn-eng/functions.c:236
msgid "BIN2DEC:decimal representation of the binary number @{x}"
msgstr "BINADEC:representação decimal do número binário @{x}"

#: ../plugins/fn-eng/functions.c:237 ../plugins/fn-eng/functions.c:259
#: ../plugins/fn-eng/functions.c:283
msgid ""
"x:a binary number, either as a string or as a number involving only the "
"digits 0 and 1"
msgstr ""
"x: um número binário, como cadeia ou como número envolvendo só dígitos 0 e 1"

#: ../plugins/fn-eng/functions.c:258
msgid "BIN2OCT:octal representation of the binary number @{x}"
msgstr "BINAOCT: representação octal do número binário @{x}"

#: ../plugins/fn-eng/functions.c:260 ../plugins/fn-eng/functions.c:284
#: ../plugins/fn-eng/functions.c:309 ../plugins/fn-eng/functions.c:339
#: ../plugins/fn-eng/functions.c:362 ../plugins/fn-eng/functions.c:439
#: ../plugins/fn-eng/functions.c:462 ../plugins/fn-eng/functions.c:485
#: ../plugins/fn-eng/functions.c:508
msgid "places:number of digits"
msgstr "casas: número de dígitos"

#: ../plugins/fn-eng/functions.c:261
msgid ""
"If @{places} is given, BIN2OCT pads the result with zeros to achieve exactly "
"@{places} digits. If this is not possible, BIN2OCT returns #NUM!"
msgstr ""
"Se @{casas} for indicado, BINAOCT enche o resultado com zeros para obter "
"@{casas} dígitos. Se não for possível, devolve #NUM!."

#: ../plugins/fn-eng/functions.c:282
msgid "BIN2HEX:hexadecimal representation of the binary number @{x}"
msgstr "BINAHEX: representação hexadecimal de um número binário @{x}"

#: ../plugins/fn-eng/functions.c:285
msgid ""
"If @{places} is given, BIN2HEX pads the result with zeros to achieve exactly "
"@{places} digits. If this is not possible, BIN2HEX returns #NUM!"
msgstr ""
"Se @{casas} for indicado, BINAOCT enche o resultado com zeros para obter "
"@{casas} dígitos. Se não for possível, devolve #NUM!."

#: ../plugins/fn-eng/functions.c:307
msgid "DEC2BIN:binary representation of the decimal number @{x}"
msgstr "DECABIN: representação binária do número decimal @{x}"

#: ../plugins/fn-eng/functions.c:308
msgid "x:integer (− 513 < @{x} < 512)"
msgstr "x:inteiro (− 513 < @{x} < 512)"

#: ../plugins/fn-eng/functions.c:310
msgid ""
"If @{places} is given and @{x} is non-negative, DEC2BIN pads the result with "
"zeros to achieve exactly @{places} digits. If this is not possible, DEC2BIN "
"returns #NUM!"
msgstr ""
"Se @{casas} for indicado e @{x} não for negativo, DECABIN enche o resultado "
"com zeros para obter @{casas} dígitos. Se não for possível, devolve #NUM!."

#: ../plugins/fn-eng/functions.c:314
msgid "If @{places} is given and @{x} is negative, @{places} is ignored."
msgstr "Se @{casas} for indicado e @{x} for negativo, @{casas} é ignorado."

#: ../plugins/fn-eng/functions.c:315
msgid "If @{x} < − 512 or @{x} > 511, DEC2BIN returns #NUM!"
msgstr "Se @{x} < − 512 ou @{x} > 511, DEC2BIN devolve #NUM!"

#: ../plugins/fn-eng/functions.c:337
msgid "DEC2OCT:octal representation of the decimal number @{x}"
msgstr "DECAOCT: representação octal do número decimal @{x}"

#: ../plugins/fn-eng/functions.c:338 ../plugins/fn-eng/functions.c:361
#: ../plugins/fn-math/functions.c:1446
msgid "x:integer"
msgstr "x:inteiro"

#: ../plugins/fn-eng/functions.c:340
msgid ""
"If @{places} is given, DEC2OCT pads the result with zeros to achieve exactly "
"@{places} digits. If this is not possible, DEC2OCT returns #NUM!"
msgstr ""
"Se @{casas} for indicado, DECAOCT enche o resultado com zeros para obter "
"@{casas} dígitos. Se não for possível, devolve #NUM!."

#: ../plugins/fn-eng/functions.c:360
msgid "DEC2HEX:hexadecimal representation of the decimal number @{x}"
msgstr "DECAHEX: representação hexadecimal do número decimal @{x}"

#: ../plugins/fn-eng/functions.c:363
msgid ""
"If @{places} is given, DEC2HEX pads the result with zeros to achieve exactly "
"@{places} digits. If this is not possible, DEC2HEX returns #NUM!"
msgstr ""
"Se @{casas} for indicado, DECAHEX enche o resultado com zeros para obter "
"@{casas} dígitos. Se não for possível, devolve #NUM!."

#: ../plugins/fn-eng/functions.c:383
msgid "DECIMAL:decimal representation of @{x}"
msgstr "DECIMAL:representação decimal de @{x}"

#: ../plugins/fn-eng/functions.c:384
msgid "x:number in base @{base}"
msgstr "x: número em base @{base}"

#: ../plugins/fn-eng/functions.c:385
msgid "base:base of @{x}, (2 ≤ @{base} ≤ 36)"
msgstr "base: base de @{x}, (2 ≤ @{base} ≤ 36)"

#: ../plugins/fn-eng/functions.c:413
msgid "OCT2DEC:decimal representation of the octal number @{x}"
msgstr "OCTADEC: representação decimal do número octal @{x}"

#: ../plugins/fn-eng/functions.c:414 ../plugins/fn-eng/functions.c:438
#: ../plugins/fn-eng/functions.c:461
msgid "x:a octal number, either as a string or as a number"
msgstr "x: um número octal, como cadeia ou como número"

#: ../plugins/fn-eng/functions.c:437
msgid "OCT2BIN:binary representation of the octal number @{x}"
msgstr "OCTABIN: representação binária do número octal @{x}"

#: ../plugins/fn-eng/functions.c:440
msgid ""
"If @{places} is given, OCT2BIN pads the result with zeros to achieve exactly "
"@{places} digits. If this is not possible, OCT2BIN returns #NUM!"
msgstr ""
"Se @{casas} for indicado, OCTABIN enche o resultado com zeros para obter "
"@{casas} dígitos. Se não for possível, devolve #NUM!."

#: ../plugins/fn-eng/functions.c:460
msgid "OCT2HEX:hexadecimal representation of the octal number @{x}"
msgstr "OCTAHEX: representação hexadecimal do número octal @{x}"

#: ../plugins/fn-eng/functions.c:463
msgid ""
"If @{places} is given, OCT2HEX pads the result with zeros to achieve exactly "
"@{places} digits. If this is not possible, OCT2HEX returns #NUM!"
msgstr ""
"Se @{casas} for indicado, BINAOCT enche o resultado com zeros para obter "
"@{casas} dígitos. Se não for possível, devolve #NUM!."

#: ../plugins/fn-eng/functions.c:483
msgid "HEX2BIN:binary representation of the hexadecimal number @{x}"
msgstr "HEXABIN: representação binária do número hexadecimal @{x}"

#: ../plugins/fn-eng/functions.c:484 ../plugins/fn-eng/functions.c:507
#: ../plugins/fn-eng/functions.c:530
msgid ""
"x:a hexadecimal number, either as a string or as a number if no A to F are "
"needed"
msgstr ""
"x: número hexadecimal, como cadeia ou como número se não forem necessárias "
"A, B, C, D, E ou F"

#: ../plugins/fn-eng/functions.c:486
msgid ""
"If @{places} is given, HEX2BIN pads the result with zeros to achieve exactly "
"@{places} digits. If this is not possible, HEX2BIN returns #NUM!"
msgstr ""
"Se @{casas} for indicado, HEXABIN enche o resultado com zeros para obter "
"@{casas} dígitos. Se não for possível, devolve #NUM!."

#: ../plugins/fn-eng/functions.c:506
msgid "HEX2OCT:octal representation of the hexadecimal number @{x}"
msgstr "HEXAOCT: representação octal do número hexadecimal @{x}"

#: ../plugins/fn-eng/functions.c:509
msgid ""
"If @{places} is given, HEX2OCT pads the result with zeros to achieve exactly "
"@{places} digits. If this is not possible, HEX2OCT returns #NUM!"
msgstr ""
"Se @{casas} for indicado, HEXAOCT enche o resultado com zeros para obter "
"@{casas} dígitos. Se não for possível, devolve #NUM!."

#: ../plugins/fn-eng/functions.c:529
msgid "HEX2DEC:decimal representation of the hexadecimal number @{x}"
msgstr "HEXADEC: representação decimal do número hexadecimal @{x}"

#: ../plugins/fn-eng/functions.c:552
msgid ""
"BESSELI:Modified Bessel function of the first kind of order @{α} at @{x}"
msgstr ""
"BESSELI:função Bessel modificada do primeiro tipo de ordem @{α} em @{x}"

#: ../plugins/fn-eng/functions.c:553 ../plugins/fn-eng/functions.c:575
#: ../plugins/fn-eng/functions.c:598 ../plugins/fn-eng/functions.c:621
msgid "X:number"
msgstr "X:número"

#: ../plugins/fn-eng/functions.c:554 ../plugins/fn-eng/functions.c:576
msgid "α:order (any non-negative number)"
msgstr "α:ordem (qualquer número não negativo)"

#: ../plugins/fn-eng/functions.c:555 ../plugins/fn-eng/functions.c:577
#: ../plugins/fn-eng/functions.c:600 ../plugins/fn-eng/functions.c:623
msgid ""
"If @{x} or @{α} are not numeric, #VALUE! is returned. If @{α} < 0, #NUM! is "
"returned."
msgstr ""
"Se @{x} ou @{α} não forem numéricos, é devolvido #VALOR!. Se @{α} < 0, é "
"devolvido #NUM!."

#: ../plugins/fn-eng/functions.c:556 ../plugins/fn-eng/functions.c:578
#: ../plugins/fn-eng/functions.c:602 ../plugins/fn-eng/functions.c:625
msgid "This function is Excel compatible if only integer orders @{α} are used."
msgstr ""
"Esta função é compatível com Excel se só forem usadas ordens inteiras @{α}"

#: ../plugins/fn-eng/functions.c:559 ../plugins/fn-eng/functions.c:581
#: ../plugins/fn-eng/functions.c:605 ../plugins/fn-eng/functions.c:628
msgid "wiki:en:Bessel_function"
msgstr "wiki:pt:Função_de_Bessel"

#: ../plugins/fn-eng/functions.c:574
msgid ""
"BESSELK:Modified Bessel function of the second kind of order @{α} at @{x}"
msgstr ""
"BESSELK: função de Bessel modificada do segundo tipo de ordem @{α} em @{x}"

#: ../plugins/fn-eng/functions.c:597
msgid "BESSELJ:Bessel function of the first kind of order @{α} at @{x}"
msgstr "BESSELJ: função de Bessel do primeiro tipo de ordem @{α} em @{x}"

#: ../plugins/fn-eng/functions.c:599 ../plugins/fn-eng/functions.c:622
msgid "α:order (any non-negative integer)"
msgstr "α:ordem (qualquer inteiro não negativo)"

#: ../plugins/fn-eng/functions.c:620
msgid "BESSELY:Bessel function of the second kind of order @{α} at @{x}"
msgstr "BESSELY: função de Bessel do segundo tipo de ordem @{α} em @{x}"

#: ../plugins/fn-eng/functions.c:643
msgid "CONVERT:a converted measurement"
msgstr "CONVERTER: uma medida convertida"

#: ../plugins/fn-eng/functions.c:644 ../plugins/fn-eng/functions.c:1452
#: ../plugins/fn-eng/functions.c:1518 ../plugins/fn-math/functions.c:357
#: ../plugins/fn-math/functions.c:376 ../plugins/fn-math/functions.c:398
#: ../plugins/fn-math/functions.c:439 ../plugins/fn-math/functions.c:457
#: ../plugins/fn-math/functions.c:483 ../plugins/fn-math/functions.c:502
#: ../plugins/fn-math/functions.c:526 ../plugins/fn-math/functions.c:608
#: ../plugins/fn-math/functions.c:798 ../plugins/fn-math/functions.c:868
#: ../plugins/fn-math/functions.c:886 ../plugins/fn-math/functions.c:921
#: ../plugins/fn-math/functions.c:957 ../plugins/fn-math/functions.c:975
#: ../plugins/fn-math/functions.c:992 ../plugins/fn-math/functions.c:1016
#: ../plugins/fn-math/functions.c:1033 ../plugins/fn-math/functions.c:1058
#: ../plugins/fn-math/functions.c:1089 ../plugins/fn-math/functions.c:1113
#: ../plugins/fn-math/functions.c:1197 ../plugins/fn-math/functions.c:1233
#: ../plugins/fn-math/functions.c:1339 ../plugins/fn-math/functions.c:1381
#: ../plugins/fn-math/functions.c:1566 ../plugins/fn-math/functions.c:1606
#: ../plugins/fn-math/functions.c:1624 ../plugins/fn-math/functions.c:1792
#: ../plugins/fn-math/functions.c:1827 ../plugins/fn-math/functions.c:1864
#: ../plugins/fn-math/functions.c:1899 ../plugins/fn-math/functions.c:2039
#: ../plugins/fn-math/functions.c:2089 ../plugins/fn-math/functions.c:2113
#: ../plugins/fn-math/functions.c:2154 ../plugins/fn-math/functions.c:2201
#: ../plugins/fn-stat/functions.c:439 ../plugins/fn-stat/functions.c:529
#: ../plugins/fn-stat/functions.c:590 ../plugins/fn-stat/functions.c:980
#: ../plugins/fn-stat/functions.c:1049 ../plugins/fn-stat/functions.c:1112
#: ../plugins/fn-stat/functions.c:1254 ../plugins/fn-stat/functions.c:1289
#: ../plugins/fn-stat/functions.c:1367 ../plugins/fn-stat/functions.c:1456
#: ../plugins/fn-stat/functions.c:1486 ../plugins/fn-stat/functions.c:1719
#: ../plugins/fn-stat/functions.c:1933 ../plugins/fn-stat/functions.c:1969
#: ../plugins/fn-stat/functions.c:2132 ../plugins/fn-stat/functions.c:4784
#: ../plugins/fn-stat/functions.c:4815 ../plugins/fn-stat/functions.c:4849
#: ../plugins/fn-stat/functions.c:4869 ../plugins/fn-stat/functions.c:4908
#: ../plugins/fn-stat/functions.c:4941
msgid "x:number"
msgstr "x: número"

#: ../plugins/fn-eng/functions.c:645
msgid "from:unit (string)"
msgstr "de: unidade (cadeia)"

#: ../plugins/fn-eng/functions.c:646
msgid "to:unit (string)"
msgstr "para: unidade (cadeia)"

#: ../plugins/fn-eng/functions.c:647
msgid ""
"CONVERT returns a conversion from one measurement system to another. @{x} is "
"a value in @{from} units that is to be converted into @{to} units."
msgstr ""
"CONVERTER devolve a conversão de um sistema de medida para outro. @{x} é um "
"valor em @{de} unidades a ser convertido em @{para} unidades."

#: ../plugins/fn-eng/functions.c:649
msgid "If @{from} and @{to} are different types, CONVERT returns #N/A!"
msgstr "Se @{de} e @{para} forem de tipos diferentes, CONVERTER devolve #N/D!"

#: ../plugins/fn-eng/functions.c:650
msgid ""
"@{from} and @{to} can be any of the following:\n"
"\n"
"Weight and mass:\n"
"\t'brton'\t\tImperial ton\n"
"\t'cwt'\t\t\tU.S. (short) hundredweight\n"
"\t'g'  \t\t\tGram\n"
"\t'grain'\t\tGrain\n"
"\t'hweight'\t\tImperial (long) hundredweight\n"
"\t'LTON'\t\tImperial ton\n"
"\t'sg' \t\t\tSlug\n"
"\t'shweight'\tU.S. (short) hundredweight\n"
"\t'lbm'\t\tPound\n"
"\t'lcwt'\t\tImperial  (long) hundredweight\n"
"\t'u'  \t\t\tU (atomic mass)\n"
"\t'uk_cwt'\t\tImperial  (long) hundredweight\n"
"\t'uk_ton'\t\tImperial ton\n"
"\t'ozm'\t\tOunce\n"
"\t'stone'\t\tStone\n"
"\t'ton'\t\t\tTon\n"
"\n"
"Distance:\n"
"\t'm'   \t\tMeter\n"
"\t'mi'  \t\tStatute mile\n"
"\t'survey_mi' \tU.S. survey mile\n"
"\t'Nmi' \t\tNautical mile\n"
"\t'in'  \t\t\tInch\n"
"\t'ft'  \t\t\tFoot\n"
"\t'yd'  \t\tYard\n"
"\t'ell' \t\t\tEnglish Ell\n"
"\t'ang' \t\tAngstrom\n"
"\t'ly' \t\t\tLight-Year\n"
"\t'pc' \t\t\tParsec\n"
"\t'parsec' \t\tParsec\n"
"\t'Pica'\t\tPica Points\n"
"\t'Picapt'\t\tPica Points\n"
"\t'picapt'\t\tPica Points\n"
"\t'pica'\t\tPica\n"
"\n"
"Time:\n"
"\t'yr'  \t\t\tYear\n"
"\t'day' \t\tDay\n"
"\t'hr'  \t\t\tHour\n"
"\t'mn'  \t\tMinute\n"
"\t'sec' \t\tSecond\n"
"\n"
"Pressure:\n"
"\t'Pa'  \t\t\tPascal\n"
"\t'psi' \t\t\tPSI\n"
"\t'atm' \t\tAtmosphere\n"
"\t'Pa'  \t\t\tPascal\n"
"\t'mmHg'\t\tmm of Mercury\n"
"\t'Torr'\t\t\tTorr\n"
"\n"
"Force:\n"
"\t'N'   \t\t\tNewton\n"
"\t'dyn' \t\tDyne\n"
"\t'pond' \t\tPond\n"
"\t'lbf' \t\t\tPound force\n"
"\n"
"Energy:\n"
"\t'J'    \t\t\tJoule\n"
"\t'e'    \t\tErg\n"
"\t'c'    \t\tThermodynamic calorie\n"
"\t'cal'  \t\tIT calorie\n"
"\t'eV'   \t\tElectron volt\n"
"\t'HPh'  \t\tHorsepower-hour\n"
"\t'Wh'   \t\tWatt-hour\n"
"\t'flb'  \t\tFoot-pound\n"
"\t'BTU'  \t\tBTU\n"
"\n"
"Power:\n"
"\t'HP'   \t\tHorsepower\n"
"\t'PS'   \t\tPferdestärke\n"
"\t'W'    \t\tWatt\n"
"\n"
"Magnetism:\n"
"\t'T'    \t\tTesla\n"
"\t'ga'   \t\tGauss\n"
"\n"
"Temperature:\n"
"\t'C'    \t\tDegree Celsius\n"
"\t'F'    \t\tDegree Fahrenheit\n"
"\t'K'    \t\tKelvin\n"
"\t'Rank' \t\tDegree Rankine\n"
"\t'Reau' \t\tDegree Réaumur\n"
"\n"
"Volume (liquid measure):\n"
"\t'tsp'  \t\tTeaspoon\n"
"\t'tspm'  \t\tTeaspoon (modern, metric)\n"
"\t'tbs'  \t\tTablespoon\n"
"\t'oz'   \t\tFluid ounce\n"
"\t'cup'  \t\tCup\n"
"\t'pt'   \t\tPint\n"
"\t'us_pt'\t\tU.S. pint\n"
"\t'uk_pt'\t\tImperial pint (U.K.)\n"
"\t'qt'   \t\tQuart\n"
"\t'uk_qt'   \t\tImperial quart\n"
"\t'gal'  \t\tGallon\n"
"\t'uk_gal'  \t\tImperial gallon\n"
"\t'GRT'  \t\tRegistered ton\n"
"\t'regton' \t\tRegistered ton\n"
"\t'MTON' \t\tMeasurement ton (freight ton)\n"
"\t'l'    \t\t\tLiter\n"
"\t'L'    \t\tLiter\n"
"\t'lt'   \t\t\tLiter\n"
"\t'ang3' \t\tCubic Angstrom\n"
"\t'ang^3' \t\tCubic Angstrom\n"
"\t'barrel' \t\tU.S. oil barrel (bbl)\n"
"\t'bushel' \t\tU.S. bushel\n"
"\t'ft3' \t\t\tCubic feet\n"
"\t'ft^3' \t\tCubic feet\n"
"\t'in3' \t\tCubic inch\n"
"\t'in^3' \t\tCubic inch\n"
"\t'ly3' \t\t\tCubic light-year\n"
"\t'ly^3' \t\tCubic light-year\n"
"\t'm3' \t\tCubic meter\n"
"\t'm^3' \t\tCubic meter\n"
"\t'mi3' \t\tCubic mile\n"
"\t'mi^3' \t\tCubic mile\n"
"\t'yd3' \t\tCubic yard\n"
"\t'yd^3' \t\tCubic yard\n"
"\t'Nmi3' \t\tCubic nautical mile\n"
"\t'Nmi^3' \t\tCubic nautical mile\n"
"\t'Picapt3' \t\tCubic Pica\n"
"\t'Picapt^3' \tCubic Pica\n"
"\t'Pica3' \t\tCubic Pica\n"
"\t'Pica^3' \t\tCubic Pica\n"
"\n"
"Area:\n"
"\t'uk_acre' \t\tInternational acre\n"
"\t'us_acre' \t\tU.S. survey/statute acre\n"
"\t'ang2' \t\tSquare angstrom\n"
"\t'ang^2' \t\tSquare angstrom\n"
"\t'ar' \t\t\tAre\n"
"\t'ha' \t\t\tHectare\n"
"\t'in2' \t\tSquare inches\n"
"\t'in^2' \t\tSquare inches\n"
"\t'ly2' \t\t\tSquare light-year\n"
"\t'ly^2' \t\tSquare light-year\n"
"\t'm2' \t\tSquare meter\n"
"\t'm^2' \t\tSquare meter\n"
"\t'Morgen' \t\tMorgen (North German Confederation)\n"
"\t'mi2' \t\tSquare miles\n"
"\t'mi^2' \t\tSquare miles\n"
"\t'Nmi2' \t\tSquare nautical miles\n"
"\t'Nmi^2' \t\tSquare nautical miles\n"
"\t'Picapt2' \t\tSquare Pica\n"
"\t'Picapt^2' \tSquare Pica\n"
"\t'Pica2' \t\tSquare Pica\n"
"\t'Pica^2' \t\tSquare Pica\n"
"\t'yd2' \t\tSquare yards\n"
"\t'yd^2' \t\tSquare yards\n"
"\n"
"Bits and Bytes:\n"
"\t'bit' \t\t\tBit\n"
"\t'byte' \t\tByte\n"
"\n"
"Speed:\n"
"\t'admkn' \t\tAdmiralty knot\n"
"\t'kn' \t\t\tknot\n"
"\t'm/h' \t\tMeters per hour\n"
"\t'm/hr' \t\tMeters per hour\n"
"\t'm/s' \t\tMeters per second\n"
"\t'm/sec' \t\tMeters per second\n"
"\t'mph' \t\tMiles per hour\n"
"\n"
"For metric units any of the following prefixes can be used:\n"
"\t'Y'  \tyotta \t\t1E+24\n"
"\t'Z'  \tzetta \t\t1E+21\n"
"\t'E'  \texa   \t\t1E+18\n"
"\t'P'  \tpeta  \t\t1E+15\n"
"\t'T'  \ttera  \t\t1E+12\n"
"\t'G'  \tgiga  \t\t1E+09\n"
"\t'M'  \tmega  \t\t1E+06\n"
"\t'k'  \tkilo  \t\t\t1E+03\n"
"\t'h'  \thecto \t\t1E+02\n"
"\t'e'  \tdeca (deka)\t1E+01\n"
"\t'd'  \tdeci  \t\t1E-01\n"
"\t'c'  \tcenti \t\t1E-02\n"
"\t'm'  \tmilli \t\t\t1E-03\n"
"\t'u'  \tmicro \t\t1E-06\n"
"\t'n'  \tnano  \t\t1E-09\n"
"\t'p'  \tpico  \t\t1E-12\n"
"\t'f'  \tfemto \t\t1E-15\n"
"\t'a'  \tatto  \t\t1E-18\n"
"\t'z'  \tzepto \t\t1E-21\n"
"\t'y'  \tyocto \t\t1E-24\n"
"\n"
"For bits and bytes any of the following prefixes can be also be used:\n"
"\t'Yi'  \tyobi \t\t2^80\n"
"\t'Zi'  \tzebi \t\t\t2^70\n"
"\t'Ei'  \texbi \t\t2^60\n"
"\t'Pi'  \tpebi \t\t2^50\n"
"\t'Ti'  \ttebi \t\t\t2^40\n"
"\t'Gi'  \tgibi \t\t\t2^30\n"
"\t'Mi'  \tmebi \t\t2^20\n"
"\t'ki'  \tkibi \t\t\t2^10"
msgstr ""
"@{de} e @{para} podem ser um dos seguintes:\n"
"\n"
"Peso e massa:\n"
"\t'brton'\t\tton Imperial\n"
"\t'cwt'\t\t\tE.U.A. (curto) 100 libras\n"
"\t'g'  \t\t\tGramas\n"
"\t'grain'\t\tGrão\n"
"\t'hweight'\t\tImperial (longo) 100 libras\n"
"\t'LTON'\t\tton Imperial\n"
"\t'sg' \t\t\tSlug\n"
"\t'shweight'\tE.U.A. (curot) 100 libras\n"
"\t'lbm'\t\tLibra\n"
"\t'lcwt'\t\tImperial  (longo) 100 libras\n"
"\t'u'  \t\t\tU (massa atómica)\n"
"\t'uk_cwt'\t\tImperial  (longo) 100 libras\n"
"\t'uk_ton'\t\tton Imperial\n"
"\t'ozm'\t\tOnça\n"
"\t'stone'\t\tPedra\n"
"\t'ton'\t\t\tTon\n"
"\n"
"Distância:\n"
"\t'm'   \t\tMetro\n"
"\t'mi'  \t\tMilha\n"
"\t'survey_mi' \tE.U.A. milha vigiada\n"
"\t'Nmi' \t\tMilha náutica\n"
"\t'in'  \t\t\tPolegada\n"
"\t'ft'  \t\t\tPé\n"
"\t'yd'  \t\tJarda\n"
"\t'ell' \t\t\tEll inglês\n"
"\t'ang' \t\tAngstrom\n"
"\t'ly' \t\t\tAno-luz\n"
"\t'pc' \t\t\tParsec\n"
"\t'parsec' \t\tParsec\n"
"\t'Pica'\t\tPicas\n"
"\t'Picapt'\t\tPicas\n"
"\t'picapt'\t\tPicas\n"
"\t'pica'\t\tPica\n"
"\n"
"Tempo:\n"
"\t'yr'  \t\t\tAno\n"
"\t'day' \t\tDia\n"
"\t'hr'  \t\t\tHora\n"
"\t'mn'  \t\tMinuto\n"
"\t'sec' \t\tSegundo\n"
"\n"
"Pressão:\n"
"\t'Pa'  \t\t\tPascal\n"
"\t'psi' \t\t\tPSI\n"
"\t'atm' \t\tAtmosfera\n"
"\t'Pa'  \t\t\tPascal\n"
"\t'mmHg'\t\tmm de mercúrio\n"
"\t'Torr'\t\t\tTorr\n"
"\n"
"Força:\n"
"\t'N'   \t\t\tNewton\n"
"\t'dyn' \t\tDina\n"
"\t'pond' \t\tPond\n"
"\t'lbf' \t\t\tLibra-força\n"
"\n"
"Energia:\n"
"\t'J'    \t\t\tJoule\n"
"\t'e'    \t\tErg\n"
"\t'c'    \t\tCaloria termodinâmica\n"
"\t'cal'  \t\tCaloria IT\n"
"\t'eV'   \t\tEletro-volt\n"
"\t'HPh'  \t\tCavalo-hora\n"
"\t'Wh'   \t\tWatt-hora\n"
"\t'flb'  \t\tPé-libra\n"
"\t'BTU'  \t\tBTU\n"
"\n"
"Potência:\n"
"\t'HP'   \t\tCavalo\n"
"\t'PS'   \t\tPferdestärke\n"
"\t'W'    \t\tWatt\n"
"\n"
"Magnetismo:\n"
"\t'T'    \t\tTesla\n"
"\t'ga'   \t\tGauss\n"
"\n"
"Temperatura:\n"
"\t'C'    \t\tGrau Celsius\n"
"\t'F'    \t\tGrau Fahrenheit\n"
"\t'K'    \t\tKelvin\n"
"\t'Rank' \t\tGrau Rankine\n"
"\t'Reau' \t\tGrau Réaumur\n"
"\n"
"Volume (medidas de líquidos):\n"
"\t'tsp'  \t\tColher de chá\n"
"\t'tspm'  \t\tColher de chá (moderna, métrica)\n"
"\t'tbs'  \t\tColher de sopa\n"
"\t'oz'   \t\tOnça fluida\n"
"\t'cup'  \t\tChávena\n"
"\t'pt'   \t\tPint\n"
"\t'us_pt'\t\tPint E.U.A.\n"
"\t'uk_pt'\t\tPint Imperial (U.K.)\n"
"\t'qt'   \t\tQuarto\n"
"\t'uk_qt'   \t\tQuarto Imperial\n"
"\t'gal'  \t\tGalão\n"
"\t'uk_gal'  \t\tGalão Imperial\n"
"\t'GRT'  \t\tTonelada registada\n"
"\t'regton' \t\tTonelada registada\n"
"\t'MTON' \t\tTon medida (ton de frete)\n"
"\t'l'    \t\t\tLitro\n"
"\t'L'    \t\tLitro\n"
"\t'lt'   \t\t\tLitro\n"
"\t'ang3' \t\tAngstrom cúbico\n"
"\t'ang^3' \t\tAngstrom cúbico\n"
"\t'barrel' \t\tE.U.A. barril de petróleo (bbl)\n"
"\t'bushel' \t\tE.U.A. bushel\n"
"\t'ft3' \t\t\tPé cúbico\n"
"\t'ft^3' \t\tPé cúbico\n"
"\t'in3' \t\tPolegada cúbica\n"
"\t'in^3' \t\tPolegada cúbica\n"
"\t'ly3' \t\t\tAno-luz cúbico\n"
"\t'ly^3' \t\tAno-luz cúbico\n"
"\t'm3' \t\tMetro cúbico\n"
"\t'm^3' \t\tMetro cúbico\n"
"\t'mi3' \t\tMilha cúbica\n"
"\t'mi^3' \t\tMilha cúbica\n"
"\t'yd3' \t\tJarda cúbica\n"
"\t'yd^3' \t\tJarda cúbica\n"
"\t'Nmi3' \t\tMilha náutica cúbica\n"
"\t'Nmi^3' \t\tMilha náutica cúbica\n"
"\t'Picapt3' \t\tPica cúbica\n"
"\t'Picapt^3' \tPica cúbica\n"
"\t'Pica3' \t\tPica cúbica\n"
"\t'Pica^3' \t\tPica cúbica\n"
"\n"
"Área:\n"
"\t'uk_acre' \t\tAcre internacional\n"
"\t'us_acre' \t\tE.U.A. acre vigia/estatutário\n"
"\t'ang2' \t\tAngstrom quadrado\n"
"\t'ang^2' \t\tAngstrom quadrado\n"
"\t'ar' \t\t\tAre\n"
"\t'ha' \t\t\tHectare\n"
"\t'in2' \t\tPolegadas quadradas\n"
"\t'in^2' \t\tPolegadas quadradas\n"
"\t'ly2' \t\t\tAno-luz quadrado\n"
"\t'ly^2' \t\tAno-luz quadrado\n"
"\t'm2' \t\tMetro quadrado\n"
"\t'm^2' \t\tMetro quadrado\n"
"\t'Morgen' \t\tMorgen (North German Confederation)\n"
"\t'mi2' \t\tMilhas quadradas\n"
"\t'mi^2' \t\tMilhas quadradas\n"
"\t'Nmi2' \t\tMilhas náuticas quadradas\n"
"\t'Nmi^2' \t\tMilhas náuticas quadradas\n"
"\t'Picapt2' \t\tPica quadrada\n"
"\t'Picapt^2' \tPica quadrada\n"
"\t'Pica2' \t\tPica quadrada\n"
"\t'Pica^2' \t\tPica quadrada\n"
"\t'yd2' \t\tJardas quadradas\n"
"\t'yd^2' \t\tJardas quadradas\n"
"\n"
"Bits e Bytes:\n"
"\t'bit' \t\t\tBit\n"
"\t'byte' \t\tByte\n"
"\n"
"Velocidade:\n"
"\t'admkn' \t\tNó do almirantado\n"
"\t'kn' \t\t\tNó\n"
"\t'm/h' \t\tMetros por hora\n"
"\t'm/hr' \t\tMetros por hora\n"
"\t'm/s' \t\tMetros por segundo\n"
"\t'm/sec' \t\tMetros por segundo\n"
"\t'mph' \t\tMilhas por hora\n"
"\n"
"Para unidades métricas pode ser usado qualquer um dos seguintes prefixos:\n"
"\t'Y'  \tyotta \t\t1E+24\n"
"\t'Z'  \tzetta \t\t1E+21\n"
"\t'E'  \texa   \t\t1E+18\n"
"\t'P'  \tpeta  \t\t1E+15\n"
"\t'T'  \ttera  \t\t1E+12\n"
"\t'G'  \tgiga  \t\t1E+09\n"
"\t'M'  \tmega  \t\t1E+06\n"
"\t'k'  \tqiilo  \t\t\t1E+03\n"
"\t'h'  \thecto \t\t1E+02\n"
"\t'e'  \tdeca (deka)\t1E+01\n"
"\t'd'  \tdeci  \t\t1E-01\n"
"\t'c'  \tcenti \t\t1E-02\n"
"\t'm'  \tmili \t\t\t1E-03\n"
"\t'u'  \tmicro \t\t1E-06\n"
"\t'n'  \tnano  \t\t1E-09\n"
"\t'p'  \tpico  \t\t1E-12\n"
"\t'f'  \tfemto \t\t1E-15\n"
"\t'a'  \tatto  \t\t1E-18\n"
"\t'z'  \tzepto \t\t1E-21\n"
"\t'y'  \tyocto \t\t1E-24\n"
"\n"
"Para bits e bytes podem ainda ser usados os seguintes prefixos:\n"
"\t'Yi'  \tyobi \t\t2^80\n"
"\t'Zi'  \tzebi \t\t\t2^70\n"
"\t'Ei'  \texbi \t\t2^60\n"
"\t'Pi'  \tpebi \t\t2^50\n"
"\t'Ti'  \ttebi \t\t\t2^40\n"
"\t'Gi'  \tgibi \t\t\t2^30\n"
"\t'Mi'  \tmebi \t\t2^20\n"
"\t'ki'  \tkibi \t\t\t2^10"

#: ../plugins/fn-eng/functions.c:832
msgid "This function is Excel compatible (except \"picapt\")."
msgstr "Esta função é compatível com Excel (exceto \"picapt\")."

#: ../plugins/fn-eng/functions.c:1420
msgid "ERF:Gauss error function"
msgstr "FUNC.ERRO:função de erro Gauss"

#: ../plugins/fn-eng/functions.c:1421
msgid "lower:lower limit of the integral, defaults to 0"
msgstr "inferior: limite inferior do integral, predefinição 0"

#: ../plugins/fn-eng/functions.c:1422
msgid "upper:upper limit of the integral"
msgstr "superior: limite superior do integral"

#: ../plugins/fn-eng/functions.c:1423
msgid ""
"ERF returns 2/sqrt(π)* integral from @{lower} to @{upper} of exp(-t*t) dt"
msgstr ""
"FUNC.ERRO devolve 2/RAIZQ(π)* integral de @{inferior} a @{superior} de exp(-"
"t*t) dt"

#: ../plugins/fn-eng/functions.c:1424
msgid ""
"This function is Excel compatible if two arguments are supplied and neither "
"is negative."
msgstr ""
"Esta função é compatível com Excel se forem indicados dois argumentos e "
"nenhum for negativo."

#: ../plugins/fn-eng/functions.c:1429 ../plugins/fn-eng/functions.c:1456
msgid "wiki:en:Error_function"
msgstr "wiki:pt:Função_erro"

#: ../plugins/fn-eng/functions.c:1451
msgid "ERFC:Complementary Gauss error function"
msgstr "FUNC.ERRO.COMPL: função de erro Gauss complementar"

#: ../plugins/fn-eng/functions.c:1453
msgid "ERFC returns 2/sqrt(π)* integral from @{x} to ∞ of exp(-t*t) dt"
msgstr ""
"FUNC.ERRO.COMPL devolve 2/RAIZQ(π)* integral de @{x} a ∞ de exp(-t*t) dt"

#: ../plugins/fn-eng/functions.c:1471
msgid "DELTA:Kronecker delta function"
msgstr "DELTA: função delta de Kronecker"

#: ../plugins/fn-eng/functions.c:1472 ../plugins/fn-eng/functions.c:1495
msgid "x0:number"
msgstr "x0: número"

#: ../plugins/fn-eng/functions.c:1473 ../plugins/fn-eng/functions.c:1496
msgid "x1:number, defaults to 0"
msgstr "x1: número, predefinição 0"

#: ../plugins/fn-eng/functions.c:1474
msgid "DELTA  returns 1 if  @{x1} = @{x0} and 0 otherwise."
msgstr "DELTA devolve 1 se  @{x1} = @{x0} e 0 noutro caso."

#: ../plugins/fn-eng/functions.c:1475 ../plugins/fn-eng/functions.c:1498
msgid "If either argument is non-numeric, #VALUE! is returned."
msgstr "Se algum dos argumentos não for numérico, devolve #VALOR!."

#: ../plugins/fn-eng/functions.c:1494
msgid "GESTEP:step function with step at @{x1} evaluated at @{x0}"
msgstr "DEGRAU: função de degrau em @{x1} avaliado em @{x0}"

#: ../plugins/fn-eng/functions.c:1497
msgid "GESTEP returns 1 if  @{x1} ≤ @{x0} and 0 otherwise."
msgstr "DEGRAU devolve 1 se  @{x1} ≤ @{x0} e 0 noutro caso."

#: ../plugins/fn-eng/functions.c:1517
msgid "HEXREP:hexadecimal representation of numeric value"
msgstr "REP.HEX: representação hexadecimal de um valor numérico"

#: ../plugins/fn-eng/functions.c:1519
msgid "HEXREP returns a hexadecimal string representation of @{x}."
msgstr "REP.HEX devolve uma cadeia hexadecimal representando @{x}"

#: ../plugins/fn-eng/functions.c:1520
msgid ""
"This is a function meant for debugging.  The layout of the result may change "
"and even depend on how Gnumeric was compiled."
msgstr ""
"Esta é uma função pensada para depuração. A disposição do resultado pode "
"variar e mesmo depender de como o Gnumeric foi compilado."

#: ../plugins/fn-eng/functions.c:1548
msgid "INVSUMINV:the reciprocal of the sum of reciprocals of the arguments"
msgstr "INVSOMAINV: o recíproco da soma dos recíprocos dos argumentos"

#: ../plugins/fn-eng/functions.c:1549
msgid "x0:non-negative number"
msgstr "x0: número não negativo"

#: ../plugins/fn-eng/functions.c:1550
msgid "x1:non-negative number"
msgstr "x1: número não negativo"

#: ../plugins/fn-eng/functions.c:1551
msgid ""
"If any of the arguments is negative, #VALUE! is returned.\n"
"If any argument is zero, the result is zero."
msgstr ""
"Se algum dos argumentos for negativo, devolve #VALOR!.\n"
"Se algum dos argumentos for 0, devolve 0."

#: ../plugins/fn-eng/functions.c:1553
msgid ""
"INVSUMINV sum calculates the reciprocal (the inverse) of the sum of "
"reciprocals (inverses) of all its arguments."
msgstr ""
"INVSOMAINV calcula o recíproco (inverso) da soma dos recíprocos (inversos) "
"de todos os seus argumentos."

#: ../plugins/fn-erlang/functions.c:105
msgid "PROBBLOCK:probability of blocking"
msgstr "PROB.TRANCA: probabilidade de trancar"

#: ../plugins/fn-erlang/functions.c:106 ../plugins/fn-erlang/functions.c:191
msgid "traffic:number of calls"
msgstr "tráfego: número de chamadas"

#: ../plugins/fn-erlang/functions.c:107 ../plugins/fn-erlang/functions.c:132
#: ../plugins/fn-erlang/functions.c:229
msgid "circuits:number of circuits"
msgstr "circuitos: número de circuitos"

#: ../plugins/fn-erlang/functions.c:108
msgid ""
"PROBBLOCK returns probability of blocking when @{traffic} calls load into "
"@{circuits} circuits."
msgstr ""
"PROB.TRANCA devolve a probabilidade de trancar quando @{tráfego} chama carga "
"para @{circuitos} circuitos."

#: ../plugins/fn-erlang/functions.c:110 ../plugins/fn-erlang/functions.c:134
msgid "@{traffic} cannot exceed @{circuits}."
msgstr "@{tráfego} não pode exceder @{circuitos}."

#: ../plugins/fn-erlang/functions.c:130
msgid "OFFTRAF:predicted number of offered calls"
msgstr "TRÁFEGO.OFERECIDO: número previsto de chamadas oferecidas"

#: ../plugins/fn-erlang/functions.c:131
msgid "traffic:number of carried calls"
msgstr "tráfego: número de chamadas"

#: ../plugins/fn-erlang/functions.c:133
msgid ""
"OFFTRAF returns the predicted number of offered calls given @{traffic} "
"carried calls (taken from measurements) on @{circuits} circuits."
msgstr ""
"TRÁFEGO.OFERECIDO devolve o número previsto de chamadas oferecidas dado "
"@{tráfego} chamadas (obtido de medições] em @{circuitos} circuitos."

#: ../plugins/fn-erlang/functions.c:190
msgid "DIMCIRC:number of circuits required"
msgstr "DIMCIRC: número de circuitos necessários"

#: ../plugins/fn-erlang/functions.c:192 ../plugins/fn-erlang/functions.c:230
msgid "gos:grade of service"
msgstr "gds: grau de serviço"

#: ../plugins/fn-erlang/functions.c:193
msgid ""
"DIMCIRC returns the number of circuits required given @{traffic} calls with "
"grade of service @{gos}."
msgstr ""
"DIMCIRC devolve o número de circuitos necessários, dadas @{tráfego} chamadas "
"com o grau de serviço @{gds}."

#: ../plugins/fn-erlang/functions.c:228
msgid "OFFCAP:traffic capacity"
msgstr "CAP.TRÁFEGO: capacidade de tráfego"

#: ../plugins/fn-erlang/functions.c:231
msgid ""
"OFFCAP returns the traffic capacity given @{circuits} circuits with grade of "
"service @{gos}."
msgstr ""
"CAP.TRÁFEGO devolve a capacidade de tráfego dados @{circuitos} circuitos com "
"grau de serviço @{gds}."

#. *************************************************************************
#: ../plugins/fn-financial/functions.c:53
msgid "@{frequency} may be 1 (annual), 2 (semi-annual), or 4 (quarterly)."
msgstr "@{frequência} pode ser 1 (anual), 2 (semestral) ou 4 (trimestral)."

#: ../plugins/fn-financial/functions.c:56
msgid ""
"If @{type} is 0, the default, payment is at the end of each period.  If "
"@{type} is 1, payment is at the beginning of each period."
msgstr ""
"Se @{tipo} for 0, a predefinição, o pagamento é no fim de cada período. Se "
"for 1, o pagamento é no início de cada período."

#: ../plugins/fn-financial/functions.c:362
msgid "ACCRINT:accrued interest"
msgstr "JURO.ACUM: juros acumulados"

#: ../plugins/fn-financial/functions.c:363
#: ../plugins/fn-financial/functions.c:450
#: ../plugins/fn-financial/functions.c:605
#: ../plugins/fn-financial/functions.c:2461
#: ../plugins/fn-financial/functions.c:2500
#: ../plugins/fn-financial/functions.c:2650
msgid "issue:date of issue"
msgstr "emissão: data de emissão"

#: ../plugins/fn-financial/functions.c:364
msgid "first_interest:date of first interest payment"
msgstr "primeiro_juro: data de pagamento dos primeiros juros"

#: ../plugins/fn-financial/functions.c:365
#: ../plugins/fn-financial/functions.c:488
#: ../plugins/fn-financial/functions.c:526
#: ../plugins/fn-financial/functions.c:567
#: ../plugins/fn-financial/functions.c:603
#: ../plugins/fn-financial/functions.c:648
#: ../plugins/fn-financial/functions.c:1086
#: ../plugins/fn-financial/functions.c:1124
#: ../plugins/fn-financial/functions.c:1158
#: ../plugins/fn-financial/functions.c:1890
#: ../plugins/fn-financial/functions.c:2255
#: ../plugins/fn-financial/functions.c:2305
#: ../plugins/fn-financial/functions.c:2414
#: ../plugins/fn-financial/functions.c:2459
#: ../plugins/fn-financial/functions.c:2498
#: ../plugins/fn-financial/functions.c:2648
#: ../plugins/fn-financial/functions.c:2744
#: ../plugins/fn-financial/functions.c:2822
#: ../plugins/fn-financial/functions.c:3002
#: ../plugins/fn-financial/functions.c:3026
#: ../plugins/fn-financial/functions.c:3050
#: ../plugins/fn-financial/functions.c:3074
#: ../plugins/fn-financial/functions.c:3100
#: ../plugins/fn-financial/functions.c:3126
#: ../plugins/fn-financial/functions.c:3238
msgid "settlement:settlement date"
msgstr "liquidação: data de liquidação"

#: ../plugins/fn-financial/functions.c:366
#: ../plugins/fn-financial/functions.c:452
#: ../plugins/fn-financial/functions.c:529
#: ../plugins/fn-financial/functions.c:686
#: ../plugins/fn-financial/functions.c:2257
#: ../plugins/fn-financial/functions.c:2307
#: ../plugins/fn-financial/functions.c:2462
#: ../plugins/fn-financial/functions.c:2502
#: ../plugins/fn-financial/functions.c:2652
#: ../plugins/fn-financial/functions.c:2747
#: ../plugins/fn-financial/functions.c:2825
msgid "rate:nominal annual interest rate"
msgstr "taxa: taxa de juro anual"

#: ../plugins/fn-financial/functions.c:367
msgid "par:par value, defaults to $1000"
msgstr "nominal: valor nominal, predefinido para 1000 €"

#: ../plugins/fn-financial/functions.c:368
#: ../plugins/fn-financial/functions.c:1894
#: ../plugins/fn-financial/functions.c:2260
#: ../plugins/fn-financial/functions.c:2310
#: ../plugins/fn-financial/functions.c:2505
#: ../plugins/fn-financial/functions.c:2655
#: ../plugins/fn-financial/functions.c:2750
#: ../plugins/fn-financial/functions.c:2828
#: ../plugins/fn-financial/functions.c:3004
#: ../plugins/fn-financial/functions.c:3028
#: ../plugins/fn-financial/functions.c:3052
#: ../plugins/fn-financial/functions.c:3076
#: ../plugins/fn-financial/functions.c:3102
#: ../plugins/fn-financial/functions.c:3128
#: ../plugins/fn-financial/functions.c:3242
msgid "frequency:number of interest payments per year"
msgstr "frequência: número de pagamentos de juros por ano"

#: ../plugins/fn-financial/functions.c:369
msgid "basis:calendar basis, defaults to 0"
msgstr "base: base de calendário, predefinição 0"

#: ../plugins/fn-financial/functions.c:370
msgid "calc_method:calculation method, defaults to TRUE"
msgstr "método_cálculo: método de cálculo, predefinido para VERDADEIRO"

#: ../plugins/fn-financial/functions.c:372
msgid ""
"If @{first_interest} < @{settlement} and @{calc_method} is TRUE, then "
"ACCRINT returns the sum of the interest accrued in all coupon periods from "
"@{issue}  date until @{settlement} date."
msgstr ""
"Se @{primeiro_juro} < @{liquidação} e @{método_cálculo} = VERDADEIRO, JURO."
"ACUM devolve a soma dos juros acumulados em todos os períodos desde a data "
"@{emissão} até à data @{liquidação}."

#: ../plugins/fn-financial/functions.c:377
msgid ""
"If @{first_interest} < @{settlement} and @{calc_method} is FALSE, then "
"ACCRINT returns the sum of the interest accrued in all coupon periods from "
"@{first_interest}  date until @{settlement} date."
msgstr ""
"Se @{primeiro_juro} < @{liquidação} e @{método_cálculo} = FALSO, JURO.ACUM "
"devolve a soma dos juros acumulados em todos os períodos desde a data "
"@{primeiro_juro} até à data @{liquidação}."

#: ../plugins/fn-financial/functions.c:382
msgid ""
"Otherwise ACCRINT returns the sum of the interest accrued in all coupon "
"periods from @{issue}  date until @{settlement} date."
msgstr ""
"Noutro caso, JURO.ACUM devolve a soma dos juros acumulados em todos os "
"períodos desde a data @{emissão} até à data @{liquidação}."

#: ../plugins/fn-financial/functions.c:385
msgid ""
"@{frequency} must be one of 1, 2 or 4, but the exact value does not affect "
"the result."
msgstr ""
"@{frequência} tem ser uma de 1, 2, 3 ou 4, mas o valor exato não afeta o "
"resultado."

#: ../plugins/fn-financial/functions.c:387
msgid "@{issue} must precede both @{first_interest} and @{settlement}."
msgstr "@{emissão}tem de preceder @{primeiro_juro} e @{liquidação}."

#: ../plugins/fn-financial/functions.c:449
msgid "ACCRINTM:accrued interest"
msgstr "JURO.M.ACUM: juros acumulados"

#: ../plugins/fn-financial/functions.c:451
#: ../plugins/fn-financial/functions.c:489
#: ../plugins/fn-financial/functions.c:527
#: ../plugins/fn-financial/functions.c:568
#: ../plugins/fn-financial/functions.c:604
#: ../plugins/fn-financial/functions.c:649
#: ../plugins/fn-financial/functions.c:1087
#: ../plugins/fn-financial/functions.c:1125
#: ../plugins/fn-financial/functions.c:1159
#: ../plugins/fn-financial/functions.c:1891
#: ../plugins/fn-financial/functions.c:2256
#: ../plugins/fn-financial/functions.c:2306
#: ../plugins/fn-financial/functions.c:2415
#: ../plugins/fn-financial/functions.c:2460
#: ../plugins/fn-financial/functions.c:2499
#: ../plugins/fn-financial/functions.c:2649
#: ../plugins/fn-financial/functions.c:2745
#: ../plugins/fn-financial/functions.c:2823
#: ../plugins/fn-financial/functions.c:3003
#: ../plugins/fn-financial/functions.c:3027
#: ../plugins/fn-financial/functions.c:3051
#: ../plugins/fn-financial/functions.c:3075
#: ../plugins/fn-financial/functions.c:3101
#: ../plugins/fn-financial/functions.c:3127
#: ../plugins/fn-financial/functions.c:3239
msgid "maturity:maturity date"
msgstr "maturidade: data de maturidade"

#: ../plugins/fn-financial/functions.c:453
msgid "par:par value"
msgstr "nominal: valor nominal"

#: ../plugins/fn-financial/functions.c:455
msgid "ACCRINTM calculates the accrued interest from @{issue} to @{maturity}."
msgstr ""
"JURO.M.ACUM calcula os juros acumulados desde @{emissão} até @{maturidade}."

#: ../plugins/fn-financial/functions.c:456
msgid "@{par} defaults to $1000."
msgstr "@{nominal} é predefinido para 1000 €."

#: ../plugins/fn-financial/functions.c:487
msgid "INTRATE:interest rate"
msgstr "TAXAJUROS: taxa de juro"

#: ../plugins/fn-financial/functions.c:490
#: ../plugins/fn-financial/functions.c:528
msgid "investment:amount paid on settlement"
msgstr "investimento: quantia paga na liquidação"

#: ../plugins/fn-financial/functions.c:491
#: ../plugins/fn-financial/functions.c:570
#: ../plugins/fn-financial/functions.c:651
#: ../plugins/fn-financial/functions.c:2259
#: ../plugins/fn-financial/functions.c:2309
#: ../plugins/fn-financial/functions.c:2417
#: ../plugins/fn-financial/functions.c:2504
#: ../plugins/fn-financial/functions.c:2654
#: ../plugins/fn-financial/functions.c:2749
#: ../plugins/fn-financial/functions.c:2827
msgid "redemption:amount received at maturity"
msgstr "redenção: quantia recebida no vencimento"

#: ../plugins/fn-financial/functions.c:493
msgid "INTRATE calculates the interest of a fully vested security."
msgstr "TAXAJUROS calcula o juro de uma segurança totalmente investida."

#: ../plugins/fn-financial/functions.c:525
msgid "RECEIVED:amount to be received at maturity"
msgstr "RECEBIDO: quantia a receber no vencimento"

#: ../plugins/fn-financial/functions.c:531
msgid "RECEIVED calculates the amount to be received when a security matures."
msgstr "RECEBIDO calcula a quantia a receber quando uma segurança vence."

#: ../plugins/fn-financial/functions.c:566
msgid "PRICEDISC:discounted price"
msgstr "PREÇODESC: preço descontado"

#: ../plugins/fn-financial/functions.c:569
#: ../plugins/fn-financial/functions.c:606
#: ../plugins/fn-financial/functions.c:1088
#: ../plugins/fn-financial/functions.c:1126
msgid "discount:annual rate at which to discount"
msgstr "desconto: taxa anual pela qual descontar"

#: ../plugins/fn-financial/functions.c:572
msgid ""
"PRICEDISC calculates the price per $100 face value of a bond that does not "
"pay interest at maturity."
msgstr ""
"PREÇODESC calcula o preço pelo valor facial de 100€ de uma ação que não paga "
"juros no vencimento."

#: ../plugins/fn-financial/functions.c:602
msgid "PRICEMAT:price at maturity"
msgstr "PREÇOVENC: preço no vencimento"

#: ../plugins/fn-financial/functions.c:607
#: ../plugins/fn-financial/functions.c:1893
#: ../plugins/fn-financial/functions.c:2258
#: ../plugins/fn-financial/functions.c:2503
#: ../plugins/fn-financial/functions.c:2748
#: ../plugins/fn-financial/functions.c:3241
msgid "yield:annual yield of security"
msgstr "rendimento: rendimento anual da segurança"

#: ../plugins/fn-financial/functions.c:609
msgid ""
"PRICEMAT calculates the price per $100 face value of a bond that pays "
"interest at maturity."
msgstr ""
"PREÇOVENC: calcula o preço pelo valor facial de 100€ de uma ação que paga "
"juros no vencimento."

#: ../plugins/fn-financial/functions.c:647
msgid "DISC:discount rate"
msgstr "DESC: taxa de desconto"

#: ../plugins/fn-financial/functions.c:650
msgid "par:price per $100 face value"
msgstr "nominal: preço por valor facial de 100€"

#: ../plugins/fn-financial/functions.c:653
msgid "DISC calculates the discount rate for a security."
msgstr "DESC calcula a taxa de desconto de uma segurança."

#: ../plugins/fn-financial/functions.c:654
msgid "@{redemption} is the redemption value per $100 face value."
msgstr "@{redenção} é o valor da redenção por valor facial de 100€."

#: ../plugins/fn-financial/functions.c:685
msgid "EFFECT:effective interest rate"
msgstr "EFETIVA: taxa de juro efetiva"

#: ../plugins/fn-financial/functions.c:687
#: ../plugins/fn-financial/functions.c:712
msgid "nper:number of periods used for compounding"
msgstr "nper: número de períodos usados para a composição"

#: ../plugins/fn-financial/functions.c:688
msgid ""
"EFFECT calculates the effective interest rate using the formula (1+@{rate}/"
"@{nper})^@{nper}-1."
msgstr ""
"EFETIVA calcula a taxa de juro efetiva usando a fórmula (1+@{taxa}/"
"@{nper})^@{nper}-1."

#: ../plugins/fn-financial/functions.c:710
msgid "NOMINAL:nominal interest rate"
msgstr "NOMINAL: taxa de juro nominal"

#: ../plugins/fn-financial/functions.c:711
#: ../plugins/fn-financial/functions.c:736
#: ../plugins/fn-financial/functions.c:1542
#: ../plugins/fn-financial/functions.c:1728
#: ../plugins/fn-financial/functions.c:1758
#: ../plugins/fn-financial/functions.c:1798
#: ../plugins/fn-financial/functions.c:1842
#: ../plugins/fn-financial/functions.c:1936
msgid "rate:effective annual interest rate"
msgstr "taxa: taxa de juro anual efetiva"

#: ../plugins/fn-financial/functions.c:713
msgid "NOMINAL calculates the nominal interest rate from the effective rate."
msgstr ""
"NOMINAL calcula a taxa de juro nominal a partir da taxa de juro efetiva."

#: ../plugins/fn-financial/functions.c:735
msgid "ISPMT:interest payment for period"
msgstr "É.PGTO: pagamento de juros no período"

#: ../plugins/fn-financial/functions.c:737
#: ../plugins/fn-financial/functions.c:1759
#: ../plugins/fn-financial/functions.c:1799
msgid "per:period number"
msgstr "per: número do período"

#: ../plugins/fn-financial/functions.c:738
#: ../plugins/fn-financial/functions.c:1192
#: ../plugins/fn-financial/functions.c:1459
#: ../plugins/fn-financial/functions.c:1693
#: ../plugins/fn-financial/functions.c:1729
#: ../plugins/fn-financial/functions.c:1760
#: ../plugins/fn-financial/functions.c:1800
#: ../plugins/fn-financial/functions.c:3151
#: ../plugins/fn-financial/functions.c:3195
msgid "nper:number of periods"
msgstr "nper: número de períodos"

#: ../plugins/fn-financial/functions.c:739
#: ../plugins/fn-financial/functions.c:1194
#: ../plugins/fn-financial/functions.c:1307
#: ../plugins/fn-financial/functions.c:1695
#: ../plugins/fn-financial/functions.c:1730
#: ../plugins/fn-financial/functions.c:1761
#: ../plugins/fn-financial/functions.c:1801
#: ../plugins/fn-financial/functions.c:1844
#: ../plugins/fn-financial/functions.c:1937
#: ../plugins/fn-financial/functions.c:3152
#: ../plugins/fn-financial/functions.c:3196
msgid "pv:present value"
msgstr "va: valor atual"

#: ../plugins/fn-financial/functions.c:740
msgid "ISPMT calculates the interest payment for period number @{per}."
msgstr "É.PGTO calcula o pagamento de juros para o período @{per}."

#: ../plugins/fn-financial/functions.c:771
msgid "DB:depreciation of an asset"
msgstr "DB: desvalorização de um ativo"

#: ../plugins/fn-financial/functions.c:772
#: ../plugins/fn-financial/functions.c:822
#: ../plugins/fn-financial/functions.c:871
#: ../plugins/fn-financial/functions.c:901
#: ../plugins/fn-financial/functions.c:2900
#: ../plugins/fn-financial/functions.c:2956
#: ../plugins/fn-financial/functions.c:3285
msgid "cost:initial cost of asset"
msgstr "custo: custo inicial do ativo"

#: ../plugins/fn-financial/functions.c:773
#: ../plugins/fn-financial/functions.c:823
#: ../plugins/fn-financial/functions.c:872
#: ../plugins/fn-financial/functions.c:902
#: ../plugins/fn-financial/functions.c:2903
#: ../plugins/fn-financial/functions.c:2959
#: ../plugins/fn-financial/functions.c:3286
msgid "salvage:value after depreciation"
msgstr "residual: valor residual após desvalorização"

#: ../plugins/fn-financial/functions.c:774
#: ../plugins/fn-financial/functions.c:824
#: ../plugins/fn-financial/functions.c:873
#: ../plugins/fn-financial/functions.c:903
#: ../plugins/fn-financial/functions.c:3287
msgid "life:number of periods"
msgstr "vida: número de períodos"

#: ../plugins/fn-financial/functions.c:775
#: ../plugins/fn-financial/functions.c:825
#: ../plugins/fn-financial/functions.c:904
#: ../plugins/fn-financial/functions.c:2904
#: ../plugins/fn-financial/functions.c:2960
msgid "period:subject period"
msgstr "período: período do assunto"

#: ../plugins/fn-financial/functions.c:776
msgid "month:number of months in first year of depreciation"
msgstr "mês: número de meses no primeiro ano do período de desvalorização"

#: ../plugins/fn-financial/functions.c:777
msgid ""
"DB calculates the depreciation of an asset for a given period using the "
"fixed-declining balance method."
msgstr ""
"DB calcula a desvalorização de um ativo num dado período usando o método de "
"balanço decrescente."

#: ../plugins/fn-financial/functions.c:821
msgid "DDB:depreciation of an asset"
msgstr "DBD: desvalorização de um ativo"

#: ../plugins/fn-financial/functions.c:826
#: ../plugins/fn-financial/functions.c:3290
msgid "factor:factor at which the balance declines"
msgstr "fator: fator pelo qual o balanço decresce"

#: ../plugins/fn-financial/functions.c:827
msgid ""
"DDB calculates the depreciation of an asset for a given period using the "
"double-declining balance method."
msgstr ""
"DBD calcula a desvalorização de um ativo num dado período usando o método de "
"balanço decrescente duplo."

#: ../plugins/fn-financial/functions.c:870
msgid "SLN:depreciation of an asset"
msgstr "AMORT: desvalorização de um ativo"

#: ../plugins/fn-financial/functions.c:874
msgid ""
"SLN calculates the depreciation of an asset using the straight-line method."
msgstr "AMORT calcula a desvalorização de um ativo usando o método direto."

#: ../plugins/fn-financial/functions.c:900
msgid "SYD:sum-of-years depreciation"
msgstr "AMORTD: desvalorização por soma de anos"

#: ../plugins/fn-financial/functions.c:905
msgid ""
"SYD calculates the depreciation of an asset using the sum-of-years method."
msgstr ""
"AMORTD calcula a desvalorização de um ativo usando o método \"soma de anos\"."

#: ../plugins/fn-financial/functions.c:933
msgid "DOLLARDE:convert to decimal dollar amount"
msgstr "MOEDADEC: converter para quantia decimal em euro"

#: ../plugins/fn-financial/functions.c:934
msgid "fractional_dollar:amount to convert"
msgstr "euro_fracional: quantia a converter"

#: ../plugins/fn-financial/functions.c:935
#: ../plugins/fn-financial/functions.c:983
msgid "fraction:denominator"
msgstr "fração: denominador"

#: ../plugins/fn-financial/functions.c:936
msgid ""
"DOLLARDE converts a fractional dollar amount into a decimal amount.  This is "
"the inverse of the DOLLARFR function."
msgstr ""
"MOEDADEC converte uma quantia fracional em euro numa quantia decimal. É o "
"inverso da função MOEDAFR."

#: ../plugins/fn-financial/functions.c:981
msgid "DOLLARFR:convert to dollar fraction"
msgstr "MOEDAFR: converter para uma fração de euro"

#: ../plugins/fn-financial/functions.c:982
msgid "decimal_dollar:amount to convert"
msgstr "euro_decimal: quantia a converter"

#: ../plugins/fn-financial/functions.c:984
msgid ""
"DOLLARFR converts a decimal dollar amount into a fractional amount which is "
"represented as the digits after the decimal point.  For example, 2/8 would "
"be represented as .2 while 3/16 would be represented as .03. This is the "
"inverse of the DOLLARDE function."
msgstr ""
"MOEDAFR converte uma quantia decimal em euro numa quantia fracional "
"representada como os dígitos após o ponto decimal. Por exemplo, 2/8 seria "
"representado como 0,2 enquanto 3/16 seria representado como 0,03. É o "
"inverso da função MOEDADEC."

#: ../plugins/fn-financial/functions.c:1027
msgid "MIRR:modified internal rate of return"
msgstr "TIRM: taxa interna de retorno modificada"

#: ../plugins/fn-financial/functions.c:1028
#: ../plugins/fn-financial/functions.c:1341
#: ../plugins/fn-financial/functions.c:1543
#: ../plugins/fn-financial/functions.c:1598
msgid "values:cash flow"
msgstr "valores: fluxo de caixa"

#: ../plugins/fn-financial/functions.c:1029
msgid "finance_rate:interest rate for financing cost"
msgstr "taxa_financeira: taxa de juro para custo financeiro"

#: ../plugins/fn-financial/functions.c:1030
msgid "reinvest_rate:interest rate for reinvestments"
msgstr "taxa_reinvestimento: taxa de juro para reinvestimentos"

#: ../plugins/fn-financial/functions.c:1031
msgid ""
"MIRR calculates the modified internal rate of return of a periodic cash flow."
msgstr ""
"TIRM calcula a taxa interna de retorno mof«dificada de um fluxo de caixa "
"periódico."

#: ../plugins/fn-financial/functions.c:1085
msgid "TBILLEQ:bond-equivalent yield for a treasury bill"
msgstr "OBRTESN: lucro de uma obrigação do tesouro equivalente ao de uma ação"

#: ../plugins/fn-financial/functions.c:1089
msgid "TBILLEQ calculates the bond-equivalent yield for a treasury bill."
msgstr ""
"OBRTESN calcula o lucro de uma obrigação do tesouro equivalente ao de uma "
"ação"

#: ../plugins/fn-financial/functions.c:1123
msgid "TBILLPRICE:price of a treasury bill"
msgstr "OBRTESNPREÇO: preço de uma obrigação do tesouro"

#: ../plugins/fn-financial/functions.c:1127
msgid ""
"TBILLPRICE calculates the price per $100 face value for a treasury bill."
msgstr ""
"OBRTESNPREÇO calcula o preço de uma obrigação do tesouro por valor facial de "
"100€"

#: ../plugins/fn-financial/functions.c:1157
msgid "TBILLYIELD:yield of a treasury bill"
msgstr "OBRTESNLUCRO: lucro de uma obrigação do tesouro"

#: ../plugins/fn-financial/functions.c:1160
msgid "price:price"
msgstr "preço: preço"

#: ../plugins/fn-financial/functions.c:1161
msgid "TBILLYIELD calculates the yield of a treasury bill."
msgstr "OBRTESNLUCRO calcula o lucro de uma obrigação do tesouro."

#: ../plugins/fn-financial/functions.c:1191
msgid "RATE:rate of investment"
msgstr "TAXA: taxa de investimento"

#: ../plugins/fn-financial/functions.c:1193
#: ../plugins/fn-financial/functions.c:1460
#: ../plugins/fn-financial/functions.c:1694
#: ../plugins/fn-financial/functions.c:1843
msgid "pmt:payment at each period"
msgstr "pgt: pagamento em cada período"

#: ../plugins/fn-financial/functions.c:1195
#: ../plugins/fn-financial/functions.c:1308
#: ../plugins/fn-financial/functions.c:1461
#: ../plugins/fn-financial/functions.c:1731
#: ../plugins/fn-financial/functions.c:1762
#: ../plugins/fn-financial/functions.c:1802
#: ../plugins/fn-financial/functions.c:1845
#: ../plugins/fn-financial/functions.c:1938
msgid "fv:future value"
msgstr "vf: valor futuro"

#: ../plugins/fn-financial/functions.c:1196
#: ../plugins/fn-financial/functions.c:1462
#: ../plugins/fn-financial/functions.c:1696
#: ../plugins/fn-financial/functions.c:1732
#: ../plugins/fn-financial/functions.c:1763
#: ../plugins/fn-financial/functions.c:1803
#: ../plugins/fn-financial/functions.c:1846
#: ../plugins/fn-financial/functions.c:3155
#: ../plugins/fn-financial/functions.c:3199
msgid "type:payment type"
msgstr "tipo: tipo de pagamento"

#: ../plugins/fn-financial/functions.c:1197
#: ../plugins/fn-financial/functions.c:1342
#: ../plugins/fn-financial/functions.c:1600
msgid "guess:an estimate of what the result should be"
msgstr "palpite: estimativa do que o resultado deveria ser"

#: ../plugins/fn-financial/functions.c:1198
msgid "RATE calculates the rate of return."
msgstr "TAXA calcula a taxa do retorno."

#: ../plugins/fn-financial/functions.c:1200
#: ../plugins/fn-financial/functions.c:1345
#: ../plugins/fn-financial/functions.c:1602
msgid ""
"The optional @{guess} is needed because there can be more than one valid "
"result.  It defaults to 10%."
msgstr ""
"A opção @{palpite} é necessária porque pode haver mais de um resultado "
"válido. A predefinição é 10%."

#: ../plugins/fn-financial/functions.c:1305
msgid "RRI:equivalent interest rate for an investment increasing in value"
msgstr "TJE: taxa de juro equivalente para um investimento a aumentar de valor"

#: ../plugins/fn-financial/functions.c:1306
msgid "p:number of periods"
msgstr "p: número de períodos"

#: ../plugins/fn-financial/functions.c:1309
msgid ""
"RRI determines an equivalent interest rate for an investment that increases "
"in value. The interest is compounded after each complete period."
msgstr ""
"TJE determina a taxa de juro equivalente para um investimento a aumentar de "
"valor. O juro é composto após cada período completo."

#: ../plugins/fn-financial/functions.c:1311
msgid ""
"Note that @{p} need not be an integer but for fractional value the "
"calculated rate is only approximate."
msgstr ""
"Note que @{p} não precisa de ser um inteiro, mas para valores fracionais a "
"taxa calculada é só aproximada."

#: ../plugins/fn-financial/functions.c:1340
msgid "IRR:internal rate of return"
msgstr "TIR: taxa interna de retorno"

#: ../plugins/fn-financial/functions.c:1343
msgid ""
"IRR calculates the internal rate of return of a cash flow with periodic "
"payments.  @{values} lists the payments (negative values) and receipts "
"(positive values) for each period."
msgstr ""
"TRI calcula a taxa interna de retorno de um fluxo de caixa com pagamentos "
"periódicos. @{valores} lista os pagamentos (valores negativos) e "
"recebimentos (valores positivos) para cadfa período."

#: ../plugins/fn-financial/functions.c:1457
msgid "PV:present value"
msgstr "VA: valor atual"

#: ../plugins/fn-financial/functions.c:1458
#: ../plugins/fn-financial/functions.c:1498
#: ../plugins/fn-financial/functions.c:1692
msgid "rate:effective interest rate per period"
msgstr "taxa: taxa de juro efetiva por período"

#: ../plugins/fn-financial/functions.c:1463
msgid ""
"PV calculates the present value of @{fv} which is @{nper} periods into the "
"future, assuming a periodic payment of @{pmt} and an interest rate of "
"@{rate} per period."
msgstr ""
"VA calcula o valor presente de @{vf}, que está @{nper} no futuro, assumindo "
"um pagamento público de @{pgt} e uma taxa de juro de @{taxa} por período."

#: ../plugins/fn-financial/functions.c:1497
msgid "NPV:net present value"
msgstr "VAL: valor atual líquido"

#: ../plugins/fn-financial/functions.c:1499
msgid "value1:cash flow for period 1"
msgstr "valor1: fluxo de caixa para o período 1"

#: ../plugins/fn-financial/functions.c:1500
msgid "value2:cash flow for period 2"
msgstr "valor2: fluxo de caixa para o período 2"

#: ../plugins/fn-financial/functions.c:1501
msgid "NPV calculates the net present value of a cash flow."
msgstr "VAL calcula o valor atual líquido de um fluxo de caixa."

#: ../plugins/fn-financial/functions.c:1541
msgid "XNPV:net present value"
msgstr "XVAL: valor atual líquido"

#: ../plugins/fn-financial/functions.c:1544
#: ../plugins/fn-financial/functions.c:1599
msgid "dates:dates of cash flow"
msgstr "datas: datas do fluxo de caixa"

#: ../plugins/fn-financial/functions.c:1545
msgid "XNPV calculates the net present value of a cash flow at irregular times"
msgstr ""
"XVAL calcula o valor atual líquido de um fluxo de caixa em períodos "
"irregulares"

#: ../plugins/fn-financial/functions.c:1597
msgid "XIRR:internal rate of return"
msgstr "XTIR: taxa interna de retorno"

#: ../plugins/fn-financial/functions.c:1601
msgid ""
"XIRR calculates the annualized internal rate of return of a cash flow at "
"arbitrary points in time.  @{values} lists the payments (negative values) "
"and receipts (positive values) with one value for each entry in @{dates}."
msgstr ""
"XTIR calcula a taxa interna de retorno anual de um fluxo de caixa em pontos "
"arbitrários no tempo. @{valores} lista os pagamentos (valores negativos) e "
"recebimentos (valores positivos) com um valor por cada entrada em @{datas}."

#: ../plugins/fn-financial/functions.c:1691
msgid "FV:future value"
msgstr "VF: valor fururo"

#: ../plugins/fn-financial/functions.c:1697
msgid ""
"FV calculates the future value of @{pv} moved @{nper} periods into the "
"future, assuming a periodic payment of @{pmt} and an interest rate of "
"@{rate} per period."
msgstr ""
"VF calcula o valor futuro de @{va} movido @{nper} períodos para o futuro, "
"assumindo um pagamento periódico de @{pgt} e uma taxa de juro de @{taxa} por "
"período."

#: ../plugins/fn-financial/functions.c:1727
msgid "PMT:payment for annuity"
msgstr "PGTO: pagamento para anuidade"

#: ../plugins/fn-financial/functions.c:1733
msgid "PMT calculates the payment amount for an annuity."
msgstr "PGTO calcula a quantia de pagamento para uma anuidade."

#: ../plugins/fn-financial/functions.c:1757
msgid "IPMT:interest payment for period"
msgstr "JPGTO: pagamento de juros do período"

#: ../plugins/fn-financial/functions.c:1764
msgid ""
"IPMT calculates the interest part of an annuity's payment for period number "
"@{per}."
msgstr ""
"JPGTO calcula a parte de juros de um pagamento de anuidade para o período "
"@{per}."

#: ../plugins/fn-financial/functions.c:1797
msgid "PPMT:interest payment for period"
msgstr "PPGTO: pagamento de juros do período"

#: ../plugins/fn-financial/functions.c:1804
msgid ""
"PPMT calculates the principal part of an annuity's payment for period number "
"@{per}."
msgstr ""
"PPGTO calcula a parte principal de um pagamento de anuidade para o período "
"@{per}."

#: ../plugins/fn-financial/functions.c:1841
msgid "NPER:number of periods"
msgstr "NUM.PER: número de períodos"

#: ../plugins/fn-financial/functions.c:1847
msgid ""
"NPER calculates the number of periods of an investment based on periodic "
"constant payments and a constant interest rate."
msgstr ""
"NMU.PER calcula o número de períodos de um investimento baseado em "
"pagamentos periódicos constantes e numa taxa de juro constante."

#: ../plugins/fn-financial/functions.c:1889
msgid "DURATION:the (Macaulay) duration of a security"
msgstr "DURAÇÃO: a duração (Macaulay) de uma segurança"

#: ../plugins/fn-financial/functions.c:1892
#: ../plugins/fn-financial/functions.c:3240
msgid "coupon:annual coupon rate"
msgstr "cupão: taxa anual do cupão"

#: ../plugins/fn-financial/functions.c:1896
msgid "DURATION calculates the (Macaulay) duration of a security."
msgstr "DURAÇÃO calcula a duração (Macaulay) de uma segurança."

#: ../plugins/fn-financial/functions.c:1935
msgid "G_DURATION:the duration of a investment"
msgstr "DURAÇÃO.G: a duração de um investimento"

#: ../plugins/fn-financial/functions.c:1939
msgid ""
"G_DURATION calculates the number of periods needed for an investment to "
"attain a desired value."
msgstr ""
"DURAÇÃO.G calcula o número de períodos necessário para que um investimento "
"obtenha um valor desejado."

#: ../plugins/fn-financial/functions.c:1940
msgid "G_DURATION is the OpenFormula function PDURATION."
msgstr "DURAÇÃO.G é a função OpenFormula DURAÇÃOP."

#: ../plugins/fn-financial/functions.c:1969
msgid "FVSCHEDULE:future value"
msgstr "VFPLANO: valor futuro"

#: ../plugins/fn-financial/functions.c:1970
msgid "principal:initial value"
msgstr "principal: valor inicial"

#: ../plugins/fn-financial/functions.c:1971
msgid "schedule:range of interest rates"
msgstr "plano: intervalo de taxas de juro"

#: ../plugins/fn-financial/functions.c:1972
msgid ""
"FVSCHEDULE calculates the future value of @{principal} after applying a "
"range of interest rates with compounding."
msgstr ""
"VFPLANO calcula o valor futuro de @{principal} após aplicar um intervalo de "
"taxas de juro com composição."

#: ../plugins/fn-financial/functions.c:2005
msgid "EURO:equivalent of 1 EUR"
msgstr "EURO: equivalente a 1 EUR"

#: ../plugins/fn-financial/functions.c:2006
msgid "currency:three-letter currency code"
msgstr "moeda: código de três letras para a moeda"

#: ../plugins/fn-financial/functions.c:2007
msgid ""
"EURO calculates the national currency amount corresponding to 1 EUR for any "
"of the national currencies that were replaced by the Euro on its "
"introduction."
msgstr ""
"EURO calcula a quantia de moeda nacional correspondente a 1 € para qualquer "
"moeda nacional que foi substituída pelo euro na sua introdução."

#: ../plugins/fn-financial/functions.c:2008
msgid ""
"@{currency} must be one of ATS (Austria), BEF (Belgium), CYP (Cyprus), DEM "
"(Germany), EEK (Estonia), ESP (Spain), EUR (Euro), FIM (Finland), FRF "
"(France), GRD (Greece), IEP (Ireland), ITL (Italy), LUF (Luxembourg), MTL "
"(Malta), NLG (The Netherlands), PTE (Portugal), SIT (Slovenia), or SKK "
"(Slovakia)."
msgstr ""
"@{moeda} tem de ser uma das ATS (Áustria), BEF (Bélgica), CYP (Chipre), DEM "
"(Alemanha), EEK (Estónia), ESP (Espanha), EUR (Euro), FIM (Finlândia), FRF "
"(França), GRD (Grécia), IEP (Irlanda), ITL (Itália), LUF (Luxemburgo), MTL "
"(Malta), NLG (Holanda), PTE (Portugal), SIT (Eslovénia), ou SKK (Eslováquia)."

#: ../plugins/fn-financial/functions.c:2027
#: ../plugins/fn-financial/functions.c:2211
msgid "This function is not likely to be useful anymore."
msgstr "Esta função não deverá voltar a ser útil."

#: ../plugins/fn-financial/functions.c:2202
msgid "EUROCONVERT:pre-Euro amount from one currency to another"
msgstr "CONVERSOREURO: conversor de moeda pré-euro"

#: ../plugins/fn-financial/functions.c:2203
msgid "n:amount"
msgstr "n: quantia"

#: ../plugins/fn-financial/functions.c:2204
msgid "source:three-letter source currency code"
msgstr "origem: código de três letras para a moeda de origem"

#: ../plugins/fn-financial/functions.c:2205
msgid "target:three-letter target currency code"
msgstr "destino: código de três letras para a moeda de destino"

#: ../plugins/fn-financial/functions.c:2206
msgid "full_precision:whether to provide the full precision; defaults to false"
msgstr "precisão_total: se fornecer precisão total; predefinição é FALSO"

#: ../plugins/fn-financial/functions.c:2207
msgid ""
"triangulation_precision:number of digits (at least 3) to be rounded to after "
"conversion of the source currency to euro; defaults to no rounding"
msgstr ""
"precisão_triangulação: número de dígitos (pelo menos 3) para serem "
"arredondados após a conversão da moeda de origem para euro; a predefinição é "
"sem arredondamento."

#: ../plugins/fn-financial/functions.c:2208
msgid ""
"EUROCONVERT converts @{n} units of currency @{source} to currency "
"@{target}.  The rates used are the official ones used on the introduction of "
"the Euro."
msgstr ""
"CONVERSOREURO converte @{n} unidades de moeda @{origem} para a moeda "
"@{destino}. As taxas são as oficiais usadas na introdução do Euro."

#: ../plugins/fn-financial/functions.c:2209
msgid ""
"If @{full_precision} is true, the result is not rounded; if it false the "
"result is rounded to 0 or 2 decimals depending on the target currency; "
"defaults to false."
msgstr ""
"Se @{precisão_total} for VERDADEIRO, o resultado não é arredondado, caso "
"contrário é arredondado para 0 ou duas casa decimais, dependendo da moda "
"destino. A predefinição é FALSO."

#: ../plugins/fn-financial/functions.c:2210
msgid ""
"@{source} and @{target} must be one of the currencies listed for the EURO "
"function."
msgstr ""
"@{origem} e @{destino} têm de ser uma das moedas listadas para a função EURO."

#: ../plugins/fn-financial/functions.c:2254
msgid "PRICE:price of a security"
msgstr "PREÇO: preço de uma segurança"

#: ../plugins/fn-financial/functions.c:2262
msgid ""
"PRICE calculates the price per $100 face value of a security that pays "
"periodic interest."
msgstr ""
"PREÇO calcula o preço por valor facial de 100€ de uma segurança que paga "
"juros periódicos."

#: ../plugins/fn-financial/functions.c:2304
msgid "YIELD:yield of a security"
msgstr "LUCRO: lucro de uma segurança"

#: ../plugins/fn-financial/functions.c:2308
#: ../plugins/fn-financial/functions.c:2416
#: ../plugins/fn-financial/functions.c:2463
#: ../plugins/fn-financial/functions.c:2653
#: ../plugins/fn-financial/functions.c:2826
msgid "price:price of security"
msgstr "preço: preço da segurança"

#: ../plugins/fn-financial/functions.c:2312
msgid "YIELD calculates the yield of a security that pays periodic interest."
msgstr "LUCRO calcula o lucro de uma segurança que paga juros periódicos."

#: ../plugins/fn-financial/functions.c:2413
msgid "YIELDDISC:yield of a discounted security"
msgstr "LUCRODESC: lucro de uma segurança descontada"

#: ../plugins/fn-financial/functions.c:2419
msgid "YIELDDISC calculates the yield of a discounted security."
msgstr "LUCRODESC calcula o lucro de uma segurança descontada."

#: ../plugins/fn-financial/functions.c:2458
msgid "YIELDMAT:yield of a security"
msgstr "LUCROVENC: lucro de uma segurança"

#: ../plugins/fn-financial/functions.c:2465
msgid ""
"YIELDMAT calculates the yield of a security for which the interest is paid "
"at maturity date."
msgstr ""
"LUCROVENC calcula lucro de uma segurança para a qual o juro é pago na data "
"de vencimento."

#: ../plugins/fn-financial/functions.c:2497
msgid "ODDFPRICE:price of a security that has an odd first period"
msgstr "PREÇOPRIMINC: preço de uma segurança que tem um primeiro período ímpar"

#: ../plugins/fn-financial/functions.c:2501
#: ../plugins/fn-financial/functions.c:2651
msgid "first_interest:first interest date"
msgstr "primeiro_juro: data do primeiro juro"

#: ../plugins/fn-financial/functions.c:2507
msgid ""
"ODDFPRICE calculates the price per $100 face value of a security that pays "
"periodic interest, but has an odd first period."
msgstr ""
"PREÇOPRIMINC calcula o preço por valor facial de 100€ de uma segurança que "
"paga juros periódicos, mas que tem um primeiro período ímpar."

#: ../plugins/fn-financial/functions.c:2647
msgid "ODDFYIELD:yield of a security that has an odd first period"
msgstr "LUCROPRIMINC: lucro de uma segurança que tem um primeiro período ímpar"

#: ../plugins/fn-financial/functions.c:2657
msgid ""
"ODDFYIELD calculates the yield of a security that pays periodic interest, "
"but has an odd first period."
msgstr ""
"LUCROPRIMINC calcula o lucro de uma segurança que paga juros periódicos, mas "
"que tem um primeiro período ímpar."

#: ../plugins/fn-financial/functions.c:2743
msgid "ODDLPRICE:price of a security that has an odd last period"
msgstr "PREÇOÚLTINC: preço de uma segurança que tem um último período ímpar"

#: ../plugins/fn-financial/functions.c:2746
#: ../plugins/fn-financial/functions.c:2824
msgid "last_interest:last interest date"
msgstr "último_juro: data do último juro"

#: ../plugins/fn-financial/functions.c:2752
msgid ""
"ODDLPRICE calculates the price per $100 face value of a security that pays "
"periodic interest, but has an odd last period."
msgstr ""
"PREÇOÚLTINC calcula o preço por valor facial de 100€ de uma segurança que "
"paga juros periódicos, mas que tem um último período ímpar"

#: ../plugins/fn-financial/functions.c:2821
msgid "ODDLYIELD:yield of a security that has an odd last period"
msgstr "LUCROÚLTINC: lucro de uma segurança que tem um último período ímpar"

#: ../plugins/fn-financial/functions.c:2830
msgid ""
"ODDLYIELD calculates the yield of a security that pays periodic interest, "
"but has an odd last period."
msgstr ""
"LUCROÚLTINC calcula o lucro de uma segurança que paga juros periódicos, mas "
"que tem um último período ímpar."

#: ../plugins/fn-financial/functions.c:2899
msgid "AMORDEGRC:depreciation of an asset using French accounting conventions"
msgstr ""
"AMORDEGRC: desvalorização de um ativo usando as convenções contabilísticas "
"francesas"

#: ../plugins/fn-financial/functions.c:2901
#: ../plugins/fn-financial/functions.c:2957
msgid "purchase_date:date of purchase"
msgstr "data_compra: data de aquisição"

#: ../plugins/fn-financial/functions.c:2902
#: ../plugins/fn-financial/functions.c:2958
msgid "first_period:end of first period"
msgstr "primeiro_período: final do primeiro período"

#: ../plugins/fn-financial/functions.c:2905
#: ../plugins/fn-financial/functions.c:2961
msgid "rate:depreciation rate"
msgstr "taxa: taxa de desvalorização"

#: ../plugins/fn-financial/functions.c:2908
msgid ""
"AMORDEGRC calculates the depreciation of an asset using French accounting "
"conventions. Assets purchased in the middle of a period take prorated "
"depreciation into account. This is similar to AMORLINC, except that a "
"depreciation coefficient is applied in the calculation depending on the life "
"of the assets."
msgstr ""
"AMORDEGRC calcula a desvalorização de um ativo usando as convenções "
"contabilísticas francesas. Ativos comprados no meio de um período levam em "
"conta desvalorização pré-taxada. É semelhante a AMORLINC, exceto que um "
"coeficiente de desvalorização é aplicado no cálculo dependendo da vida útil "
"dos ativos."

#: ../plugins/fn-financial/functions.c:2912
msgid ""
"The depreciation coefficient used is:\n"
"1.0 for an expected lifetime less than 3 years,\n"
"1.5 for an expected lifetime of at least 3 years but less than 5 years,\n"
"2.0 for an expected lifetime of at least 5 years but at most 6 years,\n"
"2.5 for an expected lifetime of more than 6 years."
msgstr ""
"Os coeficentes usados são:\n"
"1.0 para uma vida útil inferior a 3 anos,\n"
"1.5 para uma vida útil de pelo menos 3 anos, mas inferior a 5 anos,\n"
"2.0 para uma vida útil de pelo menos 5 e no máximo 6 anos,\n"
"2.5 para uma vida útil de mais de 6 anos."

#: ../plugins/fn-financial/functions.c:2917
msgid ""
"Special depreciation rules are applied for the last two periods resulting in "
"a possible total depreciation exceeding the difference of @{cost} - "
"@{salvage}."
msgstr ""
"São aplicadas regras especiais de desvalorização aos dois últimos períodos, "
"resultando numa possível desvalorização total excedendo a diferença entre "
"@{custo} - @{residual}."

#: ../plugins/fn-financial/functions.c:2919
msgid "Named for AMORtissement DEGRessif Comptabilite."
msgstr "Asim chamado por AMORtissement DEGRessif Comptabilite."

#: ../plugins/fn-financial/functions.c:2955
msgid "AMORLINC:depreciation of an asset using French accounting conventions"
msgstr ""
"AMORLINC: desvalorização de um ativo usando as convenções contabilísticas "
"francesas"

#: ../plugins/fn-financial/functions.c:2964
msgid ""
"AMORLINC calculates the depreciation of an asset using French accounting "
"conventions. Assets purchased in the middle of a period take prorated "
"depreciation into account. "
msgstr ""
"AMORLINC calcula a desvalorização de um ativo usando as convenções "
"contabilísticas francesas. Ativos comprados no meio de um período levam em "
"conta desvalorização pré-taxada."

#: ../plugins/fn-financial/functions.c:2966
msgid "Named for AMORtissement LINeaire Comptabilite."
msgstr "Assim chamado por AMORtissement LINeaire Comptabilite."

#: ../plugins/fn-financial/functions.c:3001
msgid "COUPDAYBS:number of days from coupon period to settlement"
msgstr "CUPDIASINLIQ: número de dias desde o período do cupão até à liquidação"

#: ../plugins/fn-financial/functions.c:3006
#: ../plugins/fn-financial/functions.c:3030
#: ../plugins/fn-financial/functions.c:3054
#: ../plugins/fn-financial/functions.c:3078
#: ../plugins/fn-financial/functions.c:3104
#: ../plugins/fn-financial/functions.c:3130
msgid "eom:end-of-month flag"
msgstr "fdm: bandeira de fim de mês"

#: ../plugins/fn-financial/functions.c:3007
msgid ""
"COUPDAYBS calculates the number of days from the beginning of the coupon "
"period to the settlement date."
msgstr ""
"CUPDIASINLIQ calcula o número de dias desde o início do período do cupão até "
"à data de liquidação."

#: ../plugins/fn-financial/functions.c:3025
msgid "COUPDAYS:number of days in the coupon period of the settlement date"
msgstr "CUPDIAS: número de dias no período do cupão da data de liquidação"

#: ../plugins/fn-financial/functions.c:3031
msgid ""
"COUPDAYS calculates the number of days in the coupon period of the "
"settlement date."
msgstr ""
"CUPDIAS calcula o número de dias no período do cupão da data de liquidação."

#: ../plugins/fn-financial/functions.c:3049
msgid ""
"COUPDAYSNC:number of days from the settlement date to the next coupon period"
msgstr ""
"CUPDIASPRÓX: número de dias da data de liquidação até ao próximo período de "
"cupão"

#: ../plugins/fn-financial/functions.c:3055
msgid ""
"COUPDAYSNC calculates number of days from the settlement date to the next "
"coupon period."
msgstr ""
"CUPDIASPRÓX calcula o número de dias da data de liquidação até ao próximo "
"período de cupão."

#: ../plugins/fn-financial/functions.c:3073
msgid "COUPNCD:the next coupon date after settlement"
msgstr "CUPDATAPRÓX: a próxima data de cupão após liquidação"

#: ../plugins/fn-financial/functions.c:3079
msgid "COUPNCD calculates the coupon date following settlement."
msgstr "CUPDATAPRÓX calcula a data de cupão após liquidação."

#: ../plugins/fn-financial/functions.c:3099
msgid "COUPPCD:the last coupon date before settlement"
msgstr "CUPDATAANT: a última data de cupão antes da liquidação"

#: ../plugins/fn-financial/functions.c:3105
msgid "COUPPCD calculates the coupon date preceding settlement."
msgstr "CUPDATAANT calcula a data de cupão antes da liquidação."

#: ../plugins/fn-financial/functions.c:3125
msgid "COUPNUM:number of coupons"
msgstr "CUPNÚM: número de cupões"

#: ../plugins/fn-financial/functions.c:3131
msgid ""
"COUPNUM calculates the number of coupons to be paid between the settlement "
"and maturity dates, rounded up."
msgstr ""
"CUPNÚM calcula o número de cupões a serem pagos entre as datas de liquidação "
"e vencimento, arredondado."

#: ../plugins/fn-financial/functions.c:3149
msgid "CUMIPMT:cumulative interest payment"
msgstr "PGTOJURACUM: pagamento de juros acumulados"

#: ../plugins/fn-financial/functions.c:3150
#: ../plugins/fn-financial/functions.c:3194
msgid "rate:interest rate per period"
msgstr "taxa: taxa de juro por período"

#: ../plugins/fn-financial/functions.c:3153
#: ../plugins/fn-financial/functions.c:3197
#: ../plugins/fn-financial/functions.c:3288
msgid "start_period:first period to accumulate for"
msgstr "período_inicial: primeiro período para acumular"

#: ../plugins/fn-financial/functions.c:3154
#: ../plugins/fn-financial/functions.c:3198
#: ../plugins/fn-financial/functions.c:3289
msgid "end_period:last period to accumulate for"
msgstr "período_final: último período para acumular"

#: ../plugins/fn-financial/functions.c:3156
msgid ""
"CUMIPMT calculates the cumulative interest paid on a loan from "
"@{start_period} to @{end_period}."
msgstr ""
"PGTOJURACUM calcula os juros acumulados pagos num empréstimo desde @{período:"
"inicial} até @{período_final}."

#: ../plugins/fn-financial/functions.c:3193
msgid "CUMPRINC:cumulative principal"
msgstr "PGTOCAPACUM: principal acumulado"

#: ../plugins/fn-financial/functions.c:3200
msgid ""
"CUMPRINC calculates the cumulative principal paid on a loan from "
"@{start_period} to @{end_period}."
msgstr ""
"PGTOCAPACUM calcula o pagamento principal acumulado num empréstimo desde "
"@{período:inicial} até @{período_final}."

#: ../plugins/fn-financial/functions.c:3237
msgid "MDURATION:the modified (Macaulay) duration of a security"
msgstr "DURAÇÃOM: a duração modificada (Macaulay) de uma segurança"

#: ../plugins/fn-financial/functions.c:3244
msgid "MDURATION calculates the modified (Macaulay) duration of a security."
msgstr "DURAÇÃOM calcula a duração modificada (Macaulay) de uma segurança."

#: ../plugins/fn-financial/functions.c:3284
msgid "VDB:depreciation of an asset"
msgstr "DBV: desvalorização de um ativo"

#: ../plugins/fn-financial/functions.c:3291
msgid "no_switch:do not switch to straight-line depreciation"
msgstr "não_mudar: não mudar para desvalorização direta"

#: ../plugins/fn-financial/functions.c:3292
msgid ""
"VDB calculates the depreciation of an asset for a given period range using "
"the variable-rate declining balance method."
msgstr ""
"DBV calcula a desvalorização de um ativo num dado período usando o método de "
"balanço descendente de taxa variável."

#: ../plugins/fn-financial/functions.c:3293
msgid ""
"If @{no_switch} is FALSE, the calculation switches to straight-line "
"depreciation when depreciation is greater than the declining balance "
"calculation."
msgstr ""
"Se @{não_mudar} for FALSO, o cálculo muda para a desvalorização direta "
"quando a desvalorização é maior que o cálculo de balanço descendente."

#: ../plugins/fn-hebrew-date/functions.c:92
msgid "HDATE:Hebrew date"
msgstr "DATA.HEBRAICA: data hebraica"

#: ../plugins/fn-hebrew-date/functions.c:93
#: ../plugins/fn-hebrew-date/functions.c:162
#: ../plugins/fn-hebrew-date/functions.c:235
#: ../plugins/fn-hebrew-date/functions.c:262
#: ../plugins/fn-hebrew-date/functions.c:289
#: ../plugins/fn-hebrew-date/functions.c:316
msgid "year:Gregorian year of date, defaults to the current year"
msgstr "ano: ano gregoriano da data, predefinido como o ano atual"

#: ../plugins/fn-hebrew-date/functions.c:94
#: ../plugins/fn-hebrew-date/functions.c:163
#: ../plugins/fn-hebrew-date/functions.c:236
#: ../plugins/fn-hebrew-date/functions.c:263
#: ../plugins/fn-hebrew-date/functions.c:290
#: ../plugins/fn-hebrew-date/functions.c:317
msgid "month:Gregorian month of year, defaults to the current month"
msgstr "mês: mês gregoriano da data, predefinido como o mês atual"

#: ../plugins/fn-hebrew-date/functions.c:95
#: ../plugins/fn-hebrew-date/functions.c:164
#: ../plugins/fn-hebrew-date/functions.c:237
#: ../plugins/fn-hebrew-date/functions.c:264
#: ../plugins/fn-hebrew-date/functions.c:291
#: ../plugins/fn-hebrew-date/functions.c:318
msgid "day:Gregorian day of month, defaults to the current day"
msgstr "dia: dia gregoriano da data, predefinido como o dia atual"

#: ../plugins/fn-hebrew-date/functions.c:127
msgid "DATE2HDATE:Hebrew date"
msgstr "DATA.PARA.DATA.HEBRAICA: data hebraica"

#: ../plugins/fn-hebrew-date/functions.c:128
#: ../plugins/fn-hebrew-date/functions.c:203
#: ../plugins/fn-hebrew-date/functions.c:342
msgid "date:Gregorian date, defaults to today"
msgstr "data: data gregoriana,  predefinida como hoje"

#: ../plugins/fn-hebrew-date/functions.c:161
msgid "HDATE_HEB:Hebrew date in Hebrew"
msgstr "DATA.HEBRAICA.HEB: data em Hebreu"

#: ../plugins/fn-hebrew-date/functions.c:202
msgid "DATE2HDATE_HEB:Hebrew date in Hebrew"
msgstr "DATA.PARA.DATA.HEBRAICA.HEB: data hebraica em Hebreu"

#: ../plugins/fn-hebrew-date/functions.c:234
msgid "HDATE_MONTH:Hebrew month of Gregorian date"
msgstr "MÊS.DATA.HEBRAICA: mês hebraico de data gregoriana"

#: ../plugins/fn-hebrew-date/functions.c:261
msgid "HDATE_DAY:Hebrew day of Gregorian date"
msgstr "DIA.DATA.HEBRAICA: dia hebraico de data gregoriana"

#: ../plugins/fn-hebrew-date/functions.c:288
msgid "HDATE_YEAR:Hebrew year of Gregorian date"
msgstr "ANO.DATA.HEBRAICA: ano hebraico de data gregoriana"

#: ../plugins/fn-hebrew-date/functions.c:315
msgid "HDATE_JULIAN:Julian day number for given Gregorian date"
msgstr "JULIANO.DATA: número de dia juliano para uma dada data gregoriana"

#: ../plugins/fn-hebrew-date/functions.c:341
msgid "DATE2JULIAN:Julian day number for given Gregorian date"
msgstr "DATA.PARA.JULIANO: número de dia juliano para uma dada data gregoriana"

#: ../plugins/fn-info/functions.c:68
msgid "CELL:information of @{type} about @{cell}"
msgstr "CÉLULA: informação de @{tipo} sobre a @{célula}"

#: ../plugins/fn-info/functions.c:69
msgid "type:string specifying the type of information requested"
msgstr "tipo: cadeia especificando o tipo de informação pretendida"

#: ../plugins/fn-info/functions.c:70
msgid "cell:cell reference"
msgstr "célula: referência de célula"

#: ../plugins/fn-info/functions.c:71
msgid ""
"@{type} specifies the type of information you want to obtain:\n"
"  address        \t\tReturns the given cell reference as text.\n"
"  col            \t\tReturns the number of the column in @{cell}.\n"
"  color          \t\tReturns 0.\n"
"  contents       \t\tReturns the contents of the cell in @{cell}.\n"
"  column         \t\tReturns the number of the column in @{cell}.\n"
"  columnwidth    \tReturns the column width.\n"
"  coord          \t\tReturns the absolute address of @{cell}.\n"
"  datatype       \tsame as type\n"
"  filename       \t\tReturns the name of the file of @{cell}.\n"
"  format         \t\tReturns the code of the format of the cell.\n"
"  formulatype    \tsame as type\n"
"  locked         \t\tReturns 1 if @{cell} is locked.\n"
"  parentheses    \tReturns 1 if @{cell} contains a negative value\n"
"                 \t\tand its format displays it with parentheses.\n"
"  prefix         \t\tReturns a character indicating the horizontal\n"
"                 \t\talignment of @{cell}.\n"
"  prefixcharacter  \tsame as prefix\n"
"  protect        \t\tReturns 1 if @{cell} is locked.\n"
"  row            \t\tReturns the number of the row in @{cell}.\n"
"  sheetname      \tReturns the name of the sheet of @{cell}.\n"
"  type           \t\tReturns \"l\" if @{cell} contains a string, \n"
"                 \t\t\"v\" if it contains some other value, and \n"
"                 \t\t\"b\" if @{cell} is blank.\n"
"  value          \t\tReturns the contents of the cell in @{cell}.\n"
"  width          \t\tReturns the column width."
msgstr ""
"@{tipo} especifica o tipo de informação que quer obter:\n"
"  address        \t\tdevolve a referência da célula indicada como texto.\n"
"  col            \t\tdevolve o número da coluna na @{célula}.\n"
"  color          \t\tdevolve 0.\n"
"  contents       \t\tdevolve o conteúdo da célula na @{célula}.\n"
"  column         \t\tdevolve o número da coluna na @{célula}.\n"
"  columnwidth    \t\tdevolve a largura da coluna.\n"
"  coord          \t\tdevolve o endereço absoluto da @{célula}.\n"
"  datatype       \tigual a type\n"
"  filename       \t\tdevolve o nome do ficheiro da @{célula}.\n"
"  format         \t\tdevolve o código de formato da célula.\n"
"  formulatype    \tigual a type\n"
"  locked         \t\tdevolve 1 se @{célula} estiver trancada.\n"
"  parentheses    \t\tdevolve 1 se @{célula} tiver valor negativo\n"
"                 \t\te o seu formato o mostrar entre parênteses.\n"
"  prefix         \t\tdevolve um carácter indicando o alinhamento\n"
"                 \t\thorizontal da @{célula}.\n"
"  prefixcharacter  \tigual a prefix\n"
"  protect        \t\tdevolve 1 se @{célula} estiver trancada.\n"
"  row            \t\tdevolve o número da linha na @{célula}.\n"
"  sheetname      \t\tdevolve o nome da folha da @{célula}.\n"
"  type           \t\tdevolve \"l\" se @{célula} tiver uma cadeia, \n"
"                 \t\t\"v\" se tiver um outro valor, e \n"
"                 \t\t\"b\" se @{célula} estiver vazia.\n"
"  value          \t\tdevolve o conteúdo da célula na @{célula}.\n"
"  width          \t\tdevolve a largura da coluna."

#: ../plugins/fn-info/functions.c:1173
msgid "EXPRESSION:expression in @{cell} as a string"
msgstr "EXPRESSÃO: expressão em @{célula} como cadeia"

#: ../plugins/fn-info/functions.c:1174
msgid "cell:a cell reference"
msgstr "célula: referência de célula"

#: ../plugins/fn-info/functions.c:1175
msgid "If @{cell} contains no expression, EXPRESSION returns empty."
msgstr "Se @{célula} não contiver uma expressão, devolve vazio."

#: ../plugins/fn-info/functions.c:1210
msgid "GET.FORMULA:the formula in @{cell} as a string"
msgstr "OBTER.FÓRMULA: a fórmula em @{célula} como cadeia"

#: ../plugins/fn-info/functions.c:1211 ../plugins/fn-info/functions.c:1253
#: ../plugins/fn-info/functions.c:1816
msgid "cell:the referenced cell"
msgstr "célula: referência de célula"

#: ../plugins/fn-info/functions.c:1212
msgid "GET.FORMULA is the OpenFormula function FORMULA."
msgstr "OBTER.FÓRMULA corresponde à função OpenFormula FÓRMULA."

#: ../plugins/fn-info/functions.c:1213
msgid ""
"If A1 is empty and A2 contains =B1+B2, then\n"
"GET.FORMULA(A2) yields '=B1+B2' and\n"
"GET.FORMULA(A1) yields ''."
msgstr ""
"Se A1 estiver vazia e A2 contiver =B1+B2, então\n"
"GET.FORMULA(A2) devolve '=B1+B2' e\n"
"GET.FORMULA(A1) devolve ''."

#: ../plugins/fn-info/functions.c:1252
msgid "ISFORMULA:TRUE if @{cell} contains a formula"
msgstr "ÉFÓRMULA: VERDADEIRO se @{célula} contiver uma fórmula"

#: ../plugins/fn-info/functions.c:1254
msgid "ISFORMULA is OpenFormula compatible."
msgstr "ÉFÓRMULA é compatível OpenFormula."

#: ../plugins/fn-info/functions.c:1283
msgid "COUNTBLANK:the number of blank cells in @{range}"
msgstr "CONTAR.VAZIO: o número de células vazias no @{intervalo}"

#: ../plugins/fn-info/functions.c:1284
msgid "range:a cell range"
msgstr "intervalo: um intervalo de células"

#: ../plugins/fn-info/functions.c:1286
msgid "COUNTBLANK(A1:A20) returns the number of blank cell in A1:A20."
msgstr "CONTAR.VAZIO(A1:A20) devolve o número de células vazias em A1:A20."

#: ../plugins/fn-info/functions.c:1338
msgid ""
"INFO:information about the current operating environment according to @{type}"
msgstr ""
"INFORMAÇÃO: informação acerca do ambiente de operação atual de acordo com o "
"@{tipo}"

#: ../plugins/fn-info/functions.c:1340
msgid "type:string giving the type of information requested"
msgstr "tipo: cadeia com o tipo de informação pretendida"

#: ../plugins/fn-info/functions.c:1341
msgid ""
"INFO returns information about the current operating environment according "
"to @{type}:\n"
"  memavail     \t\tReturns the amount of memory available, bytes.\n"
"  memused      \tReturns the amount of memory used (bytes).\n"
"  numfile      \t\tReturns the number of active worksheets.\n"
"  osversion    \t\tReturns the operating system version.\n"
"  recalc       \t\tReturns the recalculation mode (automatic).\n"
"  release      \t\tReturns the version of Gnumeric as text.\n"
"  system       \t\tReturns the name of the environment.\n"
"  totmem       \t\tReturns the amount of total memory available."
msgstr ""
"INFO devolve informação sobre o ambiente de trabalho atual de acordo com "
"@{tipo}: \n"
"  memavail \t\tDevolve a quantidade de memória disponível (bytes).\n"
"  memused  \t\tDevolve a quantidade de memória utilizada (bytes).\n"
"  numfile  \t\tDevolve o número de folhas de trabalho ativas.\n"
"  osversion\t\tDevolve a versão do sistema operativo.\n"
"  recalc   \t\tDevolve o modo de recálculo (automático).\n"
"  release  \t\tDevolve como texto a versão do Gnumeric.\n"
"  system   \t\tDevolve o nome do ambiente.\n"
"  totmem   \t\tDevolve a quantidade total de memória disponível."

#: ../plugins/fn-info/functions.c:1438
msgid "ISERROR:TRUE if @{value} is any error value"
msgstr "É.ERRO: VERDADEIRO se @{valor} for um valor de erro"

#: ../plugins/fn-info/functions.c:1439 ../plugins/fn-info/functions.c:1457
#: ../plugins/fn-info/functions.c:1479 ../plugins/fn-info/functions.c:1569
#: ../plugins/fn-info/functions.c:1607 ../plugins/fn-info/functions.c:1625
#: ../plugins/fn-info/functions.c:1642 ../plugins/fn-info/functions.c:1681
#: ../plugins/fn-info/functions.c:1702 ../plugins/fn-info/functions.c:1752
msgid "value:a value"
msgstr "valor: um valor"

#: ../plugins/fn-info/functions.c:1456
msgid "ISNA:TRUE if @{value} is the #N/A error value"
msgstr "É.NÃO.DISP: VERDADEIRO se @{valor} for o valor de erro #N/D!."

#: ../plugins/fn-info/functions.c:1478
msgid "ISERR:TRUE if @{value} is any error value except #N/A"
msgstr ""
"É.ERROS: VERDADEIRO se @{valor} for qualquer valor de erro exceto \"N/D!."

#: ../plugins/fn-info/functions.c:1497
msgid "ERROR.TYPE:the type of @{error}"
msgstr "TIPO.ERRO: o tipo de @{erro}"

#: ../plugins/fn-info/functions.c:1498
msgid "error:an error"
msgstr "erro: um erro"

#: ../plugins/fn-info/functions.c:1499
msgid ""
"ERROR.TYPE returns an error number corresponding to the given error value.  "
"The error numbers for error values are:\n"
"\n"
"\t#DIV/0!  \t\t2\n"
"\t#VALUE!  \t3\n"
"\t#REF!    \t\t4\n"
"\t#NAME?   \t5\n"
"\t#NUM!    \t6\n"
"\t#N/A     \t\t7"
msgstr ""
"TIPO.ERRO devolve um número de erro correspondente ao valor de erro "
"indicado. Os números de erro dos valores de erro são:\n"
"\n"
"\t#DIV/0!  \t\t2\n"
"\t#VALOR!  \t3\n"
"\t#REF!    \t\t4\n"
"\t#NOME?   \t5\n"
"\t#NUM!    \t6\n"
"\t#N/D     \t\t7"

#: ../plugins/fn-info/functions.c:1533
msgid "NA:the error value #N/A"
msgstr "NÃO.DISP: o valor de erro #N/D!."

#: ../plugins/fn-info/functions.c:1551
msgid "ERROR:the error with the given @{name}"
msgstr "ERRO: o erro com o @{nome} indicado"

#: ../plugins/fn-info/functions.c:1552
msgid "name:string"
msgstr "nome: cadeia"

#: ../plugins/fn-info/functions.c:1568
msgid "ISBLANK:TRUE if @{value} is blank"
msgstr "É.CÉL.VAZIA: VERADEIRO se @{valor} estiver vazio"

#: ../plugins/fn-info/functions.c:1570
msgid ""
"This function checks if a value is blank.  Empty cells are blank, but empty "
"strings are not."
msgstr ""
"Esta função verifica se um valor está vazio. Células vazias devolvem "
"VERDADEIRO mas cadeias vazias não."

#: ../plugins/fn-info/functions.c:1585
msgid "ISEVEN:TRUE if @{n} is even"
msgstr "É.PAR: VERDADEIRO se @{n} for par"

#: ../plugins/fn-info/functions.c:1586 ../plugins/fn-info/functions.c:1660
#: ../plugins/fn-math/functions.c:1382
msgid "n:number"
msgstr "n: número"

#: ../plugins/fn-info/functions.c:1606
msgid "ISLOGICAL:TRUE if @{value} is a logical value"
msgstr "É.LÓGICO: VERDADEIRO se @{valor} for um valor lógico"

#: ../plugins/fn-info/functions.c:1608
msgid "This function checks if a value is either TRUE or FALSE."
msgstr "Esta função verifica se um valor é VERDADEIRO ou FALSO."

#: ../plugins/fn-info/functions.c:1624
msgid "ISNONTEXT:TRUE if @{value} is not text"
msgstr "É.NÃO.TEXTO: VERDADEIRO se @{valor} não for texto"

#: ../plugins/fn-info/functions.c:1641
msgid "ISNUMBER:TRUE if @{value} is a number"
msgstr "É.NÚM: VERDADEIRO se @{valor} for um número"

#: ../plugins/fn-info/functions.c:1643
msgid ""
"This function checks if a value is a number.  Neither TRUE nor FALSE are "
"numbers for this purpose."
msgstr ""
"Esta função verifica se um valor é um número. Nem VERDADEIRO nem FALSO são "
"números nesta avaliação."

#: ../plugins/fn-info/functions.c:1659
msgid "ISODD:TRUE if @{n} is odd"
msgstr "ÉÍMPAR: VERDADEIRO se @{n} for ímpar"

#: ../plugins/fn-info/functions.c:1680
msgid "ISREF:TRUE if @{value} is a reference"
msgstr "É.REF: VERDADEIRO se @{valor} for uma referência"

#: ../plugins/fn-info/functions.c:1682
msgid "This function checks if a value is a cell reference."
msgstr "Esta função verifica se um valor é uma referência de célula."

#: ../plugins/fn-info/functions.c:1701
msgid "ISTEXT:TRUE if @{value} is text"
msgstr "É.TEXTO: VERDADEIRO se @{valor} for texto"

#: ../plugins/fn-info/functions.c:1719
msgid "N:@{text} converted to a number"
msgstr "N: @{texto} convertido num número"

#: ../plugins/fn-info/functions.c:1720 ../plugins/fn-string/functions.c:370
#: ../plugins/fn-string/functions.c:586 ../plugins/fn-string/functions.c:726
#: ../plugins/fn-string/functions.c:770 ../plugins/fn-string/functions.c:897
#: ../plugins/fn-string/functions.c:1122 ../plugins/fn-string/functions.c:1169
#: ../plugins/fn-string/functions.c:1202 ../plugins/fn-string/functions.c:1518
msgid "text:string"
msgstr "texto: cadeia"

#: ../plugins/fn-info/functions.c:1721
msgid "If @{text} contains non-numerical text, 0 is returned."
msgstr "Se @{texto} contiver texto não numérico devolve 0."

#: ../plugins/fn-info/functions.c:1724
msgid "=N(\"eleven\")"
msgstr "=N(\"onze\")"

#: ../plugins/fn-info/functions.c:1751
msgid "TYPE:a number indicating the data type of @{value}"
msgstr "TIPO: um número indicando o tipo de dados de @{valor}"

#: ../plugins/fn-info/functions.c:1753
msgid ""
"TYPE returns a number indicating the data type of @{value}:\n"
"1  \t= number\n"
"2  \t= text\n"
"4  \t= boolean\n"
"16 \t= error\n"
"64 \t= array"
msgstr ""
"TYPE returns a number indicating the data type of @{value}:\n"
"1  \t= número\n"
"2  \t= texto\n"
"4  \t= lógico\n"
"16 \t= erro\n"
"64 \t= matriz"

#: ../plugins/fn-info/functions.c:1792
msgid "GETENV:the value of execution environment variable @{name}"
msgstr "OBTER.AMB: o valor da variável de ambiente @{nome}"

#: ../plugins/fn-info/functions.c:1793
msgid "name:the name of the environment variable"
msgstr "nome: o nome da variável de ambiente"

#: ../plugins/fn-info/functions.c:1794
msgid "If a variable called @{name} does not exist, #N/A! will be returned."
msgstr "Se a variável @{nome} não existir, devolve #N/D!."

#: ../plugins/fn-info/functions.c:1795
msgid "Variable names are case sensitive."
msgstr "Nomes de variáveis são sensíveis a maiúsculas."

#: ../plugins/fn-info/functions.c:1815
msgid "GET.LINK:the target of the hyperlink attached to @{cell} as a string"
msgstr ""
"OBTER.LIGAÇÃO:o destino da hiperligação anexada a @{célula} como cadeia"

#: ../plugins/fn-info/functions.c:1817
msgid ""
"The value return is not updated automatically when the link attached to "
"@{cell} changes but requires a recalculation."
msgstr ""
"O valor devolvido não é atualizado automaticamente quando a ligação anexada "
"a @{célula} é alterada, requer um recálculo."

#: ../plugins/fn-logical/functions.c:44
msgid "AND:logical conjunction"
msgstr "E: conjunção lógica"

#: ../plugins/fn-logical/functions.c:45 ../plugins/fn-logical/functions.c:124
#: ../plugins/fn-logical/functions.c:178
msgid "b0:logical value"
msgstr "b0: valor lógico"

#: ../plugins/fn-logical/functions.c:46 ../plugins/fn-logical/functions.c:125
#: ../plugins/fn-logical/functions.c:179
msgid "b1:logical value"
msgstr "b1: valor lógico"

#: ../plugins/fn-logical/functions.c:47
msgid "AND calculates the logical conjunction of its arguments @{b0},@{b1},..."
msgstr "E calcula a conjunção lógica dos seus argumentos @{b0}, @{b1},..."

#: ../plugins/fn-logical/functions.c:48 ../plugins/fn-logical/functions.c:127
#: ../plugins/fn-logical/functions.c:181
msgid ""
"If an argument is numerical, zero is considered FALSE and anything else TRUE."
msgstr ""
"Se um dos argumentos for numérico, zero é considerado FALSO e todos os "
"outros VERDADEIRO."

#: ../plugins/fn-logical/functions.c:49 ../plugins/fn-logical/functions.c:102
#: ../plugins/fn-logical/functions.c:128 ../plugins/fn-logical/functions.c:182
msgid "Strings and empty values are ignored."
msgstr "Cadeias e valores vazios são ignorados."

#: ../plugins/fn-logical/functions.c:50 ../plugins/fn-logical/functions.c:129
#: ../plugins/fn-logical/functions.c:183
msgid "If no logical values are provided, then the error #VALUE! is returned."
msgstr "Se não forem indicados valores lógicos, é devolvido #VALOR!."

#: ../plugins/fn-logical/functions.c:51 ../plugins/fn-logical/functions.c:130
#: ../plugins/fn-logical/functions.c:184
msgid ""
"This function is strict: if any argument is an error, the result will be the "
"first such error."
msgstr ""
"Esta função é estrita: se algum dos argumentos for um erro, o resultado será "
"o primeiro desses erros."

#: ../plugins/fn-logical/functions.c:57
msgid "wiki:en:Logical_conjunction"
msgstr "wiki:pt:Valor_lógico"

#: ../plugins/fn-logical/functions.c:98
msgid "NOT:logical negation"
msgstr "NÃO: negação lógica"

#: ../plugins/fn-logical/functions.c:99
msgid "b:logical value"
msgstr "b valor lógico"

#: ../plugins/fn-logical/functions.c:100
msgid "NOT calculates the logical negation of its argument."
msgstr "NÃO calcula a negação lógica do seu argumento."

#: ../plugins/fn-logical/functions.c:101
msgid ""
"If the argument is numerical, zero is considered FALSE and anything else "
"TRUE."
msgstr ""
"Se o argumento for numérico, zero é considerado FALSO e todos os outros "
"VERDADEIRO."

#: ../plugins/fn-logical/functions.c:107
msgid "wiki:en:Negation"
msgstr "wiki:pt:Valor_lógico"

#: ../plugins/fn-logical/functions.c:123
msgid "OR:logical disjunction"
msgstr "OU: disjunção lógica"

#: ../plugins/fn-logical/functions.c:126
msgid "OR calculates the logical disjunction of its arguments @{b0},@{b1},..."
msgstr "OU calcula a disjunção lógica dos seus argumentos @{b0}, @{b1},..."

#: ../plugins/fn-logical/functions.c:136
msgid "wiki:en:Logical_disjunction"
msgstr "wiki:pt:Valor_lógico"

#: ../plugins/fn-logical/functions.c:177
msgid "XOR:logical exclusive disjunction"
msgstr "OU.EXCLUSIVO: disjunção lógica exclusiva"

#: ../plugins/fn-logical/functions.c:180
msgid ""
"XOR calculates the logical exclusive disjunction of its arguments @{b0},"
"@{b1},..."
msgstr ""
"OU.EXCLUSIVO calcula a disjunção lógica exclusiva dos seus argumentos @{b0}, "
"@{b1},..."

#: ../plugins/fn-logical/functions.c:189
msgid "wiki:en:Exclusive_disjunction"
msgstr "wiki:pt:Valor_lógico"

#: ../plugins/fn-logical/functions.c:230
msgid "IFERROR:test for error"
msgstr "SE.ERRO: testa erros"

#: ../plugins/fn-logical/functions.c:231
msgid "x:value to test for error"
msgstr "x: valor a testar"

#: ../plugins/fn-logical/functions.c:232 ../plugins/fn-logical/functions.c:250
msgid "y:alternate value"
msgstr "y: valor alternativo"

#: ../plugins/fn-logical/functions.c:233
msgid ""
"This function returns the first value, unless that is an error, in which "
"case it returns the second."
msgstr ""
"Esta função devolve o primeiro valor, a não ser que seja erro, caso em que "
"devolve o segundo."

#: ../plugins/fn-logical/functions.c:248
msgid "IFNA:test for #NA! error"
msgstr "SE.NÃO.DISP: testa o erro #N/D!"

#: ../plugins/fn-logical/functions.c:249
msgid "x:value to test for #NA! error"
msgstr "x: valor a testar"

#: ../plugins/fn-logical/functions.c:251
msgid ""
"This function returns the first value, unless that is #NA!, in which case it "
"returns the second."
msgstr ""
"Esta função devolve o primeiro valor, a não ser que seja #N/D!, caso em que "
"devolve o segundo."

#: ../plugins/fn-logical/functions.c:268
msgid "IFS:multi-branch conditional"
msgstr "SES: condicional multi-ramos"

#: ../plugins/fn-logical/functions.c:269
msgid "cond1:condition"
msgstr "cond1: condição"

#: ../plugins/fn-logical/functions.c:270
msgid "value1:value if @{condition1} is true"
msgstr "valor1: valor se @{condição1} for verdadeira"

#: ../plugins/fn-logical/functions.c:271
msgid "cond2:condition"
msgstr "cond1: condição"

#: ../plugins/fn-logical/functions.c:272
msgid "value2:value if @{condition2} is true"
msgstr "valor2: valor se @{condição2} for verdadeira"

#: ../plugins/fn-logical/functions.c:273
msgid ""
"This function returns the value after the first true contional.  If no "
"conditional is true, #VALUE! is returned."
msgstr ""
"Esta função devolve o valor seguinte à primeira condição verdadeira. Se "
"nenhuma condição for verdadeira, é devolvido #VALOR!."

#: ../plugins/fn-logical/functions.c:312
msgid "SWITCH:multi-branch selector"
msgstr "SELETOR: seletor multi-ramos"

#: ../plugins/fn-logical/functions.c:313
msgid "ref:value"
msgstr "ref: valor"

#: ../plugins/fn-logical/functions.c:314
msgid "choice1:first choice value"
msgstr "escolha1: primeiro valor da escolha"

#: ../plugins/fn-logical/functions.c:315
msgid "value1:first result value"
msgstr "valor1: primeiro valor do resultado"

#: ../plugins/fn-logical/functions.c:316
msgid "choice2:second choice value"
msgstr "escolha2: segundo valor da escolha"

#: ../plugins/fn-logical/functions.c:317
msgid "value2:second result value"
msgstr "valor2: segundo valor do resultado"

#: ../plugins/fn-logical/functions.c:318
msgid ""
"This function compares the reference value, @{ref}, against the choice "
"values, @{choice1} etc., and returns the corresponding result value when it "
"finds a match.  The choices may be followed by a default value to use.  If "
"there are no choices that match and no default value, #NA! is return."
msgstr ""
"Esta função compara o valor de referência, @{ref}, com os valores de "
"escolhas, @{escolhas}, etc, e devolve o valor do resultado correspondente "
"quando encontra uma correspondência. As escolhas podem ser seguidas por um "
"valor pré-definido a utilizar. Se não houverem escolhas que correspondam nem "
"nenhum valor pré-definido, é devolvido #NA!"

#: ../plugins/fn-logical/functions.c:371
msgid "TRUE:the value TRUE"
msgstr "VERDADEIRO: o valor verdadeiro"

#: ../plugins/fn-logical/functions.c:372
msgid "TRUE returns the value TRUE."
msgstr "VERDADEIRO devolve o valor VERDADEIRO."

#: ../plugins/fn-logical/functions.c:376 ../plugins/fn-logical/functions.c:394
msgid "wiki:en:Logical_value"
msgstr "wiki:pt:Valor_lógico"

#: ../plugins/fn-logical/functions.c:389
msgid "FALSE:the value FALSE"
msgstr "FALSO: o valor FALSO"

#: ../plugins/fn-logical/functions.c:390
msgid "FALSE returns the value FALSE."
msgstr "FALSO devolve o valor FALSO."

#: ../plugins/fn-lookup/functions.c:808
msgid "ADDRESS:cell address as text"
msgstr "ENDEREÇO: endereço da célula como texto"

#: ../plugins/fn-lookup/functions.c:809
msgid "row_num:row number"
msgstr "num_lin: número da linha"

#: ../plugins/fn-lookup/functions.c:810
msgid "col_num:column number"
msgstr "num_col: número da coluna"

#: ../plugins/fn-lookup/functions.c:811
msgid ""
"abs_num:1 for an absolute, 2 for a row absolute and column relative, 3 for a "
"row relative and column absolute, and 4 for a relative reference; defaults "
"to 1"
msgstr ""
"num_abs: 1 para absoluto, 2 para linha absoluta e coluna relativa, 3 para "
"linha relativa e coluna absoluta e 4 para referência relativa; a "
"predefinição é 1"

#: ../plugins/fn-lookup/functions.c:814
msgid ""
"a1:if TRUE, an A1-style reference is provided, otherwise an R1C1-style "
"reference; defaults to TRUE"
msgstr ""
"a1: se VERDADEIRO, é dada uma referênci de estilo A1, senão é de estilo "
"R1C1; predefinido como VERDADEIRO"

#: ../plugins/fn-lookup/functions.c:816
msgid "text:name of the worksheet, defaults to no sheet"
msgstr "texto: nome da folha, predefinição é sem folha"

#: ../plugins/fn-lookup/functions.c:817
msgid "If @{row_num} or @{col_num} is less than one, ADDRESS returns #VALUE!"
msgstr "Se @{num_lin} ou @{num_col} forem menores que 1, devolve #VALOR!."

#: ../plugins/fn-lookup/functions.c:819
msgid "If @{abs_num} is greater than 4 ADDRESS returns #VALUE!"
msgstr "Se @{num_abs} for maior que 4, devolve #VALOR!."

#: ../plugins/fn-lookup/functions.c:906
msgid "AREAS:number of areas in @{reference}"
msgstr "ÁREAS: número de áreas na @{referência}"

#: ../plugins/fn-lookup/functions.c:907
msgid "reference:range"
msgstr "referência: intervalo"

#: ../plugins/fn-lookup/functions.c:974
msgid "CHOOSE:the (@{index}+1)th argument"
msgstr "ESCOLHER: o (@{índice}+1)º argumento"

#: ../plugins/fn-lookup/functions.c:975
msgid "index:positive number"
msgstr "índice: número positivo"

#: ../plugins/fn-lookup/functions.c:976
msgid "value1:first value"
msgstr "valor1: primeiro valor"

#: ../plugins/fn-lookup/functions.c:977
msgid "value2:second value"
msgstr "valor 2: segundo valor"

#: ../plugins/fn-lookup/functions.c:978
msgid "CHOOSE returns its (@{index}+1)th argument."
msgstr "ESCOLHER devolve o seu (@{índice}+1)º argumento."

#: ../plugins/fn-lookup/functions.c:979
msgid ""
"@{index} is truncated to an integer. If @{index} < 1 or the truncated "
"@{index} > number of values, CHOOSE returns #VALUE!"
msgstr ""
"@{índice} é truncado num inteiro. Se @{índice} < 1 ou @{índice} truncado > "
"que o número de valores, devolve #VALOR!."

#: ../plugins/fn-lookup/functions.c:1021
msgid "VLOOKUP:search the first column of @{range} for @{value}"
msgstr "PROCURA.VERT: procura na primeira coluna do @{intervalo} por @{valor}"

#: ../plugins/fn-lookup/functions.c:1022 ../plugins/fn-lookup/functions.c:1090
msgid "value:search value"
msgstr "valor: valor a procurar"

#: ../plugins/fn-lookup/functions.c:1023 ../plugins/fn-lookup/functions.c:1091
msgid "range:range to search"
msgstr "intervalo: intervalo onde procurar"

#: ../plugins/fn-lookup/functions.c:1024
msgid "column:1-based column offset indicating the return values"
msgstr "coluna: desvio baseado em 1 da coluna, indicando os valores a devolver"

#: ../plugins/fn-lookup/functions.c:1025 ../plugins/fn-lookup/functions.c:1093
msgid ""
"approximate:if false, an exact match of @{value} must be found; defaults to "
"TRUE"
msgstr ""
"aproximado: se FALSO, tem de ser encontrado um valor exato de @{valor}; "
"predefinido como VERDADEIRO"

#: ../plugins/fn-lookup/functions.c:1027
msgid "as_index:if true, the 0-based row offset is returned; defaults to FALSE"
msgstr ""
"como_índice: se VERDADEIRO, é devolvido o desvio baseado em 0 da coluna; "
"predefinido como FALSO"

#: ../plugins/fn-lookup/functions.c:1029
msgid ""
"VLOOKUP function finds the row in @{range} that has a first cell similar to "
"@{value}.  If @{approximate} is not true it finds the row with an exact "
"equality. If @{approximate} is true, it finds the last row with first value "
"less than or equal to @{value}. If @{as_index} is true the 0-based row "
"offset is returned."
msgstr ""
"A função PROCURA.VERT encontra a linha no @{intervalo} que tenha uma "
"primeira célula semelhante a @{valor}. Se @{aproximado não for VERDADEIRO, "
"procura a linha com o valor exato. Se não, procura a última linha com um "
"valor menor que ou igual a @{valor}. Se @{como_índice} for VERDADEIRO é "
"devolvido o valor de linha com desvio 0."

#: ../plugins/fn-lookup/functions.c:1036 ../plugins/fn-lookup/functions.c:1104
msgid ""
"If @{approximate} is true, then the values must be sorted in order of "
"ascending value."
msgstr ""
"Se @{aproximado} for VERDADEIRO, os valores devem ser ordenados em ordem "
"ascendente de valor."

#: ../plugins/fn-lookup/functions.c:1038
msgid "VLOOKUP returns #REF! if @{column} falls outside @{range}."
msgstr "PROCURA.VERT devolve #REF! se @{coluna} estiver fora do @{intervalo}."

#: ../plugins/fn-lookup/functions.c:1089
msgid "HLOOKUP:search the first row of @{range} for @{value}"
msgstr "PROCURA.HORIZ: procura na primeira linha do @{intervalo} por @{valor}"

#: ../plugins/fn-lookup/functions.c:1092
msgid "row:1-based row offset indicating the return values "
msgstr "linha: desvio baseado em 1 da linha, indicando os valores a devolver"

#: ../plugins/fn-lookup/functions.c:1095
msgid ""
"as_index:if true, the 0-based column offset is returned; defaults to FALSE"
msgstr ""
"como_índice: se VERDADEIRO, é devolvido o desvio baseado em 0 da coluna; "
"predefinido como FALSO"

#: ../plugins/fn-lookup/functions.c:1097
msgid ""
"HLOOKUP function finds the row in @{range} that has a first cell similar to "
"@{value}.  If @{approximate} is not true it finds the column with an exact "
"equality. If @{approximate} is true, it finds the last column with first "
"value less than or equal to @{value}. If @{as_index} is true the 0-based "
"column offset is returned."
msgstr ""
"A função PROCURA.HORIZ encontra a linha no @{intervalo} que tenha uma "
"primeira célula semelhante a @{valor}. Se @{aproximado não for VERDADEIRO, "
"procura a coluna com o valor exato. Se não, procura a última coluna com um "
"valor menor que ou igual a @{valor}. Se @{como_índice} for VERDADEIRO é "
"devolvido o valor de coluna com desvio 0."

#: ../plugins/fn-lookup/functions.c:1106
msgid "HLOOKUP returns #REF! if @{row} falls outside @{range}."
msgstr "PROCURA.HORIZ devolve #REF! se @{linha} estiver fora do @{intervalo}."

#: ../plugins/fn-lookup/functions.c:1157
msgid ""
"LOOKUP:contents of @{vector2} at the corresponding location to @{value} in "
"@{vector1}"
msgstr ""
"PROCURA: conteúdo de @{vetor2} na correspondente localização de @{valor} no "
"@{vetor1}"

#: ../plugins/fn-lookup/functions.c:1159
msgid "value:value to look up"
msgstr "valor: valor a procurar"

#: ../plugins/fn-lookup/functions.c:1160
msgid "vector1:range to search:"
msgstr "vetor1: intervalo a procurar"

#: ../plugins/fn-lookup/functions.c:1161
msgid "vector2:range of return values"
msgstr "vetor2: intervalo de valores a devolver"

#: ../plugins/fn-lookup/functions.c:1162
msgid ""
"If  @{vector1} has more rows than columns, LOOKUP searches the first row of "
"@{vector1}, otherwise the first column. If @{vector2} is omitted the return "
"value is taken from the last row or column of @{vector1}."
msgstr ""
"Se @{vetor1} tiver mais linhas que colunas, PROCURA procura na primeira "
"linha de @{vetor1}, senão na primeira coluna. Se @{vetor2} for omitido, o "
"valor devolvido é obtido da última linha ou coluna de {vetor1}."

#: ../plugins/fn-lookup/functions.c:1166
msgid ""
"If LOOKUP can't find @{value} it uses the largest value less than @{value}."
msgstr ""
"Se PROCURA não encontrar @{valor}, usará o maior valor menor que @{valor}."

#: ../plugins/fn-lookup/functions.c:1168
msgid "The data must be sorted."
msgstr "Os dados têm de estar ordenados."

#: ../plugins/fn-lookup/functions.c:1169
msgid "If @{value} is smaller than the first value it returns #N/A."
msgstr "Se @{valor} for menor que o primeiro valor, devolve #N/D!."

#: ../plugins/fn-lookup/functions.c:1170
msgid ""
"If the corresponding location does not exist in @{vector2}, it returns #N/A."
msgstr ""
"Se a localização correspondente não existir em @{vetor2}, devolve #N/D!."

#: ../plugins/fn-lookup/functions.c:1257
msgid "MATCH:the index of @{seek} in @{vector}"
msgstr "CORRESP: o índice de @{procura} em @{vetor}"

#: ../plugins/fn-lookup/functions.c:1258
msgid "seek:value to find"
msgstr "procura: o valor a procurar"

#: ../plugins/fn-lookup/functions.c:1259
msgid "vector:n by 1 or 1 by n range to be searched"
msgstr "vetor: intervalo n por 1 ou 1 por n onde procurar"

#: ../plugins/fn-lookup/functions.c:1260
msgid ""
"type:+1 (the default) to find the largest value ≤ @{seek}, 0 to find the "
"first value = @{seek}, or-1 to find the smallest value ≥ @{seek}"
msgstr ""
"tipo: +1 (predefinição) para procurar o maior valor ≤ @{procura}, 0 para "
"procurar o primeiro valor = @{procura} ou-1 para procurar o menor valor ≥ "
"@{procura}"

#: ../plugins/fn-lookup/functions.c:1263
msgid "MATCH searches @{vector} for @{seek} and returns the 1-based index."
msgstr "CORRESP procura em @{vetor} por @{procura} e devolve o índice 1."

#: ../plugins/fn-lookup/functions.c:1264
msgid ""
" For @{type} = -1 the data must be sorted in descending order; for @{type} = "
"+1 the data must be sorted in ascending order."
msgstr ""
"Para @{tipo} = 1, os dados têm de estar em ordem descendente; para @{tipo} = "
"-1, têm de estar em ordem ascendente."

#: ../plugins/fn-lookup/functions.c:1266
msgid "If @{seek} could not be found, #N/A is returned."
msgstr "Se @{procura} não for encontrada, devolve #N/D!."

#: ../plugins/fn-lookup/functions.c:1267
msgid "If @{vector} is neither n by 1 nor 1 by n, #N/A is returned."
msgstr "Se @{vetor} não for nem n por 1 nem 1 por n, devolve #N/D!."

#: ../plugins/fn-lookup/functions.c:1311
msgid "INDIRECT:contents of the cell pointed to by the @{ref_text} string"
msgstr "INDIRETO: conteúdo da célula apontada por @{ref_texto}"

#: ../plugins/fn-lookup/functions.c:1312
msgid "ref_text:textual reference"
msgstr "ref_texto: referência textual"

#: ../plugins/fn-lookup/functions.c:1313
msgid ""
"format:if true, @{ref_text} is given in A1-style, otherwise it is given in "
"R1C1 style; defaults to true"
msgstr ""
"formato: se VERDADEIRO, @{ref_texto} é dada em estilo A1, senão é dada em "
"estilo R1C1; predefinido como VERDADEIRO"

#: ../plugins/fn-lookup/functions.c:1315
msgid ""
"If @{ref_text} is not a valid reference in the style determined by "
"@{format}, INDIRECT returns #REF!"
msgstr ""
"Se @{ref_texto} não for uma referência válida no estilo determinado por "
"@{formato}, devolve #REF!."

#: ../plugins/fn-lookup/functions.c:1349
msgid "INDEX:reference to a cell in the given @{array}"
msgstr "ÍNDICE: referência a uma célula na @{matriz} indicada"

#: ../plugins/fn-lookup/functions.c:1350
msgid "array:cell or inline array"
msgstr "matriz: célula ou matriz em linha"

#: ../plugins/fn-lookup/functions.c:1351
msgid "row:desired row, defaults to 1"
msgstr "linha: linha desejada, predefinida como 1"

#: ../plugins/fn-lookup/functions.c:1352
msgid "col:desired column, defaults to 1"
msgstr "coluna: coluna desejada, predefinida como 1"

#: ../plugins/fn-lookup/functions.c:1353
msgid "area:from which area to select a cell, defaults to 1"
msgstr "área: de que área selecionar uma célula, predefinida como 1"

#: ../plugins/fn-lookup/functions.c:1354
msgid ""
"INDEX gives a reference to a cell in the given @{array}. The cell is "
"selected by @{row} and @{col}, which count the rows and columns in the array."
msgstr ""
"ÍNDICE dá uma referência a uma célula na @{matriz}indicada. A célula é "
"selecionada por @{linha} e @{coluna}, o que conta as linhas e colunas na "
"matriz."

#: ../plugins/fn-lookup/functions.c:1359
msgid ""
"If the reference falls outside the range of @{array}, INDEX returns #REF!"
msgstr "Se a referência estiver fora da @{matriz}, devolve #REF!."

#: ../plugins/fn-lookup/functions.c:1361
msgid ""
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
"21.3, 25.9, and 40.1. Then INDEX(A1:A5,4,1,1) equals 25.9"
msgstr ""
"Vamos presumir que as células A1, A2, ..., A5 contêm os números 11,4, 17,3, "
"21,3 25,9 e 40,1. Assim, ÍNDICE(A1:A5,4,1,1) é igual a 25,9"

#: ../plugins/fn-lookup/functions.c:1450
msgid "COLUMN:vector of column numbers"
msgstr "COLUNA: vetor de números de coluna"

#: ../plugins/fn-lookup/functions.c:1451 ../plugins/fn-lookup/functions.c:1603
msgid "x:reference, defaults to the position of the current expression"
msgstr "x: referência, predefinida como a posição da expressão atual"

#: ../plugins/fn-lookup/functions.c:1452
msgid ""
"COLUMN function returns a Nx1 array containing the sequence of integers from "
"the first column to the last column of @{x}."
msgstr ""
"A função COLUNA devolve uma matriz Nx1 contendo a sequência de inteiros "
"desde a primeira até à última coluna de @{x}."

#: ../plugins/fn-lookup/functions.c:1455 ../plugins/fn-lookup/functions.c:1607
msgid ""
"If @{x} is neither an array nor a reference nor a range, returns #VALUE!"
msgstr ""
"Se @{x} nao for uma matriz, uma referência ou um intervalo, devolve #VALOR!."

#: ../plugins/fn-lookup/functions.c:1459
msgid "column() in G13 equals 7."
msgstr "COLUNA() em G13 é igual a 7."

#: ../plugins/fn-lookup/functions.c:1499
msgid "COLUMNNUMBER:column number for the given column called @{name}"
msgstr "NÚM.COLUNA: número de coluna para a coluna indicada chamada @{nome}"

#: ../plugins/fn-lookup/functions.c:1500
msgid "name:column name such as \"IV\""
msgstr "nome: nome da coluna, tal como \"IV\""

#: ../plugins/fn-lookup/functions.c:1501
msgid "If @{name} is invalid, COLUMNNUMBER returns #VALUE!"
msgstr "Se @{nome} for inválido, devolve #VALOR!."

#: ../plugins/fn-lookup/functions.c:1526
msgid "COLUMNS:number of columns in @{reference}"
msgstr "COLUNAS: número de colunas em @{referência}"

#: ../plugins/fn-lookup/functions.c:1527
msgid "reference:array or area"
msgstr "referência: matriz ou área"

#: ../plugins/fn-lookup/functions.c:1528
msgid ""
"If @{reference} is neither an array nor a reference nor a range, COLUMNS "
"returns #VALUE!"
msgstr "Se @{referência} não for nem matriz nem área, devolve #VALOR!."

#: ../plugins/fn-lookup/functions.c:1544
msgid "OFFSET:an offset cell range"
msgstr "DESVIO: um desvio de intervalo de células"

#: ../plugins/fn-lookup/functions.c:1545
msgid "range:reference or range"
msgstr "intervalo: referência ou intervalo"

#: ../plugins/fn-lookup/functions.c:1546
msgid "row:number of rows to offset @{range}"
msgstr "linha: número de linhas a desviar @intervalo}"

#: ../plugins/fn-lookup/functions.c:1547
msgid "col:number of columns to offset @{range}"
msgstr "coluna: número de colunas a desviar @{intervalo}"

#: ../plugins/fn-lookup/functions.c:1548
msgid "height:height of the offset range, defaults to height of @{range}"
msgstr ""
"altura: altura do intervalo desviado, predefinido para a altura de "
"@{intervalo}"

#: ../plugins/fn-lookup/functions.c:1549
msgid "width:width of the offset range, defaults to width of @{range}"
msgstr ""
"largura: largura do intervalo desviado, predefinido para a largura de "
"@{intervalo}"

#: ../plugins/fn-lookup/functions.c:1550
msgid ""
"OFFSET returns the cell range starting at offset (@{row},@{col}) from "
"@{range} of height @{height} and width @{width}."
msgstr ""
"DESVIO devolve o intervalo de células começado no desvio (@{linha},"
"@{coluna}) de @{intervalo}, de altura @{altura} e largura @{largura}."

#: ../plugins/fn-lookup/functions.c:1553
msgid "If @{range} is neither a reference nor a range, OFFSET returns #VALUE!"
msgstr ""
"Se @{intervalo não for nem uma referência nem um intervalo, devolve #VALOR!."

#: ../plugins/fn-lookup/functions.c:1602
msgid "ROW:vector of row numbers"
msgstr "LINHA: vetor de números de linha"

#: ../plugins/fn-lookup/functions.c:1604
msgid ""
"ROW function returns a 1xN array containing the sequence of integers from "
"the first row to the last row of @{x}."
msgstr ""
"A função LINHA devolve uma matriz 1xN contendo a sequência de inteiros desde "
"a primeira até à última linha de @{x}."

#: ../plugins/fn-lookup/functions.c:1650
msgid "ROWS:number of rows in @{reference}"
msgstr "LINHAS: número de linhas em @{referência}"

#: ../plugins/fn-lookup/functions.c:1651
msgid "reference:array, reference, or range"
msgstr "referência: matriz, referência ou intervalo"

#: ../plugins/fn-lookup/functions.c:1652
msgid ""
"If @{reference} is neither an array nor a reference nor a range, ROWS "
"returns #VALUE!"
msgstr ""
"Se @{referência} não for matriz, referência ou intervalo, devolve #VALOR!."

#: ../plugins/fn-lookup/functions.c:1668
msgid "SHEETS:number of sheets in @{reference}"
msgstr "FOLHAS: número de folhas em @{referência}"

#: ../plugins/fn-lookup/functions.c:1669
msgid "reference:array, reference, or range, defaults to the maximum range"
msgstr ""
"referência: matriz, referência ou intervalo, predefinido para o intervalo "
"máximo"

#: ../plugins/fn-lookup/functions.c:1670
msgid ""
"If @{reference} is neither an array nor a reference nor a range, SHEETS "
"returns #VALUE!"
msgstr ""
"Se @{referência} não for matriz, referência ou intervalo, devolve #VALOR!."

#: ../plugins/fn-lookup/functions.c:1706
msgid "SHEET:sheet number of @{reference}"
msgstr "FOLHA: número da folha de @{referência}"

#: ../plugins/fn-lookup/functions.c:1707
msgid ""
"reference:reference or literal sheet name, defaults to the current sheet"
msgstr ""
"referência: referência ou nome literal da folha, predefinida para a folha "
"atual"

#: ../plugins/fn-lookup/functions.c:1708
msgid ""
"If @{reference} is neither a reference nor a literal sheet name, SHEET "
"returns #VALUE!"
msgstr ""
"Se @{referência} não for referência ou nome literal de folha, devolve "
"#VALOR!."

#: ../plugins/fn-lookup/functions.c:1754
msgid "HYPERLINK:second or first arguments"
msgstr "HIPERLIGAÇÃO: segundo ou primeiro argumentos"

#: ../plugins/fn-lookup/functions.c:1755
msgid "link_location:string"
msgstr "local_ligação: cadeia"

#: ../plugins/fn-lookup/functions.c:1756
msgid "label:string, optional"
msgstr "rótulo: cadeia, opcional"

#: ../plugins/fn-lookup/functions.c:1757
msgid ""
"HYPERLINK function currently returns its 2nd argument, or if that is omitted "
"the 1st argument."
msgstr ""
"A função HIPERLIGAÇÃO atualmente devolve o seu segundo argumento ou, se esse "
"for omitido, o seu primeiro argumento."

#: ../plugins/fn-lookup/functions.c:1776
msgid "TRANSPOSE:the transpose of @{matrix}"
msgstr "TRANSPOR: a transposição de @{matriz}"

#: ../plugins/fn-lookup/functions.c:1777 ../plugins/fn-lookup/functions.c:1815
msgid "matrix:range"
msgstr "matriz: intervalo"

#: ../plugins/fn-lookup/functions.c:1814
msgid "FLIP:@{matrix} flipped"
msgstr "INVERTER: @{matriz} invertida"

#: ../plugins/fn-lookup/functions.c:1816
msgid ""
"vertical:if true, @{matrix} is flipped vertically, otherwise horizontally; "
"defaults to TRUE"
msgstr ""
"vertical: se VERDADEIRO, @{matriz} é invertida na vertical, senão é "
"invertida na horizontal; predefinido como VERDADEIRO"

#: ../plugins/fn-lookup/functions.c:1861
msgid "ARRAY:vertical array of the arguments"
msgstr "MATRIZ: matriz vertical de argumentos"

#: ../plugins/fn-lookup/functions.c:1862
msgid "v:value"
msgstr "v: valor"

#: ../plugins/fn-lookup/functions.c:1918
msgid "SORT:sorted list of numbers as vertical array"
msgstr "ORDENAR: lista de números ordenados como matriz vertical"

#: ../plugins/fn-lookup/functions.c:1919 ../plugins/fn-stat/functions.c:162
#: ../plugins/fn-stat/functions.c:214
msgid "ref:list of numbers"
msgstr "ref: lista de números"

#: ../plugins/fn-lookup/functions.c:1920
msgid "order:0 (descending order) or 1 (ascending order); defaults to 0"
msgstr "ordem: 0 (descendente) ou 1 (ascendente); predefinida para 0"

#: ../plugins/fn-lookup/functions.c:1921
msgid "Strings, booleans, and empty cells are ignored."
msgstr "Cadeias, valores lógicos e células vazias são ignorados."

#: ../plugins/fn-lookup/functions.c:1922
msgid "SORT({4,3,5}) evaluates to {5,4,3}"
msgstr "SORT({4,3,5}) devolve ({5,4,3})"

#: ../plugins/fn-math/functions.c:53
msgid ""
"Numbers, text and logical values are included in the calculation too. If the "
"cell contains text or the argument evaluates to FALSE, it is counted as "
"value zero (0). If the argument evaluates to TRUE, it is counted as one (1)."
msgstr ""
"Números, texto e valores lógicos também são incluídos no cálculo. Se a "
"célula contém texto ou o argumento é avaliado como FALSO, é contado como "
"valor zero (0). Se o argumentofor avaliado como VERDADEIRO, é contado como "
"um (1)."

#: ../plugins/fn-math/functions.c:190
msgid "GCD:the greatest common divisor"
msgstr "MDC: máximo divisor comum"

#: ../plugins/fn-math/functions.c:191 ../plugins/fn-math/functions.c:254
msgid "n0:positive integer"
msgstr "n0: inteiro positivo"

#: ../plugins/fn-math/functions.c:192 ../plugins/fn-math/functions.c:255
msgid "n1:positive integer"
msgstr "n1: inteiro positivo"

#: ../plugins/fn-math/functions.c:193
msgid ""
"GCD calculates the greatest common divisor of the given numbers @{n0},"
"@{n1},..., the greatest integer that is a divisor of each argument."
msgstr ""
"MDC calcula o máximo doivosor comum dos números indicados, @{n0}, "
"@{n1}, ..., o maior inteiro que é divisor de cada argumento."

#: ../plugins/fn-math/functions.c:194 ../plugins/fn-math/functions.c:257
msgid "If any of the arguments is not an integer, it is truncated."
msgstr "Se algum dos argumentos não for um inteiro, é truncado."

#: ../plugins/fn-math/functions.c:253
msgid "LCM:the least common multiple"
msgstr "MMC: o mínimo múltiplo comum"

#: ../plugins/fn-math/functions.c:256
msgid ""
"LCM calculates the least common multiple of the given numbers @{n0},"
"@{n1},..., the smallest integer that is a multiple of each argument."
msgstr ""
"MMC calcula o mínimo múltiplo comum dos números indicados @{n0}, @{n1}, ..., "
"o menor inteiro que é múltiplo de cada argumento."

#: ../plugins/fn-math/functions.c:309
msgid "GD:Gudermannian function"
msgstr "GD:função de Gudermannian"

#: ../plugins/fn-math/functions.c:310 ../plugins/fn-math/functions.c:421
#: ../plugins/fn-stat/functions.c:1906
msgid "x:value"
msgstr "x: valor"

#: ../plugins/fn-math/functions.c:313
msgid "wolfram:Gudermannian.html"
msgstr "wolfram: Gudermannian.html"

#: ../plugins/fn-math/functions.c:314
msgid "wiki:en:Gudermannian_function"
msgstr "wiki:pt:Função_gudermanniana"

#: ../plugins/fn-math/functions.c:333
msgid "HYPOT:the square root of the sum of the squares of the arguments"
msgstr "HIPOT: a raiz quadrada da soma dos quadrados dos argumentos"

#: ../plugins/fn-math/functions.c:334
msgid "n0:number"
msgstr "n0: número"

#: ../plugins/fn-math/functions.c:335
msgid "n1:number"
msgstr "n1: número"

#: ../plugins/fn-math/functions.c:356
msgid "ABS:absolute value"
msgstr "ABS: valor absoluto"

#: ../plugins/fn-math/functions.c:358
msgid ""
"ABS gives the absolute value of @{x}, i.e. the non-negative number of the "
"same magnitude as @{x}."
msgstr ""
"ABS devolve o valor absoluto de @{x}, i.e. o número não negativo da mesma "
"magnitude de @{x}."

#: ../plugins/fn-math/functions.c:375
msgid "ACOS:the arc cosine of @{x}"
msgstr "ACOS: o arco cosseno de @{x}"

#: ../plugins/fn-math/functions.c:397
msgid "ACOSH:the hyperbolic arc cosine of @{x}"
msgstr "ACOSH: o arco cosseno hiperbólico de @{x}"

#: ../plugins/fn-math/functions.c:420
msgid "ACOT:inverse cotangent of @{x}"
msgstr "ACOT: cotangente inversa de @{x}"

#: ../plugins/fn-math/functions.c:424
msgid "wolfram:InverseCotangent.html"
msgstr "wolfram:InverseCotangent.html"

#: ../plugins/fn-math/functions.c:425 ../plugins/fn-math/functions.c:834
#: ../plugins/fn-math/functions.c:890 ../plugins/fn-math/functions.c:1515
#: ../plugins/fn-math/functions.c:1552 ../plugins/fn-math/functions.c:1592
msgid "wiki:en:Trigonometric_functions"
msgstr "wiki:pt:Função_trigonométrica"

#: ../plugins/fn-math/functions.c:438
msgid "ACOTH:the inverse hyperbolic cotangent of @{x}"
msgstr "ACOTH: a cotangente inversa hiperbólica de @{x}"

#: ../plugins/fn-math/functions.c:442
msgid "wolfram:InverseHyperbolicCotangent.html"
msgstr "wolfram:InverseHyperbolicCotangent.html"

#: ../plugins/fn-math/functions.c:443
msgid "wiki:en:Inverse_hyperbolic_function"
msgstr "wiki:pt:Função_hiperbólica_inversa"

#: ../plugins/fn-math/functions.c:456
msgid "ASIN:the arc sine of @{x}"
msgstr "ASEN: o arco seno de @{x}"

#: ../plugins/fn-math/functions.c:458
msgid ""
"ASIN calculates the arc sine of @{x}; that is the value whose sine is @{x}."
msgstr "ASEN calcula o arco seno de @{x}; este é o valor cujo seno é @{x}."

#: ../plugins/fn-math/functions.c:460
msgid "If @{x} falls outside the range -1 to 1, ASIN returns #NUM!"
msgstr "Se @{x} sair fora do intervalo -1 a 1, devolve #NUM!."

#: ../plugins/fn-math/functions.c:482
msgid "ASINH:the inverse hyperbolic sine of @{x}"
msgstr "ASENH: o seno inverso hiperbólico de @{x}"

#: ../plugins/fn-math/functions.c:484
msgid ""
"ASINH calculates the inverse hyperbolic sine of @{x}; that is the value "
"whose hyperbolic sine is @{x}."
msgstr ""
"ASENH calcula o seno inverso hiperbólico de @{x}; este é o valor cujo seno "
"hiperbólico é @{x}."

#: ../plugins/fn-math/functions.c:501
msgid "ATAN:the arc tangent of @{x}"
msgstr "ATAN: o arco tangente de @{x}"

#: ../plugins/fn-math/functions.c:503
msgid ""
"ATAN calculates the arc tangent of @{x}; that is the value whose tangent is "
"@{x}."
msgstr ""
"ATAN calcula o arco tangente de @{x}; este é o valor cuja tangente é @{x}."

#: ../plugins/fn-math/functions.c:506
msgid "The result will be between −π/2 and +π/2."
msgstr "O resultado estará entre -n/2 e +n/2."

#: ../plugins/fn-math/functions.c:525
msgid "ATANH:the inverse hyperbolic tangent of @{x}"
msgstr "ATANH: a tangente inversa hiperbólica de @{x}"

#: ../plugins/fn-math/functions.c:527
msgid ""
"ATANH calculates the inverse hyperbolic tangent of @{x}; that is the value "
"whose hyperbolic tangent is @{x}."
msgstr ""
"ATANH calcula a tangente inversa hiperbólica de @{x}; este é o valor cuja "
"tangente hiperbólica é @{x}."

#: ../plugins/fn-math/functions.c:529
msgid "If the absolute value of @{x} is greater than 1.0, ATANH returns #NUM!"
msgstr "Se o valor absoluto de @{x} for maior que 1, devolve #NUM!."

#: ../plugins/fn-math/functions.c:550
msgid "ATAN2:the arc tangent of the ratio @{y}/@{x}"
msgstr "ATAN2:o arco tangente da proporção @{y}/@{x}"

#: ../plugins/fn-math/functions.c:552
msgid "x:x-coordinate"
msgstr "x: coordenada x"

#: ../plugins/fn-math/functions.c:553
msgid "y:y-coordinate"
msgstr "y: coordenada y"

#: ../plugins/fn-math/functions.c:554
msgid ""
"ATAN2 calculates the direction from the origin to the point (@{x},@{y}) as "
"an angle from the x-axis in radians."
msgstr ""
"ATAN2 calcula a direção da origem até ao ponto (@{x},@{y}) como um ângulo do "
"eixo x em radianos."

#: ../plugins/fn-math/functions.c:558
msgid "The result will be between −π and +π."
msgstr "O resultado estará entre -n e +n."

#: ../plugins/fn-math/functions.c:561
msgid "The order of the arguments may be unexpected."
msgstr "A ordem dos argumentos pode ser inesperada."

#: ../plugins/fn-math/functions.c:585
msgid "AGM:the arithmetic-geometric mean"
msgstr "AGM: média aritmética-geométrica"

#: ../plugins/fn-math/functions.c:586
msgid "a:value"
msgstr "a: valor"

#: ../plugins/fn-math/functions.c:587
msgid "b:value"
msgstr "b: valor"

#: ../plugins/fn-math/functions.c:588
msgid "AGM computes the arithmetic-geometric mean of the two values."
msgstr "AGM computa a média aritmética-geométrica de dois valores."

#: ../plugins/fn-math/functions.c:607
msgid "CEIL:smallest integer larger than or equal to @{x}"
msgstr "ARRED.EXCESSO: o menor inteiro maior ou igual a @{x}"

#: ../plugins/fn-math/functions.c:609
msgid "CEIL(@{x}) is the smallest integer that is at least as large as @{x}."
msgstr ""
"ARRED.EXCESSO(@{x}) é o menor inteiro que é pelo menos tão grande como @{x}."

#: ../plugins/fn-math/functions.c:610
msgid "This function is the OpenFormula function CEILING(@{x})."
msgstr "Esta função é a função OpenFormula CEILING(@{x})."

#: ../plugins/fn-math/functions.c:627
msgid "COUNTIF:count of the cells meeting the given @{criteria}"
msgstr "CONTAR.SE: contagem de células que cumprem o mesmo @{critério}"

#: ../plugins/fn-math/functions.c:628 ../plugins/fn-math/functions.c:652
#: ../plugins/fn-math/functions.c:671 ../plugins/fn-math/functions.c:717
msgid "range:cell area"
msgstr "intervalo: área de células"

#: ../plugins/fn-math/functions.c:629 ../plugins/fn-math/functions.c:653
msgid "criteria:condition for a cell to be counted"
msgstr "critério: condição para que uma célula seja contada"

#: ../plugins/fn-math/functions.c:651
msgid "COUNTIFS:count of the cells meeting the given @{criteria}"
msgstr "CONTAR.SE: contagem de células que cumprem o @{critério}"

#: ../plugins/fn-math/functions.c:670
msgid ""
"SUMIF:sum of the cells in @{actual_range} for which the corresponding cells "
"in the range meet the given @{criteria}"
msgstr ""
"SOMA.SE: soma das células em @{int_atual} em que as células correspondentes "
"no intervalo cumprem com o @{critério}"

#: ../plugins/fn-math/functions.c:672
msgid "criteria:condition for a cell to be summed"
msgstr "critério: condição para que uma célula seja somada"

#: ../plugins/fn-math/functions.c:673 ../plugins/fn-math/functions.c:719
msgid "actual_range:cell area, defaults to @{range}"
msgstr "int_atual: área de células, predefinida como @{intervalo}"

#: ../plugins/fn-math/functions.c:674
msgid ""
"If the @{actual_range} has a size that differs from the size of @{range}, "
"@{actual_range} is resized (retaining the top-left corner) to match the size "
"of @{range}."
msgstr ""
"Se @{int_atual} tiver um tamanho que difere do tamanho de @{intervalo}, "
"@{int_atual} será redimensionado (mantendo o canto superior esquerdo) para o "
"mesmo tamanho de @{intervalo}."

#: ../plugins/fn-math/functions.c:696
msgid ""
"SUMIFS:sum of the cells in @{actual_range} for which the corresponding cells "
"in the range meet the given criteria"
msgstr ""
"SOMA.SE: soma das células em @{interv_atual} em que as células "
"correspondentes no intervalo cumprem com o critério"

#: ../plugins/fn-math/functions.c:697 ../plugins/fn-math/functions.c:738
#: ../plugins/fn-math/functions.c:758 ../plugins/fn-math/functions.c:778
msgid "actual_range:cell area"
msgstr "intervalo_atual: área de células"

#: ../plugins/fn-math/functions.c:698 ../plugins/fn-math/functions.c:739
#: ../plugins/fn-math/functions.c:759 ../plugins/fn-math/functions.c:779
msgid "range1:cell area"
msgstr "intervalo1: área de células"

#: ../plugins/fn-math/functions.c:699 ../plugins/fn-math/functions.c:740
#: ../plugins/fn-math/functions.c:760 ../plugins/fn-math/functions.c:780
msgid "criteria1:condition for a cell to be included"
msgstr "critério1: condição para que uma célula seja incluída"

#: ../plugins/fn-math/functions.c:716
msgid ""
"AVERAGEIF:average of the cells in @{actual range} for which the "
"corresponding cells in the range meet the given @{criteria}"
msgstr ""
"MÉDIA.SE: média das células em @{int_atual} em que as células "
"correspondentes no intervalo cumprem com o @{critério}"

#: ../plugins/fn-math/functions.c:718
msgid "criteria:condition for a cell to be included"
msgstr "critério: condição para que uma célula seja incluída"

#: ../plugins/fn-math/functions.c:737
msgid ""
"AVERAGEIFS:average of the cells in @{actual_range} for which the "
"corresponding cells in the range meet the given criteria"
msgstr ""
"MÉDIA.SE: média das células em @{int_atual} em que as células "
"correspondentes no intervalo cumprem com o critério"

#: ../plugins/fn-math/functions.c:757
msgid ""
"MINIFS:minimum of the cells in @{actual_range} for which the corresponding "
"cells in the range meet the given criteria"
msgstr ""
"MINIMO.SE: soma das células em @{int_atual} em que as células "
"correspondentes no intervalo cumprem com o critério"

#: ../plugins/fn-math/functions.c:777
msgid ""
"MAXIFS:maximum of the cells in @{actual_range} for which the corresponding "
"cells in the range meet the given criteria"
msgstr ""
"MAXIMO.SE: soma das células em @{int_atual} em que as células "
"correspondentes no intervalo cumprem com o critério"

#: ../plugins/fn-math/functions.c:797
msgid ""
"CEILING:nearest multiple of @{significance} whose absolute value is at least "
"ABS(@{x})"
msgstr ""
"TETO: o mais próximo múltiplo de @{significância} cujo valor absoluto seja "
"pelo menos ABS(@{x})"

#: ../plugins/fn-math/functions.c:799 ../plugins/fn-math/functions.c:1198
msgid ""
"significance:base multiple (defaults to 1 for @{x} > 0 and -1 for @{x} < 0)"
msgstr ""
"significance:múltiplo base (predefinição 1 para @{x} > 0 e -1 para @{x} <0)"

#: ../plugins/fn-math/functions.c:800
msgid ""
"CEILING(@{x},@{significance}) is the nearest multiple of @{significance} "
"whose absolute value is at least ABS(@{x})."
msgstr ""
"TETO(@{x},@{significância}) é o múltiplo mais próximo de @{significância} "
"cujo valor absoluto é pelo menos ABS(@{x})."

#: ../plugins/fn-math/functions.c:801
msgid ""
"If @{x} or @{significance} is non-numeric, CEILING returns a #VALUE! error."
msgstr "Se @{x} ou @{significância} não forem numéricos, devolve #VALOR!."

#: ../plugins/fn-math/functions.c:802
msgid ""
"If @{x} and @{significance} have different signs, CEILING returns a #NUM! "
"error."
msgstr "Se @{x} ou @{significância} tiverem sinais diferentes, devolve #NUM!."

#: ../plugins/fn-math/functions.c:804
msgid ""
"CEILING(@{x}) is exported to ODF as CEILING(@{x},SIGN(@{x}),1). CEILING(@{x},"
"@{significance}) is the OpenFormula function CEILING(@{x},@{significance},1)."
msgstr ""
"TETO(@{x}) é exportada para ODF como ARRED.EXCESSO(@{x},SINAL(@{x}),1). "
"TETO(@{x},@{significância}) é a função OpenFormula ARRED.EXCESSO(@{x},"
"@{significância},1)."

#: ../plugins/fn-math/functions.c:830
msgid "COS:the cosine of @{x}"
msgstr "COS: o cosseno de @{x}"

#: ../plugins/fn-math/functions.c:831 ../plugins/fn-math/functions.c:939
#: ../plugins/fn-math/functions.c:1510 ../plugins/fn-math/functions.c:1546
#: ../plugins/fn-math/functions.c:1586 ../plugins/fn-math/functions.c:1759
msgid "x:angle in radians"
msgstr "x: ângulo em radianos"

#: ../plugins/fn-math/functions.c:833
msgid "wolfram:Cosine.html"
msgstr "wolfram:Cosine.html"

#: ../plugins/fn-math/functions.c:850
msgid "COSPI:the cosine of Pi*@{x}"
msgstr "COSPI: o cosseno de de Pi*@{x}"

#: ../plugins/fn-math/functions.c:851 ../plugins/fn-math/functions.c:904
#: ../plugins/fn-math/functions.c:1529 ../plugins/fn-math/functions.c:1776
msgid "x:number of half turns"
msgstr "x: número de meias voltas"

#: ../plugins/fn-math/functions.c:867
msgid "COSH:the hyperbolic cosine of @{x}"
msgstr "COSH: o cosseno hiperbólico de @{x}"

#: ../plugins/fn-math/functions.c:885
msgid "COT:the cotangent of @{x}"
msgstr "COT: a cotangente de @{x}"

#: ../plugins/fn-math/functions.c:889
msgid "wolfram:Cotangent.html"
msgstr "wolfram:Cotangent.html"

#: ../plugins/fn-math/functions.c:903
msgid "COTPI:the cotangent of Pi*@{x}"
msgstr "COTPI: a cotangente de Pi*@{x}"

#: ../plugins/fn-math/functions.c:920
msgid "COTH:the hyperbolic cotangent of @{x}"
msgstr "COTH: a cotangente hiperbólica de @{x}"

#: ../plugins/fn-math/functions.c:924
msgid "wolfram:HyperbolicCotangent.html"
msgstr "wolfram:HyperbolicCotangent.html"

#: ../plugins/fn-math/functions.c:925 ../plugins/fn-math/functions.c:1572
#: ../plugins/fn-math/functions.c:1612
msgid "wiki:en:Hyperbolic_function"
msgstr "wiki:pt:Função_hiperbólica"

#: ../plugins/fn-math/functions.c:938
msgid "DEGREES:equivalent degrees to @{x} radians"
msgstr "GRAUS: equivalente em graus de @{x} radianos"

#: ../plugins/fn-math/functions.c:956
msgid "EXP:e raised to the power of @{x}"
msgstr "EXP: e elevado à potência de @{x}"

#: ../plugins/fn-math/functions.c:958
msgid "e is the base of the natural logarithm."
msgstr "e é a base do logaritmo natural."

#: ../plugins/fn-math/functions.c:974
msgid "EXPM1:EXP(@{x})-1"
msgstr "EXPM1: EXP(@{x})-1"

#: ../plugins/fn-math/functions.c:976
msgid ""
"This function has a higher resulting precision than evaluating EXP(@{x})-1."
msgstr "Esta função tem um resultado mais preciso do que avaliar EXP(@{x})-1."

#: ../plugins/fn-math/functions.c:991
msgid "FACT:the factorial of @{x}, i.e. @{x}!"
msgstr "FATORIAL: o fatorial de @{x}, i.e. @{x}!"

#: ../plugins/fn-math/functions.c:994
msgid "The domain of this function has been extended using the GAMMA function."
msgstr "O domínio desta função foi estendido usando a função GAMA."

#: ../plugins/fn-math/functions.c:1015
msgid "GAMMA:the Gamma function"
msgstr "GAMA: a função Gama"

#: ../plugins/fn-math/functions.c:1032
msgid "GAMMALN:natural logarithm of the Gamma function"
msgstr "LNGAMA: logaritmo natural da função Gama"

#: ../plugins/fn-math/functions.c:1056
msgid "IGAMMA:the incomplete Gamma function"
msgstr "GAMAI: a função Gama incompleta"

#: ../plugins/fn-math/functions.c:1057 ../plugins/fn-stat/functions.c:510
msgid "a:number"
msgstr "a: número"

#: ../plugins/fn-math/functions.c:1061
msgid ""
"real:if true (the default), the real part of the result, otherwise the "
"imaginary part"
msgstr ""
"real: se VERDADEIRO (predefinição), a parte real do resultado, senão, a "
"parte imaginária"

#: ../plugins/fn-math/functions.c:1063
msgid ""
"This is a real valued function as long as neither @{a} nor @{z} are negative."
msgstr ""
"Esta é uma função realmente valorizada, desde que nem @{a} nem @{z} sejam "
"negativos."

#: ../plugins/fn-math/functions.c:1088
msgid "BETA:Euler beta function"
msgstr "BETA: função beta de Euler"

#: ../plugins/fn-math/functions.c:1090 ../plugins/fn-math/functions.c:1114
#: ../plugins/fn-math/functions.c:1340
msgid "y:number"
msgstr "y: número"

#: ../plugins/fn-math/functions.c:1091
msgid ""
"BETA function returns the value of the Euler beta function extended to all "
"real numbers except 0 and negative integers."
msgstr ""
"A função BETA devolve o valor da função beta de Euler, estendida a todos os "
"números reais exceto 0 e inteiros negativos."

#: ../plugins/fn-math/functions.c:1092
msgid ""
"If @{x}, @{y}, or (@{x} + @{y}) are non-positive integers, BETA returns #NUM!"
msgstr ""
"Se @{x}, @{y}, ou (@{x} + @{y}) forem inteiros não positivos, devolve #NUM!"

#: ../plugins/fn-math/functions.c:1096 ../plugins/fn-math/functions.c:1120
msgid "wiki:en:Beta_function"
msgstr "wiki:pt:Função_beta"

#: ../plugins/fn-math/functions.c:1112
msgid ""
"BETALN:natural logarithm of the absolute value of the Euler beta function"
msgstr "LNBETA: logaritmo natural do valor absoluto da função beta de Euler"

#: ../plugins/fn-math/functions.c:1115
msgid ""
"BETALN function returns the natural logarithm of the absolute value of the "
"Euler beta function extended to all real numbers except 0 and negative "
"integers."
msgstr ""
"A função LNBETA devolve o logaritmo natural do valor absoluto da função beta "
"de Euler estendida a todos os números reais exceto 0 e inteiros negativos."

#: ../plugins/fn-math/functions.c:1116
msgid ""
"If @{x}, @{y}, or (@{x} + @{y}) are non-positive integers, BETALN returns "
"#NUM!"
msgstr "Se @{x}, @{y}, ou (@{x} + @{y}) forem inteiros não positivos, #NUM!"

#: ../plugins/fn-math/functions.c:1137
msgid "COMBIN:binomial coefficient"
msgstr "COMBIN: coeficiente binomial"

#: ../plugins/fn-math/functions.c:1138 ../plugins/fn-math/functions.c:1170
#: ../plugins/fn-math/functions.c:2325
msgid "n:non-negative integer"
msgstr "n: inteiro não negativo"

#: ../plugins/fn-math/functions.c:1139 ../plugins/fn-math/functions.c:1171
msgid "k:non-negative integer"
msgstr "k: inteiro não negativo"

#: ../plugins/fn-math/functions.c:1140
msgid ""
"COMBIN returns the binomial coefficient \"@{n} choose @{k}\", the number of "
"@{k}-combinations of an @{n}-element set without repetition."
msgstr ""
"COMBIN devolve o coeficiente binomial \"@{n} escolhe @{k}\", no número de "
"combinações de @{n} termos, @{k} a @{k} sem repetição."

#: ../plugins/fn-math/functions.c:1143
msgid "If @{n} is less than @{k} COMBIN returns #NUM!"
msgstr "Se @{n} for menor que @{k}, devolve #NUM!."

#: ../plugins/fn-math/functions.c:1148
msgid "wiki:en:Binomial_coefficient"
msgstr "wiki:pt:Coeficiente_binomial"

#: ../plugins/fn-math/functions.c:1168
msgid ""
"COMBINA:the number of @{k}-combinations of an @{n}-element set with "
"repetition"
msgstr ""
"COMBINA: o número de combinações de @{n} termos, @{k} a @{k} com repetição"

#: ../plugins/fn-math/functions.c:1176
msgid "wiki:en:Multiset"
msgstr "wiki:en:Multiset"

#: ../plugins/fn-math/functions.c:1196
msgid ""
"FLOOR:nearest multiple of @{significance} whose absolute value is at most "
"ABS(@{x})"
msgstr ""
"ARRED.DEFEITO: o múltiplo mais próximo de @{significância} cujo valor "
"absoluto seja no máximo ABS@{x}"

#: ../plugins/fn-math/functions.c:1200
msgid ""
"FLOOR(@{x},@{significance}) is the nearest multiple of @{significance} whose "
"absolute value is at most ABS(@{x})"
msgstr ""
"ARRED.DEFEITO(@{x},@{significância}) é o múltiplo mais próximo de "
"@{siginficância} cujo valor absoluto é no máximo ABS(@{x})"

#: ../plugins/fn-math/functions.c:1202
msgid ""
"FLOOR(@{x}) is exported to ODF as FLOOR(@{x},SIGN(@{x}),1). FLOOR(@{x},"
"@{significance}) is the OpenFormula function FLOOR(@{x},@{significance},1)."
msgstr ""
"ARRED.DEFEITO(@{x}) é exportado para ODF como ARRED.DEFEITO(@{x},"
"SINAL(@{x}),1). ARRED.DEFEITO(@{x},@{significância}) é a função OpenFormula "
"ARRED.DEFEITO(@{x},@{significância},1)."

#: ../plugins/fn-math/functions.c:1232
msgid "INT:largest integer not larger than @{x}"
msgstr "INT: o maior inteiro não maior que @{x}"

#: ../plugins/fn-math/functions.c:1251
msgid "LOG:logarithm of @{x} with base @{base}"
msgstr "LOG: logaritmo de @{x} com base @{base}"

#: ../plugins/fn-math/functions.c:1252 ../plugins/fn-math/functions.c:1292
#: ../plugins/fn-math/functions.c:1315 ../plugins/fn-math/functions.c:1402
#: ../plugins/fn-math/functions.c:1424
msgid "x:positive number"
msgstr "x: número positivo"

#: ../plugins/fn-math/functions.c:1253
msgid "base:base of the logarithm, defaults to 10"
msgstr "base: base do logaritmo, predefinida como 10"

#: ../plugins/fn-math/functions.c:1254
msgid "@{base} must be positive and not equal to 1."
msgstr "@{base} tem de ser positiva e diferente de 1."

#: ../plugins/fn-math/functions.c:1255
msgid "If @{x} ≤ 0, LOG returns #NUM! error."
msgstr "Se @{x} ≤ 0, devolve #NUM!."

#: ../plugins/fn-math/functions.c:1291
msgid "LN:the natural logarithm of @{x}"
msgstr "LN: logaritmo natural de @{x}"

#: ../plugins/fn-math/functions.c:1293
msgid "If @{x} ≤ 0, LN returns #NUM! error."
msgstr "Se @{x} ≤ 0, devolve #NUM!."

#: ../plugins/fn-math/functions.c:1314
msgid "LN1P:LN(1+@{x})"
msgstr "LN1P: LN(1+@{x})"

#: ../plugins/fn-math/functions.c:1316
msgid ""
"LN1P calculates LN(1+@{x}) but yielding a higher precision than evaluating "
"LN(1+@{x})."
msgstr ""
"LN1P calcula LN(1+@{x}) mas com uma precisão mais alta do que avaliando "
"LN(1+@{x})."

#: ../plugins/fn-math/functions.c:1317
msgid "If @{x} ≤ -1, LN returns #NUM! error."
msgstr "Se @{x} ≤ -1, devolve #NUM!."

#: ../plugins/fn-math/functions.c:1338
msgid ""
"POWER:the value of @{x} raised to the power @{y} raised to the power of 1/"
"@{z}"
msgstr ""
"POTÊNCIA: o valor de @{x} elevado à potência de @{y} elevado à potência de 1/"
"@{z}"

#: ../plugins/fn-math/functions.c:1341
msgid "z:number"
msgstr "z: número"

#: ../plugins/fn-math/functions.c:1342
msgid "If both @{x} and @{y} equal 0, POWER returns #NUM!"
msgstr "Se @{x} e @{y} forem iguais a zero, devolve #NUM!."

#: ../plugins/fn-math/functions.c:1343
msgid "If @{x} = 0 and @{y} < 0, POWER returns #DIV/0!"
msgstr "Se @{x} = 0 e @{y} < 0, devolve #DIV/0!"

#: ../plugins/fn-math/functions.c:1344
msgid "If @{x} < 0 and @{y} is not an integer, POWER returns #NUM!"
msgstr "Se @{x} < 0 e @{y} não for um inteiro, devolve #NUM!"

#: ../plugins/fn-math/functions.c:1345
msgid "@{z} defaults to 1"
msgstr "Predefinição de @{z} é 1"

#: ../plugins/fn-math/functions.c:1346
msgid "If @{z} is not a positive integer, POWER returns #NUM!"
msgstr "Se @{z} não for um inteiro positivo, devolve #NUM!."

#: ../plugins/fn-math/functions.c:1347
msgid "If @{x} < 0, @{y} is odd, and @{z} is even, POWER returns #NUM!"
msgstr "Se @{x} < 0, @{y} for ímpar e @{z} for par, devolve #NUM!"

#: ../plugins/fn-math/functions.c:1380
msgid "POCHHAMMER:the value of GAMMA(@{x}+@{n})/GAMMA(@{x})"
msgstr "POCHHAMMER: o valor de GAMA(@{x}+@{n})/GAMA(@{x})"

#: ../plugins/fn-math/functions.c:1401
msgid "LOG2:the base-2 logarithm of @{x}"
msgstr "LOG2: o logaritmo base 2 de @{x}"

#: ../plugins/fn-math/functions.c:1403
msgid "If @{x} ≤ 0, LOG2 returns #NUM!"
msgstr "Se @{x} ≤ 0, devolve #NUM!"

#: ../plugins/fn-math/functions.c:1423
msgid "LOG10:the base-10 logarithm of @{x}"
msgstr "LOG10: o logaritmo base 10 de @{x}"

#: ../plugins/fn-math/functions.c:1425
msgid "If @{x} ≤ 0, LOG10 returns #NUM!"
msgstr "Se @{x} ≤ 0, devolve #NUM!"

#: ../plugins/fn-math/functions.c:1445
msgid "MOD:the remainder of @{x} under division by @{n}"
msgstr "RESTO: o resto da divisão de @{x} por @{n}"

#: ../plugins/fn-math/functions.c:1448
msgid "MOD function returns the remainder when @{x} is divided by @{n}."
msgstr "A função RESTO devolve o resto da divisão de @{x} por @{n}."

#: ../plugins/fn-math/functions.c:1449
msgid "If @{n} is 0, MOD returns #DIV/0!"
msgstr "Se @{n} for 0, devolve #DIV/0!."

#: ../plugins/fn-math/functions.c:1491
msgid "RADIANS:the number of radians equivalent to @{x} degrees"
msgstr "RADIANOS: o equivalente em radianos a @{x} graus"

#: ../plugins/fn-math/functions.c:1492
msgid "x:angle in degrees"
msgstr "x: ângulo em graus"

#: ../plugins/fn-math/functions.c:1509
msgid "SIN:the sine of @{x}"
msgstr "SEN: o seno de @{x}"

#: ../plugins/fn-math/functions.c:1514
msgid "wolfram:Sine.html"
msgstr "wolfram:Sine.html"

#: ../plugins/fn-math/functions.c:1528
msgid "SINPI:the sine of Pi*@{x}"
msgstr "SENPI: o seno de Pi*@{x}"

#: ../plugins/fn-math/functions.c:1545
msgid "CSC:the cosecant of @{x}"
msgstr "CSC: a cossecante de @{x}"

#: ../plugins/fn-math/functions.c:1547 ../plugins/fn-math/functions.c:1567
#: ../plugins/fn-math/functions.c:1587 ../plugins/fn-math/functions.c:1607
msgid "This function is not Excel compatible."
msgstr "Esta função não é compatível com Excel."

#: ../plugins/fn-math/functions.c:1551
msgid "wolfram:Cosecant.html"
msgstr "wolfram:Cosecant.html"

#: ../plugins/fn-math/functions.c:1565
msgid "CSCH:the hyperbolic cosecant of @{x}"
msgstr "CSCH: a cossecante hiperbólica de @{x}"

#: ../plugins/fn-math/functions.c:1571
msgid "wolfram:HyperbolicCosecant.html"
msgstr "wolfram:HyperbolicCosecant.html"

#: ../plugins/fn-math/functions.c:1585
msgid "SEC:Secant"
msgstr "SEC: a secante de @{x}"

#: ../plugins/fn-math/functions.c:1588
msgid "SEC(@{x}) is exported to OpenFormula as 1/COS(@{x})."
msgstr "SEC(@{x}) é exportada para OpenFormula como 1/COS(@{x})."

#: ../plugins/fn-math/functions.c:1591
msgid "wolfram:Secant.html"
msgstr "wolfram:Secant.html"

#: ../plugins/fn-math/functions.c:1605
msgid "SECH:the hyperbolic secant of @{x}"
msgstr "SECH: a secante hiperbólica de @{x}"

#: ../plugins/fn-math/functions.c:1608
msgid "SECH(@{x}) is exported to OpenFormula as 1/COSH(@{x})."
msgstr "SECH(@{x}) é exportada para OpenFormula como 1/COSH(@{x})."

#: ../plugins/fn-math/functions.c:1611
msgid "wolfram:HyperbolicSecant.html"
msgstr "wolfram:HyperbolicSecant.html"

#: ../plugins/fn-math/functions.c:1623
msgid "SINH:the hyperbolic sine of @{x}"
msgstr "SENH: o seno hiperbólico de @{x}"

#: ../plugins/fn-math/functions.c:1641
msgid "SQRT:square root of @{x}"
msgstr "RAIZQ: raiz quadrada de @{x}"

#: ../plugins/fn-math/functions.c:1642 ../plugins/fn-math/functions.c:2067
msgid "x:non-negative number"
msgstr "x: número não negativo"

#: ../plugins/fn-math/functions.c:1644
msgid "If @{x} is negative, SQRT returns #NUM!"
msgstr "Se @{x} for negativo, devolve #NUM!."

#: ../plugins/fn-math/functions.c:1663
msgid "SUMA:sum of all values and cells referenced"
msgstr "SOMA: soma todos os valores e células referenciadas"

#: ../plugins/fn-math/functions.c:1664 ../plugins/fn-math/functions.c:1688
msgid "area0:first cell area"
msgstr "área0: primeira área de células"

#: ../plugins/fn-math/functions.c:1665 ../plugins/fn-math/functions.c:1689
msgid "area1:second cell area"
msgstr "área1: segunda área de células"

#: ../plugins/fn-math/functions.c:1687
msgid "SUMSQ:sum of the squares of all values and cells referenced"
msgstr ""
"SOMARQUAD: a soma dos quadrados de todos os valores e células referenciadas"

#: ../plugins/fn-math/functions.c:1710
msgid ""
"MULTINOMIAL:multinomial coefficient (@{x1}+⋯+@{xn}) choose (@{x1},…,@{xn})"
msgstr ""
"MULTINOMIAL: coeficiente multinomial (@{x1}+⋯+@{xn}) escolhe (@{x1},…,@{xn})"

#: ../plugins/fn-math/functions.c:1711
msgid "x1:first number"
msgstr "x1: primeiro número"

#: ../plugins/fn-math/functions.c:1712
msgid "x2:second number"
msgstr "x2: segundo número"

#: ../plugins/fn-math/functions.c:1713
msgid "xn:nth number"
msgstr "xn: n-ésimo número"

#: ../plugins/fn-math/functions.c:1717
msgid "wiki:en:Multinomial_theorem"
msgstr "wiki:pt_Teorema_multinomial"

#: ../plugins/fn-math/functions.c:1735
msgid "G_PRODUCT:product of all the values and cells referenced"
msgstr "PRODUTO: produto de todos os valores e células referenciadas"

#: ../plugins/fn-math/functions.c:1736
msgid "x1:number"
msgstr "x1: número"

#: ../plugins/fn-math/functions.c:1737
msgid "x2:number"
msgstr "x2: número"

#: ../plugins/fn-math/functions.c:1738
msgid "Empty cells are ignored and the empty product is 1."
msgstr "Células vazias são ignoradas e o produto vazio é 1."

#: ../plugins/fn-math/functions.c:1758
msgid "TAN:the tangent of @{x}"
msgstr "TAN: a tangente de @{x}"

#: ../plugins/fn-math/functions.c:1775
msgid "TANPI:the tangent of Pi*@{x}"
msgstr "TANPI: a tangente de Pi*@{x}"

#: ../plugins/fn-math/functions.c:1791
msgid "TANH:the hyperbolic tangent of @{x}"
msgstr "TANH: a tangente hiperbólica de @{x}"

#: ../plugins/fn-math/functions.c:1808
msgid "PI:the constant 𝜋"
msgstr "PI:a constante 𝜋"

#: ../plugins/fn-math/functions.c:1809
msgid ""
"This function is Excel compatible, but it returns 𝜋 with a better precision."
msgstr "Esta função é compatível com Excel, mas devolve 𝜋 com melhor precisão."

#: ../plugins/fn-math/functions.c:1826
msgid "TRUNC:@{x} truncated to @{d} digits"
msgstr "TRUNCAR: @{x} truncado para @{d} dígitos"

#: ../plugins/fn-math/functions.c:1828
msgid "d:non-negative integer, defaults to 0"
msgstr "d: inteiro não negativo, predefinido como 0"

#: ../plugins/fn-math/functions.c:1829
msgid ""
"If @{d} is omitted or negative then it defaults to zero. If it is not an "
"integer then it is truncated to an integer."
msgstr ""
"Se @{d} for omitido ou negativo, a predefinição é zero. Se não for um "
"inteiro, é truncado para um inteiro."

#: ../plugins/fn-math/functions.c:1863
msgid "EVEN:@{x} rounded away from 0 to the next even integer"
msgstr "PAR: @{x} arredondado para o próximo inteiro par"

#: ../plugins/fn-math/functions.c:1898
msgid "ODD:@{x} rounded away from 0 to the next odd integer"
msgstr "ÍMPAR: @{x} arredondado para o próximo inteiro ímpar"

#: ../plugins/fn-math/functions.c:1933
msgid "FACTDOUBLE:double factorial"
msgstr "FATDUPLO: fatorial duplo"

#: ../plugins/fn-math/functions.c:1934
msgid "x:non-negative integer"
msgstr "x: inteiro não negativo"

#: ../plugins/fn-math/functions.c:1935
msgid "FACTDOUBLE function returns the double factorial @{x}!!"
msgstr "A função FATDUPLO devolve o fatorial duplo @{x}!!"

#: ../plugins/fn-math/functions.c:1936
msgid ""
"If @{x} is not an integer, it is truncated. If @{x} is negative, FACTDOUBLE "
"returns #NUM!"
msgstr ""
"Se @{x} não for um inteiro, é truncado. Se for negativo, devolve #NUM!."

#: ../plugins/fn-math/functions.c:1970
msgid "FIB:Fibonacci numbers"
msgstr "FIB: números de Fibonacci"

#: ../plugins/fn-math/functions.c:1971 ../plugins/fn-numtheory/numtheory.c:220
#: ../plugins/fn-numtheory/numtheory.c:253
#: ../plugins/fn-numtheory/numtheory.c:287
#: ../plugins/fn-numtheory/numtheory.c:328
#: ../plugins/fn-numtheory/numtheory.c:360
#: ../plugins/fn-numtheory/numtheory.c:420
#: ../plugins/fn-numtheory/numtheory.c:476
#: ../plugins/fn-numtheory/numtheory.c:507
msgid "n:positive integer"
msgstr "n: inteiro positivo"

#: ../plugins/fn-math/functions.c:1972
msgid "FIB(@{n}) is the @{n}th Fibonacci number."
msgstr "FIB(@{n}) é o  @{n}º número de Fibonacci."

#: ../plugins/fn-math/functions.c:1973
msgid ""
"If @{n} is not an integer, it is truncated. If it is negative or zero FIB "
"returns #NUM!"
msgstr ""
"Se @{n} não for um inteiro, é truncado. Se for negativo ou zero, devolve "
"#NUM!."

#: ../plugins/fn-math/functions.c:2011
msgid "QUOTIENT:integer portion of a division"
msgstr "QUOCIENTE: parte inteira de uma divisão"

#: ../plugins/fn-math/functions.c:2012
msgid "numerator:integer"
msgstr "numerador: inteiro"

#: ../plugins/fn-math/functions.c:2013
msgid "denominator:non-zero integer"
msgstr "denominador: inteiro não zero"

#: ../plugins/fn-math/functions.c:2014
msgid ""
"QUOTIENT yields the integer portion of the division @{numerator}/"
"@{denominator}.\n"
"QUOTIENT (@{numerator},@{denominator})⨉@{denominator}+MOD(@{numerator},"
"@{denominator})=@{numerator}"
msgstr ""
"QUOCIENTE devolve a parte inteira de uma divisão @{numerador}/"
"@{denominador}.\n"
"QUOCIENTE (@{numerador},@{denominador})⨉@{denominador}+RESTO(@{numerador},"
"@{denominador})=@{numerador}"

#: ../plugins/fn-math/functions.c:2038
msgid "SIGN:sign of @{x}"
msgstr "SINAL: sinal de @{x}"

#: ../plugins/fn-math/functions.c:2040
msgid ""
"SIGN returns 1 if the @{x} is positive and it returns -1 if @{x} is negative."
msgstr "SINAL devolve 1 se @{x} for positivo e -1 se for negativo."

#: ../plugins/fn-math/functions.c:2065
msgid "SQRTPI:the square root of @{x} times 𝜋"
msgstr "RAIZQPI: a raiz quadrada de @{x} vezes 𝜋"

#: ../plugins/fn-math/functions.c:2088
msgid "ROUNDDOWN:@{x} rounded towards 0"
msgstr "ARRED.PARA.BAIXO: @{x} arredondado em direção a zero"

#: ../plugins/fn-math/functions.c:2090 ../plugins/fn-math/functions.c:2114
#: ../plugins/fn-math/functions.c:2155
msgid "d:integer, defaults to 0"
msgstr "d: inteiro, predefinido como 0"

#: ../plugins/fn-math/functions.c:2091
msgid ""
"If @{d} is greater than zero, @{x} is rounded toward 0 to the given number "
"of digits.\n"
"If @{d} is zero, @{x} is rounded toward 0 to the next integer.\n"
"If @{d} is less than zero, @{x} is rounded toward 0 to the left of the "
"decimal point"
msgstr ""
"Se @{d} for maior que zero, @{x} é arredondado em direção a 0 pelo nº dado "
"de dígitos.\n"
"Se @{d} for zero, @{x} é arredondado em direção a 0 para o próximo inteiro.\n"
"Se @{d} for menor que zero, @{x} é arredondado em direção a 0 para a "
"esquerda do ponto decimal."

#: ../plugins/fn-math/functions.c:2112
msgid "ROUND:rounded @{x}"
msgstr "ARRED: @{x} arredondado"

#: ../plugins/fn-math/functions.c:2115
msgid ""
"If @{d} is greater than zero, @{x} is rounded to the given number of "
"digits.\n"
"If @{d} is zero, @{x} is rounded to the next integer.\n"
"If @{d} is less than zero, @{x} is rounded to the left of the decimal point"
msgstr ""
"Se @{d} for maior que zero, @{x} é arredondado pelo nº dado de dígitos.\n"
"Se @{d} for zero, @{x} é arredondado para o próximo inteiro.\n"
"Se @{d} for menor que zero, @{x} é arredondado para a esquerda do ponto "
"decimal."

#: ../plugins/fn-math/functions.c:2153
msgid "ROUNDUP:@{x} rounded away from 0"
msgstr "ARRED.PARA.CIMA: @{x} arredondado em direção contrária a zero"

#: ../plugins/fn-math/functions.c:2156
msgid ""
"If @{d} is greater than zero, @{x} is rounded away from 0 to the given "
"number of digits.\n"
"If @{d} is zero, @{x} is rounded away from 0 to the next integer.\n"
"If @{d} is less than zero, @{x} is rounded away from 0 to the left of the "
"decimal point"
msgstr ""
"Se @{d} for maior que zero, @{x} é arredondado em direção contrária a 0 pelo "
"nº dado de dígitos.\n"
"Se @{d} for zero, @{x} é arredondado em direção contrária a 0 para o próximo "
"inteiro.\n"
"Se @{d} for menor que zero, @{x} é arredondado em direção contrária a 0 para "
"a esquerda do ponto decimal."

#: ../plugins/fn-math/functions.c:2200
msgid "MROUND:@{x} rounded to a multiple of @{m}"
msgstr "ARRED.MÚLTIPLO: @{x} arredondado a um múltiplo de @{m}"

#: ../plugins/fn-math/functions.c:2202
msgid "m:number"
msgstr "m: número"

#: ../plugins/fn-math/functions.c:2203
msgid "If @{x} and @{m} have different sign, MROUND returns #NUM!"
msgstr "Se @{x} e @{m} tiverem sinal diferente, devolve #NUM!."

#: ../plugins/fn-math/functions.c:2246
msgid "ARABIC:the Roman numeral @{roman} as number"
msgstr "ÁRABE: o numeral romano @{romano} como número"

#: ../plugins/fn-math/functions.c:2247
msgid "roman:Roman numeral"
msgstr "romano: numeral romano"

#: ../plugins/fn-math/functions.c:2248
msgid ""
"Any Roman symbol to the left of a larger symbol (directly or indirectly) "
"reduces the final value by the symbol amount, otherwise, it increases the "
"final amount by the symbol's amount."
msgstr ""
"Qualquer símbolo romano à esquerda de um símbolo maior (direta ou "
"indiretamente) reduz o valor final na quantia do símbolo; caso contrário, "
"aumenta o valor final na quantia do símbolo."

#: ../plugins/fn-math/functions.c:2324
msgid "ROMAN:@{n} as a roman numeral text"
msgstr "ROMANO: @{n} como um numeral romano em texto"

#: ../plugins/fn-math/functions.c:2326
msgid "type:0,1,2,3,or 4, defaults to 0"
msgstr "tipo:0,1,2,3,or 4, predefinido como 0"

#: ../plugins/fn-math/functions.c:2327
msgid ""
"ROMAN returns the arabic number @{n} as a roman numeral text.\n"
"If @{type} is 0 or it is omitted, ROMAN returns classic roman numbers.\n"
"Type 1 is more concise than classic type, type 2 is more concise than type "
"1, and type 3 is more concise than type 2. Type 4 is a simplified type."
msgstr ""
"ROMANO devolve o número árabe @{n} como numeral romano em texto.\n"
"Se @{tipo} for 0 ou omitido, devolve números romanos clássicos.\n"
"O tipo 1 é mais conciso que o tipo 0, o tipo 2 é mais conciso que o tipo 1 e "
"o tipo 3 é mais conciso que o tipo 2. O tipo 4 é um tipo simplificado."

#: ../plugins/fn-math/functions.c:2574
msgid "SUMX2MY2:sum of the difference of squares"
msgstr "SOMAX2DY2: soma da diferença de quadrados"

#: ../plugins/fn-math/functions.c:2575 ../plugins/fn-math/functions.c:2617
#: ../plugins/fn-math/functions.c:2660
msgid "array0:first cell area"
msgstr "matriz0: primeira área de células"

#: ../plugins/fn-math/functions.c:2576 ../plugins/fn-math/functions.c:2618
#: ../plugins/fn-math/functions.c:2661
msgid "array1:second cell area"
msgstr "matriz1: segunda área de células"

#: ../plugins/fn-math/functions.c:2577
msgid ""
"SUMX2MY2 function returns the sum of the difference of squares of "
"corresponding values in two arrays. The equation of SUMX2MY2 is SUM(x^2-y^2)."
msgstr ""
"A função SOMAX2DY2 devolve a soma da diferença de quadrados de valores "
"correspondentes em duas matrizes. A equação de SOMAX2DY2 é SOMA(x²-y²)."

#: ../plugins/fn-math/functions.c:2580 ../plugins/fn-math/functions.c:2624
#: ../plugins/fn-math/functions.c:2667
msgid ""
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11, 15, 17, 21, "
"and 43 and the cells B1, B2, ..., B5 hold numbers 13, 22, 31, 33, and 39."
msgstr ""
"Vamos assumir que as células A1, A2, ..., A5 contêm os números 11, 15, 17, "
"21, e 43 e as células B1, B2, ..., B5 têm os números 13, 22, 31, 33, e 39."

#: ../plugins/fn-math/functions.c:2581
msgid "Then SUMX2MY2(A1:A5,B1:B5) yields -1299."
msgstr "Então SOMAX2DY2(A1:A5,B1:B5) devolve -1299."

#: ../plugins/fn-math/functions.c:2616
msgid "SUMX2PY2:sum of the sum of squares"
msgstr "SOMAX2SY2: soma da soma dos quadrados"

#: ../plugins/fn-math/functions.c:2619
msgid ""
"SUMX2PY2 function returns the sum of the sum of squares of corresponding "
"values in two arrays. The equation of SUMX2PY2 is SUM(x^2+y^2)."
msgstr ""
"A função SOMAX2SY2 devolve a soma da soma de quadrados de valores "
"correspondentes em duas matrizes. A equação de SOMAX2SY2 é SOMA(x²+y²)."

#: ../plugins/fn-math/functions.c:2621
msgid ""
"If @{array0} and @{array1} have different number of data points, SUMX2PY2 "
"returns #N/A.\n"
"Strings and empty cells are simply ignored."
msgstr ""
"Se @{matriz0} e @{matriz1} tiverem um número diferente de dados, devolve #N/"
"D!.\n"
"Cadeias e células vazias são simplesmente ignoradas."

#: ../plugins/fn-math/functions.c:2625
msgid "Then SUMX2PY2(A1:A5,B1:B5) yields 7149."
msgstr "Então SOMAX2SY2(A1:A5,B1:B5) devolve 7149."

#: ../plugins/fn-math/functions.c:2659
msgid "SUMXMY2:sum of the squares of differences"
msgstr "SOMAXMY2: soma dos quadrados das diferenças"

#: ../plugins/fn-math/functions.c:2662
msgid ""
"SUMXMY2 function returns the sum of the squares of the differences of "
"corresponding values in two arrays. The equation of SUMXMY2 is SUM((x-y)^2)."
msgstr ""
"A função SOMAXMY2 devolve a soma dos quadrados das diferenças de valores "
"correspndentes em duas matrizes. A equação de SOMAXMY2 é SOMA((x-y)²)."

#: ../plugins/fn-math/functions.c:2664
msgid ""
"If @{array0} and @{array1} have different number of data points, SUMXMY2 "
"returns #N/A.\n"
"Strings and empty cells are simply ignored."
msgstr ""
"Se @{matriz0} e @{matriz1} tiverem um número diferente de dados, devolve #N/"
"D!.\n"
"Cadeias e células vazias são simplesmente ignoradas."

#: ../plugins/fn-math/functions.c:2668
msgid "Then SUMXMY2(A1:A5,B1:B5) yields 409."
msgstr "Então SOMAXMY2(A1:A5,B1:B5) devolve 409."

#: ../plugins/fn-math/functions.c:2704
msgid "SERIESSUM:sum of a power series at @{x}"
msgstr "SOMASÉRIE: soma de uma série de potências em @{x}"

#: ../plugins/fn-math/functions.c:2705
msgid "x:number where to evaluate the power series"
msgstr "x: número onde avaliar a série de potências"

#: ../plugins/fn-math/functions.c:2706
msgid "n:non-negative integer, exponent of the lowest term of the series"
msgstr "n: inteiro não negativo, expoente do termo mais baixo da série"

#: ../plugins/fn-math/functions.c:2707
msgid "m:increment to each exponent"
msgstr "m: incremento de cada expoente"

#: ../plugins/fn-math/functions.c:2708
msgid "coeff:coefficients of the power series"
msgstr "coef: coeficientes da série de potências"

#: ../plugins/fn-math/functions.c:2710
msgid ""
"Let us assume that the cells A1, A2, ..., A5 contain numbers 1.23, 2.32, "
"2.98, 3.42, and 4.33."
msgstr ""
"Vamos assumir que as células A1, A2, ..., A5 contêm os números 1.23, 2.32, "
"2.98, 3.42, e 4.33."

#: ../plugins/fn-math/functions.c:2711
msgid "Then SERIESSUM(2,1,2.23,A1:A5) evaluates as 5056.37439843926"
msgstr "Então SOMASÉRIE(2,1,2.23,A1:A5) devolve 5056.37439843926"

#: ../plugins/fn-math/functions.c:2762
msgid "MINVERSE:the inverse matrix of @{matrix}"
msgstr "MATRIZ.INVERSA: a matriz inversa de @{matriz}"

#: ../plugins/fn-math/functions.c:2763 ../plugins/fn-math/functions.c:3052
msgid "matrix:a square matrix"
msgstr "matriz: uma matriz quadrada"

#: ../plugins/fn-math/functions.c:2764
msgid "If @{matrix} is not invertible, MINVERSE returns #NUM!"
msgstr "Se @{matriz} não for invertível, devolve #NUM!."

#: ../plugins/fn-math/functions.c:2765
msgid ""
"If @{matrix} does not contain an equal number of columns and rows, MINVERSE "
"returns #VALUE!"
msgstr ""
"Se @{matriz} não tiver um número igual de linhas e colunas, devolve #VALOR!."

#: ../plugins/fn-math/functions.c:2799
msgid "MPSEUDOINVERSE:the pseudo-inverse matrix of @{matrix}"
msgstr "PSEUDO.MATRIZ.INVERSA: a pseudo matrix inversa de @{matriz}"

#: ../plugins/fn-math/functions.c:2800
msgid "matrix:a matrix"
msgstr "matriz: uma matriz"

#: ../plugins/fn-math/functions.c:2801
msgid "threshold:a relative size threshold for discarding eigenvalues"
msgstr "limite: um limite de tamanho relativo para descartar autovalores"

#: ../plugins/fn-math/functions.c:2836
msgid ""
"CHOLESKY:the Cholesky decomposition of the symmetric positive-definite "
"@{matrix}"
msgstr ""
"CHOLESKY:a decomposição Cholesky da @{matriz} simétrica positiva definida"

#: ../plugins/fn-math/functions.c:2837
msgid "matrix:a symmetric positive definite matrix"
msgstr "matriz: uma matriz de simétrica positiva definida"

#: ../plugins/fn-math/functions.c:2838
msgid ""
"If the Cholesky-Banachiewicz algorithm applied to @{matrix} fails, Cholesky "
"returns #NUM!"
msgstr ""
"Se o algoritmo Cholesky-Banachiewicz aplicado a @{matrix} falhar, devolve "
"#NUM!"

#: ../plugins/fn-math/functions.c:2839
msgid ""
"If @{matrix} does not contain an equal number of columns and rows, CHOLESKY "
"returns #VALUE!"
msgstr ""
"Se @{matriz} não tiver um número igual de linhas e colunas, devolve #VALOR!."

#: ../plugins/fn-math/functions.c:2914
msgid "MUNIT:the @{n} by @{n} identity matrix"
msgstr "MUNIT:a matriz identidade @{n} por @{n}"

#: ../plugins/fn-math/functions.c:2915
msgid "n:size of the matrix"
msgstr "n: tamanho da matriz"

#: ../plugins/fn-math/functions.c:2952
msgid "MMULT:the matrix product of @{mat1} and @{mat2}"
msgstr "MATRIZ.MULT: a matriz produto de @matriz1} e @{matriz2}"

#: ../plugins/fn-math/functions.c:2953
msgid "mat1:a matrix"
msgstr "matriz1: uma matriz"

#: ../plugins/fn-math/functions.c:2954
msgid "mat2:a matrix"
msgstr "matriz2: uma matriz"

#: ../plugins/fn-math/functions.c:2955
msgid ""
"The number of columns in @{mat1} must equal the number of rows in @{mat2}; "
"otherwise #VALUE! is returned.  The result of MMULT is an array, in which "
"the number of rows is the same as in @{mat1}), and the number of columns is "
"the same as in (@{mat2})."
msgstr ""
"O número de colunas na @{matriz1} tem de ser uigual ao número de linhas da "
"@{matriz2} ou será devolvido #VLALOR!. O resultado de MATRIZ.MULT é uma "
"matriz, em que o número de linhas é o mesmo de @{matriz1} e o número de "
"colunas é o mesmo de @{matriz2}."

#: ../plugins/fn-math/functions.c:2995
msgid "LINSOLVE:solve linear equation"
msgstr "RESOLVE.EQ: resolve a equação linear"

#: ../plugins/fn-math/functions.c:2996 ../plugins/fn-stat/functions.c:3515
msgid "A:a matrix"
msgstr "a: uma matriz"

#: ../plugins/fn-math/functions.c:2997
msgid "B:a matrix"
msgstr "b: uma matriz"

#: ../plugins/fn-math/functions.c:2999
msgid "Solves the equation @{A}*X=@{B} and returns X."
msgstr "Resolve a equação @{a}+X=@{b} e devolve X."

#: ../plugins/fn-math/functions.c:3000
msgid "If the matrix @{A} is singular, #VALUE! is returned."
msgstr "Se a matriz @{a} for singular, devolve #VALOR!."

#: ../plugins/fn-math/functions.c:3051
msgid "MDETERM:the determinant of the matrix @{matrix}"
msgstr "MATRIZ.DETERM: a determinante da matriz @{matriz}"

#: ../plugins/fn-math/functions.c:3053
msgid ""
"Let us assume that A1,...,A4 contain numbers 2, 3, 7, and 3; B1,..., B4 4, "
"2, 4, and 1; C1,...,C4 9, 4, 3; and 2; and D1,...,D4 7, 3, 6, and 5. Then "
"MDETERM(A1:D4) yields 148."
msgstr ""
"Vamos assumir que A1,...,A4 contêm os números 2, 3, 7, e 3; B1,..., B4 4, 2, "
"4, e 1; C1,...,C4 9, 4, 3; e 2; e D1,...,D4 7, 3, 6, e 5. Então MATRIZ."
"DETERM(A1:D4) devolve 148."

#: ../plugins/fn-math/functions.c:3083
msgid "SUMPRODUCT:multiplies components and adds the results"
msgstr "ISOMARPRODUTO: multiplica componentes e adiciona os resultados"

#: ../plugins/fn-math/functions.c:3085 ../plugins/fn-math/functions.c:3108
msgid ""
"Multiplies corresponding data entries in the given arrays or ranges, and "
"then returns the sum of those products."
msgstr ""
"Multiplica entradas de dados correspondentes nas matrizes ou intervalos "
"indicados e devolve a soma desses produtos."

#: ../plugins/fn-math/functions.c:3088
msgid "If an entry is not numeric, the value zero is used instead."
msgstr "Se uma entrada não for numérica, é usado o valor 0."

#: ../plugins/fn-math/functions.c:3089 ../plugins/fn-math/functions.c:3112
msgid ""
"If arrays or range arguments do not have the same dimensions, return #VALUE! "
"error."
msgstr ""
"Se as matrizes ou intervalos não tiverem as mesmas dimensões, devolve "
"#VALOR!."

#: ../plugins/fn-math/functions.c:3091
msgid ""
"This function ignores logicals, so using SUMPRODUCT(A1:A5>0) will not work.  "
"Instead use SUMPRODUCT(--(A1:A5>0))"
msgstr ""
"Esta função ignora valores logicos, logo usar ISOMARPRODUTO(A1:A5>0) não "
"funciona. Use antes ISOMARPRODUTO(--(A1:A5>0))"

#: ../plugins/fn-math/functions.c:3100
msgid ""
"This function is not OpenFormula compatible. Use ODF.SUMPRODUCT instead."
msgstr "Esta função não é compativel com OpenFormula. Use antes SOMARPRODUTO."

#: ../plugins/fn-math/functions.c:3106
msgid "ODF.SUMPRODUCT:multiplies components and adds the results"
msgstr "SOMARPRODUTO:  multiplica componentes e adiciona os resultados"

#: ../plugins/fn-math/functions.c:3111
msgid "If an entry is not numeric or logical, the value zero is used instead."
msgstr "Se uma entrada não for numérica ou lógica, é usado o valor 0."

#: ../plugins/fn-math/functions.c:3114
msgid "This function differs from SUMPRODUCT by considering booleans."
msgstr ""
"Esta função difere de ISOMARPRODUTO porque leva em conta valores lógicos."

#: ../plugins/fn-math/functions.c:3115
msgid "This function is not Excel compatible. Use SUMPRODUCT instead."
msgstr "Esta função não é compatível com Excel. Use antes ISOMARPRODUTO."

#: ../plugins/fn-math/functions.c:3250
msgid "EIGEN:eigenvalues and eigenvectors of the symmetric @{matrix}"
msgstr "EIGEN: autovalores e autovetores da @{matriz} simétrica"

#: ../plugins/fn-math/functions.c:3251
msgid "matrix:a symmetric matrix"
msgstr "matriz: uma matriz simétrica"

#: ../plugins/fn-math/functions.c:3252
msgid "If @{matrix} is not symmetric, EIGEN returns #NUM!"
msgstr "Se @{matriz}não for simétrica, devolve #NUM!."

#: ../plugins/fn-math/functions.c:3253
msgid ""
"If @{matrix} does not contain an equal number of columns and rows, EIGEN "
"returns #VALUE!"
msgstr ""
"Se @{matriz} não tiver o mesmo número de linhas e colunas, devolve #VALOR!."

#: ../plugins/fn-numtheory/numtheory.c:219
msgid "NT_OMEGA:Number of distinct prime factors"
msgstr "NT_OMEGA: número de fatores primos distintos"

#: ../plugins/fn-numtheory/numtheory.c:221
msgid "Returns the number of distinct prime factors without multiplicity."
msgstr "Devolve o número de fatores primos distintos sem multiplicidade."

#: ../plugins/fn-numtheory/numtheory.c:252
msgid "NT_PHI:Euler's totient function"
msgstr "NT_PHI: função totiente de Euler"

#: ../plugins/fn-numtheory/numtheory.c:254
msgid ""
"Euler's totient function gives the number of integers less than or equal to "
"@{n} that are relatively prime (coprime) to @{n}."
msgstr ""
"A função totiente de Euler dá o número de inteiros menor ou igual a @{n} que "
"são relativamente primos (coprimos) com respeito a @{n}"

#: ../plugins/fn-numtheory/numtheory.c:257
msgid "wiki:en:Euler's_totient_function"
msgstr "wiki:pt:Função_totiente_de_Euler"

#: ../plugins/fn-numtheory/numtheory.c:286
msgid "NT_MU:Möbius mu function"
msgstr "NT_MU: função μ de Möbius"

#: ../plugins/fn-numtheory/numtheory.c:289
msgid ""
"NT_MU function (Möbius mu function) returns 0  if @{n} is divisible by the "
"square of a prime. Otherwise, if @{n} has an odd  number of different prime "
"factors, NT_MU returns -1, and if @{n} has an even number of different prime "
"factors, it returns 1. If @{n} = 1, NT_MU returns 1."
msgstr ""
"A função NT_MU (função Möbius mu) devolve 0  se @{n} for divisível pelo "
"quadrado de um primo. Caso contrário devolve: -1 se @n tiver um número ímpar "
"de fatores primos diferentes 1 se @n tiver um número par de fatores primos "
"diferentes. Se @{n} = 1, devolve 1."

#: ../plugins/fn-numtheory/numtheory.c:296
msgid "wiki:en:Möbius_function"
msgstr "wiki:pt:Função_de_Möbius"

#: ../plugins/fn-numtheory/numtheory.c:297
msgid "wolfram:MoebiusFunction.html"
msgstr "wolfram:MoebiusFunction.html"

#: ../plugins/fn-numtheory/numtheory.c:327
msgid "NT_D:number of divisors"
msgstr "NT_D: número de divisores"

#: ../plugins/fn-numtheory/numtheory.c:329
msgid "NT_D calculates the number of divisors of @{n}."
msgstr "NT_D calcula o número de divisores de @{n}."

#: ../plugins/fn-numtheory/numtheory.c:359
msgid "NT_SIGMA:sigma function"
msgstr "NT_SIGMA: função sigma"

#: ../plugins/fn-numtheory/numtheory.c:361
msgid "NT_SIGMA calculates the sum of the divisors of @{n}."
msgstr "NT_SIGMA calcula a soma dos divisores de @{n}."

#: ../plugins/fn-numtheory/numtheory.c:364
msgid "wiki:en:Divisor_function"
msgstr "wiki:pt:Função_divisor"

#: ../plugins/fn-numtheory/numtheory.c:393
msgid "ITHPRIME:@{i}th prime"
msgstr "IÉSIMO.PRIMO: o @{i}º primo"

#: ../plugins/fn-numtheory/numtheory.c:394
msgid "i:positive integer"
msgstr "i: inteiro positivo"

#: ../plugins/fn-numtheory/numtheory.c:395
msgid "ITHPRIME finds the @{i}th prime."
msgstr "IÉSIMO.PRIMO encontra o @{i}º primo."

#: ../plugins/fn-numtheory/numtheory.c:419
msgid "ISPRIME:whether @{n} is prime"
msgstr "É.PRIMO: se @{n} é primo"

#: ../plugins/fn-numtheory/numtheory.c:421
msgid "ISPRIME returns TRUE if @{n} is prime and FALSE otherwise."
msgstr "É.PRIMO devolve VERDADEIRO se @{n} for primo, senão devolve FALSO."

#: ../plugins/fn-numtheory/numtheory.c:424
msgid "wolfram:PrimeNumber.html"
msgstr "wolfram:PrimeNumber.html"

#: ../plugins/fn-numtheory/numtheory.c:475
msgid "PFACTOR:smallest prime factor"
msgstr "FATORP: o menor fator primo"

#: ../plugins/fn-numtheory/numtheory.c:477
msgid "PFACTOR finds the smallest prime factor of its argument."
msgstr "FATORP encontra o fator primo mais pequeno do seu argumento."

#: ../plugins/fn-numtheory/numtheory.c:478
msgid ""
"The argument @{n} must be at least 2. Otherwise a #VALUE! error is returned."
msgstr "O argumento @{n} tem de ser pelo menos 2. Senão devolve #VALOR!."

#: ../plugins/fn-numtheory/numtheory.c:506
msgid "NT_PI:number of primes upto @{n}"
msgstr "NT_PI: número de primos até @{n}"

#: ../plugins/fn-numtheory/numtheory.c:508
msgid "NT_PI returns the number of primes less than or equal to @{n}."
msgstr "NT_PI devolve o número de primos menores ou iguais a @{n}."

#: ../plugins/fn-numtheory/numtheory.c:511
msgid "wolfram:PrimeCountingFunction.html"
msgstr "wolfram:PrimeCountingFunction.html"

#: ../plugins/fn-numtheory/numtheory.c:537
msgid "BITOR:bitwise or"
msgstr "OUBITWISE: ou bitwise"

#: ../plugins/fn-numtheory/numtheory.c:538
#: ../plugins/fn-numtheory/numtheory.c:562
#: ../plugins/fn-numtheory/numtheory.c:586
#: ../plugins/fn-numtheory/numtheory.c:611
#: ../plugins/fn-numtheory/numtheory.c:641
msgid "a:non-negative integer"
msgstr "a: inteiro não negativo"

#: ../plugins/fn-numtheory/numtheory.c:539
#: ../plugins/fn-numtheory/numtheory.c:563
#: ../plugins/fn-numtheory/numtheory.c:587
msgid "b:non-negative integer"
msgstr "b: inteiro não negativo"

#: ../plugins/fn-numtheory/numtheory.c:540
msgid ""
"BITOR returns the bitwise or of the binary representations of its arguments."
msgstr ""
"OUBITWISE devolve o ou bitwise das representações binárias dos seus "
"argumentos."

#: ../plugins/fn-numtheory/numtheory.c:561
msgid "BITXOR:bitwise exclusive or"
msgstr "OUEXBITWISE: ou exclusivo bitwaise"

#: ../plugins/fn-numtheory/numtheory.c:564
msgid ""
"BITXOR returns the bitwise exclusive or of the binary representations of its "
"arguments."
msgstr ""
"OUEXBITWISE devolve o ou exclusivo bitwise das representações binárias dos "
"seus argumentos."

#: ../plugins/fn-numtheory/numtheory.c:585
msgid "BITAND:bitwise and"
msgstr "EBITWISE: e bitwise"

#: ../plugins/fn-numtheory/numtheory.c:588
msgid ""
"BITAND returns the bitwise and of the binary representations of its "
"arguments."
msgstr ""
"EBITWISE devolve o e bitwise das representações binárias dos seus argumentos."

#: ../plugins/fn-numtheory/numtheory.c:610
msgid "BITLSHIFT:bit-shift to the left"
msgstr "BITDESQ: bit deslocado à esquerda"

#: ../plugins/fn-numtheory/numtheory.c:613
msgid ""
"BITLSHIFT returns the binary representations of @{a} shifted @{n} positions "
"to the left."
msgstr ""
"BITDESQ devolve as representações binárias de @{a} deslocado @{n} posições à "
"esquerda."

#: ../plugins/fn-numtheory/numtheory.c:614
msgid ""
"If @{n} is negative, BITLSHIFT shifts the bits to the right by ABS(@{n}) "
"positions."
msgstr ""
"Se @{n} for negativo, BITDESQ desloca os bits à direita ABS(@{n}) posições."

#: ../plugins/fn-numtheory/numtheory.c:640
msgid "BITRSHIFT:bit-shift to the right"
msgstr "BITDDIR: bit deslocado à direita"

#: ../plugins/fn-numtheory/numtheory.c:643
msgid ""
"BITRSHIFT returns the binary representations of @{a} shifted @{n} positions "
"to the right."
msgstr ""
"BITDDIR devolve as representações binárias de @{a} deslocado @{n} posições à "
"direita."

#: ../plugins/fn-numtheory/numtheory.c:644
msgid ""
"If @{n} is negative, BITRSHIFT shifts the bits to the left by ABS(@{n}) "
"positions."
msgstr ""
"Se @{n} for negativo, BITDDIR desloca os bits à esquerda ABS(@{n}) posições."

#: ../plugins/fn-r/functions.c:19
msgid "R.DBETA:probability density function of the beta distribution"
msgstr "R.DBETA: função de densidade da probabilidade da distribuição beta"

#: ../plugins/fn-r/functions.c:20 ../plugins/fn-r/functions.c:44
#: ../plugins/fn-r/functions.c:96 ../plugins/fn-r/functions.c:120
#: ../plugins/fn-r/functions.c:172 ../plugins/fn-r/functions.c:196
#: ../plugins/fn-r/functions.c:248 ../plugins/fn-r/functions.c:271
#: ../plugins/fn-r/functions.c:321 ../plugins/fn-r/functions.c:343
#: ../plugins/fn-r/functions.c:391 ../plugins/fn-r/functions.c:415
#: ../plugins/fn-r/functions.c:467 ../plugins/fn-r/functions.c:491
#: ../plugins/fn-r/functions.c:543 ../plugins/fn-r/functions.c:565
#: ../plugins/fn-r/functions.c:613 ../plugins/fn-r/functions.c:637
#: ../plugins/fn-r/functions.c:689 ../plugins/fn-r/functions.c:715
#: ../plugins/fn-r/functions.c:771 ../plugins/fn-r/functions.c:795
#: ../plugins/fn-r/functions.c:923 ../plugins/fn-r/functions.c:947
#: ../plugins/fn-r/functions.c:999 ../plugins/fn-r/functions.c:1021
#: ../plugins/fn-r/functions.c:1069 ../plugins/fn-r/functions.c:1091
#: ../plugins/fn-r/functions.c:1139 ../plugins/fn-r/functions.c:1165
#: ../plugins/fn-r/functions.c:1221 ../plugins/fn-r/functions.c:1245
#: ../plugins/fn-r/functions.c:1297 ../plugins/fn-r/functions.c:1319
#: ../plugins/fn-r/functions.c:1367 ../plugins/fn-r/functions.c:1423
#: ../plugins/fn-r/functions.c:1447
msgid "x:observation"
msgstr "x: observação"

#: ../plugins/fn-r/functions.c:21 ../plugins/fn-r/functions.c:45
#: ../plugins/fn-r/functions.c:71
msgid "a:the first shape parameter of the distribution"
msgstr "a: o primeiro parâmetro forma da distribuição"

#: ../plugins/fn-r/functions.c:22 ../plugins/fn-r/functions.c:46
#: ../plugins/fn-r/functions.c:72
msgid "b:the second scale parameter of the distribution"
msgstr "b: o segundo parâmetro forma da distribuição"

#: ../plugins/fn-r/functions.c:23 ../plugins/fn-r/functions.c:99
#: ../plugins/fn-r/functions.c:175 ../plugins/fn-r/functions.c:250
#: ../plugins/fn-r/functions.c:323 ../plugins/fn-r/functions.c:394
#: ../plugins/fn-r/functions.c:470 ../plugins/fn-r/functions.c:545
#: ../plugins/fn-r/functions.c:616 ../plugins/fn-r/functions.c:693
#: ../plugins/fn-r/functions.c:774 ../plugins/fn-r/functions.c:850
#: ../plugins/fn-r/functions.c:926 ../plugins/fn-r/functions.c:1001
#: ../plugins/fn-r/functions.c:1071 ../plugins/fn-r/functions.c:1143
#: ../plugins/fn-r/functions.c:1224 ../plugins/fn-r/functions.c:1299
#: ../plugins/fn-r/functions.c:1426
msgid "give_log:if true, log of the result will be returned instead"
msgstr "dar_registo: se VERDADEIRO, será devolvido o registo do resultado"

#: ../plugins/fn-r/functions.c:24
msgid ""
"This function returns the probability density function of the beta "
"distribution."
msgstr ""
"Esta função devolve a função de densidade da probabilidade da distribuição "
"beta."

#: ../plugins/fn-r/functions.c:43
msgid "R.PBETA:cumulative distribution function of the beta distribution"
msgstr "R.PBETA: função de distribuição cumulativa da distribuição beta"

#: ../plugins/fn-r/functions.c:47 ../plugins/fn-r/functions.c:73
#: ../plugins/fn-r/functions.c:123 ../plugins/fn-r/functions.c:149
#: ../plugins/fn-r/functions.c:199 ../plugins/fn-r/functions.c:225
#: ../plugins/fn-r/functions.c:273 ../plugins/fn-r/functions.c:298
#: ../plugins/fn-r/functions.c:345 ../plugins/fn-r/functions.c:369
#: ../plugins/fn-r/functions.c:418 ../plugins/fn-r/functions.c:444
#: ../plugins/fn-r/functions.c:494 ../plugins/fn-r/functions.c:520
#: ../plugins/fn-r/functions.c:567 ../plugins/fn-r/functions.c:591
#: ../plugins/fn-r/functions.c:640 ../plugins/fn-r/functions.c:666
#: ../plugins/fn-r/functions.c:719 ../plugins/fn-r/functions.c:747
#: ../plugins/fn-r/functions.c:798 ../plugins/fn-r/functions.c:824
#: ../plugins/fn-r/functions.c:874 ../plugins/fn-r/functions.c:900
#: ../plugins/fn-r/functions.c:950 ../plugins/fn-r/functions.c:976
#: ../plugins/fn-r/functions.c:1023 ../plugins/fn-r/functions.c:1047
#: ../plugins/fn-r/functions.c:1093 ../plugins/fn-r/functions.c:1117
#: ../plugins/fn-r/functions.c:1169 ../plugins/fn-r/functions.c:1197
#: ../plugins/fn-r/functions.c:1248 ../plugins/fn-r/functions.c:1274
#: ../plugins/fn-r/functions.c:1321 ../plugins/fn-r/functions.c:1345
#: ../plugins/fn-r/functions.c:1371 ../plugins/fn-r/functions.c:1399
#: ../plugins/fn-r/functions.c:1450 ../plugins/fn-r/functions.c:1476
msgid ""
"lower_tail:if true (the default), the lower tail of the distribution is "
"considered"
msgstr ""
"cauda_baixa: se VERDADEIRO (predefinição), é considerada a cauda baixa da "
"distribuição"

#: ../plugins/fn-r/functions.c:48 ../plugins/fn-r/functions.c:74
#: ../plugins/fn-r/functions.c:124 ../plugins/fn-r/functions.c:150
#: ../plugins/fn-r/functions.c:200 ../plugins/fn-r/functions.c:226
#: ../plugins/fn-r/functions.c:274 ../plugins/fn-r/functions.c:299
#: ../plugins/fn-r/functions.c:346 ../plugins/fn-r/functions.c:370
#: ../plugins/fn-r/functions.c:419 ../plugins/fn-r/functions.c:445
#: ../plugins/fn-r/functions.c:495 ../plugins/fn-r/functions.c:521
#: ../plugins/fn-r/functions.c:568 ../plugins/fn-r/functions.c:592
#: ../plugins/fn-r/functions.c:641 ../plugins/fn-r/functions.c:667
#: ../plugins/fn-r/functions.c:720 ../plugins/fn-r/functions.c:748
#: ../plugins/fn-r/functions.c:799 ../plugins/fn-r/functions.c:825
#: ../plugins/fn-r/functions.c:875 ../plugins/fn-r/functions.c:901
#: ../plugins/fn-r/functions.c:951 ../plugins/fn-r/functions.c:977
#: ../plugins/fn-r/functions.c:1024 ../plugins/fn-r/functions.c:1048
#: ../plugins/fn-r/functions.c:1094 ../plugins/fn-r/functions.c:1118
#: ../plugins/fn-r/functions.c:1170 ../plugins/fn-r/functions.c:1198
#: ../plugins/fn-r/functions.c:1249 ../plugins/fn-r/functions.c:1275
#: ../plugins/fn-r/functions.c:1322 ../plugins/fn-r/functions.c:1346
#: ../plugins/fn-r/functions.c:1372 ../plugins/fn-r/functions.c:1400
#: ../plugins/fn-r/functions.c:1451 ../plugins/fn-r/functions.c:1477
msgid ""
"log_p:if true, the natural logarithm of the probability is given or "
"returned; defaults to false"
msgstr ""
"log_p: se VERDADEIRO, o logaritmo natural da probabilidade é dado ou "
"devolvido; predefinido como FALSO"

#: ../plugins/fn-r/functions.c:49
msgid ""
"This function returns the cumulative distribution function of the beta "
"distribution."
msgstr ""
"Esta função devolve a função de distribuição cumulativa da distribuição beta."

#: ../plugins/fn-r/functions.c:69
msgid "R.QBETA:probability quantile function of the beta distribution"
msgstr "R.QBETA: função de probalilidade da distribuição beta"

#: ../plugins/fn-r/functions.c:70 ../plugins/fn-r/functions.c:146
#: ../plugins/fn-r/functions.c:222 ../plugins/fn-r/functions.c:296
#: ../plugins/fn-r/functions.c:367 ../plugins/fn-r/functions.c:441
#: ../plugins/fn-r/functions.c:517 ../plugins/fn-r/functions.c:589
#: ../plugins/fn-r/functions.c:663 ../plugins/fn-r/functions.c:743
#: ../plugins/fn-r/functions.c:821 ../plugins/fn-r/functions.c:897
#: ../plugins/fn-r/functions.c:973 ../plugins/fn-r/functions.c:1045
#: ../plugins/fn-r/functions.c:1115 ../plugins/fn-r/functions.c:1193
#: ../plugins/fn-r/functions.c:1271 ../plugins/fn-r/functions.c:1343
#: ../plugins/fn-r/functions.c:1395 ../plugins/fn-r/functions.c:1473
msgid "p:probability or natural logarithm of the probability"
msgstr "p: probabilidade ou logaritmo natural da probabilidade"

#: ../plugins/fn-r/functions.c:75
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the beta distribution."
msgstr ""
"Esta função devolve o inverso da função de distribuição cumulativa da "
"distribuição beta."

#: ../plugins/fn-r/functions.c:95
msgid "R.DBINOM:probability density function of the binomial distribution"
msgstr ""
"R.DBINOM: função de densidade da probabilidade da distribuição binomial"

#: ../plugins/fn-r/functions.c:97 ../plugins/fn-r/functions.c:121
#: ../plugins/fn-r/functions.c:147
msgid "n:the number of trials"
msgstr "n: número de tentativas"

#: ../plugins/fn-r/functions.c:98 ../plugins/fn-r/functions.c:122
#: ../plugins/fn-r/functions.c:148 ../plugins/fn-r/functions.c:544
#: ../plugins/fn-r/functions.c:566 ../plugins/fn-r/functions.c:590
#: ../plugins/fn-r/functions.c:849 ../plugins/fn-r/functions.c:873
#: ../plugins/fn-r/functions.c:899
msgid "psuc:the probability of success in each trial"
msgstr "psuc: probabilidade de sucesso em cada tentativa"

#: ../plugins/fn-r/functions.c:100
msgid ""
"This function returns the probability density function of the binomial "
"distribution."
msgstr ""
"Esta função devolve a função de densidade da probabilidade da distribuição "
"binomial."

#: ../plugins/fn-r/functions.c:119
msgid "R.PBINOM:cumulative distribution function of the binomial distribution"
msgstr "R.PBINOM: função de distribuição cumulativa da distribuição binomial"

#: ../plugins/fn-r/functions.c:125
msgid ""
"This function returns the cumulative distribution function of the binomial "
"distribution."
msgstr ""
"Esta função devolve a função de distribuição cumulativa da distribuição "
"binomial."

#: ../plugins/fn-r/functions.c:145
msgid "R.QBINOM:probability quantile function of the binomial distribution"
msgstr "R.QBINOM: função de probalilidade da distribuição binomial"

#: ../plugins/fn-r/functions.c:151
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the binomial distribution."
msgstr ""
"Esta função devolve o inverso da função de distribuição cumulativa da "
"distribuição binomial."

#: ../plugins/fn-r/functions.c:171
msgid "R.DCAUCHY:probability density function of the Cauchy distribution"
msgstr "R.DCAUCHY: função de densidade da probabilidade da distribuição Cauchy"

#: ../plugins/fn-r/functions.c:173 ../plugins/fn-r/functions.c:197
#: ../plugins/fn-r/functions.c:223
msgid "location:the center of the distribution"
msgstr "localização: o centro da distribuição"

#: ../plugins/fn-r/functions.c:174 ../plugins/fn-r/functions.c:198
#: ../plugins/fn-r/functions.c:224 ../plugins/fn-r/functions.c:322
#: ../plugins/fn-r/functions.c:344 ../plugins/fn-r/functions.c:368
#: ../plugins/fn-r/functions.c:469 ../plugins/fn-r/functions.c:493
#: ../plugins/fn-r/functions.c:519 ../plugins/fn-r/functions.c:1070
#: ../plugins/fn-r/functions.c:1092 ../plugins/fn-r/functions.c:1116
#: ../plugins/fn-r/functions.c:1142 ../plugins/fn-r/functions.c:1168
#: ../plugins/fn-r/functions.c:1196 ../plugins/fn-r/functions.c:1425
#: ../plugins/fn-r/functions.c:1449 ../plugins/fn-r/functions.c:1475
msgid "scale:the scale parameter of the distribution"
msgstr "escala: o parâmetro escala da distribuição"

#: ../plugins/fn-r/functions.c:176
msgid ""
"This function returns the probability density function of the Cauchy "
"distribution."
msgstr ""
"Esta função devolve a função de densidade da probabilidade da distribuição "
"Cauchy."

#: ../plugins/fn-r/functions.c:195
msgid "R.PCAUCHY:cumulative distribution function of the Cauchy distribution"
msgstr "R.PCAUCHY: função de distribuição cumulativa da distribuição Cauchy"

#: ../plugins/fn-r/functions.c:201
msgid ""
"This function returns the cumulative distribution function of the Cauchy "
"distribution."
msgstr ""
"Esta função devolve a função de distribuição cumulativa da distribuição "
"Cauchy."

#: ../plugins/fn-r/functions.c:221
msgid "R.QCAUCHY:probability quantile function of the Cauchy distribution"
msgstr "R.QCAUCHY: função de probalilidade da distribuição Cauchy"

#: ../plugins/fn-r/functions.c:227
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the Cauchy distribution."
msgstr ""
"Esta função devolve o inverso da função de distribuição cumulativa da "
"distribuição Cauchy."

#: ../plugins/fn-r/functions.c:247
msgid "R.DCHISQ:probability density function of the chi-square distribution"
msgstr ""
"R.DCHIQ: função de densidade da probabilidade da distribuição chi quadrado"

#: ../plugins/fn-r/functions.c:249 ../plugins/fn-r/functions.c:272
#: ../plugins/fn-r/functions.c:297 ../plugins/fn-r/functions.c:1369
#: ../plugins/fn-r/functions.c:1397
msgid "df:the number of degrees of freedom of the distribution"
msgstr "gl: o número de graus de liberdade da distribuição"

#: ../plugins/fn-r/functions.c:251
msgid ""
"This function returns the probability density function of the chi-square "
"distribution."
msgstr ""
"Esta função devolve a função de densidade da probabilidade da distribuição "
"chi quadrado."

#: ../plugins/fn-r/functions.c:252
msgid ""
"A two argument invocation R.DCHISQ(@{x},@{df}) is exported to OpenFormula as "
"CHISQDIST(@{x},@{df},FALSE())."
msgstr ""
"Uma invocação de dois argumentos de R.DCHIQ(@{x},@{df}) é exportada para "
"OpenFormula como DIST.CHI.QUAD(@{x},@{df},FALSO())."

#: ../plugins/fn-r/functions.c:270
msgid ""
"R.PCHISQ:cumulative distribution function of the chi-square distribution"
msgstr ""
"R.PCHIQ: função de distribuição cumulativa da distribuição chi quadrado"

#: ../plugins/fn-r/functions.c:275
msgid ""
"This function returns the cumulative distribution function of the chi-square "
"distribution."
msgstr ""
"Esta função devolve a função de distribuição cumulativa da distribuição chi "
"quadrado."

#: ../plugins/fn-r/functions.c:276
msgid ""
"A two argument invocation R.PCHISQ(@{x},@{df}) is exported to OpenFormula as "
"CHISQDIST(@{x},@{df})."
msgstr ""
"Uma invocação de dois argumentos de R.PCHIQ(@{x},@{df}) é exportada para "
"OpenFormula como DIST.CHI.QUAD(@{x},@{df})."

#: ../plugins/fn-r/functions.c:295
msgid "R.QCHISQ:probability quantile function of the chi-square distribution"
msgstr "R.QCHIQ: função de probalilidade da distribuição chi quadrado"

#: ../plugins/fn-r/functions.c:300
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the chi-square distribution."
msgstr ""
"Esta função devolve o inverso da função de distribuição cumulativa da "
"distribuição chi quadrado."

#: ../plugins/fn-r/functions.c:301
msgid ""
"A two argument invocation R.QCHISQ(@{p},@{df}) is exported to OpenFormula as "
"CHISQINV(@{p},@{df})."
msgstr ""
"Uma invocação de dois argumentos de R.QCHIQ(@{p},@{df}) é exportada para "
"OpenFormula como INV.CHI.QUAD(@{p},@{df})."

#: ../plugins/fn-r/functions.c:320
msgid "R.DEXP:probability density function of the exponential distribution"
msgstr ""
"R.DEXP: função de densidade da probabilidade da distribuição exponencial"

#: ../plugins/fn-r/functions.c:324
msgid ""
"This function returns the probability density function of the exponential "
"distribution."
msgstr ""
"Esta função devolve a função de densidade da probabilidade da distribuição "
"exponencial."

#: ../plugins/fn-r/functions.c:342
msgid "R.PEXP:cumulative distribution function of the exponential distribution"
msgstr "R.PEXP: função de distribuição cumulativa da distribuição exponencial"

#: ../plugins/fn-r/functions.c:347
msgid ""
"This function returns the cumulative distribution function of the "
"exponential distribution."
msgstr ""
"Esta função devolve a função de distribuição cumulativa da distribuição "
"exponencial."

#: ../plugins/fn-r/functions.c:366
msgid "R.QEXP:probability quantile function of the exponential distribution"
msgstr "R.QEXP: função de probalilidade da distribuição exponencial"

#: ../plugins/fn-r/functions.c:371
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the exponential distribution."
msgstr ""
"Esta função devolve o inverso da função de distribuição cumulativa da "
"distribuição exponencial."

#: ../plugins/fn-r/functions.c:390
msgid "R.DF:probability density function of the F distribution"
msgstr "R.DF: função de densidade da probabilidade da distribuição F"

#: ../plugins/fn-r/functions.c:392 ../plugins/fn-r/functions.c:416
#: ../plugins/fn-r/functions.c:442
msgid "n1:the first number of degrees of freedom of the distribution"
msgstr "n1: o primeiro número de graus de lberdade da distribuição"

#: ../plugins/fn-r/functions.c:393 ../plugins/fn-r/functions.c:417
#: ../plugins/fn-r/functions.c:443
msgid "n2:the second number of degrees of freedom of the distribution"
msgstr "n2: o segundo número de graus de lberdade da distribuição"

#: ../plugins/fn-r/functions.c:395
msgid ""
"This function returns the probability density function of the F distribution."
msgstr ""
"Esta função devolve a função de densidade da probabilidade da distribuição F."

#: ../plugins/fn-r/functions.c:414
msgid "R.PF:cumulative distribution function of the F distribution"
msgstr "R.PF: função de distribuição cumulativa da distribuição F"

#: ../plugins/fn-r/functions.c:420
msgid ""
"This function returns the cumulative distribution function of the F "
"distribution."
msgstr ""
"Esta função devolve a função de distribuição cumulativa da distribuição F."

#: ../plugins/fn-r/functions.c:440
msgid "R.QF:probability quantile function of the F distribution"
msgstr "R.QF: função de probalilidade da distribuição F"

#: ../plugins/fn-r/functions.c:446
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the F distribution."
msgstr ""
"Esta função devolve o inverso da função de distribuição cumulativa da "
"distribuição F."

#: ../plugins/fn-r/functions.c:466
msgid "R.DGAMMA:probability density function of the gamma distribution"
msgstr "R.DGAMA: função de densidade da probabilidade da distribuição gama"

#: ../plugins/fn-r/functions.c:468 ../plugins/fn-r/functions.c:492
#: ../plugins/fn-r/functions.c:518 ../plugins/fn-r/functions.c:1140
#: ../plugins/fn-r/functions.c:1166 ../plugins/fn-r/functions.c:1194
#: ../plugins/fn-r/functions.c:1223 ../plugins/fn-r/functions.c:1247
#: ../plugins/fn-r/functions.c:1273 ../plugins/fn-r/functions.c:1424
#: ../plugins/fn-r/functions.c:1448 ../plugins/fn-r/functions.c:1474
msgid "shape:the shape parameter of the distribution"
msgstr "forma: o parâmetro forma da distribuição"

#: ../plugins/fn-r/functions.c:471
msgid ""
"This function returns the probability density function of the gamma "
"distribution."
msgstr ""
"Esta função devolve a função de densidade da probabilidade da distribuição "
"gama."

#: ../plugins/fn-r/functions.c:490
msgid "R.PGAMMA:cumulative distribution function of the gamma distribution"
msgstr "R.PGAMA: função de distribuição cumulativa da distribuição gama"

#: ../plugins/fn-r/functions.c:496
msgid ""
"This function returns the cumulative distribution function of the gamma "
"distribution."
msgstr ""
"Esta função devolve a função de distribuição cumulativa da distribuição gama"

#: ../plugins/fn-r/functions.c:516
msgid "R.QGAMMA:probability quantile function of the gamma distribution"
msgstr "R.QGAMA: função de probalilidade da distribuição gama"

#: ../plugins/fn-r/functions.c:522
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the gamma distribution."
msgstr ""
"Esta função devolve o inverso da função de distribuição cumulativa da "
"distribuição gama."

#: ../plugins/fn-r/functions.c:542
msgid "R.DGEOM:probability density function of the geometric distribution"
msgstr ""
"R.DGEOM: função de densidade da probabilidade da distribuição geométrica"

#: ../plugins/fn-r/functions.c:546
msgid ""
"This function returns the probability density function of the geometric "
"distribution."
msgstr ""
"Esta função devolve a função de densidade da probabilidade da distribuição "
"geométrica."

#: ../plugins/fn-r/functions.c:564
msgid "R.PGEOM:cumulative distribution function of the geometric distribution"
msgstr "R.PGEOM: função de distribuição cumulativa da distribuição geométrica"

#: ../plugins/fn-r/functions.c:569
msgid ""
"This function returns the cumulative distribution function of the geometric "
"distribution."
msgstr ""
"Esta função devolve a função de distribuição cumulativa da distribuição "
"geométrica."

#: ../plugins/fn-r/functions.c:588
msgid "R.QGEOM:probability quantile function of the geometric distribution"
msgstr "R.QGEOM: função de probalilidade da distribuição geométrica"

#: ../plugins/fn-r/functions.c:593
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the geometric distribution."
msgstr ""
"Esta função devolve o inverso da função de distribuição cumulativa da "
"distribuição geométrica."

#: ../plugins/fn-r/functions.c:612
msgid "R.DGUMBEL:probability density function of the Gumbel distribution"
msgstr ""
"R.DGUMBEL: função de densidade da probabilidade da distribuição de Gumbel"

#: ../plugins/fn-r/functions.c:614 ../plugins/fn-r/functions.c:638
#: ../plugins/fn-r/functions.c:664
msgid "mu:the location parameter of freedom of the distribution"
msgstr "mu: o parâmetro de localização da liberdade da distribuição"

#: ../plugins/fn-r/functions.c:615 ../plugins/fn-r/functions.c:639
#: ../plugins/fn-r/functions.c:665
msgid "beta:the scale parameter of freedom of the distribution"
msgstr "beta: o parâmetro escala da liberdade da distribuição"

#: ../plugins/fn-r/functions.c:617
msgid ""
"This function returns the probability density function of the Gumbel "
"distribution."
msgstr ""
"Esta função devolve a função de densidade da probabilidade da distribuição "
"de Gumbel."

#: ../plugins/fn-r/functions.c:636
msgid "R.PGUMBEL:cumulative distribution function of the Gumbel distribution"
msgstr "R.PGUMBEL: função de distribuição cumulativa da distribuição de Gumbel"

#: ../plugins/fn-r/functions.c:642
msgid ""
"This function returns the cumulative distribution function of the Gumbel "
"distribution."
msgstr ""
"Esta função devolve a função de distribuição cumulativa da distribuição de "
"Gumbel."

#: ../plugins/fn-r/functions.c:662
msgid "R.QGUMBEL:probability quantile function of the Gumbel distribution"
msgstr ""
"R.QGUMBEL: função de quantil de probalilidade da distribuição de Gumbel"

#: ../plugins/fn-r/functions.c:668
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the Gumbel distribution."
msgstr ""
"Esta função devolve a função do quantil da probabilidade i.e., o inverso da "
"função de distribuição cumulativa da distribuição de Gumbel."

#: ../plugins/fn-r/functions.c:688
msgid ""
"R.DHYPER:probability density function of the hypergeometric distribution"
msgstr ""
"R.DHIPER: função de densidade da probabilidade da distribuição "
"hipergeométrica"

#: ../plugins/fn-r/functions.c:690 ../plugins/fn-r/functions.c:716
#: ../plugins/fn-r/functions.c:744
msgid "r:the number of red balls"
msgstr "r: o número de bolas vermelhas"

#: ../plugins/fn-r/functions.c:691 ../plugins/fn-r/functions.c:717
#: ../plugins/fn-r/functions.c:745
msgid "b:the number of black balls"
msgstr "b: o número de bolas pretas"

#: ../plugins/fn-r/functions.c:692 ../plugins/fn-r/functions.c:718
#: ../plugins/fn-r/functions.c:746
msgid "n:the number of balls drawn"
msgstr "n: o número de bolas desenhadas"

#: ../plugins/fn-r/functions.c:694
msgid ""
"This function returns the probability density function of the hypergeometric "
"distribution."
msgstr ""
"Esta função devolve a função de densidade da probabilidade da distribuição "
"hipergeométrica"

#: ../plugins/fn-r/functions.c:714
msgid ""
"R.PHYPER:cumulative distribution function of the hypergeometric distribution"
msgstr ""
"R.PHIPER: função de distribuição cumulativa da distribuição hipergeométrica"

#: ../plugins/fn-r/functions.c:721
msgid ""
"This function returns the cumulative distribution function of the "
"hypergeometric distribution."
msgstr ""
"Esta função devolve a função de distribuição cumulativa da distribuição "
"hipergeométrica."

#: ../plugins/fn-r/functions.c:742
msgid ""
"R.QHYPER:probability quantile function of the hypergeometric distribution"
msgstr "R.QHYPER: função de probalilidade da distribuição hipergeométrica"

#: ../plugins/fn-r/functions.c:749
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the hypergeometric distribution."
msgstr ""
"Esta função devolve o inverso da função de distribuição cumulativa da "
"distribuição hipergeométrica."

#: ../plugins/fn-r/functions.c:770
msgid "R.DLNORM:probability density function of the log-normal distribution"
msgstr ""
"R.DLNORM: função de densidade da probabilidade da distribuição log-normal"

#: ../plugins/fn-r/functions.c:772 ../plugins/fn-r/functions.c:796
#: ../plugins/fn-r/functions.c:822
msgid "logmean:mean of the underlying normal distribution"
msgstr "médialog: média da distribuição normal subjacente"

#: ../plugins/fn-r/functions.c:773 ../plugins/fn-r/functions.c:797
#: ../plugins/fn-r/functions.c:823
msgid "logsd:standard deviation of the underlying normal distribution"
msgstr "dplog: desvio padrão da distribuição normal subjacente"

#: ../plugins/fn-r/functions.c:775
msgid ""
"This function returns the probability density function of the log-normal "
"distribution."
msgstr ""
"Esta função devolve a função da densidade da probabilidade da distribuição "
"log-normal"

#: ../plugins/fn-r/functions.c:794
msgid ""
"R.PLNORM:cumulative distribution function of the log-normal distribution"
msgstr "R.PLNORM: função de distribuição cumulativa da distribuição log-normal"

#: ../plugins/fn-r/functions.c:800
msgid ""
"This function returns the cumulative distribution function of the log-normal "
"distribution."
msgstr ""
"Esta função devolve a função de distribuição cumulativa da distribuição log-"
"normal"

#: ../plugins/fn-r/functions.c:820
msgid "R.QLNORM:probability quantile function of the log-normal distribution"
msgstr "R.QLNORM: função de probalilidade da distribuição log-normal"

#: ../plugins/fn-r/functions.c:826
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the log-normal distribution."
msgstr ""
"Esta função devolve o inverso da função de distribuição cumulativa da "
"distribuição log-normal."

#: ../plugins/fn-r/functions.c:846
msgid ""
"R.DNBINOM:probability density function of the negative binomial distribution"
msgstr ""
"R.DNBINOM: função de densidade da probabilidade da distribuição binomial "
"negativa"

#: ../plugins/fn-r/functions.c:847 ../plugins/fn-r/functions.c:871
msgid "x:observation (number of failures)"
msgstr "x: observação (número de falhas)"

#: ../plugins/fn-r/functions.c:848 ../plugins/fn-r/functions.c:872
#: ../plugins/fn-r/functions.c:898
msgid "n:required number of successes"
msgstr "n: número de sucessos requerido"

#: ../plugins/fn-r/functions.c:851
msgid ""
"This function returns the probability density function of the negative "
"binomial distribution."
msgstr ""
"Esta função devolve a função de densidade da probabilidade da distribuição "
"binomial negativa."

#: ../plugins/fn-r/functions.c:870
msgid ""
"R.PNBINOM:cumulative distribution function of the negative binomial "
"distribution"
msgstr ""
"R.PNBINOM: função de distribuição cumulativa da distribuição binomial "
"negativa"

#: ../plugins/fn-r/functions.c:876
msgid ""
"This function returns the cumulative distribution function of the negative "
"binomial distribution."
msgstr ""
"Esta função devolve a função de distribuição cumulativa da distribuição "
"binomial negativa."

#: ../plugins/fn-r/functions.c:896
msgid ""
"R.QNBINOM:probability quantile function of the negative binomial distribution"
msgstr "R.QNBINOM: função de probalilidade da distribuição binomial negativa"

#: ../plugins/fn-r/functions.c:902
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the negative binomial "
"distribution."
msgstr ""
"Esta função devolve o inverso da função de distribuição cumulativa da "
"distribuição binomial negativa."

#: ../plugins/fn-r/functions.c:922
msgid "R.DNORM:probability density function of the normal distribution"
msgstr "R.DNORM: função de densidade da probabilidade da distribuição normal"

#: ../plugins/fn-r/functions.c:924 ../plugins/fn-r/functions.c:948
#: ../plugins/fn-r/functions.c:974
msgid "mu:mean of the distribution"
msgstr "mu: média da distribuição"

#: ../plugins/fn-r/functions.c:925 ../plugins/fn-r/functions.c:949
#: ../plugins/fn-r/functions.c:975
msgid "sigma:standard deviation of the distribution"
msgstr "sigma: desvio padrão da distribuição"

#: ../plugins/fn-r/functions.c:927
msgid ""
"This function returns the probability density function of the normal "
"distribution."
msgstr ""
"Esta função devolve a função de densidade da probabilidade da distribuição "
"normal."

#: ../plugins/fn-r/functions.c:946
msgid "R.PNORM:cumulative distribution function of the normal distribution"
msgstr "R.PNORM: função de distribuição cumulativa da distribuição normal"

#: ../plugins/fn-r/functions.c:952
msgid ""
"This function returns the cumulative distribution function of the normal "
"distribution."
msgstr ""
"Esta função devolve a função de distribuição cumulativa da distribuição "
"normal."

#: ../plugins/fn-r/functions.c:972
msgid "R.QNORM:probability quantile function of the normal distribution"
msgstr "R.QNORM: função de probalilidade da distribuição normal"

#: ../plugins/fn-r/functions.c:978
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the normal distribution."
msgstr ""
"Esta função devolve o inverso da função de distribuição cumulativa da "
"distribuição normal."

#: ../plugins/fn-r/functions.c:998
msgid "R.DPOIS:probability density function of the Poisson distribution"
msgstr "R.DPOIS: função de densidade da probabilidade da distribuição Poisson"

#: ../plugins/fn-r/functions.c:1000 ../plugins/fn-r/functions.c:1022
#: ../plugins/fn-r/functions.c:1046
msgid "lambda:the mean of the distribution"
msgstr "lâmbda: a média da distribuição"

#: ../plugins/fn-r/functions.c:1002
msgid ""
"This function returns the probability density function of the Poisson "
"distribution."
msgstr ""
"Esta função devolve a função de densidade da probabilidade da distribuição "
"Poisson."

#: ../plugins/fn-r/functions.c:1020
msgid "R.PPOIS:cumulative distribution function of the Poisson distribution"
msgstr "R.PPOIS: função de distribuição cumulativa da distribuição Poisson"

#: ../plugins/fn-r/functions.c:1025
msgid ""
"This function returns the cumulative distribution function of the Poisson "
"distribution."
msgstr ""
"Esta função devolve a função de distribuição cumulativa da distribuição "
"Poisson."

#: ../plugins/fn-r/functions.c:1044
msgid "R.QPOIS:probability quantile function of the Poisson distribution"
msgstr "R.QPOIS: função de probalilidade da distribuição Poisson"

#: ../plugins/fn-r/functions.c:1049
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the Poisson distribution."
msgstr ""
"Esta função devolve o inverso da função de distribuição cumulativa da "
"distribuição Poisson."

#: ../plugins/fn-r/functions.c:1068
msgid "R.DRAYLEIGH:probability density function of the Rayleigh distribution"
msgstr ""
"R.DRAYLEIGH: função de densidade da probabilidade da distribuição Rayleigh"

#: ../plugins/fn-r/functions.c:1072
msgid ""
"This function returns the probability density function of the Rayleigh "
"distribution."
msgstr ""
"Esta função devolve a função de densidade da probabilidade da distribuição "
"Rayleigh."

#: ../plugins/fn-r/functions.c:1090
msgid ""
"R.PRAYLEIGH:cumulative distribution function of the Rayleigh distribution"
msgstr ""
"R.PRAYLEIGH: função de distribuição cumulativa da distribuição Rayleigh"

#: ../plugins/fn-r/functions.c:1095
msgid ""
"This function returns the cumulative distribution function of the Rayleigh "
"distribution."
msgstr ""
"Esta função devolve a função de distribuição cumulativa da distribuição "
"Rayleigh."

#: ../plugins/fn-r/functions.c:1114
msgid "R.QRAYLEIGH:probability quantile function of the Rayleigh distribution"
msgstr ""
"R.QRAYLEIGH: função de densidade da probabilidade da distribuição Rayleigh"

#: ../plugins/fn-r/functions.c:1119
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the Rayleigh distribution."
msgstr ""
"Esta função devolve a função de quantil de probabilidade, i.e., o inverso da "
"função de distribuição cumulativa, da distribuição Rayleigh"

#: ../plugins/fn-r/functions.c:1138
msgid "R.DSNORM:probability density function of the skew-normal distribution"
msgstr ""
"R.DSNORM: função de densidade da probabilidade da distribuição de inclinação "
"normal"

#: ../plugins/fn-r/functions.c:1141 ../plugins/fn-r/functions.c:1167
#: ../plugins/fn-r/functions.c:1195
msgid "location:the location parameter of the distribution"
msgstr "localização: o parâmetro de localização da distribuição"

#: ../plugins/fn-r/functions.c:1144
msgid ""
"This function returns the probability density function of the skew-normal "
"distribution."
msgstr ""
"Esta função devolve a função de densidade da probabilidade da distribuição "
"de inclinação normal."

#: ../plugins/fn-r/functions.c:1164
msgid ""
"R.PSNORM:cumulative distribution function of the skew-normal distribution"
msgstr ""
"R.PSNORM: função de distribuição cumulativa da distribuição de inclinação "
"normal"

#: ../plugins/fn-r/functions.c:1171
msgid ""
"This function returns the cumulative distribution function of the skew-"
"normal distribution."
msgstr ""
"Esta função devolve a função de distribuição cumulativa da distribuição de "
"inclinação normal."

#: ../plugins/fn-r/functions.c:1192
msgid "R.QSNORM:probability quantile function of the skew-normal distribution"
msgstr "R.QSNORM: função de probalilidade da distribuição de inclinação normal"

#: ../plugins/fn-r/functions.c:1199
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the skew-normal distribution."
msgstr ""
"Esta função devolve o inverso da função de distribuição cumulativa da "
"distribuição de inclinação normal."

#: ../plugins/fn-r/functions.c:1220
msgid "R.DST:probability density function of the skew-t distribution"
msgstr ""
"R.DST: função de densidade da probabilidade da distribuição de inclinação t"

#: ../plugins/fn-r/functions.c:1222 ../plugins/fn-r/functions.c:1246
#: ../plugins/fn-r/functions.c:1272 ../plugins/fn-r/functions.c:1298
#: ../plugins/fn-r/functions.c:1320 ../plugins/fn-r/functions.c:1344
msgid "n:the number of degrees of freedom of the distribution"
msgstr "n: o número de graus de liberdade da distribuição"

#: ../plugins/fn-r/functions.c:1225
msgid ""
"This function returns the probability density function of the skew-t "
"distribution."
msgstr ""
"Esta função devolve a função de densidade da probabilidade da distribuição "
"de inclinação t."

#: ../plugins/fn-r/functions.c:1244
msgid "R.PST:cumulative distribution function of the skew-t distribution"
msgstr ""
"R.PST: função de distribuição cumulativa da distribuição de inclinação t"

#: ../plugins/fn-r/functions.c:1250
msgid ""
"This function returns the cumulative distribution function of the skew-t "
"distribution."
msgstr ""
"Esta função devolve a função de distribuição cumulativa da distribuição de "
"inclinação t"

#: ../plugins/fn-r/functions.c:1270
msgid "R.QST:probability quantile function of the skew-t distribution"
msgstr "R.QST: função de probalilidade da distribuição de inclinação t"

#: ../plugins/fn-r/functions.c:1276
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the skew-t distribution."
msgstr ""
"Esta função devolve o inverso da função de distribuição cumulativa da "
"distribuição de inclinação t."

#: ../plugins/fn-r/functions.c:1296
msgid "R.DT:probability density function of the Student t distribution"
msgstr "R.DT: função de densidade da probabilidade da distribuição Student-t"

#: ../plugins/fn-r/functions.c:1300
msgid ""
"This function returns the probability density function of the Student t "
"distribution."
msgstr ""
"Esta função devolve a função de densidade da probabilidade da distribuição "
"Student-t."

#: ../plugins/fn-r/functions.c:1318
msgid "R.PT:cumulative distribution function of the Student t distribution"
msgstr "R.PT: função de distribuição cumulativa da distribuição t de Student"

#: ../plugins/fn-r/functions.c:1323
msgid ""
"This function returns the cumulative distribution function of the Student t "
"distribution."
msgstr ""
"Esta função devolve a função de distribuição cumulativa da distribuição t de "
"Student"

#: ../plugins/fn-r/functions.c:1342
msgid "R.QT:probability quantile function of the Student t distribution"
msgstr "R.QT: função de probalilidade da distribuição t de Student"

#: ../plugins/fn-r/functions.c:1347
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the Student t distribution."
msgstr ""
"Esta função devolve o inverso da função de distribuição cumulativa da "
"distribuição t de Student."

#: ../plugins/fn-r/functions.c:1366
msgid ""
"R.PTUKEY:cumulative distribution function of the Studentized range "
"distribution"
msgstr ""
"R.PTUKEY: função de distribuição cumulativa da distribuição de intervalo "
"Studentized"

#: ../plugins/fn-r/functions.c:1368 ../plugins/fn-r/functions.c:1396
msgid "nmeans:the number of means"
msgstr "nmédias: número de médias"

#: ../plugins/fn-r/functions.c:1370 ../plugins/fn-r/functions.c:1398
msgid "nranges:the number of ranges; default is 1"
msgstr "nint: número de intervalos; predefinido como 1"

#: ../plugins/fn-r/functions.c:1373
msgid ""
"This function returns the cumulative distribution function of the "
"Studentized range distribution."
msgstr ""
"Esta função devolve a função de distribuição cumulativa da distribuição de "
"intervalo Studentized."

#: ../plugins/fn-r/functions.c:1394
msgid ""
"R.QTUKEY:probability quantile function of the Studentized range distribution"
msgstr ""
"R.QTUKEY: função de probalilidade da distribuição de intervalo Studentized"

#: ../plugins/fn-r/functions.c:1401
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the Studentized range "
"distribution."
msgstr ""
"Esta função devolve o inverso da função de distribuição cumulativa da "
"distribuição de intervalo Studentized."

#: ../plugins/fn-r/functions.c:1422
msgid "R.DWEIBULL:probability density function of the Weibull distribution"
msgstr ""
"R.DWEIBULL: função de densidade da probabilidade da distribuição Weibull"

#: ../plugins/fn-r/functions.c:1427
msgid ""
"This function returns the probability density function of the Weibull "
"distribution."
msgstr ""
"Esta função devolve a função de densidade da probabilidade da distribuição "
"Weibull."

#: ../plugins/fn-r/functions.c:1446
msgid "R.PWEIBULL:cumulative distribution function of the Weibull distribution"
msgstr "R.PWEIBULL: função de distribuição cumulativa da distribuição Weibull"

#: ../plugins/fn-r/functions.c:1452
msgid ""
"This function returns the cumulative distribution function of the Weibull "
"distribution."
msgstr ""
"Esta função devolve a função de distribuição cumulativa da distribuição "
"Weibull."

#: ../plugins/fn-r/functions.c:1472
msgid "R.QWEIBULL:probability quantile function of the Weibull distribution"
msgstr "R.QWEIBULL: função de probalilidade da distribuição Weibull"

#: ../plugins/fn-r/functions.c:1478
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the Weibull distribution."
msgstr ""
"Esta função devolve o inverso da função de distribuição cumulativa da "
"distribuição Weibull."

#: ../plugins/fn-random/functions.c:47
msgid "RAND:a random number between zero and one"
msgstr "ALEATÓRIO: um número aleatório entre 0 e 1"

#: ../plugins/fn-random/functions.c:64
msgid ""
"RANDUNIFORM:random variate from the uniform distribution from @{a} to @{b}"
msgstr ""
"ALEATÓRIOUNIF: variação aleatória da distribuição uniforme de @{a} a @{b}"

#: ../plugins/fn-random/functions.c:65
msgid "a:lower limit of the uniform distribution"
msgstr "a: limite inferior da distribuição uniforme"

#: ../plugins/fn-random/functions.c:66
msgid "b:upper limit of the uniform distribution"
msgstr "b: limite superior da distribuição uniforme"

#: ../plugins/fn-random/functions.c:67
msgid "If @{a} > @{b} RANDUNIFORM returns #NUM!"
msgstr "Se @{a} > @{b} devolve #NUM!"

#: ../plugins/fn-random/functions.c:89
msgid "RANDDISCRETE:random variate from a finite discrete distribution"
msgstr "ALEATÓRIODISC: variação aleatória  da distribuição finita discreta"

#: ../plugins/fn-random/functions.c:90
msgid "val_range:possible values of the random variable"
msgstr "int_val: valores possíveis da variável aleatória"

#: ../plugins/fn-random/functions.c:91
msgid ""
"prob_range:probabilities of the corresponding values in @{val_range}, "
"defaults to equal probabilities"
msgstr ""
"int_prob: probabilidades dos valores correspondentes em @{int_val}; "
"predefinido como probabilidades iguais"

#: ../plugins/fn-random/functions.c:93
msgid ""
"RANDDISCRETE returns one of the values in the @{val_range}. The "
"probabilities for each value are given in the @{prob_range}."
msgstr ""
"ALEATÓRIODISC devolve um dos valores em @{int_val}. As probabilidades para "
"cada valor são dadas em @{int_prob}."

#: ../plugins/fn-random/functions.c:95
msgid ""
"If the sum of all values in @{prob_range} is not one, RANDDISCRETE returns "
"#NUM!"
msgstr ""
"Se a soma de todos os valores em @{int_prob} não for um, devolve #NUM!."

#: ../plugins/fn-random/functions.c:96
msgid ""
"If @{val_range} and @{prob_range} are not the same size, RANDDISCRETE "
"returns #NUM!"
msgstr ""
"Se @{int_val} e @{int_prob} não tiverem o mesmo tamanho, devolve #NUM!."

#: ../plugins/fn-random/functions.c:97
msgid ""
"If @{val_range} or @{prob_range} is not a range, RANDDISCRETE returns #VALUE!"
msgstr "Se @{int_val} ou @{int_prob} não forem um intervalo, devolve #VALOR!."

#: ../plugins/fn-random/functions.c:175
msgid "RANDEXP:random variate from an exponential distribution"
msgstr "ALEATÓRIOEXP: variação aleatória da distribuição exponencial"

#: ../plugins/fn-random/functions.c:176
msgid "b:parameter of the exponential distribution"
msgstr "b: parâmetro da distribuição exponencial"

#: ../plugins/fn-random/functions.c:194
msgid "RANDPOISSON:random variate from a Poisson distribution"
msgstr "ALEATÓRIOPOISSON: variação aleatória da distribuição Poisson"

#: ../plugins/fn-random/functions.c:195
msgid "λ:parameter of the Poisson distribution"
msgstr "λ: parâmetro da distribuição Poisson"

#: ../plugins/fn-random/functions.c:196
msgid "If @{λ} < 0 RANDPOISSON returns #NUM!"
msgstr "Se @{λ} < 0 devolve #NUM!"

#: ../plugins/fn-random/functions.c:218
msgid "RANDBINOM:random variate from a binomial distribution"
msgstr "ALEATÓRIOBINOM: variação aleatória da distribuição binomial"

#: ../plugins/fn-random/functions.c:219 ../plugins/fn-random/functions.c:283
#: ../plugins/fn-random/functions.c:589
msgid "p:probability of success in a single trial"
msgstr "p: probabilidade de sucesso numa única tentativa"

#: ../plugins/fn-random/functions.c:220
msgid "n:number of trials"
msgstr "n: número de tentativas"

#: ../plugins/fn-random/functions.c:221
msgid "If @{p} < 0 or @{p} > 1 RANDBINOM returns #NUM!"
msgstr "Se @{p} < 0 ou @{p} > 1 DEVOLVE #NUM!"

#: ../plugins/fn-random/functions.c:222
msgid "If @{n} < 0 RANDBINOM returns #NUM!"
msgstr "sE @{n} < 0 DEVOLVE #NUM!"

#: ../plugins/fn-random/functions.c:244
msgid ""
"RANDBETWEEN:a random integer number between and including @{bottom} and "
"@{top}"
msgstr ""
"ALEATÓRIOENTRE: um número inteiro aleatório entre e incluindo @{último} e "
"@{primeiro}"

#: ../plugins/fn-random/functions.c:246
msgid "bottom:lower limit"
msgstr "último: limite inferior"

#: ../plugins/fn-random/functions.c:247
msgid "top:upper limit"
msgstr "primeiro: limite superior"

#: ../plugins/fn-random/functions.c:248
msgid "If @{bottom} > @{top}, RANDBETWEEN returns #NUM!"
msgstr "Se @{último} > @{primeiro}, devolve #NUM!"

#: ../plugins/fn-random/functions.c:282
msgid "RANDNEGBINOM:random variate from a negative binomial distribution"
msgstr ""
"ALEATÓRIONEGBINOM: variação aleatória da distribuição binomial negativa"

#: ../plugins/fn-random/functions.c:284
msgid "n:number of failures"
msgstr "n: número de falhas"

#: ../plugins/fn-random/functions.c:285
msgid "If @{p} < 0 or @{p} > 1 RANDNEGBINOM returns #NUM!"
msgstr "Se @{p} < 0 ou @{p} > 1 devolve #NUM!"

#: ../plugins/fn-random/functions.c:286
msgid "If @{n} < 1 RANDNEGBINOM returns #NUM!"
msgstr "Se @{n} < 1 devolve #NUM!"

#: ../plugins/fn-random/functions.c:307
msgid "RANDBERNOULLI:random variate from a Bernoulli distribution"
msgstr "ALEATÓRIOBERNOULLI: variação aleatória da distribuição Bernoulli"

#: ../plugins/fn-random/functions.c:308 ../plugins/fn-stat/functions.c:1014
msgid "p:probability of success"
msgstr "p probabilidade de sucesso"

#: ../plugins/fn-random/functions.c:309
msgid "If @{p} < 0 or @{p} > 1 RANDBERNOULLI returns #NUM!"
msgstr "Se @{p} < 0 ou @{p} > 1 devolve #NUM!"

#: ../plugins/fn-random/functions.c:331
msgid "RANDNORM:random variate from a normal distribution"
msgstr "ALEATÓRIONORMAL: variação aleatória da distribuição normal"

#: ../plugins/fn-random/functions.c:332
msgid "μ:mean of the distribution"
msgstr "μ: média da distribuição"

#: ../plugins/fn-random/functions.c:333 ../plugins/fn-random/functions.c:381
msgid "σ:standard deviation of the distribution"
msgstr "σ: desvio padrão da distribuição"

#: ../plugins/fn-random/functions.c:334
msgid "If @{σ} < 0, RANDNORM returns #NUM!"
msgstr "Se @{σ} < 0, devolve #NUM!"

#: ../plugins/fn-random/functions.c:356
msgid "RANDCAUCHY:random variate from a Cauchy or Lorentz distribution"
msgstr "ALEATÓRIOCAUCHY: variação aleatória da distribuição Cauchy ou Lorentz"

#: ../plugins/fn-random/functions.c:357
msgid "a:scale parameter of the distribution"
msgstr "a: parâmetro escala da distribuição"

#: ../plugins/fn-random/functions.c:358
msgid "If @{a} < 0 RANDCAUCHY returns #NUM!"
msgstr "Se @{a} < 0 devolve #NUM!"

#: ../plugins/fn-random/functions.c:379
msgid "RANDLOGNORM:random variate from a lognormal distribution"
msgstr "ALEATÓRIOLOGNORM: : variação aleatória da distribuição log-normal"

#: ../plugins/fn-random/functions.c:380
msgid "ζ:parameter of the lognormal distribution"
msgstr "ζ: parâmetro da distribuição log-normal"

#: ../plugins/fn-random/functions.c:382
msgid "If @{σ} < 0, RANDLOGNORM returns #NUM!"
msgstr "Se @{σ} < 0, devolve #NUM!"

#: ../plugins/fn-random/functions.c:401
msgid "RANDWEIBULL:random variate from a Weibull distribution"
msgstr "ALEATÓRIOWEIBULL: variação aleatória da distribuição Weibull"

#: ../plugins/fn-random/functions.c:402
msgid "a:scale parameter of the Weibull distribution"
msgstr "a: parâmetro escala da distribuição Weibull"

#: ../plugins/fn-random/functions.c:403
msgid "b:shape parameter of the Weibull distribution"
msgstr "b: parâmetro forma da distribuição Weibull"

#: ../plugins/fn-random/functions.c:422
msgid "RANDLAPLACE:random variate from a Laplace distribution"
msgstr "ALEATÓRIOLAPLACE: variação aleatória da distribuição Laplace"

#: ../plugins/fn-random/functions.c:423
msgid "a:parameter of the Laplace distribution"
msgstr "a: parâmetro da distribuição Laplace"

#: ../plugins/fn-random/functions.c:441
msgid "RANDRAYLEIGH:random variate from a Rayleigh distribution"
msgstr "ALEATÓRIORAYLEIGH: variação aleatória da distribuição Rayleigh"

#: ../plugins/fn-random/functions.c:442 ../plugins/fn-random/functions.c:462
msgid "σ:scale parameter of the Rayleigh distribution"
msgstr "σ: parâmetro escala da distribuição Rayleigh"

#: ../plugins/fn-random/functions.c:460
msgid ""
"RANDRAYLEIGHTAIL:random variate from the tail of a Rayleigh distribution"
msgstr ""
"ALEATÓRIOCAUDARAYLEIGH: variação aleatória da cauda da distribuição Rayleigh"

#: ../plugins/fn-random/functions.c:461 ../plugins/fn-random/functions.c:800
msgid "a:lower limit of the tail"
msgstr "a: limite inferior da cauda"

#: ../plugins/fn-random/functions.c:481
msgid "RANDGAMMA:random variate from a Gamma distribution"
msgstr "ALEATÓRIOGAMA: variação aleatória da distribuição Gama"

#: ../plugins/fn-random/functions.c:482
msgid "a:shape parameter of the Gamma distribution"
msgstr "a: parâmetro forma da distribuição Gama"

#: ../plugins/fn-random/functions.c:483
msgid "b:scale parameter of the Gamma distribution"
msgstr "b: parâmetro escala da distribuição Gama"

#: ../plugins/fn-random/functions.c:484
msgid "If @{a} ≤ 0, RANDGAMMA returns #NUM!"
msgstr "Se @{a} ≤ 0, devolve #NUM!"

#: ../plugins/fn-random/functions.c:506
msgid "RANDPARETO:random variate from a Pareto distribution"
msgstr "ALEATÓRIOPARETO: variação aleatória da distribuição Pareto"

#: ../plugins/fn-random/functions.c:507
msgid "a:parameter of the Pareto distribution"
msgstr "a: parâmetro da distrobuição Pareto"

#: ../plugins/fn-random/functions.c:508
msgid "b:parameter of the Pareto distribution"
msgstr "b: parâmetro da distribuição Pareto"

#: ../plugins/fn-random/functions.c:527
msgid "RANDFDIST:random variate from an F distribution"
msgstr "ALEATÓRIODISTF: variação aleatória da distribuição F"

#: ../plugins/fn-random/functions.c:528
msgid "df1:numerator degrees of freedom"
msgstr "gl1: numerador de graus de liberdade"

#: ../plugins/fn-random/functions.c:529
msgid "df2:denominator degrees of freedom"
msgstr "gl2: denominador de graus de liberdade"

#: ../plugins/fn-random/functions.c:548
msgid "RANDBETA:random variate from a Beta distribution"
msgstr "ALEATÓRIOBETA:: variação aleatória da distribuição Beta"

#: ../plugins/fn-random/functions.c:549
msgid "a:parameter of the Beta distribution"
msgstr "a: parâmetro da distribuição Beta"

#: ../plugins/fn-random/functions.c:550
msgid "b:parameter of the Beta distribution"
msgstr "b: parâmetro da distribuição Beta"

#: ../plugins/fn-random/functions.c:569
msgid "RANDLOGISTIC:random variate from a logistic distribution"
msgstr "ALEATÓRIOLOGGÍST: variação aleatória da distribuição logística"

#: ../plugins/fn-random/functions.c:570
msgid "a:parameter of the logistic distribution"
msgstr "a: parâmetro da distribuição logística"

#: ../plugins/fn-random/functions.c:588
msgid "RANDGEOM:random variate from a geometric distribution"
msgstr "ALEATÓRIOGEOM: variação aleatória da distribuição geométrica"

#: ../plugins/fn-random/functions.c:590
msgid "If @{p} < 0 or @{p} > 1 RANDGEOM returns #NUM!"
msgstr "Se @{p} < 0 ou @{p} > 1, devolve #NUM!"

#: ../plugins/fn-random/functions.c:611
msgid "RANDHYPERG:random variate from a hypergeometric distribution"
msgstr "ALEATÓRIOHIPERG: variação aleatória da distribuição hipergeométrica"

#: ../plugins/fn-random/functions.c:612
msgid "n1:number of objects of type 1"
msgstr "n1: número de objetos de tipo 1"

#: ../plugins/fn-random/functions.c:613
msgid "n2:number of objects of type 2"
msgstr "n2: número de objetos de tipo 2"

#: ../plugins/fn-random/functions.c:614
msgid "t:total number of objects selected"
msgstr "t: total de objetos selecionados"

#: ../plugins/fn-random/functions.c:636
msgid "RANDLOG:random variate from a logarithmic distribution"
msgstr "ALEATÓRIOLOG: variação aleatória da distribuição logarítmica"

#: ../plugins/fn-random/functions.c:637 ../plugins/fn-stat/functions.c:559
#: ../plugins/fn-stat/functions.c:1082 ../plugins/fn-stat/functions.c:1140
#: ../plugins/fn-stat/functions.c:1332 ../plugins/fn-stat/functions.c:1622
#: ../plugins/fn-stat/functions.c:2002
msgid "p:probability"
msgstr "p: probabilidade"

#: ../plugins/fn-random/functions.c:638
msgid "If @{p} < 0 or @{p} > 1 RANDLOG returns #NUM!"
msgstr "Se @{p} < 0 ou @{p} > 1, devolve #NUM!"

#: ../plugins/fn-random/functions.c:659
msgid "RANDCHISQ:random variate from a Chi-square distribution"
msgstr "ALEATÓRIOCHIQ: variação aleatória da distribuição chi quadrado"

#: ../plugins/fn-random/functions.c:660 ../plugins/fn-random/functions.c:679
#: ../plugins/fn-random/functions.c:949
msgid "df:degrees of freedom"
msgstr "gl: graus de liberdade"

#: ../plugins/fn-random/functions.c:678
msgid "RANDTDIST:random variate from a Student t distribution"
msgstr "ALEATÓRIODISTT: variação aleatória da distribuição t de Student"

#: ../plugins/fn-random/functions.c:697
msgid "RANDGUMBEL:random variate from a Gumbel distribution"
msgstr "ALEATÓRIOGUMBEL: variação aleatória da distribuição Gumbel"

#: ../plugins/fn-random/functions.c:698
msgid "a:parameter of the Gumbel distribution"
msgstr "a: parâmetro da distribuição Gumbel"

#: ../plugins/fn-random/functions.c:699
msgid "b:parameter of the Gumbel distribution"
msgstr "b: parâmetro da distribuição Gumbel"

#: ../plugins/fn-random/functions.c:700
msgid "type:type of the Gumbel distribution, defaults to 1"
msgstr "tipo: tipo da distribuição Gumbel, predefinido como 1"

#: ../plugins/fn-random/functions.c:701
msgid "If @{type} is neither 1 nor 2, RANDGUMBEL returns #NUM!"
msgstr "Se @{tipo} não for nem 1 nem 2, devolve #NUM!"

#: ../plugins/fn-random/functions.c:726
msgid "RANDLEVY:random variate from a Lévy distribution"
msgstr "ALEATÓRIOLEVY: variação aleatória da distribuição Levy"

#: ../plugins/fn-random/functions.c:727
msgid "c:parameter of the Lévy distribution"
msgstr "c: parâmetro da distribuição Levy"

#: ../plugins/fn-random/functions.c:728
msgid "α:parameter of the Lévy distribution"
msgstr "α: parâmetro da distribuição Levy"

#: ../plugins/fn-random/functions.c:729
msgid "β:parameter of the Lévy distribution, defaults to 0"
msgstr "β: parâmetro da distribuição Levy, predefinido como 0"

#: ../plugins/fn-random/functions.c:730
msgid ""
"For @{α} = 1, @{β}=0, the Lévy distribution reduces to the Cauchy (or "
"Lorentzian) distribution."
msgstr ""
"Para @{α} = 1, @{β}=0, a distribuição Lévy reduz-se à distribuição Cauchy "
"(ou Lorentziana)."

#: ../plugins/fn-random/functions.c:732
msgid ""
"For @{α} = 2, @{β}=0, the Lévy distribution reduces to the normal "
"distribution."
msgstr ""
"Para @{α} = 2, @{β}=0, a distribuição Lévy reduz-se à distribuição normal."

#: ../plugins/fn-random/functions.c:734
msgid "If @{α} ≤ 0 or @{α} > 2, RANDLEVY returns #NUM!"
msgstr "Se @{α} ≤ 0 ou @{α} > 2, devolve #NUM!"

#: ../plugins/fn-random/functions.c:735
msgid "If @{β} < -1 or @{β} > 1, RANDLEVY returns #NUM!"
msgstr "Se @{β} < -1 ou @{β} > 1, devolve #NUM!"

#: ../plugins/fn-random/functions.c:758
msgid "RANDEXPPOW:random variate from an exponential power distribution"
msgstr ""
"ALEATÓRIOPOTEXP: variação aleatória da distribuição de potência exponencial"

#: ../plugins/fn-random/functions.c:759
msgid "a:scale parameter of the exponential power distribution"
msgstr "a: parâmetro escala da distribuição de potência exponencial"

#: ../plugins/fn-random/functions.c:760
msgid "b:exponent of the exponential power distribution"
msgstr "b: expoente da distribuição de potência exponencial"

#: ../plugins/fn-random/functions.c:761
msgid ""
"For @{b} = 1 the exponential power distribution reduces to the Laplace "
"distribution."
msgstr ""
"Para @{b} = 1, a distribuição de potência exponencial reduz-se à "
"distribuição Laplace."

#: ../plugins/fn-random/functions.c:763
msgid ""
"For @{b} = 2 the exponential power distribution reduces to the normal "
"distribution with σ = a/sqrt(2)"
msgstr ""
"Para @{b} = 2 a distribuição de potência exponencial reduz-se à distribuição "
"normal com σ = a/RAIZQ(2)"

#: ../plugins/fn-random/functions.c:783
msgid "RANDLANDAU:random variate from the Landau distribution"
msgstr "ALEATÓRIOLANDAU: variação aleatória da distribuição Landau"

#: ../plugins/fn-random/functions.c:799
msgid ""
"RANDNORMTAIL:random variate from the upper tail of a normal distribution "
"with mean 0"
msgstr ""
"ALEATÓRIOCAUDANORMAL: variação aleatória da cauda superior da distribuição "
"normal com média 0"

#: ../plugins/fn-random/functions.c:801
msgid "σ:standard deviation of the normal distribution"
msgstr "σ: desvio padrão da distribuição normal"

#: ../plugins/fn-random/functions.c:802
msgid ""
"The method is based on Marsaglia's famous rectangle-wedge-tail algorithm "
"(Ann Math Stat 32, 894-899 (1961)), with this aspect explained in Knuth, v2, "
"3rd ed, p139, 586 (exercise 11)."
msgstr ""
"O método é baseado no famoso algoritmo retângulo-cunha-cauda de Marsaglia's "
"(Ann Math Stat 32, 894-899 (1961)), com este aspeto explicado em Knuth, v2, "
"3ª ed, p139, 586 (exercício 11)."

#: ../plugins/fn-random/functions.c:823
msgid ""
"SIMTABLE:one of the values in the given argument list depending on the round "
"number of the simulation tool"
msgstr ""
"TABELASIM: um dos valores da lista de argumentos indicada, dependendo do "
"número de execuções da ferramenta de simulação"

#: ../plugins/fn-random/functions.c:825
msgid "d1:first value"
msgstr "d1: primeiro valor"

#: ../plugins/fn-random/functions.c:826
msgid "d2:second value"
msgstr "d2: segundo valor"

#: ../plugins/fn-random/functions.c:827
msgid ""
"SIMTABLE returns one of the values in the given argument list depending on "
"the round number of the simulation tool. When the simulation tool is not "
"activated, SIMTABLE returns @{d1}.\n"
"With the simulation tool and the SIMTABLE function you can test given "
"decision variables. Each SIMTABLE function contains the possible values of a "
"simulation variable. In most valid simulation models you should have the "
"same number of values @{dN} for all decision variables.  If the simulation "
"is run more rounds than there are values defined, SIMTABLE returns #N/A! "
"error (e.g. if A1 contains `=SIMTABLE(1)' and A2 `=SIMTABLE(1,2)', A1 yields "
"#N/A! error on the second round).\n"
"The successive use of the simulation tool also requires that you give to the "
"tool at least one input variable having RAND() or any other "
"RAND<distribution name>() function in it. On each round, the simulation tool "
"iterates for the given number of rounds over all the input variables to "
"reevaluate them. On each iteration, the values of the output variables are "
"stored, and when the round is completed, descriptive statistical information "
"is created according to the values."
msgstr ""
"TABELASIM devolve um dos valores na lista de argumentos indicada dependendo "
"no número de execuções da ferramenta de simulação. Quando a ferramenta de "
"simulação não está ativa, TABELASIM devolve @d1.\n"
"Com a ferramenta de simulação e a função TABELASIM pode testar variáveis de "
"decisão especificadas. Cada função TABELASIM contém os valores possíveis de "
"uma variável de simulação. Na maioria dos modelos de simulação válidos "
"deverá ter o mesmo número de valores @dN para todas as variáveis de decisão. "
"Se a simulação for executada mais vezes do que o número de valores "
"definidos, TABELASIM devolve #N/D! (por ex. se A1 contém \"=TABELASIM(1)\" e "
"A2 \"=TABELASIM(1,2)\", A1 conterá o erro #N/D! à segunda execução).\n"
"A utilização sucessiva da ferramenta de simulação também requer que passe à "
"ferramenta pelo menos uma variável de entrada contendo ALEATÓRIO() ou "
"qualquer outra função ALEATÓRIO<nome distribuicao>(). Em cada execução, a "
"ferramenta de simulação itera o dado número de vezes todas as variáveis de "
"entrada para as reavaliar. A cada iteração, os valores das variáveis de "
"saída são armazenados e, quando a execução termina, informação descritiva "
"estatística é criada de acordo com os valores."

#: ../plugins/fn-random/functions.c:891
msgid "RANDSNORM:random variate from a skew-normal distribution"
msgstr ""
"ALEATÓRIONORMALI: variação aleatória da distribuição de inclinação normal"

#: ../plugins/fn-random/functions.c:892
msgid "𝛼:shape parameter of the skew-normal distribution, defaults to 0"
msgstr ""
"𝛼: parâmetro forma da distribuição de inclinação normal, predefinido como 0"

#: ../plugins/fn-random/functions.c:894
msgid "𝜉:location parameter of the skew-normal distribution, defaults to 0"
msgstr ""
"𝜉: parâmetro localização da distribuição de inclinação normal, predefinido "
"como 0"

#: ../plugins/fn-random/functions.c:896
msgid "𝜔:scale parameter of the skew-normal distribution, defaults to 1"
msgstr ""
"𝜔: parâmetro escala da distribuição de inclinação normal, predefinido como 1"

#: ../plugins/fn-random/functions.c:898
msgid ""
"The random variates are drawn from a skew-normal distribution with shape "
"parameter @{𝛼}. When @{𝛼}=0, the skewness vanishes, and we obtain the "
"standard normal density; as 𝛼 increases (in absolute value), the skewness of "
"the distribution increases; when @{𝛼} approaches infinity  the density "
"converges to the so-called half-normal (or folded normal) density function; "
"if the sign of @{𝛼} changes, the density is reflected on the opposite side "
"of the vertical axis."
msgstr ""
"As variações aleatórias são desenhadas a partir de uma distribuição de "
"inclinação normal com parâmetro forma @{𝛼}. Quando @{𝛼} = 0, a inclinação "
"desaparece e obtemos a densidade normal padrão; se @{𝛼} aumentar (em valor "
"absoluto), a inclinação da distribuição aumenta; quando @{𝛼} se aproxima de "
"infinito, a densidade converge para a chamada função de densidade semi-"
"normal (ou normal dobrada); se o sinal de @{𝛼} se alterar, a densidade é "
"refletida no lado oposto do eixo vertical."

#: ../plugins/fn-random/functions.c:908
msgid ""
"The mean of a skew-normal distribution with location parameter @{𝜉}=0 is not "
"0."
msgstr ""
"A média da distribuição de inclinação normal com parâmetro de localização "
"@{𝜉} = 0 não é 0."

#: ../plugins/fn-random/functions.c:910
msgid ""
"The standard deviation of a skew-normal distribution with scale parameter "
"@{𝜔}=1 is not 1."
msgstr ""
"O desvio padrão de uma distribuição de inclinação normal com parâmetro de "
"escala @{𝜔}=1 não é 1."

#: ../plugins/fn-random/functions.c:912
msgid "The skewness of a skew-normal distribution is in general not @{𝛼}."
msgstr ""
"A inclinação de uma distribuição de inclinação normal não é geralmente @{𝛼}."

#: ../plugins/fn-random/functions.c:913
msgid "If @{𝜔} < 0, RANDSNORM returns #NUM!"
msgstr "Se @{𝜔} < 0, devolve #NUM!"

#: ../plugins/fn-random/functions.c:948
msgid "RANDSTDIST:random variate from a skew-t distribution"
msgstr "ALEATÓRIODISTT: variação aleatória da distribuição de inclinação t"

#: ../plugins/fn-random/functions.c:950
msgid "𝛼:shape parameter of the skew-t distribution, defaults to 0"
msgstr ""
"𝛼: parâmetro forma da da distribuição de inclinação t, predefinido como 0"

#: ../plugins/fn-random/functions.c:951
msgid "The mean of a skew-t distribution is not 0."
msgstr "A média da da distribuição de inclinação t não é 0."

#: ../plugins/fn-random/functions.c:952
msgid "The standard deviation of a skew-t distribution is not 1."
msgstr "O desvio padrão da da distribuição de inclinação t não é 1."

#: ../plugins/fn-random/functions.c:953
msgid "The skewness of a skew-t distribution is in general not @{𝛼}."
msgstr "A inclinação da da distribuição de inclinação t não é geralmente @{𝛼}."

#: ../plugins/fn-stat/functions.c:48
msgid ""
"Numbers, text and logical values are included in the calculation too. If the "
"cell contains text or the argument evaluates to FALSE, it is counted as "
"value zero (0). If the argument evaluates to TRUE, it is counted as one (1). "
"Note that empty cells are not counted."
msgstr ""
"Números, texto e valores lógicos são também incluídos nos cálculos. Se a "
"célula contiver texto ou o argumento for avaliado como FALSO, será contado "
"como valor zero (0). Se o argumento for avaliado como VERDADEIRO, será "
"contado como um (1). Note que células vazias não são contadas."

#: ../plugins/fn-stat/functions.c:53
msgid "VARP:variance of an entire population"
msgstr "VARP: variância de uma população inteira"

#: ../plugins/fn-stat/functions.c:54 ../plugins/fn-stat/functions.c:79
#: ../plugins/fn-stat/functions.c:108 ../plugins/fn-stat/functions.c:135
#: ../plugins/fn-stat/functions.c:2727 ../plugins/fn-stat/functions.c:2756
#: ../plugins/fn-stat/functions.c:2782 ../plugins/fn-stat/functions.c:2809
msgid "area1:first cell area"
msgstr "área1: a primeira área de células"

#: ../plugins/fn-stat/functions.c:55 ../plugins/fn-stat/functions.c:80
#: ../plugins/fn-stat/functions.c:109 ../plugins/fn-stat/functions.c:136
#: ../plugins/fn-stat/functions.c:2728 ../plugins/fn-stat/functions.c:2757
#: ../plugins/fn-stat/functions.c:2783 ../plugins/fn-stat/functions.c:2810
msgid "area2:second cell area"
msgstr "área2: a segunda área de células"

#: ../plugins/fn-stat/functions.c:56
msgid "VARP is also known as the N-variance."
msgstr "VARP também é conhecida como variância N."

#: ../plugins/fn-stat/functions.c:59 ../plugins/fn-stat/functions.c:88
msgid "wiki:en:Variance"
msgstr "wiki:pt:Variância"

#: ../plugins/fn-stat/functions.c:60 ../plugins/fn-stat/functions.c:89
msgid "wolfram:Variance.html"
msgstr "wolfram:Variance.html"

#: ../plugins/fn-stat/functions.c:78
msgid "VAR:sample variance of the given sample"
msgstr "VAR: variância amostra da amostra indicada"

#: ../plugins/fn-stat/functions.c:81
msgid "VAR is also known as the N-1-variance."
msgstr "VAR também é conhecida por variância N-1."

#: ../plugins/fn-stat/functions.c:82 ../plugins/fn-stat/functions.c:2732
msgid ""
"Since the N-1-variance includes Bessel's correction, whereas the N-variance "
"calculated by VARPA or VARP does not, under reasonable conditions the N-1-"
"variance is an unbiased estimator of the variance of the population from "
"which the sample is drawn."
msgstr ""
"Uma vez que a variância N-1 inclui a correção de Bessel e considerando que a "
"variância N calculada por VARPA ou VARP não, sob condições razoáveis a "
"variância N-1 é uma estimativa da variância da população da qual a amostra é "
"tirada."

#: ../plugins/fn-stat/functions.c:107
msgid "STDEV:sample standard deviation of the given sample"
msgstr "DESVPAD: desvio padrão da amostra indicada"

#: ../plugins/fn-stat/functions.c:110
msgid "STDEV is also known as the N-1-standard deviation."
msgstr "DESVPAD é também conhecido como desvio padrão N-1."

#: ../plugins/fn-stat/functions.c:111
msgid ""
"To obtain the population standard deviation of a whole population use STDEVP."
msgstr "Para obter o desvio padrão de uma população inteira, use DESVPADP."

#: ../plugins/fn-stat/functions.c:115 ../plugins/fn-stat/functions.c:141
msgid "wiki:en:Standard_deviation"
msgstr "wiki:pt:Desvio_padrão"

#: ../plugins/fn-stat/functions.c:116 ../plugins/fn-stat/functions.c:142
msgid "wolfram:StandardDeviation.html"
msgstr "wolfram:StandardDeviation.html"

#: ../plugins/fn-stat/functions.c:134
msgid "STDEVP:population standard deviation of the given population"
msgstr "DESVPADP: desvio padrão da população inteira indicada"

#: ../plugins/fn-stat/functions.c:137 ../plugins/fn-stat/functions.c:2811
msgid "This is also known as the N-standard deviation"
msgstr "É também conhecido como desvio padrão N"

#: ../plugins/fn-stat/functions.c:160
msgid "RANK:rank of a number in a list of numbers"
msgstr "ORDEM: ordem de um número numa lista de números"

#: ../plugins/fn-stat/functions.c:161 ../plugins/fn-stat/functions.c:213
msgid "x:number whose rank you want to find"
msgstr "x: número cuja ordem quer encontrar"

#: ../plugins/fn-stat/functions.c:163 ../plugins/fn-stat/functions.c:215
msgid "order:0 (descending order) or non-zero (ascending order); defaults to 0"
msgstr "ordem: 0 (descendente) ou não zero (ascendente); predefinido como 0"

#: ../plugins/fn-stat/functions.c:164
msgid "In case of a tie, RANK returns the largest possible rank."
msgstr "Em caso de empate, ORDEM devolve a ordem máxima possível."

#: ../plugins/fn-stat/functions.c:166
msgid ""
"Let us assume that the cells A1, A2, …, A5 contain numbers 11.4, 17.3, 21.3, "
"25.9, and 25.9."
msgstr ""
"Vamos assumir que as células A1, A2, …, A5 contêm os números 11,4, 17,3, "
"21,3, 25,9, e 25,9."

#: ../plugins/fn-stat/functions.c:167
msgid "Then RANK(17.3,A1:A5) equals 4."
msgstr "Então ORDEM(17,3,A1:A5) é igual a 4."

#: ../plugins/fn-stat/functions.c:168
msgid "Then RANK(25.9,A1:A5) equals 1."
msgstr "Então ORDEM(25,9,A1:A5) é igual a 1."

#: ../plugins/fn-stat/functions.c:212
msgid "RANK.AVG:rank of a number in a list of numbers"
msgstr "ORDEM.MÉDIA: ordem de um número numa lista de números"

#: ../plugins/fn-stat/functions.c:216
msgid "In case of a tie, RANK returns the average rank."
msgstr "Em caso de empate, ORDEM.MÉDIA devolve a ordem média."

#: ../plugins/fn-stat/functions.c:217
msgid "This function is Excel 2010 compatible."
msgstr "Esta função é compatível com Excel."

#: ../plugins/fn-stat/functions.c:218
msgid ""
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
"21.3, 25.9, and 25.9."
msgstr ""
"Vamos assumir que as células A1, A2, …, A5 contêm os números 11,4, 17,3, "
"21,3, 25,9, e 25,9."

#: ../plugins/fn-stat/functions.c:219
msgid "Then RANK.AVG(17.3,A1:A5) equals 4."
msgstr "Então ORDEM(17,3,A1:A5) é igual a 4."

#: ../plugins/fn-stat/functions.c:220
msgid "Then RANK.AVG(25.9,A1:A5) equals 1.5."
msgstr "Então ORDEM(25,9,A1:A5) é igual a 1,5."

#: ../plugins/fn-stat/functions.c:270
msgid "TRIMMEAN:mean of the interior of a data set"
msgstr "MÉDIA.INT: média do interior de um conjunto de dados"

#: ../plugins/fn-stat/functions.c:271
msgid "ref:list of numbers whose mean you want to calculate"
msgstr "ref: lista de números que quer calcular"

#: ../plugins/fn-stat/functions.c:272
msgid "fraction:fraction of the data set excluded from the mean"
msgstr "fração: fração do conjunto de dados excluída da média"

#: ../plugins/fn-stat/functions.c:273
msgid ""
"If @{fraction}=0.2 and the data set contains 40 numbers, 8 numbers are "
"trimmed from the data set (40 x 0.2): the 4 largest and the 4 smallest. To "
"avoid a bias, the number of points to be excluded is always rounded down to "
"the nearest even number."
msgstr ""
"Se @{fração}=0,2 e o conjunto de dados contiver 40 números, são excluídos 8 "
"números do conjunto (40 x 0,2); os 4 maiores e os 4 menores. Para evitar "
"conflitos, o número de pontos a excluir é sempre arredondado para o número "
"par mais próximo."

#: ../plugins/fn-stat/functions.c:276 ../plugins/fn-stat/functions.c:788
#: ../plugins/fn-stat/functions.c:2368 ../plugins/fn-stat/functions.c:2411
#: ../plugins/fn-stat/functions.c:2599 ../plugins/fn-stat/functions.c:3044
#: ../plugins/fn-stat/functions.c:3086 ../plugins/fn-stat/functions.c:3132
#: ../plugins/fn-stat/functions.c:3175
msgid ""
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
"21.3, 25.9, and 40.1."
msgstr ""
"Vamos assumir que as células A1, A2, …, A5 contêm os números 11,4, 17,3, "
"21,3, 25,9, e 40,1."

#: ../plugins/fn-stat/functions.c:277
msgid ""
"Then TRIMMEAN(A1:A5,0.2) equals 23.2 and TRIMMEAN(A1:A5,0.4) equals 21.5."
msgstr ""
"Então MÉDIA.INT(A1:A5,0.2) é igual a 23.2 e MÉDIA.INT(A1:A5,0.4) é igual a "
"21.5."

#: ../plugins/fn-stat/functions.c:319
msgid "COVAR:covariance of two data sets"
msgstr "COVAR: covariância de dois conjuntos de dados"

#: ../plugins/fn-stat/functions.c:320 ../plugins/fn-stat/functions.c:350
#: ../plugins/fn-stat/functions.c:380
msgid "array1:first data set"
msgstr "matriz1: o primeiro conjunto de dados"

#: ../plugins/fn-stat/functions.c:321 ../plugins/fn-stat/functions.c:351
msgid "array2:set data set"
msgstr "matriz2: o segundo conjunto de dados"

#: ../plugins/fn-stat/functions.c:322 ../plugins/fn-stat/functions.c:352
#: ../plugins/fn-stat/functions.c:382 ../plugins/fn-stat/functions.c:610
#: ../plugins/fn-stat/functions.c:637 ../plugins/fn-stat/functions.c:930
#: ../plugins/fn-stat/functions.c:958 ../plugins/fn-stat/functions.c:2032
#: ../plugins/fn-stat/functions.c:2062 ../plugins/fn-stat/functions.c:2110
#: ../plugins/fn-stat/functions.c:2190 ../plugins/fn-stat/functions.c:2209
#: ../plugins/fn-stat/functions.c:2233
msgid "Strings and empty cells are simply ignored."
msgstr "Cadeias e células vazias são simplesmente ignoradas."

#: ../plugins/fn-stat/functions.c:324 ../plugins/fn-stat/functions.c:354
#: ../plugins/fn-stat/functions.c:384 ../plugins/fn-stat/functions.c:2540
#: ../plugins/fn-stat/functions.c:3219 ../plugins/fn-stat/functions.c:3285
#: ../plugins/fn-stat/functions.c:4397 ../plugins/fn-stat/functions.c:4454
#: ../plugins/fn-stat/functions.c:4506
msgid ""
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
"21.3, 25.9, and 40.1, and the cells B1, B2, ... B5 23.2, 25.8, 29.9, 33.5, "
"and 42.7."
msgstr ""
"Vamos assumir que as células A1, A2, …, A5 contêm os números 11,4, 17,3, "
"21,3, 25,9, e 40,1, e as células B1, B2, ... B5 23.2, 25.8, 29.9, 33.5, e "
"42.7."

#: ../plugins/fn-stat/functions.c:327 ../plugins/fn-stat/functions.c:357
msgid "Then COVAR(A1:A5,B1:B5) equals 65.858."
msgstr "Então COVAR(A1:A5,B1:B5) é igual a 65,858."

#: ../plugins/fn-stat/functions.c:329 ../plugins/fn-stat/functions.c:359
msgid "wiki:en:Covariance"
msgstr "wiki:pt:Covariância"

#: ../plugins/fn-stat/functions.c:330 ../plugins/fn-stat/functions.c:360
#: ../plugins/fn-stat/functions.c:390
msgid "wolfram:Covariance.html"
msgstr "wolfram:Covariance.html"

#: ../plugins/fn-stat/functions.c:349
msgid "COVARIANCE.S:sample covariance of two data sets"
msgstr "COVARIÂNCIA.S: covariância de dois conjuntos de dados"

#: ../plugins/fn-stat/functions.c:379
msgid "CORREL:Pearson correlation coefficient of two data sets"
msgstr "CORREL: coeficiente de correlação Pearson de dois conjuntos de dados"

#: ../plugins/fn-stat/functions.c:381
msgid "array2:second data set"
msgstr "matriz 2: o segundo conjunto de dados"

#: ../plugins/fn-stat/functions.c:387
msgid "Then CORREL(A1:A5,B1:B5) equals 0.996124788."
msgstr "Então CORREL(A1:A5,B1:B5) é igual a 0.996124788."

#: ../plugins/fn-stat/functions.c:389
msgid "wiki:en:CorrelationCoefficient.html"
msgstr "wiki:pt:Coeficiente_de_correlação_de_Pearson"

#: ../plugins/fn-stat/functions.c:409
msgid ""
"NEGBINOMDIST:probability mass function of the negative binomial distribution"
msgstr ""
"DIST.BIN.NEG: função de probabilidade em massa da distribuição binomial "
"negativa"

#: ../plugins/fn-stat/functions.c:410
msgid "f:number of failures"
msgstr "f: número de falhas"

#: ../plugins/fn-stat/functions.c:411
msgid "t:threshold number of successes"
msgstr "t: número limite de sucessos"

#: ../plugins/fn-stat/functions.c:412
msgid "p:probability of a success"
msgstr "p: probabilidade de sucesso"

#: ../plugins/fn-stat/functions.c:413
msgid "If @{f} or @{t} is a non-integer it is truncated."
msgstr "Se @{f} ou @{t} não forem inteiros, é truncado."

#: ../plugins/fn-stat/functions.c:414
msgid "If (@{f} + @{t} -1) <= 0 this function returns a #NUM! error."
msgstr "Se (@{f} + @{t} -1) <= 0, devolve #NUM!."

#: ../plugins/fn-stat/functions.c:415 ../plugins/fn-stat/functions.c:1016
#: ../plugins/fn-stat/functions.c:1085 ../plugins/fn-stat/functions.c:1337
#: ../plugins/fn-stat/functions.c:1626 ../plugins/fn-stat/functions.c:1659
#: ../plugins/fn-stat/functions.c:1693 ../plugins/fn-stat/functions.c:1754
#: ../plugins/fn-stat/functions.c:4757
msgid "If @{p} < 0 or @{p} > 1 this function returns a #NUM! error."
msgstr "Se @{p} < 0 ou @{p} > 1, devolve #NUM!."

#: ../plugins/fn-stat/functions.c:438
msgid ""
"NORMSDIST:cumulative distribution function of the standard normal "
"distribution"
msgstr ""
"DIST.NORMP: função de distribuição cumulativa da distribuição normal padrão"

#: ../plugins/fn-stat/functions.c:441
msgid "NORMSDIST is the OpenFormula function LEGACY.NORMSDIST."
msgstr "DIST.NORMP é a função OpenFormula LEGACY.NORMSDIST."

#: ../plugins/fn-stat/functions.c:444 ../plugins/fn-stat/functions.c:488
msgid "wiki:en:Normal_distribution"
msgstr "wiki:pt:Distribuição_normal"

#: ../plugins/fn-stat/functions.c:445 ../plugins/fn-stat/functions.c:489
msgid "wolfram:NormalDistribution.html"
msgstr "wolfram:NormalDistribution.html"

#: ../plugins/fn-stat/functions.c:460
msgid ""
"SNORM.DIST.RANGE:probability of the standard normal distribution over an "
"interval"
msgstr ""
"DIST.NORMP.INT: probabilidade da distribuição normal padrão sobre um "
"intervalo"

#: ../plugins/fn-stat/functions.c:461
msgid "x1:start of the interval"
msgstr "x1: início do intervalo"

#: ../plugins/fn-stat/functions.c:462
msgid "x2:end of the interval"
msgstr "x2: fim do intervalo"

#: ../plugins/fn-stat/functions.c:463
msgid ""
"This function returns the cumulative probability over a range of the "
"standard normal distribution; that is the integral over the probability "
"density function from @{x1} to @{x2}."
msgstr ""
"Esta função devolve a probabilidade cumulativa sobre um intervalo da "
"distribuição normal padrão; é o integral sobre a função de densidade de "
"probabilidade de @{x1} a @{x2}."

#: ../plugins/fn-stat/functions.c:464
msgid "If @{x1}>@{x2}, this function returns a negative value."
msgstr "Se @{x1}>@{x2}, devolve um valor negativo."

#: ../plugins/fn-stat/functions.c:481
msgid ""
"NORMSINV:inverse of the cumulative distribution function of the standard "
"normal distribution"
msgstr ""
"INV.NORMP: inverso da função de distribuição cumulativa da distribuição "
"normal padrão"

#: ../plugins/fn-stat/functions.c:482
msgid "p:given probability"
msgstr "p: probabilidade indicada"

#: ../plugins/fn-stat/functions.c:483
msgid "If @{p} < 0 or @{p} > 1 this function returns #NUM! error."
msgstr "Se @{p} < 0 ou @{p} > 1 devolve #NUM!."

#: ../plugins/fn-stat/functions.c:485
msgid "NORMSINV is the OpenFormula function LEGACY.NORMSINV."
msgstr "INV.NORMP é a função OpenFormula LEGACY.NORMSINV"

#: ../plugins/fn-stat/functions.c:508
msgid "OWENT:Owen's T function"
msgstr "OWENT: função T de Owen"

#: ../plugins/fn-stat/functions.c:509
msgid "h:number"
msgstr "h: número"

#: ../plugins/fn-stat/functions.c:528
msgid ""
"LOGNORMDIST:cumulative distribution function of the lognormal distribution"
msgstr ""
"DIST.NORMALLOG: função de distribuição cumulativa da distribuição log-normal"

#: ../plugins/fn-stat/functions.c:530 ../plugins/fn-stat/functions.c:560
msgid "mean:mean"
msgstr "média: média"

#: ../plugins/fn-stat/functions.c:531 ../plugins/fn-stat/functions.c:561
msgid "stddev:standard deviation"
msgstr "desvpad: desvio padrão"

#: ../plugins/fn-stat/functions.c:532
msgid "If @{stddev} = 0 LOGNORMDIST returns a #DIV/0! error."
msgstr "Se @{stddev} = 0 devolve #DIV/0!."

#: ../plugins/fn-stat/functions.c:533
msgid ""
"If @{x} <= 0, @{mean} < 0 or @{stddev} <= 0 this function returns a #NUM! "
"error."
msgstr "Se @{x} <= 0, @{mean} < 0 ou @{stddev} <= 0 devolve #NUM!."

#: ../plugins/fn-stat/functions.c:537 ../plugins/fn-stat/functions.c:566
msgid "wiki:en:Log-normal_distribution"
msgstr "wki:pt:Distribuição_normal"

#: ../plugins/fn-stat/functions.c:538 ../plugins/fn-stat/functions.c:567
msgid "wolfram:LogNormalDistribution.html"
msgstr "wolfram:LogNormalDistribution.html"

#: ../plugins/fn-stat/functions.c:558
msgid ""
"LOGINV:inverse of the cumulative distribution function of the lognormal "
"distribution"
msgstr ""
"INVLOG: inverso da função de distribuição cumulativa da distribuição log-"
"normal"

#: ../plugins/fn-stat/functions.c:562
msgid ""
"If @{p} < 0 or @{p} > 1 or @{stddev} <= 0 this function returns #NUM! error."
msgstr "Se @{p} < 0 ou @{p} > 1 ou @{desvpad} <= 0 devolve #NUM!."

#: ../plugins/fn-stat/functions.c:589
msgid "FISHERINV:inverse of the Fisher transformation"
msgstr "FISHERINV: inverso da transformação Fisher"

#: ../plugins/fn-stat/functions.c:591
msgid "If @{x} is a non-number this function returns a #VALUE! error."
msgstr "Se @{x} não for número, devolve #VALOR!."

#: ../plugins/fn-stat/functions.c:607
msgid "MODE:first most common number in the dataset"
msgstr "MODA: o primeiro número mais comum num conjunto de dados"

#: ../plugins/fn-stat/functions.c:608 ../plugins/fn-stat/functions.c:635
#: ../plugins/fn-stat/functions.c:733 ../plugins/fn-stat/functions.c:759
#: ../plugins/fn-stat/functions.c:785 ../plugins/fn-stat/functions.c:810
#: ../plugins/fn-stat/functions.c:835 ../plugins/fn-stat/functions.c:860
#: ../plugins/fn-stat/functions.c:894 ../plugins/fn-stat/functions.c:928
#: ../plugins/fn-stat/functions.c:956 ../plugins/fn-stat/functions.c:2030
#: ../plugins/fn-stat/functions.c:2060 ../plugins/fn-stat/functions.c:2085
#: ../plugins/fn-stat/functions.c:2108 ../plugins/fn-stat/functions.c:2231
#: ../plugins/fn-stat/functions.c:2653 ../plugins/fn-stat/functions.c:2677
#: ../plugins/fn-stat/functions.c:2702
msgid "number1:first value"
msgstr "num1: o primeiro valor"

#: ../plugins/fn-stat/functions.c:609 ../plugins/fn-stat/functions.c:636
#: ../plugins/fn-stat/functions.c:734 ../plugins/fn-stat/functions.c:760
#: ../plugins/fn-stat/functions.c:786 ../plugins/fn-stat/functions.c:811
#: ../plugins/fn-stat/functions.c:836 ../plugins/fn-stat/functions.c:861
#: ../plugins/fn-stat/functions.c:895 ../plugins/fn-stat/functions.c:929
#: ../plugins/fn-stat/functions.c:957 ../plugins/fn-stat/functions.c:2031
#: ../plugins/fn-stat/functions.c:2061 ../plugins/fn-stat/functions.c:2086
#: ../plugins/fn-stat/functions.c:2109 ../plugins/fn-stat/functions.c:2232
#: ../plugins/fn-stat/functions.c:2654 ../plugins/fn-stat/functions.c:2678
#: ../plugins/fn-stat/functions.c:2703
msgid "number2:second value"
msgstr "num2: o segundo valor"

#: ../plugins/fn-stat/functions.c:611 ../plugins/fn-stat/functions.c:638
msgid ""
"If the data set does not contain any duplicates this function returns a #N/A "
"error."
msgstr "Se o conjunto não contiver duplicados, devolve #N/D!."

#: ../plugins/fn-stat/functions.c:615 ../plugins/fn-stat/functions.c:642
msgid "wiki:en:Mode_(statistics)"
msgstr "wiki:pt:Moda_(estatística)"

#: ../plugins/fn-stat/functions.c:616 ../plugins/fn-stat/functions.c:643
msgid "wolfram:Mode.html"
msgstr "wolfram:Mode.html"

#: ../plugins/fn-stat/functions.c:634
msgid "MODE.MULT:most common numbers in the dataset"
msgstr "MODA.MULT: números mais comuns num conjunto de dados"

#: ../plugins/fn-stat/functions.c:732
msgid "HARMEAN:harmonic mean"
msgstr "MÉDIA.HARMÓNICA: média harmónica"

#: ../plugins/fn-stat/functions.c:735
msgid ""
"The harmonic mean of N data points is N divided by the sum of the "
"reciprocals of the data points)."
msgstr ""
"A média harmónica de N pontos de dados é N dividido pela soma dos recíprocos "
"dos pontos de dados."

#: ../plugins/fn-stat/functions.c:739
msgid "wiki:en:Harmonic_mean"
msgstr "wiki:pt:Média_harmônica"

#: ../plugins/fn-stat/functions.c:740
msgid "wolfram:HarmonicMean.html"
msgstr "wolfram:HarmonicMean.html"

#: ../plugins/fn-stat/functions.c:758
msgid "GEOMEAN:geometric mean"
msgstr "MÉDIA.GEOMÉTRICA: média geométrica"

#: ../plugins/fn-stat/functions.c:761
msgid ""
"The geometric mean is equal to the Nth root of the product of the N values."
msgstr "A média geométrica é igual à raiz N do produto de N valores."

#: ../plugins/fn-stat/functions.c:765
msgid "wiki:en:Geometric_mean"
msgstr "wiki:pt:Média_geométrica"

#: ../plugins/fn-stat/functions.c:766
msgid "wolfram:GeometricMean.html"
msgstr "wolfram:GeometricMean.html"

#: ../plugins/fn-stat/functions.c:784
msgid "COUNT:total number of integer or floating point arguments passed"
msgstr "CONTAR: total de argumentos inteiros ou de vírgula flutuante passados"

#: ../plugins/fn-stat/functions.c:789
msgid "Then COUNT(A1:A5) equals 5."
msgstr "Então CONTAR(A1:A5) é igual a 5."

#: ../plugins/fn-stat/functions.c:809
msgid "COUNTA:number of arguments passed not including empty cells"
msgstr "CONTAR.VAL: número de argumentos passados não incluindo células vazias"

#: ../plugins/fn-stat/functions.c:813
msgid ""
"Let us assume that the cells A1, A2, ..., A5 contain numbers and strings "
"11.4, \"missing\", \"missing\", 25.9, and 40.1."
msgstr ""
"Vamos assumir que as células A1, A2, ..., A5 conttêm números e cadeias 11,4, "
"\"faltam\", \"faltam\", 25,9, e 40,1."

#: ../plugins/fn-stat/functions.c:814
msgid "Then COUNTA(A1:A5) equals 5."
msgstr "Então CONTAR.VAL(A1:A5) é igual a 5."

#: ../plugins/fn-stat/functions.c:834
msgid "AVERAGE:average of all the numeric values and cells"
msgstr "MÉDIA: média de todos os valores numéricos e células"

#: ../plugins/fn-stat/functions.c:840
msgid "wiki:en:Arithmetic_mean"
msgstr "wiki:pt:Média_aritmética"

#: ../plugins/fn-stat/functions.c:841
msgid "wolfram:ArithmeticMean.html"
msgstr "wolfram:ArithmeticMean.html"

#: ../plugins/fn-stat/functions.c:859
msgid ""
"MIN:smallest value, with negative numbers considered smaller than positive "
"numbers"
msgstr ""
"MÍNIMO: o menor valor, com os números negativos sendo inferiores aos "
"positivos"

#: ../plugins/fn-stat/functions.c:893
msgid ""
"MAX:largest value, with negative numbers considered smaller than positive "
"numbers"
msgstr ""
"MÁXIMO: o maior valor, com os números negativos sendo inferiores aos "
"positivos"

#: ../plugins/fn-stat/functions.c:927
msgid "SKEW:unbiased estimate for skewness of a distribution"
msgstr "INCLINAÇÃO: estimativa para a distorção de uma distribuição"

#: ../plugins/fn-stat/functions.c:931
msgid ""
"This is only meaningful if the underlying distribution really has a third "
"moment.  The skewness of a symmetric (e.g., normal) distribution is zero."
msgstr ""
"Este é o único significado se a distribuição subjacente tem um terceiro "
"momento. A inclinação de uma distribuição simétrica (ou seja, normal), é "
"zero."

#: ../plugins/fn-stat/functions.c:934
msgid ""
"If less than three numbers are given, this function returns a #DIV/0! error."
msgstr "Se forem indicados menos de três números, devolve #DIV/0!."

#: ../plugins/fn-stat/functions.c:955
msgid "SKEWP:population skewness of a data set"
msgstr "INCLINAÇÃOP: inclinação da população de um conjunto de dados"

#: ../plugins/fn-stat/functions.c:959
msgid "If less than two numbers are given, SKEWP returns a #DIV/0! error."
msgstr "Se forem indicados menos de dois números, devolve #DIV/0!."

#: ../plugins/fn-stat/functions.c:979
msgid ""
"EXPONDIST:probability density or cumulative distribution function of the "
"exponential distribution"
msgstr ""
"DISTEXPON: função de densidade da probabilidade ou da distribuição "
"cumulativa da distribuição exponencial"

#: ../plugins/fn-stat/functions.c:981
msgid "y:scale parameter"
msgstr "y: parâmetro escala"

#: ../plugins/fn-stat/functions.c:982 ../plugins/fn-stat/functions.c:1052
#: ../plugins/fn-stat/functions.c:1292 ../plugins/fn-stat/functions.c:1721
#: ../plugins/fn-stat/functions.c:1936 ../plugins/fn-stat/functions.c:1972
msgid ""
"cumulative:whether to evaluate the density function or the cumulative "
"distribution function"
msgstr ""
"cumulativo: se avaliar a função de densidade de probabilidade ou a da "
"distribuição cumulativa"

#: ../plugins/fn-stat/functions.c:983
msgid ""
"If @{cumulative} is false it will return:\t@{y} * exp (-@{y}*@{x}),otherwise "
"it will return\t1 - exp (-@{y}*@{x})."
msgstr ""
"Se @{cumulativo} for FALSO devolve:\t@{y} * EXP(-@{y}*@{x}), senão devolve"
"\t1 - EXP(-@{y}*@{x})."

#: ../plugins/fn-stat/functions.c:986
msgid "If @{x} < 0 or @{y} <= 0 this will return an error."
msgstr "Se @{x} < 0 ou @{y} <= 0 devolve um erro."

#: ../plugins/fn-stat/functions.c:1012
msgid "BERNOULLI:probability mass function of a Bernoulli distribution"
msgstr ""
"BERNOULLI: função de probabilidade em massa de uma distribuição Bernoulli"

#: ../plugins/fn-stat/functions.c:1013
msgid "k:integer"
msgstr "k: inteiro"

#: ../plugins/fn-stat/functions.c:1015
msgid "If @{k} != 0 and @{k} != 1 this function returns a #NUM! error."
msgstr "Se @{k} != 0 e @{k} != 1 devolve #NUM!."

#: ../plugins/fn-stat/functions.c:1048
msgid ""
"GAMMADIST:probability density or cumulative distribution function of the "
"gamma distribution"
msgstr ""
"DISTGAMA: função de densidade da probabilidade ou da distribuição cumulativa "
"da distribuição gama"

#: ../plugins/fn-stat/functions.c:1050 ../plugins/fn-stat/functions.c:1083
#: ../plugins/fn-stat/functions.c:1255 ../plugins/fn-stat/functions.c:1290
#: ../plugins/fn-stat/functions.c:1333 ../plugins/fn-stat/functions.c:1934
msgid "alpha:scale parameter"
msgstr "alfa: parâmetro de escala"

#: ../plugins/fn-stat/functions.c:1051 ../plugins/fn-stat/functions.c:1084
#: ../plugins/fn-stat/functions.c:1256 ../plugins/fn-stat/functions.c:1291
#: ../plugins/fn-stat/functions.c:1334 ../plugins/fn-stat/functions.c:1935
msgid "beta:scale parameter"
msgstr "beta: parâmetro de escala"

#: ../plugins/fn-stat/functions.c:1053 ../plugins/fn-stat/functions.c:1460
#: ../plugins/fn-stat/functions.c:1940 ../plugins/fn-stat/functions.c:2160
msgid "If @{x} < 0 this function returns a #NUM! error."
msgstr "Se @{x} < 0 devolve #NUM!."

#: ../plugins/fn-stat/functions.c:1054 ../plugins/fn-stat/functions.c:1260
#: ../plugins/fn-stat/functions.c:1297 ../plugins/fn-stat/functions.c:1338
msgid "If @{alpha} <= 0 or @{beta} <= 0, this function returns a #NUM! error."
msgstr "Se @{alpha} <= 0 ou @{beta} <= 0, devolve #NUM!."

#: ../plugins/fn-stat/functions.c:1081
msgid "GAMMAINV:inverse of the cumulative gamma distribution"
msgstr "INVGAMA: o inverso da distribuição gama cumulativa"

#: ../plugins/fn-stat/functions.c:1086 ../plugins/fn-stat/functions.c:1941
msgid "If @{alpha} <= 0 or @{beta} <= 0 this function returns a #NUM! error."
msgstr "Se @{alpha} <= 0 ou @{beta} <= 0 devolve #NUM!."

#: ../plugins/fn-stat/functions.c:1111
msgid "CHIDIST:survival function of the chi-squared distribution"
msgstr "DIST.CHI: função de sobrevivência da distribuição chi quadrado"

#: ../plugins/fn-stat/functions.c:1113 ../plugins/fn-stat/functions.c:1141
#: ../plugins/fn-stat/functions.c:1368 ../plugins/fn-stat/functions.c:1420
msgid "dof:number of degrees of freedom"
msgstr "gdl: número de gras de liberdade"

#: ../plugins/fn-stat/functions.c:1114 ../plugins/fn-stat/functions.c:1142
#: ../plugins/fn-stat/functions.c:1370 ../plugins/fn-stat/functions.c:1459
#: ../plugins/fn-stat/functions.c:1625
msgid "The survival function is 1 minus the cumulative distribution function."
msgstr ""
"A função de sobrevivência é 1 menos a função de distribuição cumulativa."

#: ../plugins/fn-stat/functions.c:1115
msgid "If @{dof} is non-integer it is truncated."
msgstr "Se @{gdl} não for inteiro, é truncado."

#: ../plugins/fn-stat/functions.c:1116 ../plugins/fn-stat/functions.c:1371
msgid "If @{dof} < 1 this function returns a #NUM! error."
msgstr "Se @{gdl} < 1 devolve #NUM!."

#: ../plugins/fn-stat/functions.c:1118
msgid ""
"CHIDIST(@{x},@{dof}) is the OpenFormula function LEGACY.CHIDIST(@{x},@{dof})."
msgstr ""
"DIST.CHI(@{x},@{gdl}) é a função OpenFormula LEGACY.CHIDIST(@{x},@{gdl})."

#: ../plugins/fn-stat/functions.c:1139
msgid "CHIINV:inverse of the survival function of the chi-squared distribution"
msgstr ""
"INV.CHI: o inverso da função de sobrevivência da distribuição chi quadrado"

#: ../plugins/fn-stat/functions.c:1143 ../plugins/fn-stat/functions.c:1424
msgid ""
"If @{p} < 0 or @{p} > 1 or @{dof} < 1 this function returns a #NUM! error."
msgstr "Se @{p} < 0 ou @{p} > 1 ou @{gdl} < 1 devolve #NUM!."

#: ../plugins/fn-stat/functions.c:1145
msgid ""
"CHIINV(@{p},@{dof}) is the OpenFormula function LEGACY.CHIDIST(@{p},@{dof})."
msgstr ""
"INV.CHI(@{x},@{gdl}) é a função OpenFormula LEGACY.CHIINV(@{x},@{gdl})."

#: ../plugins/fn-stat/functions.c:1166
msgid "CHITEST:p value of the Goodness of Fit Test"
msgstr "TESTE.CHI: valor p do teste chi-quadrado de Pearson"

#: ../plugins/fn-stat/functions.c:1167
msgid "actual_range:observed data"
msgstr "int_atual: dados observados"

#: ../plugins/fn-stat/functions.c:1168
msgid "theoretical_range:expected values"
msgstr "int_teórico: valores esperados"

#: ../plugins/fn-stat/functions.c:1169
msgid ""
"If the actual range is not an n by 1 or 1 by n range, but an n by m range, "
"then CHITEST uses (n-1) times (m-1) as degrees of freedom. This is useful if "
"the expected values were calculated from the observed value in a test of "
"independence or test of homogeneity."
msgstr ""
"Se o intervalo atual não for n por 1 ou 1 por n, mas sim n por m, então "
"TESTE.CHI usa (n-1) vezes (m-1) como graus de liberdade. Isto é útil se os "
"valores esperados foram calculados a partir do valor observado num teste de "
"independência ou de homogeneidade."

#: ../plugins/fn-stat/functions.c:1175
msgid "CHITEST is the OpenFormula function LEGACY.CHITEST."
msgstr "TESTE.CHI é a função OpenFormula LEGACY.CHITEST."

#: ../plugins/fn-stat/functions.c:1253
msgid "BETADIST:cumulative distribution function of the beta distribution"
msgstr "DISTBETA: função de distribuição cumulativa da distribuição Beta"

#: ../plugins/fn-stat/functions.c:1257 ../plugins/fn-stat/functions.c:1294
#: ../plugins/fn-stat/functions.c:1335
msgid "a:optional lower bound, defaults to 0"
msgstr "a: limite inferior opcional, predefinido como 0"

#: ../plugins/fn-stat/functions.c:1258 ../plugins/fn-stat/functions.c:1295
#: ../plugins/fn-stat/functions.c:1336
msgid "b:optional upper bound, defaults to 1"
msgstr "b: limite superior opcional, predefinido como 1"

#: ../plugins/fn-stat/functions.c:1259 ../plugins/fn-stat/functions.c:1296
msgid "If @{x} < @{a} or @{x} > @{b} this function returns a #NUM! error."
msgstr "Se @{x} < @{a} ou @{x} > @{b} devolve #NUM!."

#: ../plugins/fn-stat/functions.c:1261 ../plugins/fn-stat/functions.c:1298
#: ../plugins/fn-stat/functions.c:1339
msgid "If @{a} >= @{b} this function returns a #NUM! error."
msgstr "Se @{a} >= @{b} devolve #NUM!."

#: ../plugins/fn-stat/functions.c:1288
msgid "BETA.DIST:cumulative distribution function of the beta distribution"
msgstr "DIST.BETA: função de distribuição cumulativa da distribuição Beta"

#: ../plugins/fn-stat/functions.c:1331
msgid ""
"BETAINV:inverse of the cumulative distribution function of the beta "
"distribution"
msgstr ""
"BETA.ACUM.INV: o inverso da função de distribuição cumulativa da "
"distribuição Beta"

#: ../plugins/fn-stat/functions.c:1366
msgid "TDIST:survival function of the Student t-distribution"
msgstr "DISTT: função de sobrevivência da distribuição t de Student"

#: ../plugins/fn-stat/functions.c:1369
msgid "tails:1 or 2"
msgstr "caudas: 1 ou 2"

#: ../plugins/fn-stat/functions.c:1372
msgid "If @{tails} is neither 1 or 2 this function returns a #NUM! error."
msgstr "Se @{caudas não for nem 1 nem 2, devolve #NUM!."

#: ../plugins/fn-stat/functions.c:1373
msgid ""
"The parameterization of this function is different from what is used for, e."
"g., NORMSDIST.  This is a common source of mistakes, but necessary for "
"compatibility."
msgstr ""
"A parametrização desta função é diferente da usada para, por exemplo, DIST."
"NORMP. Esta é uma fonte comum de erros, mas necessária para compatibilidade."

#: ../plugins/fn-stat/functions.c:1376
msgid "This function is Excel compatible for non-negative @{x}."
msgstr "Esta função é compatível com Excel pra @{x} não negativo."

#: ../plugins/fn-stat/functions.c:1418
msgid "TINV:two tailed inverse of the Student t-distribution"
msgstr "INVT: inverso de duas caudas da distribuição t de Student"

#: ../plugins/fn-stat/functions.c:1419
msgid "p:probability in both tails"
msgstr "p: probabilidade nas duas caudas"

#: ../plugins/fn-stat/functions.c:1421
msgid ""
"This function returns the non-negative value x such that the area under the "
"Student t density with @{dof} degrees of freedom to the right of x is @{p}/2."
msgstr ""
"Esta função devolve o valor x não negativo tal que a área sob a densidade t "
"de Student com @{gdl} graus de liberdade à direita de x seja @{p}/2."

#: ../plugins/fn-stat/functions.c:1426
msgid ""
"The parameterization of this function is different from what is used for, e."
"g., NORMSINV.  This is a common source of mistakes, but necessary for "
"compatibility."
msgstr ""
"A parametrização desta função é diferente da usada para, por exemplo, INV."
"NORMP. Esta é uma fonte comum de erros, mas necessária para compatibilidade."

#: ../plugins/fn-stat/functions.c:1455
msgid "FDIST:survival function of the F distribution"
msgstr "DISTF: função de sobrevivência da distribuição F"

#: ../plugins/fn-stat/functions.c:1457 ../plugins/fn-stat/functions.c:1623
msgid "dof_of_num:numerator degrees of freedom"
msgstr "num_gdl: numerador de graus de liberdade"

#: ../plugins/fn-stat/functions.c:1458 ../plugins/fn-stat/functions.c:1624
msgid "dof_of_denom:denominator degrees of freedom"
msgstr "den_gdl: denominador de graus de liberdade"

#: ../plugins/fn-stat/functions.c:1461
msgid ""
"If @{dof_of_num} < 1 or @{dof_of_denom} < 1, this function returns a #NUM! "
"error."
msgstr "Se @{num_gdl} < 1 ou @{den_gdl} < 1, devolve #NUM!."

#: ../plugins/fn-stat/functions.c:1463
msgid "FDIST is the OpenFormula function LEGACY.FDIST."
msgstr "DISTF é a função OpenFormula LEGACY.FDIST."

#: ../plugins/fn-stat/functions.c:1485
msgid ""
"LANDAU:approximate probability density function of the Landau distribution"
msgstr ""
"LANDAU: função de densidade de probabilidade aproximada da distribuição "
"Landau"

#: ../plugins/fn-stat/functions.c:1621
msgid "FINV:inverse of the survival function of the F distribution"
msgstr "INVF: inverso da função de sobrevivência da distribuição F"

#: ../plugins/fn-stat/functions.c:1627
msgid ""
"If @{dof_of_num} < 1 or @{dof_of_denom} < 1 this function returns a #NUM! "
"error."
msgstr "Se @{num_gdl} < 1 ou @{den_gdl} < 1 devolve #NUM!."

#: ../plugins/fn-stat/functions.c:1629
msgid "FINV is the OpenFormula function LEGACY.FINV."
msgstr "INVF é a função OpenFormula LEGACY.FINV."

#: ../plugins/fn-stat/functions.c:1651
msgid ""
"BINOMDIST:probability mass or cumulative distribution function of the "
"binomial distribution"
msgstr ""
"DISTRBINOM: função de massa de probabilidade ou distribuição cumulativa da "
"distribuição binomial"

#: ../plugins/fn-stat/functions.c:1652
msgid "n:number of successes"
msgstr "n: número de sucessos"

#: ../plugins/fn-stat/functions.c:1653 ../plugins/fn-stat/functions.c:1687
#: ../plugins/fn-stat/functions.c:1749
msgid "trials:number of trials"
msgstr "tentativas: número de tentativas"

#: ../plugins/fn-stat/functions.c:1654 ../plugins/fn-stat/functions.c:1688
#: ../plugins/fn-stat/functions.c:1750
msgid "p:probability of success in each trial"
msgstr "p: probabilidade de sucesso de cada tentativa"

#: ../plugins/fn-stat/functions.c:1655 ../plugins/fn-stat/functions.c:1809
#: ../plugins/fn-stat/functions.c:2158 ../plugins/fn-stat/functions.c:4755
msgid ""
"cumulative:whether to evaluate the mass function or the cumulative "
"distribution function"
msgstr ""
"cumulativo: se avalira a função de massa de probabilidade ou a de "
"distribuição cumulativa"

#: ../plugins/fn-stat/functions.c:1656
msgid "If @{n} or @{trials} are non-integer they are truncated."
msgstr "Se @{n} ou @{tentativas} não forem inteiros, serão truncados."

#: ../plugins/fn-stat/functions.c:1657
msgid "If @{n} < 0 or @{trials} < 0 this function returns a #NUM! error."
msgstr "Se @{n} < 0 ou @{tentativas} < 0 devolve #NUM!."

#: ../plugins/fn-stat/functions.c:1658
msgid "If @{n} > @{trials} this function returns a #NUM! error."
msgstr "Se @{n} > @{tentativas} devolve #NUM!."

#: ../plugins/fn-stat/functions.c:1686
msgid ""
"BINOM.DIST.RANGE:probability of the binomial distribution over an interval"
msgstr ""
"DISTRBINOM.INT: probabilidade da distribuição binomial sobre um intervalo"

#: ../plugins/fn-stat/functions.c:1689
msgid "start:start of the interval"
msgstr "início: início do intervalo"

#: ../plugins/fn-stat/functions.c:1690
msgid "end:end of the interval, defaults to @{start}"
msgstr "fim: fim do intervalo, predefinido para @{início}"

#: ../plugins/fn-stat/functions.c:1691
msgid "If @{start}, @{end} or @{trials} are non-integer they are truncated."
msgstr ""
"Sef @{início}, @{fim} ou @{tentativas} não forem inteiros, serão truncados."

#: ../plugins/fn-stat/functions.c:1692 ../plugins/fn-stat/functions.c:1753
msgid "If @{trials} < 0 this function returns a #NUM! error."
msgstr "Se @{tentativas} < 0 devolve #NUM!."

#: ../plugins/fn-stat/functions.c:1694
msgid "If @{start} > @{end} this function returns 0."
msgstr "Se @{início} > @{fim} devolve 0."

#: ../plugins/fn-stat/functions.c:1717
msgid ""
"CAUCHY:probability density or cumulative distribution function of the "
"Cauchy, Lorentz or Breit-Wigner distribution"
msgstr ""
"CAUCHY: função de densidade de probabilidade ou de distribuição cumulativa "
"da distribuição de Cauchy, Lorentz ou Breit-Wigner"

#: ../plugins/fn-stat/functions.c:1720 ../plugins/fn-stat/functions.c:4785
#: ../plugins/fn-stat/functions.c:4909
msgid "a:scale parameter"
msgstr "a: parâmetro de escala"

#: ../plugins/fn-stat/functions.c:1722
msgid "If @{a} < 0 this function returns a #NUM! error."
msgstr "Se @{a} < 0 devolve #NUM!."

#: ../plugins/fn-stat/functions.c:1723 ../plugins/fn-stat/functions.c:4758
msgid ""
"If @{cumulative} is neither TRUE nor FALSE this function returns a #VALUE! "
"error."
msgstr "Se @{cumulativo} não for VERDADEIRO ou FALSO, devolve #VALUE!."

#: ../plugins/fn-stat/functions.c:1748
msgid "CRITBINOM:right-tailed critical value of the binomial distribution"
msgstr "CRIT.BINOM: valor crítico da cauda direita da distribuição binomial"

#: ../plugins/fn-stat/functions.c:1751
msgid "alpha:significance level (area of the tail)"
msgstr "alfa: nível de significância (área da cauda)"

#: ../plugins/fn-stat/functions.c:1752
msgid "If @{trials} is a non-integer it is truncated."
msgstr "Se @{tentativas} não for um inteiro, será truncado."

#: ../plugins/fn-stat/functions.c:1755
msgid "If @{alpha} < 0 or @{alpha} > 1 this function returns a #NUM! error."
msgstr "Se @{alfa} < 0 ou @{alfa} > 1 devolve #NUM!."

#: ../plugins/fn-stat/functions.c:1778
msgid "PERMUT:number of @{k}-permutations of a @{n}-set"
msgstr "PERMUTAR: número de permutações @{k} de um conjunto @{n}"

#: ../plugins/fn-stat/functions.c:1779
msgid "n:size of the base set"
msgstr "n: tamanho do conjunto base"

#: ../plugins/fn-stat/functions.c:1780
msgid "k:number of elements in each permutation"
msgstr "k: número de elementos em cada permutação"

#: ../plugins/fn-stat/functions.c:1781
msgid "If @{n} = 0 this function returns a #NUM! error."
msgstr "Se @{n} = 0 devolve #NUM!."

#: ../plugins/fn-stat/functions.c:1782
msgid "If @{n} < @{k} this function returns a #NUM! error."
msgstr "Se @{n} < @{k} devolve #NUM!."

#: ../plugins/fn-stat/functions.c:1804
msgid ""
"HYPGEOMDIST:probability mass or cumulative distribution function of the "
"hypergeometric distribution"
msgstr ""
"DIST.HIPERGEOM: função de massa de probabilidade ou distribuição cumulativa "
"da distribuição hipergeométrica"

#: ../plugins/fn-stat/functions.c:1805
msgid "x:number of successes"
msgstr "x: número de sucessos"

#: ../plugins/fn-stat/functions.c:1806
msgid "n:sample size"
msgstr "n: tamanho da amostra"

#: ../plugins/fn-stat/functions.c:1807
msgid "M:number of possible successes in the population"
msgstr "M: número de sucessos possíveis na população"

#: ../plugins/fn-stat/functions.c:1808
msgid "N:population size"
msgstr "N: tamanho da população"

#: ../plugins/fn-stat/functions.c:1810
msgid "If @{x},@{n},@{M} or @{N} is a non-integer it is truncated."
msgstr "Se @{x},@{n},@{M} ou @{N} não forem inteiros, serão truncados."

#: ../plugins/fn-stat/functions.c:1811
msgid "If @{x},@{n},@{M} or @{N} < 0 this function returns a #NUM! error."
msgstr "Se @{x},@{n},@{M} ou @{N} < 0 devolve #NUM!."

#: ../plugins/fn-stat/functions.c:1812
msgid "If @{x} > @{M} or @{n} > @{N} this function returns a #NUM! error."
msgstr "Se @{x} > @{M} ou @{n} > @{N} devolve #NUM!."

#: ../plugins/fn-stat/functions.c:1840
msgid ""
"CONFIDENCE:margin of error of a confidence interval for the population mean"
msgstr ""
"INT.CONFIANÇA: margem de erro de um intervalo de confiança para a média da "
"população"

#: ../plugins/fn-stat/functions.c:1841 ../plugins/fn-stat/functions.c:1874
msgid "alpha:significance level"
msgstr "alfa: nível de significância"

#: ../plugins/fn-stat/functions.c:1842
msgid "stddev:population standard deviation"
msgstr "desvpad: desvio padrão da população"

#: ../plugins/fn-stat/functions.c:1843 ../plugins/fn-stat/functions.c:1876
msgid "size:sample size"
msgstr "tamanho: tamanho da amostra"

#: ../plugins/fn-stat/functions.c:1844
msgid ""
"This function requires the usually unknown population standard deviation."
msgstr ""
"Esta função requer o habitualmente desconhecido desvio padrão da população."

#: ../plugins/fn-stat/functions.c:1845 ../plugins/fn-stat/functions.c:1878
msgid "If @{size} is non-integer it is truncated."
msgstr "Se @{tamanho} não for inteiro, será truncado."

#: ../plugins/fn-stat/functions.c:1846
msgid "If @{size} < 0 this function returns a #NUM! error."
msgstr "Se @{tamanho} < 0 devolve #NUM!."

#: ../plugins/fn-stat/functions.c:1847
msgid "If @{size} is 0 this function returns a #DIV/0! error."
msgstr "Se @{tamanho} for 0, devolve #DIV/0!."

#: ../plugins/fn-stat/functions.c:1872
msgid ""
"CONFIDENCE.T:margin of error of a confidence interval for the population "
"mean using the Student's t-distribution"
msgstr ""
"INT.CONFIANÇA.T: margem de erro de um intervalo de confiança para a média da "
"população usando a distribuição t de Student"

#: ../plugins/fn-stat/functions.c:1875
msgid "stddev:sample standard deviation"
msgstr "desvpad: desvio padrão da amostra"

#: ../plugins/fn-stat/functions.c:1877
msgid "If @{stddev} < 0 or = 0 this function returns a #NUM! error."
msgstr "Se @{desvpad} < 0 ou = 0 devolve #NUM!."

#: ../plugins/fn-stat/functions.c:1879
msgid "If @{size} < 1 this function returns a #NUM! error."
msgstr "Se @{tamanho} < 1 devolve #NUM!."

#: ../plugins/fn-stat/functions.c:1880
msgid "If @{size} is 1 this function returns a #DIV/0! error."
msgstr "Se @{tamanho} for 1, devolve #DIV/0!."

#: ../plugins/fn-stat/functions.c:1905
msgid "STANDARDIZE:z-score of a value"
msgstr "NORMALIZAR: resultado z de um valor"

#: ../plugins/fn-stat/functions.c:1907
msgid "mean:mean of the original distribution"
msgstr "média: média da distribuição original"

#: ../plugins/fn-stat/functions.c:1908
msgid "stddev:standard deviation of the original distribution"
msgstr "desvpad: desvio padrão da distribuição original"

#: ../plugins/fn-stat/functions.c:1909 ../plugins/fn-stat/functions.c:1973
msgid "If @{stddev} is 0 this function returns a #DIV/0! error."
msgstr "Se @{desvpad} for 0, devolve #DIV/0!."

#: ../plugins/fn-stat/functions.c:1932
msgid ""
"WEIBULL:probability density or cumulative distribution function of the "
"Weibull distribution"
msgstr ""
"WEIBULL: função de densidade da probabilidade ou da distribuição cumulativa "
"da distribuição Weibull"

#: ../plugins/fn-stat/functions.c:1937
msgid ""
"If the @{cumulative} boolean is true it will return: 1 - exp (-(@{x}/"
"@{beta})^@{alpha}),otherwise it will return (@{alpha}/@{beta}^@{alpha}) * "
"@{x}^(@{alpha}-1) * exp(-(@{x}/@{beta}^@{alpha}))."
msgstr ""
"Se a variável lógica @{cumulativo} for VERDADEIRO. devolve: 1 - EXP(-(@{x}/"
"@{beta})^@{alfa}), senão devolve (@{alfa}/@{beta}^@{alfa}) * @{x}"
"^(@{alfa}-1) * EXP(-(@{x}/@{beta}^@{alfa}))."

#: ../plugins/fn-stat/functions.c:1968
msgid ""
"NORMDIST:probability density or cumulative distribution function of a normal "
"distribution"
msgstr ""
"DIST.NORM: função de densidade da probabilidade ou da distribuição "
"cumulativa da distribuição normal"

#: ../plugins/fn-stat/functions.c:1970 ../plugins/fn-stat/functions.c:2003
#: ../plugins/fn-stat/functions.c:2157
msgid "mean:mean of the distribution"
msgstr "média: média da distribuição"

#: ../plugins/fn-stat/functions.c:1971 ../plugins/fn-stat/functions.c:2004
msgid "stddev:standard deviation of the distribution"
msgstr "desvpad: desvio padrão da distribuição"

#: ../plugins/fn-stat/functions.c:2001
msgid ""
"NORMINV:inverse of the cumulative distribution function of a normal "
"distribution"
msgstr ""
"INV.NORM: inverso da função da distribuição cumulativa da distribuição normal"

#: ../plugins/fn-stat/functions.c:2005
msgid ""
"If @{p} < 0 or @{p} > 1 or @{stddev} <= 0 this function returns a #NUM! "
"error."
msgstr "Se @{p} < 0 ou @{p} > 1 ou @{desvpad} <= 0, devolve #NUM!."

#: ../plugins/fn-stat/functions.c:2029
msgid "KURT:unbiased estimate of the kurtosis of a data set"
msgstr "KURT: estimativa da curtose de um conjunto de dados"

#: ../plugins/fn-stat/functions.c:2033
msgid ""
"This is only meaningful if the underlying distribution really has a fourth "
"moment.  The kurtosis is offset by three such that a normal distribution "
"will have zero kurtosis."
msgstr ""
"Este é o único significado se a distribuição subjacente tiver um quarto "
"momento. A curtose está desviada por três de modo a que a distribuição "
"normal tenha uma curtose zero."

#: ../plugins/fn-stat/functions.c:2037
msgid ""
"If fewer than four numbers are given or all of them are equal this function "
"returns a #DIV/0! error."
msgstr ""
"Se forem indicados menos de quatro números ou forem todos iguais, devolve "
"#DIV/0!."

#: ../plugins/fn-stat/functions.c:2059
msgid "KURTP:population kurtosis of a data set"
msgstr "KURTP: curtose da população de um conjunto de dados"

#: ../plugins/fn-stat/functions.c:2063
msgid ""
"If fewer than two numbers are given or all of them are equal this function "
"returns a #DIV/0! error."
msgstr ""
"Se forem indicados menos de dois números ou forem todos iguais, devolve "
"#DIV/0!."

#: ../plugins/fn-stat/functions.c:2084
msgid "AVEDEV:average of the absolute deviations of a data set"
msgstr "MÉDIA.DESV: média dos desvios absolutos de um conjunto de dados"

#: ../plugins/fn-stat/functions.c:2107
msgid "DEVSQ:sum of squares of deviations of a data set"
msgstr "DESVQ: soma dos quadrados dos desvios de um conjunto de dados"

#: ../plugins/fn-stat/functions.c:2131
msgid "FISHER:Fisher transformation"
msgstr "FISHER: transformação Fisher"

#: ../plugins/fn-stat/functions.c:2133
msgid "If @{x} is not a number, this function returns a #VALUE! error."
msgstr "Se @{x} não for um número, devolve #VALUE!."

#: ../plugins/fn-stat/functions.c:2134
msgid "If @{x} <= -1 or @{x} >= 1, this function returns a #NUM! error."
msgstr "Se @{x} <= -1 ou @{x} >= 1, devolve #NUM!."

#: ../plugins/fn-stat/functions.c:2155
msgid ""
"POISSON:probability mass or cumulative distribution function of the Poisson "
"distribution"
msgstr ""
"POISSON: função de massa de probabilidade ou da distribuição cumulativa da "
"distribuição Poisson"

#: ../plugins/fn-stat/functions.c:2156
msgid "x:number of events"
msgstr "x: número de eventos"

#: ../plugins/fn-stat/functions.c:2159
msgid "If @{x} is a non-integer it is truncated."
msgstr "Se @{x} não for um inteiro, será truncado."

#: ../plugins/fn-stat/functions.c:2161
msgid "If @{mean} <= 0 POISSON returns the #NUM! error."
msgstr "Se @{média} <= 0, devolve #NUM!."

#: ../plugins/fn-stat/functions.c:2187
msgid "PEARSON:Pearson correlation coefficient of the paired set of data"
msgstr ""
"PEARSON: coeficiente de correlação Pearson do conjunto de dados irmanado"

#: ../plugins/fn-stat/functions.c:2188 ../plugins/fn-stat/functions.c:2207
msgid "array1:first component values"
msgstr "matriz1: valores do primeiro componente"

#: ../plugins/fn-stat/functions.c:2189 ../plugins/fn-stat/functions.c:2208
msgid "array2:second component values"
msgstr "matriz2: valores do segundo componente"

#: ../plugins/fn-stat/functions.c:2206
msgid ""
"RSQ:square of the Pearson correlation coefficient of the paired set of data"
msgstr ""
"RQUAD: quadrado do coeficiente de correlação Pearson do conjunto de dados "
"irmanado"

#: ../plugins/fn-stat/functions.c:2230
msgid "MEDIAN:median of a data set"
msgstr "MEDIANA: mediana de um conjunto de dados"

#: ../plugins/fn-stat/functions.c:2234
msgid ""
"If even numbers are given MEDIAN returns the average of the two numbers in "
"the center."
msgstr ""
"Se forem indicados números pares, MEDIANA devolve a média dos dois números "
"no centro."

#: ../plugins/fn-stat/functions.c:2239
msgid "wiki:en:Median"
msgstr "wiki:pt:Mediana_(estatística)"

#: ../plugins/fn-stat/functions.c:2240
msgid "wolfram:StatisticalMedian.html"
msgstr "wolfram:StatisticalMedian.html"

#: ../plugins/fn-stat/functions.c:2259
msgid "SSMEDIAN:median for grouped data"
msgstr "MEDIANASS: mediana para dados agrupados"

#: ../plugins/fn-stat/functions.c:2260
msgid "array:data set"
msgstr "matriz: conjunto de dados"

#: ../plugins/fn-stat/functions.c:2261
msgid "interval:length of each grouping interval, defaults to 1"
msgstr "int: comprimento de cada intervalo de grupo, predefinido como 1"

#: ../plugins/fn-stat/functions.c:2262
msgid ""
"The data are assumed to be grouped into intervals of width @{interval}. Each "
"data point in @{array} is the midpoint of the interval containing the true "
"value. The median is calculated by interpolation within the median interval "
"(the interval containing the median value), assuming that the true values "
"within that interval are distributed uniformly:\n"
"median = L + @{interval}*(N/2 - CF)/F\n"
"where:\n"
"L = the lower limit of the median interval\n"
"N = the total number of data points\n"
"CF = the number of data points below the median interval\n"
"F = the number of data points in the median interval"
msgstr ""
"Presume-se que os dados estejam agrupados em intervalos de largura @{int}. "
"Cada ponto de dados na @{matriz} é o ponto médio do intervalo contendo o "
"valor verdadeiro. A mediana é calculada por interpolação dentro do intervalo "
"mediano (o intervalo contendo o valor mediano), assumindo que os valores "
"verdadeiros dentro desse intervalo são distribuídos uniformemente:\n"
"mediana = L + @{int}*(N/2 - CF)/F\n"
"onde:\n"
"L = limite inferior do intervalo mediano\n"
"N = número total de pontos de dados\n"
"CF = número de pontos de dados abaixo do intervalo mediano\n"
"F = número de pontos de dados no intervalo mediano"

#: ../plugins/fn-stat/functions.c:2273 ../plugins/fn-stat/functions.c:3041
#: ../plugins/fn-stat/functions.c:3083 ../plugins/fn-stat/functions.c:3128
#: ../plugins/fn-stat/functions.c:3171
msgid "If @{array} is empty, this function returns a #NUM! error."
msgstr "Se @{matriz} estiver vazia, devolve #NUM!."

#: ../plugins/fn-stat/functions.c:2274
msgid ""
"If @{interval} <= 0, this function returns a #NUM! error. SSMEDIAN does not "
"check whether the data points are at least @{interval} apart."
msgstr ""
"Se @{int} <= 0, devolve #NUM!. MEDIANASS não verifica se os pontos de dados "
"estão pelo menos @{int} separados."

#: ../plugins/fn-stat/functions.c:2361
msgid "LARGE:@{k}-th largest value in a data set"
msgstr "MAIOR: @{k}º maior valor num conjunto de dados"

#: ../plugins/fn-stat/functions.c:2362 ../plugins/fn-stat/functions.c:2405
msgid "data:data set"
msgstr "dados: conjunto de dados"

#: ../plugins/fn-stat/functions.c:2363 ../plugins/fn-stat/functions.c:2406
msgid "k:which value to find"
msgstr "k: que valor encontrar"

#: ../plugins/fn-stat/functions.c:2364 ../plugins/fn-stat/functions.c:2407
msgid "If data set is empty this function returns a #NUM! error."
msgstr "Se o conjunto de dados estiver vazio, devolve #NUM!."

#: ../plugins/fn-stat/functions.c:2365 ../plugins/fn-stat/functions.c:2408
msgid ""
"If @{k} <= 0 or @{k} is greater than the number of data items given this "
"function returns a #NUM! error."
msgstr ""
"Se @{k} <= 0 ou @{k} for maior que o número de itens de dados indicados, "
"devolve #NUM!."

#: ../plugins/fn-stat/functions.c:2370
msgid "Then LARGE(A1:A5,2) equals 25.9.LARGE(A1:A5,4) equals 17.3."
msgstr "Então MAIOR(A1:A5,2) é igual a 25,9. MAIOR(A1:A5,4) é igual a 17,3."

#: ../plugins/fn-stat/functions.c:2404
msgid "SMALL:@{k}-th smallest value in a data set"
msgstr "MENOR: @{k}º menor valor num conjunto de dados"

#: ../plugins/fn-stat/functions.c:2413
msgid "Then SMALL(A1:A5,2) equals 17.3.SMALL(A1:A5,4) equals 25.9."
msgstr "Então MENOR(A1:A5,2) é igual a 17,3. MENOR(A1:A5,4) é igual a 25,9."

#: ../plugins/fn-stat/functions.c:2448
msgid ""
"PROB:probability of an interval for a discrete (and finite) probability "
"distribution"
msgstr ""
"PROB: probabilidade de um intervalo para distribuição de probabilidade "
"discreta (e finita)"

#: ../plugins/fn-stat/functions.c:2449
msgid "x_range:possible values"
msgstr "int_x: valores possíveis"

#: ../plugins/fn-stat/functions.c:2450
msgid "prob_range:probabilities of the corresponding values"
msgstr "int_prob: probabilidades dos valores correspondentes"

#: ../plugins/fn-stat/functions.c:2451
msgid "lower_limit:lower interval limit"
msgstr "lim_inf: limite inferior do intervalo"

#: ../plugins/fn-stat/functions.c:2452
msgid "upper_limit:upper interval limit, defaults to @{lower_limit}"
msgstr "lim_sup: limite superior do intervalo, predefinido para @{lim_inf}"

#: ../plugins/fn-stat/functions.c:2453
msgid ""
"If the sum of the probabilities in @{prob_range} is not equal to 1 this "
"function returns a #NUM! error."
msgstr ""
"Se a soma das probabilidades em @{int_prob} não for igual a 1, devolve "
"\"NUM!."

#: ../plugins/fn-stat/functions.c:2455
msgid ""
"If any value in @{prob_range} is <=0 or > 1, this function returns a #NUM! "
"error."
msgstr "Se algum valor em @int_prob} for <=0 ou > 1, devolve #NUM!."

#: ../plugins/fn-stat/functions.c:2457
msgid ""
"If @{x_range} and @{prob_range} contain a different number of data entries, "
"this function returns a #N/A error."
msgstr ""
"Se @{int_x} e @{int_prob} contiverem um número diferente de dados, devolve "
"#N/D."

#: ../plugins/fn-stat/functions.c:2534
msgid "STEYX:standard error of the predicted y-value in the regression"
msgstr "EPADYX: erro padrão do valor y previsto na regressão"

#: ../plugins/fn-stat/functions.c:2535 ../plugins/fn-stat/functions.c:3829
#: ../plugins/fn-stat/functions.c:3945 ../plugins/fn-stat/functions.c:4187
#: ../plugins/fn-stat/functions.c:4285 ../plugins/fn-stat/functions.c:4388
#: ../plugins/fn-stat/functions.c:4447 ../plugins/fn-stat/functions.c:4499
msgid "known_ys:known y-values"
msgstr "ys_conhecidos: valores y conhecidos"

#: ../plugins/fn-stat/functions.c:2536 ../plugins/fn-stat/functions.c:3946
#: ../plugins/fn-stat/functions.c:4389 ../plugins/fn-stat/functions.c:4448
#: ../plugins/fn-stat/functions.c:4500
msgid "known_xs:known x-values"
msgstr "xs_conhecidos: valores x conhecidos"

#: ../plugins/fn-stat/functions.c:2537
msgid ""
"If @{known_ys} and @{known_xs} are empty or have a different number of "
"arguments then this function returns a #N/A error."
msgstr ""
"Se @{ys_conhecidos} e @{xs_conhecidos} estiverem vazios ou tiverem um número "
"diferente de argumentos, devolve #N/D."

#: ../plugins/fn-stat/functions.c:2543
msgid "Then STEYX(A1:A5,B1:B5) equals 1.101509979."
msgstr "Então EPADYX(A1:A5, B1:B5) é igual a 1,101509979."

#: ../plugins/fn-stat/functions.c:2587
msgid ""
"ZTEST:the probability of observing a sample mean as large as or larger than "
"the mean of the given sample"
msgstr ""
"TESTEZ: a probabilidade de opbservar uma média amostra tão ou mais larga que "
"a média da amostra indicada"

#: ../plugins/fn-stat/functions.c:2589
msgid "ref:data set (sample)"
msgstr "ref: conjunto de dados (amostra)"

#: ../plugins/fn-stat/functions.c:2590
msgid "x:population mean"
msgstr "x: média da população"

#: ../plugins/fn-stat/functions.c:2591
msgid ""
"stddev:population standard deviation, defaults to the sample standard "
"deviation"
msgstr ""
"despad: desvio padrão da população, predefinido como o desvio padrão da "
"amostra"

#: ../plugins/fn-stat/functions.c:2592
msgid ""
"ZTEST calculates the probability of observing a sample mean as large as or "
"larger than the mean of the given sample for samples drawn from a normal "
"distribution with mean @{x} and standard deviation @{stddev}."
msgstr ""
"TESTEZ calcula a a probabilidade de opbservar uma média amostra tão ou mais "
"larga que a média da amostra indicada para amostras retiradas de uma "
"distribuição normal com média @{x} e desvio padrão @{desvpad}."

#: ../plugins/fn-stat/functions.c:2595
msgid ""
"If @{ref} contains less than two data items ZTEST returns #DIV/0! error."
msgstr "Se @{ref} contiver menos de dois itens, devolve #DIV/0!."

#: ../plugins/fn-stat/functions.c:2601
msgid "Then ZTEST(A1:A5,20) equals 0.254717826."
msgstr "Então TESTEZ(A1:A5,20) é igual a 0.254717826."

#: ../plugins/fn-stat/functions.c:2652
msgid "AVERAGEA:average of all the values and cells"
msgstr "MÉDIAA: média de todos os valores e células"

#: ../plugins/fn-stat/functions.c:2676
msgid ""
"MAXA:largest value, with negative numbers considered smaller than positive "
"numbers"
msgstr ""
"MÁXIMOA: o maior valor, com números negativos considerados menores que "
"números positivos"

#: ../plugins/fn-stat/functions.c:2701
msgid ""
"MINA:smallest value, with negative numbers considered smaller than positive "
"numbers"
msgstr ""
"MÍNIMOA: o menor valor, com números negativos considerados menores que "
"números positivos"

#: ../plugins/fn-stat/functions.c:2726
msgid "VARA:sample variance of the given sample"
msgstr "VARA: variância da amostra da amostra indicada"

#: ../plugins/fn-stat/functions.c:2729
msgid "VARA is also known as the N-1-variance."
msgstr "VARA também é conhecida por variância N-1."

#: ../plugins/fn-stat/functions.c:2730
msgid "To get the true variance of a complete population use VARPA."
msgstr ""
"Para obter a verdadeira variância de uma população completa, use VARPA."

#: ../plugins/fn-stat/functions.c:2755
msgid "VARPA:variance of an entire population"
msgstr "VARPA: variância da população completa"

#: ../plugins/fn-stat/functions.c:2758
msgid "VARPA is also known as the N-variance."
msgstr "VARPA também é conhecida como variância N."

#: ../plugins/fn-stat/functions.c:2780
msgid "STDEVA:sample standard deviation of the given sample"
msgstr "DESVPADA: desvio padrão da amostra da amostra indicada"

#: ../plugins/fn-stat/functions.c:2784
msgid "STDEVA is also known as the N-1-standard deviation."
msgstr "DESVPADA também é conhecida como desvio padrão N-1."

#: ../plugins/fn-stat/functions.c:2785
msgid ""
"To obtain the population standard deviation of a whole population use "
"STDEVPA."
msgstr ""
"Para obter a verdadeira variância de uma população completa, use DESVPADPA."

#: ../plugins/fn-stat/functions.c:2808
msgid "STDEVPA:population standard deviation of an entire population"
msgstr "DESVPADPA: desvio padrão da população de uma população completa"

#: ../plugins/fn-stat/functions.c:2833
msgid ""
"PERCENTRANK:rank of a data point in a data set (Hyndman-Fan method 7: N-1 "
"basis)"
msgstr ""
"ORDEM.PERCENTUAL: ordem de um ponto de dados num conjunto (Hyndman-Fan "
"método 7: base N-1)"

#: ../plugins/fn-stat/functions.c:2834 ../plugins/fn-stat/functions.c:2938
msgid "array:range of numeric values"
msgstr "matriz: intervalo de valores numéricos"

#: ../plugins/fn-stat/functions.c:2835 ../plugins/fn-stat/functions.c:2939
msgid "x:data point to be ranked"
msgstr "x: ponto de dados a ser classificado"

#: ../plugins/fn-stat/functions.c:2836 ../plugins/fn-stat/functions.c:2940
msgid "significance:number of significant digits, defaults to 3"
msgstr "significância: número de dígitos significantes, predefinido para 3"

#: ../plugins/fn-stat/functions.c:2837 ../plugins/fn-stat/functions.c:2941
msgid ""
"If @{array} contains no data points, this function returns a #NUM! error."
msgstr "Se @{matriz} não contiver dados, devolve #NUM!."

#: ../plugins/fn-stat/functions.c:2839 ../plugins/fn-stat/functions.c:2943
msgid ""
"If @{significance} is less than one, this function returns a #NUM! error."
msgstr "Se @{sigificância} for menor que 1, devolve #NUM!."

#: ../plugins/fn-stat/functions.c:2841 ../plugins/fn-stat/functions.c:2945
msgid ""
"If @{x} exceeds the largest value or is less than the smallest value in "
"@{array}, this function returns an #N/A! error."
msgstr ""
"Se @{x} exceder o maior valor ou for inferior ao menor valor de @{matriz}, "
"devolve #N/A!."

#: ../plugins/fn-stat/functions.c:2843 ../plugins/fn-stat/functions.c:2947
msgid ""
"If @{x} does not match any of the values in @{array} or @{x} matches more "
"than once, this function interpolates the returned value."
msgstr ""
"Se @{x} não corresponder a nenhum valor em @{matriz} ou corresponder a mais "
"do que um, a função interpola o valor devolvido."

#: ../plugins/fn-stat/functions.c:2937
msgid ""
"PERCENTRANK.EXC:rank of a data point in a data set (Hyndman-Fan method 6: N"
"+1 basis)"
msgstr ""
"ORDEM.PERCENTUAL.EXC: ordem de um ponto de dados num conjunto (Hyndman-Fan "
"método 6: base N+1)"

#: ../plugins/fn-stat/functions.c:3038
msgid ""
"PERCENTILE:determines the 100*@{k}-th percentile of the given data points "
"(Hyndman-Fan method 7: N-1 basis)"
msgstr ""
"PERCENTIL: determina o 100*@{k}º percentil dos pontos de dados indicados. "
"(Hyndman-Fan método 7: base N-1)"

#: ../plugins/fn-stat/functions.c:3039 ../plugins/fn-stat/functions.c:3081
#: ../plugins/fn-stat/functions.c:3126 ../plugins/fn-stat/functions.c:3169
msgid "array:data points"
msgstr "matriz: pontos de dados"

#: ../plugins/fn-stat/functions.c:3040 ../plugins/fn-stat/functions.c:3082
msgid "k:which percentile to calculate"
msgstr "k: percentil a calcular"

#: ../plugins/fn-stat/functions.c:3042 ../plugins/fn-stat/functions.c:3084
msgid "If @{k} < 0 or @{k} > 1, this function returns a #NUM! error."
msgstr "Se @{k} < 0 ou @{k} > 1, devolve #NUM!."

#: ../plugins/fn-stat/functions.c:3045
msgid "Then PERCENTILE(A1:A5,0.42) equals 20.02."
msgstr "Então PERCENTIL(A1:A5,0,42) é igual a 20,02."

#: ../plugins/fn-stat/functions.c:3080
msgid ""
"PERCENTILE.EXC:determines the 100*@{k}-th percentile of the given data "
"points (Hyndman-Fan method 6: N+1 basis)"
msgstr ""
"PERCENTIL.EXC: determina o 100*@{k}º percentil dos pontos de dados "
"indicados. (Hyndman-Fan método 6: base N+1)"

#: ../plugins/fn-stat/functions.c:3087
msgid "Then PERCENTILE.EXC(A1:A5,0.42) equals 20.02."
msgstr "Então PERCENTIL.EXC(A1:A5,0,42) é igual a 20,02."

#: ../plugins/fn-stat/functions.c:3125
msgid ""
"QUARTILE:the @{k}-th quartile of the data points (Hyndman-Fan method 7: N-1 "
"basis)"
msgstr ""
"QUARTIL: determina o 100*@{k}º quartil dos pontos de dados indicados. "
"(Hyndman-Fan método 7: base N-1)"

#: ../plugins/fn-stat/functions.c:3127
msgid "quart:a number from 0 to 4, indicating which quartile to calculate"
msgstr "quart: número de 0 a 4 indicando qual o quartil a calcular"

#: ../plugins/fn-stat/functions.c:3129 ../plugins/fn-stat/functions.c:3172
msgid ""
"If @{quart} < 0 or @{quart} > 4, this function returns a #NUM! error. If "
"@{quart} = 0, the smallest value of @{array} to be returned."
msgstr ""
"Se @{quart} < 0 ou @{quart} > 4, devolve #NUM!. Se @{quart} = 0, devolve o "
"menor valor de @{matriz}."

#: ../plugins/fn-stat/functions.c:3130 ../plugins/fn-stat/functions.c:3173
msgid "If @{quart} is not an integer, it is truncated."
msgstr "Se @{quart} não for um inteiro, será truncado."

#: ../plugins/fn-stat/functions.c:3133
msgid "Then QUARTILE(A1:A5,1) equals 17.3."
msgstr "Então QUARTIL(A1:A5,1) é igual a 17,3."

#: ../plugins/fn-stat/functions.c:3168
msgid ""
"QUARTILE.EXC:the @{k}-th quartile of the data points (Hyndman-Fan method 6: N"
"+1 basis)"
msgstr ""
"QUARTIL.EXC: determina o 100*@{k}º quartil dos pontos de dados indicados. "
"(Hyndman-Fan método 6: base N+1)"

#: ../plugins/fn-stat/functions.c:3170
msgid "quart:a number from 1 to 3, indicating which quartile to calculate"
msgstr "quart: número de 1 a 3 indicando qual o quartil a calcular"

#: ../plugins/fn-stat/functions.c:3176
msgid "Then QUARTILE.EXC(A1:A5,1) equals 14.35."
msgstr "Então QUARTIL.EXC(A1:A5,1) é igual a 14,35."

#: ../plugins/fn-stat/functions.c:3214
msgid ""
"FTEST:p-value for the two-tailed hypothesis test comparing the variances of "
"two populations"
msgstr ""
"TESTEF: valor p para o teste da hipótese de duas caudas comparando a "
"variância de duas populações"

#: ../plugins/fn-stat/functions.c:3216 ../plugins/fn-stat/functions.c:3273
msgid "array1:sample from the first population"
msgstr "matriz1: amostra da primeira população"

#: ../plugins/fn-stat/functions.c:3217 ../plugins/fn-stat/functions.c:3274
msgid "array2:sample from the second population"
msgstr "matriz2: amostra da segunda população"

#: ../plugins/fn-stat/functions.c:3222
msgid "Then FTEST(A1:A5,B1:B5) equals 0.510815017."
msgstr "Então TESTEF(A1:A5,B1:B5) é igual a 0,510815017."

#: ../plugins/fn-stat/functions.c:3271
msgid ""
"TTEST:p-value for a hypothesis test comparing the means of two populations "
"using the Student t-distribution"
msgstr ""
"TESTET: valor p para o teste da hipótese comparando as médias de duas "
"populações usando a distribuição t de Student"

#: ../plugins/fn-stat/functions.c:3275
msgid "tails:number of tails to consider"
msgstr "caudas: número de caudas a considerar"

#: ../plugins/fn-stat/functions.c:3276
msgid ""
"type:Type of test to perform. 1 indicates a test for paired variables, 2 a "
"test of unpaired variables with equal variances, and 3 a test of unpaired "
"variables with unequal variances"
msgstr ""
"tipo: tipo de teste a executar. 1 indica um teste para variáveis irmanadas, "
"2 para variáveis deirmanadas com variâncias iguais e 3 para variáveis "
"desirmanadas com variâncias diferentes."

#: ../plugins/fn-stat/functions.c:3279
msgid ""
"If the data sets contain a different number of data points and the test is "
"paired (@{type} one), TTEST returns the #N/A error."
msgstr ""
"Se os conjuntos de dados tiverem um número diferente de pontos de dados e o "
"teste for irmanado (de @{tipo} 1), devolve #N/D. "

#: ../plugins/fn-stat/functions.c:3281
msgid "@{tails} and @{type} are truncated to integers."
msgstr "@{caudas} e @{tipo} são truncados para inteiros."

#: ../plugins/fn-stat/functions.c:3282
msgid "If @{tails} is not one or two, this function returns a #NUM! error."
msgstr "Se @{caudas} não for 1 ou 2, devolve #NUM!."

#: ../plugins/fn-stat/functions.c:3283
msgid ""
"If @{type} is any other than one, two, or three, this function returns a "
"#NUM! error."
msgstr "Se @{tipo} não for 1, 2 ou 3, devolve #NUM!."

#: ../plugins/fn-stat/functions.c:3288
msgid ""
"Then TTEST(A1:A5,B1:B5,1,1) equals 0.003127619.TTEST(A1:A5,B1:B5,2,1) equals "
"0.006255239.TTEST(A1:A5,B1:B5,1,2) equals 0.111804322.TTEST(A1:A5,B1:B5,1,3) "
"equals 0.113821797."
msgstr ""
"Entaão TESTET(A1:A5,B1:B5,1,1) é igual a 0,003127619. TESTET(A1:A5,B1:"
"B5,2,1) é igual a 0,006255239. TESTET(A1:A5,B1:B5,1,2) é igual a "
"0,111804322. TESTET(A1:A5,B1:B5,1,3) é igual a 0,113821797."

#: ../plugins/fn-stat/functions.c:3446
msgid "FREQUENCY:frequency table"
msgstr "FREQUÊNCIA: tabela de frequências"

#: ../plugins/fn-stat/functions.c:3447
msgid "data_array:data values"
msgstr "matriz_dados: valores de dados"

#: ../plugins/fn-stat/functions.c:3448
msgid "bins_array:array of cutoff values"
msgstr "matriz_bins: matriz de valores de corte"

#: ../plugins/fn-stat/functions.c:3449
msgid "The results are given as an array."
msgstr "Os resultados são dados como uma matriz."

#: ../plugins/fn-stat/functions.c:3450
msgid ""
"If the @{bins_array} is empty, this function returns the number of data "
"points in @{data_array}."
msgstr ""
"Se @{matriz_bins} estiver vazia, devolve o número de pontos de dados em "
"@{matriz_dados}."

#: ../plugins/fn-stat/functions.c:3514
msgid "LEVERAGE:calculate regression leverage"
msgstr "LEVERAGE: calcular vantagem da regressão"

#: ../plugins/fn-stat/functions.c:3517
msgid ""
"Returns the diagonal of @{A} (@{A}^T @{A})^-1 @{A}^T as a column vector."
msgstr ""
"Devolve a diagonal de @{A} (@{A}^T @{A})^-1 @{A}^T como um vetor de coluna."

#: ../plugins/fn-stat/functions.c:3518
msgid "If the matrix is singular, #VALUE! is returned."
msgstr "Se a matriz for singulas, devolve #VALOR!."

#: ../plugins/fn-stat/functions.c:3722
msgid "LINEST:multiple linear regression coefficients and statistics"
msgstr "PROJ.LIN: múltiplos coeficientes e estatísticas de regressão linear"

#: ../plugins/fn-stat/functions.c:3723 ../plugins/fn-stat/functions.c:4040
msgid "known_ys:vector of values of dependent variable"
msgstr "ys_conhecidos: vetor de valores de variável dependente"

#: ../plugins/fn-stat/functions.c:3724 ../plugins/fn-stat/functions.c:4041
msgid ""
"known_xs:array of values of independent variables, defaults to a single "
"vector {1,…,n}"
msgstr ""
"xs_conhecidos: matriz de valores de variáveis independentes, predefinido "
"como vetor único {1,…,n}"

#: ../plugins/fn-stat/functions.c:3725 ../plugins/fn-stat/functions.c:3831
#: ../plugins/fn-stat/functions.c:4043 ../plugins/fn-stat/functions.c:4189
#: ../plugins/fn-stat/functions.c:4288
msgid "affine:if true, the model contains a constant term, defaults to true"
msgstr ""
"afina: se VERDADEIRO, o modelo contém um termo constante, predefinido como "
"VERDADEIRO"

#: ../plugins/fn-stat/functions.c:3726
msgid ""
"stats:if true, some additional statistics are provided, defaults to false"
msgstr ""
"estat: se VERDADEIRO, são fornecidas estatísticas adicionais, predefinido "
"como FALSO"

#: ../plugins/fn-stat/functions.c:3727
msgid ""
"This function returns an array with the first row giving the regression "
"coefficients for the independent variables x_m, x_(m-1),…,x_2, x_1 followed "
"by the y-intercept if @{affine} is true."
msgstr ""
"Esta função devolve uma matriz em que a primeira linha indica os "
"coeficientes de regressão para as variáveis independentes x_m, x_(m-1),…,"
"x_2, x_1 seguidos de intercepção y se @{afina} for VERDADEIRO."

#: ../plugins/fn-stat/functions.c:3730
msgid ""
"If @{stats} is true, the second row contains the corresponding standard "
"errors of the regression coefficients.In this case, the third row contains "
"the R^2 value and the standard error for the predicted value. The fourth row "
"contains the observed F value and its degrees of freedom. Finally, the fifth "
"row contains the regression sum of squares and the residual sum of squares."
msgstr ""
"Se @{estat} for VERDADEIRO, a segunda linha contém os correspondentes erros "
"padrão dos coeficientes de regressão. Neste caso, a terceira linha contém o "
"valor R² e o erro padrão para o valor previsto. A quarta linha contém o "
"valor F observado e os seus graus de liberdade. Finalmente, a quinta linha "
"contém a soma dos quadrados da regressão e a soma residual dos quadrados."

#: ../plugins/fn-stat/functions.c:3737
msgid ""
"If @{affine} is false, R^2 is the uncentered version of the coefficient of "
"determination; that is the proportion of the sum of squares explained by the "
"model."
msgstr ""
"Se @{afina} for FALSO, R² é a versão descentrada do coeficiente de "
"determinação; é a proporção da soma dos quadrados explicada pelo modelo."

#: ../plugins/fn-stat/functions.c:3740 ../plugins/fn-stat/functions.c:4044
msgid ""
"If the length of @{known_ys} does not match the corresponding length of "
"@{known_xs}, this function returns a #NUM! error."
msgstr ""
"Se o comprimento de @{ys_conhecidos} não corresponder ao equivalente de "
"@{xs_conhecidos}, devolve #NUM!."

#: ../plugins/fn-stat/functions.c:3828
msgid "LOGREG:the logarithmic regression"
msgstr "REGLOG: regressão logarítmica"

#: ../plugins/fn-stat/functions.c:3830 ../plugins/fn-stat/functions.c:4286
msgid "known_xs:known x-values; defaults to the array {1, 2, 3, …}"
msgstr ""
"xs_conhecidos: valores x conhecidos, predefinidos como matriz {1, 2, 3 …}"

#: ../plugins/fn-stat/functions.c:3832 ../plugins/fn-stat/functions.c:4190
msgid ""
"stat:if true, extra statistical information will be returned; defaults to "
"FALSE"
msgstr ""
"estat: se VERDADEIRO, são fornecidas estatísticas adicionais, predefinido "
"como FALSO"

#: ../plugins/fn-stat/functions.c:3833
msgid ""
"LOGREG function transforms your x's to z=ln(x) and applies the “least "
"squares” method to fit the linear equation y = m * z + b to your y's and z's "
"--- equivalent to fitting the equation y = m * ln(x) + b to y's and x's. "
"LOGREG returns an array having two columns and one row. m is given in the "
"first column and b in the second. "
msgstr ""
"A função REGLOG transforma os seus xs em z= LN(x) e aplica o método dos "
"quadrados mínimos para acomodar a equação linear y = m * z + b aos seus ys e "
"zs --- equivalente a acomodar a equação y = m * ln(x) + b para ys e xs. "
"REGLOG devolve uma matriz com duas colunas e uma linha. m é indicado na "
"primeira coluna e b na segunda."

#: ../plugins/fn-stat/functions.c:3841
msgid ""
"Any extra statistical information is written below m and b in the result "
"array.  This extra statistical information consists of four rows of data:  "
"In the first row the standard error values for the coefficients m, b are "
"given.  The second row contains the square of R and the standard error for "
"the y estimate. The third row contains the F-observed value and the degrees "
"of freedom.  The last row contains the regression sum of squares and the "
"residual sum of squares.The default of @{stat} is FALSE."
msgstr ""
"Qualquer informação estatística extra é escrita abaixo de m e b na matriz "
"resultante. Esta informação extra consiste em quatro linhas de dados: na 1ª "
"estão os valores de erro padrão para os coeficientes m e b. Na 2ª está R² e "
"o erro padrão para a estimativa y. Na 3ª está o valor F observado e os graus "
"de liberdade. Na 4ª a soma dos quadrados da regressão e a soma residual dos "
"quadrados. A predefinição de @{estat} é FALSO."

#: ../plugins/fn-stat/functions.c:3850 ../plugins/fn-stat/functions.c:4205
#: ../plugins/fn-stat/functions.c:4296
msgid ""
"If @{known_ys} and @{known_xs} have unequal number of data points, this "
"function returns a #NUM! error."
msgstr ""
"Se @{ys_conhecidos} e @{xs_conhecidos} não tiverem o mesmo número de dados, "
"devolve #NUM!."

#: ../plugins/fn-stat/functions.c:3944
msgid "LOGFIT:logarithmic least square fit (using a trial and error method)"
msgstr ""
"SERV.LOG: logaritmo de quadrados mínimos (usando um método de teste e erro)"

#: ../plugins/fn-stat/functions.c:3948
msgid ""
"LOGFIT function applies the “least squares” method to fit the logarithmic "
"equation y = a + b * ln(sign * (x - c)) ,   sign = +1 or -1 to your data. "
"The graph of the equation is a logarithmic curve moved horizontally by c and "
"possibly mirrored across the y-axis (if sign = -1)."
msgstr ""
"A função SERV.LOG aplica o método dos quadrados mínimos para acomodar a "
"equação logarítmica y = a + b * LN(SINAL * (x - c)) ,   SINAL = +1 ou -1 aos "
"seus dados. O gráfico da equação é uma curva logarítmica movida "
"horizontalmente por c e possivelmente espelhada pelo eixo y (se SINAL = -1)."

#: ../plugins/fn-stat/functions.c:3954
msgid ""
"LOGFIT returns an array having five columns and one row. `Sign' is given in "
"the first column, `a', `b', and `c' are given in columns 2 to 4. Column 5 "
"holds the sum of squared residuals."
msgstr ""
"SERV.LOG devolve uma matriz com cinco colunas e uma linha. SINAL 'e indicado "
"na 1ª, a, b e c nas 2ª, 3ª e 4ª. A 5ª contém a soma residual dos quadrados."

#: ../plugins/fn-stat/functions.c:3958
msgid ""
"An error is returned when there are less than 3 different x's or y's, or "
"when the shape of the point cloud is too different from a ``logarithmic'' "
"one."
msgstr ""
"É devolvido um erro quando há menos de 3 xs ou ys diferentes ou quando a "
"forma da nuvem do ponto é demasiado diferente de uma forma logarítmica."

#: ../plugins/fn-stat/functions.c:3961
msgid ""
"You can use the above formula = a + b * ln(sign * (x - c)) or rearrange it "
"to = (exp((y - a) / b)) / sign + c to compute unknown y's or x's, "
"respectively. "
msgstr ""
"Pode usar a fórmula acima = a + b * LN(SINAL * (x - c)) ou rearranjá-la para "
"= (exp((y - a) / b)) / SINAL + c para calcular ys ou xs desconhecidos, "
"respetivamente. "

#: ../plugins/fn-stat/functions.c:3966
msgid ""
"This is non-linear fitting by trial-and-error. The accuracy of `c' is: width "
"of x-range -> rounded to the next smaller (10^integer), times 0.000001. "
"There might be cases in which the returned fit is not the best possible."
msgstr ""
"Esta é a acomodação não linear por tentativa e erro. A precisão de c é: "
"largura do intervalo x arredondada ao próximo menor (10^inteiro), vezes "
"0,000001. Poderá haver casos em que o resultado devolvido não seja o melhor "
"possível."

#: ../plugins/fn-stat/functions.c:4039
msgid ""
"TREND:estimates future values of a given data set using a least squares "
"approximation"
msgstr ""
"TENDÊNCIA: estima valores futuros de um dado conjunto de dados usando a "
"aproximação dos quadrados mínimos"

#: ../plugins/fn-stat/functions.c:4042
msgid ""
"new_xs:array of x-values for which to estimate the y-values; defaults to "
"@{known_xs}"
msgstr ""
"xs_novos: matriz de valores x para os quais estimar valores y, predefinido "
"como @{xs_conhecidos}"

#: ../plugins/fn-stat/functions.c:4046
msgid ""
"Let us assume that the cells A1, A2, …, A5 contain numbers 11.4, 17.3, 21.3, "
"25.9, and 40.1, and the cells B1, B2, ... B5 23.2, 25.8, 29.9, 33.5, and "
"42.7."
msgstr ""
"Vamos assumir que as células A1, A2, …, A5 contêm os números 11,4, 17,3, "
"21,3, 25,9, e 40,1 e as células B1, B2, ... B5 23,2, 25,8, 29,9, 33,5, e "
"42,7."

#: ../plugins/fn-stat/functions.c:4049
msgid "Then TREND(A1:A5,B1:B5) equals {12.1, 15.7, 21.6, 26.7, 39.7}."
msgstr "Então TREND(A1:A5,B1:B5) é igual a {12,1, 15,7, 21,6, 26,7, 39,7}."

#: ../plugins/fn-stat/functions.c:4186
msgid "LOGEST:exponential least square fit"
msgstr "PROJ.LOG; exponencial dos quadrados mínimos"

#: ../plugins/fn-stat/functions.c:4188
msgid "known_xs:known x-values; default to an array {1, 2, 3, …}"
msgstr ""
"xs_conhecidos: valores x conhecidos, predefinida como matriz {1, 2, 3, …}"

#: ../plugins/fn-stat/functions.c:4191
msgid ""
"LOGEST function applies the “least squares” method to fit an exponential "
"curve of the form\ty = b * m{1}^x{1} * m{2}^x{2}... to your data."
msgstr ""
"A função PROJ.LOG aplica o método dos quadrados mínimos para acomodar uma "
"curva exponencial de forma\ty = b * m{1}^x{1} * m{2}^x{2}... aos seus dados."

#: ../plugins/fn-stat/functions.c:4195
msgid "LOGEST returns an array { m{n},m{n-1}, ...,m{1},b }."
msgstr "PROJ.LOG devole uma matriz { m{n},m{n-1}, ...,m{1},b }."

#: ../plugins/fn-stat/functions.c:4196
msgid ""
"Extra statistical information is written below the regression line "
"coefficients in the result array.  Extra statistical information consists of "
"four rows of data.  In the first row the standard error values for the "
"coefficients m1, (m2, ...), b are represented.  The second row contains the "
"square of R and the standard error for the y estimate.  The third row "
"contains the F-observed value and the degrees of freedom.  The last row "
"contains the regression sum of squares and the residual sum of squares."
msgstr ""
"A informação estatística extra é escrita abaixo dos coeficientes da linha de "
"regressão na matriz resultante. Esta informação extra consiste em quatro "
"linhas de dados: na 1ª estão os valores de erro padrão para os coeficientes "
"m1, (m2,...), b. Na 2ª está R² e o erro padrão para a estimativa y. Na 3ª "
"está o valor F observado e os graus de liberdade. Na 4ª a soma dos quadrados "
"da regressão e a soma residual dos quadrados."

#: ../plugins/fn-stat/functions.c:4284
msgid "GROWTH:exponential growth prediction"
msgstr "CRESCIMENTO: previsão de crescimento exponencial"

#: ../plugins/fn-stat/functions.c:4287
msgid ""
"new_xs:x-values for which to estimate the y-values; defaults to @{known_xs}"
msgstr ""
"novos_xs: valores x para os quais estimar novos y, predefinido como "
"@{xs_conhecidos}"

#: ../plugins/fn-stat/functions.c:4289
msgid ""
"GROWTH function applies the “least squares” method to fit an exponential "
"curve to your data and predicts the exponential growth by using this curve."
msgstr ""
"A função CRESCIMENTO aplica o método dos quadrados mínimos para acomodar uma "
"curva exponencial aos seus dados e prevê o crescimento exponencial usando "
"esta curva."

#: ../plugins/fn-stat/functions.c:4294
msgid ""
"GROWTH returns an array having one column and a row for each data point in "
"@{new_xs}."
msgstr ""
"CRESCIMENTO devolve uma matriz com uma coluna e uma linha para cada ponto de "
"dados em @{novos_xs}."

#: ../plugins/fn-stat/functions.c:4385
msgid ""
"FORECAST:estimates a future value according to existing values using simple "
"linear regression"
msgstr ""
"PREVISÃO: estima um valor futuro de acordo com valores existentes, usando "
"uma regressão linear simples"

#: ../plugins/fn-stat/functions.c:4387
msgid "x:x-value whose matching y-value should be forecast"
msgstr "x: valor x cujo correspondente valor y deverá ser a previsão"

#: ../plugins/fn-stat/functions.c:4390
msgid ""
"This function estimates a future value according to existing values using "
"simple linear regression."
msgstr ""
"Esta função estima um valor futuro de acordo com valores existentes, usando "
"uma regressão linear simples"

#: ../plugins/fn-stat/functions.c:4392 ../plugins/fn-stat/functions.c:4449
#: ../plugins/fn-stat/functions.c:4502
msgid ""
"If @{known_xs} or @{known_ys} contains no data entries or different number "
"of data entries, this function returns a #N/A error."
msgstr ""
"Se @{xs_conhecidos} ou @{ys_conhecidos} não contiverem dados ou tiverem "
"tamanhos diferentes, devolve #N/D!"

#: ../plugins/fn-stat/functions.c:4394
msgid ""
"If the variance of the @{known_xs} is zero, this function returns a #DIV/0 "
"error."
msgstr "Se a variância de @xs_conhecidos} for zero, devolve #DIV/0."

#: ../plugins/fn-stat/functions.c:4400
msgid "Then FORECAST(7,A1:A5,B1:B5) equals -10.859397661."
msgstr "Então PREVISÃO(7,A1:A5,B1:B5) é igual a -10,859397661."

#: ../plugins/fn-stat/functions.c:4446
msgid "INTERCEPT:the intercept of a linear regression line"
msgstr "INTERCETAR: a interceção de uma linha de regressão linear"

#: ../plugins/fn-stat/functions.c:4451 ../plugins/fn-stat/functions.c:4504
msgid ""
"If the variance of the @{known_xs} is zero, this function returns #DIV/0 "
"error."
msgstr "Se a variância de @xs_conhecidos} for zero, devolve #DIV/0."

#: ../plugins/fn-stat/functions.c:4457
msgid "Then INTERCEPT(A1:A5,B1:B5) equals -20.785117212."
msgstr "Então INTERCETAR(A1:A5,B1:B5) é igual a -20,785117212."

#: ../plugins/fn-stat/functions.c:4498
msgid "SLOPE:the slope of a linear regression line"
msgstr "DECLIVE: o declive de uma linha de regressão linear"

#: ../plugins/fn-stat/functions.c:4509
msgid "Then SLOPE(A1:A5,B1:B5) equals 1.417959936."
msgstr "Então DECLIVE(A1:A5,B1:B5) é igual a 1,417959936."

#: ../plugins/fn-stat/functions.c:4550
msgid "SUBTOTAL:the subtotal of the given list of arguments"
msgstr "SUBTOTAL: o subtotal da lista de argumentos indicada"

#: ../plugins/fn-stat/functions.c:4551
msgid ""
"function_nbr:determines which function to use according to the following "
"table:\n"
"\t1   AVERAGE\n"
"\t2   COUNT\n"
"\t3   COUNTA\n"
"\t4   MAX\n"
"\t5   MIN\n"
"\t6   PRODUCT\n"
"\t7   STDEV\n"
"\t8   STDEVP\n"
"\t9   SUM\n"
"\t10   VAR\n"
"\t11   VARP"
msgstr ""
"num_função: determina que função a usar, de acordo com a tabela seguinte:\n"
"\t1   MÉDIA\n"
"\t2   CONTAR\n"
"\t3   CONTAR.VAL\n"
"\t4   MÁXIMO\n"
"\t5   MÍNIMO\n"
"\t6   PRODUTO\n"
"\t7   DESVPAD\n"
"\t8   DESVPADP\n"
"\t9   SOMA\n"
"\t10   VAR\n"
"\t11   VARP"

#: ../plugins/fn-stat/functions.c:4564
msgid "ref1:first value"
msgstr "ref1: primeiro valor"

#: ../plugins/fn-stat/functions.c:4565
msgid "ref2:second value"
msgstr "ref2: segundo valor"

#: ../plugins/fn-stat/functions.c:4567
msgid ""
"Let us assume that the cells A1, A2, ..., A5 contain numbers 23, 27, 28, 33, "
"and 39."
msgstr ""
"Vamos assumir que as células A1, A2, ..., A5 contêm os números 23, 27, 28, "
"33, and 39."

#: ../plugins/fn-stat/functions.c:4568
msgid ""
"Then SUBTOTAL(1,A1:A5) equals 30.SUBTOTAL(6,A1:A5) equals 22378356."
"SUBTOTAL(7,A1:A5) equals 6.164414003.SUBTOTAL(9,A1:A5) equals 150."
"SUBTOTAL(11,A1:A5) equals 30.4."
msgstr ""
"Então SUBTOTAL(1,A1:A5) é igual a 30. SUBTOTAL(6,A1:A5) é igual a 22378356. "
"SUBTOTAL(7,A1:A5) é igual a 6.164414003. SUBTOTAL(9,A1:A5) é igual a 150. "
"SUBTOTAL(11,A1:A5) é igual a 30,4."

#: ../plugins/fn-stat/functions.c:4640
msgid "CRONBACH:Cronbach's alpha"
msgstr "CRONBACH: alfa de Cronbach"

#: ../plugins/fn-stat/functions.c:4641
msgid "ref1:first data set"
msgstr "ref1: primeiro conjunto de dados"

#: ../plugins/fn-stat/functions.c:4642
msgid "ref2:second data set"
msgstr "ref2: segundo conjunto de dados"

#: ../plugins/fn-stat/functions.c:4752
msgid ""
"GEOMDIST:probability mass or cumulative distribution function of the "
"geometric distribution"
msgstr ""
"DISTGEOM: função de massa de probabilidade ou de distribuição cumulativa da "
"distribuição geométrica"

#: ../plugins/fn-stat/functions.c:4753
msgid "k:number of trials"
msgstr "k: número de tentativas"

#: ../plugins/fn-stat/functions.c:4754
msgid "p:probability of success in any trial"
msgstr "p: probabilidade de sucesso em cada tentativa"

#: ../plugins/fn-stat/functions.c:4756
msgid "If @{k} < 0 this function returns a #NUM! error."
msgstr "Se @{k} < 0 devolve #NUM!."

#: ../plugins/fn-stat/functions.c:4783
msgid "LOGISTIC:probability density function of the logistic distribution"
msgstr ""
"LOGÍSTICA: função de densidade da probabilidade da distribuição logística"

#: ../plugins/fn-stat/functions.c:4814
msgid "PARETO:probability density function of the Pareto distribution"
msgstr "PARETO: função de densidade da probabilidade da distribuição Pareto"

#: ../plugins/fn-stat/functions.c:4816
msgid "a:exponent"
msgstr "a: expoente"

#: ../plugins/fn-stat/functions.c:4817 ../plugins/fn-stat/functions.c:4910
msgid "b:scale parameter"
msgstr "b: parâmetro de escala"

#: ../plugins/fn-stat/functions.c:4848
msgid "RAYLEIGH:probability density function of the Rayleigh distribution"
msgstr ""
"RAYLEIGH: função de densidade da probabilidade da distribuição Rayleigh"

#: ../plugins/fn-stat/functions.c:4850 ../plugins/fn-stat/functions.c:4871
msgid "sigma:scale parameter"
msgstr "sigma: parâmetro de escala"

#: ../plugins/fn-stat/functions.c:4868
msgid ""
"RAYLEIGHTAIL:probability density function of the Rayleigh tail distribution"
msgstr ""
"CAUDARAYLEIGH: função de densidade da probabilidade da distribuição de cauda "
"Rayleigh"

#: ../plugins/fn-stat/functions.c:4870
msgid "a:lower limit"
msgstr "a: limite inferior"

#: ../plugins/fn-stat/functions.c:4906
msgid ""
"EXPPOWDIST:the probability density function of the Exponential Power "
"distribution"
msgstr ""
"DIST.PTO.EXP: função de densidade da probabilidade da distribuição de "
"potência exponencial"

#: ../plugins/fn-stat/functions.c:4912
msgid ""
"This distribution has been recommended for lifetime analysis when a U-shaped "
"hazard function is desired. This corresponds to rapid failure once the "
"product starts to wear out after a period of steady or even improving "
"reliability."
msgstr ""
"Esta distribuição tem sido recomendada para análise vitalícia quando se "
"pretende uma função de perigo em forma de U. Isto corresponde a falha rápida "
"uma vez que o produto se comece a desgastar após um período estável ou mesmo "
"de melhoria."

#: ../plugins/fn-stat/functions.c:4940
msgid "LAPLACE:probability density function of the Laplace distribution"
msgstr "LAPLACE: função de densidade da probabilidade da distribuição Laplace"

#: ../plugins/fn-stat/functions.c:4942
msgid "a:mean"
msgstr "a: média"

#: ../plugins/fn-stat/functions.c:4963
msgid ""
"PERMUTATIONA:the number of permutations of @{y} objects chosen from @{x} "
"objects with repetition allowed"
msgstr ""
"PERMUTARA: o número de permutações de objetos @{y} escolhidos de objetos "
"@{x} com repetição permitida"

#: ../plugins/fn-stat/functions.c:4964
msgid "x:total number of objects"
msgstr "x: total de objetos"

#: ../plugins/fn-stat/functions.c:4965
msgid "y:number of selected objects"
msgstr "y: número de objetos selecionados"

#: ../plugins/fn-stat/functions.c:4966
msgid "If both @{x} and @{y} equal 0, PERMUTATIONA returns 1."
msgstr "Se tanto @{x} como @{y} forem iguais a 0, devolve 1."

#: ../plugins/fn-stat/functions.c:4967
msgid "If @{x} < 0 or @{y} < 0, PERMUTATIONA returns #NUM!"
msgstr "Se @{x} < 0 ou @{y} < 0, devolve #NUM!"

#: ../plugins/fn-stat/functions.c:4968
msgid "If @{x} or @{y} are not integers, they are truncated"
msgstr "Se @{x} ou @{y} não forem inteiros, serão truncados"

#: ../plugins/fn-stat/functions.c:4996
msgid "LKSTEST:Lilliefors (Kolmogorov-Smirnov) Test of Normality"
msgstr "TESTELKS: teste de normalidade de Lilliefors (Kolmogorov-Smirnov)"

#: ../plugins/fn-stat/functions.c:4997 ../plugins/fn-stat/functions.c:5114
#: ../plugins/fn-stat/functions.c:5198 ../plugins/fn-stat/functions.c:5283
msgid "x:array of sample values"
msgstr "x: matriz de valores simples"

#: ../plugins/fn-stat/functions.c:4998
msgid ""
"This function returns an array with the first row giving the p-value of the "
"Lilliefors (Kolmogorov-Smirnov) Test, the second row the test statistic of "
"the test, and the third the number of observations in the sample."
msgstr ""
"Esta função devolve uma matriz com os valore p do teste de Lilliefors "
"(Kolmogorov-Smirnov) na primeira linha, a estatística do teste na segunda e "
"o número de observações na amostra na terceira."

#: ../plugins/fn-stat/functions.c:5000
msgid "If there are less than 5 sample values, LKSTEST returns #VALUE!"
msgstr "Se houver menos de 5 valores amostra, devolve #VALOR!."

#: ../plugins/fn-stat/functions.c:5002
msgid "wiki:en:Lilliefors_test"
msgstr "wiki:pt:Teste_Kolmogorov-Smirnov"

#: ../plugins/fn-stat/functions.c:5113
msgid "SFTEST:Shapiro-Francia Test of Normality"
msgstr "TESTESF: teste de normalidade Shapiro-Francia"

#: ../plugins/fn-stat/functions.c:5115
msgid ""
"This function returns an array with the first row giving the p-value of the "
"Shapiro-Francia Test, the second row the test statistic of the test, and the "
"third the number of observations in the sample."
msgstr ""
"Esta função devolve uma matriz com os valore p do teste de Shapiro-Francia "
"na primeira linha, a estatística do teste na segunda e o número de "
"observações na amostra na terceira."

#: ../plugins/fn-stat/functions.c:5117
msgid ""
"If there are less than 5 or more than 5000 sample values, SFTEST returns "
"#VALUE!"
msgstr "Se houver menos de 5 ou mais de 5000 valores amostra, devolve #VALOR!."

#: ../plugins/fn-stat/functions.c:5197
msgid "CVMTEST:Cramér-von Mises Test of Normality"
msgstr "TESTECVM: teste de normalidade Cramér-von Mises"

#: ../plugins/fn-stat/functions.c:5199
msgid ""
"This function returns an array with the first row giving the p-value of the "
"Cramér-von Mises Test, the second row the test statistic of the test, and "
"the third the number of observations in the sample."
msgstr ""
"Esta função devolve uma matriz com os valore p do teste de Cramér-von Mises "
"na primeira linha, a estatística do teste na segunda e o número de "
"observações na amostra na terceira."

#: ../plugins/fn-stat/functions.c:5201
msgid "If there are less than 8 sample values, CVMTEST returns #VALUE!"
msgstr "Se houver menos de 8 valores amostra, devolve #VALOR!."

#: ../plugins/fn-stat/functions.c:5203
msgid "wiki:en:Cramér–von-Mises_criterion"
msgstr "wiki:pt:Teste_de_normalidade"

#: ../plugins/fn-stat/functions.c:5282
msgid "ADTEST:Anderson-Darling Test of Normality"
msgstr "TESTEAD: teste de normalidade Anderson-Darling"

#: ../plugins/fn-stat/functions.c:5284
msgid ""
"This function returns an array with the first row giving the p-value of the "
"Anderson-Darling Test, the second row the test statistic of the test, and "
"the third the number of observations in the sample."
msgstr ""
"Esta função devolve uma matriz com os valore p do teste de Anderson-Darling "
"na primeira linha, a estatística do teste na segunda e o número de "
"observações na amostra na terceira."

#: ../plugins/fn-stat/functions.c:5286
msgid "If there are less than 8 sample values, ADTEST returns #VALUE!"
msgstr "Se houver menos de 8 valores amostra, devolve #VALOR!."

#: ../plugins/fn-stat/functions.c:5288
msgid "wiki:en:Anderson–Darling_test"
msgstr "wiki:pt:Teste_de_normalidade"

#: ../plugins/fn-string/functions.c:56
msgid "CHAR:the CP1252 (Windows-1252) character for the code point @{x}"
msgstr "CARÁCTER: o carácter CP1252 (Windows-1252) para o ponto de código @{x}"

#: ../plugins/fn-string/functions.c:57
msgid "x:code point"
msgstr "x: ponto de código"

#: ../plugins/fn-string/functions.c:58
msgid "CHAR(@{x}) returns the CP1252 (Windows-1252) character with code @{x}."
msgstr ""
"CARÁCTER(@{x}  devolve o carácter CP1252 (Windows-1252) para o ponto de "
"código @{x}"

#: ../plugins/fn-string/functions.c:59
msgid "@{x} must be in the range 1 to 255."
msgstr "@{x} tem de estar entre 1 e 255."

#: ../plugins/fn-string/functions.c:60 ../plugins/fn-string/functions.c:136
msgid ""
"CP1252 (Windows-1252) is also known as the \"ANSI code page\", but it is not "
"an ANSI standard."
msgstr ""
"CP1252 (Windows-1252) também é conhecida como \"página de código ANSI\", mas "
"não é uma norma ANSI."

#: ../plugins/fn-string/functions.c:62
msgid ""
"CP1252 (Windows-1252) is based on an early draft of ISO-8859-1, and contains "
"all of its printable characters. It also contains all of ISO-8859-15's "
"printable characters (but partially at different positions.)"
msgstr ""
"CP1252 (Windows-1252) baseia-se num rascunho da norma ISO-8859-1 e contém "
"todos os seus caracteres imprimíveis. Também contém todos os caracteres "
"imprimíveis da norma ISO-8859-15 (mas parte deles em posições diferentes)."

#: ../plugins/fn-string/functions.c:66 ../plugins/fn-string/functions.c:138
msgid ""
"In CP1252 (Windows-1252), 129, 141, 143, 144, and 157 do not have matching "
"characters."
msgstr ""
"Na CP1252 (Windows-1252), 129, 141, 143, 144 e 157 não têm caracteres "
"correspondentes."

#: ../plugins/fn-string/functions.c:67 ../plugins/fn-string/functions.c:139
msgid ""
"For @{x} from 1 to 255 except 129, 141, 143, 144, and 157 we have "
"CODE(CHAR(@{x}))=@{x}."
msgstr ""
"Para @{x} de 1 até 255 exceto 129, 141, 143, 144 e 157 temos "
"CÓDIGO(CARÁCTER(@{x}))=@{x}."

#: ../plugins/fn-string/functions.c:105
msgid ""
"UNICHAR:the Unicode character represented by the Unicode code point @{x}"
msgstr "CARACTUNI: o carácter Unicode representado pelo ponto de código @{x}"

#: ../plugins/fn-string/functions.c:106
msgid "x:Unicode code point"
msgstr "x: ponto de código Unicode"

#: ../plugins/fn-string/functions.c:133
msgid "CODE:the CP1252 (Windows-1252) code point for the character @{c}"
msgstr "CÓDIGO:  o carácter CP1252 (Windows-1252) para o ponto de código @{c}"

#: ../plugins/fn-string/functions.c:134 ../plugins/fn-string/functions.c:179
msgid "c:character"
msgstr "c: carácter"

#: ../plugins/fn-string/functions.c:135
msgid "@{c} must be a valid CP1252 (Windows-1252) character."
msgstr "@{c} tem de ser um carácter CP1252 (Windows-1252) válido."

#: ../plugins/fn-string/functions.c:137
msgid ""
"CP1252 (Windows-1252) is based on an early draft of ISO-8859-1, and contains "
"all of its printable characters (but partially at different positions.)"
msgstr ""
"CP1252 (Windows-1252) baseia-se num rascunho da norma ISO-8859-1 e contém "
"todos os seus caracteres imprimíveis (mas parte deles em posições "
"diferentes)."

#: ../plugins/fn-string/functions.c:178
msgid "UNICODE:the Unicode code point for the character @{c}"
msgstr "UNICODE:o ponto de código Unicode para o carácter @{c}"

#: ../plugins/fn-string/functions.c:248
msgid "EXACT:TRUE if @{string1} is exactly equal to @{string2}"
msgstr "EXACT:VERDADEIRO se @{cadeia1} for exatamente igual a @{cadeia2}"

#: ../plugins/fn-string/functions.c:249
msgid "string1:first string"
msgstr "cadeia1: a primeira cadeia"

#: ../plugins/fn-string/functions.c:250
msgid "string2:second string"
msgstr "cadeia2: a segunda cadeia"

#: ../plugins/fn-string/functions.c:268
msgid "LEN:the number of characters of the string @{s}"
msgstr "COMPRIMENTO: o número de caracteres da cadeia @{c}"

#: ../plugins/fn-string/functions.c:269 ../plugins/fn-string/functions.c:286
#: ../plugins/fn-string/functions.c:304 ../plugins/fn-string/functions.c:336
#: ../plugins/fn-string/functions.c:388 ../plugins/fn-string/functions.c:428
#: ../plugins/fn-string/functions.c:515 ../plugins/fn-string/functions.c:551
msgid "s:the string"
msgstr "c: a cadeia"

#: ../plugins/fn-string/functions.c:285
msgid "LENB:the number of bytes in the string @{s}"
msgstr "COMPRIMENTOB: o número de bytes da cadeia @{c}"

#: ../plugins/fn-string/functions.c:303
msgid "LEFT:the first @{num_chars} characters of the string @{s}"
msgstr "ESQUERDA: os primeiros @{num_car} caracteres da cadeia @{c}"

#: ../plugins/fn-string/functions.c:305 ../plugins/fn-string/functions.c:516
msgid "num_chars:the number of characters to return (defaults to 1)"
msgstr "num_car: o número de caracteres a devolver, predefinido como 1"

#: ../plugins/fn-string/functions.c:306
msgid ""
"If the string @{s} is in a right-to-left script, the returned first "
"characters are from the right of the string."
msgstr ""
"Se a cadeia @{c} estiver escrita da direita para a esquerda, os caracteres "
"devolvidos são da direita da cadeia."

#: ../plugins/fn-string/functions.c:335
msgid ""
"LEFTB:the first characters  of the string @{s} comprising at most "
"@{num_bytes} bytes"
msgstr ""
"ESQUERDAB: os primeiros caracteres da cadeia @{c} compreendendo no máximo "
"@num_bytes} bytes"

#: ../plugins/fn-string/functions.c:337 ../plugins/fn-string/functions.c:430
#: ../plugins/fn-string/functions.c:552
msgid "num_bytes:the maximum number of bytes to return (defaults to 1)"
msgstr "num_bytes: o máximo número de bytes a devolver, predefinido como 1."

#: ../plugins/fn-string/functions.c:338 ../plugins/fn-string/functions.c:431
#: ../plugins/fn-string/functions.c:553 ../plugins/fn-string/functions.c:997
#: ../plugins/fn-string/functions.c:1463
msgid ""
"The semantics of this function is subject to change as various applications "
"implement it."
msgstr ""
"A semântica desta função é assunto a alterar dado que muitas aplicações a "
"implementam."

#: ../plugins/fn-string/functions.c:339
msgid ""
"If the string is in a right-to-left script, the returned first characters "
"are from the right of the string."
msgstr ""
"Se a cadeia estiver escrita da direita para a esquerda, os caracteres "
"devolvidos são da direita da cadeia."

#: ../plugins/fn-string/functions.c:340 ../plugins/fn-string/functions.c:432
#: ../plugins/fn-string/functions.c:476 ../plugins/fn-string/functions.c:555
#: ../plugins/fn-string/functions.c:998 ../plugins/fn-string/functions.c:1464
msgid ""
"While this function is syntactically Excel compatible, the differences in "
"the underlying text encoding will usually yield different results."
msgstr ""
"Ainda que a função seja sintaticamente compatível com Excel, as diferenças "
"entre a codificação de texto subjacente resultarão em diferentes valores."

#: ../plugins/fn-string/functions.c:341 ../plugins/fn-string/functions.c:434
#: ../plugins/fn-string/functions.c:478 ../plugins/fn-string/functions.c:556
#: ../plugins/fn-string/functions.c:1000 ../plugins/fn-string/functions.c:1466
msgid ""
"While this function is OpenFormula compatible, most of its behavior is, at "
"this time, implementation specific."
msgstr ""
"Ainda que esta função seja compatível com OpenFormula, a maioria do seu "
"comportamento, de momento, é específico da implementação."

#: ../plugins/fn-string/functions.c:369
msgid "LOWER:a lower-case version of the string @{text}"
msgstr "MINÚSCULAS: uma versão em minúsculas da cadeia @{texto}"

#: ../plugins/fn-string/functions.c:387
msgid ""
"MID:the substring of the string @{s} starting at position @{position} "
"consisting of @{length} characters"
msgstr ""
"CENTRO: a subcadeia de @{c} começando em @{posição}, com @{comprimento} "
"caracteres"

#: ../plugins/fn-string/functions.c:389
msgid "position:the starting position"
msgstr "posição: a posição inicial"

#: ../plugins/fn-string/functions.c:390
msgid "length:the number of characters to return"
msgstr "comprimento: número de caracteres a devolver"

#: ../plugins/fn-string/functions.c:427
msgid ""
"MIDB:the characters following the first @{start_pos} bytes comprising at "
"most @{num_bytes} bytes"
msgstr ""
"CENTROB: os caracteres a seguir aos primeiros @{pos_inicial} bytes, com o "
"máximo de @{num_bytes} bytes"

#: ../plugins/fn-string/functions.c:429
msgid "start_pos:the number of the byte with which to start (defaults to 1)"
msgstr ""
"pos_inicial: o número de bytes com os quais começar, predefinido como 1"

#: ../plugins/fn-string/functions.c:471
msgid ""
"FINDB:first byte position of @{string1} in @{string2} following byte "
"position @{start}"
msgstr ""
"LOCALIZARB: primeira posição de byte da @{cadeia1} na @{cadeia2} a seguir à "
"posição {início}"

#: ../plugins/fn-string/functions.c:472 ../plugins/fn-string/functions.c:799
msgid "string1:search string"
msgstr "cadeia1: cadeia a procurar"

#: ../plugins/fn-string/functions.c:473 ../plugins/fn-string/functions.c:800
msgid "string2:search field"
msgstr "cadeia2: cadeia onde procurar"

#: ../plugins/fn-string/functions.c:474 ../plugins/fn-string/functions.c:1453
msgid "start:starting byte position, defaults to 1"
msgstr "início: posição de byte inicial, predefinida como 1"

#: ../plugins/fn-string/functions.c:475 ../plugins/fn-string/functions.c:802
msgid "This search is case-sensitive."
msgstr "Esta procura é sensível a maiúsculas."

#: ../plugins/fn-string/functions.c:514
msgid "RIGHT:the last @{num_chars} characters of the string @{s}"
msgstr "DIREITA: os últimos {num_car} da cadeia @c}"

#: ../plugins/fn-string/functions.c:517 ../plugins/fn-string/functions.c:554
msgid ""
"If the string @{s} is in a right-to-left script, the returned last "
"characters are from the left of the string."
msgstr ""
"Se a cadeia estiver escrita da direita para a esquerda, os caracteres "
"devolvidos são da esquerda da cadeia."

#: ../plugins/fn-string/functions.c:550
msgid ""
"RIGHTB:the last characters of the string @{s} comprising at most "
"@{num_bytes} bytes"
msgstr ""
"DIREITAB: os últimos caracteres da cadeia @{c} compreendendo no máximo "
"@num_bytes} bytes"

#: ../plugins/fn-string/functions.c:585
msgid "UPPER:an upper-case version of the string @{text}"
msgstr "MAIÚSCULAS: uma versão em maiúsculas da cadeia @{texto}"

#: ../plugins/fn-string/functions.c:604
msgid "CONCATENATE:the concatenation of the strings @{s1}, @{s2},…"
msgstr "CONCATENAR: a concatenação das cadeias @{c1}, @{c2},…"

#: ../plugins/fn-string/functions.c:605 ../plugins/fn-string/functions.c:626
#: ../plugins/fn-string/functions.c:647
msgid "s1:first string"
msgstr "c1: a primeira cadeia"

#: ../plugins/fn-string/functions.c:606 ../plugins/fn-string/functions.c:627
#: ../plugins/fn-string/functions.c:648
msgid "s2:second string"
msgstr "c2: a segunda cadeia"

#: ../plugins/fn-string/functions.c:625
msgid "CONCAT:the concatenation of the strings @{s1}, @{s2},…"
msgstr "CONCATENAR: a concatenação das cadeias @{c1}, @{c2},…"

#: ../plugins/fn-string/functions.c:630
msgid "This function is identical to CONCATENATE"
msgstr "Esta função é idêntica ao CONCATENAR"

#: ../plugins/fn-string/functions.c:644
msgid ""
"TEXTJOIN:the concatenation of the strings @{s1}, @{s2},… delimited by @{del}"
msgstr "JUNTARTEXTO: a concatenação das cadeias @{c1}, @{c2},…"

#: ../plugins/fn-string/functions.c:645
msgid "del:delimiter"
msgstr "del: delimitador"

#: ../plugins/fn-string/functions.c:646
msgid "blank:ignore blanks"
msgstr "branco:ignorar brancos"

#: ../plugins/fn-string/functions.c:725
msgid "REPT:@{num} repetitions of string @{text}"
msgstr "REPT: @{num} repetições da cadeia @{texto}"

#: ../plugins/fn-string/functions.c:727
msgid "num:non-negative integer"
msgstr "num: inteiro não negativo"

#: ../plugins/fn-string/functions.c:769
msgid "CLEAN:@{text} with any non-printable characters removed"
msgstr "LIMPAR: remove todos os caracteres não imprimíveis de @{texto}"

#: ../plugins/fn-string/functions.c:771
msgid ""
"CLEAN removes non-printable characters from its argument leaving only "
"regular characters and white-space."
msgstr ""
"LIMPAR remove todos os caracteres não imprimíveis do seu argumento, deixando "
"só caracteres regulares e espaços."

#: ../plugins/fn-string/functions.c:798
msgid ""
"FIND:first position of @{string1} in @{string2} following position @{start}"
msgstr ""
"LOCALIZAR: primeiraposição de @{cadeia1} na @{cadeia2} depois da posição "
"@{início}"

#: ../plugins/fn-string/functions.c:801 ../plugins/fn-string/functions.c:1410
msgid "start:starting position, defaults to 1"
msgstr "início: posição inicial, predefinida como 1"

#: ../plugins/fn-string/functions.c:836
msgid "FIXED:formatted string representation of @{num}"
msgstr "FIXO: representação de @{num} como cadeia formatada"

#: ../plugins/fn-string/functions.c:837 ../plugins/fn-string/functions.c:1335
msgid "num:number"
msgstr "num: número"

#: ../plugins/fn-string/functions.c:838
msgid "decimals:number of decimals"
msgstr "decimais: número de casas decimais"

#: ../plugins/fn-string/functions.c:839
msgid ""
"no_commas:TRUE if no thousand separators should be used, defaults to FALSE"
msgstr ""
"sem_pontos: VERDADEIRO se não se deve usar separador dos milhares, "
"predefinido como FALSO"

#: ../plugins/fn-string/functions.c:896
msgid "PROPER:@{text} with initial of each word capitalised"
msgstr ""
"INICIAL.MAIÚSCULA: @{texto} com a letra inicial de cada palavra em maiúsculas"

#: ../plugins/fn-string/functions.c:938
msgid ""
"REPLACE:string @{old} with @{num} characters starting at @{start} replaced "
"by @{new}"
msgstr ""
"SUBSTITUIR: cadeia @{antiga} com @{num} caracteres, começando em @{início} "
"substituída por @nova}"

#: ../plugins/fn-string/functions.c:940 ../plugins/fn-string/functions.c:991
msgid "old:original text"
msgstr "antiga: texto original"

#: ../plugins/fn-string/functions.c:941
msgid "start:starting position"
msgstr "início: posição inicial"

#: ../plugins/fn-string/functions.c:942
msgid "num:number of characters to be replaced"
msgstr "num: número de caracteres a substituir"

#: ../plugins/fn-string/functions.c:943 ../plugins/fn-string/functions.c:994
#: ../plugins/fn-string/functions.c:1263
msgid "new:replacement string"
msgstr "nova: cadeia de substituição"

#: ../plugins/fn-string/functions.c:989
msgid ""
"REPLACEB:string @{old} with up to @{num} bytes starting at @{start} replaced "
"by @{new}"
msgstr ""
"SUBSTITUIRB: cadeia @{antiga} com até @{num} bytes, começando em @{início} "
"substituída por @nova}"

#: ../plugins/fn-string/functions.c:992
msgid "start:starting byte position"
msgstr "início: posição de byte inicial"

#: ../plugins/fn-string/functions.c:993
msgid "num:number of bytes to be replaced"
msgstr "num: número de bytes a substituir"

#: ../plugins/fn-string/functions.c:995
msgid ""
"REPLACEB replaces the string of valid unicode characters starting at the "
"byte @{start} and ending at @{start}+@{num}-1 with the string @{new}."
msgstr ""
"SUBSTITUIRB substitui a cadeia de caracteres Unicode válidos começando no "
"byte @{início} e terminando  em @{início}+@{num}-1 pela cadeia @{nova}"

#: ../plugins/fn-string/functions.c:1044
msgid "T:@{value} if and only if @{value} is text, otherwise empty"
msgstr "T: @{valor} se e só se @{valor} for texto, senão vazia"

#: ../plugins/fn-string/functions.c:1045
msgid "value:original value"
msgstr "valor: valor original"

#: ../plugins/fn-string/functions.c:1067
msgid "TEXT:@{value} as a string formatted as @{format}"
msgstr "TEXTO: @{valor} como cadeia formatada como @{formato}"

#: ../plugins/fn-string/functions.c:1068
msgid "value:value to be formatted"
msgstr "valor: valor a formatar"

#: ../plugins/fn-string/functions.c:1069
msgid "format:desired format"
msgstr "formato: formato desejado"

#: ../plugins/fn-string/functions.c:1121
msgid "TRIM:@{text} with only single spaces between words"
msgstr "COMPRIMIR: @{texto} com espaços só entre as palavras"

#: ../plugins/fn-string/functions.c:1168
msgid "VALUE:numeric value of @{text}"
msgstr "VALOR: valor numérico de @{texto}"

#: ../plugins/fn-string/functions.c:1201
msgid "NUMBERVALUE:numeric value of @{text}"
msgstr "VALORNUMÉRICO: valor numérico de @{texto}"

#: ../plugins/fn-string/functions.c:1203
msgid "separator:decimal separator"
msgstr "separador: separador decimal"

#: ../plugins/fn-string/functions.c:1204
msgid ""
"If @{text} does not look like a decimal number, NUMBERVALUE returns the "
"value VALUE would return (ignoring the given @{separator})."
msgstr ""
"Se @{texto} não se parecer com um número decimal, VALORNUMÉRICO devolve o "
"mesmo que VALOR devolveria (ignorando o @{separador} indicado."

#: ../plugins/fn-string/functions.c:1260
msgid "SUBSTITUTE:@{text} with all occurrences of @{old} replaced by @{new}"
msgstr ""
"SUBST: @{texto} com todas as ocorrências de @{antiga} substituídas por "
"@{nova}"

#: ../plugins/fn-string/functions.c:1261 ../plugins/fn-string/functions.c:1645
msgid "text:original text"
msgstr "texto: texto original"

#: ../plugins/fn-string/functions.c:1262
msgid "old:string to be replaced"
msgstr "antiga: cadeia a substituir"

#: ../plugins/fn-string/functions.c:1264
msgid ""
"num:if @{num} is specified and a number only the @{num}th occurrence of "
"@{old} is replaced"
msgstr ""
"num: se @{num} for especificado e um número só, a @{num}ª ocorrência de "
"@{antiga} é substituída"

#: ../plugins/fn-string/functions.c:1334
msgid "DOLLAR:@{num} formatted as currency"
msgstr "MOEDA: @{num} formatado como moeda"

#: ../plugins/fn-string/functions.c:1336
msgid "decimals:decimals"
msgstr "decimais: casas decimais"

#: ../plugins/fn-string/functions.c:1406
msgid ""
"SEARCH:the location of the @{search} string within @{text} after position "
"@{start}"
msgstr ""
"PROCURAR: a localização da cadeia @{procura} dentro de @{texto} após a "
"posição @{início}"

#: ../plugins/fn-string/functions.c:1408 ../plugins/fn-string/functions.c:1451
msgid "search:search string"
msgstr "procura: cadeia a procurar"

#: ../plugins/fn-string/functions.c:1409 ../plugins/fn-string/functions.c:1452
msgid "text:search field"
msgstr "texto: cadeia onde procurar"

#: ../plugins/fn-string/functions.c:1411 ../plugins/fn-string/functions.c:1454
msgid ""
"@{search} may contain wildcard characters (*) and question marks (?). A "
"question mark matches any single character, and a wildcard matches any "
"string including the empty string. To search for * or ?, precede the symbol "
"with ~."
msgstr ""
"@{procura}pode conter asteriscos (*) e pontos de interrogação (?). Um ponto "
"de interrogação corresponde a qualquer caracter único e um asterisco "
"corresponde a qualquer cadeia, incluindo a vazia. Para procurar por * ou ? "
"anteceda o símbolo com um til (~)."

#: ../plugins/fn-string/functions.c:1416 ../plugins/fn-string/functions.c:1459
msgid "This search is not case sensitive."
msgstr "Esta procura não é sensível a maiúsculas."

#: ../plugins/fn-string/functions.c:1417
msgid "If @{search} is not found, SEARCH returns #VALUE!"
msgstr "Se @{procura} não for encontrada, devolve #VALOR!"

#: ../plugins/fn-string/functions.c:1418
msgid ""
"If @{start} is less than one or it is greater than the length of @{text}, "
"SEARCH returns #VALUE!"
msgstr ""
"Se @{início}for menor que 1 ou maior que o comprimento de @{texto}, devolve "
"#VALOR!."

#: ../plugins/fn-string/functions.c:1449
msgid ""
"SEARCHB:the location of the @{search} string within @{text} after byte "
"position @{start}"
msgstr ""
"PROCURARB: a localização da cadeia @{procura} dentro de @{texto} após a "
"posição de byte @{início}"

#: ../plugins/fn-string/functions.c:1460
msgid "If @{search} is not found, SEARCHB returns #VALUE!"
msgstr "Se @{procura} não for encontrada, devolve #VALOR!"

#: ../plugins/fn-string/functions.c:1461
msgid ""
"If @{start} is less than one or it is greater than the byte length of "
"@{text}, SEARCHB returns #VALUE!"
msgstr ""
"Se @{início}for menor que 1 ou maior que o comprimento em bytes de @{texto}, "
"devolve #VALOR!."

#: ../plugins/fn-string/functions.c:1517
msgid ""
"ASC:text with full-width katakana and ASCII characters converted to half-"
"width"
msgstr ""
"ASC: texto de largura completa, katakana ou ASCII, convertido para meia "
"largura"

#: ../plugins/fn-string/functions.c:1519
msgid ""
"ASC converts full-width katakana and ASCII characters to half-width "
"equivalent characters, copying all others. "
msgstr ""
"ASC converte texto de largura completa, katakana ou ASCII, para o "
"equivalente de meia largura, copiando todos os outros."

#: ../plugins/fn-string/functions.c:1520 ../plugins/fn-string/functions.c:1648
msgid ""
"The distinction between half-width and full-width characters is described in "
"http://www.unicode.org/reports/tr11/."
msgstr ""
"A distinção entre caracteres de meia largura e largura completa é descrita "
"em http://www.unicode.org/reports/tr11/."

#: ../plugins/fn-string/functions.c:1521 ../plugins/fn-string/functions.c:1650
msgid "For most strings, this function has the same effect as in Excel."
msgstr ""
"Para a maioria das cadeias, esta função tem o mesmo efeito que em Excel."

#: ../plugins/fn-string/functions.c:1522
msgid ""
"While in obsolete encodings ASC used to translate between 2-byte and 1-byte "
"characters, this is not the case in UTF-8."
msgstr ""
"Ainda que em codificações obsoletas, ASC seja usada para traduzir entre "
"caracteres de 1 e 2 bytes, este não é o caso em UTF-8."

#: ../plugins/fn-string/functions.c:1644
msgid ""
"JIS:text with half-width katakana and ASCII characters converted to full-"
"width"
msgstr ""
"JIS: texto de meia largura, katakana ou ASCII, convertido em largura completa"

#: ../plugins/fn-string/functions.c:1646
msgid ""
"JIS converts half-width katakana and ASCII characters to full-width "
"equivalent characters, copying all others. "
msgstr ""
"JIS converte texto de meia largura, katakana ou ASCII, para o equivalente de "
"largura completa, copiando todos os outros."

#: ../plugins/fn-string/functions.c:1651
msgid ""
"While in obsolete encodings JIS used to translate between 1-byte and 2-byte "
"characters, this is not the case in UTF-8."
msgstr ""
"Ainda que em codificações obsoletas, JIS seja usada para traduzir entre "
"caracteres de 1 e 2 bytes, este não é o caso em UTF-8."

#: ../plugins/fn-tsa/functions.c:93
msgid ""
"Possible interpolation methods are:\n"
"0: linear;\n"
"1: linear with averaging;\n"
"2: staircase;\n"
"3: staircase with averaging;\n"
"4: natural cubic spline;\n"
"5: natural cubic spline with averaging."
msgstr ""
"Possíveis métodos de interpolação são:\n"
"0: linear;\n"
"1: linear com média;\n"
"2: escada;\n"
"3: escada com média;\n"
"4: curva cúbica natural;\n"
"5: curva cúbica natural com média."

#: ../plugins/fn-tsa/functions.c:378
msgid ""
"INTERPOLATION:interpolated values corresponding to the given abscissa targets"
msgstr ""
"INTERPOLAÇÃO: valores interpolados correspondentes a um dado eixo das "
"abcissas destino"

#: ../plugins/fn-tsa/functions.c:379
msgid "abscissae:abscissae of the given data points"
msgstr "abcissa: abcissa dos pontos de dados indicados"

#: ../plugins/fn-tsa/functions.c:380
msgid "ordinates:ordinates of the given data points"
msgstr "ordenadas: ordenadas dos pontos de dados indicados"

#: ../plugins/fn-tsa/functions.c:381
msgid "targets:abscissae of the interpolated data"
msgstr "destinos: abcissa dos dados interpolados"

#: ../plugins/fn-tsa/functions.c:382
msgid "interpolation:method of interpolation, defaults to 0 ('linear')"
msgstr "interpolação: método de interpolação, predefinido como 0 (linear)"

#: ../plugins/fn-tsa/functions.c:383 ../plugins/fn-tsa/functions.c:572
msgid "The output consists always of one column of numbers."
msgstr "A saída consiste sempre numa coluna de números."

#: ../plugins/fn-tsa/functions.c:385
msgid ""
"The @{abscissae} should be given in increasing order. If the @{abscissae} is "
"not in increasing order the INTERPOLATION function is significantly slower."
msgstr ""
"A @{abcissa} deve ser dada em ordem crescente. Se assim não for, a função "
"torna-se significativamente mais lenta."

#: ../plugins/fn-tsa/functions.c:387
msgid "If any two @{abscissae} values are equal an error is returned."
msgstr ""
"Se quaisquer dois valores de @{abcissa} forem iguais, é devolvido um erro."

#: ../plugins/fn-tsa/functions.c:388
msgid ""
"If any of interpolation methods 1 ('linear with averaging'), 3 ('staircase "
"with averaging'), and 5 ('natural cubic spline with averaging') is used, the "
"number of returned values is one less than the number of targets and the "
"target values must be given in increasing order. The values returned are the "
"average heights of the interpolation function on the intervals determined by "
"consecutive target values."
msgstr ""
"Se qualquer um dos métodos de interpolação 1, 3 ou 5 for usado, o número de "
"valores devolvidos é menor que o número de destinos e os valores destino tên "
"de ser indicados em ordem crescente. Os valores devolvidos são a média de "
"alturas da função de interpolação nos intervalos determinados por valores "
"destino consecutivos."

#: ../plugins/fn-tsa/functions.c:395 ../plugins/fn-tsa/functions.c:579
msgid "Strings and empty cells in @{abscissae} and @{ordinates} are ignored."
msgstr "Cadeias e células vazias em @{abcissa} e @{ordenadas} são ignoradas."

#: ../plugins/fn-tsa/functions.c:396 ../plugins/fn-tsa/functions.c:580
msgid ""
"If several target data are provided they must be in the same column in "
"consecutive cells."
msgstr ""
"Se vários dados destino forem fornecidos, têm de estar na mesma coluna em "
"células consecutivas"

#: ../plugins/fn-tsa/functions.c:565
msgid "PERIODOGRAM:periodogram of the given data"
msgstr "GRÁF.PERÍODO: gráfico de período dos dados indicados"

#: ../plugins/fn-tsa/functions.c:566
msgid "ordinates:ordinates of the given data"
msgstr "ordenada: ordenadas dos dados indicados"

#: ../plugins/fn-tsa/functions.c:567
msgid "filter:windowing function to  be used, defaults to no filter"
msgstr "filtro: função de janelas a usar, predefinida como sem filtro"

#: ../plugins/fn-tsa/functions.c:568
msgid ""
"abscissae:abscissae of the given data, defaults to regularly spaced abscissae"
msgstr ""
"abcissa: abcissa dos dados indicados, predefinida como abcissa espaçada "
"regularmente"

#: ../plugins/fn-tsa/functions.c:569
msgid "interpolation:method of interpolation, defaults to none"
msgstr "interpolação: método de interpolação, predefinido como nenhum"

#: ../plugins/fn-tsa/functions.c:570
msgid "number:number of interpolated data points"
msgstr "num: número de pontos de dados interpolados"

#: ../plugins/fn-tsa/functions.c:571
msgid ""
"If an interpolation method is used, the number of returned values is one "
"less than the number of targets and the targets values must be given in "
"increasing order."
msgstr ""
"Se for usado um método de interpolação, o número de valores devolvidos é um "
"a menos que o número de destinos e os valores destino têm de ser dados em "
"ordem crescente."

#: ../plugins/fn-tsa/functions.c:574
msgid ""
"Possible window functions are:\n"
"0: no filter (rectangular window)\n"
"1: Bartlett (triangular window)\n"
"2: Hahn (cosine window)\n"
"3: Welch (parabolic window)"
msgstr ""
"Possíveis funções de janela são:\n"
"0: sem filtro (janela retangular)\n"
"1: Bartlett (janela triangular)\n"
"2: Hahn (janela cosseno)\n"
"3: Welch (janela parabólica)"

#: ../plugins/fn-tsa/functions.c:824
msgid "FOURIER:Fourier or inverse Fourier transform"
msgstr "FOURIER: transformação Fourier ou transformação inversa Fourier"

#: ../plugins/fn-tsa/functions.c:825 ../plugins/fn-tsa/functions.c:921
msgid "Sequence:the data sequence to be transformed"
msgstr "sequência: a sequ^encia de dados a transformar"

#: ../plugins/fn-tsa/functions.c:826
msgid ""
"Inverse:if true, the inverse Fourier transform is calculated, defaults to "
"false"
msgstr ""
"inverso: se VERDADEIRO, é calculada a transformação inversa, predefinido "
"como FALSO"

#: ../plugins/fn-tsa/functions.c:827
msgid ""
"Separate:if true, the real and imaginary parts are given separately, "
"defaults to false"
msgstr ""
"separado: se VERDADEIRO, as partes reais e imaginárias são dadas "
"separadamente, predefinido como FALSO"

#: ../plugins/fn-tsa/functions.c:828
msgid ""
"This array function returns the Fourier or inverse Fourier transform of the "
"given data sequence."
msgstr ""
"Esta função de matriz devolve a transformação de Fourier ou a transformação "
"inversa de Fourier da sequência de dados indicada."

#: ../plugins/fn-tsa/functions.c:829
msgid ""
"The output consists of one column of complex numbers if @{Separate} is false "
"and of two columns of real numbers if @{Separate} is true."
msgstr ""
"A saída consiste numa coluna de números complexos se @{separado} for falso e "
"duas colunas de números reais se @{separado} for verdadeiro."

#: ../plugins/fn-tsa/functions.c:830
msgid ""
"If @{Separate} is true the first output column contains the real parts and "
"the second column the imaginary parts."
msgstr ""
"Se @{separado} for verdadeiro, a primeira coluna contém as partes reais e a "
"segunda, as partes imaginárias."

#: ../plugins/fn-tsa/functions.c:831 ../plugins/fn-tsa/functions.c:925
msgid ""
"If @{Sequence} is neither an n by 1 nor 1 by n array, this function returns "
"#VALUE!"
msgstr ""
"Se @{sequência} não for uma matriz nem n por 1 nem 1 por n, devolve #VALOR!"

#: ../plugins/fn-tsa/functions.c:920
msgid "HPFILTER:Hodrick Prescott Filter"
msgstr "FILTROHP: filtro Hodrick-Prescott"

#: ../plugins/fn-tsa/functions.c:922
msgid "λ:filter parameter λ, defaults to 1600"
msgstr "λ: parâmetro de filtro λ, predefinido como 1600"

#: ../plugins/fn-tsa/functions.c:923
msgid ""
"This array function returns the trend and cyclical components obtained by "
"applying the Hodrick Prescott Filter with parameter @{λ} to the given data "
"sequence."
msgstr ""
"Esta função de matriz devolve a tendência e componentes cíclicos obtidos ao "
"aplicar o filtro Hodrick-Prescott com parâmetro @{λ} à sequência de dados "
"indicada."

#: ../plugins/fn-tsa/functions.c:924
msgid ""
"The output consists of two columns of numbers, the first containing the "
"trend component, the second the cyclical component."
msgstr ""
"A saida consiste em duas colunas de números, a primeira contendo o "
"componente tendência, a segunda o componente cíclico."

#: ../plugins/fn-tsa/functions.c:926
msgid ""
"If @{Sequence} contains less than 6 numerical values, this function returns "
"#VALUE!"
msgstr ""
"Se @{sequência} contiver menos de 6 valores numéricos,, devolve #VALOR!."

#: ../plugins/gda/plugin-gda.c:374
msgid "EXECSQL:result of executing @{sql} in the libgda data source @{dsn}"
msgstr ""
"EXECSQL:resultado da execução de @{sql} na origem de dados libgda @{dsn}"

#: ../plugins/gda/plugin-gda.c:376 ../plugins/gda/plugin-gda.c:452
msgid "dsn:libgda data source"
msgstr "dsn: origem de dados libgda"

#: ../plugins/gda/plugin-gda.c:377 ../plugins/gda/plugin-gda.c:453
msgid "username:user name to access @{dsn}"
msgstr "utilizador: nome de utilizador para aceder a @dsn}"

#: ../plugins/gda/plugin-gda.c:378 ../plugins/gda/plugin-gda.c:454
msgid "password:password to access @{dsn} as @{username}"
msgstr "senha: senha para aceder a @dsn} como @{utilizador}"

#: ../plugins/gda/plugin-gda.c:379
msgid "sql:SQL command"
msgstr "sql: comando SQL"

#: ../plugins/gda/plugin-gda.c:380 ../plugins/gda/plugin-gda.c:456
msgid "Before using EXECSQL, you need to set up a libgda data source."
msgstr "Antes de usar EXECSQL, tem de definir uma origem de dados libgda."

#: ../plugins/gda/plugin-gda.c:451
msgid "READDBTABLE:all rows of the table @{table} in @{dsn}"
msgstr "LERTABELABD: todas as linhas da @{tabela} em @{dsn}"

#: ../plugins/gda/plugin-gda.c:455
msgid "table:SQL table to retrieve"
msgstr "tabela: tabela SQL a obter"

#: ../plugins/sample_datasource/sample_datasource.c:274
msgid "ATL_LAST:sample real-time data source"
msgstr "ATL_ÚLTIMA: origem de dados exemplo em tempo real"

#: ../plugins/sample_datasource/sample_datasource.c:275
msgid "tag:tag to watch"
msgstr "etiqueta: etiqueta a observar"

#: ../plugins/sample_datasource/sample_datasource.c:276
msgid ""
"ATL_LAST is a sample implementation of a real time data source.  It takes a "
"string tag and monitors the named pipe ~/atl for changes to the value of "
"that tag."
msgstr ""
"ATL_ÚLTIMA é uma implementação exemplo de uma origem de dados em tempo real. "
"Obtém uma etiqueta de texto e monitoriza alterações no canal ~/atl  ao valor "
"dessa etiqueta."

#: ../plugins/sample_datasource/sample_datasource.c:277
msgid "This is not intended to be generally enabled and is OFF by default."
msgstr ""
"Isto não é suposto estar geralmente ativado, está DESLIGADO por predefinição."

#, fuzzy
#~ msgid ""
#~ "@{from} and @{to} can be any of the following:\n"
#~ "\n"
#~ "Weight and mass:\n"
#~ "\t'g'  \t\t\tGram\n"
#~ "\t'sg' \t\t\tSlug\n"
#~ "\t'lbm'\t\tPound\n"
#~ "\t'u'  \t\t\tU (atomic mass)\n"
#~ "\t'ozm'\t\tOunce\n"
#~ "\n"
#~ "Distance:\n"
#~ "\t'm'   \t\tMeter\n"
#~ "\t'mi'  \t\tStatute mile\n"
#~ "\t'Nmi' \t\tNautical mile\n"
#~ "\t'in'  \t\t\tInch\n"
#~ "\t'ft'  \t\t\tFoot\n"
#~ "\t'yd'  \t\tYard\n"
#~ "\t'ang' \t\tAngstrom\n"
#~ "\t'Pica'\t\tPica Points\n"
#~ "\t'picapt'\t\tPica Points\n"
#~ "\t'pica'\t\tPica\n"
#~ "\n"
#~ "Time:\n"
#~ "\t'yr'  \t\t\tYear\n"
#~ "\t'day' \t\tDay\n"
#~ "\t'hr'  \t\t\tHour\n"
#~ "\t'mn'  \t\tMinute\n"
#~ "\t'sec' \t\tSecond\n"
#~ "\n"
#~ "Pressure:\n"
#~ "\t'Pa'  \t\tPascal\n"
#~ "\t'atm' \t\tAtmosphere\n"
#~ "\t'mmHg'\t\tmm of Mercury\n"
#~ "\n"
#~ "Force:\n"
#~ "\t'N'   \t\t\tNewton\n"
#~ "\t'dyn' \t\tDyne\n"
#~ "\t'lbf' \t\t\tPound force\n"
#~ "\n"
#~ "Energy:\n"
#~ "\t'J'    \t\t\tJoule\n"
#~ "\t'e'    \t\tErg\n"
#~ "\t'c'    \t\tThermodynamic calorie\n"
#~ "\t'cal'  \t\tIT calorie\n"
#~ "\t'eV'   \t\tElectron volt\n"
#~ "\t'HPh'  \t\tHorsepower-hour\n"
#~ "\t'Wh'   \t\tWatt-hour\n"
#~ "\t'flb'  \t\tFoot-pound\n"
#~ "\t'BTU'  \t\tBTU\n"
#~ "\n"
#~ "Power:\n"
#~ "\t'HP'   \t\tHorsepower\n"
#~ "\t'W'    \t\tWatt\n"
#~ "\n"
#~ "Magnetism:\n"
#~ "\t'T'    \t\tTesla\n"
#~ "\t'ga'   \t\tGauss\n"
#~ "\n"
#~ "Temperature:\n"
#~ "\t'C'    \t\tDegree Celsius\n"
#~ "\t'F'    \t\tDegree Fahrenheit\n"
#~ "\t'K'    \t\tDegree Kelvin\n"
#~ "\n"
#~ "Liquid measure:\n"
#~ "\t'tsp'  \t\tTeaspoon\n"
#~ "\t'tbs'  \t\tTablespoon\n"
#~ "\t'oz'   \t\tFluid ounce\n"
#~ "\t'cup'  \t\tCup\n"
#~ "\t'pt'   \t\tPint\n"
#~ "\t'qt'   \t\tQuart\n"
#~ "\t'gal'  \t\tGallon\n"
#~ "\t'l'    \t\t\tLiter\n"
#~ "\n"
#~ "For metric units any of the following prefixes can be used:\n"
#~ "\t'Y'  \tyotta \t\t1E+24\n"
#~ "\t'Z'  \tzetta \t\t1E+21\n"
#~ "\t'E'  \texa   \t\t1E+18\n"
#~ "\t'P'  \tpeta  \t\t1E+15\n"
#~ "\t'T'  \ttera  \t\t1E+12\n"
#~ "\t'G'  \tgiga  \t\t1E+09\n"
#~ "\t'M'  \tmega  \t\t1E+06\n"
#~ "\t'k'  \tkilo  \t\t1E+03\n"
#~ "\t'h'  \thecto \t\t1E+02\n"
#~ "\t'e'  \tdeca (deka)\t1E+01\n"
#~ "\t'd'  \tdeci  \t\t1E-01\n"
#~ "\t'c'  \tcenti \t\t1E-02\n"
#~ "\t'm'  \tmilli \t\t1E-03\n"
#~ "\t'u'  \tmicro \t\t1E-06\n"
#~ "\t'n'  \tnano  \t\t1E-09\n"
#~ "\t'p'  \tpico  \t\t1E-12\n"
#~ "\t'f'  \tfemto \t\t1E-15\n"
#~ "\t'a'  \tatto  \t\t1E-18\n"
#~ "\t'z'  \tzepto \t\t1E-21\n"
#~ "\t'y'  \tyocto \t\t1E-24"
#~ msgstr ""
#~ "@FUNCTION=CONVERT\n"
#~ "@SYNTAX=CONVERT(número,de_unidade,para_unidade)\n"
#~ "@DESCRIPTION=CONVERT devolve uma conversão de um sistema de medida para "
#~ "outro. Por exemplo, pode converter um peso em libras num peso em gramas. "
#~ "@número é o valor que deseja converter, @de_unidade especifica a unidade "
#~ "do @número, e @para_unidade é a unidade para o resultado.\n"
#~ "\n"
#~ "@para_unidade e @de_unidade poderão ser quaisquer umas das seguintes:\n"
#~ "\n"
#~ "Peso e massa:\n"
#~ "\t'g'    \t\tGrama\n"
#~ "\t'sg'   \t\tCarga\n"
#~ "\t'lbm'  \t\tLibra\n"
#~ "\t'u'    \t\tU (massa atómica)\n"
#~ "\t'ozm'  \t\tOnça\n"
#~ "\n"
#~ "Distância:\n"
#~ "\t'm'    \t\tMetro\n"
#~ "\t'mi'   \t\tMilha terrestre\n"
#~ "\t'Nmi'  \t\tMilha náutica\n"
#~ "\t'in'   \t\tPolegada\n"
#~ "\t'ft'   \t\tPé\n"
#~ "\t'yd'   \t\tJarda\n"
#~ "\t'ang'  \t\tAngstrom\n"
#~ "\t'Pica' \t\tPica\n"
#~ "\n"
#~ "Tempo:\n"
#~ "\t'yr'   \t\tAno\n"
#~ "\t'day'  \t\tDia\n"
#~ "\t'hr'   \t\tHora\n"
#~ "\t'mn'   \t\tMinuto\n"
#~ "\t'sec'  \t\tSegundo\n"
#~ "\n"
#~ "Pressão:\n"
#~ "\t'Pa'   \t\tPascal\n"
#~ "\t'atm'  \t\tAtmosfera\n"
#~ "\t'mmHg' \t\tmm de Mercúrio\n"
#~ "\n"
#~ "Força:\n"
#~ "\t'N'    \t\tNewton\n"
#~ "\t'dyn'  \t\tDyne\n"
#~ "\t'lbf'  \t\tLibras de força\n"
#~ "\n"
#~ "Energia:\n"
#~ "\t'J'    \t\tJoule\n"
#~ "\t'e'    \t\tErg\n"
#~ "\t'c'    \t\tCaloria termodinâmica\n"
#~ "\t'cal'  \t\tCaloria IT\n"
#~ "\t'eV'   \t\tVolt electrão\n"
#~ "\t'HPh'  \t\tCavalos-hora\n"
#~ "\t'Wh'   \t\tWatt-hora\n"
#~ "\t'flb'  \t\tPé-libra\n"
#~ "\t'BTU'  \t\tBTU\n"
#~ "\n"
#~ "Poder:\n"
#~ "\t'HP'   \t\tCavalo\n"
#~ "\t'W'    \t\tWatt\n"
#~ "Magnetismo:\n"
#~ "\t'T'    \t\tTesla\n"
#~ "\t'ga'   \t\tGauss\n"
#~ "\n"
#~ "Temperatura:\n"
#~ "\t'C'    \t\tGraus Celsius\n"
#~ "\t'F'    \t\tGraus Fahrenheit\n"
#~ "\t'K'    \t\tGraus Kelvin\n"
#~ "\n"
#~ "Medida Líquida:\n"
#~ "\t'tsp'  \t\tColher de chá\n"
#~ "\t'tbs'  \t\tColher de mesa\n"
#~ "\t'oz'   \t\tOnça líquida\n"
#~ "\t'cup'  \t\tChavena\n"
#~ "\t'pt'   \t\tCaneca\n"
#~ "\t'qt'   \t\tQuartilho\n"
#~ "\t'gal'  \t\tGalão\n"
#~ "\t'l'    \t\tLitro\n"
#~ "\n"
#~ "Para unidades métricas pode ser utilizado qualquer um dos seguintes "
#~ "prefixos:\n"
#~ "\t'E'  \texa    \t1E+18\n"
#~ "\t'P'  \tpeta   \t1E+15\n"
#~ "\t'T'  \ttera   \t1E+12\n"
#~ "\t'G'  \tgiga   \t1E+09\n"
#~ "\t'M'  \tmega   \t1E+06\n"
#~ "\t'k'  \tquilo  \t1E+03\n"
#~ "\t'h'  \thecto  \t1E+02\n"
#~ "\t'e'  \tdeca   \t1E+01\n"
#~ "\t'd'  \tdeci   \t1E-01\n"
#~ "\t'c'  \tcenti  \t1E-02\n"
#~ "\t'm'  \tmili   \t1E-03\n"
#~ "\t'u'  \tmicro  \t1E-06\n"
#~ "\t'n'  \tnano   \t1E-09\n"
#~ "\t'p'  \tpico   \t1E-12\n"
#~ "\t'f'  \tfemto  \t1E-15\n"
#~ "\t'a'  \tatto   \t1E-18\n"
#~ "\n"
#~ "* Se @de_unidade e @para_unidade forem de tipos diferentes, CONVERT "
#~ "devolve um erro #NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CONVERT(3,\"lbm\",\"g\") igual a 1360.7769.\n"
#~ "CONVERT(5.8,\"m\",\"in\") igual a 228.3465.\n"
#~ "CONVERT(7.9,\"cal\",\"J\") igual a 33.07567.\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=PRICE\n"
#~ "@SYNTAX=PRICE(settle,mat,rate,yield,redemption_price,[frequency,basis])\n"
#~ "@DESCRIPTION=PRICE returns price per $100 face value of a security. This "
#~ "method can only be used if the security pays periodic interest.\n"
#~ "\n"
#~ "@frequency is the number of coupon payments per year. Allowed frequencies "
#~ "are: 1 = annual, 2 = semi, 4 = quarterly. @basis is the type of day "
#~ "counting system you want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @frequency is other than 1, 2, or 4, PRICE returns #NUM! error.\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis is not in between 0 and 4, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=PRICE\n"
#~ "@SYNTAX=PRICE(acordo,mat,rácio,juro,valor_amort,[frequência,base])\n"
#~ "@DESCRIPTION=PRICE devolve o preço por €100 de valor nominal de uma "
#~ "obrigação. Este método apenas pode ser utilizado se a obrigação pagar "
#~ "juros periódicos.\n"
#~ "\n"
#~ "@frequência é o número de pagamentos de cupão por ano. Frequências "
#~ "permitidas são: 1 = anual, 2 = semestral, 4 = trimestral. @base é o tipo "
#~ "de sistema de contagem de dias que deseja utilizar:\n"
#~ "\n"
#~ "  0  30/360 EUA\n"
#~ "  1  dias reais/dias reais\n"
#~ "  2  dias reais/360\n"
#~ "  3  dias reais/365\n"
#~ "  4  30/360 Europeu\n"
#~ "\n"
#~ "* Se @frequência for outra que não 1, 2, ou 4, PRICE devolve o erro "
#~ "#NUM!.\n"
#~ "* Se @base for omitida, 30/360 EUA é aplicada.\n"
#~ "* Se @base não estiver entre 0 e 4, o erro #NUM! é devolvido.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=YIELD\n"
#~ "@SYNTAX=YIELD(settlement,maturity,rate,price,redemption_price,frequency[,"
#~ "basis])\n"
#~ "@DESCRIPTION=YIELD returns the yield on a security that pays periodic "
#~ "interest.\n"
#~ "\n"
#~ "@frequency is the number of coupon payments per year. Allowed frequencies "
#~ "are: 1 = annual, 2 = semi, 4 = quarterly. @basis is the type of day "
#~ "counting system you want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @frequency is other than 1, 2, or 4, YIELD returns #NUM! error.\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis is not in between 0 and 4, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=YIELD\n"
#~ "@SYNTAX=YIELD(acordo,mat,rácio,preço,valor_amort,frequência[,base])\n"
#~ "@DESCRIPTION=Utilize YIELD para calcular o juro de uma obrigação que paga "
#~ "juros periódicos.\n"
#~ "\n"
#~ "@frequência é o número de pagamentos de cupão por ano. Frequências "
#~ "permitidas são: 1 = anual, 2 = semestral, 4 = trimestral. @base é o tipo "
#~ "de sistema de contagem de dias que deseja utilizar:\n"
#~ "\n"
#~ "  0  30/360 EUA\n"
#~ "  1  dias reais/dias reais\n"
#~ "  2  dias reais/360\n"
#~ "  3  dias reais/365\n"
#~ "  4  30/360 Europeu\n"
#~ "\n"
#~ "* Se @frequência for outra que não 1, 2, ou 4, YIELD devolve o erro "
#~ "#NUM!.\n"
#~ "* Se @base for omitida, 30/360 EUA é aplicada.\n"
#~ "* Se @base não estiver entre 0 e 4, o erro #NUM! é devolvido.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=YIELDDISC\n"
#~ "@SYNTAX=YIELDDISC(settlement,maturity,pr,redemption[,basis])\n"
#~ "@DESCRIPTION=YIELDDISC calculates the annual yield of a security that is "
#~ "discounted.\n"
#~ "\n"
#~ "@settlement is the settlement date of the security.  @maturity is the "
#~ "maturity date of the security. @pr is the price per $100 face value of "
#~ "the security. @redemption is the redemption value per $100 face value. "
#~ "@basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @frequency is other than 1, 2, or 4, YIELDDISC returns #NUM! error.\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis is not in between 0 and 4, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=YIELDDISC\n"
#~ "@SYNTAX=YIELDDISC(acordo,maturidade,pr,amortização[,base])\n"
#~ "@DESCRIPTION=YIELDDISC calcula o juro anual de uma obrigação que é "
#~ "descontada.\n"
#~ "\n"
#~ "@acordo é a data de acordo de uma obrigação.  @maturidade é a data de "
#~ "maturidade da obrigação. @pr é o preço por $100 de valor nominal da "
#~ "obrigação. @amortização é o valor de amortização por $100 de valor "
#~ "nominal. @base é o tipo de sistema de contagem de dias que deseja "
#~ "utilizar:\n"
#~ "\n"
#~ "  0  30/360 EUA\n"
#~ "  1  dias reais/dias reais\n"
#~ "  2  dias reais/360\n"
#~ "  3  dias reais/365\n"
#~ "  4  30/360 Europeu\n"
#~ "\n"
#~ "* Se @frequência for outra que não 1, 2, ou 4, YIELDDISC devolve o erro "
#~ "#NUM!.\n"
#~ "* Se @base for omitida, 30/360 EUA é aplicada.\n"
#~ "* Se @base não estiver entre 0 e 4, o erro #NUM! é devolvido.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=YIELDMAT\n"
#~ "@SYNTAX=YIELDMAT(settlement,maturity,issue,rate,pr[,basis])\n"
#~ "@DESCRIPTION=YIELDMAT calculates the annual yield of a security for which "
#~ "the interest is paid at maturity date.\n"
#~ "\n"
#~ "@settlement is the settlement date of the security. @maturity is the "
#~ "maturity date of the security. @issue is the issue date of the security. "
#~ "@rate is the interest rate set to the security. @pr is the price per $100 "
#~ "face value of the security. @basis is the type of day counting system you "
#~ "want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis is not in between 0 and 4, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=YIELDMAT\n"
#~ "@SYNTAX=YIELDMAT(acordo,maturidade,emissão,rácio,pr[,base])\n"
#~ "@DESCRIPTION=YIELDMAT calcula o juro anual de uma obrigação para a qual "
#~ "os juros são pagos na data de maturidade.\n"
#~ "\n"
#~ "@acordo é a data de acordo da obrigação. @maturidade é a data de "
#~ "maturidade da obrigação. @emissão é a data de emissão da obrigação. "
#~ "@rácio é a taxa de juro definida para a obrigação. @pr é o preço por €100 "
#~ "de valor nominal da obrigação. @base é o tipo de sistema de contagem de "
#~ "dias que deseja utilizar:\n"
#~ "\n"
#~ "  0  30/360 EUA\n"
#~ "  1  dias reais/dias reais\n"
#~ "  2  dias reais/360\n"
#~ "  3  dias reais/365\n"
#~ "  4  30/360 Europeu\n"
#~ "\n"
#~ "* Se @base for omitida, 30/360 EUA é aplicada.\n"
#~ "* Se @base não estiver entre 0 e 4, o erro #NUM! é devolvido.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=ODDFPRICE\n"
#~ "@SYNTAX=ODDFPRICE(settlement,maturity,issue,first_coupon,rate,yld,"
#~ "redemption,frequency[,basis])\n"
#~ "@DESCRIPTION=ODDFPRICE returns the price per $100 face value of a "
#~ "security. The security should have an odd short or long first period.\n"
#~ "\n"
#~ "@settlement is the settlement date of the security. @maturity is the "
#~ "maturity date of the security. @issue is the issue date of the security. "
#~ "@frequency is the number of coupon payments per year. Allowed frequencies "
#~ "are: 1 = annual, 2 = semi, 4 = quarterly. @basis is the type of day "
#~ "counting system you want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @frequency is other than 1, 2, or 4, ODDFPRICE returns #NUM! error.\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis is not in between 0 and 4, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=ODDFPRICE\n"
#~ "@SYNTAX=ODDFPRICE(acordo,maturidade,emissão,primeiro_cupão,rácio,yld,"
#~ "amortização,frequência[,base])\n"
#~ "@DESCRIPTION=ODDFPRICE devolve o preço por $100 de valor nominal de uma "
#~ "obrigação. A obrigação deverá ter um primeiro período mais curto ou "
#~ "longo.\n"
#~ "\n"
#~ "@acordo é a data de acordo da obrigação. @maturidade é a data de "
#~ "maturidade da obrigação. @emissão é a data de emissão da obrigação. "
#~ "@frequência é o número de pagamentos de cupão por ano. Frequências "
#~ "permitidas são: 1 = anual, 2 = semi, 4 = trimestral. @base é o tipo de "
#~ "sistema de contagem de dias que deseja utilizar:\n"
#~ "\n"
#~ "  0  30/360 EUA\n"
#~ "  1  dias reais/dias reais\n"
#~ "  2  dias reais/360\n"
#~ "  3  dias reais/365\n"
#~ "  4  30/360 Europeu\n"
#~ "\n"
#~ "* Se @frequência for outra que não 1, 2, ou 4, ODDFPRICE devolve o erro "
#~ "#NUM!.\n"
#~ "* Se @base for omitida, 30/360 EUA é aplicada.\n"
#~ "* Se @base não estiver entre 0 e 4, o erro #NUM! é devolvido.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=ODDFYIELD\n"
#~ "@SYNTAX=ODDFYIELD(settlement,maturity,issue,first_coupon,rate,pr,"
#~ "redemption,frequency[,basis])\n"
#~ "@DESCRIPTION=ODDFYIELD calculates the yield of a security having an odd "
#~ "first period.\n"
#~ "\n"
#~ "@settlement is the settlement date of the security. @maturity is the "
#~ "maturity date of the security. @frequency is the number of coupon "
#~ "payments per year. Allowed frequencies are: 1 = annual, 2 = semi, 4 = "
#~ "quarterly. @basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @frequency is other than 1, 2, or 4, ODDFYIELD returns #NUM! error.\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis is not in between 0 and 4, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=ODDFYIELD\n"
#~ "@SYNTAX=ODDFYIELD(acordo,maturidade,emissão,primeiro_cupão,rácio,pr,"
#~ "amortização,frequência[,base])\n"
#~ "@DESCRIPTION=ODDFYIELD calcula o juro de uma obrigação com um primeiro "
#~ "período diferente.\n"
#~ "\n"
#~ "@acordo é a data de acordo da obrigação. @maturidade é a data de "
#~ "maturidade da obrigação. @frequência é o número de pagamentos de cupão "
#~ "por ano. Frequências permitidas são: 1 = anual, 2 = semi, 4 = trimestral. "
#~ "@base é o tipo de sistema de contagem de dias que deseja utilizar:\n"
#~ "\n"
#~ "  0  30/360 EUA\n"
#~ "  1  dias reais/dias reais\n"
#~ "  2  dias reais/360\n"
#~ "  3  dias reais/365\n"
#~ "  4  30/360 Europeu\n"
#~ "\n"
#~ "* Se @frequência for outra que não 1, 2, ou 4, ODDFYIELD devolve o erro "
#~ "#NUM!.\n"
#~ "* Se @base for omitida, 30/360 EUA é aplicada.\n"
#~ "* Se @base não estiver entre 0 e 4, o erro #NUM! é devolvido.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=ODDLPRICE\n"
#~ "@SYNTAX=ODDLPRICE(settlement,maturity,last_interest,rate,yld,redemption,"
#~ "frequency[,basis])\n"
#~ "@DESCRIPTION=ODDLPRICE calculates the price per $100 face value of a "
#~ "security that has an odd last coupon period.\n"
#~ "\n"
#~ "@settlement is the settlement date of the security. @maturity is the "
#~ "maturity date of the security. @frequency is the number of coupon "
#~ "payments per year. Allowed frequencies are: 1 = annual, 2 = semi, 4 = "
#~ "quarterly. @basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @frequency is other than 1, 2, or 4, ODDLPRICE returns #NUM! error.\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis is not in between 0 and 4, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=ODDLPRICE\n"
#~ "@SYNTAX=ODDLPRICE(acordo,maturidade,último_juro,rácio,yld,amortização,"
#~ "frequência[,base])\n"
#~ "@DESCRIPTION=ODDLPRICE calcula o preço por $100 de valor nominal de uma "
#~ "obrigação que tem um último período de cupão diferente.\n"
#~ "\n"
#~ "@acordo é a data de acordo da obrigação. @maturidade é a data de "
#~ "maturidade da obrigação. @frequência é o número de pagamentos de cupão "
#~ "por ano. Frequências permitidas são: 1 = anual, 2 = semi, 4 = trimestral. "
#~ "@base é o tipo de sistema de contagem de dias que deseja utilizar:\n"
#~ "\n"
#~ "  0  30/360 EUA\n"
#~ "  1  dias reais/dias reais\n"
#~ "  2  dias reais/360\n"
#~ "  3  dias reais/365\n"
#~ "  4  30/360 Europeu\n"
#~ "\n"
#~ "* Se @frequência for outra que não 1, 2, ou 4, ODDLPRICE devolve o erro "
#~ "#NUM!.\n"
#~ "* Se @base for omitida, 30/360 EUA é aplicada.\n"
#~ "* Se @base não estiver entre 0 e 4, o erro #NUM! é devolvido.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=ODDLYIELD\n"
#~ "@SYNTAX=ODDLYIELD(settlement,maturity,last_interest,rate,pr,redemption,"
#~ "frequency[,basis])\n"
#~ "@DESCRIPTION=ODDLYIELD calculates the yield of a security having an odd "
#~ "last period.\n"
#~ "\n"
#~ "@settlement is the settlement date of the security. @maturity is the "
#~ "maturity date of the security. @frequency is the number of coupon "
#~ "payments per year. Allowed frequencies are: 1 = annual, 2 = semi, 4 = "
#~ "quarterly. @basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @frequency is other than 1, 2, or 4, ODDLYIELD returns #NUM! error.\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis is not in between 0 and 4, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=ODDLYIELD\n"
#~ "@SYNTAX=ODDLYIELD(acordo,maturidade,último_juro,rácio,pr,amortização,"
#~ "frequência[,base])\n"
#~ "@DESCRIPTION=ODDLYIELD calcula o juro de uma obrigação que tem o último "
#~ "diferente.\n"
#~ "\n"
#~ "@acordo é a data de acordo da obrigação. @maturidade é a data de "
#~ "maturidade da obrigação. @frequência é o número de pagamentos de cupão "
#~ "por ano. Frequências permitidas são: 1 = anual, 2 = semi, 4 = trimestral. "
#~ "@base é o tipo de sistema de contagem de dias que deseja utilizar:\n"
#~ "\n"
#~ "  0  30/360 EUA\n"
#~ "  1  dias reais/dias reais\n"
#~ "  2  dias reais/360\n"
#~ "  3  dias reais/365\n"
#~ "  4  30/360 Europeu\n"
#~ "\n"
#~ "* Se @frequência for outra que não 1, 2, ou 4, ODDLYIELD devolve o erro "
#~ "#NUM!.\n"
#~ "* Se @base for omitida, 30/360 EUA é aplicada.\n"
#~ "* Se @base não estiver entre 0 e 4, o erro #NUM! é devolvido.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=AMORDEGRC\n"
#~ "@SYNTAX=AMORDEGRC(cost,purchase_date,first_period,salvage,period,rate[,"
#~ "basis])\n"
#~ "@DESCRIPTION=AMORDEGRC: Calculates depreciation for each accounting "
#~ "period using French accounting conventions.   Assets purchased in the "
#~ "middle of a period take prorated depreciation into account.  This is "
#~ "similar to AMORLINC, except that a depreciation coefficient is applied in "
#~ "the calculation depending on the life of the assets.\n"
#~ "Named for AMORtissement DEGRessif Comptabilite\n"
#~ "\n"
#~ "@cost The value of the asset.\n"
#~ "@purchase_date The date the asset was purchased.\n"
#~ "@first_period The end of the first period.\n"
#~ "@salvage Asset value at maturity.\n"
#~ "@period The length of accounting periods.\n"
#~ "@rate rate of depreciation as a percentage.\n"
#~ "@basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis is not in between 0 and 4, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "AMORDEGRC(2400,DATE(1998,8,19),DATE(1998,12,30),300,1,0.14,1) = 733\n"
#~ "\n"
#~ "@SEEALSO=AMORLINC"
#~ msgstr ""
#~ "@FUNCTION=AMORDEGRC\n"
#~ "@SYNTAX=AMORDEGRC(custo,data_aquisição,primeiro_período,valor_residual,"
#~ "período,taxa[,base])\n"
#~ "@DESCRIPTION=AMORDEGRC: Calcula a depreciação para cada período "
#~ "contabilístico utilizando as convenções contabilísticas Francesas. "
#~ "Activos adquiridos no meio de um período tomam em conta uma depreciação "
#~ "pró-rateada.  É semelhante à função AMORLINC, excepto que o coeficiente "
#~ "de depreciação é aplicado no cálculo dependendo da vida útil dos "
#~ "activos.\n"
#~ "O nome da função advém de 'AMORtissement DEGRessif Comptabilite'\n"
#~ "\n"
#~ "@custo O valor do activo.\n"
#~ "@data_aquisição A data em que o activo foi adquirido.\n"
#~ "@primeiro_período O final do primeiro período.\n"
#~ "@valor_residual O valor do activo na maturidade.\n"
#~ "@período A duração dos períodos contabilísticos.\n"
#~ "@taxa taxa de depreciação como percentagem.\n"
#~ "@base é o tipo de sistema de contagem de dias que deseja utilizar:\n"
#~ "\n"
#~ "  0  30/360 EUA\n"
#~ "  1  dias reais/dias reais\n"
#~ "  2  dias reais/360\n"
#~ "  3  dias reais/365\n"
#~ "  4  30/360 Europeu\n"
#~ "\n"
#~ "* Se @base for omitida, 30/360 EUA é aplicada.\n"
#~ "* Se @base não estiver entre 0 e 4, o erro #NUM! é devolvido.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "AMORDEGRC(2400,DATE(1998,8,19),DATE(1998,12,30),300,1,0.14,1) = 733\n"
#~ "\n"
#~ "@SEEALSO=AMORLINC"

#~ msgid ""
#~ "@FUNCTION=AMORLINC\n"
#~ "@SYNTAX=AMORLINC(cost,purchase_date,first_period,salvage,period,rate[,"
#~ "basis])\n"
#~ "@DESCRIPTION=AMORLINC: Calculates depreciation for each accounting period "
#~ "using French accounting conventions.   Assets purchased in the middle of "
#~ "a period take prorated depreciation into account.\n"
#~ "Named for AMORtissement LINeaire Comptabilite.\n"
#~ "\n"
#~ "@cost The value of the asset.\n"
#~ "@purchase_date The date the asset was purchased.\n"
#~ "@first_period The end of the first period.\n"
#~ "@salvage Asset value at maturity.\n"
#~ "@period The length of accounting periods.\n"
#~ "@rate rate of depreciation as a percentage.\n"
#~ "@basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis is not in between 0 and 4, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "AMORLINC(2400,DATE(1998,8,19),DATE(1998,12,31),300,1,0.15,1) = 360\n"
#~ "\n"
#~ "@SEEALSO=AMORDEGRC"
#~ msgstr ""
#~ "@FUNCTION=AMORLINC\n"
#~ "@SYNTAX=AMORLINC(custo,data_aquisição,primeiro_período,valor_residual,"
#~ "período,taxa[,base])\n"
#~ "@DESCRIPTION=AMORLINC: Calcula a depreciação para cada período "
#~ "contabilístico utilizando as convenções contabilísticas Francesas. "
#~ "Activos adquiridos no meio de um período tomam em conta uma depreciação "
#~ "pró-rateada.\n"
#~ "O nome da função advém de 'AMORtissement LINeaire Comptabilite'.\n"
#~ "\n"
#~ "@custo O valor do activo.\n"
#~ "@data_aquisição A data em que o activo foi adquirido.\n"
#~ "@primeiro_período O final do primeiro período.\n"
#~ "@valor_residual O valor do activo na maturidade.\n"
#~ "@período A duração dos períodos contabilísticos.\n"
#~ "@taxa taxa de depreciação como percentagem.\n"
#~ "@base é o tipo de sistema de contagem de dias que deseja utilizar:\n"
#~ "\n"
#~ "  0  30/360 EUA\n"
#~ "  1  dias reais/dias reais\n"
#~ "  2  dias reais/360\n"
#~ "  3  dias reais/365\n"
#~ "  4  30/360 Europeu\n"
#~ "\n"
#~ "* Se @base for omitida, 30/360 EUA é aplicada.\n"
#~ "* Se @base não estiver entre 0 e 4, o erro #NUM! é devolvido.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "AMORLINC(2400,DATE(1998,8,19),DATE(1998,12,31),300,1,0.15,1) = 360\n"
#~ "\n"
#~ "@SEEALSO=AMORDEGRC"

#~ msgid ""
#~ "@FUNCTION=COUPDAYBS\n"
#~ "@SYNTAX=COUPDAYBS(settlement,maturity,frequency[,basis,eom])\n"
#~ "@DESCRIPTION=COUPDAYBS returns the number of days from the beginning of "
#~ "the coupon period to the settlement date.\n"
#~ "\n"
#~ "@settlement is the settlement date of the security.\n"
#~ "@maturity is the maturity date of the security.\n"
#~ "@frequency is the number of coupon payments per year.\n"
#~ "@eom = TRUE handles end of month maturity dates special.\n"
#~ "Allowed frequencies are: 1 = annual, 2 = semi, 4 = quarterly, 6 = "
#~ "bimonthly, 12 = monthly.\n"
#~ "@basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  MSRB 30/360 (MSRB Rule G33 (e))\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "  5  European+ 30/360\n"
#~ "\n"
#~ "(See the gnumeric manual for a detailed description of these bases).\n"
#~ "\n"
#~ "* If @frequency is invalid, COUPDAYBS returns #NUM! error.\n"
#~ "* If @basis is omitted, MSRB 30/360 is applied.\n"
#~ "* If @basis is invalid, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COUPDAYBS (DATE(2002,11,29),DATE(2004,2,29),4,0) = 89\n"
#~ "COUPDAYBS (DATE(2002,11,29),DATE(2004,2,29),4,0,FALSE) = 0\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=COUPDAYBS\n"
#~ "@SYNTAX=COUPDAYBS(acordo,maturidade,frequência[,base,fdm])\n"
#~ "@DESCRIPTION=COUPDAYBS devolve o número de dias desde o ínicio do período "
#~ "do cupão até à data de acordo.\n"
#~ "\n"
#~ "@acordo é a data de acordo da obrigação.\n"
#~ "@maturidade é a data de maturidade da obrigação.\n"
#~ "@frequência é o número de pagamentos de cupão por ano.\n"
#~ "@fdm = VERDADE gere datas de maturidade de final de mês especiais.\n"
#~ "Frequências permitidas são: 1 = anual, 2 = semestral, 4 = trimestral, 6 = "
#~ "bimensal, 12 = mensal.\n"
#~ "@base é o tipo de sistema de contagem de dias que ideseja utilizar:\n"
#~ "\n"
#~ "  0  MSBR 30/360 (Regra MSBR G33(e))\n"
#~ "  1  dias reais/dias reais\n"
#~ "  2  dias reais/360\n"
#~ "  3  dias reais/365\n"
#~ "  4  30/360 Europeu\n"
#~ "  5  30/360 Europeu+\n"
#~ "\n"
#~ "(consulte o manual do Gnumeric para informação detalhada destas bases).\n"
#~ "\n"
#~ "* Se @frequência for inválida, COUPDAYBS devolve o erro #NUM!.\n"
#~ "* Se @base for omitida, é aplicada MSBR 30/360.\n"
#~ "* Se @base for inválida, é devolvido o erro #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COUPDAYBS (DATE(2002,11,29),DATE(2004,2,29),4,0) = 89\n"
#~ "COUPDAYBS (DATE(2002,11,29),DATE(2004,2,29),4,0,FALSE) = 0\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=COUPDAYS\n"
#~ "@SYNTAX=COUPDAYS(settlement,maturity,frequency[,basis,eom])\n"
#~ "@DESCRIPTION=COUPDAYS returns the number of days in the coupon period of "
#~ "the settlement date.\n"
#~ "\n"
#~ "@settlement is the settlement date of the security.\n"
#~ "@maturity is the maturity date of the security.\n"
#~ "@frequency is the number of coupon payments per year.\n"
#~ "@eom = TRUE handles end of month maturity dates special.\n"
#~ "Allowed frequencies are: 1 = annual, 2 = semi, 4 = quarterly, 6 = "
#~ "bimonthly, 12 = monthly.\n"
#~ "@basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  MSRB 30/360 (MSRB Rule G33 (e))\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "  5  European+ 30/360\n"
#~ "\n"
#~ "(See the gnumeric manual for a detailed description of these bases).\n"
#~ "\n"
#~ "* If @frequency is invalid, COUPDAYS returns #NUM! error.\n"
#~ "* If @basis is omitted, MSRB 30/360 is applied.\n"
#~ "* If @basis is invalid, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COUPDAYS (DATE(2002,11,29),DATE(2004,2,29),4,0) = 90\n"
#~ "COUPDAYS (DATE(2002,11,29),DATE(2004,2,29),4,0,FALSE) = 90\n"
#~ "COUPDAYS (DATE(2002,11,29),DATE(2004,2,29),4,1,FALSE) = 91\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=COUPDAYS\n"
#~ "@SYNTAX=COUPDAYS(acordo,maturidade,frequência[,base, fdm])\n"
#~ "@DESCRIPTION=COUPDAYS devolve o número de dias no período do cupão da "
#~ "data de acordo.\n"
#~ "\n"
#~ "@acordo é a data de acordo da obrigação.\n"
#~ "@maturidade é a data de maturidade da obrigação.\n"
#~ "@frequência é o número de pagamentos de cupão por ano.\n"
#~ "@fdm = VERDADE gere datas de maturidade em final de mês especiais.\n"
#~ "Frequências permitidas são: 1 = anual, 2 = semestral, 4 = trimestral, 6 = "
#~ "bimensal, 12 = mensal.\n"
#~ "@base é o tipo de sistema de contagem de dias que deseja utilizar:\n"
#~ "\n"
#~ "  0  MSRB 30/360 (MSRB Regra G33 (e))\n"
#~ "  1  dias reais/dias reais\n"
#~ "  2  dias reais/360\n"
#~ "  3  dias reais/365\n"
#~ "  4  Europeu 30/360\n"
#~ "  5  Europeu+ 30/360\n"
#~ "\n"
#~ "(consulte o manual do Gnumeric para uma descrição detalhada destas "
#~ "bases).\n"
#~ "\n"
#~ "* Se @frequência for inválida, COUPDAYS devolve o erro #NUM!.\n"
#~ "* Se @base for omitida, é aplicada MSBR 30/360.\n"
#~ "* Se @base for inválida, o erro #NUM! é devolvido. \n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COUPDAYS (DATE(2002,11,29),DATE(2004,2,29),4,0) = 90\n"
#~ "COUPDAYS (DATE(2002,11,29),DATE(2004,2,29),4,0,FALSE) = 90\n"
#~ "COUPDAYS (DATE(2002,11,29),DATE(2004,2,29),4,1,FALSE) = 91\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=COUPDAYSNC\n"
#~ "@SYNTAX=COUPDAYSNC(settlement,maturity,frequency[,basis,eom])\n"
#~ "@DESCRIPTION=COUPDAYSNC returns the number of days from the settlement "
#~ "date to the next coupon date.\n"
#~ "\n"
#~ "@settlement is the settlement date of the security.\n"
#~ "@maturity is the maturity date of the security.\n"
#~ "@frequency is the number of coupon payments per year.\n"
#~ "@eom = TRUE handles end of month maturity dates special.\n"
#~ "Allowed frequencies are: 1 = annual, 2 = semi, 4 = quarterly, 6 = "
#~ "bimonthly, 12 = monthly.\n"
#~ "@basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  MSRB 30/360 (MSRB Rule G33 (e))\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "  5  European+ 30/360\n"
#~ "\n"
#~ "(See the gnumeric manual for a detailed description of these bases).\n"
#~ "\n"
#~ "* If @frequency is invalid, COUPDAYSNC returns #NUM! error.\n"
#~ "* If @basis is omitted, MSRB 30/360 is applied.\n"
#~ "* If @basis is invalid, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COUPDAYSNC (DATE(2002,11,29),DATE(2004,2,29),4,0) = 1\n"
#~ "COUPDAYSNC (DATE(2002,11,29),DATE(2004,2,29),4,0,FALSE) = 89\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=COUPDAYSNC\n"
#~ "@SYNTAX=COUPDAYSNC(acordo,maturidade,frequência[,base, fdm])\n"
#~ "@DESCRIPTION=COUPDAYSNC devolve o número de dias desde a data de acordo "
#~ "até à data do próximo cupão.\n"
#~ "\n"
#~ "@acordo é a data de acordo da obrigação.\n"
#~ "@maturidade é a data de maturidade da obrigação.\n"
#~ "@frequência é o número de pagamentos de cupão por ano.\n"
#~ "@fdm = VERDADE gere datas de maturidade em final de mês especiais.\n"
#~ "Frequências permitidas são: 1 = anual, 2 = semestral, 4 = trimestral, 6 = "
#~ "bimensal, 12 = mensal.\n"
#~ "@base é o tipo de sistema de contagem de dias que deseja utilizar:\n"
#~ "\n"
#~ "  0  MSRB 30/360 (MSRB Regra G33 (e))\n"
#~ "  1  dias reais/dias reais\n"
#~ "  2  dias reais/360\n"
#~ "  3  dias reais/365\n"
#~ "  4  Europeu 30/360\n"
#~ "  5  Europeu+ 30/360\n"
#~ "\n"
#~ "(consulte o manual do Gnumeric para uma descrição detalhada destas "
#~ "bases).\n"
#~ "\n"
#~ "* Se @frequência for inválida, COUPDAYSNC devolve o erro #NUM!.\n"
#~ "* Se @base for omitida, é aplicada MSBR 30/360.\n"
#~ "* Se @base for inválida, o erro #NUM! é devolvido. \n"
#~ "@EXAMPLES=\n"
#~ "COUPDAYSNC (DATE(2002,11,29),DATE(2004,2,29),4,0) = 1\n"
#~ "COUPDAYSNC (DATE(2002,11,29),DATE(2004,2,29),4,0,FALSE) = 89\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=COUPNCD\n"
#~ "@SYNTAX=COUPNCD(settlement,maturity,frequency[,basis,eom])\n"
#~ "@DESCRIPTION=COUPNCD returns the coupon date following settlement.\n"
#~ "\n"
#~ "@settlement is the settlement date of the security.\n"
#~ "@maturity is the maturity date of the security.\n"
#~ "@frequency is the number of coupon payments per year.\n"
#~ "@eom = TRUE handles end of month maturity dates special.\n"
#~ "Allowed frequencies are: 1 = annual, 2 = semi, 4 = quarterly, 6 = "
#~ "bimonthly, 12 = monthly.\n"
#~ "@basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  MSRB 30/360 (MSRB Rule G33 (e))\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "  5  European+ 30/360\n"
#~ "\n"
#~ "(See the gnumeric manual for a detailed description of these bases).\n"
#~ "\n"
#~ "* If @frequency is invalid, COUPNCD returns #NUM! error.\n"
#~ "* If @basis is omitted, MSRB 30/360 is applied.\n"
#~ "* If @basis is invalid, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COUPNCD (DATE(2002,11,29),DATE(2004,2,29),4,0) = 30-Nov-2002\n"
#~ "COUPNCD (DATE(2002,11,29),DATE(2004,2,29),4,0,FALSE) = 28-Feb-2003\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=COUPNCD\n"
#~ "@SYNTAX=COUPNCD(acordo,maturidade,frequência[,base, fdm])\n"
#~ "@DESCRIPTION=COUPNCD devolve a data do cupão após o acordo.\n"
#~ "\n"
#~ "@acordo é a data de acordo da obrigação.\n"
#~ "@maturidade é a data de maturidade da obrigação.\n"
#~ "@frequência é o número de pagamentos de cupão por ano.\n"
#~ "@fdm = VERDADE gere datas de maturidade em final de mês especiais.\n"
#~ "Frequências permitidas são: 1 = anual, 2 = semestral, 4 = trimestral, 6 = "
#~ "bimensal, 12 = mensal.\n"
#~ "@base é o tipo de sistema de contagem de dias que deseja utilizar:\n"
#~ "\n"
#~ "  0  MSRB 30/360 (MSRB Regra G33 (e))\n"
#~ "  1  dias reais/dias reais\n"
#~ "  2  dias reais/360\n"
#~ "  3  dias reais/365\n"
#~ "  4  Europeu 30/360\n"
#~ "  5  Europeu+ 30/360\n"
#~ "\n"
#~ "(consulte o manual do Gnumeric para uma descrição detalhada destas "
#~ "bases).\n"
#~ "\n"
#~ "* Se @frequência for inválida, COUPNCD devolve o erro #NUM!.\n"
#~ "* Se @base for omitida, é aplicada MSBR 30/360.\n"
#~ "* Se @base for inválida, o erro #NUM! é devolvido.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COUPNCD (DATE(2002,11,29),DATE(2004,2,29),4,0) = 30-Nov-2002\n"
#~ "COUPNCD (DATE(2002,11,29),DATE(2004,2,29),4,0,FALSE) = 28-Feb-2003\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=COUPPCD\n"
#~ "@SYNTAX=COUPPCD(settlement,maturity,frequency[,basis,eom])\n"
#~ "@DESCRIPTION=COUPPCD returns the coupon date preceding settlement.\n"
#~ "\n"
#~ "@settlement is the settlement date of the security.\n"
#~ "@maturity is the maturity date of the security.\n"
#~ "@frequency is the number of coupon payments per year.\n"
#~ "@eom = TRUE handles end of month maturity dates special.\n"
#~ "Allowed frequencies are: 1 = annual, 2 = semi, 4 = quarterly, 6 = "
#~ "bimonthly, 12 = monthly.\n"
#~ "@basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  MSRB 30/360 (MSRB Rule G33 (e))\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "  5  European+ 30/360\n"
#~ "\n"
#~ "(See the gnumeric manual for a detailed description of these bases).\n"
#~ "\n"
#~ "* If @frequency is invalid, COUPPCD returns #NUM! error.\n"
#~ "* If @basis is omitted, MSRB 30/360 is applied.\n"
#~ "* If @basis is invalid, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COUPPCD (DATE(2002,11,29),DATE(2004,2,29),4,0) = 31-Aug-2002\n"
#~ "COUPPCD (DATE(2002,11,29),DATE(2004,2,29),4,0,FALSE) = 29-Nov-2002\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=COUPPCD\n"
#~ "@SYNTAX=COUPPCD(acordo,maturidade,frequência[,base, fdm])\n"
#~ "@DESCRIPTION=COUPPCD devolve a data de cupão antes da data de acordo.\n"
#~ "\n"
#~ "@acordo é a data de acordo da obrigação.\n"
#~ "@maturidade é a data de maturidade da obrigação.\n"
#~ "@frequência é o número de pagamentos de cupão por ano.\n"
#~ "@fdm = VERDADE gere datas de maturidade em final de mês especiais.\n"
#~ "Frequências permitidas são: 1 = anual, 2 = semestral, 4 = trimestral, 6 = "
#~ "bimensal, 12 = mensal.\n"
#~ "@base é o tipo de sistema de contagem de dias que deseja utilizar:\n"
#~ "\n"
#~ "  0  MSRB 30/360 (MSRB Regra G33 (e))\n"
#~ "  1  dias reais/dias reais\n"
#~ "  2  dias reais/360\n"
#~ "  3  dias reais/365\n"
#~ "  4  Europeu 30/360\n"
#~ "  5  Europeu+ 30/360\n"
#~ "\n"
#~ "(consulte o manual do Gnumeric para uma descrição detalhada destas "
#~ "bases).\n"
#~ "\n"
#~ "* Se @frequência for inválida, COUPPCD devolve o erro #NUM!.\n"
#~ "* Se @base for omitida, é aplicada MSBR 30/360.\n"
#~ "* Se @base for inválida, o erro #NUM! é devolvido.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COUPPCD (DATE(2002,11,29),DATE(2004,2,29),4,0) = 31-Ago-2002\n"
#~ "COUPPCD (DATE(2002,11,29),DATE(2004,2,29),4,0,FALSE) = 29-Nov-2002\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=COUPNUM\n"
#~ "@SYNTAX=COUPNUM(settlement,maturity,frequency[,basis,eom])\n"
#~ "@DESCRIPTION=COUPNUM returns the numbers of coupons to be paid between "
#~ "the settlement and maturity dates, rounded up.\n"
#~ "\n"
#~ "@settlement is the settlement date of the security.\n"
#~ "@maturity is the maturity date of the security.\n"
#~ "@frequency is the number of coupon payments per year.\n"
#~ "@eom = TRUE handles end of month maturity dates special.\n"
#~ "Allowed frequencies are: 1 = annual, 2 = semi, 4 = quarterly. 6 = "
#~ "bimonthly, 12 = monthly.\n"
#~ "@basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  MSRB 30/360 (MSRB Rule G33 (e))\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "  5  European+ 30/360\n"
#~ "\n"
#~ "* If @frequency is other than 1, 2, 4, 6 or 12, COUPNUM returns #NUM! "
#~ "error.\n"
#~ "* If @basis is omitted, MSRB 30/360 is applied.\n"
#~ "* If @basis is not in between 0 and 5, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COUPNUM (DATE(2002,11,29),DATE(2004,2,29),4,0) = 6\n"
#~ "COUPNUM (DATE(2002,11,29),DATE(2004,2,29),4,0,FALSE) = 5\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=COUPNUM\n"
#~ "@SYNTAX=COUPNUM(acordo,maturidade,frequência[,base,fdm])\n"
#~ "@DESCRIPTION=COUPNUM devolve o número de cupões a serem pagos entre as "
#~ "datas de acordo e de maturidade, arredondados acima.\n"
#~ "\n"
#~ "@acordo é a data de acordo da obrigação.\n"
#~ "@maturidade é a data de maturidade da obrigação.\n"
#~ "@frequência é o número de pagamentos de cupão por ano.\n"
#~ "@fdm = VERDADE gere datas de maturidade em final de mês especiais.\n"
#~ "Frequências permitidas são: 1 = anual, 2 = semestral, 4 = trimestral, 6 = "
#~ "bimensal, 12 = mensal.\n"
#~ "@base é o tipo de sistema de contagem de dias que deseja utilizar:\n"
#~ "\n"
#~ "  0  MSRB 30/360 (MSRB Regra G33 (e))\n"
#~ "  1  dias reais/dias reais\n"
#~ "  2  dias reais/360\n"
#~ "  3  dias reais/365\n"
#~ "  4  Europeu 30/360\n"
#~ "  5  Europeu+ 30/360\n"
#~ "\n"
#~ "* Se @frequência for outra que não 1, 2, ou 4, COUPNUM devolve o erro "
#~ "#NUM!.\n"
#~ "* Se @base for omitida, MSBR 30/360 é aplicada.\n"
#~ "* Se @base não estiver entre 0 e 4, o erro #NUM! é devolvido.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COUPNUM (DATE(2002,11,29),DATE(2004,2,29),4,0) = 6\n"
#~ "COUPNUM (DATE(2002,11,29),DATE(2004,2,29),4,0,FALSE) = 5\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=CUM_BIV_NORM_DIST\n"
#~ "@SYNTAX=CUM_BIV_NORM_DIST(a,b,rho)\n"
#~ "@DESCRIPTION=CUM_BIV_NORM_DIST calculates the cumulative bivariate normal "
#~ "distribution from parameters a, b & rho.\n"
#~ "The return value is the probability that two random variables with "
#~ "correlation @rho are respectively each less than @a and @b.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=NORMDIST,NORMSDIST,NORMSINV"
#~ msgstr ""
#~ "@FUNCTION=CUM_BIV_NORM_DIST\n"
#~ "@SYNTAX=CUM_BIV_NORM_DIST(a,b,rho)\n"
#~ "@DESCRIPTION=CUM_BIV_NORM_DIST calcula a distribuição acumulada bivariada "
#~ "normal dos parâmetros @a, @b & @rho.\n"
#~ "O resultado é a probabilidade de duas variáveis aleatórias com correlação "
#~ "@rho serem respectivamente menos do que @a e @b.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=NORMDIST,NORMSDIST,NORMSINV"

#~ msgid ""
#~ "@FUNCTION=OPT_BS\n"
#~ "@SYNTAX=OPT_BS(call_put_flag,spot,strike,time,rate,volatility [,"
#~ "cost_of_carry])\n"
#~ "@DESCRIPTION=OPT_BS uses the Black-Scholes model to calculate the price "
#~ "of a European option using call_put_flag, @call_put_flag, 'c' or 'p' "
#~ "struck at @strike on an asset with spot price @spot.\n"
#~ "@time is the time to maturity of the option expressed in years.\n"
#~ "@rate is the risk-free interest rate.\n"
#~ "@volatility is the annualized volatility, in percent, of the asset for "
#~ "the period through to the exercise date. \n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "* The returned value will be expressed in the same units as @strike and "
#~ "@spot.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_VEGA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_BS\n"
#~ "@SYNTAX=OPT_BS(opção_call_put,alvo,preço,duração,taxa,volatilidade[,"
#~ "custo_conversão])\n"
#~ "@DESCRIPTION=OPT_BS utiliza o modelo de Black-Scholes para calcular o "
#~ "preço de uma opção Europeia utilizando a opção_call_put, @opção_call_put, "
#~ "c ou p acerta ao @preço sobre um activo com o preço alvo @alvo.\n"
#~ "@duração é o tempo até à maturidade da opção, expresso em anos\n"
#~ "@taxa é a taxa de juro livre de risco\n"
#~ "@volatilidade é a volatilidade anualizada, em percentagem, do activo para "
#~ "o período até à data de exercício. \n"
#~ "@custo_conversão é a depreciação em valor do activo subjacente, para "
#~ "acções correntes, isto seria o dividendo gerado\n"
#~ "* O valor devolvido será expresso nas mesmas unidades que @alvo e "
#~ "@preço.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_VEGA, OPT_BS_GAMMA"

#~ msgid ""
#~ "@FUNCTION=OPT_BS_DELTA\n"
#~ "@SYNTAX=OPT_BS_DELTA(call_put_flag,spot,strike,time,rate,volatility[,"
#~ "cost_of_carry])\n"
#~ "@DESCRIPTION=OPT_BS_DELTA uses the Black-Scholes model to calculate the "
#~ "'delta' of a European option with call_put_flag, @call_put_flag, 'c' or "
#~ "'p' struck at @strike on an asset with spot price @spot.\n"
#~ "Where @time is the time to maturity of the option expressed in years.\n"
#~ "@rate is the risk-free interest rate.\n"
#~ "@volatility is the annualized volatility, in percent, of the asset for "
#~ "the period through to the exercise date. \n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "* The returned value will be expressed in the same units as @strike and "
#~ "@spot.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_VEGA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_BS_DELTA\n"
#~ "@SYNTAX=OPT_BS_DELTA(opção_call_put,alvo,preço,duração,taxa,volatilidade[,"
#~ "custo_conversão])\n"
#~ "@DESCRIPTION=OPT_BS_DELTA utiliza o modelo de Black-Scholes para calcular "
#~ "o \"delta\" de uma opção Europeia com a opção call ou put, "
#~ "@opção_call_put, c ou p acerta ao @preço sobre um activo com o preço alvo "
#~ "@alvo.\n"
#~ "Onde @duração é o tempo até à maturidade da opção, expresso em anos\n"
#~ "@taxa é a taxa de juro livre de risco\n"
#~ "@volatilidade é a volatilidade anualizada, em percentagem, do activo para "
#~ "o período até à data de exercício. \n"
#~ "@custo_conversão é a depreciação em valor do activo subjacente, para "
#~ "acções correntes, isto seria o dividendo gerado\n"
#~ "* O valor devolvido será expresso nas mesmas unidades que @alvo e "
#~ "@preço.\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_VEGA, OPT_BS_GAMMA"

#~ msgid ""
#~ "@FUNCTION=OPT_BS_GAMMA\n"
#~ "@SYNTAX=OPT_BS_GAMMA(spot,strike,time,rate,volatility[,cost_of_carry])\n"
#~ "@DESCRIPTION=OPT_BS_GAMMA uses the Black-Scholes model to calculate the "
#~ "'gamma' of a European option struck at @strike on an asset with spot "
#~ "price @spot.\n"
#~ "\n"
#~ "(The gamma of an option is the second derivative of its price with "
#~ "respect to the price of the underlying asset, and is the same for calls "
#~ "and puts.)\n"
#~ "\n"
#~ "@time is the time to maturity of the option expressed in years.\n"
#~ "@rate is the risk-free interest rate to the exercise date, in percent.\n"
#~ "@volatility is the annualized volatility, in percent, of the asset for "
#~ "the period through to the exercise date.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "* The returned value will be expressed as the rate of change of delta per "
#~ "unit change in @spot.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_VEGA"
#~ msgstr ""
#~ "@FUNCTION=OPT_BS_GAMMA\n"
#~ "@SYNTAX=OPT_BS_GAMMA(alvo,preço,duração,taxa,volatilidade[,"
#~ "custo_conversão])\n"
#~ "@DESCRIPTION=OPT_BS_GAMMA utiliza o modelo de Black-Scholes para calcular "
#~ "o \"gamma\" de uma opção Europeia acerta ao @preço sobre um activo com o "
#~ "preço alvo @alvo.\n"
#~ "\n"
#~ "(O gamma de uma opção é a segunda derivada do seu preço em relação ao "
#~ "preço do activo subjacente, e é o mesmo para opções de compra e de "
#~ "venda.)\n"
#~ "\n"
#~ "@duração é o tempo até à maturidade da opção, expresso em anos\n"
#~ "@taxa é a taxa de juro livre de risco para a data de exercício, em "
#~ "percentagem.\n"
#~ "@volatilidade é a volatilidade anualizada, em percentagem, do activo para "
#~ "o período até à data de exercício.\n"
#~ "@custo_conversão é a depreciação em valor do activo subjacente, para "
#~ "acções correntes, isto seria o dividendo gerado\n"
#~ "* O valor devolvido será expresso como o rácio de mudança de delta por "
#~ "unidade alterada em @preço.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_VEGA"

#~ msgid ""
#~ "@FUNCTION=OPT_BS_THETA\n"
#~ "@SYNTAX=OPT_BS_THETA(call_put_flag,spot,strike,time,rate,volatility[,"
#~ "cost_of_carry])\n"
#~ "@DESCRIPTION=OPT_BS_THETA uses the Black-Scholes model to calculate the "
#~ "'theta' of a European option with call_put_flag, @call_put_flag struck at "
#~ "@strike on an asset with spot price @spot.\n"
#~ "\n"
#~ "(The theta of an option is the rate of change of its price with respect "
#~ "to time to expiry.)\n"
#~ "\n"
#~ "@time is the time to maturity of the option expressed in years\n"
#~ "and @rate is the risk-free interest rate to the exercise date, in "
#~ "percent.\n"
#~ "@volatility is the annualized volatility, in percent, of the asset for "
#~ "the period through to the exercise date.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "* The returned value will be expressed as minus the rate of change of "
#~ "option value, per 365.25 days.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_VEGA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_BS_THETA\n"
#~ "@SYNTAX=OPT_BS_THETA(opção_call_put,alvo,preço,duração,taxa,volatilidade[,"
#~ "custo_conversão])\n"
#~ "@DESCRIPTION=OPT_BS_THETA utiliza o modelo de Black-Scholes para calcular "
#~ "o \"theta\" de uma opção Europeia com a opção call ou put, "
#~ "@opção_call_put acerta ao @preço sobre um activo com o preço alvo @alvo.\n"
#~ "\n"
#~ "(O theta de uma opção é a taxa de alteração do seu preço relativamente ao "
#~ "tempo para expirar.)\n"
#~ "\n"
#~ "@duração é o tempo até à maturidade da opção, expresso em anos\n"
#~ "e @taxa é a taxa de juro livre de risco para a data de exercício, em "
#~ "percentagem.\n"
#~ "@volatilidade é a volatilidade anualizada, em percentagem, do activo para "
#~ "o período até à data de exercício.\n"
#~ "@custo_conversão é a depreciação em valor do activo subjacente, para "
#~ "acções correntes, isto seria o dividendo gerado\n"
#~ "* O valor devolvido será expresso como o negativo do rácio de alteração "
#~ "do valor da opção, por 365.25 dias.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_VEGA, OPT_BS_GAMMA"

#~ msgid ""
#~ "@FUNCTION=OPT_BS_VEGA\n"
#~ "@SYNTAX=OPT_BS_VEGA(spot,strike,time,rate,volatility[,cost_of_carry])\n"
#~ "@DESCRIPTION=OPT_BS_VEGA uses the Black-Scholes model to calculate the "
#~ "'vega' of a European option struck at @strike on an asset with spot price "
#~ "@spot.\n"
#~ "(The vega of an option is the rate of change of its price with respect to "
#~ "volatility, and is the same for calls and puts.)\n"
#~ "@volatility is the annualized volatility, in percent, of the asset for "
#~ "the period through to the exercise date.\n"
#~ " @time is the time to maturity of the option expressed in years.\n"
#~ "@rate is the risk-free interest rate to the exercise date, in percent.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "\n"
#~ "* The returned value will be expressed as the rate of change of option "
#~ "value, per 100% volatility.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_BS_VEGA\n"
#~ "@SYNTAX=OPT_BS_VEGA(alvo,preço,duração,taxa,volatilidade[,"
#~ "custo_conversão)\n"
#~ "@DESCRIPTION=OPT_BS_VEGA utiliza o modelo de Black-Scholes para calcular "
#~ "o \"vega\" de uma opção Europeia que acerta ao @preço sobre um activo com "
#~ "o preço alvo @alvo.\n"
#~ "(O vega de uma opção é a taxa de alteração do seu preço relativamente à "
#~ "volatilidade e é o mesmo para calls e puts.)\n"
#~ "@volatilidade é a volatilidade anualizada, em percentagem, do activo para "
#~ "o período até à data de exercício.\n"
#~ "@duração é o tempo até à maturidade da opção, expresso em anos\n"
#~ "@taxa é a taxa de juro livre de risco para a data de exercício, em "
#~ "percentagem.\n"
#~ "@custo_conversão é a depreciação em valor do activo subjacente, para "
#~ "acções correntes, isto seria o dividendo gerado.\n"
#~ "\n"
#~ "* O valor devolvido será expresso como o rácio de mudança do valor da "
#~ "opção, por 100% de volatilidade.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#~ msgid ""
#~ "@FUNCTION=OPT_BS_RHO\n"
#~ "@SYNTAX=OPT_BS_RHO(call_put_flag,spot,strike,time,rate,volatility[,"
#~ "cost_of_carry])\n"
#~ "@DESCRIPTION=OPT_BS_RHO uses the Black-Scholes model to calculate the "
#~ "'rho' of a European option with call_put_flag, @call_put_flag struck at "
#~ "@strike on an asset with spot price @spot.\n"
#~ "@call_put_flag is 'c' or 'p' to indicate whether the option is a call or "
#~ "a put.\n"
#~ "\n"
#~ "(The rho of an option is the rate of change of its price with respect to "
#~ "the risk free interest rate.)\n"
#~ "@time is the time to maturity of the option expressed in years.\n"
#~ "@rate is the risk-free interest rate to the exercise date, in percent.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "* The returned value will be expressed as the rate of change of option "
#~ "value, per 100% change in @rate.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_THETA, OPT_BS_VEGA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_BS_RHO\n"
#~ "@SYNTAX=OPT_BS_RHO(opção_call_put,alvo,preço,duração,taxa,volatilidade[,"
#~ "custo_conversão])\n"
#~ "@DESCRIPTION=OPT_BS_RHO utiliza o modelo de Black-Scholes para calcular o "
#~ "\"rho\" de uma opção Europeia com a opção_call_put, @opção_call_put "
#~ "acerta ao @preço sobre um activo com o preço alvo @alvo.\n"
#~ "@opção_call_put é c ou p para indicar se a opção é uma call ou put \n"
#~ "\n"
#~ "(O rho de uma opção é o rácio de alteração do seu preço em relação à taxa "
#~ "de juro sem risco.)\n"
#~ "@duração é o tempo até à maturidade da opção, expresso em anos\n"
#~ "@taxa é a taxa de juro livre de risco para a data de exercício, em "
#~ "percentagem.\n"
#~ "@custo_conversão é a depreciação em valor do activo subjacente, para "
#~ "acções correntes, isto seria o dividendo gerado\n"
#~ "* O valor devolvido será expresso como o rácio de alteração do valor da "
#~ "opção, por 100% de alteração em @taxa.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_THETA, OPT_BS_VEGA, OPT_BS_GAMMA"

#~ msgid ""
#~ "@FUNCTION=OPT_BS_CARRYCOST\n"
#~ "@SYNTAX=OPT_BS_CARRYCOST(call_put_flag,spot,strike,time,rate,volatility[,"
#~ "cost_of_carry])\n"
#~ "@DESCRIPTION=OPT_BS_CARRYCOST uses the Black-Scholes model to calculate "
#~ "the 'elasticity' of a European option struck at @strike on an asset with "
#~ "spot price @spot.\n"
#~ "@call_put_flag is 'c' or 'p' to indicate whether the option is a call or "
#~ "a put.\n"
#~ "\n"
#~ "(The elasticity of an option is the rate of change of its price with "
#~ "respect to its cost of carry.)\n"
#~ "\n"
#~ "@volatility is the annualized volatility, in percent, of the asset for "
#~ "the period through to the exercise date.  @time is the time to maturity "
#~ "of the option expressed in years.\n"
#~ "@rate is the risk-free interest rate to the exercise date, in percent.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "\n"
#~ "* The returned value will be expressed as the rate of change of option "
#~ "value, per 100% volatility.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_BS_CARRYCOST\n"
#~ "@SYNTAX=OPT_BS_CARRYCOST(opção_call_put,alvo,preço,duração,taxa,"
#~ "volatilidade[,custo_conversão])\n"
#~ "@DESCRIPTION=OPT_BS_CARRYCOST utiliza o modelo de Black-Scholes para "
#~ "calcular a \"elasticidade\" de uma opção Europeia que acerta ao @preço "
#~ "sobre um activo com o preço alvo @alvo.\n"
#~ "@opção_call_put é c ou p para indicar se a opção é uma call ou put \n"
#~ "\n"
#~ "(A elasticidade de uma opção é a taxa de alteração de seu preço "
#~ "respectivamente ao seu custo de conversão.)\n"
#~ "\n"
#~ "@volatilidade é a volatilidade anualizada, em percentagem, do activo para "
#~ "o período até à data de exercício.  @duração é o tempo até à maturidade "
#~ "da opção, expresso em anos\n"
#~ "@taxa é a taxa de juro livre de risco para a data de exercício, em "
#~ "percentagem.\n"
#~ "@custo_conversão é a depreciação em valor do activo subjacente, para "
#~ "acções correntes, isto seria o dividendo gerado\n"
#~ "\n"
#~ "* O valor devolvido será expresso como o rácio de mudança do valor da "
#~ "opção, por 100% de volatilidade.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#~ msgid ""
#~ "@FUNCTION=OPT_GARMAN_KOHLHAGEN\n"
#~ "@SYNTAX=OPT_GARMAN_KOHLHAGEN(call_put_flag,spot,strike,time,domestic_rate,"
#~ "foreign_rate,volatility[,cost_of_carry])\n"
#~ "@DESCRIPTION=OPT_GARMAN_KOHLHAGEN values the theoretical price of a "
#~ "European currency option struck at @strike on an asset with spot price "
#~ "@spot.\n"
#~ "@call_put_flag is 'c' or 'p' to indicate whether the option is a call or "
#~ "a put.\n"
#~ "@volatility is the annualized volatility, in percent, of the asset for "
#~ "the period through to the exercise date. \n"
#~ "@time the number of days to exercise.\n"
#~ "@domestic_rate is the domestic risk-free interest rate to the exercise "
#~ "date.\n"
#~ "@foreign_rate is the foreign risk-free interest rate to the exercise "
#~ "date, in percent.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "* The returned value will be expressed as the rate of change of option "
#~ "value, per 100% volatility.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_GARMAN_KOHLHAGEN\n"
#~ "@SYNTAX=OPT_GARMAN_KOHLHAGEN(opção_call_put,alvo,preço,duração,"
#~ "taxa_nacional,taxa_internacional,volatilidade[,custo_conversão])\n"
#~ "@DESCRIPTION=OPT_GARMAN_KOHLHAGEN avalia o preço teórico de uma opção "
#~ "Europeia com o alvo @alvo sobre um activo de preço @preço.\n"
#~ "@opção_call_put é c ou p para indicar se a opção é uma call ou put \n"
#~ "@volatilidade é a volatilidade anualizada, em percentagem, do activo para "
#~ "o período até à data de exercício. \n"
#~ "@duração é o número de dias até ao exercício \n"
#~ "@taxa_nacional é a taxa de juro nacional livre de risco para a data de "
#~ "exercício \n"
#~ "@taxa_internacional é a taxa de juro internacional livre de risco para a "
#~ "data de exercício, em percentagem.\n"
#~ "@custo_conversão é a depreciação em valor do activo subjacente, para "
#~ "acções correntes, isto seria o dividendo gerado\n"
#~ "* O valor devolvido será expresso como a taxa de alteração de valor da "
#~ "opção por 100% de volatilidade.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#~ msgid ""
#~ "@FUNCTION=OPT_FRENCH\n"
#~ "@SYNTAX=OPT_FRENCH(call_put_flag,spot,strike,time,t2,rate,volatility[,"
#~ "cost_of_carry])\n"
#~ "@DESCRIPTION=OPT_FRENCH values the theoretical price of a European option "
#~ "adjusted for trading day volatility, struck at @strike on an asset with "
#~ "spot price @spot.\n"
#~ "@call_put_flag is 'c' or 'p' to indicate whether the option is a call or "
#~ "a put.\n"
#~ "@volatility is the annualized volatility, in percent, of the asset for "
#~ "the period through to the exercise date.\n"
#~ " @time the number of calendar days to exercise divided by calendar days "
#~ "in the year.\n"
#~ "@t2 is the number of trading days to exercise divided by trading days in "
#~ "the year.\n"
#~ "@rate is the risk-free interest rate.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, to the "
#~ "exercise date, in percent.\n"
#~ "For common stocks, this would be the dividend yield.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_FRENCH\n"
#~ "@SYNTAX=OPT_FRENCH(opção_call_put,alvo,preço,duração,t2,taxa,"
#~ "volatilidade[,custo_conversão])\n"
#~ "@DESCRIPTION=OPT_FRENCH avalia o preço teórico de uma opção Europeia "
#~ "ajustada para a volatilidade do day-trading, com o alvo @alvo sobre um "
#~ "activo de preço @preço.\n"
#~ "@opção_call_put é 'c' ou 'p' para indicar se a opção é uma call ou put.\n"
#~ "@volatilidade é a volatilidade anualizada, em percentagem, do activo para "
#~ "o período até à data de exercício.\n"
#~ " @duração é o número de dias de calendário para o exercício dividido pelo "
#~ "número de dias de calendário no ano.\n"
#~ "@t2 é o número de dias de transacção para o exercício dividido pelo "
#~ "número de dias de transacção do ano.\n"
#~ "@taxa é a taxa de juro livre de risco.\n"
#~ "@custo_conversão é a depreciação em valor do activo subjacente, para "
#~ "acções correntes, isto seria o dividendo gerado para a data de exercício, "
#~ "em percentagem.\n"
#~ "\n"
#~ "* O valor devolvido será expresso como a taxa de alteração do valor da "
#~ "opção, por 100% da volatilidade.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#~ msgid ""
#~ "@FUNCTION=OPT_JUMP_DIFF\n"
#~ "@SYNTAX=OPT_JUMP_DIFF(call_put_flag,spot,strike,time,rate,volatility,"
#~ "lambda,gamma)\n"
#~ "@DESCRIPTION=OPT_JUMP_DIFF models the theoretical price of an option "
#~ "according to the Jump Diffusion process (Merton).\n"
#~ "@call_put_flag is 'c' or 'p' to indicate whether the option is a call or "
#~ "a put.\n"
#~ "@spot is the spot price of the underlying asset.\n"
#~ "@strike is the strike price of the option.\n"
#~ "@time is the time to maturity of the option expressed in years.\n"
#~ "@rate is the annualized rate of interest.\n"
#~ "@volatility is the annualized volatility of the underlying asset.\n"
#~ "@lambda is expected number of 'jumps' per year.\n"
#~ "@gamma is proportion of volatility explained by the 'jumps.'\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_JUMP_DIFF\n"
#~ "@SYNTAX=OPT_JUMP_DIFF(opção_call_put,alvo,preço,duração,taxa,volatilidade,"
#~ "lambda,gama)\n"
#~ "@DESCRIPTION=OPT_JUMP_DIFF modela o preço teórico de uma opção de acordo "
#~ "com o processo de Difusão em Salto (Merton).\n"
#~ "@opção_call_put é c ou p para indicar se a opção é uma call ou put \n"
#~ "@alvo é o preço alvo do subjacente\n"
#~ "@preço é o preço de exercício da opção\n"
#~ "@duração é o tempo para a maturidade da opção expresso em anos\n"
#~ "@taxa é a taxa de juro anualizada\n"
#~ "@volatilidade é a volatilidade anualizada do activo subjacente\n"
#~ "@lambda é o número de 'saltos' esperados por ano\n"
#~ "@gama é a proporção de volatilidade explicada pelos 'saltos'\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OPT_MILTERSEN_SCHWARTZ\n"
#~ "@SYNTAX=OPT_MILTERSEN_SCHWARTZ(call_put_flag,p_t,f_t,x,t1,t2,v_s,v_e,v_f,"
#~ "rho_se,rho_sf,rho_ef,kappa_e,kappa_f)\n"
#~ "@DESCRIPTION=OPT_MILTERSEN_SCHWARTZ models the theoretical price of "
#~ "options on commodities futures according to Miltersen & Schwartz. \n"
#~ "@call_put_flag is 'c' or 'p' to indicate whether the option is a call or "
#~ "a put.\n"
#~ "@p_t is a zero coupon bond with expiry at option maturity.\n"
#~ "@f_t is the futures price.\n"
#~ "@x is the strike price.\n"
#~ "@t1 is the time to maturity of the option.\n"
#~ "@t2 is the time to maturity of the underlying commodity futures "
#~ "contract.\n"
#~ "@v_s is the volatility of the spot commodity price.\n"
#~ "@v_e is the volatility of the future convenience yield.\n"
#~ "@v_f is the volatility of the forward rate of interest.\n"
#~ "@rho_se is correlation between the spot commodity price and the "
#~ "convenience yield.\n"
#~ "@rho_sf is correlation between the spot commodity price and the forward "
#~ "interest rate.\n"
#~ "@rho_ef is correlation between the forward interest rate and the "
#~ "convenience yield.\n"
#~ "@kappa_e is the speed of mean reversion of the convenience yield.\n"
#~ "@kappa_f is the speed of mean reversion of the forward interest rate.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_MILTERSEN_SCHWARTZ\n"
#~ "@SYNTAX=OPT_MILTERSEN_SCHWARTZ(opção_call_put,p_t,f_t,x,t1,t2,v_s,v_e,v_f,"
#~ "rho_se,rho_sf,rho_ef,kappa_e,kappa_f)\n"
#~ "@DESCRIPTION=OPT_MILTERSEN_SCHWARTZ modela o preço teórico de futuros "
#~ "sobre acções ou mercadorias de acordo com Miltersen & Schwartz. \n"
#~ "@opção_call_put é c ou p para indicar se a opção é uma call ou put \n"
#~ "@p_t é uma obrigação de cupão zero que expira na maturidade da opção \n"
#~ "@f_t é o preço do futuro \n"
#~ "@x é o preço alvo \n"
#~ "@t1 é o tempo para a maturidade da opção \n"
#~ "@t2 é o tempo para a maturidade do contrato de futuro de mercadorias "
#~ "subjacente \n"
#~ "@v_s é a volatilidade do preço alvo da mercadoria \n"
#~ "@v_e é a volatilidade do rendimento de conveniência futura \n"
#~ "@v_f é a volatilidade da taxa de juro futura \n"
#~ "@rho_se é a correlação entre o prelo alvo da mercadoria e o rendimento "
#~ "futuro de conveniência\n"
#~ "@rho_sf é a correlação entre o preço alvo da mercadoria e a taxa de juro "
#~ "futura \n"
#~ "@rho_ef é a correlação entre a taxa de juro futura e o rendimento futuro "
#~ "de conveniência \n"
#~ "@kappa_e é a velocidade da reversão média do rendimento futuro de "
#~ "conveniência \n"
#~ "@kappa_f é a velocidade da reversão média da taxa de juro futura \n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OPT_RGW\n"
#~ "@SYNTAX=OPT_RGW(spot,strike,t1,t2,rate,d,volatility)\n"
#~ "@DESCRIPTION=OPT_RGW models the theoretical price of an American option "
#~ "according to the Roll-Geske-Whaley approximation where: \n"
#~ "@spot is the spot price of the underlying asset.\n"
#~ "@strike is the strike price at which the option is struck.\n"
#~ "@t1 is the time to the dividend payout.\n"
#~ "@t2 is the time to option expiration.\n"
#~ "@rate is the annualized rate of interest.\n"
#~ "@d is the amount of the dividend to be paid expressed in currency.\n"
#~ "@volatility is the annualized rate of volatility of the underlying "
#~ "asset.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_RGW\n"
#~ "@SYNTAX=OPT_RGW(opção_call_put,alvo,preço,t1,t2,taxa,d,volatilidade)\n"
#~ "@DESCRIPTION=OPT_RGW modela o preço teórico de uma opção de acordo com a "
#~ "aproximação Roll Geske Whaley onde: \n"
#~ "@opção_call_put é c ou p para indicar se a opção é uma call ou put \n"
#~ "@alvo é o preço alvo do subjacente\n"
#~ "@preço é o preço de exercício da opção\n"
#~ "@t1 é a duração até ao pagamento do dividendo\n"
#~ "@t2 é o tempo até à expiração da opção.\n"
#~ "@taxa é a taxa de juro anualizada\n"
#~ "@d é o montante do dividendo a ser pago \n"
#~ "@volatilidade é a volatilidade anualizada do activo subjacente\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OPT_BAW_AMER\n"
#~ "@SYNTAX=OPT_BAW_AMER(call_put_flag,spot,strike,time,rate,cost_of_carry,"
#~ "volatility)\n"
#~ "@DESCRIPTION=OPT_BAW_AMER models the theoretical price of an option "
#~ "according to the Barone Adesie & Whaley approximation. \n"
#~ "@call_put_flag is 'c' or 'p' to indicate whether the option is a call or "
#~ "a put.\n"
#~ "@spot is the spot price of the underlying asset.\n"
#~ "@strike is the strike price at which the option is struck.\n"
#~ "@time is the number of days to maturity of the option.\n"
#~ "@rate is the annualized risk-free rate of interest.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "@volatility is the annualized volatility in price of the underlying "
#~ "asset.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_BAW_AMER\n"
#~ "@SYNTAX=OPT_BAW_AMER(opção_call_put,alvo,preço,duração,taxa,"
#~ "custo_conversão,volatilidade)\n"
#~ "@DESCRIPTION=OPT_BAW_AMER modela o preço teórico de uma opção de acordo "
#~ "com a aproximação de Barone Adesie & Whaley. \n"
#~ "@opção_call_put é c ou p para indicar se a opção é uma call ou put \n"
#~ "@alvo é o preço alvo do subjacente\n"
#~ "@preço é o preço de exercício da opção\n"
#~ "@duração é o tempo para a maturidade da opção expresso em anos\n"
#~ "@taxa é a taxa de juro anualizada\n"
#~ "@custo_conversão é a depreciação em valor do activo subjacente, para "
#~ "acções correntes, isto seria o dividendo gerado.\n"
#~ "@volatilidade é a volatilidade anualizada do activo subjacente\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OPT_BJER_STENS\n"
#~ "@SYNTAX=OPT_BJER_STENS(call_put_flag,spot,strike,time,rate,volatility[,"
#~ "cost_of_carry])\n"
#~ "@DESCRIPTION=OPT_BJER_STENS models the theoretical price of American "
#~ "options according to the Bjerksund & Stensland approximation technique.\n"
#~ "@call_put_flag is 'c' or 'p' to indicate whether the option is a call or "
#~ "a put.\n"
#~ "@spot is the spot price of the underlying asset.\n"
#~ "@strike is the strike price at which the option is struck.\n"
#~ "@time is the number of days to maturity of the option.\n"
#~ "@rate is the annualized risk-free rate of interest.\n"
#~ "@volatility is the annualized volatility in price of the underlying "
#~ "asset.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_BJER_STENS\n"
#~ "@SYNTAX=OPT_BJER_STENS(opção_call_put,alvo,preço,duração,taxa,"
#~ "volatilidade[,custo_conversão])\n"
#~ "@DESCRIPTION=OPT_BJER_STENS modela o preço teórico de opções americanas "
#~ "de acordo com a técnica de aproximação de Bjerksund & Stensland.\n"
#~ "@opção_call_put é c ou p para indicar se a opção é uma call ou put \n"
#~ "@alvo é o preço alvo do subjacente\n"
#~ "@preço é o preço de exercício da opção\n"
#~ "@duração é o tempo para a maturidade da opção expresso em anos\n"
#~ "@taxa é a taxa de juro anualizada\n"
#~ "@volatilidade é a volatilidade anualizada do activo subjacente\n"
#~ "@custo_conversão é a depreciação em valor do activo subjacente, para "
#~ "acções correntes, isto seria o dividendo gerado.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OPT_EXEC\n"
#~ "@SYNTAX=OPT_EXEC(call_put_flag,spot,strike,time,rate,volatility,"
#~ "cost_of_carry,lambda)\n"
#~ "@DESCRIPTION=OPT_EXEC models the theoretical price of executive stock "
#~ "options @call_put_flag is 'c' or 'p' to indicate whether the option is a "
#~ "call or a put.\n"
#~ "One would expect this to always be a call option.\n"
#~ "@spot is the spot price of the underlying asset.\n"
#~ "@strike is the strike price at which the option is struck.\n"
#~ "@time is the number of days to maturity of the option.\n"
#~ "@rate is the annualized risk-free rate of interest.\n"
#~ "@volatility is the annualized volatility in price of the underlying "
#~ "asset.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "@lambda is the jump rate for executives. The model assumes executives "
#~ "forfeit their options if they leave the company.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_EXEC\n"
#~ "@SYNTAX=OPT_EXEC(opção_call_put,alvo,preço,duração,taxa,volatilidade,"
#~ "custo_conversão,lambda)\n"
#~ "@DESCRIPTION=OPT_EXEC modela o preço teórico de opções executivas sobre "
#~ "acções @opção_call_put é c ou p para indicar se a opção é uma call ou "
#~ "put \n"
#~ "Será de esperar que sejam sempre opções call \n"
#~ "@alvo é o preço alvo do subjacente \n"
#~ "@preço é o preço de exercício da opção \n"
#~ "@duração é o tempo para a maturidade da opção \n"
#~ "@taxa é a taxa de juro livre de risco anualizada \n"
#~ "@volatilidade é a volatilidade anualizada do activo subjacente \n"
#~ "@custo_conversão é a depreciação em valor do activo subjacente, para "
#~ "acções correntes, isto seria o dividendo gerado.\n"
#~ "@lambda é a taxa de salto para os executivos. O modelo assume que os "
#~ "executivos perdem o direito às suas opções se sairem da empresa.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OPT_FORWARD_START\n"
#~ "@SYNTAX=OPT_FORWARD_START(call_put_flag,spot,alpha,time1,time,rate,"
#~ "volatility,cost_of_carry)\n"
#~ "@DESCRIPTION=OPT_FORWARD_START models the theoretical price of forward "
#~ "start options\n"
#~ " @call_put_flag is 'c' or 'p' to indicate whether the option is a call or "
#~ "a put.\n"
#~ "@spot is the spot price of the underlying asset.\n"
#~ "@alpha is a fraction that set the strike price the future date @time1.\n"
#~ "@time1 is the number of days until the option starts.\n"
#~ "@time is the number of days to maturity of the option.\n"
#~ "@rate is the annualized risk-free rate of interest.\n"
#~ "@volatility is the annualized volatility in price of the underlying "
#~ "asset.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_FORWARD_START\n"
#~ "@SYNTAX=OPT_FORWARD_START(opção_call_put,alvo,alfa,duração1,duração,taxa,"
#~ "volatilidade,custo_conversão)\n"
#~ "@DESCRIPTION=OPT_FORWARD_START modela o preço teórico de opções de início "
#~ "avançado (forward start)\n"
#~ "\n"
#~ "@opção_call_put é c ou p para indicar se a opção é uma call ou put \n"
#~ "@alvo é o preço alvo do subjacente \n"
#~ "@alfa é uma francção que define o preço na data futura @duração1\n"
#~ "@duração1 é o número de dias até que a opção inicie \n"
#~ "@duração é o número de dias para a maturidade da opção \n"
#~ "@taxa é a taxa de juro livre de risco anualizada \n"
#~ "@volatilidade é a volatilidade anualizada do activo subjacente \n"
#~ "@custo_conversão é a depreciação em valor do activo subjacente, para "
#~ "acções correntes, isto seria o dividendo gerado\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OPT_TIME_SWITCH\n"
#~ "@SYNTAX=OPT_TIME_SWITCH(call_put_flag,spot,strike,a,time,m,dt,rate,"
#~ "cost_of_carry,volatility)\n"
#~ "@DESCRIPTION=OPT_TIME_SWITCH models the theoretical price of time switch "
#~ "options. (Pechtl 1995)\n"
#~ "The holder receives @a * @dt for each period dt that the asset price was "
#~ "greater than the strike price (for a call) or below it (for a put). \n"
#~ "@call_put_flag is 'c' or 'p' to indicate whether the option is a call or "
#~ "a put.\n"
#~ "@spot is the spot price of the underlying asset.\n"
#~ "@strike is the strike price at which the option is struck.\n"
#~ "@a is the amount received for each time period as discussed above.\n"
#~ "@time is the maturity of the option in years.\n"
#~ "@m is the number of time units the option has already met the condition.\n"
#~ "@dt is the agreed upon discrete time period (often a day) expressed as a "
#~ "fraction of a year.\n"
#~ "@rate is the annualized risk-free rate of interest.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_TIME_SWITCH\n"
#~ "@SYNTAX=OPT_TIME_SWITCH(opção_call_put,alvo,preço,a,duração,m,dt,taxa,"
#~ "custo_conversão,volatilidade)\n"
#~ "@DESCRIPTION=OPT_TIME_SWITCH modela o preço teórico de opções de troca "
#~ "temporais. (Pechtl 1995)\n"
#~ "O detentor recebe @a * @dt para cada período dt que o preço do activo foi "
#~ "maior que o preço alvo (para uma call) ou abaixo (para uma put) \n"
#~ "@opção_call_put é c ou p para indicar se a opção é uma call ou put \n"
#~ "@alvo é o preço alvo do subjacente \n"
#~ "@preço é o preço de exercício da opção \n"
#~ "@a é a quantidade recebida por cada período de tempo, tal como explicado "
#~ "acima\n"
#~ "@duração é a maturidade da opção em anos \n"
#~ "@m é o número de unidades de tempo em que a opção já atingiu a condição \n"
#~ "@dt é o período de tempo discreto acordado (normalmente um dia) expresso "
#~ "como uma fracção de um ano \n"
#~ "@taxa é a taxa de juro livre de risco anualizada \n"
#~ "@custo_conversão é a depreciação em valor do activo subjacente, para "
#~ "acções correntes, isto seria o dividendo gerado\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OPT_SIMPLE_CHOOSER\n"
#~ "@SYNTAX=OPT_SIMPLE_CHOOSER(call_put_flag,spot,strike,time1,time2,rate,"
#~ "cost_of_carry,volatility)\n"
#~ "@DESCRIPTION=OPT_SIMPLE_CHOOSER models the theoretical price of simple "
#~ "chooser options.\n"
#~ "@call_put_flag is 'c' or 'p' to indicate whether the option is a call or "
#~ "a put.\n"
#~ "@spot is the spot price of the underlying asset.\n"
#~ "@strike is the strike price at which the option is struck.\n"
#~ "@time1 is the time in years until the holder chooses a put or a call "
#~ "option.\n"
#~ "@time2 is the time in years until the chosen option expires.\n"
#~ "@rate is the annualized risk-free rate of interest.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_SIMPLE_CHOOSER\n"
#~ "@SYNTAX=OPT_SIMPLE_CHOOSER(opção_call_put,alvo,preço,duração1,duração2,"
#~ "taxa,custo_conversão,volatilidade)\n"
#~ "@DESCRIPTION=OPT_SIMPLE_CHOOSER modela o preço teórico de opções de "
#~ "selecção simples.\n"
#~ "@opção_call_put é c ou p para indicar se a opção é uma call ou put \n"
#~ "@alvo é o preço alvo do subjacente \n"
#~ "@preço é o preço de exercício da opção \n"
#~ "@duração1 é o tempo em anos até que o detentor seleccione uma opção call "
#~ "ou put\n"
#~ "@duração2 é o tempo em anos até que a opção seleccionada expire\n"
#~ "@taxa é a taxa de juro livre de risco anualizada \n"
#~ "@custo_conversão é a depreciação em valor do activo subjacente, para "
#~ "acções correntes, isto seria o dividendo gerado\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OPT_COMPLEX_CHOOSER\n"
#~ "@SYNTAX=OPT_COMPLEX_CHOOSER(call_put_flag,spot,strike_call,strike_put,"
#~ "time,time_call,time_put,rate,cost_of_carry,volatility)\n"
#~ "@DESCRIPTION=OPT_COMPLEX_CHOOSER models the theoretical price of complex "
#~ "chooser options.\n"
#~ "@call_put_flag is 'c' or 'p' to indicate whether the option is a call or "
#~ "a put.\n"
#~ "@spot is the spot price of the underlying asset.\n"
#~ "@strike_call is the strike price at which the option is struck, "
#~ "applicable if exercised as a call option.\n"
#~ "@strike_put is the strike price at which the option is struck, applicable "
#~ "if exercised as a put option.\n"
#~ "@time is the time in years until the holder chooses a put or a call "
#~ "option. \n"
#~ "@time_call is the time in years to maturity of the call option if "
#~ "chosen.\n"
#~ "@time_put is the time in years  to maturity of the put option if chosen.\n"
#~ "@rate is the annualized risk-free rate of interest.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "@volatility is the annualized volatility in price of the underlying "
#~ "asset.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_COMPLEX_CHOOSER\n"
#~ "@SYNTAX=OPT_COMPLEX_CHOOSER(opção_call_put,alvo,preço_call,preço_put,"
#~ "duração,duração_call,duração_put,taxa,custo_conversão,volatilidade)\n"
#~ "@DESCRIPTION=OPT_COMPLEX_CHOOSER modela o preço teórico de opções de "
#~ "selecção complexas.\n"
#~ "@opção_call_put é c ou p para indicar se a opção é uma call ou put \n"
#~ "@alvo é o preço alvo do subjacente \n"
#~ "@preço_call é o preço de exercício da opção \n"
#~ "@preço_put é o preço de exercício da opção \n"
#~ "@duração é o tempo em anos até que o detentor seleccione uma opção call "
#~ "ou put\n"
#~ "@duração_call é o tempo em anos até à maturidade da opção call, se "
#~ "seleccionada\n"
#~ "@duração_put é o tempo em anos até à maturidade da opção put, se "
#~ "seleccionada\n"
#~ "@taxa é a taxa de juro livre de risco anualizada \n"
#~ "@custo_conversão é a depreciação em valor do activo subjacente, para "
#~ "acções correntes, isto seria o dividendo gerado\n"
#~ "@volatilidade é a volatilidade anualizada do activo subjacente \n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OPT_ON_OPTIONS\n"
#~ "@SYNTAX=OPT_ON_OPTIONS(type_flag,spot,strike1,strike2,time1,time2,rate,"
#~ "cost_of_carry,volatility)\n"
#~ "@DESCRIPTION=OPT_ON_OPTIONS models the theoretical price of options on "
#~ "options.\n"
#~ "@type_flag is 'cc' for calls on calls, 'cp' for calls on puts, and so on "
#~ "for 'pc', and 'pp'.\n"
#~ "@spot is the spot price of the underlying asset.\n"
#~ "@strike1 is the strike price at which the option being valued is struck.\n"
#~ "@strike2 is the strike price at which the underlying option is struck.\n"
#~ "@time1 is the time in years to maturity of the option.\n"
#~ "@time2 is the time in years to the maturity of the underlying option.\n"
#~ "(@time2 >= @time1).\n"
#~ "@rate is the annualized risk-free rate of interest.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset of the "
#~ "underlying option.for common stocks, this would be the dividend yield.\n"
#~ "@volatility is the annualized volatility in price of the underlying asset "
#~ "of the underlying option.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_ON_OPTIONS\n"
#~ "@SYNTAX=OPT_ON_OPTIONS(tipo_opção,alvo,preço1,preço2,duração1,duração2,"
#~ "taxa,custo_conversão,volatilidade)\n"
#~ "@DESCRIPTION=OPT_ON_OPTIONS modela o preço teório de opções sobre "
#~ "opções \n"
#~ "\n"
#~ "@tipo_opção é 'cc' para calls sobre calls, 'cp' para calls sobre puts, "
#~ "com a mesma lógica para 'pc' e 'pp'\n"
#~ "@alvo é o preço alvo do activo subjacente.\n"
#~ "@preço1 é o preço de exercício da opção \n"
#~ "@preço2 é o preço de exercício da opção \n"
#~ "@duração1 é o tempo em anos até à maturidade da opção.\n"
#~ "@duração2 é o tempo em anos até à maturidade da opção subjacente.\n"
#~ "(@duração2 >= @duração1)\n"
#~ "@taxa é a taxa de juro livre de risco anualizada \n"
#~ "@custo_conversão é a depreciação em valor do activo subjacente, para "
#~ "acções correntes, isto seria o dividendo gerado\n"
#~ "@volatilidade é a volatilidade anualizada do activo subjacente \n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OPT_EXTENDIBLE_WRITER\n"
#~ "@SYNTAX=OPT_EXTENDIBLE_WRITER(call_put_flag,spot,strike1,strike2,time1,"
#~ "time2,rate,cost_of_carry,volatility)\n"
#~ "@DESCRIPTION=OPT_EXTENDIBLE_WRITER models the theoretical price of "
#~ "extendible writer options. These are options that can be exercised at an "
#~ "initial period, @time1, or their maturity extended to @time2 if the "
#~ "option is out of the money at @time1.\n"
#~ "@call_put_flag is 'c' or 'p' to indicate whether the option is a call or "
#~ "a put.\n"
#~ "@spot is the spot price of the underlying asset.\n"
#~ "@strike1 is the strike price at which the option is struck.\n"
#~ "@strike2 is the strike price at which the option is re-struck if out of "
#~ "the money at @time1.\n"
#~ "@time1 is the initial maturity of the option in years.\n"
#~ "@time2 is the is the extended maturity in years if chosen.\n"
#~ "@rate is the annualized risk-free rate of interest.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "@volatility is the annualized volatility in price of the underlying "
#~ "asset.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_EXTENDIBLE_WRITER\n"
#~ "@SYNTAX=OPT_EXTENDIBLE_WRITER(opção_call_put,alvo,preço1,preço2,duração1,"
#~ "duração2,taxa,custo_conversão,volatilidade)\n"
#~ "@DESCRIPTION=OPT_EXTENDIBLE_WRITER modela o preço teórico de opções de "
#~ "escrita extensível. Estas são opções que podem ser exercidas num período "
#~ "inicial, @duração1, ou a sua maturidade ser extendida para @duração2 se a "
#~ "opção estiver 'out of the money' no @duração1 \n"
#~ "@opção_call_put é c ou p para indicar se a opção é uma call ou put \n"
#~ "@alvo é o preço alvo do activo subjacente.\n"
#~ "@preço1 é o preço de exercício da opção.\n"
#~ "@preço2 é o preço de exercício da opção.\n"
#~ "@duração1 é a maturidade inicial da opção em anos.\n"
#~ "@duração2 é a maturidade extendida da opção em anos, se seleccionada.\n"
#~ "@taxa é a taxa de juro livre de risco anualizada.\n"
#~ "@custo_conversão é a depreciação em valor do activo subjacente, para "
#~ "acções correntes, isto seria o dividendo gerado.\n"
#~ "@volatilidade é a volatilidade anualizada do activo subjacente.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OPT_2_ASSET_CORRELATION\n"
#~ "@SYNTAX=OPT_2_ASSET_CORRELATION(call_put_flag,spot1,spot2,strike1,strike2,"
#~ "time,cost_of_carry1,cost_of_carry2,rate,volatility1,volatility2,rho)\n"
#~ "@DESCRIPTION=OPT_2_ASSET_CORRELATION models the theoretical price of  "
#~ "options on 2 assets with correlation @rho.\n"
#~ "The payoff for a call is max(@spot2 - @strike2,0) if @spot1 > @strike1 or "
#~ "0 otherwise.\n"
#~ "The payoff for a put is max (@strike2 - @spot2, 0) if @spot1 < @strike1 "
#~ "or 0 otherwise.\n"
#~ "@call_put_flag is 'c' or 'p' to indicate whether the option is a call or "
#~ "a put.\n"
#~ "@spot1 & @spot2 are the spot prices of the underlying assets.\n"
#~ "@strike1 & @strike2 are the strike prices at which the option is struck.\n"
#~ "@time is the initial maturity of the option in years.\n"
#~ "@rate is the annualized risk-free rate of interest.\n"
#~ "@cost_of_carry1 & @cost_of_carry2 are the leakage in value of the "
#~ "underlying assets, for common stocks, this would be the dividend yield.\n"
#~ "@volatility1 & @volatility2 are the annualized volatility in price of the "
#~ "underlying assets.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_BAW_AMER\n"
#~ "@SYNTAX=OPT_BAW_AMER(opção_call_put,alvo,preço,duração,taxa,"
#~ "custo_conversão,volatilidade)\n"
#~ "@DESCRIPTION=OPT_BAW_AMER modela o preço teórico de uma opção de acordo "
#~ "com a aproximação de Barone Adesie & Whaley. \n"
#~ "@opção_call_put é c ou p para indicar se a opção é uma call ou put \n"
#~ "@alvo é o preço alvo do subjacente\n"
#~ "@preço é o preço de exercício da opção\n"
#~ "@duração é o tempo para a maturidade da opção expresso em anos\n"
#~ "@taxa é a taxa de juro anualizada\n"
#~ "@custo_conversão é a depreciação em valor do activo subjacente, para "
#~ "acções correntes, isto seria o dividendo gerado.\n"
#~ "@volatilidade é a volatilidade anualizada do activo subjacente\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OPT_EURO_EXCHANGE\n"
#~ "@SYNTAX=OPT_EURO_EXCHANGE(spot1,spot2,qty1,qty2,time,rate,cost_of_carry1,"
#~ "cost_of_carry2,volatility1,volatility2,rho)\n"
#~ "@DESCRIPTION=OPT_EURO_EXCHANGE models the theoretical price of a European "
#~ "option to exchange one asset with quantity @qty2 and spot price @spot2 "
#~ "for another, with quantity @qty1 and spot price @spot1.\n"
#~ "@time is the initial maturity of the option in years.\n"
#~ "@rate is the annualized risk-free rate of interest.\n"
#~ "@cost_of_carry1 & @cost_of_carry2 are the leakage in value of the "
#~ "underlying assets, for common stocks, this would be the dividend yield.\n"
#~ "@volatility1 & @volatility2 are the annualized volatility in price of the "
#~ "underlying assets.\n"
#~ "@rho is the correlation between the two assets.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_AMER_EXCHANGE, OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, "
#~ "OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_BAW_AMER\n"
#~ "@SYNTAX=OPT_BAW_AMER(opção_call_put,alvo,preço,duração,taxa,"
#~ "custo_conversão,volatilidade)\n"
#~ "@DESCRIPTION=OPT_BAW_AMER modela o preço teórico de uma opção de acordo "
#~ "com a aproximação de Barone Adesie & Whaley. \n"
#~ "@opção_call_put é c ou p para indicar se a opção é uma call ou put \n"
#~ "@alvo é o preço alvo do subjacente\n"
#~ "@preço é o preço de exercício da opção\n"
#~ "@duração é o tempo para a maturidade da opção expresso em anos\n"
#~ "@taxa é a taxa de juro anualizada\n"
#~ "@custo_conversão é a depreciação em valor do activo subjacente, para "
#~ "acções correntes, isto seria o dividendo gerado.\n"
#~ "@volatilidade é a volatilidade anualizada do activo subjacente\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OPT_AMER_EXCHANGE\n"
#~ "@SYNTAX=OPT_AMER_EXCHANGE(spot1,spot2,qty1,qty2,time,rate,cost_of_carry1,"
#~ "cost_of_carry2,volatility1, volatility2, rho)\n"
#~ "@DESCRIPTION=OPT_AMER_EXCHANGE models the theoretical price of an "
#~ "American option to exchange one asset with quantity @qty2 and spot price "
#~ "@spot2 for another, with quantity @qty1 and spot price @spot1.\n"
#~ "@time is the initial maturity of the option in years.\n"
#~ "@rate is the annualized risk-free rate of interest.\n"
#~ "@cost_of_carry1 & @cost_of_carry2 are the leakage in value of the "
#~ "underlying assets, for common stocks, this would be the dividend yield.\n"
#~ "@volatility1 & @volatility2 are the annualized volatility in price of the "
#~ "underlying assets.\n"
#~ "@rho is the correlation between the two assets.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_EURO_EXCHANGE, OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, "
#~ "OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_BAW_AMER\n"
#~ "@SYNTAX=OPT_BAW_AMER(opção_call_put,alvo,preço,duração,taxa,"
#~ "custo_conversão,volatilidade)\n"
#~ "@DESCRIPTION=OPT_BAW_AMER modela o preço teórico de uma opção de acordo "
#~ "com a aproximação de Barone Adesie & Whaley. \n"
#~ "@opção_call_put é c ou p para indicar se a opção é uma call ou put \n"
#~ "@alvo é o preço alvo do subjacente\n"
#~ "@preço é o preço de exercício da opção\n"
#~ "@duração é o tempo para a maturidade da opção expresso em anos\n"
#~ "@taxa é a taxa de juro anualizada\n"
#~ "@custo_conversão é a depreciação em valor do activo subjacente, para "
#~ "acções correntes, isto seria o dividendo gerado.\n"
#~ "@volatilidade é a volatilidade anualizada do activo subjacente\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OPT_SPREAD_APPROX\n"
#~ "@SYNTAX=OPT_SPREAD_APPROX(call_put_flag,fut_price1,fut_price2,strike,"
#~ "time, rate,volatility1,volatility2,rho)\n"
#~ "@DESCRIPTION=OPT_SPREAD_APPROX models the theoretical price of a European "
#~ "option on the spread between two futures contracts.\n"
#~ "@call_put_flag is 'c' or 'p' to indicate whether the option is a call or "
#~ "a put.\n"
#~ "@fut_price1 & @fut_price2 are the prices of the two futures contracts.\n"
#~ "@strike is the strike price at which the option is struck \n"
#~ "@time is the initial maturity of the option in years.\n"
#~ "@rate is the annualized risk-free rate of interest.\n"
#~ "@volatility1 & @volatility2 are the annualized volatility in price of the "
#~ "underlying futures contracts.\n"
#~ "@rho is the correlation between the two futures contracts.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_BJER_STENS\n"
#~ "@SYNTAX=OPT_BJER_STENS(opção_call_put,alvo,preço,duração,taxa,"
#~ "volatilidade[,custo_conversão])\n"
#~ "@DESCRIPTION=OPT_BJER_STENS modela o preço teórico de opções americanas "
#~ "de acordo com a técnica de aproximação de Bjerksund & Stensland.\n"
#~ "@opção_call_put é c ou p para indicar se a opção é uma call ou put \n"
#~ "@alvo é o preço alvo do subjacente\n"
#~ "@preço é o preço de exercício da opção\n"
#~ "@duração é o tempo para a maturidade da opção expresso em anos\n"
#~ "@taxa é a taxa de juro anualizada\n"
#~ "@volatilidade é a volatilidade anualizada do activo subjacente\n"
#~ "@custo_conversão é a depreciação em valor do activo subjacente, para "
#~ "acções correntes, isto seria o dividendo gerado.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OPT_FLOAT_STRK_LKBK\n"
#~ "@SYNTAX=OPT_FLOAT_STRK_LKBK(call_put_flag,spot,spot_min,spot_max,time,"
#~ "rate,cost_of_carry,volatility)\n"
#~ "@DESCRIPTION=OPT_FLOAT_STRK_LKBK models the theoretical price of an "
#~ "option where the holder of the option may exercise on expiry at the most "
#~ "favourable price observed during the options life of the underlying "
#~ "asset.\n"
#~ "@call_put_flag is 'c' or 'p' to indicate whether the option is a call or "
#~ "a put.\n"
#~ "@spot is the spot price of the underlying asset.\n"
#~ "@spot_min is the minimum spot price of the underlying asset so far "
#~ "observed.\n"
#~ "@spot_max is the maximum spot price of the underlying asset so far "
#~ "observed.\n"
#~ "@time is the initial maturity of the option in years.\n"
#~ "@rate is the annualized risk-free rate of interest.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "@volatility is the annualized volatility in price of the underlying "
#~ "asset.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_BAW_AMER\n"
#~ "@SYNTAX=OPT_BAW_AMER(opção_call_put,alvo,preço,duração,taxa,"
#~ "custo_conversão,volatilidade)\n"
#~ "@DESCRIPTION=OPT_BAW_AMER modela o preço teórico de uma opção de acordo "
#~ "com a aproximação de Barone Adesie & Whaley. \n"
#~ "@opção_call_put é c ou p para indicar se a opção é uma call ou put \n"
#~ "@alvo é o preço alvo do subjacente\n"
#~ "@preço é o preço de exercício da opção\n"
#~ "@duração é o tempo para a maturidade da opção expresso em anos\n"
#~ "@taxa é a taxa de juro anualizada\n"
#~ "@custo_conversão é a depreciação em valor do activo subjacente, para "
#~ "acções correntes, isto seria o dividendo gerado.\n"
#~ "@volatilidade é a volatilidade anualizada do activo subjacente\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OPT_FIXED_STRK_LKBK\n"
#~ "@SYNTAX=OPT_FIXED_STRK_LKBK(call_put_flag,spot,spot_min,spot_max,strike,"
#~ "time,rate,cost_of_carry,volatility)\n"
#~ "@DESCRIPTION=OPT_FIXED_STRK_LKBK models the theoretical price of an "
#~ "option where the holder of the option may exercise on expiry at the most "
#~ "favourable price observed during the options life of the underlying "
#~ "asset.\n"
#~ "@call_put_flag is 'c' or 'p' to indicate whether the option is a call or "
#~ "a put.\n"
#~ "@spot is the spot price of the underlying asset.\n"
#~ "@spot_min is the minimum spot price of the underlying asset so far "
#~ "observed.\n"
#~ "@spot_max is the maximum spot price of the underlying asset so far "
#~ "observed.\n"
#~ "@strike is the strike prices at which the option is struck.\n"
#~ "@time is the initial maturity of the option in years.\n"
#~ "@rate is the annualized risk-free rate of interest.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "@volatility is the annualized volatility in price of the underlying "
#~ "asset.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_EXTENDIBLE_WRITER\n"
#~ "@SYNTAX=OPT_EXTENDIBLE_WRITER(opção_call_put,alvo,preço1,preço2,duração1,"
#~ "duração2,taxa,custo_conversão,volatilidade)\n"
#~ "@DESCRIPTION=OPT_EXTENDIBLE_WRITER modela o preço teórico de opções de "
#~ "escrita extensível. Estas são opções que podem ser exercidas num período "
#~ "inicial, @duração1, ou a sua maturidade ser extendida para @duração2 se a "
#~ "opção estiver 'out of the money' no @duração1 \n"
#~ "@opção_call_put é c ou p para indicar se a opção é uma call ou put \n"
#~ "@alvo é o preço alvo do activo subjacente.\n"
#~ "@preço1 é o preço de exercício da opção.\n"
#~ "@preço2 é o preço de exercício da opção.\n"
#~ "@duração1 é a maturidade inicial da opção em anos.\n"
#~ "@duração2 é a maturidade extendida da opção em anos, se seleccionada.\n"
#~ "@taxa é a taxa de juro livre de risco anualizada.\n"
#~ "@custo_conversão é a depreciação em valor do activo subjacente, para "
#~ "acções correntes, isto seria o dividendo gerado.\n"
#~ "@volatilidade é a volatilidade anualizada do activo subjacente.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OPT_BINOMIAL\n"
#~ "@SYNTAX=OPT_BINOMIAL(amer_euro_flag,call_put_flag,num_time_steps, spot, "
#~ "strike, time, rate, volatility, cost_of_carry)\n"
#~ "@DESCRIPTION=OPT_ models the theoretical price of either an American or "
#~ "European style option using a binomial tree.\n"
#~ "@amer_euro_flag is either 'a' or 'e' to indicate whether the option being "
#~ "valued is an American or European style option respectively.\n"
#~ "@call_put_flag is 'c' or 'p' to indicate whether the option is a call or "
#~ "a put.\n"
#~ "@num_time_steps is the number of time steps used in the valuation, a "
#~ "greater number of time steps yields greater accuracy however is slower to "
#~ "calculate.\n"
#~ "@spot is the spot price of the underlying asset.\n"
#~ "@strike is the strike price at which the option is struck.\n"
#~ "@time is the initial maturity of the option in years.\n"
#~ "@rate is the annualized risk-free rate of interest.\n"
#~ "@volatility is the annualized volatility in price of the underlying "
#~ "asset.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_BJER_STENS\n"
#~ "@SYNTAX=OPT_BJER_STENS(opção_call_put,alvo,preço,duração,taxa,"
#~ "volatilidade[,custo_conversão])\n"
#~ "@DESCRIPTION=OPT_BJER_STENS modela o preço teórico de opções americanas "
#~ "de acordo com a técnica de aproximação de Bjerksund & Stensland.\n"
#~ "@opção_call_put é c ou p para indicar se a opção é uma call ou put \n"
#~ "@alvo é o preço alvo do subjacente\n"
#~ "@preço é o preço de exercício da opção\n"
#~ "@duração é o tempo para a maturidade da opção expresso em anos\n"
#~ "@taxa é a taxa de juro anualizada\n"
#~ "@volatilidade é a volatilidade anualizada do activo subjacente\n"
#~ "@custo_conversão é a depreciação em valor do activo subjacente, para "
#~ "acções correntes, isto seria o dividendo gerado.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#~ msgid ""
#~ "@FUNCTION=COMPLEX\n"
#~ "@SYNTAX=COMPLEX(real,im[,suffix])\n"
#~ "@DESCRIPTION=COMPLEX returns a complex number of the form x + yi.\n"
#~ "\n"
#~ "@real is the real and @im is the imaginary part of the complex number.  "
#~ "@suffix is the suffix for the imaginary part.  If it is omitted, COMPLEX "
#~ "uses 'i' by default.\n"
#~ "\n"
#~ "* If @suffix is neither 'i' nor 'j', COMPLEX returns #VALUE! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COMPLEX(1,-1) equals 1-i.\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=COMPLEX\n"
#~ "@SYNTAX=COMPLEX(real,im[,sufixo])\n"
#~ "@DESCRIPTION=COMPLEX devolve um número complexo no formato x + yi.\n"
#~ "\n"
#~ "@real é real e @im é o coeficiente imaginário do número complexo.  "
#~ "@sufixo é o sufixo do coeficiente imaginário. Se for omitido, COMPLEX "
#~ "utiliza 'i' por omissão.\n"
#~ "\n"
#~ "* Se @sufixo não for nem 'i' nem 'j', COMPLEX devolve o erro #VALOR!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COMPLEX(1,-1) igual a 1-i.\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=IMAGINARY\n"
#~ "@SYNTAX=IMAGINARY(inumber)\n"
#~ "@DESCRIPTION=IMAGINARY returns the imaginary part of a complex number.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMAGINARY returns #VALUE! "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMAGINARY(\"132-j\") equals -1.\n"
#~ "\n"
#~ "@SEEALSO=IMREAL"
#~ msgstr ""
#~ "@FUNCTION=IMAGINARY\n"
#~ "@SYNTAX=IMAGINARY(inúmero)\n"
#~ "@DESCRIPTION=IMAGINARY devolve o coeficiente imaginário de um número "
#~ "complexo.\n"
#~ "\n"
#~ "* Se @inúmero não for um número complexo válido, IMAGINARY devolve o erro "
#~ "#VALOR!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMAGINARY(\"132-j\") igual a -1.\n"
#~ "\n"
#~ "@SEEALSO=IMREAL"

#~ msgid ""
#~ "@FUNCTION=IMABS\n"
#~ "@SYNTAX=IMABS(inumber)\n"
#~ "@DESCRIPTION=IMABS returns the absolute value of a complex number.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMABS returns #VALUE! "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMABS(\"2-j\") equals 2.23606798.\n"
#~ "\n"
#~ "@SEEALSO=IMAGINARY,IMREAL"
#~ msgstr ""
#~ "@FUNCTION=IMABS\n"
#~ "@SYNTAX=IMABS(inúmero)\n"
#~ "@DESCRIPTION=IMABS devolve o valor absoluto de um número complexo.\n"
#~ "\n"
#~ "* Se @inúmero não for um número complexo válido, IMABS devolve o erro "
#~ "#VALOR!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMABS(\"2-j\") igual a 2.23606798.\n"
#~ "\n"
#~ "@SEEALSO=IMAGINARY,IMREAL"

#~ msgid ""
#~ "@FUNCTION=IMREAL\n"
#~ "@SYNTAX=IMREAL(inumber)\n"
#~ "@DESCRIPTION=IMREAL returns the real part of a complex number.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMREAL returns #VALUE! "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "imreal(\"132-j\") equals 132.\n"
#~ "\n"
#~ "@SEEALSO=IMAGINARY"
#~ msgstr ""
#~ "@FUNCTION=IMREAL\n"
#~ "@SYNTAX=IMREAL(inúmero)\n"
#~ "@DESCRIPTION=IMREAL devolve o coeficiente real de um número complexo.\n"
#~ "\n"
#~ "* Se @inúmero não for um número complexo válido, IMREAL devolve o erro "
#~ "#VALOR!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "imreal(\"132-j\") igual a 132.\n"
#~ "\n"
#~ "@SEEALSO=IMAGINARY"

#~ msgid ""
#~ "@FUNCTION=IMCONJUGATE\n"
#~ "@SYNTAX=IMCONJUGATE(inumber)\n"
#~ "@DESCRIPTION=IMCONJUGATE returns the complex conjugate of a complex "
#~ "number.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMCONJUGATE returns #VALUE! "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMCONJUGATE(\"1-j\") equals 1+j.\n"
#~ "\n"
#~ "@SEEALSO=IMAGINARY,IMREAL"
#~ msgstr ""
#~ "@FUNCTION=IMCONJUGATE\n"
#~ "@SYNTAX=IMCONJUGATE(inúmero)\n"
#~ "@DESCRIPTION=IMCONJUGATE devolve o conjugado complexo de um número "
#~ "complexo.\n"
#~ "\n"
#~ "* Se @inúmero não for um número complexo válido, IMCONJUGATE devolve o "
#~ "erro #VALOR!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMCONJUGATE(\"1-j\") igual a 1+j.\n"
#~ "\n"
#~ "@SEEALSO=IMAGINARY,IMREAL"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=IMINV\n"
#~ "@SYNTAX=IMINV(inumber)\n"
#~ "@DESCRIPTION=IMINV returns the inverse, or reciprocal, of the complex "
#~ "number z (@inumber), where\n"
#~ "\n"
#~ "\t1/z = (x - i y)/(x^2 + y^2).\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMINV returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMINV(\"1-j\") equals 0.5+0.5j.\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=IMINV\n"
#~ "@SYNTAX=IMINV(inúmero)\n"
#~ "@DESCRIPTION=IMINV devolve o inverso, ou recíproco, do número complexo z "
#~ "(@inúmero), onde.\n"
#~ "\n"
#~ "\t1/z = (x - i y)/(x^2 + y^2).\n"
#~ "\n"
#~ "* Se @inúmero não for um número complexo válido, IMINV devolve o erro "
#~ "#VALOR!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMINV(\"1-j\") igual a 0.5+0.5j.\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=IMNEG\n"
#~ "@SYNTAX=IMNEG(inumber)\n"
#~ "@DESCRIPTION=IMNEG returns the negative of the complex number z "
#~ "(@inumber), where\n"
#~ "\n"
#~ "\t-z = (-x) + i(-y).\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMNEG returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMNEG(\"1-j\") equals -1+j.\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=IMNEG\n"
#~ "@SYNTAX=IMNEG(inúmero)\n"
#~ "@DESCRIPTION=IMNEG devolve o negativo do número complexo z (@inúmero), "
#~ "onde\n"
#~ "\n"
#~ "\t-z = (-x) + i(-y).\n"
#~ "\n"
#~ "* Se @inúmero não for um número complexo válido, IMNEG devolve o erro "
#~ "#VALOR!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMNEG(\"1-j\") igual a -1+j.\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=IMCOS\n"
#~ "@SYNTAX=IMCOS(inumber)\n"
#~ "@DESCRIPTION=IMCOS returns the cosine of a complex number.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMCOS returns #VALUE! "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMCOS(\"1+j\") equals 0.833730-0.988898j.\n"
#~ "\n"
#~ "@SEEALSO=IMSIN,IMTAN"
#~ msgstr ""
#~ "@FUNCTION=IMCOS\n"
#~ "@SYNTAX=IMCOS(inúmero)\n"
#~ "@DESCRIPTION=IMCOS devolve o coseno de um número complexo.\n"
#~ "\n"
#~ "* Se @inúmero não for um número complexo válido, IMCOS devolve o erro "
#~ "#VALOR!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMCOS(\"1+j\") igual a 0.833730-0.988898j.\n"
#~ "\n"
#~ "@SEEALSO=IMSIN,IMTAN"

#~ msgid ""
#~ "@FUNCTION=IMTAN\n"
#~ "@SYNTAX=IMTAN(inumber)\n"
#~ "@DESCRIPTION=IMTAN returns the tangent of a complex number.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMTAN returns #VALUE! "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMTAN(\"2-j\") equals -0.2434582-1.1667363j.\n"
#~ "\n"
#~ "@SEEALSO=IMSIN,IMCOS"
#~ msgstr ""
#~ "@FUNCTION=IMTAN\n"
#~ "@SYNTAX=IMTAN(inúmero)\n"
#~ "@DESCRIPTION=IMTAN devolve a tangente de um número complexo.\n"
#~ "\n"
#~ "* Se @inúmero não for um número complexo válido, IMTAN devolve o erro "
#~ "#VALOR!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMTAN(\"2-j\") igual a -0.2434582-1.1667363j.\n"
#~ "\n"
#~ "@SEEALSO=IMSIN,IMCOS"

#~ msgid ""
#~ "@FUNCTION=IMSEC\n"
#~ "@SYNTAX=IMSEC(inumber)\n"
#~ "@DESCRIPTION=IMSEC returns the complex secant of the complex number z "
#~ "(@inumber), where\n"
#~ "\n"
#~ "\tsec(z) = 1/cos(z).\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMSEC returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMSEC(\"2-j\") equals -0.413149-0.687527j.\n"
#~ "\n"
#~ "@SEEALSO=IMCSC,IMCOT"
#~ msgstr ""
#~ "@FUNCTION=IMSEC\n"
#~ "@SYNTAX=IMSEC(inúmero)\n"
#~ "@DESCRIPTION=IMSEC devolve a secante complexa do número complexo z "
#~ "(@inúmero), onde.\n"
#~ "\n"
#~ "\tsec(z) = 1/cos(z).\n"
#~ "\n"
#~ "* Se @inúmero não for um número complexo válido, IMSEC devolve o erro "
#~ "#VALOR!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMSEC(\"2-j\") igual a -0.413149-0.687527j.\n"
#~ "\n"
#~ "@SEEALSO=IMCSC,IMCOT"

#~ msgid ""
#~ "@FUNCTION=IMCSC\n"
#~ "@SYNTAX=IMCSC(inumber)\n"
#~ "@DESCRIPTION=IMCSC returns the complex cosecant of the complex number z "
#~ "(@inumber), where\n"
#~ "\n"
#~ "\tcsc(z) = 1/sin(z).\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMCSC returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMCSC(\"2-j\") equals 0.635494-0.221501j.\n"
#~ "\n"
#~ "@SEEALSO=IMSEC,IMCOT"
#~ msgstr ""
#~ "@FUNCTION=IMCSC\n"
#~ "@SYNTAX=IMCSC(inúmero)\n"
#~ "@DESCRIPTION=IMCSC devolve a cosecante complexa do número complexo z "
#~ "(@inúmero) onde\n"
#~ "\n"
#~ "\tcsc(z) = 1/sin(z).\n"
#~ "\n"
#~ "* Se @inúmero não for um número complexo válido, IMCSC devolve o erro "
#~ "#VALOR!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMCSC(\"2-j\") igual a 0.635494-0.221501j.\n"
#~ "\n"
#~ "@SEEALSO=IMSEC,IMCOT"

#~ msgid ""
#~ "@FUNCTION=IMCOT\n"
#~ "@SYNTAX=IMCOT(inumber)\n"
#~ "@DESCRIPTION=IMCOT returns the complex cotangent of the complex number z "
#~ "(@inumber), where\n"
#~ "\n"
#~ "\tcot(z) = 1/tan(z).\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMCOT returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMCOT(\"2-j\") equals -0.171384+0.821330j.\n"
#~ "\n"
#~ "@SEEALSO=IMSEC,IMCSC"
#~ msgstr ""
#~ "@FUNCTION=IMCOT\n"
#~ "@SYNTAX=IMCOT(inúmero)\n"
#~ "@DESCRIPTION=IMCOT devolve a cotangente complexa do número complexo z "
#~ "(@inúmero), onde\n"
#~ "\n"
#~ "\tcot(z) = 1/tan(z).\n"
#~ "\n"
#~ "* Se @inúmero não for um número complexo válido, IMCOT devolve o erro "
#~ "#VALOR!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMCOT(\"2-j\") igual a -0.171384+0.821330j.\n"
#~ "\n"
#~ "@SEEALSO=IMSEC,IMCSC"

#~ msgid ""
#~ "@FUNCTION=IMEXP\n"
#~ "@SYNTAX=IMEXP(inumber)\n"
#~ "@DESCRIPTION=IMEXP returns the exponential of a complex number.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMEXP returns #VALUE! "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMEXP(\"2-j\") equals 3.992324-6.217676j.\n"
#~ "\n"
#~ "@SEEALSO=IMLN"
#~ msgstr ""
#~ "@FUNCTION=IMEXP\n"
#~ "@SYNTAX=IMEXP(inúmero)\n"
#~ "@DESCRIPTION=IMEXP devolve o exponencial de um número complexo.\n"
#~ "\n"
#~ "* Se @inúmero não for um número complexo válido, IMEXP devolve o erro "
#~ "#VALOR!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMEXP(\"2-j\") igual a 3.992324-6.217676j.\n"
#~ "\n"
#~ "@SEEALSO=IMLN"

#~ msgid ""
#~ "@FUNCTION=IMARGUMENT\n"
#~ "@SYNTAX=IMARGUMENT(inumber)\n"
#~ "@DESCRIPTION=IMARGUMENT returns the argument theta of a complex number, i."
#~ "e. the angle in radians from the real axis to the representation of the "
#~ "number in polar coordinates.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMARGUMENT returns #VALUE! "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARGUMENT(\"2-j\") equals -0.463647609.\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=IMARGUMENT\n"
#~ "@SYNTAX=IMARGUMENT(inúmero)\n"
#~ "@DESCRIPTION=IMARGUMENT devolve o argumento theta de um número complexo, "
#~ "por ex. o ângulo em radianos do eixo real até à representação do número "
#~ "em coordenadas polares.\n"
#~ "\n"
#~ "* Se @inúmero não for um número complexo válido, IMARGUMENT devolve o "
#~ "erro #VALOR!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARGUMENT(\"2-j\") igual a -0.463647609.\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=IMLN\n"
#~ "@SYNTAX=IMLN(inumber)\n"
#~ "@DESCRIPTION=IMLN returns the natural logarithm of a complex number.\n"
#~ "\n"
#~ "The result will have an imaginary part between -pi and +pi.  The natural "
#~ "logarithm is not uniquely defined on complex numbers. You may need to add "
#~ "or subtract an even multiple of pi to the imaginary part.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMLN returns #VALUE! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMLN(\"3-j\") equals 1.15129-0.32175j.\n"
#~ "\n"
#~ "@SEEALSO=IMEXP,IMLOG2,IMLOG10"
#~ msgstr ""
#~ "@FUNCTION=IMLN\n"
#~ "@SYNTAX=IMLN(inúmero)\n"
#~ "@DESCRIPTION=IMLN devolve o logaritmo natural de um número complexo.\n"
#~ "\n"
#~ "O resultado terá uma parte imaginária entre -pi e +pi. O logaritmo "
#~ "natural não é definido de forma única em números complexos. Poderá ter de "
#~ "adicionar ou subtrair um múltiplo par de pi à parte imaginária.\n"
#~ "\n"
#~ "* Se @inúmero não for um número complexo válido, IMLN devolve o erro "
#~ "#VALOR!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMLN(\"3-j\") igual a 1.15129-0.32175j.\n"
#~ "\n"
#~ "@SEEALSO=IMEXP,IMLOG2,IMLOG10"

#~ msgid ""
#~ "@FUNCTION=IMLOG2\n"
#~ "@SYNTAX=IMLOG2(inumber)\n"
#~ "@DESCRIPTION=IMLOG2 returns the logarithm of a complex number in base 2.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMLOG2 returns #VALUE! "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMLOG2(\"3-j\") equals 1.66096-0.46419j.\n"
#~ "\n"
#~ "@SEEALSO=IMLN,IMLOG10"
#~ msgstr ""
#~ "@FUNCTION=IMLOG2\n"
#~ "@SYNTAX=IMLOG2(inúmero)\n"
#~ "@DESCRIPTION=IMLOG2 devolve o logaritmo de um número complexo na base 2.\n"
#~ "\n"
#~ "* Se @inúmero não for um número complexo válido, IMLOG2 devolve o erro "
#~ "#VALOR!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMLOG2(\"3-j\") igual a 1.66096-0.46419j.\n"
#~ "\n"
#~ "@SEEALSO=IMLN,IMLOG10"

#~ msgid ""
#~ "@FUNCTION=IMLOG10\n"
#~ "@SYNTAX=IMLOG10(inumber)\n"
#~ "@DESCRIPTION=IMLOG10 returns the logarithm of a complex number in base "
#~ "10.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMLOG10 returns #VALUE! "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMLOG10(\"3-j\") equals 0.5-0.13973j.\n"
#~ "\n"
#~ "@SEEALSO=IMLN,IMLOG2"
#~ msgstr ""
#~ "@FUNCTION=IMLOG10\n"
#~ "@SYNTAX=IMLOG10(inúmero)\n"
#~ "@DESCRIPTION=IMLOG10 devolve o logaritmo de um número complexo na base "
#~ "10.\n"
#~ "\n"
#~ "* Se @inúmero não for um número complexo válido, IMLOG10 devolve o erro "
#~ "#VALOR!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMLOG10(\"3-j\") igual a 0.5-0.13973j.\n"
#~ "\n"
#~ "@SEEALSO=IMLN,IMLOG2"

#~ msgid ""
#~ "@FUNCTION=IMPOWER\n"
#~ "@SYNTAX=IMPOWER(inumber1,inumber2)\n"
#~ "@DESCRIPTION=IMPOWER returns a complex number raised to a power.  "
#~ "@inumber1 is the complex number to be raised to a power and @inumber2 is "
#~ "the power to which you want to raise it.\n"
#~ "\n"
#~ "* If @inumber1 or @inumber2 are not valid complex numbers, IMPOWER "
#~ "returns #VALUE! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMPOWER(\"4-j\",2) equals 15-8j.\n"
#~ "\n"
#~ "@SEEALSO=IMSQRT"
#~ msgstr ""
#~ "@FUNCTION=IMPOWER\n"
#~ "@SYNTAX=IMPOWER(inúmero1,inúmero2)\n"
#~ "@DESCRIPTION=IMPOWER devolve um número complexo elevado a uma potência. "
#~ "@inúmero1 é o número complexo a ser elevado a uma potência e @inúmero2 é "
#~ "a potência a que se quer elevar o número.\n"
#~ "\n"
#~ "* Se @inúmero1 ou @inúmero2 não forem números complexos válidos, IMPOWER "
#~ "devolve o erro #VALOR!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMPOWER(\"4-j\",2) igual a 15-8j.\n"
#~ "\n"
#~ "@SEEALSO=IMSQRT"

#~ msgid ""
#~ "@FUNCTION=IMDIV\n"
#~ "@SYNTAX=IMDIV(inumber1,inumber2)\n"
#~ "@DESCRIPTION=IMDIV returns the quotient of two complex numbers.\n"
#~ "\n"
#~ "* If @inumber1 or @inumber2 are not valid complex numbers, IMDIV returns "
#~ "#VALUE! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMDIV(\"2-j\",\"2+j\") equals 0.6-0.8j.\n"
#~ "\n"
#~ "@SEEALSO=IMPRODUCT"
#~ msgstr ""
#~ "@FUNCTION=IMDIV\n"
#~ "@SYNTAX=IMDIV(inúmero1,inúmero2)\n"
#~ "@DESCRIPTION=IMDIV devolve o quociente de dois números complexos.\n"
#~ "\n"
#~ "* Se @inúmero1 ou @inúmero2 não forem números complexos válidos, IMDIV "
#~ "devolve o erro #VALOR!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMDIV(\"2-j\",\"2+j\") igual a 0.6-0.8j.\n"
#~ "\n"
#~ "@SEEALSO=IMPRODUCT"

#~ msgid ""
#~ "@FUNCTION=IMSIN\n"
#~ "@SYNTAX=IMSIN(inumber)\n"
#~ "@DESCRIPTION=IMSIN returns the sine of a complex number.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMSIN returns #VALUE! "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMSIN(\"1+j\") equals 1.29846+0.63496j.\n"
#~ "\n"
#~ "@SEEALSO=IMCOS,IMTAN"
#~ msgstr ""
#~ "@FUNCTION=IMSIN\n"
#~ "@SYNTAX=IMSIN(inúmero)\n"
#~ "@DESCRIPTION=IMSIN devolve o seno de um número complexo.\n"
#~ "\n"
#~ "* Se @inúmero não for um número complexo válido, IMSIN devolve o erro "
#~ "#VALOR!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMSIN(\"1+j\") igual a 1.29846+0.63496j.\n"
#~ "\n"
#~ "@SEEALSO=IMCOS,IMTAN"

#~ msgid ""
#~ "@FUNCTION=IMSINH\n"
#~ "@SYNTAX=IMSINH(inumber)\n"
#~ "@DESCRIPTION=IMSINH returns the complex hyperbolic sine of the complex "
#~ "number z (@inumber), where\n"
#~ "\n"
#~ "\tsinh(z) = (exp(z) - exp(-z))/2.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMSINH returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMSINH(\"1+j\") equals 0.63496+1.29846j.\n"
#~ "\n"
#~ "@SEEALSO=IMCOSH,IMTANH"
#~ msgstr ""
#~ "@FUNCTION=IMSINH\n"
#~ "@SYNTAX=IMSINH(inúmero)\n"
#~ "@DESCRIPTION=IMSINH devolve o seno hiperbólico complexo do número "
#~ "complexo z (@inúmero), onde\n"
#~ "\n"
#~ "\tsinh(z) = (exp(z) - exp(-z))/2.\n"
#~ "\n"
#~ "* Se @inúmero não for um número complexo válido, IMSINH devolve o erro "
#~ "#VALOR!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMSINH(\"1+j\") igual a 0.63496+1.29846j.\n"
#~ "\n"
#~ "@SEEALSO=IMCOSH,IMTANH"

#~ msgid ""
#~ "@FUNCTION=IMCOSH\n"
#~ "@SYNTAX=IMCOSH(inumber)\n"
#~ "@DESCRIPTION=IMCOSH returns the complex hyperbolic cosine of the complex "
#~ "number z (@inumber), where\n"
#~ "\n"
#~ "\tcosh(z) = (exp(z) + exp(-z))/2.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMCOSH returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMCOSH(\"1+j\") equals 0.83373+0.988898j.\n"
#~ "\n"
#~ "@SEEALSO=IMSINH,IMTANH"
#~ msgstr ""
#~ "@FUNCTION=IMCOSH\n"
#~ "@SYNTAX=IMCOSH(inúmero)\n"
#~ "@DESCRIPTION=IMCOSH devolve o coseno hiperbólico complexo de um número "
#~ "complexo z (@inúmero), onde\n"
#~ "\n"
#~ "\tcosh(z) = (exp(z) + exp(-z))/2.\n"
#~ "\n"
#~ "* Se @inúmero não for um número complexo válido, IMCOSH devolve o erro "
#~ "#VALOR!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMCOSH(\"1+j\") igual a 0.83373+0.988898j.\n"
#~ "\n"
#~ "@SEEALSO=IMSINH,IMTANH"

#~ msgid ""
#~ "@FUNCTION=IMTANH\n"
#~ "@SYNTAX=IMTANH(inumber)\n"
#~ "@DESCRIPTION=IMTANH returns the complex hyperbolic tangent of the complex "
#~ "number z (@inumber), where\n"
#~ "\n"
#~ "\ttanh(z) = sinh(z)/cosh(z).\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMTANH returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMTANH(\"1+j\") equals 1.083923+0.2717526j.\n"
#~ "\n"
#~ "@SEEALSO=IMSINH,IMCOSH"
#~ msgstr ""
#~ "@FUNCTION=IMTANH\n"
#~ "@SYNTAX=IMTANH(inúmero)\n"
#~ "@DESCRIPTION=IMTANH devolve a tangente hiperbólica complexa de um número "
#~ "complexo z (@inúmero), onde\n"
#~ "\n"
#~ "\ttanh(z) = sinh(z)/cosh(z).\n"
#~ "\n"
#~ "* Se @inúmero não for um número complexo válido, IMTANH devolve o erro "
#~ "#VALOR!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMTANH(\"1+j\") igual a 1.083923+0.2717526j.\n"
#~ "\n"
#~ "@SEEALSO=IMSINH,IMCOSH"

#~ msgid ""
#~ "@FUNCTION=IMSECH\n"
#~ "@SYNTAX=IMSECH(inumber)\n"
#~ "@DESCRIPTION=IMSECH returns the complex hyperbolic secant of the complex "
#~ "number z (@inumber), where\n"
#~ "\n"
#~ "\tsech(z) = 1/cosh(z).\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMSECH returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMSECH(\"1+j\") equals 0.498337-0.5910838j.\n"
#~ "\n"
#~ "@SEEALSO=IMCSCH,IMCOTH"
#~ msgstr ""
#~ "@FUNCTION=IMSECH\n"
#~ "@SYNTAX=IMSECH(inúmero)\n"
#~ "@DESCRIPTION=IMSECH devolve a secante hiperbólica complexa de um número "
#~ "complexo z (@inúmero), onde\n"
#~ "\n"
#~ "\tsech(z) = 1/cosh(z).\n"
#~ "\n"
#~ "* Se @inúmero não for um número complexo válido, IMSECH devolve o erro "
#~ "#VALOR!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMSECH(\"1+j\") igual a 0.498337-0.5910838j.\n"
#~ "\n"
#~ "@SEEALSO=IMCSCH,IMCOTH"

#~ msgid ""
#~ "@FUNCTION=IMCSCH\n"
#~ "@SYNTAX=IMCSCH(inumber)\n"
#~ "@DESCRIPTION=IMCSCH returns the complex hyperbolic cosecant of the "
#~ "complex number z (@inumber), where\n"
#~ "\n"
#~ "\tcsch(z) = 1/sinh(z).\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMCSCH returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMCSCH(\"1+j\") equals 0.303931-0.621518j.\n"
#~ "\n"
#~ "@SEEALSO=IMSECH,IMCOTH"
#~ msgstr ""
#~ "@FUNCTION=IMCSCH\n"
#~ "@SYNTAX=IMCSCH(inúmero)\n"
#~ "@DESCRIPTION=IMCSCH devolve a cosecante hiperbólica complexa de um número "
#~ "complexo z (@inúmero), onde\n"
#~ "\n"
#~ "\tcsch(z) = 1/sinh(z).\n"
#~ "\n"
#~ "* Se @inúmero não for um número complexo válido, IMCSCH devolve o erro "
#~ "#VALOR!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMCSCH(\"1+j\") igual a 0.303931-0.621518j.\n"
#~ "\n"
#~ "@SEEALSO=IMSECH,IMCOTH"

#~ msgid ""
#~ "@FUNCTION=IMCOTH\n"
#~ "@SYNTAX=IMCOTH(inumber)\n"
#~ "@DESCRIPTION=IMCOTH returns the complex hyperbolic cotangent of the "
#~ "complex number z (@inumber) where,\n"
#~ "\n"
#~ "\tcoth(z) = 1/tanh(z).\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMCOTH returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMCOTH(\"1+j\") equals 0.868014-0.217622j.\n"
#~ "\n"
#~ "@SEEALSO=IMSECH,IMCSCH"
#~ msgstr ""
#~ "@FUNCTION=IMCOTH\n"
#~ "@SYNTAX=IMCOTH(inúmero)\n"
#~ "@DESCRIPTION=IMCOTH devolve a cotangente hiperbólica complexa de um "
#~ "número complexo z (@inúmero), onde\n"
#~ "\n"
#~ "\tcoth(z) = 1/tanh(z).\n"
#~ "\n"
#~ "* Se @inúmero não for um número complexo válido, IMCOTH devolve o erro "
#~ "#VALOR!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMCOTH(\"1+j\") igual a 0.868014-0.217622j.\n"
#~ "\n"
#~ "@SEEALSO=IMSECH,IMCSCH"

#~ msgid ""
#~ "@FUNCTION=IMARCSIN\n"
#~ "@SYNTAX=IMARCSIN(inumber)\n"
#~ "@DESCRIPTION=IMARCSIN returns the complex arcsine of the complex number "
#~ "@inumber. The branch cuts are on the real axis, less than -1 and greater "
#~ "than 1.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMARCSIN returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCSIN(\"1+j\") equals 0.6662394+1.061275j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCCOS,IMARCTAN"
#~ msgstr ""
#~ "@FUNCTION=IMARCSIN\n"
#~ "@SYNTAX=IMARCSIN(inúmero)\n"
#~ "@DESCRIPTION=IMARCSIN devolve o arco-seno complexo do número complexo "
#~ "@inúmero. Os cortes de ramo são no eixo real, menor que -1 e maior que "
#~ "1.\n"
#~ "\n"
#~ "* Se @inúmero não for um número complexo válido, IMARCSIN devolve o erro "
#~ "#VALOR!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCSIN(\"1+j\") igual a 0.6662394+1.061275j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCCOS,IMARCTAN"

#~ msgid ""
#~ "@FUNCTION=IMARCCOS\n"
#~ "@SYNTAX=IMARCCOS(inumber)\n"
#~ "@DESCRIPTION=IMARCCOS returns the complex arccosine of the complex number "
#~ "@inumber. The branch cuts are on the real axis, less than -1 and greater "
#~ "than 1.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMARCCOS returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCCOS(\"1+j\") equals 0.9045569-1.061275j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCSIN,IMARCTAN"
#~ msgstr ""
#~ "@FUNCTION=IMARCCOS\n"
#~ "@SYNTAX=IMARCCOS(inúmero)\n"
#~ "@DESCRIPTION=IMARCCOS devolve o arco-coseno complexo do número complexo "
#~ "@inúmero. Os cortes de ramo são no eixo real, menor que -1 e maior que "
#~ "1.\n"
#~ "\n"
#~ "* Se @inúmero não for um número complexo válido, IMARCCOS devolve o erro "
#~ "#VALOR!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCCOS(\"1+j\") igual a 0.9045569-1.061275j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCSIN,IMARCTAN"

#~ msgid ""
#~ "@FUNCTION=IMARCTAN\n"
#~ "@SYNTAX=IMARCTAN(inumber)\n"
#~ "@DESCRIPTION=IMARCTAN returns the complex arctangent of the complex "
#~ "number @inumber. The branch cuts are on the imaginary axis, below -i and "
#~ "above i.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMARCTAN returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCTAN(\"1+j\") equals 1.0172220+0.4023595j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCSIN,IMARCCOS"
#~ msgstr ""
#~ "@FUNCTION=IMARCTAN\n"
#~ "@SYNTAX=IMARCTAN(inúmero)\n"
#~ "@DESCRIPTION=IMARCTAN devolve o arco-tangente complexo do número complexo "
#~ "@inúmero. Os cortes de ramo são no eixo imaginário, abaixo de -i e acima "
#~ "i.\n"
#~ "\n"
#~ "* Se @inúmero não for um número complexo válido, IMARCTAN devolve o erro "
#~ "#VALOR!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCTAN(\"1+j\") igual a 1.0172220+0.4023595j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCSIN,IMARCCOS"

#~ msgid ""
#~ "@FUNCTION=IMARCSEC\n"
#~ "@SYNTAX=IMARCSEC(inumber)\n"
#~ "@DESCRIPTION=IMARCSEC returns the complex arcsecant of the complex number "
#~ "z (@inumber), where\n"
#~ "\n"
#~ "\tarcsec(z) = arccos(1/z).\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMARCSEC returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCSEC(\"1+j\") equals 1.1185179+0.5306375j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCCSC,IMARCCOT"
#~ msgstr ""
#~ "@FUNCTION=IMARCSEC\n"
#~ "@SYNTAX=IMARCSEC(inúmero)\n"
#~ "@DESCRIPTION=IMARCSEC devolve o arco-secante complexo do número complexo "
#~ "z (@inúmero), onde\n"
#~ "\n"
#~ "\tarcsec(z) = arccos(1/z).\n"
#~ "\n"
#~ "* Se @inúmero não for um número complexo válido, IMARCSEC devolve o erro "
#~ "#VALOR!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCSEC(\"1+j\") igual a 1.1185179+0.5306375j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCCSC,IMARCCOT"

#~ msgid ""
#~ "@FUNCTION=IMARCCSC\n"
#~ "@SYNTAX=IMARCCSC(inumber)\n"
#~ "@DESCRIPTION=IMARCCSC returns the complex arccosecant of the complex "
#~ "number z (@inumber), where\n"
#~ "\n"
#~ "\tarccsc(z) = arcsin(1/z).\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMARCCSC returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCCSC(\"1+j\") equals 0.45227845-0.5306375j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCSEC,IMARCCOT"
#~ msgstr ""
#~ "@FUNCTION=IMARCCSC\n"
#~ "@SYNTAX=IMARCCSC(inúmero)\n"
#~ "@DESCRIPTION=IMARCCSC devolve o arco-cosecante complexo do número "
#~ "complexo z (@inúmero), onde\n"
#~ "\n"
#~ "\tarccsc(z) = arcsin(1/z).\n"
#~ "\n"
#~ "* Se @inúmero não for um número complexo válido, IMARCCSC devolve o erro "
#~ "#VALOR!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCCSC(\"1+j\") igual a 0.45227845-0.5306375j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCSEC,IMARCCOT"

#~ msgid ""
#~ "@FUNCTION=IMARCCOT\n"
#~ "@SYNTAX=IMARCCOT(inumber)\n"
#~ "@DESCRIPTION=IMARCCOT returns the complex arccotangent of the complex "
#~ "number z (@inumber), where\n"
#~ "\n"
#~ "\tarccot(z) = arctan(1/z).\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMARCCOT returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCCOT(\"1+j\") equals 0.553574+0.4023595j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCSEC,IMARCCSC"
#~ msgstr ""
#~ "@FUNCTION=IMARCCOT\n"
#~ "@SYNTAX=IMARCCOT(inúmero)\n"
#~ "@DESCRIPTION=IMARCCOT devolve o arco-cotangente complexo do número "
#~ "complexo z (@inúmero), onde\n"
#~ "\n"
#~ "\tarccot(z) = arctan(1/z).\n"
#~ "\n"
#~ "* Se @inúmero não for um número complexo válido, IMARCCOT devolve o erro "
#~ "#VALOR!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCCOT(\"1+j\") igual a 0.553574+0.4023595j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCSEC,IMARCCSC"

#~ msgid ""
#~ "@FUNCTION=IMARCSINH\n"
#~ "@SYNTAX=IMARCSINH(inumber)\n"
#~ "@DESCRIPTION=IMARCSINH returns the complex hyperbolic arcsine of the "
#~ "complex number @inumber. The branch cuts are on the imaginary axis, below "
#~ "-i and above i.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMARCSINH returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCSINH(\"1+j\") equals 1.061275+0.6662394j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCCOSH,IMARCTANH"
#~ msgstr ""
#~ "@FUNCTION=IMARCSINH\n"
#~ "@SYNTAX=IMARCSINH(inúmero)\n"
#~ "@DESCRIPTION=IMARCSINH devolve o arco-seno hiperbólico complexo do número "
#~ "complexo @inúmero. Os cortes de ramo são no eixo imaginário, abaixo de -i "
#~ "e acima i.\n"
#~ "\n"
#~ "* Se @inúmero não for um número complexo válido, IMARCSINH devolve o erro "
#~ "#VALOR!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCSINH(\"1+j\") igual a 1.061275+0.6662394j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCCOSH,IMARCTANH"

#~ msgid ""
#~ "@FUNCTION=IMARCCOSH\n"
#~ "@SYNTAX=IMARCCOSH(inumber)\n"
#~ "@DESCRIPTION=IMARCCOSH returns the complex hyperbolic arccosine of the "
#~ "complex number @inumber. The branch cut is on the real axis, less than "
#~ "1.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMARCCOSH returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCCOSH(\"1+j\") equals 1.06127506+0.904557j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCSINH,IMARCTANH"
#~ msgstr ""
#~ "@FUNCTION=IMARCCOSH\n"
#~ "@SYNTAX=IMARCCOSH(inúmero)\n"
#~ "@DESCRIPTION=IMARCCOSH devolve o arco-coseno hiperbólico complexo do "
#~ "número complexo @inúmero. O corte de ramo é feito no eixo real, menor que "
#~ "1.\n"
#~ "\n"
#~ "* Se @inúmero não for um número complexo válido, IMARCCOSH devolve o erro "
#~ "#VALOR!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCCOSH(\"1+j\") igual a 1.06127506+0.904557j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCSINH,IMARCTANH"

#~ msgid ""
#~ "@FUNCTION=IMARCTANH\n"
#~ "@SYNTAX=IMARCTANH(inumber)\n"
#~ "@DESCRIPTION=IMARCTANH returns the complex hyperbolic arctangent of the "
#~ "complex number @inumber. The branch cuts are on the real axis, less than "
#~ "-1 and greater than 1.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMARCTANH returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCTANH(\"1+j\") equals 0.4023595+1.0172220j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCSINH,IMARCCOSH"
#~ msgstr ""
#~ "@FUNCTION=IMARCTANH\n"
#~ "@SYNTAX=IMARCTANH(inúmero)\n"
#~ "@DESCRIPTION=IMARCTANH devolve o arco-tangente hiperbólico complexo do "
#~ "número complexo @inúmero. Os cortes de ramo são feitos no eixo real, "
#~ "menor que -1 e maior do que 1.\n"
#~ "\n"
#~ "* Se @inúmero não for um número complexo válido, IMARCTANH devolve o erro "
#~ "#VALOR!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCTANH(\"1+j\") igual a 0.4023595+1.0172220j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCSINH,IMARCCOSH"

#~ msgid ""
#~ "@FUNCTION=IMARCSECH\n"
#~ "@SYNTAX=IMARCSECH(inumber)\n"
#~ "@DESCRIPTION=IMARCSECH returns the complex hyperbolic arcsecant of the "
#~ "complex number z (@inumber), where\n"
#~ "\n"
#~ "\tarcsech(z) = arccosh(1/z).\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMARCSECH returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCSECH(\"1+j\") equals 0.5306375-1.118518j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCCSCH,IMARCCOTH"
#~ msgstr ""
#~ "@FUNCTION=IMARCSECH\n"
#~ "@SYNTAX=IMARCSECH(inúmero)\n"
#~ "@DESCRIPTION=IMARCSECH devolve a arco-secante hiperbólica complexa do "
#~ "número complexo z (@inúmero), onde\n"
#~ "\n"
#~ "\tarcsech(z) = arccosh(1/z).\n"
#~ "\n"
#~ "* Se @inúmero não for um número complexo válido, IMARCSECH devolve o erro "
#~ "#VALOR!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCSECH(\"1+j\") igual a 0.5306375-1.118518j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCCSCH,IMARCCOTH"

#~ msgid ""
#~ "@FUNCTION=IMARCCSCH\n"
#~ "@SYNTAX=IMARCCSCH(inumber)\n"
#~ "@DESCRIPTION=IMARCCSCH returns the complex hyperbolic arccosecant of the "
#~ "complex number z (@inumber), where\n"
#~ "\n"
#~ "\tarccsch(z) = arcsinh(1/z).\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMARCCSCH returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCCSCH(\"1+j\") equals 0.5306375-0.452278j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCSECH,IMARCCOTH"
#~ msgstr ""
#~ "@FUNCTION=IMARCCSCH\n"
#~ "@SYNTAX=IMARCCSCH(inúmero)\n"
#~ "@DESCRIPTION=IMARCCSCH devolve a arco-cosecante hiperbólica complexa do "
#~ "número complexo z (@inúmero), onde\n"
#~ "\n"
#~ "\tarccsch(z) = arcsinh(1/z).\n"
#~ "\n"
#~ "* Se @inúmero não for um número complexo válido, IMARCCSCH devolve o erro "
#~ "#VALOR!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCCSCH(\"1+j\") igual a 0.5306375-0.452278j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCSECH,IMARCCOTH"

#~ msgid ""
#~ "@FUNCTION=IMARCCOTH\n"
#~ "@SYNTAX=IMARCCOTH(inumber)\n"
#~ "@DESCRIPTION=IMARCCOTH returns the complex hyperbolic arccotangent of the "
#~ "complex number z (@inumber), where\n"
#~ "\n"
#~ "\tarccoth(z) = arctanh(1/z).\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMARCCOTH returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCCOTH(\"1+j\") equals 0.40235948-0.5535744j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCSECH,IMARCCSCH"
#~ msgstr ""
#~ "@FUNCTION=IMARCCOTH\n"
#~ "@SYNTAX=IMARCCOTH(inúmero)\n"
#~ "@DESCRIPTION=IMARCCOTH devolve a arco-cotangente hiperbólica complexa do "
#~ "número complexo z (@inúmero), onde\n"
#~ "\n"
#~ "\tarccoth(z) = arctanh(1/z).\n"
#~ "\n"
#~ "* Se @inúmero não for um número complexo válido, IMARCCOTH devolve o erro "
#~ "#VALOR!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCCOTH(\"1+j\") igual a 0.40235948-0.5535744j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCSECH,IMARCCSCH"

#~ msgid ""
#~ "@FUNCTION=IMSQRT\n"
#~ "@SYNTAX=IMSQRT(inumber)\n"
#~ "@DESCRIPTION=IMSQRT returns the square root of a complex number.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMSQRT returns #VALUE! "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMSQRT(\"1+j\") equals 1.09868+0.4550899j.\n"
#~ "\n"
#~ "@SEEALSO=IMPOWER"
#~ msgstr ""
#~ "@FUNCTION=IMSQRT\n"
#~ "@SYNTAX=IMSQRT(inúmero)\n"
#~ "@DESCRIPTION=IMSQRT devolve a raiz quadrada de um número complexo.\n"
#~ "\n"
#~ "* Se @inúmero não for um número complexo válido, IMSQRT devolve o erro "
#~ "#VALOR!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMSQRT(\"1+j\") igual a 1.09868+0.4550899j.\n"
#~ "\n"
#~ "@SEEALSO=IMPOWER"

#~ msgid ""
#~ "@FUNCTION=IMSUB\n"
#~ "@SYNTAX=IMSUB(inumber1,inumber2)\n"
#~ "@DESCRIPTION=IMSUB returns the difference of two complex numbers.\n"
#~ "\n"
#~ "* If @inumber1 or @inumber2 are not valid complex numbers, IMSUB returns "
#~ "#VALUE! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMSUB(\"3-j\",\"2+j\") equals 1-2j.\n"
#~ "\n"
#~ "@SEEALSO=IMSUM"
#~ msgstr ""
#~ "@FUNCTION=IMSUB\n"
#~ "@SYNTAX=IMSUB(inúmero1,inúmero2)\n"
#~ "@DESCRIPTION=IMSUB devolve a diferença entre dois números complexos.\n"
#~ "\n"
#~ "* Se @inúmero1 ou @inúmero2 não forem números complexos válidos, IMSUB "
#~ "devolve o erro #VALOR!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMSUB(\"3-j\",\"2+j\") igual a 1-2j.\n"
#~ "\n"
#~ "@SEEALSO=IMSUM"

#~ msgid ""
#~ "@FUNCTION=IMPRODUCT\n"
#~ "@SYNTAX=IMPRODUCT(inumber1[,inumber2,...])\n"
#~ "@DESCRIPTION=IMPRODUCT returns the product of given complex numbers.\n"
#~ "\n"
#~ "* If any of the @inumbers are not valid complex numbers, IMPRODUCT "
#~ "returns #VALUE! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMPRODUCT(\"2-j\",\"4-2j\") equals 6-8j.\n"
#~ "\n"
#~ "@SEEALSO=IMDIV"
#~ msgstr ""
#~ "@FUNCTION=IMPRODUCT\n"
#~ "@SYNTAX=IMPRODUCT(inúmero1[,inúmero2,...])\n"
#~ "@DESCRIPTION=IMPRODUCT devolve o produto dos números complexos dados.\n"
#~ "\n"
#~ "* Se qualquer um dos @inúmeros não forem números complexos válidos, "
#~ "IMPRODUCT devolve o erro #VALOR!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMPRODUCT(\"2-j\",\"4-2j\") igual a 6-8j.\n"
#~ "\n"
#~ "@SEEALSO=IMDIV"

#~ msgid ""
#~ "@FUNCTION=IMSUM\n"
#~ "@SYNTAX=IMSUM(inumber1,inumber2)\n"
#~ "@DESCRIPTION=IMSUM returns the sum of two complex numbers.\n"
#~ "\n"
#~ "* If @inumber1 or @inumber2 are not valid complex numbers, IMSUM returns "
#~ "#VALUE! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMSUM(\"2-4j\",\"9-j\") equals 11-5j.\n"
#~ "\n"
#~ "@SEEALSO=IMSUB"
#~ msgstr ""
#~ "@FUNCTION=IMSUM\n"
#~ "@SYNTAX=IMSUM(inúmero1,inúmero2)\n"
#~ "@DESCRIPTION=IMSUM devolve a soma de dois números complexos.\n"
#~ "\n"
#~ "* Se @inúmero1 ou @inúmero2 não forem números complexos válidos, IMSUM "
#~ "devolve o erro #VALOR!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMSUM(\"2-4j\",\"9-j\") igual a 11-5j.\n"
#~ "\n"
#~ "@SEEALSO=IMSUB"

#~ msgid ""
#~ "@FUNCTION=DAVERAGE\n"
#~ "@SYNTAX=DAVERAGE(database,field,criteria)\n"
#~ "@DESCRIPTION=DAVERAGE function returns the average of the values in a "
#~ "list or database that match conditions specified.\n"
#~ "\n"
#~ "@database is a range of cells in which rows of related information are "
#~ "records and columns of data are fields. The first row of a database "
#~ "contains labels for each column. \n"
#~ "\n"
#~ "@field specifies which column is used in the function.  If @field is an "
#~ "integer, for example 2, the second column is used. Field can also be the "
#~ "label of a column.  For example, ``Age'' refers to the column with the "
#~ "label ``Age'' in @database range. \n"
#~ "\n"
#~ "@criteria is the range of cells which contains the specified conditions.  "
#~ "The first row of a @criteria should contain the labels of the fields for "
#~ "which the criteria are for.  Cells below the labels specify conditions, "
#~ "for example, ``>3'' or ``<9''.  Equality condition can be given simply by "
#~ "specifying a value, e.g. ``3'' or ``John''. \n"
#~ "Each row in @criteria specifies a separate condition. If a row in "
#~ "@database matches a row in @criteria, then that row is counted. "
#~ "Technically speaking, this a boolean OR operation between the rows in "
#~ "@criteria.\n"
#~ "If @criteria specifies more than one column, then each of the conditions "
#~ "in the specified columns must be true for the row in @database to match. "
#~ "Technically speaking, this is a boolean AND operation between the columns "
#~ "in @criteria.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the range A1:C7 contain the following values:\n"
#~ "Name    Age     Salary\n"
#~ "John    34      54342\n"
#~ "Bill    35      22343\n"
#~ "Clark   29      34323\n"
#~ "Bob     43      47242\n"
#~ "Susan   37      42932\n"
#~ "Jill    45      45324\n"
#~ "\n"
#~ "In addition, the cells A9:B11 contain the following values:\n"
#~ "Age     Salary\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "DAVERAGE(A1:C7, \"Salary\", A9:A11) equals 42296.3333.\n"
#~ "DAVERAGE(A1:C7, \"Age\", A9:A11) equals 39.\n"
#~ "DAVERAGE(A1:C7, \"Salary\", A9:B11) equals 40782.5.\n"
#~ "DAVERAGE(A1:C7, \"Age\", A9:B11) equals 36.\n"
#~ "\n"
#~ "@SEEALSO=DCOUNT"
#~ msgstr ""
#~ "@FUNCTION=DAVERAGE\n"
#~ "@SYNTAX=DAVERAGE(base_dados,campo,critério)\n"
#~ "@DESCRIPTION=DAVERAGE devolve a média de valores numa lista ou base de "
#~ "dados que cumpra com as condições especificadas.\n"
#~ "\n"
#~ "@base_dados é uma área de células em que linhas de informação relacionada "
#~ "são registos e colunas de dados são campos. A primeira linha de uma base "
#~ "de dados contém as etiquetas de cada coluna. \n"
#~ "\n"
#~ "@campo especifica que coluna é utilizada na função.  Se @campo for um "
#~ "inteiro, por exemplo 2, a segunda coluna é utilizada. Campo também pode "
#~ "ser a etiqueta de uma coluna.  Por exemplo, ``Idade'' refere-se à coluna "
#~ "com a etiqueta ``Idade'' na área @base_dados. \n"
#~ "\n"
#~ "@critério é a área de células que contém as condições especificadas.  A "
#~ "primeira linha de um @critério deverá conter as etiquetas dos campos para "
#~ "os quais se aplicam os critérios.  Células abaixo das etiquetas "
#~ "especificam as condições, por exemplo, ``>3'' ou ``<9''.  Condição de "
#~ "igualdade pode ser dada simplesmente especificando um valor, por ex. "
#~ "``3'' ou ``John''.\n"
#~ "Cada linha em @critério especifica uma condição diferente. Se uma linha "
#~ "em @base_dados equivale a uma linha em @critério, então essa linha é "
#~ "incluida. Tecnicamente falando esta é uma operação boleana OR entre "
#~ "linhas em @critério.\n"
#~ "Se @critério especifica mais do que uma coluna, então cada uma das "
#~ "condições destas colunas tem de ser verdadeiras para que a linha na "
#~ "@base_dados equivalha. Tecnicamente falando, esta é uma operação boleana "
#~ "AND entre as colunas em @critério.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que a área A1:C7 contém os seguintes valores:\n"
#~ "Nome    Idade   Salário\n"
#~ "John    34      54342\n"
#~ "Bill    35      22343\n"
#~ "Clark   29      34323\n"
#~ "Bob     43      47242\n"
#~ "Susan   37      42932\n"
#~ "Jill    45      45324\n"
#~ "\n"
#~ "Além destas, as células A9:B11 contêm os seguintes valores:\n"
#~ "Idade   Salário\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DAVERAGE(A1:C7, \"Salário\", A9:A11) igual a 42296.3333.\n"
#~ "DAVERAGE(A1:C7, \"Idade\", A9:A11) igual a 39.\n"
#~ "DAVERAGE(A1:C7, \"Salário\", A9:B11) igual a 40782.5.\n"
#~ "DAVERAGE(A1:C7, \"Idade\", A9:B11) igual a 36.\n"
#~ "\n"
#~ "@SEEALSO=DCOUNT"

#~ msgid ""
#~ "@FUNCTION=DCOUNT\n"
#~ "@SYNTAX=DCOUNT(database,field,criteria)\n"
#~ "@DESCRIPTION=DCOUNT function counts the cells that contain numbers in a "
#~ "database that match conditions specified.\n"
#~ "\n"
#~ "@database is a range of cells in which rows of related information are "
#~ "records and columns of data are fields. The first row of a database "
#~ "contains labels for each column. \n"
#~ "\n"
#~ "@field specifies which column is used in the function.  If @field is an "
#~ "integer, for example 2, the second column is used. Field can also be the "
#~ "label of a column.  For example, ``Age'' refers to the column with the "
#~ "label ``Age'' in @database range. \n"
#~ "\n"
#~ "@criteria is the range of cells which contains the specified conditions.  "
#~ "The first row of a @criteria should contain the labels of the fields for "
#~ "which the criteria are for.  Cells below the labels specify conditions, "
#~ "for example, ``>3'' or ``<9''.  Equality condition can be given simply by "
#~ "specifying a value, e.g. ``3'' or ``John''. \n"
#~ "Each row in @criteria specifies a separate condition. If a row in "
#~ "@database matches a row in @criteria, then that row is counted. "
#~ "Technically speaking, this a boolean OR operation between the rows in "
#~ "@criteria.\n"
#~ "If @criteria specifies more than one column, then each of the conditions "
#~ "in the specified columns must be true for the row in @database to match. "
#~ "Technically speaking, this is a boolean AND operation between the columns "
#~ "in @criteria.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the range A1:C7 contain the following values:\n"
#~ "Name    Age     Salary\n"
#~ "John    34      54342\n"
#~ "Bill    35      22343\n"
#~ "Clark   29      34323\n"
#~ "Bob     43      47242\n"
#~ "Susan   37      42932\n"
#~ "Jill    45      45324\n"
#~ "\n"
#~ "In addition, the cells A9:B11 contain the following values:\n"
#~ "Age     Salary\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "DCOUNT(A1:C7, \"Salary\", A9:A11) equals 3.\n"
#~ "DCOUNT(A1:C7, \"Salary\", A9:B11) equals 2.\n"
#~ "DCOUNT(A1:C7, \"Name\", A9:B11) equals 0.\n"
#~ "\n"
#~ "@SEEALSO=DAVERAGE"
#~ msgstr ""
#~ "@FUNCTION=DCOUNT\n"
#~ "@SYNTAX=DCOUNT(base_dados,campo,critério)\n"
#~ "@DESCRIPTION=DCOUNT conta as células que contêm números numa base de "
#~ "dados que coincidem com as condições especificadas.\n"
#~ "\n"
#~ "@base_dados é uma área de células em que linhas de informação relacionada "
#~ "são registos e colunas de dados são campos. A primeira linha de uma base "
#~ "de dados contém as etiquetas de cada coluna. \n"
#~ "\n"
#~ "@campo especifica que coluna é utilizada na função.  Se @campo for um "
#~ "inteiro, por exemplo 2, a segunda coluna é utilizada. Campo também pode "
#~ "ser a etiqueta de uma coluna.  Por exemplo, ``Idade'' refere-se à coluna "
#~ "com a etiqueta ``Idade'' na área @base_dados. \n"
#~ "\n"
#~ "@critério é a área de células que contém as condições especificadas.  A "
#~ "primeira linha de um @critério deverá conter as etiquetas dos campos para "
#~ "os quais se aplicam os critérios.  Células abaixo das etiquetas "
#~ "especificam as condições, por exemplo, ``>3'' ou ``<9''.  Condição de "
#~ "igualdade pode ser dada simplesmente especificando um valor, por ex. "
#~ "``3'' ou ``John''.\n"
#~ "Cada linha em @critério especifica uma condição diferente. Se uma linha "
#~ "em @base_dados equivale a uma linha em @critério, então essa linha é "
#~ "incluida.Tecnicamente falando, esta é uma operação boleana OR entre "
#~ "linhas em @critério.\n"
#~ "Se @critério especifica mais do que uma coluna então cada uma das "
#~ "condições destas colunas tem de ser verdadeira para que a linha na "
#~ "@base_dados equivalha. Tecnicamente falando, esta é uma operação boleana "
#~ "AND entre as colunas em @critério.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que a área A1:C7 contém os seguintes valores:\n"
#~ "Nome    Idade   Salário\n"
#~ "John    34      54342\n"
#~ "Bill    35      22343\n"
#~ "Clark   29      34323\n"
#~ "Bob     43      47242\n"
#~ "Susan   37      42932\n"
#~ "Jill    45      45324\n"
#~ "\n"
#~ "Além destas, as células A9:B11 contêm os seguintes valores:\n"
#~ "Idade   Salário\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DCOUNT(A1:C7, \"Salário\", A9:A11) igual a 3.\n"
#~ "DCOUNT(A1:C7, \"Salário\", A9:B11) igual a 2.\n"
#~ "DCOUNT(A1:C7, \"Nome\", A9:B11) igual a 0.\n"
#~ "\n"
#~ "@SEEALSO=DAVERAGE"

#~ msgid ""
#~ "@FUNCTION=DCOUNTA\n"
#~ "@SYNTAX=DCOUNTA(database,field,criteria)\n"
#~ "@DESCRIPTION=DCOUNTA function counts the cells that contain data in a "
#~ "database that match conditions specified.\n"
#~ "\n"
#~ "@database is a range of cells in which rows of related information are "
#~ "records and columns of data are fields. The first row of a database "
#~ "contains labels for each column. \n"
#~ "\n"
#~ "@field specifies which column is used in the function.  If @field is an "
#~ "integer, for example 2, the second column is used. Field can also be the "
#~ "label of a column.  For example, ``Age'' refers to the column with the "
#~ "label ``Age'' in @database range. \n"
#~ "\n"
#~ "@criteria is the range of cells which contains the specified conditions.  "
#~ "The first row of a @criteria should contain the labels of the fields for "
#~ "which the criteria are for.  Cells below the labels specify conditions, "
#~ "for example, ``>3'' or ``<9''.  Equality condition can be given simply by "
#~ "specifying a value, e.g. ``3'' or ``John''. \n"
#~ "Each row in @criteria specifies a separate condition. If a row in "
#~ "@database matches a row in @criteria, then that row is counted. "
#~ "Technically speaking, this a boolean OR operation between the rows in "
#~ "@criteria.\n"
#~ "If @criteria specifies more than one column, then each of the conditions "
#~ "in the specified columns must be true for the row in @database to match. "
#~ "Technically speaking, this is a boolean AND operation between the columns "
#~ "in @criteria.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the range A1:C7 contain the following values:\n"
#~ "Name    Age     Salary\n"
#~ "John    34      54342\n"
#~ "Bill    35      22343\n"
#~ "Clark   29      34323\n"
#~ "Bob     43      47242\n"
#~ "Susan   37      42932\n"
#~ "Jill    45      45324\n"
#~ "\n"
#~ "In addition, the cells A9:B11 contain the following values:\n"
#~ "Age     Salary\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "DCOUNTA(A1:C7, \"Salary\", A9:A11) equals 3.\n"
#~ "DCOUNTA(A1:C7, \"Salary\", A9:B11) equals 2.\n"
#~ "DCOUNTA(A1:C7, \"Name\", A9:B11) equals 2.\n"
#~ "\n"
#~ "@SEEALSO=DCOUNT"
#~ msgstr ""
#~ "@FUNCTION=DCOUNTA\n"
#~ "@SYNTAX=DCOUNTA(base_dados,campo,critério)\n"
#~ "@DESCRIPTION=DCOUNTA conta as células que contêm dados numa base de dados "
#~ "que coincidem com as condições especificadas.\n"
#~ "\n"
#~ "@base_dados é uma área de células em que linhas de informação relacionada "
#~ "são registos e colunas de dados são campos. A primeira linha de uma base "
#~ "de dados contém as etiquetas de cada coluna. \n"
#~ "\n"
#~ "@campo especifica que coluna é utilizada na função.  Se @campo for um "
#~ "inteiro, por exemplo 2, a segunda coluna é utilizada. Campo também pode "
#~ "ser a etiqueta de uma coluna.  Por exemplo, ``Idade'' refere-se à coluna "
#~ "com a etiqueta ``Idade'' na área @base_dados. \n"
#~ "\n"
#~ "@critério é a área de células que contém as condições especificadas.  A "
#~ "primeira linha de um @critério deverá conter as etiquetas dos campos para "
#~ "os quais se aplicam os critérios.  Células abaixo das etiquetas "
#~ "especificam as condições, por exemplo, ``>3'' ou ``<9''.  Condição de "
#~ "igualdade pode ser dada simplesmente especificando um valor, por ex. "
#~ "``3'' ou ``John''.\n"
#~ "Cada linha em @critério especifica uma condição diferente. Se uma linha "
#~ "em @base_dados equivale a uma linha em @critério, então essa linha é "
#~ "incluida.Tecnicamente falando, esta é uma operação boleana OR entre "
#~ "linhas em @critério.\n"
#~ "Se @critério especifica mais do que uma coluna então cada uma das "
#~ "condições destas colunas tem de ser verdadeira para que a linha na "
#~ "@base_dados equivalha. Tecnicamente falando, esta é uma operação boleana "
#~ "AND entre as colunas em @critério.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que a área A1:C7 contém os seguintes valores:\n"
#~ "Nome    Idade   Salário\n"
#~ "John    34      54342\n"
#~ "Bill    35      22343\n"
#~ "Clark   29      34323\n"
#~ "Bob     43      47242\n"
#~ "Susan   37      42932\n"
#~ "Jill    45      45324\n"
#~ "\n"
#~ "Além destas, as células A9:B11 contêm os seguintes valores:\n"
#~ "Idade   Salário\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DCOUNTA(A1:C7, \"Salário\", A9:A11) igual a 3.\n"
#~ "DCOUNTA(A1:C7, \"Salário\", A9:B11) igual a 2.\n"
#~ "DCOUNTA(A1:C7, \"Nome\", A9:B11) igual a 2.\n"
#~ "\n"
#~ "@SEEALSO=DCOUNT"

#~ msgid ""
#~ "@FUNCTION=DGET\n"
#~ "@SYNTAX=DGET(database,field,criteria)\n"
#~ "@DESCRIPTION=DGET function returns a single value from a column that "
#~ "match conditions specified.\n"
#~ "\n"
#~ "@database is a range of cells in which rows of related information are "
#~ "records and columns of data are fields. The first row of a database "
#~ "contains labels for each column. \n"
#~ "\n"
#~ "@field specifies which column is used in the function.  If @field is an "
#~ "integer, for example 2, the second column is used. Field can also be the "
#~ "label of a column.  For example, ``Age'' refers to the column with the "
#~ "label ``Age'' in @database range. \n"
#~ "\n"
#~ "@criteria is the range of cells which contains the specified conditions.  "
#~ "The first row of a @criteria should contain the labels of the fields for "
#~ "which the criteria are for.  Cells below the labels specify conditions, "
#~ "for example, ``>3'' or ``<9''.  Equality condition can be given simply by "
#~ "specifying a value, e.g. ``3'' or ``John''. \n"
#~ "Each row in @criteria specifies a separate condition. If a row in "
#~ "@database matches a row in @criteria, then that row is counted. "
#~ "Technically speaking, this a boolean OR operation between the rows in "
#~ "@criteria.\n"
#~ "If @criteria specifies more than one column, then each of the conditions "
#~ "in the specified columns must be true for the row in @database to match. "
#~ "Technically speaking, this is a boolean AND operation between the columns "
#~ "in @criteria.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the range A1:C7 contain the following values:\n"
#~ "Name    Age     Salary\n"
#~ "John    34      54342\n"
#~ "Bill    35      22343\n"
#~ "Clark   29      34323\n"
#~ "Bob     43      47242\n"
#~ "Susan   37      42932\n"
#~ "Jill    45      45324\n"
#~ "\n"
#~ "In addition, the cells A9:B11 contain the following values:\n"
#~ "Age     Salary\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "* If none of the items match the conditions, DGET returns #VALUE! error.\n"
#~ "* If more than one items match the conditions, DGET returns #NUM! error.\n"
#~ "\n"
#~ "DGET(A1:C7, \"Salary\", A9:A10) equals 34323.\n"
#~ "DGET(A1:C7, \"Name\", A9:A10) equals \"Clark\".\n"
#~ "\n"
#~ "@SEEALSO=DCOUNT"
#~ msgstr ""
#~ "@FUNCTION=DGET\n"
#~ "@SYNTAX=DGET(base_dados,campo,critério)\n"
#~ "@DESCRIPTION=DGET devolve um valor único de uma coluna que coincida com "
#~ "as condições especificadas.\n"
#~ "\n"
#~ "@base_dados é uma área de células em que linhas de informação relacionada "
#~ "são registos e colunas de dados são campos. A primeira linha de uma base "
#~ "de dados contém as etiquetas de cada coluna. \n"
#~ "\n"
#~ "@campo especifica que coluna é utilizada na função.  Se @campo for um "
#~ "inteiro, por exemplo 2, a segunda coluna é utilizada. Campo também pode "
#~ "ser a etiqueta de uma coluna.  Por exemplo, ``Idade'' refere-se à coluna "
#~ "com a etiqueta ``Idade'' na área @base_dados. \n"
#~ "\n"
#~ "@critério é a área de células que contém as condições especificadas.  A "
#~ "primeira linha de um @critério deverá conter as etiquetas dos campos para "
#~ "os quais se aplicam os critérios.  Células abaixo das etiquetas "
#~ "especificam as condições, por exemplo, ``>3'' ou ``<9''.  Condição de "
#~ "igualdade pode ser dada simplesmente especificando um valor, por ex. "
#~ "``3'' ou ``John''.\n"
#~ "Cada linha em @critério especifica uma condição diferente. Se uma linha "
#~ "em @base_dados equivale a uma linha em @critério, então essa linha é "
#~ "incluida.Tecnicamente falando, esta é uma operação boleana OR entre "
#~ "linhas em @critério.\n"
#~ "Se @critério especifica mais do que uma coluna então cada uma das "
#~ "condições destas colunas tem de ser verdadeira para que a linha na "
#~ "@base_dados equivalha. Tecnicamente falando, esta é uma operação boleana "
#~ "AND entre as colunas em @critério.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que a área A1:C7 contém os seguintes valores:\n"
#~ "Nome    Idade   Salário\n"
#~ "John    34      54342\n"
#~ "Bill    35      22343\n"
#~ "Clark   29      34323\n"
#~ "Bob     43      47242\n"
#~ "Susan   37      42932\n"
#~ "Jill    45      45324\n"
#~ "\n"
#~ "Além destas, as células A9:B11 contêm os seguintes valores:\n"
#~ "Idade   Salário\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "* Se nenhum dos itens coincidir com as condições, DGET devolve o erro "
#~ "#VALOR!.\n"
#~ "* Se mais de um item coincidir com as condições, DGET devolve o erro "
#~ "#NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DGET(A1:C7, \"Salário\", A9:A10) igual a 34323.\n"
#~ "DGET(A1:C7, \"Nome\", A9:A10) igual a \"Clark\".\n"
#~ "\n"
#~ "@SEEALSO=DCOUNT"

#~ msgid ""
#~ "@FUNCTION=DMAX\n"
#~ "@SYNTAX=DMAX(database,field,criteria)\n"
#~ "@DESCRIPTION=DMAX function returns the largest number in a column that "
#~ "match conditions specified.\n"
#~ "\n"
#~ "@database is a range of cells in which rows of related information are "
#~ "records and columns of data are fields. The first row of a database "
#~ "contains labels for each column. \n"
#~ "\n"
#~ "@field specifies which column is used in the function.  If @field is an "
#~ "integer, for example 2, the second column is used. Field can also be the "
#~ "label of a column.  For example, ``Age'' refers to the column with the "
#~ "label ``Age'' in @database range. \n"
#~ "\n"
#~ "@criteria is the range of cells which contains the specified conditions.  "
#~ "The first row of a @criteria should contain the labels of the fields for "
#~ "which the criteria are for.  Cells below the labels specify conditions, "
#~ "for example, ``>3'' or ``<9''.  Equality condition can be given simply by "
#~ "specifying a value, e.g. ``3'' or ``John''. \n"
#~ "Each row in @criteria specifies a separate condition. If a row in "
#~ "@database matches a row in @criteria, then that row is counted. "
#~ "Technically speaking, this a boolean OR operation between the rows in "
#~ "@criteria.\n"
#~ "If @criteria specifies more than one column, then each of the conditions "
#~ "in the specified columns must be true for the row in @database to match. "
#~ "Technically speaking, this is a boolean AND operation between the columns "
#~ "in @criteria.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the range A1:C7 contain the following values:\n"
#~ "Name    Age     Salary\n"
#~ "John    34      54342\n"
#~ "Bill    35      22343\n"
#~ "Clark   29      34323\n"
#~ "Bob     43      47242\n"
#~ "Susan   37      42932\n"
#~ "Jill    45      45324\n"
#~ "\n"
#~ "In addition, the cells A9:B11 contain the following values:\n"
#~ "Age     Salary\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "DMAX(A1:C7, \"Salary\", A9:A11) equals 47242.\n"
#~ "DMAX(A1:C7, \"Age\", A9:A11) equals 45.\n"
#~ "DMAX(A1:C7, \"Age\", A9:B11) equals 43.\n"
#~ "\n"
#~ "@SEEALSO=DMIN"
#~ msgstr ""
#~ "@FUNCTION=DMAX\n"
#~ "@SYNTAX=DMAX(base_dados,campo,critério)\n"
#~ "@DESCRIPTION=DMAX devolve o maior número na coluna que coincida com as "
#~ "condições especificadas.\n"
#~ "\n"
#~ "@base_dados é uma área de células em que linhas de informação relacionada "
#~ "são registos e colunas de dados são campos. A primeira linha de uma base "
#~ "de dados contém as etiquetas de cada coluna. \n"
#~ "\n"
#~ "@campo especifica que coluna é utilizada na função.  Se @campo for um "
#~ "inteiro, por exemplo 2, a segunda coluna é utilizada. Campo também pode "
#~ "ser a etiqueta de uma coluna.  Por exemplo, ``Idade'' refere-se à coluna "
#~ "com a etiqueta ``Idade'' na área @base_dados. \n"
#~ "\n"
#~ "@critério é a área de células que contém as condições especificadas.  A "
#~ "primeira linha de um @critério deverá conter as etiquetas dos campos para "
#~ "os quais se aplicam os critérios.  Células abaixo das etiquetas "
#~ "especificam as condições, por exemplo, ``>3'' ou ``<9''.  Condição de "
#~ "igualdade pode ser dada simplesmente especificando um valor, por ex. "
#~ "``3'' ou ``John''.\n"
#~ "Cada linha em @critério especifica uma condição diferente. Se uma linha "
#~ "em @base_dados equivale a uma linha em @critério, então essa linha é "
#~ "incluida.Tecnicamente falando, esta é uma operação boleana OR entre "
#~ "linhas em @critério.\n"
#~ "Se @critério especifica mais do que uma coluna então cada uma das "
#~ "condições destas colunas tem de ser verdadeira para que a linha na "
#~ "@base_dados equivalha. Tecnicamente falando, esta é uma operação boleana "
#~ "AND entre as colunas em @critério.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que a área A1:C7 contém os seguintes valores:\n"
#~ "Nome    Idade   Salário\n"
#~ "John    34      54342\n"
#~ "Bill    35      22343\n"
#~ "Clark   29      34323\n"
#~ "Bob     43      47242\n"
#~ "Susan   37      42932\n"
#~ "Jill    45      45324\n"
#~ "\n"
#~ "Além destas, as células A9:B11 contêm os seguintes valores:\n"
#~ "Idade   Salário\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DMAX(A1:C7, \"Salário\", A9:A11) igual a 47242.\n"
#~ "DMAX(A1:C7, \"Idade\", A9:A11) igual a 45.\n"
#~ "DMAX(A1:C7, \"Idade\", A9:B11) igual a 43.\n"
#~ "\n"
#~ "@SEEALSO=DMIN"

#~ msgid ""
#~ "@FUNCTION=DMIN\n"
#~ "@SYNTAX=DMIN(database,field,criteria)\n"
#~ "@DESCRIPTION=DMIN function returns the smallest number in a column that "
#~ "match conditions specified.\n"
#~ "\n"
#~ "@database is a range of cells in which rows of related information are "
#~ "records and columns of data are fields. The first row of a database "
#~ "contains labels for each column. \n"
#~ "\n"
#~ "@field specifies which column is used in the function.  If @field is an "
#~ "integer, for example 2, the second column is used. Field can also be the "
#~ "label of a column.  For example, ``Age'' refers to the column with the "
#~ "label ``Age'' in @database range. \n"
#~ "\n"
#~ "@criteria is the range of cells which contains the specified conditions.  "
#~ "The first row of a @criteria should contain the labels of the fields for "
#~ "which the criteria are for.  Cells below the labels specify conditions, "
#~ "for example, ``>3'' or ``<9''.  Equality condition can be given simply by "
#~ "specifying a value, e.g. ``3'' or ``John''. \n"
#~ "Each row in @criteria specifies a separate condition. If a row in "
#~ "@database matches a row in @criteria, then that row is counted. "
#~ "Technically speaking, this a boolean OR operation between the rows in "
#~ "@criteria.\n"
#~ "If @criteria specifies more than one column, then each of the conditions "
#~ "in the specified columns must be true for the row in @database to match. "
#~ "Technically speaking, this is a boolean AND operation between the columns "
#~ "in @criteria.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the range A1:C7 contain the following values:\n"
#~ "Name    Age     Salary\n"
#~ "John    34      54342\n"
#~ "Bill    35      22343\n"
#~ "Clark   29      34323\n"
#~ "Bob     43      47242\n"
#~ "Susan   37      42932\n"
#~ "Jill    45      45324\n"
#~ "\n"
#~ "In addition, the cells A9:B11 contain the following values:\n"
#~ "Age     Salary\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "DMIN(A1:C7, \"Salary\", A9:B11) equals 34323.\n"
#~ "DMIN(A1:C7, \"Age\", A9:B11) equals 29.\n"
#~ "\n"
#~ "@SEEALSO=DMAX"
#~ msgstr ""
#~ "@FUNCTION=DMIN\n"
#~ "@SYNTAX=DMIN(base_dados,campo,critério)\n"
#~ "@DESCRIPTION=DMIN devolve o menor número na coluna que coincida com as "
#~ "condições especificadas.\n"
#~ "\n"
#~ "@base_dados é uma área de células em que linhas de informação relacionada "
#~ "são registos e colunas de dados são campos. A primeira linha de uma base "
#~ "de dados contém as etiquetas de cada coluna. \n"
#~ "\n"
#~ "@campo especifica que coluna é utilizada na função.  Se @campo for um "
#~ "inteiro, por exemplo 2, a segunda coluna é utilizada. Campo também pode "
#~ "ser a etiqueta de uma coluna.  Por exemplo, ``Idade'' refere-se à coluna "
#~ "com a etiqueta ``Idade'' na área @base_dados. \n"
#~ "\n"
#~ "@critério é a área de células que contém as condições especificadas.  A "
#~ "primeira linha de um @critério deverá conter as etiquetas dos campos para "
#~ "os quais se aplicam os critérios.  Células abaixo das etiquetas "
#~ "especificam as condições, por exemplo, ``>3'' ou ``<9''.  Condição de "
#~ "igualdade pode ser dada simplesmente especificando um valor, por ex. "
#~ "``3'' ou ``John''.\n"
#~ "Cada linha em @critério especifica uma condição diferente. Se uma linha "
#~ "em @base_dados equivale a uma linha em @critério, então essa linha é "
#~ "incluida.Tecnicamente falando, esta é uma operação boleana OR entre "
#~ "linhas em @critério.\n"
#~ "Se @critério especifica mais do que uma coluna então cada uma das "
#~ "condições destas colunas tem de ser verdadeira para que a linha na "
#~ "@base_dados equivalha. Tecnicamente falando, esta é uma operação boleana "
#~ "AND entre as colunas em @critério.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que a área A1:C7 contém os seguintes valores:\n"
#~ "Nome    Idade   Salário\n"
#~ "John    34      54342\n"
#~ "Bill    35      22343\n"
#~ "Clark   29      34323\n"
#~ "Bob     43      47242\n"
#~ "Susan   37      42932\n"
#~ "Jill    45      45324\n"
#~ "\n"
#~ "Além destas, as células A9:B11 contêm os seguintes valores:\n"
#~ "Idade   Salário\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DMIN(A1:C7, \"Salário\", A9:B11) igual a 34323.\n"
#~ "DMIN(A1:C7, \"Idade\", A9:B11) igual a 29.\n"
#~ "\n"
#~ "@SEEALSO=DMAX"

#~ msgid ""
#~ "@FUNCTION=DPRODUCT\n"
#~ "@SYNTAX=DPRODUCT(database,field,criteria)\n"
#~ "@DESCRIPTION=DPRODUCT function returns the product of numbers in a column "
#~ "that match conditions specified.\n"
#~ "\n"
#~ "@database is a range of cells in which rows of related information are "
#~ "records and columns of data are fields. The first row of a database "
#~ "contains labels for each column. \n"
#~ "\n"
#~ "@field specifies which column is used in the function.  If @field is an "
#~ "integer, for example 2, the second column is used. Field can also be the "
#~ "label of a column.  For example, ``Age'' refers to the column with the "
#~ "label ``Age'' in @database range. \n"
#~ "\n"
#~ "@criteria is the range of cells which contains the specified conditions.  "
#~ "The first row of a @criteria should contain the labels of the fields for "
#~ "which the criteria are for.  Cells below the labels specify conditions, "
#~ "for example, ``>3'' or ``<9''.  Equality condition can be given simply by "
#~ "specifying a value, e.g. ``3'' or ``John''. \n"
#~ "Each row in @criteria specifies a separate condition. If a row in "
#~ "@database matches a row in @criteria, then that row is counted. "
#~ "Technically speaking, this a boolean OR operation between the rows in "
#~ "@criteria.\n"
#~ "If @criteria specifies more than one column, then each of the conditions "
#~ "in the specified columns must be true for the row in @database to match. "
#~ "Technically speaking, this is a boolean AND operation between the columns "
#~ "in @criteria.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the range A1:C7 contain the following values:\n"
#~ "Name    Age     Salary\n"
#~ "John    34      54342\n"
#~ "Bill    35      22343\n"
#~ "Clark   29      34323\n"
#~ "Bob     43      47242\n"
#~ "Susan   37      42932\n"
#~ "Jill    45      45324\n"
#~ "\n"
#~ "In addition, the cells A9:B11 contain the following values:\n"
#~ "Age     Salary\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "DPRODUCT(A1:C7, \"Age\", A9:B11) equals 1247.\n"
#~ "\n"
#~ "@SEEALSO=DSUM"
#~ msgstr ""
#~ "@FUNCTION=DPRODUCT\n"
#~ "@SYNTAX=DPRODUCT(database,field,criteria)\n"
#~ "@DESCRIPTION=DPRODUCT devolve o producto dos números na coluna que "
#~ "coincide com as condições especificadas.\n"
#~ "\n"
#~ "@base_dados é uma área de células em que linhas de informação relacionada "
#~ "são registos e colunas de dados são campos. A primeira linha de uma base "
#~ "de dados contém as etiquetas de cada coluna. \n"
#~ "\n"
#~ "@campo especifica que coluna é utilizada na função.  Se @campo for um "
#~ "inteiro, por exemplo 2, a segunda coluna é utilizada. Campo também pode "
#~ "ser a etiqueta de uma coluna.  Por exemplo, ``Idade'' refere-se à coluna "
#~ "com a etiqueta ``Idade'' na área @base_dados. \n"
#~ "\n"
#~ "@critério é a área de células que contém as condições especificadas.  A "
#~ "primeira linha de um @critério deverá conter as etiquetas dos campos para "
#~ "os quais se aplicam os critérios.  Células abaixo das etiquetas "
#~ "especificam as condições, por exemplo, ``>3'' ou ``<9''.  Condição de "
#~ "igualdade pode ser dada simplesmente especificando um valor, por ex. "
#~ "``3'' ou ``John''.\n"
#~ "Cada linha em @critério especifica uma condição diferente. Se uma linha "
#~ "em @base_dados equivale a uma linha em @critério, então essa linha é "
#~ "incluida.Tecnicamente falando, esta é uma operação boleana OR entre "
#~ "linhas em @critério.\n"
#~ "Se @critério especifica mais do que uma coluna então cada uma das "
#~ "condições destas colunas tem de ser verdadeira para que a linha na "
#~ "@base_dados equivalha. Tecnicamente falando, esta é uma operação boleana "
#~ "AND entre as colunas em @critério.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que a área A1:C7 contém os seguintes valores:\n"
#~ "Nome    Idade   Salário\n"
#~ "John    34      54342\n"
#~ "Bill    35      22343\n"
#~ "Clark   29      34323\n"
#~ "Bob     43      47242\n"
#~ "Susan   37      42932\n"
#~ "Jill    45      45324\n"
#~ "\n"
#~ "Além destas, as células A9:B11 contêm os seguintes valores:\n"
#~ "Idade   Salário\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DPRODUCT(A1:C7, \"Idade\", A9:B11) igual a 1247.\n"
#~ "\n"
#~ "@SEEALSO=DSUM"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=DSTDEV\n"
#~ "@SYNTAX=DSTDEV(database,field,criteria)\n"
#~ "@DESCRIPTION=DSTDEV function returns the estimate of the standard "
#~ "deviation of a population based on a sample. The population consists of "
#~ "numbers that match conditions specified.\n"
#~ "\n"
#~ "@database is a range of cells in which rows of related information are "
#~ "records and columns of data are fields. The first row of a database "
#~ "contains labels for each column. \n"
#~ "\n"
#~ "@field specifies which column is used in the function.  If @field is an "
#~ "integer, for example 2, the second column is used. Field can also be the "
#~ "label of a column.  For example, ``Age'' refers to the column with the "
#~ "label ``Age'' in @database range. \n"
#~ "\n"
#~ "@criteria is the range of cells which contains the specified conditions.  "
#~ "The first row of a @criteria should contain the labels of the fields for "
#~ "which the criteria are for.  Cells below the labels specify conditions, "
#~ "for example, ``>3'' or ``<9''.  Equality condition can be given simply by "
#~ "specifying a value, e.g. ``3'' or ``John''. \n"
#~ "Each row in @criteria specifies a separate condition. If a row in "
#~ "@database matches a row in @criteria, then that row is counted. "
#~ "Technically speaking, this a boolean OR operation between the rows in "
#~ "@criteria.\n"
#~ "If @criteria specifies more than one column, then each of the conditions "
#~ "in the specified columns must be true for the row in @database to match. "
#~ "Technically speaking, this is a boolean AND operation between the columns "
#~ "in @criteria.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the range A1:C7 contain the following values:\n"
#~ "Name    Age     Salary\n"
#~ "John    34      54342\n"
#~ "Bill    35      22343\n"
#~ "Clark   29      34323\n"
#~ "Bob     43      47242\n"
#~ "Susan   37      42932\n"
#~ "Jill    45      45324\n"
#~ "\n"
#~ "In addition, the cells A9:B11 contain the following values:\n"
#~ "Age     Salary\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "DSTDEV(A1:C7, \"Age\", A9:B11) equals 9.89949.\n"
#~ "DSTDEV(A1:C7, \"Salary\", A9:B11) equals 9135.112506.\n"
#~ "\n"
#~ "@SEEALSO=DSTDEVP"
#~ msgstr ""
#~ "@FUNCTION=DSTDEV\n"
#~ "@SYNTAX=DSTDEV(base_dados,campo,critério)\n"
#~ "@DESCRIPTION=DSTDEV devolve a estimativa do desvio padrão de uma "
#~ "população baseada numa amostra. A população consiste nos números que "
#~ "coincidem com as condições especificadas.\n"
#~ "\n"
#~ "@base_dados é uma área de células em que linhas de informação relacionada "
#~ "são registos e colunas de dados são campos. A primeira linha de uma base "
#~ "de dados contém as etiquetas de cada coluna. \n"
#~ "\n"
#~ "@campo especifica que coluna é utilizada na função.  Se @campo for um "
#~ "inteiro, por exemplo 2, a segunda coluna é utilizada. Campo também pode "
#~ "ser a etiqueta de uma coluna.  Por exemplo, ``Idade'' refere-se à coluna "
#~ "com a etiqueta ``Idade'' na área @base_dados. \n"
#~ "\n"
#~ "@critério é a área de células que contém as condições especificadas.  A "
#~ "primeira linha de um @critério deverá conter as etiquetas dos campos para "
#~ "os quais se aplicam os critérios.  Células abaixo das etiquetas "
#~ "especificam as condições, por exemplo, ``>3'' ou ``<9''.  Condição de "
#~ "igualdade pode ser dada simplesmente especificando um valor, por ex. "
#~ "``3'' ou ``John''.\n"
#~ "Cada linha em @critério especifica uma condição diferente. Se uma linha "
#~ "em @base_dados equivale a uma linha em @critério, então essa linha é "
#~ "incluida.Tecnicamente falando, esta é uma operação boleana OR entre "
#~ "linhas em @critério.\n"
#~ "Se @critério especifica mais do que uma coluna então cada uma das "
#~ "condições destas colunas tem de ser verdadeira para que a linha na "
#~ "@base_dados equivalha. Tecnicamente falando, esta é uma operação boleana "
#~ "AND entre as colunas em @critério.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que a área A1:C7 contém os seguintes valores:\n"
#~ "Nome    Idade   Salário\n"
#~ "John    34      54342\n"
#~ "Bill    35      22343\n"
#~ "Clark   29      34323\n"
#~ "Bob     43      47242\n"
#~ "Susan   37      42932\n"
#~ "Jill    45      45324\n"
#~ "\n"
#~ "Além destas, as células A9:B11 contêm os seguintes valores:\n"
#~ "Idade   Salário\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DSTDEV(A1:C7, \"Idade\", A9:B11) igual a 9.89949.\n"
#~ "DSTDEV(A1:C7, \"Salário\", A9:B11) igual a 9135.112506.\n"
#~ "\n"
#~ "@SEEALSO=DSTDEVP"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=DSTDEVP\n"
#~ "@SYNTAX=DSTDEVP(database,field,criteria)\n"
#~ "@DESCRIPTION=DSTDEVP function returns the standard deviation of a "
#~ "population based on the entire population. The population consists of "
#~ "numbers that match conditions specified.\n"
#~ "\n"
#~ "@database is a range of cells in which rows of related information are "
#~ "records and columns of data are fields. The first row of a database "
#~ "contains labels for each column. \n"
#~ "\n"
#~ "@field specifies which column is used in the function.  If @field is an "
#~ "integer, for example 2, the second column is used. Field can also be the "
#~ "label of a column.  For example, ``Age'' refers to the column with the "
#~ "label ``Age'' in @database range. \n"
#~ "\n"
#~ "@criteria is the range of cells which contains the specified conditions.  "
#~ "The first row of a @criteria should contain the labels of the fields for "
#~ "which the criteria are for.  Cells below the labels specify conditions, "
#~ "for example, ``>3'' or ``<9''.  Equality condition can be given simply by "
#~ "specifying a value, e.g. ``3'' or ``John''. \n"
#~ "Each row in @criteria specifies a separate condition. If a row in "
#~ "@database matches a row in @criteria, then that row is counted. "
#~ "Technically speaking, this a boolean OR operation between the rows in "
#~ "@criteria.\n"
#~ "If @criteria specifies more than one column, then each of the conditions "
#~ "in the specified columns must be true for the row in @database to match. "
#~ "Technically speaking, this is a boolean AND operation between the columns "
#~ "in @criteria.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the range A1:C7 contain the following values:\n"
#~ "Name    Age     Salary\n"
#~ "John    34      54342\n"
#~ "Bill    35      22343\n"
#~ "Clark   29      34323\n"
#~ "Bob     43      47242\n"
#~ "Susan   37      42932\n"
#~ "Jill    45      45324\n"
#~ "\n"
#~ "In addition, the cells A9:B11 contain the following values:\n"
#~ "Age     Salary\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "DSTDEVP(A1:C7, \"Age\", A9:B11) equals 7.\n"
#~ "DSTDEVP(A1:C7, \"Salary\", A9:B11) equals 6459.5.\n"
#~ "\n"
#~ "@SEEALSO=DSTDEV"
#~ msgstr ""
#~ "@FUNCTION=DSTDEVP\n"
#~ "@SYNTAX=DSTDEVP(base_dados,campo,critério)\n"
#~ "@DESCRIPTION=DSTDEVP devolve o desvio padrão de uma população baseada na "
#~ "população completa. A população consiste nos números que coincidem com as "
#~ "condições especificadas.\n"
#~ "\n"
#~ "@base_dados é uma área de células em que linhas de informação relacionada "
#~ "são registos e colunas de dados são campos. A primeira linha de uma base "
#~ "de dados contém as etiquetas de cada coluna. \n"
#~ "\n"
#~ "@campo especifica que coluna é utilizada na função.  Se @campo for um "
#~ "inteiro, por exemplo 2, a segunda coluna é utilizada. Campo também pode "
#~ "ser a etiqueta de uma coluna.  Por exemplo, ``Idade'' refere-se à coluna "
#~ "com a etiqueta ``Idade'' na área @base_dados. \n"
#~ "\n"
#~ "@critério é a área de células que contém as condições especificadas.  A "
#~ "primeira linha de um @critério deverá conter as etiquetas dos campos para "
#~ "os quais se aplicam os critérios.  Células abaixo das etiquetas "
#~ "especificam as condições, por exemplo, ``>3'' ou ``<9''.  Condição de "
#~ "igualdade pode ser dada simplesmente especificando um valor, por ex. "
#~ "``3'' ou ``John''.\n"
#~ "Cada linha em @critério especifica uma condição diferente. Se uma linha "
#~ "em @base_dados equivale a uma linha em @critério, então essa linha é "
#~ "incluida.Tecnicamente falando, esta é uma operação boleana OR entre "
#~ "linhas em @critério.\n"
#~ "Se @critério especifica mais do que uma coluna então cada uma das "
#~ "condições destas colunas tem de ser verdadeira para que a linha na "
#~ "@base_dados equivalha. Tecnicamente falando, esta é uma operação boleana "
#~ "AND entre as colunas em @critério.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que a área A1:C7 contém os seguintes valores:\n"
#~ "Nome    Idade   Salário\n"
#~ "John    34      54342\n"
#~ "Bill    35      22343\n"
#~ "Clark   29      34323\n"
#~ "Bob     43      47242\n"
#~ "Susan   37      42932\n"
#~ "Jill    45      45324\n"
#~ "\n"
#~ "Além destas, as células A9:B11 contêm os seguintes valores:\n"
#~ "Idade   Salário\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DSTDEVP(A1:C7, \"Idade\", A9:B11) igual a 7.\n"
#~ "DSTDEVP(A1:C7, \"Salário\", A9:B11) igual a 6459.5.\n"
#~ "\n"
#~ "@SEEALSO=DSTDEV"

#~ msgid ""
#~ "@FUNCTION=DSUM\n"
#~ "@SYNTAX=DSUM(database,field,criteria)\n"
#~ "@DESCRIPTION=DSUM function returns the sum of numbers in a column that "
#~ "match conditions specified.\n"
#~ "\n"
#~ "@database is a range of cells in which rows of related information are "
#~ "records and columns of data are fields. The first row of a database "
#~ "contains labels for each column. \n"
#~ "\n"
#~ "@field specifies which column is used in the function.  If @field is an "
#~ "integer, for example 2, the second column is used. Field can also be the "
#~ "label of a column.  For example, ``Age'' refers to the column with the "
#~ "label ``Age'' in @database range. \n"
#~ "\n"
#~ "@criteria is the range of cells which contains the specified conditions.  "
#~ "The first row of a @criteria should contain the labels of the fields for "
#~ "which the criteria are for.  Cells below the labels specify conditions, "
#~ "for example, ``>3'' or ``<9''.  Equality condition can be given simply by "
#~ "specifying a value, e.g. ``3'' or ``John''. \n"
#~ "Each row in @criteria specifies a separate condition. If a row in "
#~ "@database matches a row in @criteria, then that row is counted. "
#~ "Technically speaking, this a boolean OR operation between the rows in "
#~ "@criteria.\n"
#~ "If @criteria specifies more than one column, then each of the conditions "
#~ "in the specified columns must be true for the row in @database to match. "
#~ "Technically speaking, this is a boolean AND operation between the columns "
#~ "in @criteria.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the range A1:C7 contain the following values:\n"
#~ "Name    Age     Salary\n"
#~ "John    34      54342\n"
#~ "Bill    35      22343\n"
#~ "Clark   29      34323\n"
#~ "Bob     43      47242\n"
#~ "Susan   37      42932\n"
#~ "Jill    45      45324\n"
#~ "\n"
#~ "In addition, the cells A9:B11 contain the following values:\n"
#~ "Age     Salary\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "DSUM(A1:C7, \"Age\", A9:B11) equals 72.\n"
#~ "DSUM(A1:C7, \"Salary\", A9:B11) equals 81565.\n"
#~ "\n"
#~ "@SEEALSO=DPRODUCT"
#~ msgstr ""
#~ "@FUNCTION=DSUM\n"
#~ "@SYNTAX=DSUM(base_dados,campo,critério)\n"
#~ "@DESCRIPTION=DSUM devolve a soma dos números numa coluna que coincida com "
#~ "as condições especificadas.\n"
#~ "\n"
#~ "@base_dados é uma área de células em que linhas de informação relacionada "
#~ "são registos e colunas de dados são campos. A primeira linha de uma base "
#~ "de dados contém as etiquetas de cada coluna. \n"
#~ "\n"
#~ "@campo especifica que coluna é utilizada na função.  Se @campo for um "
#~ "inteiro, por exemplo 2, a segunda coluna é utilizada. Campo também pode "
#~ "ser a etiqueta de uma coluna.  Por exemplo, ``Idade'' refere-se à coluna "
#~ "com a etiqueta ``Idade'' na área @base_dados. \n"
#~ "\n"
#~ "@critério é a área de células que contém as condições especificadas.  A "
#~ "primeira linha de um @critério deverá conter as etiquetas dos campos para "
#~ "os quais se aplicam os critérios.  Células abaixo das etiquetas "
#~ "especificam as condições, por exemplo, ``>3'' ou ``<9''.  Condição de "
#~ "igualdade pode ser dada simplesmente especificando um valor, por ex. "
#~ "``3'' ou ``John''.\n"
#~ "Cada linha em @critério especifica uma condição diferente. Se uma linha "
#~ "em @base_dados equivale a uma linha em @critério, então essa linha é "
#~ "incluida.Tecnicamente falando, esta é uma operação boleana OR entre "
#~ "linhas em @critério.\n"
#~ "Se @critério especifica mais do que uma coluna então cada uma das "
#~ "condições destas colunas tem de ser verdadeira para que a linha na "
#~ "@base_dados equivalha. Tecnicamente falando, esta é uma operação boleana "
#~ "AND entre as colunas em @critério.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que a área A1:C7 contém os seguintes valores:\n"
#~ "Nome    Idade   Salário\n"
#~ "John    34      54342\n"
#~ "Bill    35      22343\n"
#~ "Clark   29      34323\n"
#~ "Bob     43      47242\n"
#~ "Susan   37      42932\n"
#~ "Jill    45      45324\n"
#~ "\n"
#~ "Além destas, as células A9:B11 contêm os seguintes valores:\n"
#~ "Idade   Salário\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DSUM(A1:C7, \"Idade\", A9:B11) igual a 72.\n"
#~ "DSUM(A1:C7, \"Salário\", A9:B11) igual a 81565.\n"
#~ "\n"
#~ "@SEEALSO=DPRODUCT"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=DVAR\n"
#~ "@SYNTAX=DVAR(database,field,criteria)\n"
#~ "@DESCRIPTION=DVAR function returns the estimate of variance of a "
#~ "population based on a sample. The population consists of numbers that "
#~ "match conditions specified.\n"
#~ "\n"
#~ "@database is a range of cells in which rows of related information are "
#~ "records and columns of data are fields. The first row of a database "
#~ "contains labels for each column. \n"
#~ "\n"
#~ "@field specifies which column is used in the function.  If @field is an "
#~ "integer, for example 2, the second column is used. Field can also be the "
#~ "label of a column.  For example, ``Age'' refers to the column with the "
#~ "label ``Age'' in @database range. \n"
#~ "\n"
#~ "@criteria is the range of cells which contains the specified conditions.  "
#~ "The first row of a @criteria should contain the labels of the fields for "
#~ "which the criteria are for.  Cells below the labels specify conditions, "
#~ "for example, ``>3'' or ``<9''.  Equality condition can be given simply by "
#~ "specifying a value, e.g. ``3'' or ``John''. \n"
#~ "Each row in @criteria specifies a separate condition. If a row in "
#~ "@database matches a row in @criteria, then that row is counted. "
#~ "Technically speaking, this a boolean OR operation between the rows in "
#~ "@criteria.\n"
#~ "If @criteria specifies more than one column, then each of the conditions "
#~ "in the specified columns must be true for the row in @database to match. "
#~ "Technically speaking, this is a boolean AND operation between the columns "
#~ "in @criteria.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the range A1:C7 contain the following values:\n"
#~ "Name    Age     Salary\n"
#~ "John    34      54342\n"
#~ "Bill    35      22343\n"
#~ "Clark   29      34323\n"
#~ "Bob     43      47242\n"
#~ "Susan   37      42932\n"
#~ "Jill    45      45324\n"
#~ "\n"
#~ "In addition, the cells A9:B11 contain the following values:\n"
#~ "Age     Salary\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "DVAR(A1:C7, \"Age\", A9:B11) equals 98.\n"
#~ "DVAR(A1:C7, \"Salary\", A9:B11) equals 83450280.5.\n"
#~ "\n"
#~ "@SEEALSO=DVARP"
#~ msgstr ""
#~ "@FUNCTION=DVAR\n"
#~ "@SYNTAX=DVAR(base_dados,campo,critério)\n"
#~ "@DESCRIPTION=DVAR devolve a estimativa da variância de uma população "
#~ "baseada na amostra. A população consiste nos números que coincidam com as "
#~ "condições especificadas.\n"
#~ "\n"
#~ "@base_dados é uma área de células em que linhas de informação relacionada "
#~ "são registos e colunas de dados são campos. A primeira linha de uma base "
#~ "de dados contém as etiquetas de cada coluna. \n"
#~ "\n"
#~ "@campo especifica que coluna é utilizada na função.  Se @campo for um "
#~ "inteiro, por exemplo 2, a segunda coluna é utilizada. Campo também pode "
#~ "ser a etiqueta de uma coluna.  Por exemplo, ``Idade'' refere-se à coluna "
#~ "com a etiqueta ``Idade'' na área @base_dados. \n"
#~ "\n"
#~ "@critério é a área de células que contém as condições especificadas.  A "
#~ "primeira linha de um @critério deverá conter as etiquetas dos campos para "
#~ "os quais se aplicam os critérios.  Células abaixo das etiquetas "
#~ "especificam as condições, por exemplo, ``>3'' ou ``<9''.  Condição de "
#~ "igualdade pode ser dada simplesmente especificando um valor, por ex. "
#~ "``3'' ou ``John''.\n"
#~ "Cada linha em @critério especifica uma condição diferente. Se uma linha "
#~ "em @base_dados equivale a uma linha em @critério, então essa linha é "
#~ "incluida.Tecnicamente falando, esta é uma operação boleana OR entre "
#~ "linhas em @critério.\n"
#~ "Se @critério especifica mais do que uma coluna então cada uma das "
#~ "condições destas colunas tem de ser verdadeira para que a linha na "
#~ "@base_dados equivalha. Tecnicamente falando, esta é uma operação boleana "
#~ "AND entre as colunas em @critério.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que a área A1:C7 contém os seguintes valores:\n"
#~ "Nome    Idade   Salário\n"
#~ "John    34      54342\n"
#~ "Bill    35      22343\n"
#~ "Clark   29      34323\n"
#~ "Bob     43      47242\n"
#~ "Susan   37      42932\n"
#~ "Jill    45      45324\n"
#~ "\n"
#~ "Além destas, as células A9:B11 contêm os seguintes valores:\n"
#~ "Idade   Salário\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DVAR(A1:C7, \"Age\", A9:B11) equals 98.\n"
#~ "DVAR(A1:C7, \"Salary\", A9:B11) equals 83450280.5.\n"
#~ "\n"
#~ "@SEEALSO=DVARP"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=DVARP\n"
#~ "@SYNTAX=DVARP(database,field,criteria)\n"
#~ "@DESCRIPTION=DVARP function returns the variance of a population based on "
#~ "the entire population. The population consists of numbers that match "
#~ "conditions specified.\n"
#~ "\n"
#~ "@database is a range of cells in which rows of related information are "
#~ "records and columns of data are fields. The first row of a database "
#~ "contains labels for each column. \n"
#~ "\n"
#~ "@field specifies which column is used in the function.  If @field is an "
#~ "integer, for example 2, the second column is used. Field can also be the "
#~ "label of a column.  For example, ``Age'' refers to the column with the "
#~ "label ``Age'' in @database range. \n"
#~ "\n"
#~ "@criteria is the range of cells which contains the specified conditions.  "
#~ "The first row of a @criteria should contain the labels of the fields for "
#~ "which the criteria are for.  Cells below the labels specify conditions, "
#~ "for example, ``>3'' or ``<9''.  Equality condition can be given simply by "
#~ "specifying a value, e.g. ``3'' or ``John''. \n"
#~ "Each row in @criteria specifies a separate condition. If a row in "
#~ "@database matches a row in @criteria, then that row is counted. "
#~ "Technically speaking, this a boolean OR operation between the rows in "
#~ "@criteria.\n"
#~ "If @criteria specifies more than one column, then each of the conditions "
#~ "in the specified columns must be true for the row in @database to match. "
#~ "Technically speaking, this is a boolean AND operation between the columns "
#~ "in @criteria.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the range A1:C7 contain the following values:\n"
#~ "Name    Age     Salary\n"
#~ "John    34      54342\n"
#~ "Bill    35      22343\n"
#~ "Clark   29      34323\n"
#~ "Bob     43      47242\n"
#~ "Susan   37      42932\n"
#~ "Jill    45      45324\n"
#~ "\n"
#~ "In addition, the cells A9:B11 contain the following values:\n"
#~ "Age     Salary\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "DVARP(A1:C7, \"Age\", A9:B11) equals 49.\n"
#~ "DVARP(A1:C7, \"Salary\", A9:B11) equals 41725140.25.\n"
#~ "\n"
#~ "@SEEALSO=DVAR"
#~ msgstr ""
#~ "@FUNCTION=DVARP\n"
#~ "@SYNTAX=DVARP(base_dados,campo,critério)\n"
#~ "@DESCRIPTION=DVARP devolve a variância de uma população baseada na "
#~ "população completa. A população consiste nos números que coincidam com as "
#~ "condições especificadas.\n"
#~ "\n"
#~ "@base_dados é uma área de células em que linhas de informação relacionada "
#~ "são registos e colunas de dados são campos. A primeira linha de uma base "
#~ "de dados contém as etiquetas de cada coluna. \n"
#~ "\n"
#~ "@campo especifica que coluna é utilizada na função.  Se @campo for um "
#~ "inteiro, por exemplo 2, a segunda coluna é utilizada. Campo também pode "
#~ "ser a etiqueta de uma coluna.  Por exemplo, ``Idade'' refere-se à coluna "
#~ "com a etiqueta ``Idade'' na área @base_dados. \n"
#~ "\n"
#~ "@critério é a área de células que contém as condições especificadas.  A "
#~ "primeira linha de um @critério deverá conter as etiquetas dos campos para "
#~ "os quais se aplicam os critérios.  Células abaixo das etiquetas "
#~ "especificam as condições, por exemplo, ``>3'' ou ``<9''.  Condição de "
#~ "igualdade pode ser dada simplesmente especificando um valor, por ex. "
#~ "``3'' ou ``John''.\n"
#~ "Cada linha em @critério especifica uma condição diferente. Se uma linha "
#~ "em @base_dados equivale a uma linha em @critério, então essa linha é "
#~ "incluida.Tecnicamente falando, esta é uma operação boleana OR entre "
#~ "linhas em @critério.\n"
#~ "Se @critério especifica mais do que uma coluna então cada uma das "
#~ "condições destas colunas tem de ser verdadeira para que a linha na "
#~ "@base_dados equivalha. Tecnicamente falando, esta é uma operação boleana "
#~ "AND entre as colunas em @critério.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que a área A1:C7 contém os seguintes valores:\n"
#~ "Nome    Idade   Salário\n"
#~ "John    34      54342\n"
#~ "Bill    35      22343\n"
#~ "Clark   29      34323\n"
#~ "Bob     43      47242\n"
#~ "Susan   37      42932\n"
#~ "Jill    45      45324\n"
#~ "\n"
#~ "Além destas, as células A9:B11 contêm os seguintes valores:\n"
#~ "Idade   Salário\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DVARP(A1:C7, \"Idade\", A9:B11) igual a 49.\n"
#~ "DVARP(A1:C7, \"Salário\", A9:B11) igual a 41725140.25.\n"
#~ "\n"
#~ "@SEEALSO=DVAR"

#~ msgid ""
#~ "@FUNCTION=GETPIVOTDATA\n"
#~ "@SYNTAX=GETPIVOTDATA(pivot_table,field_name)\n"
#~ "@DESCRIPTION=GETPIVOTDATA function fetches summary data from a pivot "
#~ "table. @pivot_table is a cell range containing the pivot table. "
#~ "@field_name is the name of the field of which you want the summary data.\n"
#~ "\n"
#~ "* If the summary data is unavailable, GETPIVOTDATA returns #REF! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=GETPIVOTDATA\n"
#~ "@SYNTAX=GETPIVOTDATA(tabela_pivot,nome_campo)\n"
#~ "@DESCRIPTION=A função GETPIVOTDATA recupera dados de resumo de uma tabela "
#~ "pivot. @tabela_pivot é uma área de células que contêm a tabela pivot. "
#~ "@nome_campo é o nome do campo do qual deseja os dados de resumo. \n"
#~ "\n"
#~ "* Se os dados de resumo estiverem indisponíveis, GETPIVOTDATA devolve o "
#~ "erro #REF!. \n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=DATE\n"
#~ "@SYNTAX=DATE (year,month,day)\n"
#~ "@DESCRIPTION=DATE returns the number of days since the 1st of January of "
#~ "1900(the date serial number) for the given year, month and day.\n"
#~ "\n"
#~ "* If @month < 1 or @month > 12, the year will be corrected.  A similar "
#~ "correction takes place for days.\n"
#~ "* The @years should be at least 1900.  If @years < 1900, it is assumed to "
#~ "be 1900 + @years.\n"
#~ "* If the given date is not valid, DATE returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DATE(2001, 3, 30) returns 'Mar 30, 2001'.\n"
#~ " \n"
#~ "@SEEALSO=TODAY, NOW"
#~ msgstr ""
#~ "@FUNCTION=DATE\n"
#~ "@SYNTAX=DATE (ano,mês,dia)\n"
#~ "@DESCRIPTION=DATE devolve o número de dias desde 1 de janeiro de 1900 (o "
#~ "número de série de data) para o ano, mês e dia indicados.\n"
#~ "\n"
#~ "* Se @mês < 1 ou @mês > 12, o ano será corrigido.  Uma correcção "
#~ "semelhante é efectuada para os dias.\n"
#~ "* O @ano deverá ser pelo menos 1900.  Se @ano < 1900, assume-se que seja "
#~ "1900 + @ano.\n"
#~ "* Se a data indicada não for válida, DATE devolve o erro #NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DATE(2001, 3, 30) devolve 'Mar 30, 2001'.\n"
#~ " \n"
#~ "@SEEALSO=TODAY, NOW"

#~ msgid ""
#~ "@FUNCTION=UNIX2DATE\n"
#~ "@SYNTAX=UNIX2DATE(unixtime)\n"
#~ "@DESCRIPTION=UNIX2DATE converts a unix time into a spreadsheet date and "
#~ "time.\n"
#~ "\n"
#~ "A unix time is the number of seconds since midnight January 1, 1970.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=NOW, DATE, DATE2UNIX"
#~ msgstr ""
#~ "@FUNCTION=UNIX2DATE\n"
#~ "@SYNTAX=UNIX2DATE(tempounix)\n"
#~ "@DESCRIPTION=UNIX2DATE converte um valor de tempo unix numa data e hora "
#~ "de folha de cálculo.\n"
#~ "\n"
#~ "Tempo unix é o número de segundos desde a meia-noite de 1 Janeiro 1970.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=NOW, DATE, DATE2UNIX"

#~ msgid ""
#~ "@FUNCTION=DATE2UNIX\n"
#~ "@SYNTAX=DATE2UNIX(serial)\n"
#~ "@DESCRIPTION=DATE2UNIX converts a spreadsheet date and time serial number "
#~ "into a unix time.\n"
#~ "\n"
#~ "A unix time is the number of seconds since midnight January 1, 1970.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DATE2UNIX(\"01/01/2000\") equals 946656000.\n"
#~ "\n"
#~ "@SEEALSO=NOW, DATE, UNIX2DATE"
#~ msgstr ""
#~ "@FUNCTION=DATE2UNIX\n"
#~ "@SYNTAX=DATE2UNIX(série)\n"
#~ "@DESCRIPTION=DATE2UNIX converte um número de série de data e hora de "
#~ "folha de cálculo em tempo unix.\n"
#~ "\n"
#~ "Tempo unix é o número de segundos desde a meia-noite de 1 Janeiro 1970.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DATE2UNIX(\"01/01/2000\") igual a 946656000.\n"
#~ "\n"
#~ "@SEEALSO=NOW, DATE, UNIX2DATE"

#~ msgid ""
#~ "@FUNCTION=DATEVALUE\n"
#~ "@SYNTAX=DATEVALUE(date_str)\n"
#~ "@DESCRIPTION=DATEVALUE returns the serial number of the date.  @date_str "
#~ "is the string that contains the date. The value depends on the date "
#~ "convention.  The MS Excel 1900 convention dates things from Jan 1 1900 "
#~ "while the 1904 convention uses Jan 1 1904.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DATEVALUE(\"1/1/1999\") equals 36161 (in the 1900 convention).\n"
#~ "@SEEALSO=DATE"
#~ msgstr ""
#~ "@FUNCTION=DATEVALUE\n"
#~ "@SYNTAX=DATEVALUE(texto_data)\n"
#~ "@DESCRIPTION=DATEVALUE devolve o número de série da data. @texto_data é a "
#~ "expressão que contém a data. O valor depende da conversão da data. A "
#~ "conversão de datas MS Excel 1900 pensa a partir de 1 Jan 1900 ao passo "
#~ "que a conversão 1904 utiliza 1 Jan 1904.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DATEVALUE(\"1/1/1999\") igual a 36161 (na conversão 1900).\n"
#~ "@SEEALSO=DATE"

#~ msgid ""
#~ "@FUNCTION=DATEDIF\n"
#~ "@SYNTAX=DATEDIF(date1,date2,interval)\n"
#~ "@DESCRIPTION=DATEDIF returns the difference between two dates.  @interval "
#~ "is one of six possible values:  \"y\", \"m\", \"d\", \"ym\", \"md\", and "
#~ "\"yd\".\n"
#~ "\n"
#~ "The first three options will return the number of complete years, months, "
#~ "or days, respectively, between the two dates specified.\n"
#~ "\n"
#~ "  \"ym\" will return the number of full months between the two dates, not "
#~ "including the difference in years.\n"
#~ "  \"md\" will return the number of full days between the two dates, not "
#~ "including the difference in months.\n"
#~ "  \"yd\" will return the number of full days between the two dates, not "
#~ "including the difference in years.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DATEDIF(DATE(2000,4,30),DATE(2003,8,4),\"d\") equals 1191.\n"
#~ "DATEDIF(DATE(2000,4,30),DATE(2003,8,4),\"y\") equals 3.\n"
#~ "\n"
#~ "@SEEALSO=DATE"
#~ msgstr ""
#~ "@FUNCTION=DATEDIF\n"
#~ "@SYNTAX=DATEDIF(data1,data2,intervalo)\n"
#~ "@DESCRIPTION=DATEDIF devolve a diferença entre duas datas.  @intervalo é "
#~ "um de seis valores possíveis:  \"y\", \"m\", \"d\", \"ym\", \"md\", e \"yd"
#~ "\".\n"
#~ "\n"
#~ "As três primeiras opções irão devolver o número de anos, meses ou dias "
#~ "completos, respectivamente, entre as duas datas especificadas.\n"
#~ "\n"
#~ "  \"ym\" irá devolver o número de meses completos entre as duas datas, "
#~ "não incluindo a diferença em anos.\n"
#~ "  \"md\" irá devolver o número de dias completos entre as duas datas, não "
#~ "incluindo a diferença em meses.\n"
#~ "  \"yd\" irá devolver o número de dias completos entre as duas datas, não "
#~ "incluindo a diferença em anos.\n"
#~ "\n"
#~ "* Esta fnção é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DATEDIF(DATE(2000,4,30),DATE(2003,8,4),\"d\") igual a 1191.\n"
#~ "DATEDIF(DATE(2000,4,30),DATE(2003,8,4),\"y\") igual a 3.\n"
#~ "\n"
#~ "@SEEALSO=DATE"

#~ msgid ""
#~ "@FUNCTION=EDATE\n"
#~ "@SYNTAX=EDATE(date,months)\n"
#~ "@DESCRIPTION=EDATE returns the serial number of the date that is the "
#~ "specified number of months before or after a given date.  @date is the "
#~ "serial number of the initial date and @months is the number of months "
#~ "before (negative number) or after (positive number) the initial date.\n"
#~ "\n"
#~ "* If @months is not an integer, it is truncated.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "EDATE(DATE(2001,12,30),2) returns 'Feb 28, 2002'.\n"
#~ "\n"
#~ "@SEEALSO=DATE"
#~ msgstr ""
#~ "@FUNCTION=EDATE\n"
#~ "@SYNTAX=EDATE(data,meses)\n"
#~ "@DESCRIPTION=EDATE devolve o número de série da data que é um número "
#~ "específico de meses antes ou depois da data indicada.  @data é o número "
#~ "de série da data inicial e @meses é o número de meses antes (número "
#~ "negativo) ou depois (número positivo) da data inicial.\n"
#~ "\n"
#~ "* Se @months não for um inteiro, será truncado.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "EDATE(DATE(2001,12,30),2) devolve 'Fev 28, 2002'.\n"
#~ "\n"
#~ "@SEEALSO=DATE"

#~ msgid ""
#~ "@FUNCTION=TODAY\n"
#~ "@SYNTAX=TODAY()\n"
#~ "@DESCRIPTION=TODAY returns the serial number for today (the number of "
#~ "days elapsed since the 1st of January of 1900).\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TODAY() returns 'Nov 6, 2001' on that particular day.\n"
#~ " \n"
#~ "@SEEALSO=NOW"
#~ msgstr ""
#~ "@FUNCTION=TODAY\n"
#~ "@SYNTAX=TODAY()\n"
#~ "@DESCRIPTION=TODAY devolve o número de série da data de hoje (o número de "
#~ "dias que já decorreram desde 1 de Janeiro de 1900).\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TODAY() devolve 'Nov 6, 2001' nesse dia em específico.\n"
#~ " \n"
#~ "@SEEALSO=NOW"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=NOW\n"
#~ "@SYNTAX=NOW ()\n"
#~ "@DESCRIPTION=NOW returns the serial number for the date and time at the "
#~ "time it is evaluated.\n"
#~ "\n"
#~ "Serial Numbers in Gnumeric are represented as follows: The integral part "
#~ "is the number of days since the 1st of January of 1900.  The decimal part "
#~ "represent the fraction of the day and is mapped into hour, minutes and "
#~ "seconds.\n"
#~ "\n"
#~ "For example: .0 represents the beginning of the day, and 0.5 represents "
#~ "noon.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "NOW().\n"
#~ "\n"
#~ "@SEEALSO=TODAY"
#~ msgstr ""
#~ "@FUNCTION=NOW\n"
#~ "@SYNTAX=NOW ()\n"
#~ "@DESCRIPTION=NOW devolve o número de série para a data e hora no momento "
#~ "em que for feita a avaliação.\n"
#~ "\n"
#~ "Números de Série no Gnumeric são representados da seguinte forma:A parte "
#~ "inteira é o número de dias desde 1 de Janeiro de 1900. A parte decimal "
#~ "representa a fracção do dia e está mapeada em horas, minutos e segundos.\n"
#~ "\n"
#~ "Por exemplo: .0 representa o início do dia, e 0.5 representa o meio-dia.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "NOW().\n"
#~ "\n"
#~ "@SEEALSO=TODAY"

#~ msgid ""
#~ "@FUNCTION=TIME\n"
#~ "@SYNTAX=TIME (hours,minutes,seconds)\n"
#~ "@DESCRIPTION=TIME returns a fraction representing the time of day.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TIME(3, 5, 23) equals 3:05AM.\n"
#~ "\n"
#~ "@SEEALSO=HOUR"
#~ msgstr ""
#~ "@FUNCTION=TIME\n"
#~ "@SYNTAX=TIME (horas,minutos,segundos)\n"
#~ "@DESCRIPTION=TIME devolve uma fracção que representa a hora do dia.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TIME(3, 5, 23) igual a 3:05AM.\n"
#~ "\n"
#~ "@SEEALSO=HOUR"

#~ msgid ""
#~ "@FUNCTION=TIMEVALUE\n"
#~ "@SYNTAX=TIMEVALUE (timetext)\n"
#~ "@DESCRIPTION=TIMEVALUE returns a fraction representing the time of day, a "
#~ "number between 0 and 1.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TIMEVALUE(\"3:05\") equals 0.128472.\n"
#~ "TIMEVALUE(\"2:24:53 PM\") equals 0.600613.\n"
#~ "\n"
#~ "@SEEALSO=HOUR,MINUTE"
#~ msgstr ""
#~ "@FUNCTION=TIMEVALUE\n"
#~ "@SYNTAX=TIMEVALUE (textohora)\n"
#~ "@DESCRIPTION=TIMEVALUE devolve uma fracção que representa a hora do dia, "
#~ "um número entre 0 e 1.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TIMEVALUE(\"3:05\") igual a 0.128472.\n"
#~ "TIMEVALUE(\"2:24:53 PM\") igual a 0.600613.\n"
#~ "\n"
#~ "@SEEALSO=HOUR,MINUTE"

#~ msgid ""
#~ "@FUNCTION=HOUR\n"
#~ "@SYNTAX=HOUR (date)\n"
#~ "@DESCRIPTION=HOUR converts a serial number to an hour.  The hour is "
#~ "returned as an integer in the range 0 (12:00 A.M.) to 23 (11:00 P.M.).\n"
#~ "\n"
#~ "* Note that Gnumeric will perform regular string to serial number "
#~ "conversion for you, so you can enter a date as a string.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "HOUR(0.128472) equals 3.\n"
#~ "\n"
#~ "@SEEALSO=MINUTE, NOW, TIME, SECOND"
#~ msgstr ""
#~ "@FUNCTION=HOUR\n"
#~ "@SYNTAX=HOUR (data)\n"
#~ "@DESCRIPTION=HOUR converte um número de série numa hora. A hora é "
#~ "devolvida como inteiro no intervalo 0 (12:00 A.M.) a 23 (11:00 P.M.).\n"
#~ "\n"
#~ "* Note que o Gnumeric irá realizar por si as normais conversões de texto "
#~ "para número de série, pelo que pode inserir a data como texto.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "HOUR(0.128472) igual a 3.\n"
#~ "\n"
#~ "@SEEALSO=MINUTE, NOW, TIME, SECOND"

#~ msgid ""
#~ "@FUNCTION=MINUTE\n"
#~ "@SYNTAX=MINUTE (date)\n"
#~ "@DESCRIPTION=MINUTE converts a serial number to a minute.  The minute is "
#~ "returned as an integer in the range 0 to 59.\n"
#~ "\n"
#~ "* Note that Gnumeric will perform regular string to serial number "
#~ "conversion for you, so you can enter a date as a string.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "MINUTE(0.128472) equals 5.\n"
#~ "\n"
#~ "@SEEALSO=HOUR, NOW, TIME, SECOND"
#~ msgstr ""
#~ "@FUNCTION=MINUTE\n"
#~ "@SYNTAX=MINUTE (data)\n"
#~ "@DESCRIPTION=MINUTE converte um número de série num minuto. O minuto é "
#~ "devolvido como um inteiro no intervalo de 0 a 59.\n"
#~ "\n"
#~ "* Note que o Gnumeric irá realizar por si as normais conversões de texto "
#~ "para número de série, pelo que pode inserir a data como texto.\n"
#~ "* Esta função é compatívelcom o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "MINUTE(0.128472) igual a 5.\n"
#~ "\n"
#~ "@SEEALSO=HOUR, NOW, TIME, SECOND"

#~ msgid ""
#~ "@FUNCTION=SECOND\n"
#~ "@SYNTAX=SECOND (date)\n"
#~ "@DESCRIPTION=SECOND converts a serial number to a second.  The second is "
#~ "returned as an integer in the range 0 to 59.\n"
#~ "\n"
#~ "* Note that Gnumeric will perform regular string to serial number "
#~ "conversion for you, so you can enter a date as a string.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "SECOND(0.600613) equals 53.\n"
#~ "\n"
#~ "@SEEALSO=HOUR, MINUTE, NOW, TIME"
#~ msgstr ""
#~ "@FUNCTION=SECOND\n"
#~ "@SYNTAX=SECOND (data)\n"
#~ "@DESCRIPTION=SECOND converte um número de série num segundo. O segundo é "
#~ "devolvido como um inteiro dentro do intervalo 0 a 59.\n"
#~ "\n"
#~ "* Note que o Gnumeric irá realizar por sí uma conversão de texto para "
#~ "número de série, pelo que pode introduzir uma data como texto.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "SECOND(0.600613) igual a 53.\n"
#~ "\n"
#~ "@SEEALSO=HOUR, MINUTE, NOW, TIME"

#~ msgid ""
#~ "@FUNCTION=YEAR\n"
#~ "@SYNTAX=YEAR (date)\n"
#~ "@DESCRIPTION=YEAR converts a serial number to a year.\n"
#~ "\n"
#~ "* Note that Gnumeric will perform regular string to serial number "
#~ "conversion for you, so you can enter a date as a string.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "YEAR(DATE(2003, 4, 30)) equals 2003.\n"
#~ "\n"
#~ "@SEEALSO=DAY, MONTH, TIME, NOW"
#~ msgstr ""
#~ "@FUNCTION=YEAR\n"
#~ "@SYNTAX=YEAR (data)\n"
#~ "@DESCRIPTION=YEAR converte um número de série num ano.\n"
#~ "\n"
#~ "* Note que o Gnumeric irá realizar por sí uma conversão de texto para "
#~ "número de série, pelo que pode introduzir uma data como texto.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "YEAR(DATE(2003, 4, 30)) igual a 2003.\n"
#~ "\n"
#~ "@SEEALSO=DAY, MONTH, TIME, NOW"

#~ msgid ""
#~ "@FUNCTION=MONTH\n"
#~ "@SYNTAX=MONTH (date)\n"
#~ "@DESCRIPTION=MONTH converts a serial number to a month.\n"
#~ "\n"
#~ "* Note that Gnumeric will perform regular string to serial number "
#~ "conversion for you, so you can enter a date as a string.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "MONTH(DATE(2003, 4, 30)) equals 4.\n"
#~ "\n"
#~ "@SEEALSO=DAY, TIME, NOW, YEAR"
#~ msgstr ""
#~ "@FUNCTION=MONTH\n"
#~ "@SYNTAX=MONTH (data)\n"
#~ "@DESCRIPTION=MONTH converte um número de série num mês.\n"
#~ "\n"
#~ "* Note que o Gnumeric irá realizar por sí uma conversão de texto para "
#~ "número de série, pelo que pode introduzir uma data como texto.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "MONTH(DATE(2003, 4, 30)) igual a 4.\n"
#~ "\n"
#~ "@SEEALSO=DAY, TIME, NOW, YEAR"

#~ msgid ""
#~ "@FUNCTION=DAY\n"
#~ "@SYNTAX=DAY (date)\n"
#~ "@DESCRIPTION=DAY converts a serial number to a day of month.\n"
#~ "\n"
#~ "* Note that Gnumeric will perform regular string to serial number "
#~ "conversion for you, so you can enter a date as a string.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DAY(\"10/24/1968\") equals 24.\n"
#~ "\n"
#~ "@SEEALSO=MONTH, TIME, NOW, YEAR"
#~ msgstr ""
#~ "@FUNCTION=DAY\n"
#~ "@SYNTAX=DAY (data)\n"
#~ "@DESCRIPTION=DAY converte um número de série num dia do mês.\n"
#~ "\n"
#~ "* Note que o Gnumeric irá realizar por sí uma conversão de texto para "
#~ "número de série, pelo que pode introduzir uma data como texto.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DAY(\"10/24/1968\") igual a 24.\n"
#~ "\n"
#~ "@SEEALSO=MONTH, TIME, NOW, YEAR"

#~ msgid ""
#~ "@FUNCTION=WEEKDAY\n"
#~ "@SYNTAX=WEEKDAY (date[, method])\n"
#~ "@DESCRIPTION=WEEKDAY converts a serial number to a weekday.\n"
#~ "\n"
#~ "This function returns an integer indicating the day of week.\n"
#~ "@METHOD indicates the numbering system.  It defaults to 1.\n"
#~ "\n"
#~ "  For @METHOD=1: Sunday is 1, Monday is 2, etc.\n"
#~ "  For @METHOD=2: Monday is 1, Tuesday is 2, etc.\n"
#~ "  For @METHOD=3: Monday is 0, Tuesday is 1, etc.\n"
#~ "\n"
#~ "* Note that Gnumeric will perform regular string to serial number "
#~ "conversion for you, so you can enter a date as a string.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "WEEKDAY(\"10/24/1968\") equals 5 (Thursday).\n"
#~ "\n"
#~ "@SEEALSO=DAY, MONTH, TIME, NOW, YEAR"
#~ msgstr ""
#~ "@FUNCTION=WEEKDAY\n"
#~ "@SYNTAX=WEEKDAY (data[, método])\n"
#~ "@DESCRIPTION=WEEKDAY converte um número de série num dia da semana.\n"
#~ "\n"
#~ "Esta função devolve um inteiro que indica o dia da semana.\n"
#~ "@MÉTODO indica o sistema de numeração. A omissão é 1.\n"
#~ "\n"
#~ "  Para @MÉTODO=1: Domingo é 1, Segunda é 2, etc.\n"
#~ "  Para @MÉTODO=2: Segunda é 1, Terça é 2, etc.\n"
#~ "  Para @MÉTODO=3: Segunda é 0, Terça é 1, etc.\n"
#~ "\n"
#~ "* Note que o Gnumeric irá realizar por sí uma conversão de texto para "
#~ "número de série, pelo que pode introduzir uma data como texto.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "WEEKDAY(\"10/24/1968\") igual a 5 (Quinta Feira).\n"
#~ "\n"
#~ "@SEEALSO=DAY, MONTH, TIME, NOW, YEAR"

#~ msgid ""
#~ "@FUNCTION=DAYS360 \n"
#~ "@SYNTAX=DAYS360 (date1,date2,method)\n"
#~ "@DESCRIPTION=DAYS360 returns the number of days from @date1 to @date2 "
#~ "following a 360-day calendar in which all months are assumed to have 30 "
#~ "days.\n"
#~ "\n"
#~ "* If @method is 1, the European method will be used.  In this case, if "
#~ "the day of the month is 31 it will be considered as 30.\n"
#~ "* If @method is 0 or omitted, the MS Excel (tm) US method will be used.  "
#~ "This is a somewhat complicated industry standard method where the last "
#~ "day of February is considered to be the 30th day of the month, but only "
#~ "for the first date.\n"
#~ "* If @method is 2, a saner version of the US method is used in which both "
#~ "dates get the same February treatment.\n"
#~ "* Note that Gnumeric will perform regular string to serial number "
#~ "conversion for you, so you can enter a date as a string.\n"
#~ "* This function is mostly Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DAYS360(DATE(2003, 2, 3), DATE(2007, 4, 2)) equals 1499.\n"
#~ "\n"
#~ "@SEEALSO=MONTH, TIME, NOW, YEAR"
#~ msgstr ""
#~ "@FUNCTION=DAYS360 \n"
#~ "@SYNTAX=DAYS360 (data1,data2,método)\n"
#~ "@DESCRIPTION=DAYS360 devolve o número de dias de @data1 até @date2 "
#~ "segundo um calendário de 360 dias em que se assume que todos os meses têm "
#~ "30 dias.\n"
#~ "\n"
#~ "* Se @método for 1, será utilizado o método Europeu. Neste caso, se o dia "
#~ "do mês for 31 será considerado como sendo 30.\n"
#~ "* Se @método for 0 ou omitido, o método MS Excel (tm) dos EUA será "
#~ "utilizado. Este é um método standard de indústria algo complicado, onde o "
#~ "último dia de Fevereiro é considerado o 30º dia do mês, mas apenas para a "
#~ "primeira data.\n"
#~ "* Se @método for 2, uma versão mais sã do método EUA será utilizado em "
#~ "que ambas as datas recebem o mesmo tratamento para Fevereiro.\n"
#~ "* Note que o Gnumeric irá realizar por sí uma conversão de texto para "
#~ "número de série, pelo que pode introduzir uma data como texto.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DAYS360(DATE(2003, 2, 3), DATE(2007, 4, 2)) igual a 1499.\n"
#~ "\n"
#~ "@SEEALSO=MONTH, TIME, NOW, YEAR"

#~ msgid ""
#~ "@FUNCTION=EOMONTH\n"
#~ "@SYNTAX=EOMONTH (start_date,months)\n"
#~ "@DESCRIPTION=EOMONTH returns the last day of the month which is @months "
#~ "from the @start_date.\n"
#~ "\n"
#~ "* EOMONTH returns #NUM! if @start_date or @months are invalid.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "If A1 contains 12/21/00 then EOMONTH(A1,0)=12/31/00, "
#~ "EOMONTH(A1,5)=5/31/01, and EOMONTH(A1,2)=2/28/01\n"
#~ "\n"
#~ "@SEEALSO=MONTH"
#~ msgstr ""
#~ "@FUNCTION=EOMONTH\n"
#~ "@SYNTAX=EOMONTH (data_início,meses)\n"
#~ "@DESCRIPTION=EOMONTH devolve o último dia do mês que está a @meses da "
#~ "@data_início.\n"
#~ "\n"
#~ "* EOMONTH devolve #NUM! se data_início ou meses forem inválidos.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Se A1 contiver 12/21/00 então EOMONTH(A1,0)=12/31/00, "
#~ "EOMONTH(A1,5)=5/31/01, e EOMONTH(A1,2)=2/28/01\n"
#~ "\n"
#~ "@SEEALSO=MONTH"

#~ msgid ""
#~ "@FUNCTION=WORKDAY\n"
#~ "@SYNTAX=WORKDAY (start_date,days[,holidays])\n"
#~ "@DESCRIPTION=WORKDAY returns the date which is @days working days from "
#~ "the @start_date.  Weekends and holidays optionally supplied in @holidays "
#~ "are respected.\n"
#~ "\n"
#~ "* WORKDAY returns #NUM! if @start_date or @days are invalid.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DAY(WORKDAY(DATE(2001,1,5),30)) equals 16 and\n"
#~ "MONTH(WORKDAY(DATE(2001,1,5),30)) equals 2.\n"
#~ "\n"
#~ "@SEEALSO=NETWORKDAYS"
#~ msgstr ""
#~ "@FUNCTION=WORKDAY\n"
#~ "@SYNTAX=WORKDAY (data_início,dias[,feriados])\n"
#~ "@DESCRIPTION=WORKDAY devolve o dia que está a @dias dias úteis da "
#~ "@data_início. Fins-de-semana e feriados opcionalmente indicados em "
#~ "@feriados são respeitados.\n"
#~ "\n"
#~ "* WORKDAY devolve #NUM! se a @data_início ou @dias forem inválidos.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DAY(WORKDAY(DATE(2001,1,5),30)) igual a 16 e\n"
#~ "MONTH(WORKDAY(DATE(2001,1,5),30)) igual a 2.\n"
#~ "\n"
#~ "@SEEALSO=NETWORKDAYS"

#~ msgid ""
#~ "@FUNCTION=NETWORKDAYS\n"
#~ "@SYNTAX=NETWORKDAYS (start_date,end_date[,holidays])\n"
#~ "@DESCRIPTION=NETWORKDAYS returns the number of non-weekend non-holidays "
#~ "between @start_date and @end_date including these dates. Holidays are "
#~ "optionally supplied in @holidays.\n"
#~ "\n"
#~ "* NETWORKDAYS returns #NUM! if @start_date or @end_date are invalid.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "NETWORKDAYS(DATE(2001,1,2),DATE(2001,2,15)) equals 33.\n"
#~ "\n"
#~ "@SEEALSO=WORKDAY"
#~ msgstr ""
#~ "@FUNCTION=NETWORKDAYS\n"
#~ "@SYNTAX=NETWORKDAYS (data_início,data_fim[,feriados])\n"
#~ "@DESCRIPTION=NETWORKDAYS devolve o número de dias úteis entre "
#~ "@data_início e @data_fim incluindo estas datas. Feriados podem ser "
#~ "opcionalmente indicados em @feriados.\n"
#~ "\n"
#~ "* NETWORKDAYS devolve #NUM! se @data_início ou @data_fim forem "
#~ "inválidos.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "NETWORKDAYS(DATE(2001,1,2),DATE(2001,2,15)) igual a 33.\n"
#~ "\n"
#~ "@SEEALSO=WORKDAY"

#~ msgid ""
#~ "@FUNCTION=ISOWEEKNUM\n"
#~ "@SYNTAX=ISOWEEKNUM (date)\n"
#~ "@DESCRIPTION=ISOWEEKNUM returns the ISO 8601 week number of @date.\n"
#~ "\n"
#~ "An ISO 8601 week starts on Monday. Weeks are numbered from 1. A week "
#~ "including days from two different years is assigned to the year which "
#~ "includes the most days. This means that Dec 31 could be in week 1 of the "
#~ "following year, and Jan 1 could be in week 52 or 53 of the previous year. "
#~ "ISOWEEKNUM returns the week number.\n"
#~ "\n"
#~ "* ISOWEEKNUM returns #NUM! if date is invalid.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "If A1 contains 12/21/00 then ISOWEEKNUM(A1)=51\n"
#~ "@SEEALSO=WEEKNUM, ISOYEAR"
#~ msgstr ""
#~ "@FUNCTION=ISOWEEKNUM\n"
#~ "@SYNTAX=ISOWEEKNUM (data)\n"
#~ "@DESCRIPTION=ISOWEEKNUM devolve o número de semana ISO 8601 de @data.\n"
#~ "\n"
#~ "Uma semana ISO 8601 começa à Segunda. As semanas são numeradas a partir "
#~ "de 1. Uma semana que inclua dias de anos diferentes é associada ao ano de "
#~ "que possua mais dias. Isto significa que 31 Dez pode pertencer à semana 1 "
#~ "do ano seguinte, e 1 Jan pode pertencer à semana 52 ou 53 do ano "
#~ "anterior. ISOWEEKNUM devolve o número da semana.\n"
#~ "\n"
#~ "* ISOWEEKNUM devolve #NUM! se a data for inválida.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Se A1 contém 12/21/00 então ISOWEEKNUM(A1)=51\n"
#~ "@SEEALSO=WEEKNUM, ISOYEAR"

#~ msgid ""
#~ "@FUNCTION=ISOYEAR\n"
#~ "@SYNTAX=ISOYEAR (date)\n"
#~ "@DESCRIPTION=ISOYEAR returns the year of the ISO 8601 week number of "
#~ "@date.\n"
#~ "\n"
#~ "An ISO 8601 week starts on Monday. Weeks are numbered from 1. A week "
#~ "including days from two different years is assigned to the year which "
#~ "includes the most days. This means that Dec 31 could be in week 1 of the "
#~ "following year, and Jan 1 could be in week 52 or 53 of the previous year. "
#~ "ISOYEAR returns the year the week is assigned to.\n"
#~ "\n"
#~ "* ISOYEAR returns #NUM! if date is invalid.\n"
#~ "@EXAMPLES=\n"
#~ "If A1 contains 12/31/2001 then ISOYEAR(A1)=2002\n"
#~ "@SEEALSO=ISOWEEKNUM"
#~ msgstr ""
#~ "@FUNCTION=ISOYEAR\n"
#~ "@SYNTAX=ISOYEAR (data)\n"
#~ "@DESCRIPTION=ISOYEAR devolve o ano do número da semana ISO 8601 de "
#~ "@data.\n"
#~ "\n"
#~ "Uma semana ISO 8601 começa à Segunda. As semanas são numeradas a partir "
#~ "de 1. Uma semana que inclua dias de anos diferentes é associada ao ano de "
#~ "que possua mais dias. Isto significa que 31 Dez pode pertencer à semana 1 "
#~ "do ano seguinte, e 1 Jan pode pertencer à semana 52 ou 53 do ano "
#~ "anterior. ISOYEAR devolve o ano a que a semana está assignada.\n"
#~ "\n"
#~ "* ISOYEAR devolve #NUM! se a data for inválida.\n"
#~ "@EXAMPLES=\n"
#~ "Se A1 contém 12/31/2001 então ISOYEAR(A1)=2002\n"
#~ "@SEEALSO=ISOWEEKNUM"

#~ msgid ""
#~ "@FUNCTION=WEEKNUM\n"
#~ "@SYNTAX=WEEKNUM (date[,method])\n"
#~ "@DESCRIPTION=WEEKNUM returns the week number of @date according to the "
#~ "given @method.\n"
#~ "\n"
#~ "@method defaults to 1.\n"
#~ "\n"
#~ "  For @method=1, week starts on Sunday, and days before first Sunday are "
#~ "in week 0.\n"
#~ "  For @method=2, week starts on Monday, and days before first Monday are "
#~ "in week 0.\n"
#~ "  For @method=150, the ISO 8601 week number is returned.\n"
#~ "\n"
#~ "* WEEKNUM returns #NUM! if @date or @method is invalid.\n"
#~ "* This function is Excel compatible, except that Excel does not support "
#~ "ISO 8601 week numbers.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "If A1 contains 12/21/00 then WEEKNUM(A1,2)=51\n"
#~ "@SEEALSO=ISOWEEKNUM"
#~ msgstr ""
#~ "@FUNCTION=WEEKNUM\n"
#~ "@SYNTAX=WEEKNUM (data[,método])\n"
#~ "@DESCRIPTION=WEEKNUM devolve o número de semana da @data de acordo com o "
#~ "@método especificado.\n"
#~ "\n"
#~ "@método é 1 por omissão.\n"
#~ "\n"
#~ "  Para @método=1, a semana começa no Domingo, e os dias antes do primeiro "
#~ "Domingo são na semana 0.\n"
#~ "  Para @método=2, a semana começa à Segunda, e os dias antes da primeira "
#~ "Segunda são na semana 0.\n"
#~ "  Para @método=150, é devolvido o número de semana ISO 8601.\n"
#~ "\n"
#~ "* WEEKNUM devolve #NUM! se @data ou @método for inválido.\n"
#~ "* Esta função é compatível com o Excel, excepto em que o Excel não "
#~ "suporta números de semana ISO 8601.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Se A1 contém 12/21/00 então WEEKNUM(A1,2)=51\n"
#~ "@SEEALSO=ISOWEEKNUM"

#~ msgid ""
#~ "@FUNCTION=YEARFRAC\n"
#~ "@SYNTAX=YEARFRAC (start_date, end_date [,basis])\n"
#~ "@DESCRIPTION=YEARFRAC returns the number of full days between @start_date "
#~ "and @end_date according to the @basis.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=DATEDIF"
#~ msgstr ""
#~ "@FUNCTION=YEARFRAC\n"
#~ "@SYNTAX=WEEKNUM (data_início, data_fim [,base])\n"
#~ "@DESCRIPTION=YEARFRAC devolve o número de dias completos entre a "
#~ "@data_início e @data_fim de acordo com a @base.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=DATEDIF"

#~ msgid ""
#~ "@FUNCTION=BASE\n"
#~ "@SYNTAX=BASE(number,base[,length])\n"
#~ "@DESCRIPTION=BASE function converts a number to a string representing "
#~ "that number in base @base.\n"
#~ "\n"
#~ "* @base must be an integer between 2 and 36.\n"
#~ "* This function is OpenOffice.Org compatible.\n"
#~ "* Optional argument @length specifies the minimum result length.  "
#~ "Leading  zeroes will be added to reach this length.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BASE(255,16,4) equals \"00FF\".\n"
#~ "\n"
#~ "@SEEALSO=DECIMAL"
#~ msgstr ""
#~ "@FUNCTION=OCT2DEC\n"
#~ "@SYNTAX=OCT2DEC(x)\n"
#~ "@DESCRIPTION=A função OCT2DEC converte um número octal num texto ou "
#~ "número para o seu equivalente decimal.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "OCT2DEC(\"124\") igual a 84.\n"
#~ "\n"
#~ "@SEEALSO=DEC2OCT, OCT2BIN, OCT2HEX"

#~ msgid ""
#~ "@FUNCTION=BIN2DEC\n"
#~ "@SYNTAX=BIN2DEC(x)\n"
#~ "@DESCRIPTION=BIN2DEC function converts a binary number in string or "
#~ "number to its decimal equivalent.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BIN2DEC(101) equals 5.\n"
#~ "\n"
#~ "@SEEALSO=DEC2BIN, BIN2OCT, BIN2HEX"
#~ msgstr ""
#~ "@FUNCTION=BIN2DEC\n"
#~ "@SYNTAX=BIN2DEC(x)\n"
#~ "@DESCRIPTION=A função BIN2DEC converte um número binário em formato "
#~ "numérico ou texto no seu equivalente decimal.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BIN2DEC(101) igual a 5.\n"
#~ "\n"
#~ "@SEEALSO=DEC2BIN, BIN2OCT, BIN2HEX"

#~ msgid ""
#~ "@FUNCTION=BIN2OCT\n"
#~ "@SYNTAX=BIN2OCT(number[,places])\n"
#~ "@DESCRIPTION=BIN2OCT function converts a binary number to an octal "
#~ "number. @places is an optional field, specifying to zero pad to that "
#~ "number of spaces.\n"
#~ "\n"
#~ "* If @places is too small or negative #NUM! error is returned.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BIN2OCT(110111) equals 67.\n"
#~ "\n"
#~ "@SEEALSO=OCT2BIN, BIN2DEC, BIN2HEX"
#~ msgstr ""
#~ "@FUNCTION=BIN2OCT\n"
#~ "@SYNTAX=BIN2OCT(número[,casas])\n"
#~ "@DESCRIPTION=A função BIN2OCT converte um número binário num número "
#~ "octal. @casas é um campo opcional, que indica o preenchimento com zeros "
#~ "para esse número de espaços.\n"
#~ "\n"
#~ "* Se @casas for demasiado pequeno ou negativo é devolvido um erro #NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BIN2OCT(110111) igual a 67.\n"
#~ "\n"
#~ "@SEEALSO=OCT2BIN, BIN2DEC, BIN2HEX"

#~ msgid ""
#~ "@FUNCTION=BIN2HEX\n"
#~ "@SYNTAX=BIN2HEX(number[,places])\n"
#~ "@DESCRIPTION=BIN2HEX function converts a binary number to a hexadecimal "
#~ "number.  @places is an optional field, specifying to zero pad to that "
#~ "number of spaces.\n"
#~ "\n"
#~ "* If @places is too small or negative #NUM! error is returned.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BIN2HEX(100111) equals 27.\n"
#~ "\n"
#~ "@SEEALSO=HEX2BIN, BIN2OCT, BIN2DEC"
#~ msgstr ""
#~ "@FUNCTION=BIN2HEX\n"
#~ "@SYNTAX=BIN2HEX(número[,casas])\n"
#~ "@DESCRIPTION=A função BIN2HEX converte um número binário num número "
#~ "hexadecimal. @casas é um campo opcional, que indica o preenchimento com "
#~ "zeros para esse número de espaços.\n"
#~ "\n"
#~ "* Se @casas for demasiado pequeno ou negativo é devolvido um erro #NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BIN2HEX(100111) igual a 27.\n"
#~ "\n"
#~ "@SEEALSO=HEX2BIN, BIN2OCT, BIN2DEC"

#~ msgid ""
#~ "@FUNCTION=DEC2BIN\n"
#~ "@SYNTAX=DEC2BIN(number[,places])\n"
#~ "@DESCRIPTION=DEC2BIN function converts a decimal number to a binary "
#~ "number. @places is an optional field, specifying to zero pad to that "
#~ "number of spaces.\n"
#~ "\n"
#~ "* If @places is too small or negative #NUM! error is returned.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DEC2BIN(42) equals 101010.\n"
#~ "\n"
#~ "@SEEALSO=BIN2DEC, DEC2OCT, DEC2HEX"
#~ msgstr ""
#~ "@FUNCTION=DEC2BIN\n"
#~ "@SYNTAX=DEC2BIN(número[,casas])\n"
#~ "@DESCRIPTION=A função DEC2BIN converte um número decimal num número "
#~ "binário. @casas é um campo opcional, que indica o preenchimento com zeros "
#~ "para esse número de espaços.\n"
#~ "\n"
#~ "* Se @casas for demasiado pequeno ou negativo é devolvido um erro #NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DEC2BIN(42) igual a 101010.\n"
#~ "\n"
#~ "@SEEALSO=BIN2DEC, DEC2OCT, DEC2HEX"

#~ msgid ""
#~ "@FUNCTION=DEC2OCT\n"
#~ "@SYNTAX=DEC2OCT(number[,places])\n"
#~ "@DESCRIPTION=DEC2OCT function converts a decimal number to an octal "
#~ "number. @places is an optional field, specifying to zero pad to that "
#~ "number of spaces.\n"
#~ "\n"
#~ "* If @places is too small or negative #NUM! error is returned.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DEC2OCT(42) equals 52.\n"
#~ "\n"
#~ "@SEEALSO=OCT2DEC, DEC2BIN, DEC2HEX"
#~ msgstr ""
#~ "@FUNCTION=DEC2OCT\n"
#~ "@SYNTAX=DEC2OCT(número[,casas])\n"
#~ "@DESCRIPTION=A função DEC2OCT converte um número decimal num número "
#~ "octal. @casas é um campo opcional, que indica o preenchimento com zeros "
#~ "para esse número de espaços.\n"
#~ "\n"
#~ "* Se @casas for demasiado pequeno ou negativo é devolvido um erro #NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DEC2OCT(42) igual a 52.\n"
#~ "\n"
#~ "@SEEALSO=OCT2DEC, DEC2BIN, DEC2HEX"

#~ msgid ""
#~ "@FUNCTION=DEC2HEX\n"
#~ "@SYNTAX=DEC2HEX(number[,places])\n"
#~ "@DESCRIPTION=DEC2HEX function converts a decimal number to a hexadecimal "
#~ "number. @places is an optional field, specifying to zero pad to that "
#~ "number of spaces.\n"
#~ "\n"
#~ "* If @places is too small or negative #NUM! error is returned.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DEC2HEX(42) equals 2A.\n"
#~ "\n"
#~ "@SEEALSO=HEX2DEC, DEC2BIN, DEC2OCT"
#~ msgstr ""
#~ "@FUNCTION=DEC2HEX\n"
#~ "@SYNTAX=DEC2HEX(número[,casas])\n"
#~ "@DESCRIPTION=A função DEC2HEX converte um número decimal num número "
#~ "hexadecimal. @casas é um campo opcional, que indica o preenchimento com "
#~ "zeros para esse número de espaços.\n"
#~ "\n"
#~ "* Se @casas for demasiado pequeno ou negativo é devolvido um erro #NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DEC2HEX(42) igual a 2A.\n"
#~ "\n"
#~ "@SEEALSO=HEX2DEC, DEC2BIN, DEC2OCT"

#~ msgid ""
#~ "@FUNCTION=DECIMAL\n"
#~ "@SYNTAX=DECIMAL(text,base)\n"
#~ "@DESCRIPTION=DECIMAL function converts a number in base @base to "
#~ "decimal.\n"
#~ "\n"
#~ "* @base must be an integer between 2 and 36.\n"
#~ "* This function is OpenOffice.Org compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DECIMAL(\"A1\",16) equals 161.\n"
#~ "\n"
#~ "@SEEALSO=BASE"
#~ msgstr ""
#~ "@FUNCTION=OCT2DEC\n"
#~ "@SYNTAX=OCT2DEC(x)\n"
#~ "@DESCRIPTION=A função OCT2DEC converte um número octal num texto ou "
#~ "número para o seu equivalente decimal.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "OCT2DEC(\"124\") igual a 84.\n"
#~ "\n"
#~ "@SEEALSO=DEC2OCT, OCT2BIN, OCT2HEX"

#~ msgid ""
#~ "@FUNCTION=OCT2DEC\n"
#~ "@SYNTAX=OCT2DEC(x)\n"
#~ "@DESCRIPTION=OCT2DEC function converts an octal number in a string or "
#~ "number to its decimal equivalent.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "OCT2DEC(\"124\") equals 84.\n"
#~ "\n"
#~ "@SEEALSO=DEC2OCT, OCT2BIN, OCT2HEX"
#~ msgstr ""
#~ "@FUNCTION=OCT2DEC\n"
#~ "@SYNTAX=OCT2DEC(x)\n"
#~ "@DESCRIPTION=A função OCT2DEC converte um número octal num texto ou "
#~ "número para o seu equivalente decimal.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "OCT2DEC(\"124\") igual a 84.\n"
#~ "\n"
#~ "@SEEALSO=DEC2OCT, OCT2BIN, OCT2HEX"

#~ msgid ""
#~ "@FUNCTION=OCT2BIN\n"
#~ "@SYNTAX=OCT2BIN(number[,places])\n"
#~ "@DESCRIPTION=OCT2BIN function converts an octal number to a binary "
#~ "number.  @places is an optional field, specifying to zero pad to that "
#~ "number of spaces.\n"
#~ "\n"
#~ "* If @places is too small or negative #NUM! error is returned.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "OCT2BIN(\"213\") equals 10001011.\n"
#~ "\n"
#~ "@SEEALSO=BIN2OCT, OCT2DEC, OCT2HEX"
#~ msgstr ""
#~ "@FUNCTION=OCT2BIN\n"
#~ "@SYNTAX=OCT2BIN(número[,casas])\n"
#~ "@DESCRIPTION=A função OCT2BIN converte um número octal num número "
#~ "binário. @casas é um campo opcional, que indica o preenchimento com zeros "
#~ "para esse número de espaços.\n"
#~ "\n"
#~ "* Se @casas for demasiado pequeno ou negativo é devolvido um erro #NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "OCT2BIN(\"213\") igual a 10001011.\n"
#~ "\n"
#~ "@SEEALSO=BIN2OCT, OCT2DEC, OCT2HEX"

#~ msgid ""
#~ "@FUNCTION=OCT2HEX\n"
#~ "@SYNTAX=OCT2HEX(number[,places])\n"
#~ "@DESCRIPTION=OCT2HEX function converts an octal number to a hexadecimal "
#~ "number.  @places is an optional field, specifying to zero pad to that "
#~ "number of spaces.\n"
#~ "\n"
#~ "* If @places is too small or negative #NUM! error is returned.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "OCT2HEX(132) equals 5A.\n"
#~ "\n"
#~ "@SEEALSO=HEX2OCT, OCT2BIN, OCT2DEC"
#~ msgstr ""
#~ "@FUNCTION=OCT2HEX\n"
#~ "@SYNTAX=OCT2HEX(número[,casas])\n"
#~ "@DESCRIPTION=A função OCT2HEX converte um número octal num número "
#~ "hexadecimal. @casas é um campo opcional, que indica o preenchimento com "
#~ "zeros para esse número de espaços.\n"
#~ "\n"
#~ "* Se @casas for demasiado pequeno ou negativo é devolvido um erro #NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "OCT2HEX(132) igual a 5A.\n"
#~ "\n"
#~ "@SEEALSO=HEX2OCT, OCT2BIN, OCT2DEC"

#~ msgid ""
#~ "@FUNCTION=HEX2BIN\n"
#~ "@SYNTAX=HEX2BIN(number[,places])\n"
#~ "@DESCRIPTION=HEX2BIN function converts a hexadecimal number to a binary "
#~ "number.  @places is an optional field, specifying to zero pad to that "
#~ "number of spaces.\n"
#~ "\n"
#~ "* If @places is too small or negative #NUM! error is returned.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "HEX2BIN(\"2A\") equals 101010.\n"
#~ "\n"
#~ "@SEEALSO=BIN2HEX, HEX2OCT, HEX2DEC"
#~ msgstr ""
#~ "@FUNCTION=HEX2BIN\n"
#~ "@SYNTAX=HEX2BIN(número[,casas])\n"
#~ "@DESCRIPTION=A função HEX2BIN converte um número hexadecimal num número "
#~ "binário. @casas é um campo opcional, que indica o preenchimento com zeros "
#~ "para esse número de espaços.\n"
#~ "\n"
#~ "* Se @casas for demasiado pequeno ou negativo é devolvido um erro #NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "HEX2BIN(\"2A\") igual a 101010.\n"
#~ "\n"
#~ "@SEEALSO=BIN2HEX, HEX2OCT, HEX2DEC"

#~ msgid ""
#~ "@FUNCTION=HEX2OCT\n"
#~ "@SYNTAX=HEX2OCT(number[,places])\n"
#~ "@DESCRIPTION=HEX2OCT function converts a hexadecimal number to an octal "
#~ "number.  @places is an optional field, specifying to zero pad to that "
#~ "number of spaces.\n"
#~ "\n"
#~ "* If @places is too small or negative #NUM! error is returned.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "HEX2OCT(\"2A\") equals 52.\n"
#~ "\n"
#~ "@SEEALSO=OCT2HEX, HEX2BIN, HEX2DEC"
#~ msgstr ""
#~ "@FUNCTION=HEX2OCT\n"
#~ "@SYNTAX=HEX2OCT(número[,casas])\n"
#~ "@DESCRIPTION=A função HEX2OCT converte um número hexadecimal num número "
#~ "octal. @casas é um campo opcional, que indica o preenchimento com zeros "
#~ "para esse número de espaços.\n"
#~ "\n"
#~ "* Se @casas for demasiado pequeno ou negativo é devolvido um erro #NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "HEX2OCT(\"2A\") igual a 52.\n"
#~ "\n"
#~ "@SEEALSO=OCT2HEX, HEX2BIN, HEX2DEC"

#~ msgid ""
#~ "@FUNCTION=HEX2DEC\n"
#~ "@SYNTAX=HEX2DEC(x)\n"
#~ "@DESCRIPTION=HEX2DEC function converts a hexadecimal number to its "
#~ "decimal equivalent.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "HEX2DEC(\"2A\") equals 42.\n"
#~ "\n"
#~ "@SEEALSO=DEC2HEX, HEX2BIN, HEX2OCT"
#~ msgstr ""
#~ "@FUNCTION=HEX2DEC\n"
#~ "@SYNTAX=HEX2DEC(x)\n"
#~ "@DESCRIPTION=A função HEX2DEC converte um número hexadecimal no seu "
#~ "equivalente decimal.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "HEX2DEC(\"2A\") igual a 42.\n"
#~ "\n"
#~ "@SEEALSO=DEC2HEX, HEX2BIN, HEX2OCT"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=BESSELI\n"
#~ "@SYNTAX=BESSELI(x,y)\n"
#~ "@DESCRIPTION=BESSELI function returns the Neumann, Weber or Bessel "
#~ "function.\n"
#~ "\n"
#~ "@x is where the function is evaluated. @y is the order of the Bessel "
#~ "function.\n"
#~ "\n"
#~ "* If @x or @y are not numeric a #VALUE! error is returned.\n"
#~ "* If @y < 0 a #NUM! error is returned.\n"
#~ "* This function extends the Excel function of the same name to non-"
#~ "integer orders.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BESSELI(0.7,3) equals 0.007367374.\n"
#~ "\n"
#~ "@SEEALSO=BESSELJ,BESSELK,BESSELY"
#~ msgstr ""
#~ "@FUNCTION=BESSELI\n"
#~ "@SYNTAX=BESSELI(x,y)\n"
#~ "@DESCRIPTION=A função BESSELI devolve a função Neumann, Weber ou Bessel.\n"
#~ "\n"
#~ "@x é onde a função é avaliada. @y é a ordem da função bessel, se não for "
#~ "inteiro será truncado.\n"
#~ "\n"
#~ "* Se @x ou @y não forem numéricos é devolvido um erro #VALOR!.\n"
#~ "* Se @y < 0 é devolvido um erro #NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BESSELI(0.7,3) igual a 0.007367374.\n"
#~ "\n"
#~ "@SEEALSO=BESSELJ,BESSELK,BESSELY"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=BESSELK\n"
#~ "@SYNTAX=BESSELK(x,y)\n"
#~ "@DESCRIPTION=BESSELK function returns the Neumann, Weber or Bessel "
#~ "function. @x is where the function is evaluated. @y is the order of the "
#~ "Bessel function.\n"
#~ "\n"
#~ "* If @x or @y are not numeric a #VALUE! error is returned.\n"
#~ "* If @y < 0 a #NUM! error is returned.\n"
#~ "* This function extends the Excel function of the same name to non-"
#~ "integer orders.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BESSELK(3,9) equals 397.95880.\n"
#~ "\n"
#~ "@SEEALSO=BESSELI,BESSELJ,BESSELY"
#~ msgstr ""
#~ "@FUNCTION=BESSELK\n"
#~ "@SYNTAX=BESSELK(x,y)\n"
#~ "@DESCRIPTION=A função BESSELK devolve a função Neumann, Weber ou Bessel. "
#~ "@x é onde a função é avaliada. @y é a ordem da função bessel, se não for "
#~ "inteiro será truncado.\n"
#~ "\n"
#~ "* Se @x ou @y não forem numéricos é devolvido um erro #VALOR!.\n"
#~ "* Se @y < 0 é devolvido um erro #NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BESSELK(3,9) igual a 397.95880.\n"
#~ "\n"
#~ "@SEEALSO=BESSELI,BESSELJ,BESSELY"

#~ msgid ""
#~ "@FUNCTION=BESSELJ\n"
#~ "@SYNTAX=BESSELJ(x,y)\n"
#~ "@DESCRIPTION=BESSELJ function returns the Bessel function with @x is "
#~ "where the function is evaluated. @y is the order of the Bessel function, "
#~ "if non-integer it is truncated.\n"
#~ "\n"
#~ "* If @x or @y are not numeric a #VALUE! error is returned.\n"
#~ "* If @y < 0 a #NUM! error is returned.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BESSELJ(0.89,3) equals 0.013974004.\n"
#~ "\n"
#~ "@SEEALSO=BESSELI,BESSELK,BESSELY"
#~ msgstr ""
#~ "@FUNCTION=BESSELJ\n"
#~ "@SYNTAX=BESSELJ(x,y)\n"
#~ "@DESCRIPTION=A função BESSELJ devolve a função bessel em que @x é onde a "
#~ "função é avaliada. @y é a ordem da função bessel, se não for inteiro será "
#~ "truncado.\n"
#~ "\n"
#~ "* Se @x ou @y não forem numéricos é devolvido um erro #VALOR!.\n"
#~ "* Se @y < 0 é devolvido um erro #NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BESSELJ(0.89,3) igual a 0.013974004.\n"
#~ "\n"
#~ "@SEEALSO=BESSELJ,BESSELK,BESSELY"

#~ msgid ""
#~ "@FUNCTION=BESSELY\n"
#~ "@SYNTAX=BESSELY(x,y)\n"
#~ "@DESCRIPTION=BESSELY function returns the Neumann, Weber or Bessel "
#~ "function.\n"
#~ "\n"
#~ "@x is where the function is evaluated. @y is the order of the Bessel "
#~ "function, if non-integer it is truncated.\n"
#~ "\n"
#~ "* If @x or @y are not numeric a #VALUE! error is returned.\n"
#~ "* If @y < 0 a #NUM! error is returned.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BESSELY(4,2) equals 0.215903595.\n"
#~ "\n"
#~ "@SEEALSO=BESSELI,BESSELJ,BESSELK"
#~ msgstr ""
#~ "@FUNCTION=BESSELY\n"
#~ "@SYNTAX=BESSELY(x,y)\n"
#~ "@DESCRIPTION=A função BESSELY devolve a função Neumann, Weber ou Bessel.\n"
#~ "\n"
#~ "@x é onde a função é avaliada. @y é a ordem da função bessel, se não for "
#~ "inteiro será truncado.\n"
#~ "\n"
#~ "* Se @x ou @y não forem numéricos é devolvido um erro #VALOR!.\n"
#~ "* Se @y < 0 é devolvido um erro #NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BESSELY(4,2) igual a 0.215903595.\n"
#~ "\n"
#~ "@SEEALSO=BESSELJ,BESSELK,BESSELY"

#~ msgid ""
#~ "@FUNCTION=ERF\n"
#~ "@SYNTAX=ERF([lower limit,]upper_limit)\n"
#~ "@DESCRIPTION=ERF returns the error function.  With a single argument ERF "
#~ "returns the error function, defined as\n"
#~ "\n"
#~ "\terf(x) = 2/sqrt(pi)* integral from 0 to x of exp(-t*t) dt.\n"
#~ "\n"
#~ "If two arguments are supplied, they are the lower and upper limits of the "
#~ "integral.\n"
#~ "\n"
#~ "* If either @lower_limit or @upper_limit is not numeric a #VALUE! error "
#~ "is returned.\n"
#~ "* This function is upward-compatible with that in Excel. (If two "
#~ "arguments are supplied, Excel will not allow either to be negative.)\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ERF(0.4) equals 0.428392355.\n"
#~ "ERF(1.6448536269515/SQRT(2)) equals 0.90.\n"
#~ "\n"
#~ "The second example shows that a random variable with a normal "
#~ "distribution has a 90 percent chance of falling within approximately "
#~ "1.645 standard deviations of the mean.\n"
#~ "@SEEALSO=ERFC"
#~ msgstr ""
#~ "@FUNCTION=ERF\n"
#~ "@SYNTAX=ERF([limite_inferior,]limite_superior)\n"
#~ "@DESCRIPTION=Com um único argumento ERF devolve a função de erro, "
#~ "definida como\n"
#~ "\n"
#~ "\terf(x) = 2/sqrt(pi)* integral de 0 a x do exp(-t*t) dt.\n"
#~ "\n"
#~ "Se forem dados dois argumentos, serão os limites inferior e superior do "
#~ "integral.\n"
#~ "\n"
#~ "* Se o @limite_inferior ou @limite_superior não for numérico é devolvido "
#~ "um erro #VALOR!.\n"
#~ "* Esta função é compatível ascendentemente com a do Excel. (Se forem "
#~ "dados dois argumentos, o Excel não permitirá que qualquer um seja "
#~ "negativo.) \n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ERF(0.4) igual a 0.428392355.\n"
#~ "ERF(1.6448536269515/SQRT(2)) igual a 0.90.\n"
#~ "\n"
#~ "O segundo exemplo mostra que uma variável aleatória com uma distribuição "
#~ "normal tem uma probabilidade de 90 porcento de ficar entre "
#~ "aproximadamente 1.645 desvios padrão da média.\n"
#~ "@SEEALSO=ERFC"

#~ msgid ""
#~ "@FUNCTION=ERFC\n"
#~ "@SYNTAX=ERFC(x)\n"
#~ "@DESCRIPTION=ERFC function returns the complementary error function, "
#~ "defined as\n"
#~ "\n"
#~ "\t1 - erf(x).\n"
#~ "\n"
#~ "erfc(x) is calculated more accurately than 1 - erf(x) for arguments "
#~ "larger than about 0.5.\n"
#~ "\n"
#~ "* If @x is not numeric a #VALUE! error is returned.  \n"
#~ "@EXAMPLES=\n"
#~ "ERFC(6) equals 2.15197367e-17.\n"
#~ "\n"
#~ "@SEEALSO=ERF"
#~ msgstr ""
#~ "@FUNCTION=ERFC\n"
#~ "@SYNTAX=ERFC(x)\n"
#~ "@DESCRIPTION=A função ERFC devolve a função de erro complementar, "
#~ "definida como\n"
#~ "\n"
#~ "\t1 - erf(x).\n"
#~ "\n"
#~ "erfc(x) é calculado com maior precisão do que 1 - erf(x) para argumentos "
#~ "maiores do que cerca de 0.5.\n"
#~ "\n"
#~ "* Se @x não for numérico é devolvido um erro #VALOR!.  \n"
#~ "@EXAMPLES=\n"
#~ "ERFC(6) igual a 2.15197367e-17.\n"
#~ "\n"
#~ "@SEEALSO=ERF"

#~ msgid ""
#~ "@FUNCTION=DELTA\n"
#~ "@SYNTAX=DELTA(x[,y])\n"
#~ "@DESCRIPTION=DELTA function tests for numerical equivalence of two "
#~ "arguments, returning 1 in case of equality.\n"
#~ "\n"
#~ "* @y is optional, and defaults to 0.\n"
#~ "* If either argument is non-numeric returns a #VALUE! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DELTA(42.99,43) equals 0.\n"
#~ "\n"
#~ "@SEEALSO=EXACT,GESTEP"
#~ msgstr ""
#~ "@FUNCTION=DELTA\n"
#~ "@SYNTAX=DELTA(x[,y])\n"
#~ "@DESCRIPTION=A função DELTA testa a equivalência numérica de dois "
#~ "argumentos devolvendo 1 no caso de equivalência.\n"
#~ "\n"
#~ "* @y é opcional, e por omissão é 0.\n"
#~ "* Se qualquer um dos argumentos não for numérico é devolvido um erro "
#~ "#VALOR!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DELTA(42.99,43) igual a 0.\n"
#~ "\n"
#~ "@SEEALSO=EXACT,GESTEP"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=GESTEP\n"
#~ "@SYNTAX=GESTEP(x[,y])\n"
#~ "@DESCRIPTION=GESTEP function tests if @x is >= @y, returning 1 if it is "
#~ "so, and 0 otherwise. @y is optional, and defaults to 0.\n"
#~ "\n"
#~ "* If either argument is non-numeric returns a #VALUE! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "@EXAMPLES=\n"
#~ "GESTEP(5,4) equals 1.\n"
#~ "\n"
#~ "@SEEALSO=DELTA"
#~ msgstr ""
#~ "@FUNCTION=GESTEP\n"
#~ "@SYNTAX=GESTEP(x[,y])\n"
#~ "@DESCRIPTION=A função GESTEP testa se @x é >= @y, devolvendo 1 se o for, "
#~ "e 0 caso contrário. @y é opcional, e o valor por omissão é 0.\n"
#~ "\n"
#~ "* Se qualquer um dos argumentos não for numérico é devolvido um erro "
#~ "#VALOR!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "@EXAMPLES=\n"
#~ "GESTEP(5,4) igual a 1.\n"
#~ "\n"
#~ "@SEEALSO=DELTA"

#~ msgid ""
#~ "@FUNCTION=ACCRINT\n"
#~ "@SYNTAX=ACCRINT(issue,first_interest,settlement,rate,par,frequency[,"
#~ "basis])\n"
#~ "@DESCRIPTION=ACCRINT calculates the accrued interest for a security that "
#~ "pays periodic interest.\n"
#~ "\n"
#~ "@issue is the issue date of the security.  @first_interest is the first "
#~ "interest date of the security.  @settlement is the settlement date of the "
#~ "security.  The settlement date is always after the issue date (the date "
#~ "when the security is bought). @rate is the annual rate of the security "
#~ "and @par is the par value of the security. @frequency is the number of "
#~ "coupon payments per year.\n"
#~ "\n"
#~ "Allowed frequencies are:\n"
#~ "  1 = annual,\n"
#~ "  2 = semi,\n"
#~ "  4 = quarterly.\n"
#~ "\n"
#~ "@basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @issue date, @first_interest date, or @settlement date is not valid, "
#~ "ACCRINT returns #NUM! error.\n"
#~ "* The dates must be @issue < @first_interest < @settlement, or ACCRINT "
#~ "returns #NUM! error.\n"
#~ "* If @rate <= 0 or @par <= 0 , ACCRINT returns #NUM! error.\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis < 0 or @basis > 4, ACCRINT returns #NUM! error.\n"
#~ "* If @issue date is after @settlement date or they are the same, ACCRINT "
#~ "returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=ACCRINTM"
#~ msgstr ""
#~ "@FUNCTION=ACCRINT\n"
#~ "@SYNTAX=ACCRINT(emissão,primeiro_juro,acordo,rácio,par,frequência[,"
#~ "base])\n"
#~ "@DESCRIPTION=ACCRINT calcula o resultado dos juros de uma obrigação que "
#~ "paga juros periodicamente.\n"
#~ "\n"
#~ "@emissão é a data de emissão da obrigação. @primeiro_juro é a data do "
#~ "primeiro juro da obrigação. @acordo é a data acordada de pagamento da "
#~ "obrigação. A data de acordo é sempre posterior à data de emissão (a data "
#~ "em que a obrigação é adquirida). @rácio é a taxa anual da obrigação e "
#~ "@par é o valor nominal da obrigação. @frequência é o número de "
#~ "amortizações por ano.\n"
#~ "\n"
#~ "Frequências permitidas são:\n"
#~ "  1 = anual,\n"
#~ "  2 = semestral,\n"
#~ "  4 = trimestral.\n"
#~ "\n"
#~ "@base é o tipo de sistema de contagem de dias que deseja utilizar:\n"
#~ "\n"
#~ "  0  30/360 EUA\n"
#~ "  1  dias reais/dias reais\n"
#~ "  2  dias reais/360\n"
#~ "  3  dias reais/365\n"
#~ "  4  30/360 Europeu\n"
#~ "\n"
#~ "* Se @data_emissão, a data de @primeira_emissão, ou a data de @acordo não "
#~ "forem válidas, ACCRINT devolve o erro #NUM!.\n"
#~ "* As datas têm de ser @emissão < @primeiro_juro < @acordo, ou ACCRINT "
#~ "devolve o erro #NUM!.\n"
#~ "* Se @rácio <= 0 ou @par <= 0 , ACCRINT devolve o erro #NUM!.\n"
#~ "* Se @base for omitida, é aplicado o 30/360 EUA.\n"
#~ "* Se @base < 0 ou @base > 4, ACCRINT devolve o erro #NUM!.\n"
#~ "* Se @data_emissão for posterior à data de @acordo ou forem a mesma, "
#~ "ACCRINT devolve o erro #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=ACCRINTM"

#~ msgid ""
#~ "@FUNCTION=ACCRINTM\n"
#~ "@SYNTAX=ACCRINTM(issue,maturity,rate[,par,basis])\n"
#~ "@DESCRIPTION=ACCRINTM calculates and returns the accrued interest for a "
#~ "security from @issue to @maturity date.\n"
#~ "\n"
#~ "@issue is the issue date of the security.  @maturity is the maturity date "
#~ "of the security.  @rate is the annual rate of the security and @par is "
#~ "the par value of the security. If you omit @par, ACCRINTM applies $1,000 "
#~ "instead.  @basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @issue date or @maturity date is not valid, ACCRINTM returns #NUM! "
#~ "error.\n"
#~ "* If @rate <= 0 or @par <= 0, ACCRINTM returns #NUM! error.\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis < 0 or @basis > 4, ACCRINTM returns #NUM! error.\n"
#~ "* If @issue date is after @maturity date or they are the same, ACCRINTM "
#~ "returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=ACCRINT"
#~ msgstr ""
#~ "@FUNCTION=ACCRINTM\n"
#~ "@SYNTAX=ACCRINTM(emissão,maturidade,rácio[,par,base])\n"
#~ "@DESCRIPTION=ACCRINTM calcula e devolve o juro ganho com uma obrigação "
#~ "desde a data de @emissão até à data de @maturidade.\n"
#~ "\n"
#~ "@emissão é a data de emissão da obrigação.  @maturidade é a data de "
#~ "maturidade da obrigação. @rácio é a taxa anual da obrigação e @par é o "
#~ "valor nominal da obrigação. Se @par for omitido, ACCRINTM aplica por "
#~ "omissão $1,000. @base é o tipo de sistema de contagem de dias que deseja "
#~ "utilizar:\n"
#~ "\n"
#~ "  0  30/360 EUA\n"
#~ "  1  dias reais/dias reais\n"
#~ "  2  dias reais/360\n"
#~ "  3  dias reais/365\n"
#~ "  4  30/360 Europeu\n"
#~ "\n"
#~ "* Se @data_emissão ou a data de @maturidade não forem válidas, ACCRINTM "
#~ "devolve o erro #NUM!.\n"
#~ "* Se @rácio <= 0 ou @par <= 0, ACCRINTM devolve o erro #NUM!.\n"
#~ "* Se @base for omitida, é aplicado o 30/360 EUA.\n"
#~ "* Se @base < 0 ou @base > 4, ACCRINTM devolve o erro #NUM!.\n"
#~ "* Se a @data_emissão for posterior à data de @maturidade ou forem a "
#~ "mesma, ACCRINTM devolve o erro #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=ACCRINT"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=INTRATE\n"
#~ "@SYNTAX=INTRATE(settlement,maturity,investment,redemption[,basis])\n"
#~ "@DESCRIPTION=INTRATE calculates and returns the interest rate of a fully "
#~ "vested security.\n"
#~ "\n"
#~ "@settlement is the settlement date of the security.  @maturity is the "
#~ "maturity date of the security. @investment is the price of the security "
#~ "paid at @settlement date and @redemption is the amount to be received at "
#~ "@maturity date.\n"
#~ "\n"
#~ "@basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @settlement date or @maturity date is not valid, INTRATE returns "
#~ "#NUM! error.\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis < 0 or @basis > 4, INTRATE returns #NUM! error.\n"
#~ "* If @settlement date is after @maturity date or they are the same, "
#~ "INTRATE returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "If you had a bond with a settlement date of April 15, 2000, maturity date "
#~ "September 30, 2000, investment of $100,000, redemption value $103,525, "
#~ "using the actual/actual basis, the bond discount rate is:\n"
#~ "=INTRATE(36631, 36799, 100000, 103525, 1) which equals 0.0648 or 6.48%\n"
#~ "@SEEALSO=RECEIVED, DATE"
#~ msgstr ""
#~ "@FUNCTION=INTRATE\n"
#~ "@SYNTAX=INTRATE(acordo,maturidade,investimento,devolução[,base])\n"
#~ "@DESCRIPTION=INTRATE calcula e devolve a taxa de juro de uma obrigação "
#~ "que atinjiu a maturidade.\n"
#~ "\n"
#~ "@acordo é a data acordada para pagamento da obrigação.  @maturidade é a "
#~ "data de maturidade da obrigação. @investimento é o prémio que a obrigação "
#~ "pagou na data de @acordo e @devolução é o montante a ser reembolsado na "
#~ "data de @maturidade.\n"
#~ "\n"
#~ "@base é o tipo de sistema de contagem de dias que deseja utilizar:\n"
#~ "\n"
#~ "  0  30/360 EUA\n"
#~ "  1  dias reais/dias reais\n"
#~ "  2  dias reais/360\n"
#~ "  3  dias reais/365\n"
#~ "  4  30/360 Europeu\n"
#~ "\n"
#~ "* Se as datas de @acordo ou @maturidade não forem válidas, INTRATE "
#~ "devolve o erro #NUM!.\n"
#~ "* Se @base for omitida, será aplicada a 30/360 EUA.\n"
#~ "* Se @base < 0 ou @base > 4, INTRATE devolve o erro #NUM!.\n"
#~ "* Se a data de @cordo for posterior à data de @maturidade ou forem a "
#~ "mesma, INTRATE devolve o erro #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "Se tivesse uma obrigação com uma data de acordo 15 Abril, 2000, data de "
#~ "maturidade 30 Setembro, 2000, investimento de $100,000, valor de "
#~ "devolução de $103,525, utilizando a base actual/actual, a taxa de "
#~ "desconto da obrigação é:\n"
#~ "=INTRATE(36631, 36799, 100000, 103525, 1) o que equivale a 0.0648 ou "
#~ "6.48%\n"
#~ "@SEEALSO=RECEIVED, DATE"

#~ msgid ""
#~ "@FUNCTION=RECEIVED\n"
#~ "@SYNTAX=RECEIVED(settlement,maturity,investment,rate[,basis])\n"
#~ "@DESCRIPTION=RECEIVED calculates and returns the amount to be received at "
#~ "maturity date for a security bond.\n"
#~ "\n"
#~ "@settlement is the settlement date of the security.  @maturity is the "
#~ "maturity date of the security.  The amount of investment is specified in "
#~ "@investment.  @rate is the security's discount rate.\n"
#~ "\n"
#~ "@basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @settlement date or @maturity date is not valid, RECEIVED returns "
#~ "#NUM! error.\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis < 0 or @basis > 4, RECEIVED returns #NUM! error.\n"
#~ "* If @settlement date is after @maturity date or they are the same, "
#~ "RECEIVED returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=INTRATE"
#~ msgstr ""
#~ "@FUNCTION=RECEIVED\n"
#~ "@SYNTAX=RECEIVED(acordo,maturidade,investimento,rácio[,base])\n"
#~ "@DESCRIPTION=RECEIVED calcula e devolve o montante a receber na data de "
#~ "maturidade de uma obrigação.\n"
#~ "\n"
#~ "@acordo é a data em que ficou acordado o pagamento da obrigação.  "
#~ "@maturidade é a data de maturidade da obrigação. O montante investido é "
#~ "indicado em @investimento.  @rácio é a taxa de desconto da obrigação.\n"
#~ "\n"
#~ "@base é o tipo de sistema de contagem de dias que deseja utilizar:\n"
#~ "\n"
#~ "  0  30/360 EUA\n"
#~ "  1  dias reais/dias reais\n"
#~ "  2  dias reais/360\n"
#~ "  3  dias reais/365\n"
#~ "  4  30/360 Europeu\n"
#~ "\n"
#~ "* Se a data de @acordo ou @maturidade não for válida, RECEIVED devolve o "
#~ "erro #NUM!.\n"
#~ "* Se a @base for omitida, é aplicada a 30/360 EUA.\n"
#~ "* Se @base < 0 ou @base > 4, RECEIVED devolve o erro #NUM!.\n"
#~ "* Se a data de @acordo for posterior à data de @maturidade ou forem a "
#~ "mesma, RECEIVED devolve o erro #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=INTRATE"

#~ msgid ""
#~ "@FUNCTION=PRICEDISC\n"
#~ "@SYNTAX=PRICEDISC(settlement,maturity,discount,redemption[,basis])\n"
#~ "@DESCRIPTION=PRICEDISC calculates and returns the price per $100 face "
#~ "value of a security bond.  The security does not pay interest at "
#~ "maturity.\n"
#~ "\n"
#~ "@settlement is the settlement date of the security. @maturity is the "
#~ "maturity date of the security.  @discount is the rate for which the "
#~ "security is discounted.  @redemption is the amount to be received on "
#~ "@maturity date.\n"
#~ "\n"
#~ "@basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @settlement date or @maturity date is not valid, PRICEDISC returns "
#~ "#NUM! error.\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis < 0 or @basis > 4, PRICEDISC returns #NUM! error.\n"
#~ "* If @settlement date is after @maturity date or they are the same, "
#~ "PRICEDISC returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=PRICEMAT"
#~ msgstr ""
#~ "@FUNCTION=PRICEDISC\n"
#~ "@SYNTAX=PRICEDISC(acordo,maturidade,desconto,reembolso[,base])\n"
#~ "@DESCRIPTION=PRICEDISC calcula e devolve o preço por $100 de valor "
#~ "nominal de uma obrigação. A obrigação não paga juros na maturidade.\n"
#~ "\n"
#~ "@acordo é a data em que ficou acordado o pagamento da obrigação. "
#~ "@maturidade é a data de vencimento da obrigação. @desconto é a taxa de "
#~ "desconto da obrigação. @reembolso é o montante a ser recebido na data de "
#~ "@maturidade.\n"
#~ "\n"
#~ "@base é o tipo de sistema de contagem de dias que deseja utilizar:\n"
#~ "\n"
#~ "  0  30/360 EUA\n"
#~ "  1  dias reais/dias reais\n"
#~ "  2  dias reais/360\n"
#~ "  3  dias reais/365\n"
#~ "  4  30/360 Europeu\n"
#~ "\n"
#~ "* Se a data de @acordo ou @maturidade não for válida, PRICEDISC devolve o "
#~ "erro #NUM!.\n"
#~ "* Se @base for omitida, é aplicada 30/360 EUA.\n"
#~ "* Se @base < 0 ou @base > 4, PRICEDISC devolve o erro #NUM!.\n"
#~ "* Se a data de @acordo for posterior à data de @maturidade ou forem a "
#~ "mesma, PRICEDISC devolve o erro #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=PRICEMAT"

#~ msgid ""
#~ "@FUNCTION=PRICEMAT\n"
#~ "@SYNTAX=PRICEMAT(settlement,maturity,issue,rate,yield[,basis])\n"
#~ "@DESCRIPTION=PRICEMAT calculates and returns the price per $100 face "
#~ "value of a security.  The security pays interest at maturity.\n"
#~ "\n"
#~ "@settlement is the settlement date of the security.  @maturity is the "
#~ "maturity date of the security.  @issue is the issue date of the "
#~ "security.  @rate is the discount rate of the security. @yield is the "
#~ "annual yield of the security. @basis is the type of day counting system "
#~ "you want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @settlement date or @maturity date is not valid, PRICEMAT returns "
#~ "#NUM! error.\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis < 0 or @basis > 4, PRICEMAT returns #NUM! error.\n"
#~ "* If @settlement date is after @maturity date or they are the same, "
#~ "PRICEMAT returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=PRICEDISC"
#~ msgstr ""
#~ "@FUNCTION=PRICEMAT\n"
#~ "@SYNTAX=PRICEMAT(acordo,maturidade,emissão,rácio,rendimento[,base])\n"
#~ "@DESCRIPTION=PRICEMAT calcula e devolve o preço por $100 de valor nominal "
#~ "de uma obrigação. A obrigação paga juros na maturidade.\n"
#~ "\n"
#~ "@acordo é a data de acordo da obrigação.  @maturidade é a data de "
#~ "maturidade da obrigação. @emissão é a data de emissão da obrigação.  "
#~ "@rácio é a taxa de desconto da obrigação. @rendimento é o rendimento "
#~ "anual da obrigação. @base é o tipo de sistema de contagem de dias que "
#~ "deseja utilizar:\n"
#~ "\n"
#~ "  0  30/360 EUA\n"
#~ "  1  dias reais/dias reais\n"
#~ "  2  dias reais/360\n"
#~ "  3  dias reais/365\n"
#~ "  4  30/360 Europeu\n"
#~ "\n"
#~ "* Se a data de @acordo ou @maturidade não for válida, PRICEMAT devolve o "
#~ "erro #NUM!.\n"
#~ "* Se a @base for omitida, é aplicada 30/360 EUA.\n"
#~ "* Se @base < 0 ou @base > 4, PRICEMAT devolve o erro #NUM!.\n"
#~ "* Se a data de @acordo for posterior à data de @maturidade ou forem a "
#~ "mesma, PRICEMAT devolve o erro #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=PRICEDISC"

#~ msgid ""
#~ "@FUNCTION=DISC\n"
#~ "@SYNTAX=DISC(settlement,maturity,par,redemption[,basis])\n"
#~ "@DESCRIPTION=DISC calculates and returns the discount rate for a "
#~ "security. @settlement is the settlement date of the security.\n"
#~ "\n"
#~ "@maturity is the maturity date of the security.  @par is the price per "
#~ "$100 face value of the security.  @redemption is the redemption value per "
#~ "$100 face value of the security.\n"
#~ "\n"
#~ "@basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @settlement date or @maturity date is not valid, DISC returns #NUM! "
#~ "error.\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis < 0 or @basis > 4, DISC returns #NUM! error.\n"
#~ "* If @settlement date is after @maturity date or they are the same, DISC "
#~ "returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=DISC\n"
#~ "@SYNTAX=DISC(acordo,maturidade,par,reembolso[,base])\n"
#~ "@DESCRIPTION=DISC calcula e devolve a taxa de desconto de uma obrigação. "
#~ "@acordo é a data de acordo de uma obrigação.\n"
#~ "\n"
#~ "@maturidade é a data de maturidade de uma obrigação. @par é o preço por "
#~ "cada €100 de valor nominal de uma obrigação. @reembolso é o valor de "
#~ "reembolso por cada €100 de valor nominal da obrigação.\n"
#~ "\n"
#~ "@base é o tipo de sistema de contagem de dias a utilizar:\n"
#~ "\n"
#~ "  0  30/360 EUA\n"
#~ "  1  dias reais/dias reais\n"
#~ "  2  dias reais/360\n"
#~ "  3  dias reais/365\n"
#~ "  4  30/360 Europeu\n"
#~ "\n"
#~ "* Se a data de @acordo ou @maturidade não for válida, DISC devolve o erro "
#~ "#NUM!.\n"
#~ "* Se a @base for omitida, é aplicada 30/360 EUA.\n"
#~ "* Se a @base < 0 ou @base > 4, DISC devolve o erro #NUM!.\n"
#~ "* Se a data de @acordo for posterior à de @maturidade ou forem a mesma, "
#~ "DISC devolve o erro #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=EFFECT\n"
#~ "@SYNTAX=EFFECT(r,nper)\n"
#~ "@DESCRIPTION=EFFECT calculates the effective interest rate from a given "
#~ "nominal rate.\n"
#~ "\n"
#~ "Effective interest rate is calculated using this formula:\n"
#~ "\n"
#~ "    (1 + @r / @nper) ^ @nper - 1\n"
#~ "\n"
#~ "where:\n"
#~ "\n"
#~ "@r = nominal interest rate (stated in yearly terms)\n"
#~ "@nper = number of periods used for compounding\n"
#~ "\n"
#~ "* If @rate < 0, EFFECT returns #NUM! error.\n"
#~ "* If @nper <= 0, EFFECT returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "For example credit cards will list an APR (annual percentage rate) which "
#~ "is a nominal interest rate.\n"
#~ "For example if you wanted to find out how much you are actually paying "
#~ "interest on your credit card that states an APR of 19% that is compounded "
#~ "monthly you would type in:\n"
#~ "=EFFECT(.19,12) and you would get .2075 or 20.75%. That is the effective "
#~ "percentage you will pay on your loan.\n"
#~ "@SEEALSO=NOMINAL"
#~ msgstr ""
#~ "@FUNCTION=EFFECT\n"
#~ "@SYNTAX=EFFECT(r,nper)\n"
#~ "@DESCRIPTION=EFFECT calcula a taxa de juro efectiva para uma dada taxa "
#~ "nominal.\n"
#~ "\n"
#~ "A taxa de juro efectiva é calculada utilizando a fórmula:\n"
#~ "\n"
#~ "    (1 + @r / @nper) ^ @nper - 1\n"
#~ "onde:\n"
#~ "\n"
#~ "@r = taxa de juro nominal (especificada anualmente)\n"
#~ "@nper = número de períodos utilizados para a capitalização\n"
#~ "\n"
#~ "* Se @r < 0, EFFECT devolve o erro #NUM!.\n"
#~ "* Se @nper <= 0, EFFECT devolve o erro #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Por exemplo, cartões de crédito indicam uma TNB (Taxa Nominal Bancária) "
#~ "que é uma taxa de juro nominal.\n"
#~ "Se desejasse saber quanto está na realidade a pagar de juros sobre o seu "
#~ "cartão de crédito que especifica uma TNB de 19% que é capitalizada "
#~ "mensalmente, escreveria:\n"
#~ "=EFFECT(.19,12) e obteria .2075 ou 20.75%. Essa é a percentagem efectiva "
#~ "que irá pagar pelo seu empréstimo.\n"
#~ "@SEEALSO=NOMINAL"

#~ msgid ""
#~ "@FUNCTION=NOMINAL\n"
#~ "@SYNTAX=NOMINAL(r,nper)\n"
#~ "@DESCRIPTION=NOMINAL calculates the nominal interest rate from a given "
#~ "effective rate.\n"
#~ "\n"
#~ "Nominal interest rate is given by a formula:\n"
#~ "\n"
#~ "@nper * (( 1 + @r ) ^ (1 / @nper) - 1 )\n"
#~ "where:\n"
#~ "\n"
#~ "@r = effective interest rate\n"
#~ "@nper = number of periods used for compounding\n"
#~ "\n"
#~ "* If @rate < 0, NOMINAL returns #NUM! error.\n"
#~ "* If @nper <= 0, NOMINAL returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=EFFECT"
#~ msgstr ""
#~ "@FUNCTION=NOMINAL\n"
#~ "@SYNTAX=NOMINAL(r,nper)\n"
#~ "@DESCRIPTION=NOMINAL calcula a taxa de juro nominal para uma dada taxa de "
#~ "juro efectiva.\n"
#~ "\n"
#~ "A taxa de juro nominal é dada pela fórmula:\n"
#~ "\n"
#~ "@nper * (( 1 + @r ) ^ (1 / @nper) - 1 )\n"
#~ "where:\n"
#~ "\n"
#~ "@r = taxa de juro efectiva\n"
#~ "@nper = número de períodos utilizados para a capitalização\n"
#~ "\n"
#~ "* Se @r < 0, NOMINAL devolve o erro #NUM!.\n"
#~ "* Se @nper <= 0, NOMINAL devolve o erro #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=EFFECT"

#~ msgid ""
#~ "@FUNCTION=ISPMT\n"
#~ "@SYNTAX=ISPMT(rate,per,nper,pv)\n"
#~ "@DESCRIPTION=ISPMT function returns the interest paid on a given period.\n"
#~ "\n"
#~ "* If @per < 1 or @per > @nper, ISPMT returns #NUM! error. \n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=PV"
#~ msgstr ""
#~ "@FUNCTION=ISPMT\n"
#~ "@SYNTAX=ISPMT(rácio,per,nper,pv)\n"
#~ "@DESCRIPTION=A função ISPMT devolve o juro pago num dado período. \n"
#~ "\n"
#~ "* Se @per < 1 ou @per > @nper, ISPMT devolve o erro #NUM!. \n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=PV"

#~ msgid ""
#~ "@FUNCTION=DB\n"
#~ "@SYNTAX=DB(cost,salvage,life,period[,month])\n"
#~ "@DESCRIPTION=DB calculates the depreciation of an asset for a given "
#~ "period using the fixed-declining balance method.  @cost is the initial "
#~ "value of the asset.  @salvage is the value after the depreciation.\n"
#~ "\n"
#~ "@life is the number of periods overall.  @period is the period for which "
#~ "you want the depreciation to be calculated.  @month is the number of "
#~ "months in the first year of depreciation.\n"
#~ "\n"
#~ "* If @month is omitted, it is assumed to be 12.\n"
#~ "* If @cost = 0, DB returns #NUM! error.\n"
#~ "* If @life <= 0, DB returns #NUM! error.\n"
#~ "* If @salvage / @cost < 0, DB returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=DDB,SLN,SYD"
#~ msgstr ""
#~ "@FUNCTION=DB\n"
#~ "@SYNTAX=DB(custo,residual,vida,período[,mês])\n"
#~ "@DESCRIPTION=DB calcula a depreciação de um activo por um dado período "
#~ "utilizando o método contabilístico de quotas constantes. @custo é o valor "
#~ "inicial do activo. @residual é o valor após a depreciação.\n"
#~ "\n"
#~ "@vida é o número total de períodos. @período é o período para o qual "
#~ "deseja que a depreciação seja calculada. @mês é o número de meses no "
#~ "primeiro ano de depreciação.\n"
#~ "\n"
#~ "* Se @mês for omitido, assume-se que sejam 12.\n"
#~ "* Se @custo = 0, DB devolve o erro #NUM!.\n"
#~ "* Se @vida <= 0, DB devolve o erro #NUM!.\n"
#~ "* Se @residual / @custo < 0, DB devolve o erro #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=DDB,SLN,SYD"

#~ msgid ""
#~ "@FUNCTION=DDB\n"
#~ "@SYNTAX=DDB(cost,salvage,life,period[,factor])\n"
#~ "@DESCRIPTION=DDB returns the depreciation of an asset for a given period "
#~ "using the double-declining balance method or some other similar method "
#~ "you specify.\n"
#~ "\n"
#~ "@cost is the initial value of the asset, @salvage is the value after the "
#~ "last period, @life is the number of periods, @period is the period for "
#~ "which you want the depreciation to be calculated, and @factor is the "
#~ "factor at which the balance declines.\n"
#~ "\n"
#~ "* If @factor is omitted, it is assumed to be two (double-declining "
#~ "balance method).\n"
#~ "* If @life <= 0, DDB returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=SLN,SYD"
#~ msgstr ""
#~ "@FUNCTION=DDB\n"
#~ "@SYNTAX=DDB(custo,residual,vida,período[,factor])\n"
#~ "@DESCRIPTION=DDB devolve a depreciação de um activo para um dado período "
#~ "utilizando o método contabilístico de depreciação progressiva ou outro "
#~ "semelhante que especifique.\n"
#~ "\n"
#~ "@custo é o valor inicial do activo, @residual é o valor após o último "
#~ "período, @vida é o número de períodos, @período é o período para o qual "
#~ "deseja que a depreciação seja calculada, e @factor é o factor de "
#~ "ponderação para a depreciação do activo.\n"
#~ "\n"
#~ "* Se @factor for omitido, assume-se que seja dois (método contabilístico "
#~ "da depreciação-dupla).\n"
#~ "* Se @vida <= 0, DDB devolve o erro #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=SLN,SYD"

#~ msgid ""
#~ "@FUNCTION=SLN\n"
#~ "@SYNTAX=SLN(cost,salvage_value,life)\n"
#~ "@DESCRIPTION=SLN function will determine the straight line depreciation "
#~ "of an asset for a single period.\n"
#~ "\n"
#~ "The formula is:\n"
#~ "\n"
#~ "Depreciation expense = ( @cost - @salvage_value ) / @life\n"
#~ "\n"
#~ "@cost is the cost of an asset when acquired (market value).\n"
#~ "@salvage_value is the amount you get when asset is sold at the end of the "
#~ "asset's useful life.\n"
#~ "@life is the anticipated life of an asset.\n"
#~ "\n"
#~ "* If @life <= 0, SLN returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "For example, lets suppose your company purchases a new machine for "
#~ "$10,000, which has a salvage value of $700 and will have a useful life of "
#~ "10 years. The SLN yearly depreciation is computed as follows:\n"
#~ "=SLN(10000, 700, 10)\n"
#~ "This will return the yearly depreciation figure of $930.\n"
#~ "@SEEALSO=SYD"
#~ msgstr ""
#~ "@FUNCTION=SLN\n"
#~ "@SYNTAX=SLN(custo,valor_residual,vida)\n"
#~ "@DESCRIPTION=A função SLN determina a depreciação em linha recta de um "
#~ "activo para um único período.\n"
#~ "\n"
#~ "A fórmula é:\n"
#~ "\n"
#~ "Custo de Depreciação = ( @custo - @valor_residual ) / @vida\n"
#~ "\n"
#~ "@custo é o custo de um activo quando adquirido (valor de mercado).\n"
#~ "@valor_residual é o montante que se obtém quando o activo é vendido no "
#~ "final da sua vida útil.\n"
#~ "@vida é o tempo de vida útil de um activo.\n"
#~ "\n"
#~ "* Se @vida <= 0, SLN devolve o erro #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Por exemplo, imaginemos que a sua empresa compra uma nova máquina por "
#~ "€10,000, que tem um valor residual de €700 e terá uma vida útil de 10 "
#~ "anos. A depreciação anual SLN é calculada da seguinte forma:\n"
#~ "=SLN(10000, 700, 10)\n"
#~ "Isto irá devolver a depreciação anual no valor de €930.\n"
#~ "@SEEALSO=SYD"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=SYD\n"
#~ "@SYNTAX=SYD(cost,salvage_value,life,period)\n"
#~ "@DESCRIPTION=SYD function calculates the sum-of-years digits depreciation "
#~ "for an asset based on its cost, salvage value, anticipated life and a "
#~ "particular period. This method accelerates the rate of the depreciation, "
#~ "so that more depreciation expense occurs in earlier periods than in later "
#~ "ones. The depreciable cost is the actual cost minus the salvage value. "
#~ "The useful life is the number of periods (typically years) over which the "
#~ "asset is depreciated.\n"
#~ "\n"
#~ "The Formula used for sum-of-years digits depreciation is:\n"
#~ "\n"
#~ "Depreciation expense =\n"
#~ "\n"
#~ "\t ( @cost - @salvage_value ) * (@life - @period + 1) * 2 / @life * "
#~ "(@life + 1).\n"
#~ "\n"
#~ "@cost is the cost of an asset when acquired (market value).\n"
#~ "@salvage_value is the amount you get when asset sold at the end of its "
#~ "useful life.\n"
#~ "@life is the anticipated life of an asset.\n"
#~ "@period is the period for which we need the expense.\n"
#~ "\n"
#~ "* If @life <= 0, SYD returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "For example say a company purchases a new computer for $5000 which has a "
#~ "salvage value of $200, and a useful life of five years. We would use the "
#~ "following to calculate the second year's depreciation using the SYD "
#~ "method:\n"
#~ "=SYD(5000, 200, 5, 2) which returns 1,280.00.\n"
#~ "@SEEALSO=SLN"
#~ msgstr ""
#~ "@FUNCTION=SYD\n"
#~ "@SYNTAX=SYD(custo,valor_residual,vida,período)\n"
#~ "@DESCRIPTION=A função SYD calcula a depreciação acumulada ao final de um "
#~ "número de anos para um activo baseando-se no seu custo, valor residual, "
#~ "vida útil e um período em particular. Este método acelera a taxa de "
#~ "depreciação, por forma a que ocorra uma maior depreciação nos períodos "
#~ "iniciais do que nos seguintes. O custo depreciável é o custo actual menos "
#~ "o valor residual. A vida útil é o número de períodos (tipicamente anos) "
#~ "ao longo dos quais o activo se deprecia.\n"
#~ "\n"
#~ "A Fórmula utilizada pela depreciação de soma de anos é:\n"
#~ "\n"
#~ "Custo de depreciação =\n"
#~ "\n"
#~ "\t ( @custo - @valor_residual ) * (@vida - @período + 1) * 2 / @vida * "
#~ "(@vida + 1).\n"
#~ "\n"
#~ "@custo é o custo de um activo quando adquirido (valor de mercado).\n"
#~ "@valor_resídual é o montante que se obtém quando um activo é vendido no "
#~ "final da sua vida útil.\n"
#~ "@vida é vida útil antecipada de um activo.\n"
#~ "@período é o período para o qual necessitamos do custo.\n"
#~ "\n"
#~ "* Se @life <= 0, SYD devolve o erro #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Por exemplo digamos que a sua empresa comprou um computador novo por "
#~ "€5000 que tem um valor residual de €200, e uma vida útil de cinco anos. "
#~ "Utilizariamos o seguinte para calcular o segundo ano de depreciação "
#~ "utilizando o método SYD:\n"
#~ "=SYD(5000, 200, 5, 2) que devolveria 1,280.00.\n"
#~ "@SEEALSO=SLN"

#~ msgid ""
#~ "@FUNCTION=DOLLARDE\n"
#~ "@SYNTAX=DOLLARDE(fractional_dollar,fraction)\n"
#~ "@DESCRIPTION=DOLLARDE converts a dollar price expressed as a fraction "
#~ "into a dollar price expressed as a decimal number.\n"
#~ "\n"
#~ "@fractional_dollar is the fractional number to be converted. @fraction is "
#~ "the denominator of the fraction.\n"
#~ "\n"
#~ "* If @fraction is non-integer it is truncated.\n"
#~ "* If @fraction <= 0, DOLLARDE returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=DOLLARFR"
#~ msgstr ""
#~ "@FUNCTION=DOLLARDE\n"
#~ "@SYNTAX=DOLLARDE(fracção_dolar,fracção)\n"
#~ "@DESCRIPTION=DOLLARDE converte um valor em dólares expresso como uma "
#~ "fracção num valor em dólares expresso como um número decimal.\n"
#~ "\n"
#~ "@fração_dolar é a fracção numérica a ser convertida. @fracção é o "
#~ "denominador da fracção.\n"
#~ "\n"
#~ "* Se @fracção for um não-inteiro será truncado.\n"
#~ "* Se @fracção <= 0, DOLLARDE devolve o erro #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=DOLLARFR"

#~ msgid ""
#~ "@FUNCTION=DOLLARFR\n"
#~ "@SYNTAX=DOLLARFR(decimal_dollar,fraction)\n"
#~ "@DESCRIPTION=DOLLARFR converts a decimal dollar price into a dollar price "
#~ "expressed as a fraction.\n"
#~ "\n"
#~ "* If @fraction is non-integer it is truncated.\n"
#~ "* If @fraction <= 0, DOLLARFR returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=DOLLARDE"
#~ msgstr ""
#~ "@FUNCTION=DOLLARFR\n"
#~ "@SYNTAX=DOLLARFR(decimal_dolar,fracção)\n"
#~ "@DESCRIPTION=DOLLARFR converte um montante decimal em dólares num "
#~ "montante em dólares expresso como uma fracção. \n"
#~ "\n"
#~ "* Se @fracção não for um inteiro será truncado.\n"
#~ "* Se @fracção <= 0, DOLLARFR devolve o erro #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=DOLLARDE"

#~ msgid ""
#~ "@FUNCTION=MIRR\n"
#~ "@SYNTAX=MIRR(values,finance_rate,reinvest_rate)\n"
#~ "@DESCRIPTION=MIRR function returns the modified internal rate of return "
#~ "for a given periodic cash flow. \n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=NPV"
#~ msgstr ""
#~ "@FUNCTION=MIRR\n"
#~ "@SYNTAX=MIRR(valores,taxa_financeira,taxa_reinvestimento)\n"
#~ "@DESCRIPTION=A função MIRR devolve a taxa de retorno interna modificada "
#~ "para um dado 'cash flow' periódico. \n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=NPV"

#~ msgid ""
#~ "@FUNCTION=TBILLEQ\n"
#~ "@SYNTAX=TBILLEQ(settlement,maturity,discount)\n"
#~ "@DESCRIPTION=TBILLEQ function returns the bond-yield equivalent (BEY) for "
#~ "a treasury bill.  TBILLEQ is equivalent to\n"
#~ "\n"
#~ "\t(365 * @discount) / (360 - @discount * DSM),\n"
#~ "\n"
#~ "where DSM is the days between @settlement and @maturity.\n"
#~ "\n"
#~ "* If @settlement is after @maturity or the @maturity is set to over one "
#~ "year later than the @settlement, TBILLEQ returns #NUM! error.\n"
#~ "* If @discount is negative, TBILLEQ returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=TBILLPRICE,TBILLYIELD"
#~ msgstr ""
#~ "@FUNCTION=TBILLEQ\n"
#~ "@SYNTAX=TBILLEQ(acordo,maturidade,desconto)\n"
#~ "@DESCRIPTION=A função TBILLEQ devolve o equivalente ao juro de uma "
#~ "obrigação (BEY) para um t+itulo do tesouro.  TBILLEQ é equivalente a\n"
#~ "\n"
#~ "\t(365 * @desconto) / (360 - @desconto * DSM),\n"
#~ "\n"
#~ "onde DSM é o número de dias entre @acordo e @maturidade. \n"
#~ "\n"
#~ "* Se @acordo for posterior a @maturidade ou a @maturidade for definida "
#~ "para mais de um ano após o @acordo, TBILLEQ devolve o erro #NUM!.\n"
#~ "* Se @desconto for negativo, TBILLEQ devolve o erro #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=TBILLPRICE,TBILLYIELD"

#~ msgid ""
#~ "@FUNCTION=TBILLPRICE\n"
#~ "@SYNTAX=TBILLPRICE(settlement,maturity,discount)\n"
#~ "@DESCRIPTION=TBILLPRICE function returns the price per $100 value for a "
#~ "treasury bill where @settlement is the settlement date and @maturity is "
#~ "the maturity date of the bill.  @discount is the treasury bill's discount "
#~ "rate.\n"
#~ "\n"
#~ "* If @settlement is after @maturity or the @maturity is set to over one "
#~ "year later than the @settlement, TBILLPRICE returns #NUM! error.\n"
#~ "* If @discount is negative, TBILLPRICE returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=TBILLEQ,TBILLYIELD"
#~ msgstr ""
#~ "@FUNCTION=TBILLPRICE\n"
#~ "@SYNTAX=TBILLPRICE(acordo,maturidade,desconto)\n"
#~ "@DESCRIPTION=A função TBILLPRICE devolve o preço por $100 de valor "
#~ "nominal de um título do tesouro onde @acordo é a data de reembolso e "
#~ "@maturidade a data de maturidade do título.  @desconto é a taxa de "
#~ "desconto do título do tesouro.\n"
#~ "\n"
#~ "* Se @acordo for posterior a @maturidade ou a @maturidade for definida "
#~ "para mais de um ano após o @acordo, TBILLPRICE devolve o erro #NUM!.\n"
#~ "* Se @desconto for negativo, TBILLPRICE devolve o erro #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=TBILLEQ,TBILLYIELD"

#~ msgid ""
#~ "@FUNCTION=TBILLYIELD\n"
#~ "@SYNTAX=TBILLYIELD(settlement,maturity,pr)\n"
#~ "@DESCRIPTION=TBILLYIELD function returns the yield for a treasury bill. "
#~ "@settlement is the settlement date and @maturity is the maturity date of "
#~ "the bill.  @discount is the treasury bill's discount rate.\n"
#~ "\n"
#~ "* If @settlement is after @maturity or the @maturity is set to over one "
#~ "year later than the @settlement, TBILLYIELD returns #NUM! error.\n"
#~ "* If @pr is negative, TBILLYIELD returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=TBILLEQ,TBILLPRICE"
#~ msgstr ""
#~ "@FUNCTION=TBILLYIELD\n"
#~ "@SYNTAX=TBILLYIELD(acordo,maturidade,pr)\n"
#~ "@DESCRIPTION=A função TBILLYIELD devolve o rendimento de um título do "
#~ "tesouro. @acordo é a data de reembolso e maturidade é a data de "
#~ "maturidade do título. @desconto é a taxa de desconto do título do "
#~ "tesouro.\n"
#~ "\n"
#~ "* Se @acordo for após a @maturidade ou a @maturidade for definida para "
#~ "mais de um ano após a data de @acordo, TBILLYIELD devolve o erro #NUM!.\n"
#~ "* Se @pr for negativo, TBILLYIELD devolve o erro #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=TBILLEQ,TBILLPRICE"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=RATE\n"
#~ "@SYNTAX=RATE(nper,pmt,pv[,fv,type,guess])\n"
#~ "@DESCRIPTION=RATE calculates the rate of an investment.\n"
#~ "\n"
#~ "* If @pmt is omitted it defaults to 0\n"
#~ "* If @nper <= 0, RATE returns #NUM! error.\n"
#~ "* If @type != 0 and @type != 1, RATE returns #VALUE! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=PV,FV"
#~ msgstr ""
#~ "@FUNCTION=RATE\n"
#~ "@SYNTAX=RATE(nper,pmt,pv[,fv,tipo,adivinha])\n"
#~ "@DESCRIPTION=RATE calcula a taxa de um investimento.\n"
#~ "\n"
#~ "* Se @nper <= 0, RATE devolve o erro #NUM!.\n"
#~ "* Se @tipo != 0 e @tipo != 1, RATE devolve o erro #VALOR!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=PV,FV"

#~ msgid ""
#~ "@FUNCTION=IRR\n"
#~ "@SYNTAX=IRR(values[,guess])\n"
#~ "@DESCRIPTION=IRR calculates and returns the internal rate of return of an "
#~ "investment.  This function is closely related to the net present value "
#~ "function (NPV).  The IRR is the interest rate for a series of cash flows "
#~ "where the net preset value is zero.\n"
#~ "\n"
#~ "@values contains the series of cash flows generated by the investment.  "
#~ "The payments should occur at regular intervals.  The optional @guess is "
#~ "the initial value used in calculating the IRR.  You do not have to use "
#~ "that, it is only provided for the Excel compatibility.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1:A8 contain the numbers -32432, 5324, "
#~ "7432, 9332, 12324, 4334, 1235, -3422.  Then\n"
#~ "IRR(A1:A8) returns 0.04375. \n"
#~ "@SEEALSO=FV,NPV,PV"
#~ msgstr ""
#~ "@FUNCTION=IRR\n"
#~ "@SYNTAX=IRR(valores[,adivinha])\n"
#~ "@DESCRIPTION=IRR calcula e devolve a taxa interna de retorno de um "
#~ "investimento. Esta função está bastante relacionada com a função de valor "
#~ "actual líquido (NPV). O IRR é a taxa de juro de uma série de 'cash flows' "
#~ "onde o valor actual líquido é zero.\n"
#~ "\n"
#~ "@valores contém a série de 'cash flows' generados pelo investimento. Os "
#~ "pagamentos deverão ocorrer a intervalos regulares. O parâmetro opcional "
#~ "@adivinha é o valor inicial utilizado no cálculo do IRR. Não tem de o "
#~ "utilizar, apenas é disponibilizado para compatibilidade com o Excel.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1:A8 contêm os números -32432, 5324, 7432, "
#~ "9332, 12324, 4334, 1235, -3422.  Então\n"
#~ "IRR(A1:A8) devolve 0.04375. \n"
#~ "@SEEALSO=FV,NPV,PV"

#~ msgid ""
#~ "@FUNCTION=PV\n"
#~ "@SYNTAX=PV(rate,nper,pmt[,fv,type])\n"
#~ "@DESCRIPTION=PV calculates the present value of an investment. @rate is "
#~ "the periodic interest rate, @nper is the number of periods used for "
#~ "compounding. @pmt is the payment made each period, @fv is the future "
#~ "value and @type is when the payment is made.\n"
#~ "\n"
#~ "* If @type = 1 then the payment is made at the beginning of the period.\n"
#~ "* If @type = 0 (or omitted) it is made at the end of each period.\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=FV"
#~ msgstr ""
#~ "@FUNCTION=PV\n"
#~ "@SYNTAX=PV(rácio,nper,pmt[,fv,tipo])\n"
#~ "@DESCRIPTION=PV calcula o valor actual de um investimento. @rácio é a "
#~ "taxa de juro periódica, @nper é o número de períodos utilizados para a "
#~ "capitalização. @pmt é o pagamento realizado a cada período, @fv é o valor "
#~ "futuro e @tipo é quando o pagamento é feito.\n"
#~ "\n"
#~ "* Se @tipo = 1 então o pagamento é feito no início do período.\n"
#~ "* Se @tipo = 0 (ou omitido) é feito no final de cada período.\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=FV"

#~ msgid ""
#~ "@FUNCTION=NPV\n"
#~ "@SYNTAX=NPV(rate,v1,v2,...)\n"
#~ "@DESCRIPTION=NPV calculates the net present value of an investment "
#~ "generating periodic payments.  @rate is the periodic interest rate and "
#~ "@v1, @v2, ... are the periodic payments.  If the schedule of the cash "
#~ "flows are not periodic use the XNPV function. \n"
#~ "@EXAMPLES=\n"
#~ "NPV(0.17,-10000,3340,2941,2493,3233,1732,2932) equals 186.30673.\n"
#~ "\n"
#~ "@SEEALSO=PV,XNPV"
#~ msgstr ""
#~ "@FUNCTION=NPV\n"
#~ "@SYNTAX=NPV(rácio,v1,v2,...)\n"
#~ "@DESCRIPTION=NPV calcula o valor líquido actual de um investimento que "
#~ "gera pagamentos periódicos.  @rácio é a taxa de juro periódica e @v1, "
#~ "@v2, ... são os pagamentos periódicos.  Se o pagamento dos 'cash flows' "
#~ "não for periódico utilize a função XNPV. \n"
#~ "@EXAMPLES=\n"
#~ "NPV(0.17,-10000,3340,2941,2493,3233,1732,2932) igual a 186.30673.\n"
#~ "\n"
#~ "@SEEALSO=PV,XNPV"

#~ msgid ""
#~ "@FUNCTION=XNPV\n"
#~ "@SYNTAX=XNPV(rate,values,dates)\n"
#~ "@DESCRIPTION=XNPV calculates the net present value of an investment.  The "
#~ "schedule of the cash flows is given in @dates array.  The first date "
#~ "indicates the beginning of the payment schedule.  @rate is the interest "
#~ "rate and @values are the payments.\n"
#~ "\n"
#~ "* If @values and @dates contain unequal number of values, XNPV returns "
#~ "the #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=NPV,PV"
#~ msgstr ""
#~ "@FUNCTION=XNPV\n"
#~ "@SYNTAX=XNPV(rácio,valores,datas)\n"
#~ "@DESCRIPTION=XNPV calcula o valor líquido actual de um investimento.  A "
#~ "calendarização dos 'cash flows' é dada pela matriz de @datas.  A primeira "
#~ "data indica o início da calendarização dos pagamentos.  @rácio é a taxa "
#~ "de juro e @valores são os pagamentos. \n"
#~ "\n"
#~ "* Se @valores e @datas contiverem um número desigual de valores, XNPV "
#~ "devolve o erro #NUM!. \n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=NPV,PV"

#~ msgid ""
#~ "@FUNCTION=XIRR\n"
#~ "@SYNTAX=XIRR(values,dates[,guess])\n"
#~ "@DESCRIPTION=XIRR calculates and returns the internal rate of return of "
#~ "an investment that has not necessarily periodic payments.  This function "
#~ "is closely related to the net present value function (NPV and XNPV).  The "
#~ "XIRR is the interest rate for a series of cash flows where the XNPV is "
#~ "zero.\n"
#~ "\n"
#~ "@values contains the series of cash flows generated by the investment.  "
#~ "@dates contains the dates of the payments.  The first date describes the "
#~ "payment day of the initial payment and thus all the other dates should be "
#~ "after this date. The optional @guess is the initial value used in "
#~ "calculating the XIRR.  You do not have to use that, it is only provided "
#~ "for the Excel compatibility.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1:A5 contain the numbers -6000, 2134, 1422, "
#~ "1933, and 1422, and the cells B1:B5 contain the dates \"1999-01-15\", "
#~ "\"1999-04-04\", \"1999-05-09\", \"2000-03-12\", and \"2000-05-1\". Then\n"
#~ "XIRR(A1:A5,B1:B5) returns 0.224838. \n"
#~ "@SEEALSO=IRR,XNPV"
#~ msgstr ""
#~ "@FUNCTION=XIRR\n"
#~ "@SYNTAX=XIRR(valores,datas[,adivinha])\n"
#~ "@DESCRIPTION=XIRR calcula e devolve a taxa interna de retorno de um "
#~ "investimento que não tenha necessariamente pagamentos periódicos.  Esta "
#~ "função está relacionada com a função do valor líquido actual (NPV e "
#~ "XNPV).  O XIRR é a taxa de juro para uma série de 'cash flow' onde o XNPV "
#~ "é zero.\n"
#~ "\n"
#~ "@valores contém a série de 'cash flow' gerados pelo investimento.  @datas "
#~ "contém as datas dos pagamentos.  A primeira data descreve o dia de "
#~ "pagamento do pagamento inicial e assim todas as restantes datas deverão "
#~ "ser posteriores. O valor opcional @adivinha é o valor inicial a utilizar "
#~ "ao calcular o XIRR.  Não tem de o utilizar, é apenas disponibilizado para "
#~ "compatibilidade com o Excel.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1:A5 contêm os números -6000, 2134, 1422, "
#~ "1933, e 1422, e as células B1:B5 contêm as datas \"1999-01-15\", "
#~ "\"1999-04-04\", \"1999-05-09\", \"2000-03-12\", e \"2000-05-1\". Então\n"
#~ "XIRR(A1:A5,B1:B5) devolve 0.224838. \n"
#~ "@SEEALSO=IRR,XNPV"

#~ msgid ""
#~ "@FUNCTION=FV\n"
#~ "@SYNTAX=FV(rate,nper,pmt[,pv,type])\n"
#~ "@DESCRIPTION=FV computes the future value of an investment. This is based "
#~ "on periodic, constant payments and a constant interest rate. The interest "
#~ "rate per period is @rate, @nper is the number of periods in an annuity, "
#~ "@pmt is the payment made each period, @pv is the present value and @type "
#~ "is when the payment is made.\n"
#~ "\n"
#~ "* If @type = 1 then the payment is made at the beginning of the period.\n"
#~ "* If @type = 0 it is made at the end of each period.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=PV,PMT,PPMT"
#~ msgstr ""
#~ "@FUNCTION=FV\n"
#~ "@SYNTAX=FV(rácio,nper,pmt[,pv,tipo])\n"
#~ "@DESCRIPTION=FV calcula o valor futuro de um investimento. Isto é baseado "
#~ "em pagamentos periódicos e constantes e numa taxa de juro constante. A "
#~ "taxa de juro por período é @rácio, @nper é o número de períodos numa "
#~ "anuidade, @pmt é o pagamento efectuado em cada período, @pv é o valor "
#~ "actual e @tipo é quando o pagamento é efectuado.\n"
#~ "\n"
#~ "* Se @tipo = 1 então o pagamento é feito no início do período.\n"
#~ "* Se @tipo = 0 então é feito no final de cada período.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=PV,PMT,PPMT"

#~ msgid ""
#~ "@FUNCTION=PMT\n"
#~ "@SYNTAX=PMT(rate,nper,pv[,fv,type])\n"
#~ "@DESCRIPTION=PMT returns the amount of payment for a loan based on a "
#~ "constant interest rate and constant payments (each payment is equal "
#~ "amount).\n"
#~ "\n"
#~ "@rate is the constant interest rate.\n"
#~ "@nper is the overall number of payments.\n"
#~ "@pv is the present value.\n"
#~ "@fv is the future value.\n"
#~ "@type is the type of the payment: 0 means at the end of the period and 1 "
#~ "means at the beginning of the period.\n"
#~ "\n"
#~ "* If @fv is omitted, Gnumeric assumes it to be zero.\n"
#~ "* If @type is omitted, Gnumeric assumes it to be zero.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=PPMT,PV,FV"
#~ msgstr ""
#~ "@FUNCTION=PMT\n"
#~ "@SYNTAX=PMT(rácio,nper,pv[,fv,tipo])\n"
#~ "@DESCRIPTION=PMT devolve o montante de pagamento de um empréstimo baseado "
#~ "numa taxa de juro contante e pagamentos constantes (cada pagamento de "
#~ "igual montante).\n"
#~ "\n"
#~ "@rácio é a taxa de juro constante.\n"
#~ "@nper é o númro total de pagamentos.\n"
#~ "@pv é o valor actual.\n"
#~ "@fv é o valor futuro.\n"
#~ "@tipo é o tipo de pagamento: 0 significa no final de cada período e 1 "
#~ "significa no início de cada período.\n"
#~ "\n"
#~ "* Se @fv for omitido, Gnumeric assume que seja zero.\n"
#~ "* Se @tipo for omitido, Gnumeric assume que seja zero.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=PPMT,PV,FV"

#~ msgid ""
#~ "@FUNCTION=IPMT\n"
#~ "@SYNTAX=IPMT(rate,per,nper,pv[,fv,type])\n"
#~ "@DESCRIPTION=IPMT calculates the amount of a payment of an annuity going "
#~ "towards interest.\n"
#~ "\n"
#~ "Formula for IPMT is:\n"
#~ "\n"
#~ "IPMT(PER) = -PRINCIPAL(PER-1) * INTEREST_RATE\n"
#~ "\n"
#~ "where:\n"
#~ "\n"
#~ "PRINCIPAL(PER-1) = amount of the remaining principal from last period\n"
#~ "\n"
#~ "* If @fv is omitted, it is assumed to be 0.\n"
#~ "* If @type is omitted, it is assumed to be 0.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=PPMT,PV,FV"
#~ msgstr ""
#~ "@FUNCTION=IPMT\n"
#~ "@SYNTAX=IPMT(rácio,per,nper,pv[,fv,tipo])\n"
#~ "@DESCRIPTION=IPMT calcula o montante de pagamento de uma anuidade que vai "
#~ "no sentido do juro.\n"
#~ "\n"
#~ "A fórmula para IPMT é:\n"
#~ "\n"
#~ "IPMT(PER) = -PRINCIPAL(PER-1) * INTEREST_RATE\n"
#~ "\n"
#~ "onde:\n"
#~ "\n"
#~ "PRINCIPAL(PER-1) = montante do capital remanescente do último período\n"
#~ "\n"
#~ "* Se @fv for omitido, é assumido como sendo 0.\n"
#~ "* Se @tipo for omitido, é assumido como sendo 0.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=PPMT,PV,FV"

#~ msgid ""
#~ "@FUNCTION=PPMT\n"
#~ "@SYNTAX=PPMT(rate,per,nper,pv[,fv,type])\n"
#~ "@DESCRIPTION=PPMT calculates the amount of a payment of an annuity going "
#~ "towards principal.\n"
#~ "\n"
#~ "Formula for it is:\n"
#~ "PPMT(per) = PMT - IPMT(per)\n"
#~ "where:\n"
#~ "\n"
#~ "PMT = Payment received on annuity\n"
#~ "IPMT(per) = amount of interest for period @per\n"
#~ "\n"
#~ "* If @fv is omitted, it is assumed to be 0.\n"
#~ "* If @type is omitted, it is assumed to be 0.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=IPMT,PV,FV"
#~ msgstr ""
#~ "@FUNCTION=PPMT\n"
#~ "@SYNTAX=PPMT(rácio,per,nper,pv[,fv,tipo])\n"
#~ "@DESCRIPTION=PPMT calcula o montante de pagamento de uma anuidade que vai "
#~ "no sentido do capital.\n"
#~ "\n"
#~ "A fórmula utilizada é:\n"
#~ "PPMT(per) = PMT - IPMT(per)\n"
#~ "onde:\n"
#~ "\n"
#~ "PMT = Pagamento recebido na anuidade\n"
#~ "IPMT(per) = montante de juro por período @per\n"
#~ "\n"
#~ "* Se @fv for omitido, é assumido como sendo 0.\n"
#~ "* Se @tipo for omitido, é assumido como sendo 0.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=IPMT,PV,FV"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=NPER\n"
#~ "@SYNTAX=NPER(rate,pmt,pv[,fv,type])\n"
#~ "@DESCRIPTION=NPER calculates number of periods of an investment based on "
#~ "periodic constant payments and a constant interest rate.\n"
#~ "\n"
#~ "The interest rate per period is @rate, @pmt is the payment made each "
#~ "period, @pv is the present value, @fv is the future value and @type is "
#~ "when the payments are due. If @type = 1, payments are due at the "
#~ "beginning of the period, if @type = 0, payments are due at the end of the "
#~ "period.\n"
#~ "\n"
#~ "* If @rate <= 0, NPER returns #DIV0 error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "For example, if you deposit $10,000 in a savings account that earns an "
#~ "interest rate of 6%. To calculate how many years it will take to double "
#~ "your investment use NPER as follows:\n"
#~ "=NPER(0.06, 0, -10000, 20000,0)returns 11.895661046 which indicates that "
#~ "you can double your money just before the end of the 12th year.\n"
#~ "@SEEALSO=PPMT,PV,FV"
#~ msgstr ""
#~ "@FUNCTION=NPER\n"
#~ "@SYNTAX=NPER(rácio,pmt,pv[,fv,tipo])\n"
#~ "@DESCRIPTION=NPER calcula o número de períodos de um investimento baseado "
#~ "em pagamentos periódicos constantes e uma taxa de juro constante.\n"
#~ "\n"
#~ "A taxa de juro por período é @rácio, @pmt é o pagamento efectuado a cada "
#~ "período, @pv é o valor actual, @fv é o valor futuro e @tipo é quando os "
#~ "pagamentos são efectuados. Se @tipo = 1 então o pagamento é feito no "
#~ "início do período. Se @tipo = 0 então é feito no final de cada período.\n"
#~ "\n"
#~ "* Se @rácio <= 0, NPER devolve o erro #DIV0.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Por exemplo, se depositar €10,000 numa conta a prazo que aufere uma taxa "
#~ "de juro de 6%. Para calcular quantos anos levará a duplicar o seu "
#~ "investimento utilize a NPER da seguinte forma:\n"
#~ "=NPER(0.06, 0, -10000, 20000,0) devolve 11.895661046 que significa que "
#~ "pode duplicar o seu dinheiro um pouco antes do 12º ano.\n"
#~ "@SEEALSO=PPMT,PV,FV"

#~ msgid ""
#~ "@FUNCTION=DURATION\n"
#~ "@SYNTAX=DURATION(settlement,maturity,coup,yield,frequency[,basis])\n"
#~ "@DESCRIPTION=DURATION calculates the duration of a security.\n"
#~ "\n"
#~ "@settlement is the settlement date of the security.\n"
#~ "@maturity is the maturity date of the security.\n"
#~ "@coup The annual coupon rate as a percentage.\n"
#~ "@yield The annualized yield of the security as a percentage.\n"
#~ "@frequency is the number of coupon payments per year. Allowed frequencies "
#~ "are: 1 = annual, 2 = semi, 4 = quarterly. @basis is the type of day "
#~ "counting system you want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @frequency is other than 1, 2, or 4, DURATION returns #NUM! error.\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis is not in between 0 and 4, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=G_DURATION,MDURATION"
#~ msgstr ""
#~ "@FUNCTION=DURATION\n"
#~ "@SYNTAX=DURATION(acordo,maturidade,cupão,dividendo,freq[,base])\n"
#~ "@DESCRIPTION=DURATION calcula a duração de uma obrigação.\n"
#~ "\n"
#~ "@acordo é a data de acordo da obrigação.\n"
#~ "@maturidade é a data de maturidade da obrigação.\n"
#~ "@cupão é a taxa de cupão anual como percentagem.\n"
#~ "@dividendo é o dividendo anualizado da obrigação como uma percentagem.\n"
#~ "@freq é o número de pagamentos de cupão por ano. Frequências permitidas "
#~ "são: 1 = anual, 2 = semestral, 4 = trimestral. @base é o tipo de sistema "
#~ "de contagem de dias que deseja utilizar:\n"
#~ "\n"
#~ "  0  30/360 EUA\n"
#~ "  1  dias reais/dias reais\n"
#~ "  2  dias reais/360\n"
#~ "  3  dias reais/365\n"
#~ "  4  30/360 Europeu\n"
#~ "\n"
#~ "* Se @frequência for outra que não 1, 2, ou 4, DURATION devolve o erro "
#~ "#NUM!.\n"
#~ "* Se @base for omitida, 30/360 EUA é aplicada.\n"
#~ "* Se @base não estiver entre 0 e 4, o erro #NUM! é devolvido.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=G_DURATION,MDURATION"

#~ msgid ""
#~ "@FUNCTION=G_DURATION\n"
#~ "@SYNTAX=G_DURATION(rate,pv,fv)\n"
#~ "@DESCRIPTION=G_DURATION calculates number of periods needed for an "
#~ "investment to attain a desired value. This function is similar to FV and "
#~ "PV with a difference that we do not need give the direction of cash flows "
#~ "e.g. -100 for a cash outflow and +100 for a cash inflow.\n"
#~ "\n"
#~ "* If @rate <= 0, G_DURATION returns #DIV0 error.\n"
#~ "* If @fv = 0 or @pv = 0, G_DURATION returns #DIV0 error.\n"
#~ "* If @fv / @pv < 0, G_DURATION returns #VALUE error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=PPMT,PV,FV,DURATION,MDURATION"
#~ msgstr ""
#~ "@FUNCTION=G_DURATION\n"
#~ "@SYNTAX=G_DURATION(rácio,pv,fv)\n"
#~ "@DESCRIPTION=G_DURATION calcula o número de períodos necessários para um "
#~ "investimento obter um determinado valor. Esta função é semelhante à FV e "
#~ "PV com a diferença de que não é necessário indicar a direcção dos 'cash "
#~ "flows' por ex. -100 para uma saída de caixa e +100 para uma entrada em "
#~ "caixa.\n"
#~ "\n"
#~ "* Se @rácio <= 0, G_DURATION devolve o erro #DIV0.\n"
#~ "* Se @fv = 0 or @pv = 0, G_DURATION devolve o erro #DIV0.\n"
#~ "* Se @fv / @pv < 0, G_DURATION devolve o erro #VALOR.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=PPMT,PV,FV,DURATION,MDURATION"

#~ msgid ""
#~ "@FUNCTION=FVSCHEDULE\n"
#~ "@SYNTAX=FVSCHEDULE(principal,schedule)\n"
#~ "@DESCRIPTION=FVSCHEDULE returns the future value of given initial value "
#~ "after applying a series of compound periodic interest rates. The argument "
#~ "@principal is the present value; @schedule is an array of interest rates "
#~ "to apply. The @schedule argument must be a range of cells.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain interest rates 0.11, "
#~ "0.13, 0.09, 0.17, and 0.03.  Then\n"
#~ "FVSCHEDULE(3000,A1:A5) equals 4942.7911611.\n"
#~ "@SEEALSO=PV,FV"
#~ msgstr ""
#~ "@FUNCTION=FVSCHEDULE\n"
#~ "@SYNTAX=FVSCHEDULE(capital,calendarização)\n"
#~ "@DESCRIPTION=FVSCHEDULE devolve o valor futuro de um dado montante "
#~ "inicial após aplicar uma série de taxas de juro compostas periódicas. O "
#~ "argumento @capital é o valor actual; @calendarização é uma matriz de "
#~ "taxas de juro a aplicar. O argumento @calendarização tem de ser uma área "
#~ "de células.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1, A2, ..., A5 contêm as taxas de juro "
#~ "0.11, 0.13, 0.09, 0.17, e 0.03.  Então\n"
#~ "FVSCHEDULE(3000,A1:A5) igual a 4942.7911611.\n"
#~ "@SEEALSO=PV,FV"

#~ msgid ""
#~ "@FUNCTION=EURO\n"
#~ "@SYNTAX=EURO(currency)\n"
#~ "@DESCRIPTION=EURO converts one Euro to a given national currency in the "
#~ "European monetary union.\n"
#~ "\n"
#~ "@currency is one of the following:\n"
#~ "\n"
#~ "    ATS\t(Austria)\n"
#~ "    BEF\t(Belgium)\n"
#~ "    DEM\t(Germany)\n"
#~ "    ESP\t(Spain)\n"
#~ "    EUR\t(Euro)\n"
#~ "    FIM\t(Finland)\n"
#~ "    FRF\t(France)\n"
#~ "    GRD\t(Greek)\n"
#~ "    IEP\t(Ireland)\n"
#~ "    ITL\t(Italy)\n"
#~ "    LUF\t(Luxembourg)\n"
#~ "    NLG\t(Netherlands)\n"
#~ "    PTE\t(Portugal)\n"
#~ "\n"
#~ "* If the given @currency is other than one of the above, EURO returns "
#~ "#NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "EURO(\"DEM\") returns 1.95583.\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=EURO\n"
#~ "@SYNTAX=EURO(moeda)\n"
#~ "@DESCRIPTION=EURO converte um Euro para uma dada moeda nacional da união "
#~ "monetária Europeia.\n"
#~ "\n"
#~ "@moeda é uma das seguintes:\n"
#~ "\n"
#~ "    ATS\t(Austria)\n"
#~ "    BEF\t(Bélgica)\n"
#~ "    DEM\t(Alemanha)\n"
#~ "    ESP\t(Espanha)\n"
#~ "    EUR\t(Euro)\n"
#~ "    FIM\t(Finlândia)\n"
#~ "    FRF\t(França)\n"
#~ "    GRD\t(Grécia)\n"
#~ "    IEP\t(Irlanda)\n"
#~ "    ITL\t(Itália)\n"
#~ "    LUF\t(Luxemburgo)\n"
#~ "    NLG\t(Holanda)\n"
#~ "    PTE\t(Portugal)\n"
#~ "\n"
#~ "* Se a @moeda indicada for outra que não uma das acima, EURO devolve o "
#~ "erro #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "EURO(\"DEM\") devolve 1.95583.\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=EUROCONVERT\n"
#~ "@SYNTAX=EUROCONVERT(n,source,target)\n"
#~ "@DESCRIPTION=EUROCONVERT converts the currency value @n of @source "
#~ "currency to a target currency @target. Both currencies are given as three-"
#~ "letter strings using the ISO code system names.  The following currencies "
#~ "are available:\n"
#~ "\n"
#~ "    ATS\t(Austria)\n"
#~ "    BEF\t(Belgium)\n"
#~ "    DEM\t(Germany)\n"
#~ "    ESP\t(Spain)\n"
#~ "    EUR\t(Euro)\n"
#~ "    FIM\t(Finland)\n"
#~ "    FRF\t(France)\n"
#~ "    GRD\t(Greek)\n"
#~ "    IEP\t(Ireland)\n"
#~ "    ITL\t(Italy)\n"
#~ "    LUF\t(Luxembourg)\n"
#~ "    NLG\t(Netherlands)\n"
#~ "    PTE\t(Portugal)\n"
#~ "\n"
#~ "* If the given @source or @target is other than one of the above, "
#~ "EUROCONVERT returns #VALUE! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "EUROCONVERT(2.1,\"DEM\",\"EUR\") returns 1.07.\n"
#~ "@SEEALSO=EURO"
#~ msgstr ""
#~ "@FUNCTION=EUROCONVERT\n"
#~ "@SYNTAX=EUROCONVERT(n,origem,destino)\n"
#~ "@DESCRIPTION=EUROCONVERT converte o valor moeda @n da moeda @origem para "
#~ "a moeda destino @destino. Ambas as moedas são especificadas como "
#~ "expressões de três letras utilizando a convenção de nomes ISO. Estão "
#~ "disponíveis as seguintes moedas:\n"
#~ "\n"
#~ "    ATS\t(Austria)\n"
#~ "    BEF\t(Bélgica)\n"
#~ "    DEM\t(Alemanha)\n"
#~ "    ESP\t(Espanha)\n"
#~ "    EUR\t(Euro)\n"
#~ "    FIM\t(Finlândia)\n"
#~ "    FRF\t(França)\n"
#~ "    GRD\t(Grécia)\n"
#~ "    IEP\t(Irlanda)\n"
#~ "    ITL\t(Itália)\n"
#~ "    LUF\t(Luxemburgo)\n"
#~ "    NLG\t(Holanda)\n"
#~ "    PTE\t(Portugal)\n"
#~ "\n"
#~ "* Se a @origem ou @destino especificados forem outros que não os acima, "
#~ "EUROCONVERT devolve o erro #VALOR!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "EUROCONVERT(2.1,\"DEM\",\"EUR\") devolve 1.07.\n"
#~ "@SEEALSO=EURO"

#~ msgid ""
#~ "@FUNCTION=CUMIPMT\n"
#~ "@SYNTAX=CUMIPMT(rate,nper,pv,start_period,end_period,type)\n"
#~ "@DESCRIPTION=CUMIPMT returns the cumulative interest paid on a loan "
#~ "between @start_period and @end_period.\n"
#~ "\n"
#~ "* If @rate <= 0, CUMIPMT returns #NUM! error.\n"
#~ "* If @nper <= 0, CUMIPMT returns #NUM! error.\n"
#~ "* If @pv <= 0, CUMIPMT returns #NUM! error.\n"
#~ "* If @start_period < 1, CUMIPMT returns #NUM! error.\n"
#~ "* If @end_period < @start_period, CUMIPMT returns #NUM! error.\n"
#~ "* If @end_period > @nper, CUMIPMT returns #NUM! error.\n"
#~ "* If @type <> 0 and @type <> 1, CUMIPMT returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=CUMIPMT\n"
#~ "@SYNTAX=CUMIPMT(rácio,nper,pv,início_período,fim_período,tipo)\n"
#~ "@DESCRIPTION=CUMIPMT devolve o juro acumulado pago sobre um empréstimo "
#~ "entre @início_período e @fim_período.\n"
#~ "\n"
#~ "* Se @rácio <= 0, CUMIPMT devolve o erro #NUM!.\n"
#~ "* Se @nper <= 0, CUMIPMT devolve o erro #NUM!.\n"
#~ "* Se @pv <= 0, CUMIPMT devolve o erro #NUM!.\n"
#~ "* Se @início_período < 1, CUMIPMT devolve o erro #NUM!.\n"
#~ "* Se @fim_período < @início_período, CUMIPMT devolve o erro #NUM!.\n"
#~ "* Se @fim_período > @nper, CUMIPMT devolve o erro #NUM!.\n"
#~ "* Se @tipo <> 0 e @tipo <> 1, CUMIPMT devolve o erro #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=CUMPRINC\n"
#~ "@SYNTAX=CUMPRINC(rate,nper,pv,start_period,end_period,type)\n"
#~ "@DESCRIPTION=CUMPRINC returns the cumulative principal paid on a loan "
#~ "between @start_period and @end_period.\n"
#~ "\n"
#~ "* If @rate <= 0, CUMPRINC returns #NUM! error.\n"
#~ "* If @nper <= 0, CUMPRINC returns #NUM! error.\n"
#~ "* If @pv <= 0, CUMPRINC returns #NUM! error.\n"
#~ "* If @start_period < 1, CUMPRINC returns #NUM! error.\n"
#~ "* If @end_period < @start_period, CUMPRINC returns #NUM! error.\n"
#~ "* If @end_period > @nper, CUMPRINC returns #NUM! error.\n"
#~ "* If @type <> 0 and @type <> 1, CUMPRINC returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=CUMPRINC\n"
#~ "@SYNTAX=CUMPRINC(rácio,nper,pv,início_período,fim_período,tipo)\n"
#~ "@DESCRIPTION=CUMPRINC devolve a amortização acumulada paga sobre um "
#~ "empréstimo entre @início_período e @fim_período.\n"
#~ "\n"
#~ "* Se @rácio <= 0, CUMIPMT devolve o erro #NUM!.\n"
#~ "* Se @nper <= 0, CUMIPMT devolve o erro #NUM!.\n"
#~ "* Se @pv <= 0, CUMIPMT devolve o erro #NUM!.\n"
#~ "* Se @início_período < 1, CUMIPMT devolve o erro #NUM!.\n"
#~ "* Se @fim_período < @início_período, CUMIPMT devolve o erro #NUM!.\n"
#~ "* Se @fim_período > @nper, CUMIPMT devolve o erro #NUM!.\n"
#~ "* Se @tipo <> 0 e @tipo <> 1, CUMIPMT devolve o erro #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=MDURATION\n"
#~ "@SYNTAX=MDURATION(settlement,maturity,coupon,yield,frequency[,basis])\n"
#~ "@DESCRIPTION=MDURATION returns the Macauley duration for a security with "
#~ "par value 100.\n"
#~ "\n"
#~ "@basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  MSRB 30/360 (MSRB Rule G33 (e))\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "  5  European+ 30/360\n"
#~ "\n"
#~ "* If @settlement or @maturity are not valid dates, MDURATION returns "
#~ "#NUM! error.\n"
#~ "* If @frequency is other than 1, 2, or 4, MDURATION returns #NUM! error.\n"
#~ "* If @basis is omitted, MSRB 30/360 is applied.\n"
#~ "* If @basis is invalid, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=DURATION,G_DURATION"
#~ msgstr ""
#~ "@FUNCTION=MDURATION\n"
#~ "@SYNTAX=MDURATION(acordo,maturidade,emissão,rácio,frequência[,base])\n"
#~ "@DESCRIPTION=MDURATION devolve a duração de Macauley para uma obrigação "
#~ "com o valor nominal 100.\n"
#~ "\n"
#~ "@base é o tipo de sistema de contagem de dias que deseja utilizar:\n"
#~ "\n"
#~ "  0  MSRB 30/360 (MSRB Regra G33 (e))\n"
#~ "  1  dias reais/dias reais\n"
#~ "  2  dias reais/360\n"
#~ "  3  dias reais/365\n"
#~ "  4  Europeu 30/360\n"
#~ "  5  Europeu+ 30/360\n"
#~ "\n"
#~ "* Se @frequência ou @maturidade não forem datas válidas, MDURATION "
#~ "devolve o erro #NUM!.\n"
#~ "* Se @frequência for outra que não 1, 2, ou 4, MDURATION devolve o erro "
#~ "#NUM!.\n"
#~ "* Se @base for omitida, MSBR 30/360 é aplicada.\n"
#~ "* Se @base não estiver entre 0 e 4, o erro #NUM! é devolvido.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=DURATION,G_DURATION"

#~ msgid ""
#~ "@FUNCTION=VDB\n"
#~ "@SYNTAX=VDB(cost,salvage,life,start_period,end_period[,factor,switch])\n"
#~ "@DESCRIPTION=VDB calculates the depreciation of an asset for a given "
#~ "period or partial period using the double-declining balance method.\n"
#~ "\n"
#~ "* If @start_period < 0, VDB returns #NUM! error.\n"
#~ "* If @start_period > @end_period, VDB returns #NUM! error.\n"
#~ "* If @end_period > @life, VDB returns #NUM! error.\n"
#~ "* If @cost < 0, VDB returns #NUM! error.\n"
#~ "* If @salvage > @cost, VDB returns #NUM! error.\n"
#~ "* If @factor <= 0, VDB returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=DB"
#~ msgstr ""
#~ "@FUNCTION=VDB\n"
#~ "@SYNTAX=VDB(custo,resídual,vida,início_período,fim_período[,factor,"
#~ "mudança])\n"
#~ "@DESCRIPTION=VDB calcula a depreciação de um activo por um dado período "
#~ "ou período parcial utilizando o método contabilístico da dupla-"
#~ "declinação.\n"
#~ "\n"
#~ "* Se @início_período < 0, VDB devolve o erro #NUM!.\n"
#~ "* Se @início_período > @fim_período, VDB devolve o erro #NUM!.\n"
#~ "* Se @fim_período > @vida, VDB devolve o erro #NUM!.\n"
#~ "* Se @custo < 0, VDB devolve o erro #NUM!.\n"
#~ "* Se @residual > @custo, VDB devolve o erro #NUM!.\n"
#~ "* Se @factor <= 0, VDB devolve o erro #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=DB"

#~ msgid ""
#~ "@FUNCTION=CELL\n"
#~ "@SYNTAX=CELL(type,ref)\n"
#~ "@DESCRIPTION=CELL returns information about the formatting, location, or "
#~ "contents of a cell.\n"
#~ "\n"
#~ "@type specifies the type of information you want to obtain:\n"
#~ "\n"
#~ "  address    \tReturns the given cell reference as text.\n"
#~ "  col        \t\tReturns the number of the column in @ref.\n"
#~ "  contents   \tReturns the contents of the cell in @ref.\n"
#~ "  format     \t\tReturns the code of the format of the cell.\n"
#~ "  parentheses\tReturns 1 if @ref contains a negative value\n"
#~ "             \t\tand its format displays it with parentheses.\n"
#~ "  row        \t\tReturns the number of the row in @ref.\n"
#~ "  width      \t\tReturns the column width.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Cell(\"format\",A1) returns the code of the format of the cell A1.\n"
#~ "\n"
#~ "@SEEALSO=INDIRECT"
#~ msgstr ""
#~ "@FUNCTION=CELL\n"
#~ "@SYNTAX=CELL(tipo,ref)\n"
#~ "@DESCRIPTION=CELL devolve informação sobre a formatação, localização, ou "
#~ "conteúdo de uma célula.\n"
#~ "\n"
#~ "@tipo especifica o tipo de informação que deseja obter:\n"
#~ "\n"
#~ "  address    \tDevolve a referência da célula especificada como texto.\n"
#~ "  col        \t\tDevolve o número da coluna em @ref.\n"
#~ "  contents   \tDevolve o conteúdo da célula em @ref.\n"
#~ "  format     \t\tDevolve o código do formato da célula.\n"
#~ "  parentheses\tDevolve 1 se @ref contiver um valor negativo\n"
#~ "             \t\te o seu formato o mostrar com parentesis.\n"
#~ "  row        \t\tDevolve o número da linha em @ref.\n"
#~ "  width      \t\tDevolve a largura da coluna.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CEll(\"formato\",A1) devolve o código do formato da célula A1.\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=EXPRESSION\n"
#~ "@SYNTAX=EXPRESSION(cell)\n"
#~ "@DESCRIPTION=EXPRESSION returns expression in @cell as a string, or empty "
#~ "if the cell is not an expression.\n"
#~ "@EXAMPLES=\n"
#~ "entering '=EXPRESSION(A3)' in A2 = empty (assuming there is nothing in "
#~ "A3).\n"
#~ "entering '=EXPRESSION(A2)' in A1 = 'EXPRESSION(A3)'.\n"
#~ "\n"
#~ "@SEEALSO=TEXT"
#~ msgstr ""
#~ "@FUNCTION=EXPRESSION\n"
#~ "@SYNTAX=EXPRESSION(célula)\n"
#~ "@DESCRIPTION=EXPRESSION devolve a expressão em @célula como texto, ou "
#~ "vazio se a célula não contiver uma expressão.\n"
#~ "@EXAMPLES=\n"
#~ "introduzir '=EXPRESSION(A3)' em A2 = empty (assumindo que não existe nada "
#~ "em A3).\n"
#~ "introduzir '=EXPRESSION(A2)' em A1 = 'EXPRESSION(A3)'.\n"
#~ "\n"
#~ "@SEEALSO=TEXT"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=GET.FORMULA\n"
#~ "@SYNTAX=GET.FORMULA(cell)\n"
#~ "@DESCRIPTION=EXPRESSION returns expression in @cell as a string, or empty "
#~ "if the cell is not an expression.\n"
#~ "@EXAMPLES=\n"
#~ "entering '=GET.FORMULA(A3)' in A2 = empty (assuming there is nothing in "
#~ "A3).\n"
#~ "entering '=GET.FORMULA(A2)' in A1 = '=GET.FORMULA(A3)'.\n"
#~ "\n"
#~ "@SEEALSO=EXPRESSION"
#~ msgstr ""
#~ "@FUNCTION=EXPRESSION\n"
#~ "@SYNTAX=EXPRESSION(célula)\n"
#~ "@DESCRIPTION=EXPRESSION devolve a expressão em @célula como texto, ou "
#~ "vazio se a célula não contiver uma expressão.\n"
#~ "@EXAMPLES=\n"
#~ "introduzir '=EXPRESSION(A3)' em A2 = empty (assumindo que não existe nada "
#~ "em A3).\n"
#~ "introduzir '=EXPRESSION(A2)' em A1 = 'EXPRESSION(A3)'.\n"
#~ "\n"
#~ "@SEEALSO=TEXT"

#~ msgid ""
#~ "@FUNCTION=COUNTBLANK\n"
#~ "@SYNTAX=COUNTBLANK(range)\n"
#~ "@DESCRIPTION=COUNTBLANK returns the number of blank cells in a @range.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COUNTBLANK(A1:A20) returns the number of blank cell in A1:A20.\n"
#~ "\n"
#~ "@SEEALSO=COUNT"
#~ msgstr ""
#~ "@FUNCTION=COUNTBLANK\n"
#~ "@SYNTAX=COUNTBLANK(área)\n"
#~ "@DESCRIPTION=COUNTBLANK devolve o número de células em branco numa "
#~ "@área.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COUNTBLANK(A1:A20) devolve o número de células em branco em A1:A20.\n"
#~ "\n"
#~ "@SEEALSO=COUNT"

#~ msgid ""
#~ "@FUNCTION=ISERROR\n"
#~ "@SYNTAX=ISERROR(value)\n"
#~ "@DESCRIPTION=ISERROR returns a TRUE value if the expression has an "
#~ "error.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISERROR(NA()) equals TRUE.\n"
#~ "\n"
#~ "@SEEALSO=ERROR"
#~ msgstr ""
#~ "@FUNCTION=ISERROR\n"
#~ "@SYNTAX=ISERROR(valor)\n"
#~ "@DESCRIPTION=ISERROR devolve um valor VERDADE se a expressão tiver um "
#~ "erro.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISERROR(NA()) igual a VERDADE.\n"
#~ "\n"
#~ "@SEEALSO=ERROR"

#~ msgid ""
#~ "@FUNCTION=ISNA\n"
#~ "@SYNTAX=ISNA(value)\n"
#~ "@DESCRIPTION=ISNA returns TRUE if the value is the #N/A error value.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISNA(NA()) equals TRUE.\n"
#~ "\n"
#~ "@SEEALSO=NA"
#~ msgstr ""
#~ "@FUNCTION=ISNA\n"
#~ "@SYNTAX=ISNA(valor)\n"
#~ "@DESCRIPTION=ISNA devolve VERDADE se o valor for o valor de erro #N/A.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISNA(NA()) igual a VERDADE.\n"
#~ "\n"
#~ "@SEEALSO=NA"

#~ msgid ""
#~ "@FUNCTION=ISERR\n"
#~ "@SYNTAX=ISERR(value)\n"
#~ "@DESCRIPTION=ISERR returns TRUE if the value is any error value except #N/"
#~ "A.\n"
#~ "\n"
#~ "* This function is Excel compatible. \n"
#~ "@EXAMPLES=\n"
#~ "ISERR(NA()) return FALSE.\n"
#~ "\n"
#~ "@SEEALSO=ISERROR"
#~ msgstr ""
#~ "@FUNCTION=ISERR\n"
#~ "@SYNTAX=ISERR(valor)\n"
#~ "@DESCRIPTION=ISERR devolve VERDADE se o valor for um qualquer erro "
#~ "excepto #N/A.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "@EXAMPLES=\n"
#~ "ISERR(NA()) devolve FALSO.\n"
#~ "\n"
#~ "@SEEALSO=ISERROR"

#~ msgid ""
#~ "@FUNCTION=NA\n"
#~ "@SYNTAX=NA()\n"
#~ "@DESCRIPTION=NA returns the error value #N/A.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "NA() equals #N/A error.\n"
#~ "\n"
#~ "@SEEALSO=ISNA"
#~ msgstr ""
#~ "@FUNCTION=NA\n"
#~ "@SYNTAX=NA()\n"
#~ "@DESCRIPTION=NA devolve o valor de erro #N/A.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "NA() igual a erro #N/A.\n"
#~ "\n"
#~ "@SEEALSO=ISNA"

#~ msgid ""
#~ "@FUNCTION=ERROR\n"
#~ "@SYNTAX=ERROR(text)\n"
#~ "@DESCRIPTION=ERROR return the specified error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ERROR(\"#OWN ERROR\").\n"
#~ "\n"
#~ "@SEEALSO=ISERROR"
#~ msgstr ""
#~ "@FUNCTION=ERROR\n"
#~ "@SYNTAX=ERROR(texto)\n"
#~ "@DESCRIPTION=ERROR devolve o erro especificado.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ERROR(\"#PRÓPRIO ERRO\").\n"
#~ "\n"
#~ "@SEEALSO=ISERROR"

#~ msgid ""
#~ "@FUNCTION=ISBLANK\n"
#~ "@SYNTAX=ISBLANK(value)\n"
#~ "@DESCRIPTION=ISBLANK returns TRUE if the value is blank.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISBLANK(A1).\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=ISBLANK\n"
#~ "@SYNTAX=ISBLANK(valor)\n"
#~ "@DESCRIPTION=ISBLANK devolve VERDADE se o valor for vazio.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISBLANK(A1).\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=ISEVEN\n"
#~ "@SYNTAX=ISEVEN(value)\n"
#~ "@DESCRIPTION=ISEVEN returns TRUE if the number is even.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISEVEN(4) equals TRUE.\n"
#~ "\n"
#~ "@SEEALSO=ISODD"
#~ msgstr ""
#~ "@FUNCTION=ISEVEN\n"
#~ "@SYNTAX=ISEVEN(valor)\n"
#~ "@DESCRIPTION=ISEVEN devolve VERDADE se o número for par.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISEVEN(4) devolve VERDADE.\n"
#~ "\n"
#~ "@SEEALSO=ISODD"

#~ msgid ""
#~ "@FUNCTION=ISLOGICAL\n"
#~ "@SYNTAX=ISLOGICAL(value)\n"
#~ "@DESCRIPTION=ISLOGICAL returns TRUE if the value is a logical value.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISLOGICAL(A1).\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=ISLOGICAL\n"
#~ "@SYNTAX=ISLOGICAL(valor)\n"
#~ "@DESCRIPTION=ISLOGICAL devolve VERDADE se o valor for um valor lógico.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISLOGICAL(A1).\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=ISNONTEXT\n"
#~ "@SYNTAX=ISNONTEXT(value)\n"
#~ "@DESCRIPTION=ISNONTEXT Returns TRUE if the value is not text.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISNONTEXT(\"text\") equals FALSE.\n"
#~ "\n"
#~ "@SEEALSO=ISTEXT"
#~ msgstr ""
#~ "@FUNCTION=ISNONTEXT\n"
#~ "@SYNTAX=ISNONTEXT(valor)\n"
#~ "@DESCRIPTION=ISNONTEXT devolve VERDADE se o valor não for texto.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISNONTEXT(\"text\") igual a FALSO.\n"
#~ "\n"
#~ "@SEEALSO=ISTEXT"

#~ msgid ""
#~ "@FUNCTION=ISNUMBER\n"
#~ "@SYNTAX=ISNUMBER(value)\n"
#~ "@DESCRIPTION=ISNUMBER returns TRUE if the value is a number.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISNUMBER(\"text\") equals FALSE.\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=ISNUMBER\n"
#~ "@SYNTAX=ISNUMBER(valor)\n"
#~ "@DESCRIPTION=ISNUMBER devolve VERDADE se o valor for numérico.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISNUMBER(\"texto\") igual a FALSO.\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=ISODD\n"
#~ "@SYNTAX=ISODD(value)\n"
#~ "@DESCRIPTION=ISODD returns TRUE if the number is odd.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISODD(3) equals TRUE.\n"
#~ "\n"
#~ "@SEEALSO=ISEVEN"
#~ msgstr ""
#~ "@FUNCTION=ISODD\n"
#~ "@SYNTAX=ISODD(valor)\n"
#~ "@DESCRIPTION=ISODD devolve VERDADE se o número for impar.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISEVEN(3) devolve VERDADE.\n"
#~ "\n"
#~ "@SEEALSO=ISEVEN"

#~ msgid ""
#~ "@FUNCTION=ISREF\n"
#~ "@SYNTAX=ISREF(value)\n"
#~ "@DESCRIPTION=ISREF returns TRUE if the value is a reference.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISREF(A1) equals TRUE.\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=ISREF\n"
#~ "@SYNTAX=ISREF(valor)\n"
#~ "@DESCRIPTION=ISREF devolve VERDADE se o valor for uma referência.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISREF(A1) igual a VERDADE.\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=ISTEXT\n"
#~ "@SYNTAX=ISTEXT(value)\n"
#~ "@DESCRIPTION=ISTEXT returns TRUE if the value is text.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISTEXT(\"text\") equals TRUE.\n"
#~ "\n"
#~ "@SEEALSO=ISNONTEXT"
#~ msgstr ""
#~ "@FUNCTION=ISTEXT\n"
#~ "@SYNTAX=ISTEXT(valor)\n"
#~ "@DESCRIPTION=ISTEXT devolve VERDADE se o valor for texto.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISTEXT(\"texto\") igual a VERDADE.\n"
#~ "\n"
#~ "@SEEALSO=ISNONTEXT"

#~ msgid ""
#~ "@FUNCTION=N\n"
#~ "@SYNTAX=N(value)\n"
#~ "@DESCRIPTION=N returns a value converted to a number.  Strings containing "
#~ "text are converted to the zero value.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "N(\"42\") equals 42.\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=N\n"
#~ "@SYNTAX=N(valor)\n"
#~ "@DESCRIPTION=N devolve um valor convertido num número. Expressões que "
#~ "contenham texto são convertidas para o valor zero.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "N(\"42\") igual a 42.\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=TYPE\n"
#~ "@SYNTAX=TYPE(value)\n"
#~ "@DESCRIPTION=TYPE returns a number indicating the data type of a value.\n"
#~ "\n"
#~ "1  == number\n"
#~ "2  == text\n"
#~ "4  == boolean\n"
#~ "16 == error\n"
#~ "64 == array\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TYPE(3) equals 1.\n"
#~ "TYPE(\"text\") equals 2.\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=TYPE\n"
#~ "@SYNTAX=TYPE(valor)\n"
#~ "@DESCRIPTION=TYPE devolve um número que indica o tipo de dados do valor.\n"
#~ "\n"
#~ "1  == numérico\n"
#~ "2  == texto\n"
#~ "4  == boleano\n"
#~ "16 == erro\n"
#~ "64 == matriz\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TYPE(3) igual a 1.\n"
#~ "TYPE(\"text\") igual a 2.\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=GETENV\n"
#~ "@SYNTAX=GETENV(string)\n"
#~ "@DESCRIPTION=GETENV retrieves a value from the execution environment.\n"
#~ "\n"
#~ "* If the variable specified by @string does not exist, #N/A! will be "
#~ "returned.  Note, that variable names are case sensitive.\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=GETENV\n"
#~ "@SYNTAX=GETENV(expressão)\n"
#~ "@DESCRIPTION=GETENV obtém um valor do ambiente de execução.\n"
#~ "\n"
#~ "* Se a variável especificada por @expressão não existir, será devolvido "
#~ "#N/A!.  Note que os nomes de variáveis são sensíveis à capitalização.\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=AND\n"
#~ "@SYNTAX=AND(b1, b2, ...)\n"
#~ "@DESCRIPTION=AND implements the logical AND function: the result is TRUE "
#~ "if all of the expressions evaluate to TRUE, otherwise it returns FALSE.\n"
#~ "\n"
#~ "@b1 through @bN are expressions that should evaluate to TRUE or FALSE.  "
#~ "If an integer or floating point value is provided, zero is considered "
#~ "FALSE and anything else is TRUE.\n"
#~ "\n"
#~ "* If the values contain strings or empty cells those values are ignored.\n"
#~ "* If no logical values are provided, then the error #VALUE! is returned.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "AND(TRUE,TRUE) equals TRUE.\n"
#~ "AND(TRUE,FALSE) equals FALSE.\n"
#~ "\n"
#~ "Let us assume that A1 holds number five and A2 number one.  Then\n"
#~ "AND(A1>3,A2<2) equals TRUE.\n"
#~ "\n"
#~ "@SEEALSO=OR, NOT"
#~ msgstr ""
#~ "@FUNCTION=AND\n"
#~ "@SYNTAX=AND(b1, b2, ...)\n"
#~ "@DESCRIPTION=AND implementa a função lógica AND: o resultado é VERDADEIRO "
#~ "se todas as expressões forem avaliadas como VERDADEIRAS, caso contrário "
#~ "devolve FALSO.\n"
#~ "\n"
#~ "@b1, até @bN são expressões que deverão avaliar para VERDADEIRO ou "
#~ "FALSO.  Se um valor inteiro ou de vírgula flutuante for indicado, zero "
#~ "será considerado FALSO e qualquer outro valor VERDADEIRO.\n"
#~ "\n"
#~ "* Se os valores contiverem expressões ou células vazias esses valores "
#~ "serão ignorados.\n"
#~ "* Se não forem indicados valores lógicos, é devolvido o erro #VALOR!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "AND(TRUE,TRUE) igual a TRUE.\n"
#~ "AND(TRUE,FALSE) igual a FALSE.\n"
#~ "\n"
#~ "Vamos assumir que A1 contém o número cinco e A2 o número um.  Então\n"
#~ "AND(A1>3,A2<2) igual a TRUE.\n"
#~ "\n"
#~ "@SEEALSO=OR, NOT"

#~ msgid ""
#~ "@FUNCTION=NOT\n"
#~ "@SYNTAX=NOT(number)\n"
#~ "@DESCRIPTION=NOT implements the logical NOT function: the result is TRUE "
#~ "if the @number is zero;  otherwise the result is FALSE.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "NOT(0) equals TRUE.\n"
#~ "NOT(TRUE) equals FALSE.\n"
#~ "\n"
#~ "@SEEALSO=AND, OR"
#~ msgstr ""
#~ "@FUNCTION=NOT\n"
#~ "@SYNTAX=NOT(número)\n"
#~ "@DESCRIPTION=NOT implementa a função lógica NOT (negação): o resultado é "
#~ "VERDADE se o @número for zero; caso contrário o resultado é FALSO.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "NOT(0) igual a VERDADE.\n"
#~ "NOT(TRUE) igual a FALSO.\n"
#~ "\n"
#~ "@SEEALSO=AND, OR"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OR\n"
#~ "@SYNTAX=OR(b1, b2, ...)\n"
#~ "@DESCRIPTION=OR implements the logical OR function: the result is TRUE if "
#~ "any of the values evaluated to TRUE.\n"
#~ "\n"
#~ "@b1 through @bN are expressions that should evaluate to TRUE or FALSE. If "
#~ "an integer or floating point value is provided, zero is considered FALSE "
#~ "and anything else is TRUE.\n"
#~ "\n"
#~ "* If the values contain strings or empty cells those values are ignored.\n"
#~ "* If no logical values are provided, then the error #VALUE! is returned.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "OR(TRUE,FALSE) equals TRUE.\n"
#~ "OR(3>4,4<3) equals FALSE.\n"
#~ "\n"
#~ "@SEEALSO=AND, NOT"
#~ msgstr ""
#~ "@FUNCTION=OR\n"
#~ "@SYNTAX=OR(b1, b2, ...)\n"
#~ "@DESCRIPTION=OR implementa a função lógica OR: o seu resultado é "
#~ "VERDADEIRO se qualquer um dos valores avaliados for VERDADEIRO.\n"
#~ "\n"
#~ "@b1, até @bN são expressões que deverão ser avaliadas como VERDADEIRO ou "
#~ "FALSO. Se um valor inteiro ou de vírgula flutuante for indicado zero será "
#~ "considerado FALSO e qualquer outro valor será VERDADEIRO.\n"
#~ "\n"
#~ "* Se os valores contiverem expressões ou células vazias esses valores "
#~ "serão ignorados.\n"
#~ "* Se não forem indicados valores lógicos, é devolvido o erro #VALOR!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "OR(TRUE,FALSE) igual a VERDADEIRO.\n"
#~ "OR(3>4,4<3) igual a FALSO.\n"
#~ "\n"
#~ "@SEEALSO=AND, NOT"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=XOR\n"
#~ "@SYNTAX=XOR(b1, b2, ...)\n"
#~ "@DESCRIPTION=XOR implements the logical exclusive OR function: the result "
#~ "is TRUE if an odd number of the values evaluated to TRUE.\n"
#~ "\n"
#~ "@b1 through @bN are expressions that should evaluate to TRUE or FALSE. If "
#~ "an integer or floating point value is provided, zero is considered FALSE "
#~ "and anything else is TRUE.\n"
#~ "\n"
#~ "* If the values contain strings or empty cells those values are ignored.\n"
#~ "* If no logical values are provided, then the error #VALUE! is returned.\n"
#~ "@EXAMPLES=\n"
#~ "XOR(TRUE,FALSE) equals TRUE.\n"
#~ "XOR(3>4,4<3) equals FALSE.\n"
#~ "\n"
#~ "@SEEALSO=OR, AND, NOT"
#~ msgstr ""
#~ "@FUNCTION=XOR\n"
#~ "@SYNTAX=XOR(b1, b2, ...)\n"
#~ "@DESCRIPTION=XOR implementa a função lógica exclusiva OR: o seu resultado "
#~ "é VERDADEIRO se um número ímpar de valores for avaliado como VERDADEIRO.\n"
#~ "\n"
#~ "@b1, até @bN são expressões que deverão ser avaliadas como VERDADEIRO ou "
#~ "FALSO. Se um valor inteiro ou de vírgula flutuante for indicado zero será "
#~ "considerado FALSO e qualquer outro valor será VERDADEIRO.\n"
#~ "\n"
#~ "* Se os valores contiverem expressões ou células vazias esses valores "
#~ "serão ignorados.\n"
#~ "* Se não forem indicados valores lógicos, é devolvido o erro #VALOR!.\n"
#~ "@EXAMPLES=\n"
#~ "XOR(TRUE,FALSE) igual a VERDADEIRO.\n"
#~ "XOR(3>4,4<3) igual a FALSO.\n"
#~ "\n"
#~ "@SEEALSO=OR, AND, NOT"

#~ msgid ""
#~ "@FUNCTION=IF\n"
#~ "@SYNTAX=IF(condition[,if-true,if-false])\n"
#~ "@DESCRIPTION=IF function can be used to evaluate conditionally other "
#~ "expressions. IF evaluates @condition.  If @condition returns a non-zero "
#~ "value the result of the IF expression is the @if-true expression, "
#~ "otherwise IF evaluates to the value of @if-false.\n"
#~ "\n"
#~ "* If omitted @if-true defaults to TRUE and @if-false to FALSE.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IF(FALSE,TRUE,FALSE) equals FALSE.\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=IF\n"
#~ "@SYNTAX=IF(condição[,se-verdade,se-falso])\n"
#~ "@DESCRIPTION=A função IF pode ser utilizada para avaliar condicionalmente "
#~ "outras expressões. IF avalia @condição.  Se @condição devolver um valor "
#~ "não-zero o resultado da expressão IF é a expressão @se-verdade, caso "
#~ "contrário IF devolve o valor de @se-falso.\n"
#~ "\n"
#~ "* Se omitidos, por omissão, @se-verdade é VERDADEIRO e @se-falso é "
#~ "FALSO.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IF(FALSE,TRUE,FALSE) igual a FALSE.\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=TRUE\n"
#~ "@SYNTAX=TRUE()\n"
#~ "@DESCRIPTION=TRUE returns boolean value true.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TRUE() equals TRUE.\n"
#~ "\n"
#~ "@SEEALSO=FALSE"
#~ msgstr ""
#~ "@FUNCTION=TRUE\n"
#~ "@SYNTAX=TRUE()\n"
#~ "@DESCRIPTION=TRUE devolve o valor boleano verdade.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TRUE() igual a VERDADE.\n"
#~ "\n"
#~ "@SEEALSO=FALSE"

#~ msgid ""
#~ "@FUNCTION=FALSE\n"
#~ "@SYNTAX=FALSE()\n"
#~ "@DESCRIPTION=FALSE returns boolean value false.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FALSE() equals FALSE.\n"
#~ "\n"
#~ "@SEEALSO=TRUE"
#~ msgstr ""
#~ "@FUNCTION=FALSE\n"
#~ "@SYNTAX=FALSE()\n"
#~ "@DESCRIPTION=FALSE devolve o valor boleano falso.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FALSE() igual a FALSO.\n"
#~ "\n"
#~ "@SEEALSO=TRUE"

#~ msgid ""
#~ "@FUNCTION=ADDRESS\n"
#~ "@SYNTAX=ADDRESS(row_num,col_num[,abs_num,a1,text])\n"
#~ "@DESCRIPTION=ADDRESS returns a cell address as text for specified row and "
#~ "column numbers.\n"
#~ "\n"
#~ "@a1 is a logical value that specifies the reference style.  If @a1 is "
#~ "TRUE or omitted, ADDRESS returns an A1-style reference, i.e. $D$4.  "
#~ "Otherwise ADDRESS returns an R1C1-style reference, i.e. R4C4.\n"
#~ "\n"
#~ "@text specifies the name of the worksheet to be used as the external "
#~ "reference.\n"
#~ "\n"
#~ "* If @abs_num is 1 or omitted, ADDRESS returns absolute reference.\n"
#~ "* If @abs_num is 2 ADDRESS returns absolute row and relative column.\n"
#~ "* If @abs_num is 3 ADDRESS returns relative row and absolute column.\n"
#~ "* If @abs_num is 4 ADDRESS returns relative reference.\n"
#~ "* If @abs_num is greater than 4 ADDRESS returns #VALUE! error.\n"
#~ "* If @row_num or @col_num is less than one, ADDRESS returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ADDRESS(5,4) equals \"$D$5\".\n"
#~ "ADDRESS(5,4,4) equals \"D5\".\n"
#~ "ADDRESS(5,4,3,FALSE) equals \"R[5]C4\".\n"
#~ "\n"
#~ "@SEEALSO=COLUMNNUMBER"
#~ msgstr ""
#~ "@FUNCTION=ADDRESS\n"
#~ "@SYNTAX=ADDRESS(num_linha,num_coluna[,num_abs,a1,texto])\n"
#~ "@DESCRIPTION=ADDRESS devolve um endereço de célula como texto para um "
#~ "número de linha e coluna especificados.\n"
#~ "\n"
#~ "@a1 é um valor lógico que especifica o estilo de referência.  Se @a1 for "
#~ "VERDADE ou omitido, ADDRESS devolve uma referência estilo-A1, isto é, $D"
#~ "$4.  Caso contrário ADDRESS devolve uma referência estilo-R1C1, isto é, "
#~ "R4C4.\n"
#~ "\n"
#~ "@texto especifica que o nome da folha de trabalho a ser utilizada como "
#~ "referência externa.\n"
#~ "\n"
#~ "* Se @num_abs for 1 ou omitido, ADDRESS devolve uma referência absoluta.\n"
#~ "* Se @num_abs for 2, ADDRESS devolve uma linha absoluta e uma coluna "
#~ "relativa.\n"
#~ "* Se @num_abs for 3, ADDRESS devolve uma linha relativa e uma coluna "
#~ "absoluta.\n"
#~ "* Se @num_abs for 4, ADDRESS devolve uma referência relativa.\n"
#~ "* Se @num_abs for maior do que 4, ADDRESS devolve o erro #VALOR!.\n"
#~ "* Se @num_linha ou @num_coluna for menor do que um, ADDRESS devolve o "
#~ "erro #VALOR!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ADDRESS(5,4) igual a \"$D$5\".\n"
#~ "ADDRESS(5,4,4) igual a \"D5\".\n"
#~ "ADDRESS(5,4,3,FALSE) igual a \"R[5]C4\".\n"
#~ "\n"
#~ "@SEEALSO=COLUMNNUMBER"

#~ msgid ""
#~ "@FUNCTION=AREAS\n"
#~ "@SYNTAX=AREAS(reference)\n"
#~ "@DESCRIPTION=AREAS returns the number of areas in @reference. \n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "AREAS((A1,B2,C3)) equals 3.\n"
#~ "\n"
#~ "@SEEALSO=ADDRESS,INDEX,INDIRECT,OFFSET"
#~ msgstr ""
#~ "@FUNCTION=AREAS\n"
#~ "@SYNTAX=AREAS(referência)\n"
#~ "@DESCRIPTION=AREAS devolve o número de áreas em @referência. \n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "AREAS((A1,B2,C3)) igual a 3.\n"
#~ "\n"
#~ "@SEEALSO=ADDRESS,INDEX,INDIRECT,OFFSET"

#~ msgid ""
#~ "@FUNCTION=CHOOSE\n"
#~ "@SYNTAX=CHOOSE(index[,value1][,value2]...)\n"
#~ "@DESCRIPTION=CHOOSE returns the value of index @index. @index is rounded "
#~ "to an integer if it is not.\n"
#~ "\n"
#~ "* If @index < 1 or @index > number of values, CHOOSE returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CHOOSE(3,\"Apple\",\"Orange\",\"Grape\",\"Perry\") equals \"Grape\".\n"
#~ "\n"
#~ "@SEEALSO=IF"
#~ msgstr ""
#~ "@FUNCTION=CHOOSE\n"
#~ "@SYNTAX=CHOOSE(índice[,valor1][,valor2]...)\n"
#~ "@DESCRIPTION=CHOOSE devolve o valor do índice @índice. @índice é "
#~ "arredondado para inteiro, se o não for.\n"
#~ "\n"
#~ "* Se @índice < 1 ou @índice > número de valores: devolve #VALOR!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CHOOSE(3,\"Maçã\",\"Laranja\",\"Uvas\",\"Peras\") igual a \"Uvas\".\n"
#~ "\n"
#~ "@SEEALSO=IF"

#~ msgid ""
#~ "@FUNCTION=VLOOKUP\n"
#~ "@SYNTAX=VLOOKUP(value,range,column[,approximate,as_index])\n"
#~ "@DESCRIPTION=VLOOKUP function finds the row in range that has a first "
#~ "column similar to @value.  If @approximate is not true it finds the row "
#~ "with an exact equivalence.  If @approximate is true, then the values must "
#~ "be sorted in order of ascending value for correct function; in this case "
#~ "it finds the row with value less than @value.  It returns the value in "
#~ "the row found at a 1-based offset in @column columns into the @range.  "
#~ "@as_index returns the 0-based offset that matched rather than the value.\n"
#~ "\n"
#~ "* VLOOKUP returns #NUM! if @column < 0.\n"
#~ "* VLOOKUP returns #REF! if @column falls outside @range.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=HLOOKUP"
#~ msgstr ""
#~ "@FUNCTION=VLOOKUP\n"
#~ "@SYNTAX=VLOOKUP(valor,área,coluna[,aproximação,como_índice])\n"
#~ "@DESCRIPTION=A função VLOOKUP procura a linha na área que tem uma "
#~ "primeira coluna semelhante a @valor.  Se @aproximação não for verdade "
#~ "procura a linha com uma equivalência exacta.  Se @aproximação for "
#~ "verdade, então os valores têm de estar ordenados por ordem ascendente "
#~ "para que a função funcione correctamente; neste caso procura a linha com "
#~ "um valor menor que @valor.  Devolve o valor na linha encontrada em 1 "
#~ "baseada no deslocamento em @coluna colunas dentro da @área. @como_índice "
#~ "devolve o deslocamento baseado em 0 que correspondeu em vez do valor "
#~ "correspondido em si\n"
#~ "\n"
#~ "* VLOOKUP devolve #NUM! se @coluna < 0.\n"
#~ "* VLOOKUP devolve #REF! se @coluna ficar fora da @área.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=HLOOKUP"

#~ msgid ""
#~ "@FUNCTION=HLOOKUP\n"
#~ "@SYNTAX=HLOOKUP(value,range,row[,approximate,as_index])\n"
#~ "@DESCRIPTION=HLOOKUP function finds the col in range that has a first row "
#~ "cell similar to @value.  If @approximate is not true it finds the col "
#~ "with an exact equivalence.  If @approximate is true, then the values must "
#~ "be sorted in order of ascending value for correct function; in this case "
#~ "it finds the col with value less than @value it returns the value in the "
#~ "col found at a 1-based offset in @row rows into the @range.  @as_index "
#~ "returns the 0-based offset that matched rather than the value.\n"
#~ "\n"
#~ "* HLOOKUP returns #NUM! if @row < 0.\n"
#~ "* HLOOKUP returns #REF! if @row falls outside @range.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=VLOOKUP"
#~ msgstr ""
#~ "@FUNCTION=HLOOKUP\n"
#~ "@SYNTAX=HLOOKUP(valor,área,linha[,aproximação,como_índice])\n"
#~ "@DESCRIPTION=A função HLOOKUP procura a coluna na área que tem uma célula "
#~ "na primeira linha semelhante a @valor.  Se @aproximação não for verdade "
#~ "procura uma coluna com uma equivalência exacta.  Se @aproximação for "
#~ "verdade, então os valores têm de estar ordenados em ordem ascendente para "
#~ "o correcto funcionamento; neste caso procura a coluna com o valor menor "
#~ "que @valor e devolve o valor na coluna encontrada em 1 baseada no "
#~ "deslocamento em @linha linhas dentro da @área.  @como_índice devolve o "
#~ "deslocamento baseado em 0 que correspondeu em vez do valor correspondido "
#~ "em si\n"
#~ "\n"
#~ "* HLOOKUP devolve #NUM! se @linha < 0.\n"
#~ "* HLOOKUP devolve #REF! se @linha ficar fora da @área.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=VLOOKUP"

#~ msgid ""
#~ "@FUNCTION=LOOKUP\n"
#~ "@SYNTAX=LOOKUP(value,vector1[,vector2])\n"
#~ "@DESCRIPTION=LOOKUP function finds the row index of @value in @vector1 "
#~ "and returns the contents of @vector2 at that row index. Alternatively a "
#~ "single array can be used for @vector1. If the area is longer than it is "
#~ "wide then the sense of the search is rotated. \n"
#~ "\n"
#~ "* If LOOKUP can't find @value it uses the largest value less than "
#~ "@value.\n"
#~ "* The data must be sorted.\n"
#~ "* If @value is smaller than the first value it returns #N/A.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=VLOOKUP,HLOOKUP"
#~ msgstr ""
#~ "@FUNCTION=LOOKUP\n"
#~ "@SYNTAX=LOOKUP(valor,vector1[,vector2])\n"
#~ "@DESCRIPTION=A função LOOKUP procura o índice de linha de @valor em "
#~ "@vector1 e devolve o conteúdo de @vector2 nesse índice de linha. "
#~ "Alternativamente pode ser utilizada uma única matriz como @vector1. Se a "
#~ "área for maior em altura que largura a orientação da procura é rodada. \n"
#~ "\n"
#~ "* Se LOOKUP não encontrar @valor utiliza o maior valor seguinte menor do "
#~ "que @valor.\n"
#~ "* Os dados têm de estar ordenados.\n"
#~ "* Se @valor for menor que o primeiro valor é devolvido #N/A.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=VLOOKUP,HLOOKUP"

#~ msgid ""
#~ "@FUNCTION=MATCH\n"
#~ "@SYNTAX=MATCH(seek,vector[,type])\n"
#~ "@DESCRIPTION=MATCH function finds the row index of @seek in @vector and "
#~ "returns it.\n"
#~ "\n"
#~ "If the area is longer than it is wide then the sense of the search is "
#~ "rotated. Alternatively a single array can be used.\n"
#~ "\n"
#~ "* The @type parameter, which defaults to +1, controls the search:\n"
#~ "* If @type = 1, MATCH finds largest value <= @seek.\n"
#~ "* If @type = 0, MATCH finds first value == @seek.\n"
#~ "* If @type = -1, MATCH finds smallest value >= @seek.\n"
#~ "* For @type = 0, the data can be in any order.  * For @type = -1 and "
#~ "@type = +1, the data must be sorted.  (And in these cases, MATCH uses a "
#~ "binary search to locate the index.)\n"
#~ "* If @seek could not be found, #N/A is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=LOOKUP"
#~ msgstr ""
#~ "@FUNCTION=MATCH\n"
#~ "@SYNTAX=MATCH(procurar,vector[,tipo])\n"
#~ "@DESCRIPTION=A função MATCH procura o índice de linha de @procurar em "
#~ "@vector and devolve-o.\n"
#~ "\n"
#~ "Se a área for mais alta do que larga então a orientação da procura é "
#~ "rodada. Alternativamente pode ser utilizada uma matriz de uma coluna.\n"
#~ "\n"
#~ "* O parâmetro @tipo, que é +1 por omissão, controla a procura:\n"
#~ "* Se @tipo = 1, MATCH procura o maior valor <= @procurar.\n"
#~ "* Se @tipo = 0, MATCH procura o primeiro valor == @procurar.\n"
#~ "* Se @tipo = -1, MATCH procura o valor mais pequeno >= @procurar.\n"
#~ "* Para @tipo = 0, os dados podem estar em qualquer ordem.  * Para @tipo = "
#~ "-1 e @tipo = +1, os dados têm de estar ordenados. (E nestes casos, MATCH "
#~ "utiliza uma procura binária para localizar o índice.)\n"
#~ "* Se @procurar não for encontrado, é devolvido #N/A.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=LOOKUP"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=INDIRECT\n"
#~ "@SYNTAX=INDIRECT(ref_text[,format])\n"
#~ "@DESCRIPTION=INDIRECT function returns the contents of the cell pointed "
#~ "to by the @ref_text string. The string specifies a single cell reference "
#~ "the format of which is either A1 or R1C1 style. The boolean @format "
#~ "controls how @ref_text is to be interpreted: TRUE (the default) for A1 "
#~ "style and FALSE for R1C1 style.\n"
#~ "\n"
#~ "* If @ref_text is not a valid reference in the style controlled by "
#~ "@format, returns #REF! \n"
#~ "@EXAMPLES=\n"
#~ "If A1 contains 3.14 and A2 contains \"A1\", then\n"
#~ "INDIRECT(A2) equals 3.14.\n"
#~ "\n"
#~ "If B1 contains 23 and A1 contains \"R1C2\", then\n"
#~ "INDIRECT(A1,FALSE) equals 23.\n"
#~ "@SEEALSO=AREAS,INDEX,CELL"
#~ msgstr ""
#~ "@FUNCTION=INDIRECT\n"
#~ "@SYNTAX=INDIRECT(texto_ref,[formato])\n"
#~ "@DESCRIPTION=A função INDIRECT devolve o conteúdo da célula indicada pela "
#~ "expressão em @texto_ref. A expressão especifica uma referência de célula "
#~ "única e o formato de se é no estilo A1 ou R1C1. O estilo é definido pela "
#~ "boleana @formato, que por omissão é o estilo A1.\n"
#~ "\n"
#~ "* Se @texto_ref não for uma referência válida devolve #REF! \n"
#~ "@EXAMPLES=\n"
#~ "Se A1 contém 3.14 e A2 contém A1, então\n"
#~ "INDIRECT(A2) igual a 3.14.\n"
#~ "\n"
#~ "@SEEALSO=AREAS,INDEX,"

#~ msgid ""
#~ "@FUNCTION=INDEX\n"
#~ "@SYNTAX=INDEX(array[,row, col, area])\n"
#~ "@DESCRIPTION=INDEX gives a reference to a cell in the given @array.The "
#~ "cell is pointed out by @row and @col, which count the rows and columns in "
#~ "the array.\n"
#~ "\n"
#~ "* If @row and @col are omitted the are assumed to be 1.\n"
#~ "* If the reference falls outside the range of the @array, INDEX returns a "
#~ "#REF! error.\n"
#~ "\n"
#~ "@EXAMPLES=Let us assume that the cells A1, A2, ..., A5 contain numbers "
#~ "11.4, 17.3, 21.3, 25.9, and 40.1. Then INDEX(A1:A5,4,1,1) equals 25.9\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=INDEX\n"
#~ "@SYNTAX=INDEX(matriz,[linha, col, área])\n"
#~ "@DESCRIPTION=INDEX dá uma referência para uma célula na @matriz indicada. "
#~ "A célula é indicada pela @linha e @col, que contam as linhas e colunas na "
#~ "matriz.\n"
#~ "\n"
#~ "* Se @linha e @col forem omitidas assume-se que sejam 1.\n"
#~ "* Se a referência ficar fora da área da @matriz, INDEX devolve o erro "
#~ "#REF!.\n"
#~ "\n"
#~ "@EXAMPLES=Vamos assumir que as células A1, A2, ..., A5 contêm os números "
#~ "11.4, 17.3,21.3, 25.9, e 40.1. Então INDEX(A1:A5,4,1,1) igual a 25,9\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=COLUMNNUMBER\n"
#~ "@SYNTAX=COLUMNNUMBER(name)\n"
#~ "@DESCRIPTION=COLUMNNUMBER function returns an integer corresponding to "
#~ "the column name supplied as a string.\n"
#~ "\n"
#~ "* If @name is invalid, COLUMNNUMBER returns the #VALUE! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COLUMNNUMBER(\"E\") equals 5.\n"
#~ "\n"
#~ "@SEEALSO=ADDRESS"
#~ msgstr ""
#~ "@FUNCTION=COLUMNNUMBER\n"
#~ "@SYNTAX=COLUMNNUMBER(nome)\n"
#~ "@DESCRIPTION=A função COLUMNNUMBER devolve um inteiro correspondente à "
#~ "coluna cujo nome foi indicado como expressão.\n"
#~ "\n"
#~ "* Se @nome for inválido, COLUMNNUMBER devolve o erro #VALOR!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COLUMNNUMBER(\"E\") igual a 5.\n"
#~ "\n"
#~ "@SEEALSO=ADDRESS"

#~ msgid ""
#~ "@FUNCTION=COLUMNS\n"
#~ "@SYNTAX=COLUMNS(reference)\n"
#~ "@DESCRIPTION=COLUMNS function returns the number of columns in area or "
#~ "array reference.\n"
#~ "\n"
#~ "* If @reference is neither an array nor a reference nor a range, COLUMNS "
#~ "returns #VALUE! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COLUMNS(H2:J3) equals 3.\n"
#~ "\n"
#~ "@SEEALSO=COLUMN,ROW,ROWS"
#~ msgstr ""
#~ "@FUNCTION=COLUMNS\n"
#~ "@SYNTAX=COLUMNS(referência)\n"
#~ "@DESCRIPTION=A função COLUMNS devolve o número de colunas numa área ou "
#~ "matriz de referência.\n"
#~ "\n"
#~ "* Se @referência não for nem uma matriz nem uma referência nem uma área "
#~ "devolve o erro #VALOR!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COLUMNS(H2:J3) igual a 3.\n"
#~ "\n"
#~ "@SEEALSO=COLUMN,ROW,ROWS"

#~ msgid ""
#~ "@FUNCTION=OFFSET\n"
#~ "@SYNTAX=OFFSET(range,row,col[,height[,width]])\n"
#~ "@DESCRIPTION=OFFSET function returns a cell range. The cell range starts "
#~ "at offset (@row,@col) from @range, and is of height @height and width "
#~ "@width.\n"
#~ "\n"
#~ "* If @range is neither a reference nor a range, OFFSET returns #VALUE!.\n"
#~ "* If either @height or @width is omitted, the height or width of the "
#~ "reference is used.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=COLUMN,COLUMNS,ROWS,INDEX,INDIRECT,ADDRESS"
#~ msgstr ""
#~ "@FUNCTION=OFFSET\n"
#~ "@SYNTAX=OFFSET(área,linha,coluna[,altura[,largura]])\n"
#~ "@DESCRIPTION=A função OFFSET devolve uma área de células. A área de "
#~ "células começa na posição (@coluna,@linha) da @área, e tem a altura "
#~ "@altura e largura @largura.\n"
#~ "\n"
#~ "* Se @área não for nem uma referência nem uma área, OFFSET devolve "
#~ "#VALOR!.\n"
#~ "* Se @altura ou @largura for omitida, é utilizada a altura ou largura da "
#~ "referência.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=COLUMN,COLUMNS,ROWS,INDEX,INDIRECT,ADDRESS"

#~ msgid ""
#~ "@FUNCTION=ROWS\n"
#~ "@SYNTAX=ROWS(reference)\n"
#~ "@DESCRIPTION=ROWS function returns the number of rows in area or array "
#~ "reference.\n"
#~ "\n"
#~ "* If @reference is neither an array nor a reference nor a range, ROWS "
#~ "returns #VALUE! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ROWS(H7:I13) equals 7.\n"
#~ "\n"
#~ "@SEEALSO=COLUMN,COLUMNS,ROW"
#~ msgstr ""
#~ "@FUNCTION=ROWS\n"
#~ "@SYNTAX=ROWS(referência)\n"
#~ "@DESCRIPTION=A função ROWS devolve o número de linhas numa área ou matriz "
#~ "de referência.\n"
#~ "\n"
#~ "* Se @referência não for nem uma matriz nem uma referência nem uma área, "
#~ "ROWS devolve o erro #VALOR!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ROWS(H7:I13) igual a 7.\n"
#~ "\n"
#~ "@SEEALSO=COLUMN,COLUMNS,ROW"

#~ msgid ""
#~ "@FUNCTION=HYPERLINK\n"
#~ "@SYNTAX=HYPERLINK(link_location[,optional_label])\n"
#~ "@DESCRIPTION=HYPERLINK function currently returns its 2nd argument, or if "
#~ "that is omitted the 1st argument.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "HYPERLINK(\"www.gnome.org\",\"GNOME\").\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=HYPERLINK\n"
#~ "@SYNTAX=HYPERLINK(localização_link[,etiqueta_opcional])\n"
#~ "@DESCRIPTION=A função HYPERLINK actualmente devolve o seu segundo "
#~ "argumento, ou se ele for omitido o primeiro argumento.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "HYPERLINK(\"www.gnome.org\",\"GNOME\").\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=TRANSPOSE\n"
#~ "@SYNTAX=TRANSPOSE(matrix)\n"
#~ "@DESCRIPTION=TRANSPOSE function returns the transpose of the input "
#~ "@matrix.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=MMULT"
#~ msgstr ""
#~ "@FUNCTION=TRANSPOSE\n"
#~ "@SYNTAX=TRANSPOSE(matriz)\n"
#~ "@DESCRIPTION=A função TRANSPOSE devolve a transposta da @matriz de "
#~ "entrada.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=MMULT"

#~ msgid ""
#~ "@FUNCTION=GCD\n"
#~ "@SYNTAX=GCD(number1,number2,...)\n"
#~ "@DESCRIPTION=GCD returns the greatest common divisor of given numbers.\n"
#~ "\n"
#~ "* If any of the arguments is less than one, GCD returns #NUM! error.\n"
#~ "* If any of the arguments is non-integer, it is truncated.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "GCD(470,770) equals 10.\n"
#~ "GCD(470,770,1495) equals 5.\n"
#~ "\n"
#~ "@SEEALSO=LCM"
#~ msgstr ""
#~ "@FUNCTION=GCD\n"
#~ "@SYNTAX=GCD(número1,número2,...)\n"
#~ "@DESCRIPTION=GCD devolve o máximo divisor comum dos números indicados.\n"
#~ "\n"
#~ "* Se qualquer um dos argumentos for menor do que zero, GCD devolve o erro "
#~ "#NUM!.\n"
#~ "* Se qualquer um dos argumentos for não-inteiro, será truncado.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "GCD(470,770) igual a 10.\n"
#~ "GCD(470,770,1495) igual a 5.\n"
#~ "\n"
#~ "@SEEALSO=LCM"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=LCM\n"
#~ "@SYNTAX=LCM(number1,number2,...)\n"
#~ "@DESCRIPTION=LCM returns the least common multiple of integers.  The "
#~ "least common multiple is the smallest positive number that is a multiple "
#~ "of all integer arguments given.\n"
#~ "\n"
#~ "* If any of the arguments is less than one, LCM returns #NUM!.\n"
#~ "* If any of the arguments is non-integer, it is truncated.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LCM(2,13) equals 26.\n"
#~ "LCM(4,7,5) equals 140.\n"
#~ "\n"
#~ "@SEEALSO=GCD"
#~ msgstr ""
#~ "@FUNCTION=LCM\n"
#~ "@SYNTAX=LCM(número1,número2,...)\n"
#~ "@DESCRIPTION=LCM devolve o mínimo múltiplo comum de inteiros. O mínimo "
#~ "múltiplo comun é o menor valor positivo que é um múltiplo de todos os "
#~ "argumentos inteiros indicados.\n"
#~ "\n"
#~ "* Se qualquer um dos argumentos for menor do que um, LCM devolve o erro "
#~ "#NUM!.\n"
#~ "* Se qualquer um dos argumentos for não-inteiro, será truncado.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LCM(2,13) igual a 26.\n"
#~ "LCM(4,7,5) igual a 140.\n"
#~ "\n"
#~ "@SEEALSO=GCD"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=HYPOT\n"
#~ "@SYNTAX=HYPOT(number1,number2,...)\n"
#~ "@DESCRIPTION=HYPOT returns the square root of the sum of the squares of "
#~ "the arguments.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "HYPOT(3,4) equals 5.\n"
#~ "\n"
#~ "@SEEALSO=MIN,MAX"
#~ msgstr ""
#~ "@FUNCTION=ODD\n"
#~ "@SYNTAX=ODD(número)\n"
#~ "@DESCRIPTION=A função ODD devolve o @número arredondado acima até ao "
#~ "inteiro impar mais próximo.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ODD(4.4) igual a 5.\n"
#~ "\n"
#~ "@SEEALSO=EVEN"

#~ msgid ""
#~ "@FUNCTION=ABS\n"
#~ "@SYNTAX=ABS(b1)\n"
#~ "@DESCRIPTION=ABS implements the Absolute Value function:  the result is "
#~ "to drop the negative sign (if present).  This can be done for integers "
#~ "and floating point numbers.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ABS(7) equals 7.\n"
#~ "ABS(-3.14) equals 3.14.\n"
#~ "\n"
#~ "@SEEALSO=CEIL, CEILING, FLOOR, INT, MOD"
#~ msgstr ""
#~ "@FUNCTION=ABS\n"
#~ "@SYNTAX=ABS(b1)\n"
#~ "@DESCRIPTION=ABS implementa a função de Valor Absoluto: o resultado é "
#~ "remover o sinal negativo (se presente). Isto pode ser feito para números "
#~ "inteiros e de vírgula flutuante.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ABS(7) igual a 7.\n"
#~ "ABS(-3.14) igual a 3.14.\n"
#~ "\n"
#~ "@SEEALSO=CEIL, FLOOR"

#~ msgid ""
#~ "@FUNCTION=ACOS\n"
#~ "@SYNTAX=ACOS(x)\n"
#~ "@DESCRIPTION=ACOS function calculates the arc cosine of @x; that is the "
#~ "value whose cosine is @x.\n"
#~ "\n"
#~ "* The value it returns is in radians.\n"
#~ "* If @x falls outside the range -1 to 1, ACOS returns the #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ACOS(0.1) equals 1.470629.\n"
#~ "ACOS(-0.1) equals 1.670964.\n"
#~ "\n"
#~ "@SEEALSO=COS, SIN, DEGREES, RADIANS"
#~ msgstr ""
#~ "@FUNCTION=ACOS\n"
#~ "@SYNTAX=ACOS(x)\n"
#~ "@DESCRIPTION=A função ACOS calcula o arco cosseno de @x; esse é o valor "
#~ "cujo cosseno é @x.\n"
#~ "\n"
#~ "* O valor é devolvido em radianos.\n"
#~ "* Se @x estiver fora do intervalo -1 a 1, ACOS falha e devolve o erro "
#~ "#NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ACOS(0.1) igual a 1.470629.\n"
#~ "ACOS(-0.1) igual a 1.670964.\n"
#~ "\n"
#~ "@SEEALSO=COS, SIN, DEGREES, RADIANS"

#~ msgid ""
#~ "@FUNCTION=ACOSH\n"
#~ "@SYNTAX=ACOSH(x)\n"
#~ "@DESCRIPTION=ACOSH  function  calculates  the inverse hyperbolic cosine "
#~ "of @x; that is the value whose hyperbolic cosine is @x.\n"
#~ "\n"
#~ "* If @x is less than 1.0, ACOSH() returns the #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ " \n"
#~ "@EXAMPLES=\n"
#~ "ACOSH(2) equals 1.31696.\n"
#~ "ACOSH(5.3) equals 2.35183.\n"
#~ "\n"
#~ "@SEEALSO=ACOS, ASINH, DEGREES, RADIANS "
#~ msgstr ""
#~ "@FUNCTION=ACOSH\n"
#~ "@SYNTAX=ACOSH(x)\n"
#~ "@DESCRIPTION=A função ACOSH calcula a hiperbólica inversa do cosseno de "
#~ "@x; esse é o valor cuja hiperbólica do cosseno é @x.\n"
#~ "\n"
#~ "* Se @x for menor do que 1.0, ACOSH() devolve o erro #NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ACOSH(2) igual a 1.31696.\n"
#~ "ACOSH(5.3) igual a 2.35183.\n"
#~ "\n"
#~ "@SEEALSO=ACOS, ASINH, DEGREES, RADIANS "

#~ msgid ""
#~ "@FUNCTION=ASIN\n"
#~ "@SYNTAX=ASIN(x)\n"
#~ "@DESCRIPTION=ASIN function calculates the arc sine of @x; that is the "
#~ "value whose sine is @x.\n"
#~ "\n"
#~ "* If @x falls outside the range -1 to 1, ASIN returns the #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ASIN(0.5) equals 0.523599.\n"
#~ "ASIN(1) equals 1.570797.\n"
#~ "\n"
#~ "@SEEALSO=SIN, COS, ASINH, DEGREES, RADIANS"
#~ msgstr ""
#~ "@FUNCTION=ASIN\n"
#~ "@SYNTAX=ASIN(x)\n"
#~ "@DESCRIPTION=A função ASIN calcula o arco do seno de @x; esse é o valor "
#~ "cujo seno é @x.\n"
#~ "\n"
#~ "* Se @x estiver fora do intervalo -1 a 1, ASIN falha e devolve o erro "
#~ "#NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ASIN(0.5) igual a 0.523599.\n"
#~ "ASIN(1) igual a 1.570797.\n"
#~ "\n"
#~ "@SEEALSO=SIN, COS, ASINH, DEGREES, RADIANS"

#~ msgid ""
#~ "@FUNCTION=ASINH\n"
#~ "@SYNTAX=ASINH(x)\n"
#~ "@DESCRIPTION=ASINH function calculates the inverse hyperbolic sine of @x; "
#~ "that is the value whose hyperbolic sine is @x.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ASINH(0.5) equals 0.481212.\n"
#~ "ASINH(1.0) equals 0.881374.\n"
#~ "\n"
#~ "@SEEALSO=ASIN, ACOSH, SIN, COS, DEGREES, RADIANS"
#~ msgstr ""
#~ "@FUNCTION=ASINH\n"
#~ "@SYNTAX=ASINH(x)\n"
#~ "@DESCRIPTION=A função ASINH calcula o seno hiperbólico inverso de @x; "
#~ "isto é o valor cujo seno hiperbólico é @x.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ASINH(0.5) igual a 0.481212.\n"
#~ "ASINH(1.0) igual a 0.881374.\n"
#~ "\n"
#~ "@SEEALSO=ASIN, ACOSH, SIN, COS, DEGREES, RADIANS"

#~ msgid ""
#~ "@FUNCTION=ATAN\n"
#~ "@SYNTAX=ATAN(x)\n"
#~ "@DESCRIPTION=ATAN function calculates the arc tangent of @x; that is the "
#~ "value whose tangent is @x.\n"
#~ "\n"
#~ "* Return value is in radians.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ATAN(0.5) equals 0,463648.\n"
#~ "ATAN(1) equals 0,785398.\n"
#~ "\n"
#~ "@SEEALSO=TAN, COS, SIN, DEGREES, RADIANS"
#~ msgstr ""
#~ "@FUNCTION=ATAN\n"
#~ "@SYNTAX=ATAN(x)\n"
#~ "@DESCRIPTION=A função ATAN calcula o arco tangente de @x; isto é o valor "
#~ "cuja tangente é @x.\n"
#~ "\n"
#~ "* Devolve o valor em radianos.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ATAN(0.5) igual a 0,463648.\n"
#~ "ATAN(1) igual a 0,785398.\n"
#~ "\n"
#~ "@SEEALSO=TAN, COS, SIN, DEGREES, RADIANS"

#~ msgid ""
#~ "@FUNCTION=ATANH\n"
#~ "@SYNTAX=ATANH(x)\n"
#~ "@DESCRIPTION=ATANH function calculates the inverse hyperbolic tangent of "
#~ "@x; that is the value whose hyperbolic tangent is @x.\n"
#~ "\n"
#~ "* If the absolute value of @x is greater than 1.0, ATANH returns #NUM! "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ATANH(0.5) equals 0.549306.\n"
#~ "ATANH(0.8) equals 1.098612.\n"
#~ "\n"
#~ "@SEEALSO=ATAN, TAN, SIN, COS, DEGREES, RADIANS"
#~ msgstr ""
#~ "@FUNCTION=ATANH\n"
#~ "@SYNTAX=ATANH(x)\n"
#~ "@DESCRIPTION=A função ATANH calcula a tangente hiperbólica inversa de @x; "
#~ "esse é o valor cuja tangente hiperbólica é @x.\n"
#~ "\n"
#~ "* Se o valor absoluto de @x for maior do que 1.0, ATANH devolve o erro "
#~ "#NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ATANH(0.5) igual a 0.549306.\n"
#~ "ATANH(0.8) igual a 1.098612.\n"
#~ "\n"
#~ "@SEEALSO=ATAN, TAN, SIN, COS, DEGREES, RADIANS"

#~ msgid ""
#~ "@FUNCTION=ATAN2\n"
#~ "@SYNTAX=ATAN2(b1,b2)\n"
#~ "@DESCRIPTION=ATAN2 function calculates the arc tangent of the two "
#~ "variables @b1 and @b2.  It is similar to calculating the arc tangent of "
#~ "@b2 / @b1, except that the signs of both arguments are used to determine "
#~ "the quadrant of the result.\n"
#~ "\n"
#~ "* The result is in radians.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ATAN2(0.5,1.0) equals 1.107149.\n"
#~ "ATAN2(-0.5,2.0) equals 1.815775.\n"
#~ "\n"
#~ "@SEEALSO=ATAN, ATANH, COS, SIN, DEGREES, RADIANS"
#~ msgstr ""
#~ "@FUNCTION=ATAN2\n"
#~ "@SYNTAX=ATAN2(b1,b2)\n"
#~ "@DESCRIPTION=A função ATAN2 calcula o arco da tangente das duas variáveis "
#~ "@b1 e @b2. É semelhante a calcular o arco tangente de @b2 / @b1, excepto "
#~ "que os sinais de ambos os argumentos são utilizados para determinar o "
#~ "quadrante do resultado.\n"
#~ "\n"
#~ "* O resultado é em radianos.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ATAN2(0.5,1.0) igual a 1.107149.\n"
#~ "ATAN2(-0.5,2.0) igual a 1.815775.\n"
#~ "\n"
#~ "@SEEALSO=ATAN, ATANH, COS, SIN, DEGREES, RADIANS"

#~ msgid ""
#~ "@FUNCTION=CEIL\n"
#~ "@SYNTAX=CEIL(x)\n"
#~ "@DESCRIPTION=CEIL function rounds @x up to the next nearest integer.\n"
#~ "\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CEIL(0.4) equals 1.\n"
#~ "CEIL(-1.1) equals -1.\n"
#~ "CEIL(-2.9) equals -2.\n"
#~ "\n"
#~ "@SEEALSO=CEILING, FLOOR, ABS, INT, MOD"
#~ msgstr ""
#~ "@FUNCTION=CEIL\n"
#~ "@SYNTAX=CEIL(x)\n"
#~ "@DESCRIPTION=A função CEIL arredonda @x acima para o inteiro mais "
#~ "próximo.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CEIL(0.4) igual a 1.\n"
#~ "CEIL(-1.1) igual a -1.\n"
#~ "CEIL(-2.9) igual a -2.\n"
#~ "\n"
#~ "@SEEALSO=ABS, FLOOR, INT"

#~ msgid ""
#~ "@FUNCTION=COUNTIF\n"
#~ "@SYNTAX=COUNTIF(range,criteria)\n"
#~ "@DESCRIPTION=COUNTIF function counts the number of cells in the given "
#~ "@range that meet the given @criteria.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 23, 27, 28, "
#~ "33, and 39.  Then\n"
#~ "COUNTIF(A1:A5,\"<=28\") equals 3.\n"
#~ "COUNTIF(A1:A5,\"<28\") equals 2.\n"
#~ "COUNTIF(A1:A5,\"28\") equals 1.\n"
#~ "COUNTIF(A1:A5,\">28\") equals 2.\n"
#~ "\n"
#~ "@SEEALSO=COUNT,SUMIF"
#~ msgstr ""
#~ "@FUNCTION=COUNTIF\n"
#~ "@SYNTAX=COUNTIF(área,critério)\n"
#~ "@DESCRIPTION=A função COUNTIF conta o número de células na @área indicada "
#~ "que respeitam o @critério especificado.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1, A2, ..., A5 contêm os números 23, 27, "
#~ "28, 33, e 39.  Então\n"
#~ "COUNTIF(A1:A5,\"<=28\") igual a 3.\n"
#~ "COUNTIF(A1:A5,\"<28\") igual a 2.\n"
#~ "COUNTIF(A1:A5,\"28\") igual a 1.\n"
#~ "COUNTIF(A1:A5,\">28\") igual a 2.\n"
#~ "\n"
#~ "@SEEALSO=COUNT,SUMIF"

#~ msgid ""
#~ "@FUNCTION=SUMIF\n"
#~ "@SYNTAX=SUMIF(range,criteria[,actual_range])\n"
#~ "@DESCRIPTION=SUMIF function sums the values in the given @range that meet "
#~ "the given @criteria.  If @actual_range is given, SUMIF sums the values in "
#~ "the @actual_range whose corresponding components in @range meet the given "
#~ "@criteria.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 23, 27, 28, "
#~ "33, and 39.  Then\n"
#~ "SUMIF(A1:A5,\"<=28\") equals 78.\n"
#~ "SUMIF(A1:A5,\"<28\") equals 50.\n"
#~ "In addition, if the cells B1, B2, ..., B5 hold numbers 5, 3, 2, 6, and 7 "
#~ "then:\n"
#~ "SUMIF(A1:A5,\"<=27\",B1:B5) equals 8.\n"
#~ "\n"
#~ "@SEEALSO=COUNTIF, SUM"
#~ msgstr ""
#~ "@FUNCTION=SUMIF\n"
#~ "@SYNTAX=SUMIF(área,critério[,área_actual])\n"
#~ "@DESCRIPTION=A função SUMIF soma os valores na @área indicada que "
#~ "respeitam o @critério especificado.  Se @área_actual for indicada, SUMIF "
#~ "soma os valores na @área_actual cujo componente correspondente na @área "
#~ "cumpre o @critério especificado.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1, A2, ..., A5 contêm os números 23, 27, "
#~ "28, 33, e 39.  Então\n"
#~ "SUMIF(A1:A5,\"<=28\") igual a 78.\n"
#~ "SUMIF(A1:A5,\"<28\") igual a 50.\n"
#~ "Adicionalmente, se as células B1, B2, ..., B5 contiverem os números 5, 3, "
#~ "2, 6, e 7 então:\n"
#~ "SUMIF(A1:A5,\"<=27\",B1:B5) igual a 8.\n"
#~ "\n"
#~ "@SEEALSO=COUNTIF, SUM"

#~ msgid ""
#~ "@FUNCTION=CEILING\n"
#~ "@SYNTAX=CEILING(x[,significance])\n"
#~ "@DESCRIPTION=CEILING function rounds @x up to the nearest multiple of "
#~ "@significance.\n"
#~ "\n"
#~ "* If @x or @significance is non-numeric CEILING returns #VALUE! error.\n"
#~ "* If @x and @significance have different signs CEILING returns #NUM! "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CEILING(2.43,1) equals 3.\n"
#~ "CEILING(123.123,3) equals 126.\n"
#~ "\n"
#~ "@SEEALSO=CEIL, FLOOR, ABS, INT, MOD"
#~ msgstr ""
#~ "@FUNCTION=CEILING\n"
#~ "@SYNTAX=CEILING(x,significância)\n"
#~ "@DESCRIPTION=A função CEILING arredonda @x para cima para o mais próximo "
#~ "múltiplo de @significância.\n"
#~ "\n"
#~ "* Se @x ou @significância forem não-numéricos CEILING devolve o erro "
#~ "#VALOR!.\n"
#~ "* Se @x e @significância tiverem sinais diferentes CEILING devolve o erro "
#~ "#NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CEILING(2.43,1) igual a 3.\n"
#~ "CEILING(123.123,3) igual a 126.\n"
#~ "\n"
#~ "@SEEALSO=CEIL"

#~ msgid ""
#~ "@FUNCTION=COS\n"
#~ "@SYNTAX=COS(x)\n"
#~ "@DESCRIPTION=COS function returns the cosine of @x, where @x is given in "
#~ "radians.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COS(0.5) equals 0.877583.\n"
#~ "COS(1) equals 0.540302.\n"
#~ "\n"
#~ "@SEEALSO=COSH, SIN, SINH, TAN, TANH, RADIANS, DEGREES"
#~ msgstr ""
#~ "@FUNCTION=COS\n"
#~ "@SYNTAX=COS(x)\n"
#~ "@DESCRIPTION=A função COS devolve o cosseno de @x, onde @x é dado em "
#~ "radianos.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COS(0.5) igual a 0.877583.\n"
#~ "COS(1) igual a 0.540302.\n"
#~ "\n"
#~ "@SEEALSO=COSH, SIN, SINH, TAN, TANH, RADIANS, DEGREES"

#~ msgid ""
#~ "@FUNCTION=COSH\n"
#~ "@SYNTAX=COSH(x)\n"
#~ "@DESCRIPTION=COSH function returns the hyperbolic cosine of @x, which is "
#~ "defined mathematically as\n"
#~ "\n"
#~ "\t(exp(@x) + exp(-@x)) / 2.\n"
#~ "\n"
#~ "* @x is in radians.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COSH(0.5) equals 1.127626.\n"
#~ "COSH(1) equals 1.543081.\n"
#~ "\n"
#~ "@SEEALSO=COS, SIN, SINH, TAN, TANH, RADIANS, DEGREES, EXP"
#~ msgstr ""
#~ "@FUNCTION=COSH\n"
#~ "@SYNTAX=COSH(x)\n"
#~ "@DESCRIPTION=A função COSH devolve o cosseno hiperbólico de @x, que é "
#~ "definido matematicamente como\n"
#~ "\n"
#~ "\t(exp(@x) + exp(-@x)) / 2.\n"
#~ "\n"
#~ "* @x está em radianos.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COSH(0.5) igual a 1.127626.\n"
#~ "COSH(1) igual a 1.543081.\n"
#~ "\n"
#~ "@SEEALSO=COS, SIN, SINH, TAN, TANH, RADIANS, DEGREES, EXP"

#~ msgid ""
#~ "@FUNCTION=DEGREES\n"
#~ "@SYNTAX=DEGREES(x)\n"
#~ "@DESCRIPTION=DEGREES computes the number of degrees equivalent to @x "
#~ "radians.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DEGREES(2.5) equals 143.2394.\n"
#~ "\n"
#~ "@SEEALSO=RADIANS, PI"
#~ msgstr ""
#~ "@FUNCTION=DEGREES\n"
#~ "@SYNTAX=DEGREES(x)\n"
#~ "@DESCRIPTION=DEGREES calcula o número de graus equivalente a @x "
#~ "radianos.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DEGREES(2.5) igual a 143.2394.\n"
#~ "\n"
#~ "@SEEALSO=RADIANS, PI"

#~ msgid ""
#~ "@FUNCTION=EXP\n"
#~ "@SYNTAX=EXP(x)\n"
#~ "@DESCRIPTION=EXP computes the value of e (the base of natural logarithms) "
#~ "raised to the power of @x.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "EXP(2) equals 7.389056.\n"
#~ "\n"
#~ "@SEEALSO=LOG, LOG2, LOG10"
#~ msgstr ""
#~ "@FUNCTION=EXP\n"
#~ "@SYNTAX=EXP(x)\n"
#~ "@DESCRIPTION=EXP calcula o valor de e (a base dos logaritmos naturais) "
#~ "elevada à potência de @x.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "EXP(2) igual a 7.389056.\n"
#~ "\n"
#~ "@SEEALSO=LOG, LOG2, LOG10"

#~ msgid ""
#~ "@FUNCTION=EXPM1\n"
#~ "@SYNTAX=EXPM1(x)\n"
#~ "@DESCRIPTION=EXPM1 computes EXP(@x)-1 with higher resulting precision "
#~ "than the direct formula.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "EXPM1(0.01) equals 0.01005.\n"
#~ "\n"
#~ "@SEEALSO=EXP, LN1P"
#~ msgstr ""
#~ "@FUNCTION=EXP\n"
#~ "@SYNTAX=EXP(x)\n"
#~ "@DESCRIPTION=EXP calcula o valor de e (a base dos logaritmos naturais) "
#~ "elevada à potência de @x.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "EXP(2) igual a 7.389056.\n"
#~ "\n"
#~ "@SEEALSO=LOG, LOG2, LOG10"

#~ msgid ""
#~ "@FUNCTION=FACT\n"
#~ "@SYNTAX=FACT(x)\n"
#~ "@DESCRIPTION=FACT computes the factorial of @x. ie, @x!\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FACT(3) equals 6.\n"
#~ "FACT(9) equals 362880.\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=FACT\n"
#~ "@SYNTAX=FACT(x)\n"
#~ "@DESCRIPTION=FACT calcula o factorial de @x. por exemplo, @x!\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FACT(3) igual a 6.\n"
#~ "FACT(9) igual a 362880.\n"
#~ "\n"
#~ "@SEEALSO="

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=BETA\n"
#~ "@SYNTAX=BETA(a,b)\n"
#~ "@DESCRIPTION=BETA function returns the value of the mathematical beta "
#~ "function extended to all real numbers except 0 and negative integers.\n"
#~ "\n"
#~ "* If @a, @b, or (@a + @b) are non-positive integers, BETA returns #NUM! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BETA(2,3) equals 0.083333.\n"
#~ "BETA(-0.5,0.5) equals #NUM!.\n"
#~ "\n"
#~ "@SEEALSO=BETALN,GAMMALN"
#~ msgstr ""
#~ "@FUNCTION=BETA\n"
#~ "@SYNTAX=BETA(a,b)\n"
#~ "@DESCRIPTION=A função BETA devolve o valor da função matemática beta "
#~ "extendida a todos os números reais excepto 0 e inteiros negativos.\n"
#~ "\n"
#~ "* Se @a, @b, ou (@ + @b) forem inteiros não-positivos, BETA devolve o "
#~ "erro #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BETA(2,3) igual a 0.083333.\n"
#~ "BETA(-0.5,0.5) igual a #NUM!.\n"
#~ "\n"
#~ "@SEEALSO=BETALN,GAMMALN"

#~ msgid ""
#~ "@FUNCTION=BETALN\n"
#~ "@SYNTAX=BETALN(a,b)\n"
#~ "@DESCRIPTION=BETALN function returns the natural logarithm of the "
#~ "absolute value of the beta function.\n"
#~ "\n"
#~ "* If @a, @b, or (@a + @b) are non-positive integers, BETALN returns "
#~ "#NUM! \n"
#~ "@EXAMPLES=\n"
#~ "BETALN(2,3) equals -2.48.\n"
#~ "BETALN(-0.5,0.5) equals #NUM!.\n"
#~ "\n"
#~ "@SEEALSO=BETA,GAMMALN"
#~ msgstr ""
#~ "@FUNCTION=BETALN\n"
#~ "@SYNTAX=BETALN(a,b)\n"
#~ "@DESCRIPTION=A função BETALN devolve o logarítmo natural do valor "
#~ "absoluto da função beta.\n"
#~ "\n"
#~ "* Se @a, @b, ou (@ + @b) forem inteiros não-positivos, BETALN devolve o "
#~ "erro #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BETALN(2,3) igual a -2.48.\n"
#~ "BETALN(-0.5,0.5) igual a #NUM!.\n"
#~ "\n"
#~ "@SEEALSO=BETA,GAMMALN"

#~ msgid ""
#~ "@FUNCTION=COMBIN\n"
#~ "@SYNTAX=COMBIN(n,k)\n"
#~ "@DESCRIPTION=COMBIN computes the number of combinations.\n"
#~ "\n"
#~ "* Performing this function on a non-integer or a negative number returns "
#~ "#NUM! error.\n"
#~ "* If @n is less than @k COMBIN returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COMBIN(8,6) equals 28.\n"
#~ "COMBIN(6,2) equals 15.\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=COMBIN\n"
#~ "@SYNTAX=COMBIN(n,k)\n"
#~ "@DESCRIPTION=COMBIN calcula o número de combinações.\n"
#~ "\n"
#~ "* Realizar esta operação num número não-inteiro ou negativo devolve um "
#~ "erro #NUM!..\n"
#~ "* Se @n for menor do que @k devolve um erro #NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COMBIN(8,6) igual a 28.\n"
#~ "COMBIN(6,2) igual a 15.\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=INT\n"
#~ "@SYNTAX=INT(a)\n"
#~ "@DESCRIPTION=INT function returns the largest integer that is not bigger "
#~ "than its argument.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "INT(7.2) equals 7.\n"
#~ "INT(-5.5) equals -6.\n"
#~ "\n"
#~ "@SEEALSO=CEIL, CEILING, FLOOR, ABS, MOD"
#~ msgstr ""
#~ "@FUNCTION=INT\n"
#~ "@SYNTAX=INT(a)\n"
#~ "@DESCRIPTION=A função INT devolve o maior inteiro que não seja maior do "
#~ "que o argumento.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "INT(7.2) igual a 7.\n"
#~ "INT(-5.5) igual a -6.\n"
#~ "\n"
#~ "@SEEALSO=FLOOR, CEIL, ABS"

#~ msgid ""
#~ "@FUNCTION=LOG\n"
#~ "@SYNTAX=LOG(x[,base])\n"
#~ "@DESCRIPTION=LOG computes the logarithm of @x in the given base @base.  "
#~ "If no @base is given LOG returns the logarithm in base 10. @base must be "
#~ "> 0. and cannot equal 1.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LOG(2) equals 0.30103.\n"
#~ "LOG(8192,2) equals 13.\n"
#~ "\n"
#~ "@SEEALSO=LN, LOG2, LOG10"
#~ msgstr ""
#~ "@FUNCTION=LOG\n"
#~ "@SYNTAX=LOG(x[,base])\n"
#~ "@DESCRIPTION=LOG calcula o logaritmo de @x na @base indicada. Se nenhuma "
#~ "@base for indicada LOG devolve o logaritmo na base 10. @base tem de ser > "
#~ "0. e não pode ser igual a 1.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LOG(2) igual a 0.30103.\n"
#~ "LOG(8192,2) igual a 13.\n"
#~ "\n"
#~ "@SEEALSO=LN, LOG2, LOG10"

#~ msgid ""
#~ "@FUNCTION=LN\n"
#~ "@SYNTAX=LN(x)\n"
#~ "@DESCRIPTION=LN returns the natural logarithm of @x.\n"
#~ "\n"
#~ "* If @x <= 0, LN returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LN(7) equals 1.94591.\n"
#~ "\n"
#~ "@SEEALSO=EXP, LOG2, LOG10"
#~ msgstr ""
#~ "@FUNCTION=LN\n"
#~ "@SYNTAX=LN(x)\n"
#~ "@DESCRIPTION=LN devolve o logaritmo natural de @x.\n"
#~ "\n"
#~ "* Se @x <= 0, LN devolve o erro #NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LN(7) igual a 1.94591.\n"
#~ "\n"
#~ "@SEEALSO=EXP, LOG2, LOG10"

#~ msgid ""
#~ "@FUNCTION=LN1P\n"
#~ "@SYNTAX=LN1P(x)\n"
#~ "@DESCRIPTION=LN1P computes LN(1+@x) with higher resulting precision than "
#~ "the direct formula.\n"
#~ "\n"
#~ "* If @x <= -1, LN1P returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LN1P(0.01) equals 0.00995.\n"
#~ "\n"
#~ "@SEEALSO=LN, EXPM1"
#~ msgstr ""
#~ "@FUNCTION=LOG2\n"
#~ "@SYNTAX=LOG2(x)\n"
#~ "@DESCRIPTION=LOG2 calcula o logaritmo base-2 de @x.\n"
#~ "\n"
#~ "* Se @x <= 0, LOG2 devolve o erro #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LOG2(1024) igual a 10.\n"
#~ "\n"
#~ "@SEEALSO=EXP, LOG10, LOG"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=POWER\n"
#~ "@SYNTAX=POWER(x,y)\n"
#~ "@DESCRIPTION=POWER returns the value of @x raised to the power @y.\n"
#~ "\n"
#~ "\n"
#~ "* If both @x and @y equal 0, POWER returns #NUM! error.\n"
#~ "* If @x = 0 and @y < 0, POWER returns #DIV/0! error.\n"
#~ "* If @x < 0 and @y is non-integer, POWER returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "POWER(2,7) equals 128.\n"
#~ "POWER(3,3.141) equals 31.523749.\n"
#~ "\n"
#~ "@SEEALSO=EXP"
#~ msgstr ""
#~ "@FUNCTION=POWER\n"
#~ "@SYNTAX=POWER(x,y)\n"
#~ "@DESCRIPTION=POWER devolve o valor de @x elevado à potência de @y.\n"
#~ "\n"
#~ "\n"
#~ "* Se ambos @x e @y iguais a 0, POWER devolve o erro #NUM!.\n"
#~ "* Se @x = 0 e @y < 0, POWER devolve o erro #DIV/0!.\n"
#~ "* Se @x < 0 e @y for não-inteiro, POWER devolve o erro #NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "POWER(2,7) igual a 128.\n"
#~ "POWER(3,3.141) igual a 31.523749.\n"
#~ "\n"
#~ "@SEEALSO=EXP"

#~ msgid ""
#~ "@FUNCTION=LOG2\n"
#~ "@SYNTAX=LOG2(x)\n"
#~ "@DESCRIPTION=LOG2 computes the base-2 logarithm of @x.\n"
#~ "\n"
#~ "* If @x <= 0, LOG2 returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LOG2(1024) equals 10.\n"
#~ "\n"
#~ "@SEEALSO=EXP, LOG10, LOG"
#~ msgstr ""
#~ "@FUNCTION=LOG2\n"
#~ "@SYNTAX=LOG2(x)\n"
#~ "@DESCRIPTION=LOG2 calcula o logaritmo base-2 de @x.\n"
#~ "\n"
#~ "* Se @x <= 0, LOG2 devolve o erro #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LOG2(1024) igual a 10.\n"
#~ "\n"
#~ "@SEEALSO=EXP, LOG10, LOG"

#~ msgid ""
#~ "@FUNCTION=LOG10\n"
#~ "@SYNTAX=LOG10(x)\n"
#~ "@DESCRIPTION=LOG10 computes the base-10 logarithm of @x.\n"
#~ "\n"
#~ "* If @x <= 0, LOG10 returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ " \n"
#~ "@EXAMPLES=\n"
#~ "LOG10(7) equals 0.845098.\n"
#~ "\n"
#~ "@SEEALSO=EXP, LOG2, LOG"
#~ msgstr ""
#~ "@FUNCTION=LOG10\n"
#~ "@SYNTAX=LOG10(x)\n"
#~ "@DESCRIPTION=LOG10 calcula o logaritmo base-10 de @x.\n"
#~ "\n"
#~ "* Se @x <= 0, LOG10 devolve o erro #NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LOG10(7) igual a 0.845098.\n"
#~ "\n"
#~ "@SEEALSO=EXP, LOG2, LOG"

#~ msgid ""
#~ "@FUNCTION=MOD\n"
#~ "@SYNTAX=MOD(number,divisor)\n"
#~ "@DESCRIPTION=MOD function returns the remainder when @divisor is divided "
#~ "into @number.\n"
#~ "\n"
#~ "* MOD returns #DIV/0! if @divisor is zero.\n"
#~ "* This function is Excel compatible.\n"
#~ " \n"
#~ "@EXAMPLES=\n"
#~ "MOD(23,7) equals 2.\n"
#~ "\n"
#~ "@SEEALSO=CEIL, CEILING, FLOOR, ABS, INT, ABS"
#~ msgstr ""
#~ "@FUNCTION=MOD\n"
#~ "@SYNTAX=MOD(número,divisor)\n"
#~ "@DESCRIPTION=A função MOD devolve o resto da divisão de @número pelo "
#~ "@divisor.\n"
#~ "\n"
#~ "* MOD devolve #DIV/0! se @divisor for zero.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ " \n"
#~ "@EXAMPLES=\n"
#~ "MOD(23,7) igual a 2.\n"
#~ "\n"
#~ "@SEEALSO=INT,FLOOR,CEIL"

#~ msgid ""
#~ "@FUNCTION=RADIANS\n"
#~ "@SYNTAX=RADIANS(x)\n"
#~ "@DESCRIPTION=RADIANS computes the number of radians equivalent to @x "
#~ "degrees.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RADIANS(180) equals 3.14159.\n"
#~ "\n"
#~ "@SEEALSO=PI,DEGREES"
#~ msgstr ""
#~ "@FUNCTION=RADIANS\n"
#~ "@SYNTAX=RADIANS(x)\n"
#~ "@DESCRIPTION=RADIANS calcula o número de radianos equivalente a @x "
#~ "graus.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RADIANS(180) igual a 3.14159.\n"
#~ "\n"
#~ "@SEEALSO=PI,DEGREES"

#~ msgid ""
#~ "@FUNCTION=SIN\n"
#~ "@SYNTAX=SIN(x)\n"
#~ "@DESCRIPTION=SIN function returns the sine of @x, where @x is given in "
#~ "radians.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "SIN(0.5) equals 0.479426.\n"
#~ "\n"
#~ "@SEEALSO=COS, COSH, SINH, TAN, TANH, RADIANS, DEGREES"
#~ msgstr ""
#~ "@FUNCTION=SIN\n"
#~ "@SYNTAX=SIN(x)\n"
#~ "@DESCRIPTION=A função SIN devolve o seno de @x, onde @x é dado em "
#~ "radianos.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "SIN(0.5) igual a 0.479426.\n"
#~ "\n"
#~ "@SEEALSO=COS, COSH, SINH, TAN, TANH, RADIANS, DEGREES"

#~ msgid ""
#~ "@FUNCTION=SINH\n"
#~ "@SYNTAX=SINH(x)\n"
#~ "@DESCRIPTION=SINH function returns the hyperbolic sine of @x, which is "
#~ "defined mathematically as\n"
#~ "\n"
#~ "\t(exp(@x) - exp(-@x)) / 2.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "SINH(0.5) equals 0.521095.\n"
#~ "\n"
#~ "@SEEALSO=SIN, COS, COSH, TAN, TANH, DEGREES, RADIANS, EXP"
#~ msgstr ""
#~ "@FUNCTION=SINH\n"
#~ "@SYNTAX=SINH(x)\n"
#~ "@DESCRIPTION=A função SINH devolve o seno hiperbólico de @x, que é "
#~ "definido matematicamente como\n"
#~ "\n"
#~ "\t(exp(@x) - exp(-@x)) / 2.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "SINH(0.5) igual a 0.521095.\n"
#~ "\n"
#~ "@SEEALSO=SIN, COS, COSH, TAN, TANH, DEGREES, RADIANS, EXP"

#~ msgid ""
#~ "@FUNCTION=SQRT\n"
#~ "@SYNTAX=SQRT(x)\n"
#~ "@DESCRIPTION=SQRT function returns the square root of @x.\n"
#~ "\n"
#~ "* If @x is negative, SQRT returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "SQRT(2) equals 1.4142136.\n"
#~ "\n"
#~ "@SEEALSO=POWER"
#~ msgstr ""
#~ "@FUNCTION=SQRT\n"
#~ "@SYNTAX=SQRT(x)\n"
#~ "@DESCRIPTION=A função SQRT devolve a raiz quadrada de @x.\n"
#~ "\n"
#~ "* Se @x for negativo, SQRT devolve o erro #NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "SQRT(2) igual a 1.4142136.\n"
#~ "\n"
#~ "@SEEALSO=POWER"

#~ msgid ""
#~ "@FUNCTION=SUMSQ\n"
#~ "@SYNTAX=SUMSQ(value1, value2, ...)\n"
#~ "@DESCRIPTION=SUMSQ returns the sum of the squares of all the values and "
#~ "cells referenced in the argument list.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ " \n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11, 15, 17, "
#~ "21, and 43.  Then\n"
#~ "SUMSQ(A1:A5) equals 2925.\n"
#~ "\n"
#~ "@SEEALSO=SUM, COUNT"
#~ msgstr ""
#~ "@FUNCTION=SUMSQ\n"
#~ "@SYNTAX=SUMSQ(valor1, valor2, ...)\n"
#~ "@DESCRIPTION=SUMSQ devolve a soma dos quadrados de todos os valores e "
#~ "células referenciadas na lista de argumentos.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1, A2, ..., A5 contêm os números 11, 15, "
#~ "17, 21, e 43. Então\n"
#~ "SUMSQ(A1:A5) igual a 2925.\n"
#~ "\n"
#~ "@SEEALSO=SUM, COUNT"

#~ msgid ""
#~ "@FUNCTION=MULTINOMIAL\n"
#~ "@SYNTAX=MULTINOMIAL(value1, value2, ...)\n"
#~ "@DESCRIPTION=MULTINOMIAL returns the ratio of the factorial of a sum of "
#~ "values to the product of factorials.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ " \n"
#~ "@EXAMPLES=\n"
#~ "MULTINOMIAL(2,3,4) equals 1260.\n"
#~ "\n"
#~ "@SEEALSO=SUM"
#~ msgstr ""
#~ "@FUNCTION=MULTINOMIAL\n"
#~ "@SYNTAX=MULTINOMIAL(valor1, valor2, ...)\n"
#~ "@DESCRIPTION=MULTINOMIAL devolve o rácio do factorial de uma soma de "
#~ "valores ao produto de factoriais.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "MULTINOMIAL(2,3,4) igual a 1260.\n"
#~ "\n"
#~ "@SEEALSO=SUM"

#~ msgid ""
#~ "@FUNCTION=G_PRODUCT\n"
#~ "@SYNTAX=G_PRODUCT(value1, value2, ...)\n"
#~ "@DESCRIPTION=G_PRODUCT returns the product of all the values and cells "
#~ "referenced in the argument list.\n"
#~ "\n"
#~ "* Empty cells are ignored and the empty product is 1.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "G_PRODUCT(2,5,9) equals 90.\n"
#~ "\n"
#~ "@SEEALSO=SUM, COUNT"
#~ msgstr ""
#~ "@FUNCTION=G_PRODUCT\n"
#~ "@SYNTAX=G_PRODUCT(valor1, valor2, ...)\n"
#~ "@DESCRIPTION=PRODUCT devolve o produto de todos os valores e células "
#~ "referenciadas na lista de argumentos.\n"
#~ "\n"
#~ "* Células vazias são ignoradas e o produto de vazio é 1.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "G_PRODUCT(2,5,9) igual a 90.\n"
#~ "\n"
#~ "@SEEALSO=SUM, COUNT"

#~ msgid ""
#~ "@FUNCTION=TAN\n"
#~ "@SYNTAX=TAN(x)\n"
#~ "@DESCRIPTION=TAN function returns the tangent of @x, where @x is given in "
#~ "radians.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TAN(3) equals -0.1425465.\n"
#~ "\n"
#~ "@SEEALSO=TANH, COS, COSH, SIN, SINH, DEGREES, RADIANS"
#~ msgstr ""
#~ "@FUNCTION=TAN\n"
#~ "@SYNTAX=TAN(x)\n"
#~ "@DESCRIPTION=A função TAN devolve a tangente de @x, onde @x é dado em "
#~ "radianos.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TAN(3) igual a -0.1425465.\n"
#~ "\n"
#~ "@SEEALSO=TANH, COS, COSH, SIN, SINH, DEGREES, RADIANS"

#~ msgid ""
#~ "@FUNCTION=TANH\n"
#~ "@SYNTAX=TANH(x)\n"
#~ "@DESCRIPTION=TANH function returns the hyperbolic tangent of @x, which is "
#~ "defined mathematically as \n"
#~ "\n"
#~ "\tsinh(@x) / cosh(@x).\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TANH(2) equals 0.96402758.\n"
#~ "\n"
#~ "@SEEALSO=TAN, SIN, SINH, COS, COSH, DEGREES, RADIANS"
#~ msgstr ""
#~ "@FUNCTION=TANH\n"
#~ "@SYNTAX=TANH(x)\n"
#~ "@DESCRIPTION=A função TANH devolve a tangente hiperbólica de @x, que é "
#~ "definida matematicamente como\n"
#~ "\n"
#~ "\tsinh(@x) / cosh(@x).\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TANH(2) igual a 0.96402758.\n"
#~ "\n"
#~ "@SEEALSO=TAN, SIN, SINH, COS, COSH, DEGREES, RADIANS"

#~ msgid ""
#~ "@FUNCTION=PI\n"
#~ "@SYNTAX=PI()\n"
#~ "@DESCRIPTION=PI functions returns the value of pi.\n"
#~ "\n"
#~ "* This function is called with no arguments.\n"
#~ "* This function is Excel compatible, except that it returns pi with a "
#~ "better precision.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "PI() equals about 3.141593.\n"
#~ "\n"
#~ "@SEEALSO=SQRTPI"
#~ msgstr ""
#~ "@FUNCTION=PI\n"
#~ "@SYNTAX=PI()\n"
#~ "@DESCRIPTION=A função PI devolve o valor de pi.\n"
#~ "\n"
#~ "* Esta função é chamada sem passagem de argumentos.\n"
#~ "* Esta função é compatível com o Excel, excepto em que devolve pi com "
#~ "maior precisão.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "PI() igual a 3.141593.\n"
#~ "\n"
#~ "@SEEALSO=SQRTPI"

#~ msgid ""
#~ "@FUNCTION=TRUNC\n"
#~ "@SYNTAX=TRUNC(number[,digits])\n"
#~ "@DESCRIPTION=TRUNC function returns the value of @number truncated to the "
#~ "number of digits specified.\n"
#~ "\n"
#~ "* If @digits is omitted or negative then @digits defaults to zero.\n"
#~ "* If @digits is not an integer, it is truncated.\n"
#~ "* This function is Excel compatible.\n"
#~ " \n"
#~ "@EXAMPLES=\n"
#~ "TRUNC(3.12) equals 3.\n"
#~ "TRUNC(4.15,1) equals 4.1.\n"
#~ "\n"
#~ "@SEEALSO=INT"
#~ msgstr ""
#~ "@FUNCTION=TRUNC\n"
#~ "@SYNTAX=TRUNC(número[,dígitos])\n"
#~ "@DESCRIPTION=A função TRUNC devolve o valor de @número truncado ao número "
#~ "de dígitos especificado.\n"
#~ "\n"
#~ "* Se @dígitos for omitido então @dígitos passa para o valor por omissão "
#~ "de zero.\n"
#~ "* Se @dígitos não for um inteiro, será truncado.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TRUNC(3.12) igual a 3.\n"
#~ "TRUNC(4.15,1) igual a 4.1.\n"
#~ "\n"
#~ "@SEEALSO=INT"

#~ msgid ""
#~ "@FUNCTION=EVEN\n"
#~ "@SYNTAX=EVEN(number)\n"
#~ "@DESCRIPTION=EVEN function returns the number rounded up to the nearest "
#~ "even integer.  Negative numbers are rounded down.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ " \n"
#~ "@EXAMPLES=\n"
#~ "EVEN(5.4) equals 6.\n"
#~ "EVEN(-5.4) equals -6.\n"
#~ "\n"
#~ "@SEEALSO=ODD"
#~ msgstr ""
#~ "@FUNCTION=EVEN\n"
#~ "@SYNTAX=EVEN(número)\n"
#~ "@DESCRIPTION=A função EVEN devolve o número arredondado acima até ao "
#~ "inteiro par mais próximo.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "EVEN(5.4) igual a 6.\n"
#~ "\n"
#~ "@SEEALSO=ODD"

#~ msgid ""
#~ "@FUNCTION=ODD\n"
#~ "@SYNTAX=ODD(number)\n"
#~ "@DESCRIPTION=ODD function returns the @number rounded up to the nearest "
#~ "odd integer.  Negative numbers are rounded down.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ " \n"
#~ "@EXAMPLES=\n"
#~ "ODD(4.4) equals 5.\n"
#~ "ODD(-4.4) equals -5.\n"
#~ "\n"
#~ "@SEEALSO=EVEN"
#~ msgstr ""
#~ "@FUNCTION=ODD\n"
#~ "@SYNTAX=ODD(número)\n"
#~ "@DESCRIPTION=A função ODD devolve o @número arredondado acima até ao "
#~ "inteiro impar mais próximo.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ODD(4.4) igual a 5.\n"
#~ "\n"
#~ "@SEEALSO=EVEN"

#~ msgid ""
#~ "@FUNCTION=FACTDOUBLE\n"
#~ "@SYNTAX=FACTDOUBLE(number)\n"
#~ "@DESCRIPTION=FACTDOUBLE function returns the double factorial of a "
#~ "@number, i.e., x!!.\n"
#~ "\n"
#~ "* If @number is not an integer, it is truncated.\n"
#~ "* If @number is negative FACTDOUBLE returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ " \n"
#~ "@EXAMPLES=\n"
#~ "FACTDOUBLE(5) equals 15.\n"
#~ "\n"
#~ "@SEEALSO=FACT"
#~ msgstr ""
#~ "@FUNCTION=FACTDOUBLE\n"
#~ "@SYNTAX=FACTDOUBLE(number)\n"
#~ "@DESCRIPTION=A função FACTDOUBLE devolve o duplo factorial de um @número, "
#~ "por ex. x!!.\n"
#~ "\n"
#~ "* Se @número não for um inteiro, será truncado.\n"
#~ "* Se @número for negativo FACTDOUBLE devolve o erro #NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FACTDOUBLE(5) igual a 15.\n"
#~ "\n"
#~ "@SEEALSO=FACT"

#~ msgid ""
#~ "@FUNCTION=FIB\n"
#~ "@SYNTAX=FIB(number)\n"
#~ "@DESCRIPTION=FIB function computes Fibonacci numbers.\n"
#~ "\n"
#~ "* If @number is not an integer, it is truncated.\n"
#~ "* If @number is negative or zero FIB returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FIB(12) equals 144.\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=FIB\n"
#~ "@SYNTAX=FIB(número)\n"
#~ "@DESCRIPTION=A função FIB calcula números de Fibonacci.\n"
#~ "\n"
#~ "* Se @número não for um inteiro, será truncado.\n"
#~ "* Se @número for negativo FACTDOUBLE devolve o erro #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FIB(512 igual a 144.\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=QUOTIENT\n"
#~ "@SYNTAX=QUOTIENT(numerator,denominator)\n"
#~ "@DESCRIPTION=QUOTIENT function returns the integer portion of a "
#~ "division.  @numerator is the divided number and @denominator is the "
#~ "divisor.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ " \n"
#~ "@EXAMPLES=\n"
#~ "QUOTIENT(23,5) equals 4.\n"
#~ "\n"
#~ "@SEEALSO=MOD"
#~ msgstr ""
#~ "@FUNCTION=QUOTIENT\n"
#~ "@SYNTAX=QUOTIENT(numerador,denominador)\n"
#~ "@DESCRIPTION=A função QUOTIENT devolve a parte inteira de uma divisão. "
#~ "@numerador é número dividido e @denominador é o divisor.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "QUOTIENT(23,5) igual a 4.\n"
#~ "\n"
#~ "@SEEALSO=MOD"

#~ msgid ""
#~ "@FUNCTION=SIGN\n"
#~ "@SYNTAX=SIGN(number)\n"
#~ "@DESCRIPTION=SIGN function returns 1 if the @number is positive, zero if "
#~ "the @number is 0, and -1 if the @number is negative.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ " \n"
#~ "@EXAMPLES=\n"
#~ "SIGN(3) equals 1.\n"
#~ "SIGN(-3) equals -1.\n"
#~ "SIGN(0) equals 0.\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=SIGN\n"
#~ "@SYNTAX=SIGN(número)\n"
#~ "@DESCRIPTION=A função SIGN devolve 1 se o @número for positivo, zero se o "
#~ "@número for 0, e -1 se o @número for negativo.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "SIGN(3) igual a 1.\n"
#~ "SIGN(-3) igual a -1.\n"
#~ "SIGN(0) igual a 0.\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=SQRTPI\n"
#~ "@SYNTAX=SQRTPI(number)\n"
#~ "@DESCRIPTION=SQRTPI function returns the square root of a @number "
#~ "multiplied by pi.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "SQRTPI(2) equals 2.506628275.\n"
#~ "\n"
#~ "@SEEALSO=PI"
#~ msgstr ""
#~ "@FUNCTION=SQRTPI\n"
#~ "@SYNTAX=SQRTPI(número)\n"
#~ "@DESCRIPTION=A função SQRTPI devolve a raiz quadrada de um @número "
#~ "multiplicado por pi.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "SQRTPI(2) igual a 2.506628275.\n"
#~ "\n"
#~ "@SEEALSO=PI"

#~ msgid ""
#~ "@FUNCTION=ROUNDDOWN\n"
#~ "@SYNTAX=ROUNDDOWN(number[,digits])\n"
#~ "@DESCRIPTION=ROUNDDOWN function rounds a given @number towards 0.\n"
#~ "\n"
#~ "@number is the number you want rounded toward 0 and @digits is the number "
#~ "of digits to which you want to round that number.\n"
#~ "\n"
#~ "* If @digits is greater than zero, @number is rounded toward 0 to the "
#~ "given number of digits.\n"
#~ "* If @digits is zero or omitted, @number is rounded toward 0 to the next "
#~ "integer.\n"
#~ "* If @digits is less than zero, @number is rounded toward 0 to the left "
#~ "of the decimal point.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ROUNDDOWN(5.5) equals 5.\n"
#~ "ROUNDDOWN(-3.3) equals -3.\n"
#~ "ROUNDDOWN(1501.15,1) equals 1501.1.\n"
#~ "ROUNDDOWN(1501.15,-2) equals 1500.0.\n"
#~ "\n"
#~ "@SEEALSO=ROUND,ROUNDUP"
#~ msgstr ""
#~ "@FUNCTION=ROUNDDOWN\n"
#~ "@SYNTAX=ROUNDDOWN(número[,dígitos])\n"
#~ "@DESCRIPTION=A função ROUNDDOWN arredonda abaixo um dado @número. @número "
#~ "é o número que deseja arredondar e @dígitos é o número de dígitos para os "
#~ "quais quer arredondar o número.\n"
#~ "\n"
#~ "* Se @dígitos for maior do que zero, @número é arredondado para o número "
#~ "de dígitos indicado.\n"
#~ "* Se @dígitos for zero ou omitido, @número é arredondado abaixo para o "
#~ "inteiro mais próximo.\n"
#~ "* Se @dígitos for menor do que zero, @número é arredondado abaixo para a "
#~ "esquerda do separador decimal.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ROUNDDOWN(5.5) igual a 5.\n"
#~ "ROUNDDOWN(-3.3) igual a -4.\n"
#~ "ROUNDDOWN(1501.15,1) igual a 1501.1.\n"
#~ "ROUNDDOWN(1501.15,-2) igual a 1500.0.\n"
#~ "\n"
#~ "@SEEALSO=ROUND,ROUNDUP"

#~ msgid ""
#~ "@FUNCTION=ROUND\n"
#~ "@SYNTAX=ROUND(number[,digits])\n"
#~ "@DESCRIPTION=ROUND function rounds a given number.\n"
#~ "\n"
#~ "@number is the number you want rounded and @digits is the number of "
#~ "digits to which you want to round that number.\n"
#~ "\n"
#~ "* If @digits is greater than zero, @number is rounded to the given number "
#~ "of digits.\n"
#~ "* If @digits is zero or omitted, @number is rounded to the nearest "
#~ "integer.\n"
#~ "* If @digits is less than zero, @number is rounded to the left of the "
#~ "decimal point.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ROUND(5.5) equals 6.\n"
#~ "ROUND(-3.3) equals -3.\n"
#~ "ROUND(1501.15,1) equals 1501.2.\n"
#~ "ROUND(1501.15,-2) equals 1500.0.\n"
#~ "\n"
#~ "@SEEALSO=ROUNDDOWN,ROUNDUP"
#~ msgstr ""
#~ "@FUNCTION=ROUND\n"
#~ "@SYNTAX=ROUND(número[,dígitos])\n"
#~ "@DESCRIPTION=A função ROUND arredonda o número indicado.\n"
#~ "\n"
#~ "@número é o número que deseja arredondar e @dígitos é o número de dígitos "
#~ "para o qual deseja arredondar o número.\n"
#~ "\n"
#~ "* Se @dígitos for maior do que zero, @número é arredondado para o número "
#~ "de dígitos indicado.\n"
#~ "* Se @dígitos for zero ou omitido, @número é arredondado para o inteiro "
#~ "mais próximo.\n"
#~ "* Se @dígitos for menor do que zero, @número é arredondado para a "
#~ "esquerda do separador decimal.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ROUND(5.5) igual a 6.\n"
#~ "ROUND(-3.3) igual a -3.\n"
#~ "ROUND(1501.15,1) igual a 1501.2.\n"
#~ "ROUND(1501.15,-2) igual a 1500.0.\n"
#~ "\n"
#~ "@SEEALSO=ROUNDDOWN,ROUNDUP"

#~ msgid ""
#~ "@FUNCTION=ROUNDUP\n"
#~ "@SYNTAX=ROUNDUP(number[,digits])\n"
#~ "@DESCRIPTION=ROUNDUP function rounds a given number away from 0.\n"
#~ "\n"
#~ "@number is the number you want rounded away from 0 and @digits is the "
#~ "number of digits to which you want to round that number.\n"
#~ "\n"
#~ "* If @digits is greater than zero, @number is rounded away from 0 to the "
#~ "given number of digits.\n"
#~ "* If @digits is zero or omitted, @number is rounded away from 0 to the "
#~ "next integer.\n"
#~ "* If @digits is less than zero, @number is rounded away from 0 to the "
#~ "left of the decimal point.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ROUNDUP(5.5) equals 6.\n"
#~ "ROUNDUP(-3.3) equals -4.\n"
#~ "ROUNDUP(1501.15,1) equals 1501.2.\n"
#~ "ROUNDUP(1501.15,-2) equals 1600.0.\n"
#~ "\n"
#~ "@SEEALSO=ROUND,ROUNDDOWN"
#~ msgstr ""
#~ "@FUNCTION=ROUNDUP\n"
#~ "@SYNTAX=ROUNDUP(número[,dígitos])\n"
#~ "@DESCRIPTION=A função ROUNDUP arredonda para cima um número indicado.\n"
#~ "\n"
#~ "@número é o número que deseja arredondar acima e @dígitos é o número de "
#~ "dígitos que deseja utilizar ao arredondar o número.\n"
#~ "\n"
#~ "* Se @dígitos for maior do que zero, @número é arredondado até ao número "
#~ "indicado de dígitos.\n"
#~ "* Se @dígitos for zero ou omitido, @número é arredondado até ao inteiro "
#~ "mais próximo.\n"
#~ "* Se @dígitos for menor do que zero, @número é arredondado para cima à "
#~ "esquerda do separador decimal.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ROUNDUP(5.5) igual a 6.\n"
#~ "ROUNDUP(-3.3) igual a -3.\n"
#~ "ROUNDUP(1501.15,1) igual a 1501.2.\n"
#~ "ROUNDUP(1501.15,-2) igual a 1600.0.\n"
#~ "\n"
#~ "@SEEALSO=ROUND,ROUNDDOWN"

#~ msgid ""
#~ "@FUNCTION=MROUND\n"
#~ "@SYNTAX=MROUND(number,multiple)\n"
#~ "@DESCRIPTION=MROUND function rounds a given number to the desired "
#~ "multiple.\n"
#~ "\n"
#~ "@number is the number you want rounded and @multiple is the the multiple "
#~ "to which you want to round the number.\n"
#~ "\n"
#~ "* If @number and @multiple have different sign, MROUND returns #NUM! "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "MROUND(1.7,0.2) equals 1.8.\n"
#~ "MROUND(321.123,0.12) equals 321.12.\n"
#~ "\n"
#~ "@SEEALSO=ROUNDDOWN,ROUND,ROUNDUP"
#~ msgstr ""
#~ "@FUNCTION=MROUND\n"
#~ "@SYNTAX=MROUND(número,múltiplo)\n"
#~ "@DESCRIPTION=A função MROUND arredonda um número indicado para o seu "
#~ "múltiplo designado.\n"
#~ "\n"
#~ "@número é o número que deseja arredondar e @múltiplo é o múltiplo para o "
#~ "qual deseja arredondar o número.\n"
#~ "\n"
#~ "* Se @número e @múltiplo tiverem um sinal diferente, MROUND devolve o "
#~ "erro #NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "MROUND(1.7,0.2) igual a 1.8.\n"
#~ "MROUND(321.123,0.12) igual a 321.12.\n"
#~ "\n"
#~ "@SEEALSO=ROUNDDOWN,ROUND,ROUNDUP"

#~ msgid ""
#~ "@FUNCTION=ROMAN\n"
#~ "@SYNTAX=ROMAN(number[,type])\n"
#~ "@DESCRIPTION=ROMAN function returns an arabic number in the roman numeral "
#~ "style, as text. @number is the number you want to convert and @type is "
#~ "the type of roman numeral you want.\n"
#~ "\n"
#~ "* If @type is 0 or it is omitted, ROMAN returns classic roman numbers.\n"
#~ "* Type 1 is more concise than classic type, type 2 is more concise than "
#~ "type 1, and type 3 is more concise than type 2.  Type 4 is simplified "
#~ "type.\n"
#~ "* If @number is negative or greater than 3999, ROMAN returns #VALUE! "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ROMAN(999) equals CMXCIX.\n"
#~ "ROMAN(999,1) equals LMVLIV.\n"
#~ "ROMAN(999,2) equals XMIX.\n"
#~ "ROMAN(999,3) equals VMIV.\n"
#~ "ROMAN(999,4) equals IM.\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=ROMAN\n"
#~ "@SYNTAX=ROMAN(número[,tipo])\n"
#~ "@DESCRIPTION=A função ROMAN devolve um número arábico no estilo numérico "
#~ "romano, como texto. @número é o número que deseja converter e @tipo é o "
#~ "tipo de numérico romano que deseja.\n"
#~ "\n"
#~ "* Se @tipo for 0 ou for omitido, ROMAN devolve números romanos "
#~ "classicos.\n"
#~ "* Tipo 1 é mais conciso que o tipo clássico, tipo 2 é mais conciso que o "
#~ "tipo 1, e tipo 3 é mais conciso que o tipo 2.  Tipo 4 é o tipo "
#~ "simplificado.\n"
#~ "* Se @número for negativo ou maior do que 3999, ROMAN devolve o erro "
#~ "#VALOR!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ROMAN(999) igual a CMXCIX.\n"
#~ "ROMAN(999,1) igual a LMVLIV.\n"
#~ "ROMAN(999,2) igual a XMIX.\n"
#~ "ROMAN(999,3) igual a VMIV.\n"
#~ "ROMAN(999,4) igual a IM.\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=SUMX2MY2\n"
#~ "@SYNTAX=SUMX2MY2(array1,array2)\n"
#~ "@DESCRIPTION=SUMX2MY2 function returns the sum of the difference of "
#~ "squares of corresponding values in two arrays. @array1 is the first array "
#~ "or range of data points and @array2 is the second array or range of data "
#~ "points. The equation of SUMX2MY2 is SUM (x^2-y^2).\n"
#~ "\n"
#~ "* Strings and empty cells are simply ignored.\n"
#~ "* If @array1 and @array2 have different number of data points, SUMX2MY2 "
#~ "returns #N/A error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11, 15, 17, "
#~ "21, and 43 and the cells B1, B2, ..., B5 hold numbers 13, 22, 31, 33, and "
#~ "39.  Then\n"
#~ "SUMX2MY2(A1:A5,B1:B5) equals -1299.\n"
#~ "\n"
#~ "@SEEALSO=SUMSQ,SUMX2PY2"
#~ msgstr ""
#~ "@FUNCTION=SUMX2MY2\n"
#~ "@SYNTAX=SUMX2MY2(matriz1,matriz2)\n"
#~ "@DESCRIPTION=A função SUMX2MY2 devolve a soma da diferença dos quadrados "
#~ "de valores correspondentes em duas matrizes. @matriz1 é a primeira matriz "
#~ "ou área de pontos de dados e @matriz2 é a segunda matriz ou área de "
#~ "pontos de dados. A equação de SUMX2MY2 é SUM (x^2-y^2).\n"
#~ "\n"
#~ "* Expressões e células vazias são simplesmente ignoradas.\n"
#~ "* Se @matriz1 e @matriz2 tiverem um número diferente de pontos de dados, "
#~ "SUMX2MY2 devolve o erro #N/A.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1, A2, ..., A5 contêm os números 11, 15, "
#~ "17, 21, e 43 e as células B1, B2, ..., B5 contêm os números 13, 22, 31, "
#~ "33, and 39.  Então\n"
#~ "SUMX2MY2(A1:A5,B1:B5) igual a -1299.\n"
#~ "\n"
#~ "@SEEALSO=SUMSQ,SUMX2PY2"

#~ msgid ""
#~ "@FUNCTION=SUMX2PY2\n"
#~ "@SYNTAX=SUMX2PY2(array1,array2)\n"
#~ "@DESCRIPTION=SUMX2PY2 function returns the sum of the sum of squares of "
#~ "corresponding values in two arrays. @array1 is the first array or range "
#~ "of data points and @array2 is the second array or range of data points. "
#~ "The equation of SUMX2PY2 is SUM (x^2+y^2).\n"
#~ "\n"
#~ "* Strings and empty cells are simply ignored.\n"
#~ "* If @array1 and @array2 have different number of data points, SUMX2PY2 "
#~ "returns #N/A error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11, 15, 17, "
#~ "21, and 43 and the cells B1, B2, ..., B5 hold numbers 13, 22, 31, 33, and "
#~ "39.  Then\n"
#~ "SUMX2PY2(A1:A5,B1:B5) equals 7149.\n"
#~ "\n"
#~ "@SEEALSO=SUMSQ,SUMX2MY2"
#~ msgstr ""
#~ "@FUNCTION=SUMX2PY2\n"
#~ "@SYNTAX=SUMX2PY2(matriz1,matriz2)\n"
#~ "@DESCRIPTION=A função SUMX2PY2 devolve a soma da soma dos quadrados de "
#~ "valores correspondentes em duas matrizes. @matriz1 é a primeira matriz ou "
#~ "área de pontos de dados e @matriz2 é a segunda matriz ou área de pontos "
#~ "de dados. A equação de SUMX2PY2 é SUM (x^2+y^2).\n"
#~ "\n"
#~ "* Expressões e células vazias são simplesmente ignoradas.\n"
#~ "* Se @matriz1 e @matriz2 tiverem um número diferente de pontos de dados, "
#~ "SUMX2PY2 devolve o erro #N/A.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1, A2, ..., A5 contêm os números 11, 15, "
#~ "17, 21, e 43 e as células B1, B2, ..., B5 contêm os números 13, 22, 31, "
#~ "33, and 39.  Então\n"
#~ "SUMX2PY2(A1:A5,B1:B5) igual a 7149.\n"
#~ "\n"
#~ "@SEEALSO=SUMSQ,SUMX2MY2"

#~ msgid ""
#~ "@FUNCTION=SUMXMY2\n"
#~ "@SYNTAX=SUMXMY2(array1,array2)\n"
#~ "@DESCRIPTION=SUMXMY2 function returns the sum of squares of differences "
#~ "of corresponding values in two arrays. @array1 is the first array or "
#~ "range of data points and @array2 is the second array or range of data "
#~ "points. The equation of SUMXMY2 is SUM (x-y)^2.\n"
#~ "\n"
#~ "* Strings and empty cells are simply ignored.\n"
#~ "* If @array1 and @array2 have different number of data points, SUMXMY2 "
#~ "returns #N/A error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11, 15, 17, "
#~ "21, and 43 and the cells B1, B2, ..., B5 hold numbers 13, 22, 31, 33, and "
#~ "39.  Then\n"
#~ "SUMXMY2(A1:A5,B1:B5) equals 409.\n"
#~ "\n"
#~ "@SEEALSO=SUMSQ,SUMX2MY2,SUMX2PY2"
#~ msgstr ""
#~ "@FUNCTION=SUMXMY2\n"
#~ "@SYNTAX=SUMXMY2(matriz1,matriz2)\n"
#~ "@DESCRIPTION=A função SUMXMY2 devolve a soma dos quadrados das diferenças "
#~ "de valores correspondentes em duas matrizes de dados. @matriz1 é a "
#~ "primeira matriz ou área de pontos de dados e @matriz2 é a segunda matriz "
#~ "ou área de pontos de dados. A equação de SUMXMY2 é SUM (x-y)^2.\n"
#~ "\n"
#~ "* Expressões e células vazias são simplesmente ignoradas.\n"
#~ "* Se @matriz1 e @matriz2 têm número diferente de pontos de dados, SUMXMY2 "
#~ "devolve o erro #N/A.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1, A2, ..., A5 contêm os números 11, 15, "
#~ "17, 21, e 43 e as células B1, B2, ..., B5 contêm os números 13, 22, 31, "
#~ "33, and 39.  Então\n"
#~ "SUMXMY2(A1:A5,B1:B5) igual a 409.\n"
#~ "\n"
#~ "@SEEALSO=SUMSQ,SUMX2MY2,SUMX2PY2"

#~ msgid ""
#~ "@FUNCTION=SERIESSUM\n"
#~ "@SYNTAX=SERIESSUM(x,n,m,coefficients)\n"
#~ "@DESCRIPTION=SERIESSUM function returns the sum of a power series.  @x is "
#~ "the base of the power series, @n is the initial power to raise @x, @m is "
#~ "the increment to the power for each term in the series, and @coefficients "
#~ "are the coefficients by which each successive power of @x is multiplied.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 1.23, 2.32, "
#~ "2.98, 3.42, and 4.33.  Then\n"
#~ "SERIESSUM(3,1,2.23,A1:A5) equals 251416.43018.\n"
#~ "\n"
#~ "@SEEALSO=COUNT,SUM"
#~ msgstr ""
#~ "@FUNCTION=SERIESSUM\n"
#~ "@SYNTAX=SERIESSUM(x,n,m,coeficientes)\n"
#~ "@DESCRIPTION=A função SERIESSUM devolve a soma de uma série de "
#~ "potências.  @x é a base da série de potências, @n é a potência inicial "
#~ "para elevar @x, @m é o incremento à potência em cada termo da série, e "
#~ "@coeficientes são os coeficientes pelos quais cada potência sucessiva de "
#~ "@x é multiplicada.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1, A2, ..., A5 contêm os números 1.23, "
#~ "2.32, 2.98, 3.42, e 4.33.  Então\n"
#~ "SERIESSUM(3,1,2.23,A1:A5) igual a 251416.43018.\n"
#~ "\n"
#~ "@SEEALSO=COUNT,SUM"

#~ msgid ""
#~ "@FUNCTION=MINVERSE\n"
#~ "@SYNTAX=MINVERSE(matrix)\n"
#~ "@DESCRIPTION=MINVERSE function returns the inverse matrix of @matrix.\n"
#~ "\n"
#~ "* If @matrix cannot be inverted, MINVERSE returns #NUM! error.\n"
#~ "* If @matrix does not contain equal number of columns and rows, MINVERSE "
#~ "returns #VALUE! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=MMULT, MDETERM"
#~ msgstr ""
#~ "@FUNCTION=MINVERSE\n"
#~ "@SYNTAX=MINVERSE(matriz)\n"
#~ "@DESCRIPTION=A função MINVERSE devolve a matriz inversa de @matriz.\n"
#~ "\n"
#~ "* Se @matriz não puder ser invertida, MINVERSE devolve o erro #NUM!.\n"
#~ "* Se @matriz não possuir um número igual de linhas e colunas, MINVERSE "
#~ "devolve o erro #VALOR!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=MMULT, MDETERM"

#~ msgid ""
#~ "@FUNCTION=MMULT\n"
#~ "@SYNTAX=MMULT(array1,array2)\n"
#~ "@DESCRIPTION=MMULT function returns the matrix product of two arrays. The "
#~ "result is an array with the same number of rows as @array1 and the same "
#~ "number of columns as @array2.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=TRANSPOSE,MINVERSE"
#~ msgstr ""
#~ "@FUNCTION=MMULT\n"
#~ "@SYNTAX=MMULT(matriz1,matriz2)\n"
#~ "@DESCRIPTION=A função MMULT devolve a matriz produto de duas matrizes. O "
#~ "resultado é uma matriz com o mesmo número de linhas que a @matriz1 e o "
#~ "mesmo número de colunas que a @matriz2.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=TRANSPOSE,MINVERSE"

#~ msgid ""
#~ "@FUNCTION=MDETERM\n"
#~ "@SYNTAX=MDETERM(matrix)\n"
#~ "@DESCRIPTION=MDETERM function returns the determinant of a given matrix.\n"
#~ "\n"
#~ "* If the @matrix does not contain equal number of columns and rows, "
#~ "MDETERM returns #VALUE! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that A1, ..., A4 contain numbers 2, 3, 7, and 3, B1, ..., "
#~ "B4 4, 2, 4, and 1, C1, ..., C4 9, 4, 3, and 2, and D1, ..., D4 7, 3, 6, "
#~ "and 5. Then\n"
#~ "MDETERM(A1:D4) equals 148.\n"
#~ "\n"
#~ "@SEEALSO=MMULT, MINVERSE"
#~ msgstr ""
#~ "@FUNCTION=MDETERM\n"
#~ "@SYNTAX=MDETERM(matriz)\n"
#~ "@DESCRIPTION=A função MDETERM devolve o determinante de uma dada matriz.\n"
#~ "\n"
#~ "* Se a @matriz não contiver um número igual de colunas e linhas, MDETERM "
#~ "devolve o erro #VALOR!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que A1, ..., A4 contêm os números 2, 3, 7, e 3, B1, ..., B4 "
#~ "4, 2, 4, e 1, C1, ..., C4 9, 4, 3, e 2, e D1, ..., D4 7, 3, 6, e 5. "
#~ "Então\n"
#~ "MDETERM(A1:D4) igual a 148.\n"
#~ "\n"
#~ "@SEEALSO=MMULT, MINVERSE"

#~ msgid ""
#~ "@FUNCTION=RAND\n"
#~ "@SYNTAX=RAND()\n"
#~ "@DESCRIPTION=RAND returns a random number between zero and one.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RAND() returns a random number greater than zero but less than one.\n"
#~ "\n"
#~ "@SEEALSO=RANDBETWEEN"
#~ msgstr ""
#~ "@FUNCTION=RAND\n"
#~ "@SYNTAX=RAND()\n"
#~ "@DESCRIPTION=RAND devolve um número aleatório entre zero e um.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RAND() devolve um número aleatório maior do que zero mas menor do que "
#~ "um.\n"
#~ "\n"
#~ "@SEEALSO=RANDBETWEEN"

#~ msgid ""
#~ "@FUNCTION=RANDUNIFORM\n"
#~ "@SYNTAX=RANDUNIFORM(a,b)\n"
#~ "@DESCRIPTION=RANDUNIFORM returns a random variate from the uniform (flat) "
#~ "distribution from a to b. The distribution is,\n"
#~ "\n"
#~ "\tp(x) dx = {1 over (b-a)} dx : for a <= x < b.\n"
#~ "p(x) dx = 0 : for x < a or b <= x.\n"
#~ "* If @a > @b RANDUNIFORM returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDUNIFORM(1.4,4.2) returns a random number greater than or equal to 1.4 "
#~ "but less than 4.2.\n"
#~ "\n"
#~ "@SEEALSO=RANDBETWEEN,RAND"
#~ msgstr ""
#~ "@FUNCTION=RANDUNIFORM\n"
#~ "@SYNTAX=RANDUNIFORM(a,b)\n"
#~ "@DESCRIPTION=RANDUNIFORM devolve uma variação aleatória da distribuição "
#~ "uniforme (lisa) de @a a @b. A distribuição é,\n"
#~ "\n"
#~ "\tp(x) dx = {1 sobre (b-a)} dx : para a <= x < b.\n"
#~ "p(x) dx = 0 : para x < a ou b <= x.\n"
#~ "* Se @a > @b RANDUNIFORM devolve o erro #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDUNIFORM(1.4,4.2) devolve um número aleatório maior ou igual a 1.4 mas "
#~ "menor do que 4.2.\n"
#~ "\n"
#~ "@SEEALSO=RANDBETWEEN,RAND"

#~ msgid ""
#~ "@FUNCTION=RANDDISCRETE\n"
#~ "@SYNTAX=RANDDISCRETE(val_range[,prob_range])\n"
#~ "@DESCRIPTION=RANDDISCRETE returns one of the values in the @val_range. "
#~ "The probabilities for each value are given in the @prob_range.\n"
#~ "\n"
#~ "* If @prob_range is omitted, the uniform discrete distribution is "
#~ "assumed.\n"
#~ "* If the sum of all values in @prob_range is other than one, RANDDISCRETE "
#~ "returns #NUM! error.\n"
#~ "* If @val_range and @prob_range are not the same size, RANDDISCRETE "
#~ "returns #NUM! error.\n"
#~ "* If @val_range or @prob_range is not a range, RANDDISCRETE returns "
#~ "#VALUE! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDDISCRETE(A1:A6) returns one of the values in the range A1:A6.\n"
#~ "\n"
#~ "@SEEALSO=RANDBETWEEN,RAND"
#~ msgstr ""
#~ "@FUNCTION=RANDDISCRETE\n"
#~ "@SYNTAX=RANDDISCRETE(área_val[,área_prob])\n"
#~ "@DESCRIPTION=RANDDISCRETE devolve um dos valores na @área_val. As "
#~ "probabilidades de cada valor são dadas pela @área_prob.\n"
#~ "\n"
#~ "* Se @área_prob for omitida, é assumida uma distribuição discreta "
#~ "uniforme.\n"
#~ "* Se a soma de todos os valores em @área_prob for outra que não um, "
#~ "RANDDISCRETE devolve o erro #NUM!.\n"
#~ "* Se @área_val e @área_prob não forem do mesmo tamanho, RANDDISCRETE "
#~ "devolve o erro #NUM!.\n"
#~ "* Se @área_val ou @área_prob não for uma área, RANDDISCRETE devolve o "
#~ "erro #VALOR!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDDISCRETE(A1:A6) devolve um dos valores na área A1:A6.\n"
#~ "\n"
#~ "@SEEALSO=RANDBETWEEN,RAND"

#~ msgid ""
#~ "@FUNCTION=RANDEXP\n"
#~ "@SYNTAX=RANDEXP(b)\n"
#~ "@DESCRIPTION=RANDEXP returns a exponentially-distributed random number.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDEXP(0.5).\n"
#~ "\n"
#~ "@SEEALSO=RAND,RANDBETWEEN"
#~ msgstr ""
#~ "@FUNCTION=RANDEXP\n"
#~ "@SYNTAX=RANDEXP(b)\n"
#~ "@DESCRIPTION=RANDEXP devolve um número aleatório distribuido "
#~ "exponencialmente.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDEXP(0.5).\n"
#~ "\n"
#~ "@SEEALSO=RAND,RANDBETWEEN"

#~ msgid ""
#~ "@FUNCTION=RANDPOISSON\n"
#~ "@SYNTAX=RANDPOISSON(lambda)\n"
#~ "@DESCRIPTION=RANDPOISSON returns a Poisson-distributed random number.\n"
#~ "\n"
#~ "* If @lambda < 0 RANDPOISSON returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDPOISSON(3).\n"
#~ "\n"
#~ "@SEEALSO=RAND,RANDBETWEEN"
#~ msgstr ""
#~ "@FUNCTION=RANDPOISSON\n"
#~ "@SYNTAX=RANDPOISSON(lambda)\n"
#~ "@DESCRIPTION=RANDPOISSON devolve um número aleatório distribuido segundo "
#~ "Poisson.\n"
#~ "\n"
#~ "* Se @lambda < 0 RANDPOISSON devolve o erro #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDPOISSON(3).\n"
#~ "\n"
#~ "@SEEALSO=RAND,RANDBETWEEN"

#~ msgid ""
#~ "@FUNCTION=RANDBINOM\n"
#~ "@SYNTAX=RANDBINOM(p,trials)\n"
#~ "@DESCRIPTION=RANDBINOM returns a binomially-distributed random number.\n"
#~ "\n"
#~ "* If @p < 0 or @p > 1 RANDBINOM returns #NUM! error.\n"
#~ "* If @trials < 0 RANDBINOM returns #NUM! error. \n"
#~ "@EXAMPLES=\n"
#~ "RANDBINOM(0.5,2).\n"
#~ "\n"
#~ "@SEEALSO=RAND,RANDBETWEEN"
#~ msgstr ""
#~ "@FUNCTION=RANDBINOM\n"
#~ "@SYNTAX=RANDBINOM(p,tentativas)\n"
#~ "@DESCRIPTION=RANDBINOM devolve um número aleatório distribuido "
#~ "binomialmente.\n"
#~ "\n"
#~ "* Se @p < 0 ou @p > 1, RANDBINOM devolve o erro #NUM!.\n"
#~ "* Se @tentativas < 0 RANDBINOM devolve o erro #NUM!.\n"
#~ "@EXAMPLES=\n"
#~ "RANDBINOM(0.5,2).\n"
#~ "\n"
#~ "@SEEALSO=RAND,RANDBETWEEN"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=RANDBETWEEN\n"
#~ "@SYNTAX=RANDBETWEEN(bottom,top)\n"
#~ "@DESCRIPTION=RANDBETWEEN function returns a random integer number between "
#~ "and including @bottom and @top.\n"
#~ "\n"
#~ "* If @bottom is non-integer, it is rounded up.\n"
#~ "* If @top is non-integer, it is rounded down.\n"
#~ "* If @bottom > @top, RANDBETWEEN returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDBETWEEN(3,7).\n"
#~ "\n"
#~ "@SEEALSO=RAND,RANDUNIFORM"
#~ msgstr ""
#~ "@FUNCTION=RANDBETWEEN\n"
#~ "@SYNTAX=RANDBETWEEN(base,topo)\n"
#~ "@DESCRIPTION=A função RANDBETWEEN devolve um número inteiro aleatório "
#~ "entre @base e @topo.\n"
#~ "\n"
#~ "* Se @base ou @topo for um não-inteiro, será truncado.\n"
#~ "* Se @base > @topo, RANDBETWEEN devolve o erro #NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDBETWEEN(3,7).\n"
#~ "\n"
#~ "@SEEALSO=RAND,RANDUNIFORM"

#~ msgid ""
#~ "@FUNCTION=RANDNEGBINOM\n"
#~ "@SYNTAX=RANDNEGBINOM(p,failures)\n"
#~ "@DESCRIPTION=RANDNEGBINOM returns a negative binomially-distributed "
#~ "random number.\n"
#~ "\n"
#~ "* If @p < 0 or @p > 1, RANDNEGBINOM returns #NUM! error.\n"
#~ "* If @failures < 1, RANDNEGBINOM returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDNEGBINOM(0.5,2).\n"
#~ "\n"
#~ "@SEEALSO=RAND,RANDBETWEEN"
#~ msgstr ""
#~ "@FUNCTION=RANDNEGBINOM\n"
#~ "@SYNTAX=RANDNEGBINOM(p,falhas)\n"
#~ "@DESCRIPTION=RANDNEGBINOM devolve um número aleatório negativo e "
#~ "distribuido binomialmente.\n"
#~ "\n"
#~ "* Se @p < 0 ou @p > 1, RANDNEGBINOM devolve o erro #NUM!.\n"
#~ "* Se @falhas < 1, RANDNEGBINOM devolve o erro #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDNEGBINOM(0.5,2).\n"
#~ "\n"
#~ "@SEEALSO=RAND,RANDBETWEEN"

#~ msgid ""
#~ "@FUNCTION=RANDBERNOULLI\n"
#~ "@SYNTAX=RANDBERNOULLI(p)\n"
#~ "@DESCRIPTION=RANDBERNOULLI returns a Bernoulli-distributed random "
#~ "number.\n"
#~ "\n"
#~ "* If @p < 0 or @p > 1 RANDBERNOULLI returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDBERNOULLI(0.5).\n"
#~ "\n"
#~ "@SEEALSO=RAND,RANDBETWEEN"
#~ msgstr ""
#~ "@FUNCTION=RANDBERNOULLI\n"
#~ "@SYNTAX=RANDBERNOULLI(p)\n"
#~ "@DESCRIPTION=RANDBERNOULLI devolve um número aleatório distribuido "
#~ "segundo Bernoulli.\n"
#~ "\n"
#~ "* Se @p < 0 ou @p > 1 RANDBERNOULLI devolve o erro #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDBERNOULLI(0.5).\n"
#~ "\n"
#~ "@SEEALSO=RAND,RANDBETWEEN"

#~ msgid ""
#~ "@FUNCTION=RANDNORM\n"
#~ "@SYNTAX=RANDNORM(mean,stdev)\n"
#~ "@DESCRIPTION=RANDNORM returns a normal-distributed random number.\n"
#~ "\n"
#~ "* If @stdev < 0 RANDNORM returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDNORM(0,1).\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=RANDNORM\n"
#~ "@SYNTAX=RANDNORM(média,desv_padrão)\n"
#~ "@DESCRIPTION=RANDNORM devolve um número aleatório distribuido de forma "
#~ "normal.\n"
#~ "\n"
#~ "Se @desv_padrão < 0 RANDNORM devolve o erro #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDNORM(0,1).\n"
#~ "\n"
#~ "@SEEALSO=RAND"

#~ msgid ""
#~ "@FUNCTION=RANDCAUCHY\n"
#~ "@SYNTAX=RANDCAUCHY(a)\n"
#~ "@DESCRIPTION=RANDCAUCHY returns a Cauchy-distributed random number with "
#~ "scale parameter a. The Cauchy distribution is also known as the Lorentz "
#~ "distribution.\n"
#~ "\n"
#~ "* If @a < 0 RANDCAUCHY returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDCAUCHY(1).\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=RANDCAUCHY\n"
#~ "@SYNTAX=RANDCAUCHY(a)\n"
#~ "@DESCRIPTION=RANDCAUCHY devolve um número aleatório distribuido segundo "
#~ "Cauchy com parâmetro de escala a. A distribuição de Cauchy é também "
#~ "conhecida como a distribuição Lorentz.\n"
#~ "\n"
#~ "* Se @a < 0 RANDCAUCHY devolve o erro #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDCAUCHY(1).\n"
#~ "\n"
#~ "@SEEALSO=RAND"

#~ msgid ""
#~ "@FUNCTION=RANDLOGNORM\n"
#~ "@SYNTAX=RANDLOGNORM(zeta,sigma)\n"
#~ "@DESCRIPTION=RANDLOGNORM returns a lognormal-distributed random number.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDLOGNORM(1,2).\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=RANDLOGNORM\n"
#~ "@SYNTAX=RANDLOGNORM(zeta,sigma)\n"
#~ "@DESCRIPTION=RANDLOGNORM devolve um número aleatório distribuido de forma "
#~ "lognormal. \n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDLOGNORM(1,2).\n"
#~ "\n"
#~ "@SEEALSO=RAND"

#~ msgid ""
#~ "@FUNCTION=RANDWEIBULL\n"
#~ "@SYNTAX=RANDWEIBULL(a,b)\n"
#~ "@DESCRIPTION=RANDWEIBULL returns a Weibull-distributed random number.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDWEIBULL(1,2).\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=RANDWEIBULL\n"
#~ "@SYNTAX=RANDWEIBULL(a,b)\n"
#~ "@DESCRIPTION=RANDWEIBULL devolve um número aleatório distribuido segundo "
#~ "Weilbull.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDWEIBULL(1,2).\n"
#~ "\n"
#~ "@SEEALSO=RAND"

#~ msgid ""
#~ "@FUNCTION=RANDLAPLACE\n"
#~ "@SYNTAX=RANDLAPLACE(a)\n"
#~ "@DESCRIPTION=RANDLAPLACE returns a Laplace-distributed random number. "
#~ "Laplace distribution is also known as two-sided exponential probability "
#~ "distribution.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDLAPLACE(1).\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=RANDLAPLACE\n"
#~ "@SYNTAX=RANDLAPLACE(a)\n"
#~ "@DESCRIPTION=RANDLAPLACE devolve um número aleatório distribuido segundo "
#~ "Laplace. A distribuição de Laplace é também conhecida como a distribuição "
#~ "de probabilidade exponencial de dois lados.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDLAPLACE(1).\n"
#~ "\n"
#~ "@SEEALSO=RAND"

#~ msgid ""
#~ "@FUNCTION=RANDRAYLEIGH\n"
#~ "@SYNTAX=RANDRAYLEIGH(sigma)\n"
#~ "@DESCRIPTION=RANDRAYLEIGH returns a Rayleigh-distributed random number.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDRAYLEIGH(1).\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=RANDRAYLEIGH\n"
#~ "@SYNTAX=RANDRAYLEIGH(sigma)\n"
#~ "@DESCRIPTION=RANDRAYLEIGH devolve um número aleatório distribuido segundo "
#~ "Rayleigh.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDRAYLEIGH(1).\n"
#~ "\n"
#~ "@SEEALSO=RAND"

#~ msgid ""
#~ "@FUNCTION=RANDRAYLEIGHTAIL\n"
#~ "@SYNTAX=RANDRAYLEIGHTAIL(a,sigma)\n"
#~ "@DESCRIPTION=RANDRAYLEIGHTAIL returns  a random variate from the tail of "
#~ "the Rayleigh distribution with scale parameter sigma and a lower limit of "
#~ "a. The distribution is,\n"
#~ "\n"
#~ "\tp(x) dx = {x over sigma^2} exp ((a^2 - x^2) /(2 sigma^2)) dx,\n"
#~ "\n"
#~ "for x > a.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDRAYLEIGHTAIL(0.3,1).\n"
#~ "\n"
#~ "@SEEALSO=RAND,RANDRAYLEIGH"
#~ msgstr ""
#~ "@FUNCTION=RANDRAYLEIGHTAIL\n"
#~ "@SYNTAX=RANDRAYLEIGHTAIL(a,sigma)\n"
#~ "@DESCRIPTION=RANDRAYLEIGHTAIL uma variaçãoo aleatória da cauda da "
#~ "distribuição de Rayleigh com o parâmetro de escala sigma e um limite "
#~ "inferior de a. A distribuição é,\n"
#~ "\n"
#~ "\tp(x) dx = {x sobre sigma^2} exp ((a^2 - x^2) /(2 sigma^2)) dx,\n"
#~ "\n"
#~ "para x > a.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDRAYLEIGHTAIL(0.3,1).\n"
#~ "\n"
#~ "@SEEALSO=RAND,RANDRAYLEIGH"

#~ msgid ""
#~ "@FUNCTION=RANDGAMMA\n"
#~ "@SYNTAX=RANDGAMMA(a,b)\n"
#~ "@DESCRIPTION=RANDGAMMA returns a Gamma-distributed random number.\n"
#~ "\n"
#~ "* If @a <= 0 RANDGAMMA returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDGAMMA(1,2).\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=RANDGAMMA\n"
#~ "@SYNTAX=RANDGAMMA(a,b)\n"
#~ "@DESCRIPTION=RANDGAMMA devolve um número aleatório distribuido segundo "
#~ "Gamma.\n"
#~ "\n"
#~ "* Se @a <= 0 RANDGAMMA devolve o erro #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDGAMMA(1,2).\n"
#~ "\n"
#~ "@SEEALSO=RAND"

#~ msgid ""
#~ "@FUNCTION=RANDPARETO\n"
#~ "@SYNTAX=RANDPARETO(a,b)\n"
#~ "@DESCRIPTION=RANDPARETO returns a Pareto-distributed random number.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDPARETO(1,2).\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=RANDPARETO\n"
#~ "@SYNTAX=RANDPARETO(b)\n"
#~ "@DESCRIPTION=RANDPARETO devolve um número aleatório distribuido segundo "
#~ "Pareto.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDPARETO(1,2).\n"
#~ "\n"
#~ "@SEEALSO=RAND"

#~ msgid ""
#~ "@FUNCTION=RANDFDIST\n"
#~ "@SYNTAX=RANDFDIST(nu1,nu2)\n"
#~ "@DESCRIPTION=RANDFDIST returns a F-distributed random number.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDFDIST(1,2).\n"
#~ "\n"
#~ "@SEEALSO=RAND,RANDGAMMA"
#~ msgstr ""
#~ "@FUNCTION=RANDFDIST\n"
#~ "@SYNTAX=RANDFDIST(nu1,nu2)\n"
#~ "@DESCRIPTION=RANDFDIST devolve um número aleatório F-distribuido.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDFDIST(1,2).\n"
#~ "\n"
#~ "@SEEALSO=RAND,RANDGAMMA"

#~ msgid ""
#~ "@FUNCTION=RANDBETA\n"
#~ "@SYNTAX=RANDBETA(a,b)\n"
#~ "@DESCRIPTION=RANDBETA returns a Beta-distributed random number.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDBETA(1,2).\n"
#~ "\n"
#~ "@SEEALSO=RAND,RANDGAMMA"
#~ msgstr ""
#~ "@FUNCTION=RANDBETA\n"
#~ "@SYNTAX=RANDBETA(a,b)\n"
#~ "@DESCRIPTION=RANDBETA devolve um número aleatório distribuido segundo "
#~ "Beta.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDBETA(1,2).\n"
#~ "\n"
#~ "@SEEALSO=RAND,RANDGAMMA"

#~ msgid ""
#~ "@FUNCTION=RANDLOGISTIC\n"
#~ "@SYNTAX=RANDLOGISTIC(a)\n"
#~ "@DESCRIPTION=RANDLOGISTIC returns a logistic-distributed random number.  "
#~ "The distribution function is,\n"
#~ "\n"
#~ "\tp(x) dx = { exp(-x/a) over a (1 + exp(-x/a))^2 } dx for -infty < x < "
#~ "+infty.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDLOGISTIC(1).\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=RANDLOGISTIC\n"
#~ "@SYNTAX=RANDLOGISTIC(a)\n"
#~ "@DESCRIPTION=RANDLOGISTIC devolve um número aleatório distribuido segundo "
#~ "logística. A função de distribuição é,\n"
#~ "\n"
#~ "\tp(x) dx = { exp(-x/a) sobre a (1 + exp(-x/a))^2 } dx para -infty < x < "
#~ "+infty.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDLOGISTIC(1).\n"
#~ "\n"
#~ "@SEEALSO=RAND"

#~ msgid ""
#~ "@FUNCTION=RANDGEOM\n"
#~ "@SYNTAX=RANDGEOM(p)\n"
#~ "@DESCRIPTION=RANDGEOM returns a geometric-distributed random number. The "
#~ "number of independent trials with probability @p until the first success. "
#~ "The probability distribution for geometric variates is, \n"
#~ "\n"
#~ "\tp(k) =  p (1-p)^(k-1), for k >= 1.\n"
#~ "\n"
#~ "* If @p < 0 or @p > 1 RANDGEOM returns #NUM! error. \n"
#~ "@EXAMPLES=\n"
#~ "RANDGEOM(0.4).\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=RANDGEOM\n"
#~ "@SYNTAX=RANDGEOM(p)\n"
#~ "@DESCRIPTION=RANDGEOM devolve um número aleatório geometricamente "
#~ "distribuido. O número de tentativas independentes com a probabilidade @p "
#~ "até ao primeiro sucesso. A distribuição de probabilidade para variações "
#~ "geométricas é, \n"
#~ "\n"
#~ "\tp(k) =  p (1-p)^(k-1), para k >= 1.\n"
#~ "\n"
#~ "* Se @p < 0 ou @p > 1 RANDGEOM devolve o erro #NUM!. \n"
#~ "@EXAMPLES=\n"
#~ "RANDGEOM(0.4).\n"
#~ "\n"
#~ "@SEEALSO=RAND"

#~ msgid ""
#~ "@FUNCTION=RANDHYPERG\n"
#~ "@SYNTAX=RANDHYPERG(n1,n2,t)\n"
#~ "@DESCRIPTION=RANDHYPERG returns a hypergeometric-distributed random "
#~ "number. The probability distribution for hypergeometric random variates "
#~ "is,\n"
#~ "\n"
#~ "\tp(k) =  C(n_1,k) C(n_2, t-k) / C(n_1 + n_2,k), \n"
#~ "\n"
#~ "where C(a,b) = a!/(b!(a-b)!). \n"
#~ "\n"
#~ "The domain of k is max(0,t-n_2), ..., max(t,n_1).\n"
#~ "@EXAMPLES=\n"
#~ "RANDHYPERG(21,1,9).\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=RANDHYPERG\n"
#~ "@SYNTAX=RANDHYPERG(n1,n2,t)\n"
#~ "@DESCRIPTION=RANDHYPERG devolve um número aleatório hipergeometricamente "
#~ "distribuido. A probabilidade de distribuição para uma variação aleatória "
#~ "hipergeométrica é,\n"
#~ "\n"
#~ "\tp(k) =  C(n_1,k) C(n_2, t-k) / C(n_1 + n_2,k), \n"
#~ "\n"
#~ "onde C(a,b) = a!/(b!(a-b)!). \n"
#~ "\n"
#~ "O domínio de k é max(0,t-n_2), ..., max(t,n_1).\n"
#~ "@EXAMPLES=\n"
#~ "RANDHYPERG(21,1,9).\n"
#~ "\n"
#~ "@SEEALSO=RAND"

#~ msgid ""
#~ "@FUNCTION=RANDLOG\n"
#~ "@SYNTAX=RANDLOG(p)\n"
#~ "@DESCRIPTION=RANDLOG returns a logarithmic-distributed random number.\n"
#~ "\n"
#~ "* If @p < 0 or @p > 1 RANDLOG returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDLOG(0.72).\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=RANDLOG\n"
#~ "@SYNTAX=RANDLOG(p)\n"
#~ "@DESCRIPTION=RANDLOG devolve um número aleatório distribuido "
#~ "logaritmicamente.\n"
#~ "\n"
#~ "* Se @p < 0 ou @p > 1 RANDLOG devolve o erro #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDHYPERG(0.72).\n"
#~ "\n"
#~ "@SEEALSO=RAND"

#~ msgid ""
#~ "@FUNCTION=RANDCHISQ\n"
#~ "@SYNTAX=RANDCHISQ(nu)\n"
#~ "@DESCRIPTION=RANDCHISQ returns a Chi-Square-distributed random number.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDCHISQ(0.5).\n"
#~ "\n"
#~ "@SEEALSO=RAND,RANDGAMMA"
#~ msgstr ""
#~ "@FUNCTION=RANDCHISQ\n"
#~ "@SYNTAX=RANDCHISQ(nu)\n"
#~ "@DESCRIPTION=RANDCHISQ devolve um número aleatório distribuido de forma "
#~ "Chi-Quadrado.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDCHISQ(0.5).\n"
#~ "\n"
#~ "@SEEALSO=RAND,RANDGAMMA"

#~ msgid ""
#~ "@FUNCTION=RANDTDIST\n"
#~ "@SYNTAX=RANDTDIST(nu)\n"
#~ "@DESCRIPTION=RANDTDIST returns a T-distributed random number.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDTDIST(0.5).\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=RANDTDIST\n"
#~ "@SYNTAX=RANDTDIST(nu)\n"
#~ "@DESCRIPTION=RANDTDIST devolve um número aleatório T-distribuido.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDTDIST(0.5).\n"
#~ "\n"
#~ "@SEEALSO=RAND"

#~ msgid ""
#~ "@FUNCTION=RANDGUMBEL\n"
#~ "@SYNTAX=RANDGUMBEL(a,b[,type])\n"
#~ "@DESCRIPTION=RANDGUMBEL returns a Type I or Type II Gumbel-distributed "
#~ "random number. @type is either 1 or 2 and specifies the type of the "
#~ "distribution (Type I or Type II).\n"
#~ "\n"
#~ "* If @type is neither 1 nor 2, RANDGUMBEL returns #NUM! error.\n"
#~ "* If @type is omitted, Type I is assumed.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDGUMBEL(0.5,1,2).\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=RANDGUMBEL\n"
#~ "@SYNTAX=RANDGUMBEL(a,b[,tipo])\n"
#~ "@DESCRIPTION=RANDGUMBEL devolve um número aleatório segundo a "
#~ "distribuição de Gumbel Tipo I ou Tipo II. @tipo é 1 ou 2 e especifica o "
#~ "tipo da distribuição (Tipo I ou Tipo II).\n"
#~ "\n"
#~ "* Se @tipo não for nem 1 nem 2, RANDGUMBEL devolve o erro #NUM!.\n"
#~ "* Se @tipo for omitido, é assumido Tipo I.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDGUMBEL(0.5,1,2).\n"
#~ "\n"
#~ "@SEEALSO=RAND"

#~ msgid ""
#~ "@FUNCTION=RANDLEVY\n"
#~ "@SYNTAX=RANDLEVY(c,alpha[,beta])\n"
#~ "@DESCRIPTION=RANDLEVY returns a Levy-distributed random number. If @beta "
#~ "is omitted, it is assumed to be 0.\n"
#~ "\n"
#~ "* For @alpha = 1, @beta=0, we get the Lorentz distribution.\n"
#~ "* For @alpha = 2, @beta=0, we get the normal distribution.\n"
#~ "\n"
#~ "* If @alpha <= 0 or @alpha > 2, RANDLEVY returns #NUM! error.\n"
#~ "* If @beta < -1 or @beta > 1, RANDLEVY returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDLEVY(0.5,0.1,1).\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=RANDLEVY\n"
#~ "@SYNTAX=RANDLEVY(c,alfa[,beta])\n"
#~ "@DESCRIPTION=RANDLEVY devolve um número aleatório distribuido segundo "
#~ "Levy. Se @beta for omitido, é assumido como 0.\n"
#~ "\n"
#~ "* Para @alfa = 1, @beta=0, obtemos a distribuição de Lorentz.\n"
#~ "* Para @alfa = 2, @beta=0, obtemos a distribuição normal.\n"
#~ "\n"
#~ "* Se @alfa <= 0 ou @alpha > 2, RANDLEVY devolve o erro #NUM!.\n"
#~ "* Se @beta < -1 or @beta > 1, RANDLEVY devolve o erro #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDLEVY(0.5,0.1,1).\n"
#~ "\n"
#~ "@SEEALSO=RAND"

#~ msgid ""
#~ "@FUNCTION=RANDEXPPOW\n"
#~ "@SYNTAX=RANDEXPPOW(a,b)\n"
#~ "@DESCRIPTION=RANDEXPPOW returns a random variate from the exponential "
#~ "power distribution with scale parameter @a and exponent @b. The "
#~ "distribution is,\n"
#~ "\n"
#~ "\tp(x) dx = {1 over 2 a Gamma(1+1/b)} exp(-|x/a|^b) dx, for x >= 0.\n"
#~ "\n"
#~ "* For @b = 1 this reduces to the Laplace distribution.\n"
#~ "* For @b = 2 it has the same form as a normal distribution with sigma = a/"
#~ "sqrt(2).\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDEXPPOW(0.5,0.1).\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=RANDEXPPOW\n"
#~ "@SYNTAX=RANDEXPPOW(a,b)\n"
#~ "@DESCRIPTION=RANDEXPPOW devolve uma variante aleatória da distribuição de "
#~ "potencia expoencial com parâmetro de escala @a e expoente @b. A "
#~ "distribuição é,\n"
#~ "\n"
#~ "\tp(x) dx = {1 sobre 2 a Gamma(1+1/b)} exp(-|x/a|^b) dx, para x >= 0.\n"
#~ "\n"
#~ "* Para @b = 1 reduz-se à distribuição de Laplace.\n"
#~ "* Para @b = 2 tem a mesma forma que a distribuição normal, mas com um "
#~ "sigma = a/sqrt(2).\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDEXPPOW(0.5,0.1).\n"
#~ "\n"
#~ "@SEEALSO=RAND"

#~ msgid ""
#~ "@FUNCTION=RANDLANDAU\n"
#~ "@SYNTAX=RANDLANDAU()\n"
#~ "@DESCRIPTION=RANDLANDAU returns a random variate from the Landau "
#~ "distribution. The probability distribution for Landau random variates is "
#~ "defined analytically by the complex integral,\n"
#~ "\n"
#~ "\tp(x) = (1/(2 pi i)) int_{c-i infty}^{c+i infty} ds exp(s log(s) + x "
#~ "s).\n"
#~ "\n"
#~ "For numerical purposes it is more convenient to use the following "
#~ "equivalent form of the integral,\n"
#~ "\n"
#~ "\tp(x) = (1/pi) int_0^ infty dt exp(-t log(t) - x t) sin(pi t).\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDLANDAU().\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=RANDLANDAU\n"
#~ "@SYNTAX=RANDLANDAU()\n"
#~ "@DESCRIPTION=RANDLANDAU devolve uma variante aleatória da distribuição de "
#~ "Landau. A probabilidade da distribuição para variantes aleatórias de "
#~ "Landau é definida analiticamente pelo integral complexo,\n"
#~ "\n"
#~ "\tp(x) = (1/(2 pi i)) int_{c-i infty}^{c+i infty} ds exp(s log(s) + x "
#~ "s).\n"
#~ "\n"
#~ "Para efeitos numéricos é mais conveniente utilizar a seguinte forma "
#~ "equivalente do integral,\n"
#~ "\n"
#~ "\tp(x) = (1/pi) int_0^ infty dt exp(-t log(t) - x t) sin(pi t).\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDLANDAU().\n"
#~ "\n"
#~ "@SEEALSO=RAND"

#~ msgid ""
#~ "@FUNCTION=RANDNORMTAIL\n"
#~ "@SYNTAX=RANDNORMTAIL(a,sigma)\n"
#~ "@DESCRIPTION=RANDNORMTAIL returns a random variates from the upper tail "
#~ "of a normal distribution with standard deviation @sigma. The values "
#~ "returned are larger than the lower limit @a, which must be positive. The "
#~ "method is based on Marsaglia's famous rectangle-wedge-tail algorithm (Ann "
#~ "Math Stat 32, 894-899 (1961)), with this aspect explained in Knuth, v2, "
#~ "3rd ed, p139, 586 (exercise 11).\n"
#~ "\n"
#~ "The probability distribution for normal tail random variates is,\n"
#~ "\n"
#~ "\tp(x) dx = {1 over N(a;sigma)} exp (- x^2/(2 sigma^2)) dx,\n"
#~ "\n"
#~ "for x > a where N(a;sigma) is the normalization constant, N(a;sigma) = "
#~ "(1/2) erfc(a / sqrt(2 sigma^2)).\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDNORMTAIL(0.5,0.1).\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=RANDNORMTAIL\n"
#~ "@SYNTAX=RANDNORMTAIL(a,sigma)\n"
#~ "@DESCRIPTION=RANDNORMTAIL devolve uma variante aleatória da cauda "
#~ "superior de uma distribuição normal com desvio padrão @sigma. Os valores "
#~ "devolvidos são maiores que o limite inferior @a, que tem de ser positivo. "
#~ "O método é baseado no famoso algorítmo rectângulo-cunha-cauda de "
#~ "Marsaglia (Ann Math Stat 32, 894-899 (1961)), com este aspecto explicado "
#~ "em Knuth, v2, 3rd ed, p139, 586 (exercício 11).\n"
#~ "\n"
#~ "A probabilidade da distribuição para a variante aleatória de cauda normal "
#~ "é,\n"
#~ "\n"
#~ "\tp(x) dx = {1 sobre N(a;sigma)} exp (- x^2/(2 sigma^2)) dx,\n"
#~ "\n"
#~ "para x > a onde N(a;sigma) é a constante de normalização, N(a;sigma) = "
#~ "(1/2) erfc(a / sqrt(2 sigma^2)).\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDNORMTAIL(0.5,0.1).\n"
#~ "\n"
#~ "@SEEALSO=RAND"

#~ msgid ""
#~ "@FUNCTION=VARP\n"
#~ "@SYNTAX=VARP(b1, b2, ...)\n"
#~ "@DESCRIPTION=VARP calculates the variance of an entire population.\n"
#~ "VARP is also known as the N-variance.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "VARP(A1:A5) equals 94.112.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,DVAR,DVARP,STDEV,VAR"
#~ msgstr ""
#~ "@FUNCTION=VARP\n"
#~ "@SYNTAX=VARP(b1, b2, ...)\n"
#~ "@DESCRIPTION=VARP calcula a variância de um conjunto de números em que "
#~ "cada número é um membro da população e o conjunto é toda a população.\n"
#~ "\n"
#~ "* VARP é também conhecida como a variância-N.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1, A2, ..., A5 contêm os números 11.4, "
#~ "17.3, 21.3, 25.9, e 40.1.  Então\n"
#~ "VARP(A1:A5) igual a 94.112.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,DVAR,DVARP,STDEV,VAR"

#~ msgid ""
#~ "@FUNCTION=VAR\n"
#~ "@SYNTAX=VAR(b1, b2, ...)\n"
#~ "@DESCRIPTION=VAR calculates sample variance of the given sample. To get "
#~ "the true variance of a complete population use VARP.\n"
#~ "VAR is also known as the N-1-variance. Under reasonable conditions, it is "
#~ "the maximum-likelihood estimator for the true variance.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "VAR(A1:A5) equals 117.64.\n"
#~ "\n"
#~ "@SEEALSO=VARP,STDEV"
#~ msgstr ""
#~ "@FUNCTION=VAR\n"
#~ "@SYNTAX=VAR(b1, b2, ...)\n"
#~ "@DESCRIPTION=VAR estima a variância de uma amostra da população. Para "
#~ "obter a variância real de uma população completa utilize VARP.\n"
#~ "\n"
#~ "* VAR é também conhecida como a variância N-1. Sob condições razoáveis, é "
#~ "a estimativa de máxima semelhança da variância real.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1, A2, ..., A5 contêm os números 11.4, "
#~ "17.3, 21.3, 25.9, e 40.1.  Então\n"
#~ "VAR(A1:A5) igual a 117.64.\n"
#~ "\n"
#~ "@SEEALSO=VARP,STDEV"

#~ msgid ""
#~ "@FUNCTION=STDEV\n"
#~ "@SYNTAX=STDEV(b1, b2, ...)\n"
#~ "@DESCRIPTION=STDEV returns the sample standard deviation of the given "
#~ "sample.\n"
#~ "To obtain the population standard deviation of a whole population use "
#~ "STDEVP.\n"
#~ "STDEV is also known as the N-1-standard deviation.\n"
#~ "Under reasonable conditions, it is the maximum-likelihood estimator for "
#~ "the true population standard deviation.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "STDEV(A1:A5) equals 10.84619749.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,DSTDEV,DSTDEVP,STDEVA,STDEVPA,VAR"
#~ msgstr ""
#~ "@FUNCTION=VAR\n"
#~ "@SYNTAX=VAR(b1, b2, ...)\n"
#~ "@DESCRIPTION=VAR estima a variância de uma amostra da população. Para "
#~ "obter a variância real de uma população completa utilize VARP.\n"
#~ "\n"
#~ "* VAR é também conhecida como a variância N-1. Sob condições razoáveis, é "
#~ "a estimativa de máxima semelhança da variância real.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1, A2, ..., A5 contêm os números 11.4, "
#~ "17.3, 21.3, 25.9, e 40.1.  Então\n"
#~ "VAR(A1:A5) igual a 117.64.\n"
#~ "\n"
#~ "@SEEALSO=VARP,STDEV"

#~ msgid ""
#~ "@FUNCTION=STDEVP\n"
#~ "@SYNTAX=STDEVP(b1, b2, ...)\n"
#~ "@DESCRIPTION=STDEVP returns the population standard deviation of the "
#~ "given population. \n"
#~ "This is also known as the N-standard deviation\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "STDEVP(A1:A5) equals 9.701133954.\n"
#~ "\n"
#~ "@SEEALSO=STDEV,STDEVA,STDEVPA"
#~ msgstr ""
#~ "@FUNCTION=STDEVP\n"
#~ "@SYNTAX=STDEVP(b1, b2, ...)\n"
#~ "@DESCRIPTION=STDEVP devolve o desvio padrão de um conjunto de números, "
#~ "tratando esses números como membros de uma população completa.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1, A2, ..., A5 contêm os números 11.4, "
#~ "17.3, 21.3, 25.9, e 40.1.  Então\n"
#~ "STDEVP(A1:A5) igual a 9.701133954.\n"
#~ "\n"
#~ "@SEEALSO=STDEV,STDEVA,STDEVPA"

#~ msgid ""
#~ "@FUNCTION=RANK\n"
#~ "@SYNTAX=RANK(x,ref[,order])\n"
#~ "@DESCRIPTION=RANK returns the rank of a number in a list of numbers.  @x "
#~ "is the number whose rank you want to find, @ref is the list of numbers, "
#~ "and @order specifies how to rank numbers.  If @order is 0, numbers are "
#~ "ranked in descending order, otherwise numbers are ranked in ascending "
#~ "order.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "RANK(17.3,A1:A5) equals 4.\n"
#~ "\n"
#~ "@SEEALSO=PERCENTRANK"
#~ msgstr ""
#~ "@FUNCTION=RANK\n"
#~ "@SYNTAX=RANK(x,ref[,ordem])\n"
#~ "@DESCRIPTION=RANK devolve a posição de um número numa lista de números.  "
#~ "@x é o número cuja classificação desejamos descobrir, @ref é a lista de "
#~ "números, e @ordem especifica como classificar os números.  Se @ordem for "
#~ "0, os números são classificados em ordem descendente, caso contrário são "
#~ "ordenados ascendentemente.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1, A2, ..., A5 contêm os números 11.4, "
#~ "17.3, 21.3, 25.9, e 40.1.  Então\n"
#~ "RANK(17.3,A1:A5) igual a 4.\n"
#~ "\n"
#~ "@SEEALSO=PERCENTRANK"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=TRIMMEAN\n"
#~ "@SYNTAX=TRIMMEAN(ref,fraction)\n"
#~ "@DESCRIPTION=TRIMMEAN returns the mean of the interior of a data set. "
#~ "@ref is the list of numbers whose mean you want to calculate and "
#~ "@fraction is the fraction of the data set excluded from the mean. For "
#~ "example, if @fraction=0.2 and the data set contains 40 numbers, 8 numbers "
#~ "are trimmed from the data set (40 x 0.2): the 4 largest and the 4 "
#~ "smallest.  To avoid a bias, the number of points to be excluded is always "
#~ "rounded down to the nearest even number.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "TRIMMEAN(A1:A5,0.2) equals 23.2.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,GEOMEAN,HARMEAN,MEDIAN,MODE"
#~ msgstr ""
#~ "@FUNCTION=TRIMMEAN\n"
#~ "@SYNTAX=TRIMMEAN(ref,fracção)\n"
#~ "@DESCRIPTION=TRIMMEAN devolve a média do interior do conjunto de dados. "
#~ "@ref é a lista de números cuja média deseja calcular e @fracção é a "
#~ "fracção do conjunto de dados excluídos da média. Por exemplo, se "
#~ "@fracção=0.2 e o conjunto de dados contém 40 números, 8 números são "
#~ "excluidos do conjunto de dados (40 x 0.2), 4 do topo e 4 do fundo do "
#~ "conjunto.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1, A2, ..., A5 contêm os números 11.4, "
#~ "17.3, 21.3, 25.9, e 40.1.  Então\n"
#~ "TRIMMEAN(A1:A5,0.2) igual a 23.2.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,GEOMEAN,HARMEAN,MEDIAN,MODE"

#~ msgid ""
#~ "@FUNCTION=COVAR\n"
#~ "@SYNTAX=COVAR(array1,array2)\n"
#~ "@DESCRIPTION=COVAR returns the covariance of two data sets.\n"
#~ "\n"
#~ "* Strings and empty cells are simply ignored.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1, and the cells B1, B2, ... B5 23.2, 25.8, 29.9, "
#~ "33.5, and 42.7.  Then\n"
#~ "COVAR(A1:A5,B1:B5) equals 65.858.\n"
#~ "\n"
#~ "@SEEALSO=CORREL,FISHER,FISHERINV"
#~ msgstr ""
#~ "@FUNCTION=COVAR\n"
#~ "@SYNTAX=COVAR(matriz1,matriz2)\n"
#~ "@DESCRIPTION=COVAR devolve a covariância de dois conjuntos de dados.\n"
#~ "\n"
#~ "* Expressões e células vazias são simplesmente ignoradas.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1, A2, ..., A5 contêm os números 11.4, "
#~ "17.3, 21.3, 25.9, e 40.1, e as células B1, B2, ... B5 23.2, 25.8, 29.9, "
#~ "33.5, e 42.7.  Então\n"
#~ "COVAR(A1:A5,B1:B5) igual a 65.858.\n"
#~ "\n"
#~ "@SEEALSO=CORREL,FISHER,FISHERINV"

#~ msgid ""
#~ "@FUNCTION=CORREL\n"
#~ "@SYNTAX=CORREL(array1,array2)\n"
#~ "@DESCRIPTION=CORREL returns the correlation coefficient of two data "
#~ "sets.\n"
#~ "\n"
#~ "* Strings and empty cells are simply ignored.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1, and the cells B1, B2, ... B5 23.2, 25.8, 29.9, "
#~ "33.5, and 42.7.  Then\n"
#~ "CORREL(A1:A5,B1:B5) equals 0.996124788.\n"
#~ "\n"
#~ "@SEEALSO=COVAR,FISHER,FISHERINV"
#~ msgstr ""
#~ "@FUNCTION=CORREL\n"
#~ "@SYNTAX=CORREL(matriz1,matriz2)\n"
#~ "@DESCRIPTION=CORREL devolve o coeficiente de correlação de dois conjuntos "
#~ "de dados.\n"
#~ "\n"
#~ "* Expressões e células vazias são simplesmente ignoradas.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1, A2, ..., A5 contêm os números 11.4, "
#~ "17.3, 21.3, 25.9, e 40.1, e as células B1, B2, ... B5 23.2, 25.8, 29.9, "
#~ "33.5, e 42.7.  Então\n"
#~ "CORREL(A1:A5,B1:B5) igual a 0.996124788.\n"
#~ "\n"
#~ "@SEEALSO=COVAR,FISHER,FISHERINV"

#~ msgid ""
#~ "@FUNCTION=NEGBINOMDIST\n"
#~ "@SYNTAX=NEGBINOMDIST(f,t,p)\n"
#~ "@DESCRIPTION=NEGBINOMDIST function returns the negative binomial "
#~ "distribution. @f is the number of failures, @t is the threshold number of "
#~ "successes, and @p is the probability of a success.\n"
#~ "\n"
#~ "* If @f or @t is a non-integer it is truncated.\n"
#~ "* If (@f + @t -1) <= 0 NEGBINOMDIST returns #NUM! error.\n"
#~ "* If @p < 0 or @p > 1 NEGBINOMDIST returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "NEGBINOMDIST(2,5,0.55) equals 0.152872629.\n"
#~ "\n"
#~ "@SEEALSO=BINOMDIST,COMBIN,FACT,HYPGEOMDIST,PERMUT"
#~ msgstr ""
#~ "@FUNCTION=NEGBINOMDIST\n"
#~ "@SYNTAX=NEGBINOMDIST(f,t,p)\n"
#~ "@DESCRIPTION=A função NEGBINOMDIST devolve a distribuição binomial "
#~ "negativa. @f é o número de falhas, @t é o número limiar de sucessos, e @p "
#~ "é a probabilidade de um sucesso.\n"
#~ "\n"
#~ "* Se @f ou @t for um não-inteiro será truncado.\n"
#~ "* Se (@f + @t -1) <= 0 NEGBINOMDIST devolve o erro #NUM!.\n"
#~ "* Se @p < 0 ou @p > 1 NEGBINOMDIST devolve o erro #NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "NEGBINOMDIST(2,5,0.55) igual a 0.152872629.\n"
#~ "\n"
#~ "@SEEALSO=BINOMDIST,COMBIN,FACT,HYPGEOMDIST,PERMUT"

#~ msgid ""
#~ "@FUNCTION=NORMSDIST\n"
#~ "@SYNTAX=NORMSDIST(x)\n"
#~ "@DESCRIPTION=NORMSDIST function returns the standard normal cumulative "
#~ "distribution. @x is the value for which you want the distribution.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "NORMSDIST(2) equals 0.977249868.\n"
#~ "\n"
#~ "@SEEALSO=NORMDIST"
#~ msgstr ""
#~ "@FUNCTION=NORMSDIST\n"
#~ "@SYNTAX=NORMSDIST(x)\n"
#~ "@DESCRIPTION=A função NORMSDIST devolve a distribuição standard normal "
#~ "acumulada. @x é o valor para o qual deseja a distribuição.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "NORMSDIST(2) igual a 0.977249868.\n"
#~ "\n"
#~ "@SEEALSO=NORMDIST"

#~ msgid ""
#~ "@FUNCTION=NORMSINV\n"
#~ "@SYNTAX=NORMSINV(p)\n"
#~ "@DESCRIPTION=NORMSINV function returns the inverse of the standard normal "
#~ "cumulative distribution. @p is the given probability corresponding to the "
#~ "normal distribution.\n"
#~ "\n"
#~ "* If @p < 0 or @p > 1 NORMSINV returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "NORMSINV(0.2) equals -0.841621234.\n"
#~ "\n"
#~ "@SEEALSO=NORMDIST,NORMINV,NORMSDIST,STANDARDIZE,ZTEST"
#~ msgstr ""
#~ "@FUNCTION=NORMSINV\n"
#~ "@SYNTAX=NORMSINV(p)\n"
#~ "@DESCRIPTION=A função NORMSINV devolve a inversa da distribuição normal "
#~ "standard acumulativa. @p é a probabilidade indicada que corresponde à "
#~ "distribuição normal.\n"
#~ "\n"
#~ "* Se @p < 0 ou @p > 1 NORMSINV devolve o erro #NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "NORMSINV(0.2) igual a -0.841621234.\n"
#~ "\n"
#~ "@SEEALSO=NORMDIST,NORMINV,NORMSDIST,STANDARDIZE,ZTEST"

#~ msgid ""
#~ "@FUNCTION=LOGNORMDIST\n"
#~ "@SYNTAX=LOGNORMDIST(x,mean,stddev)\n"
#~ "@DESCRIPTION=LOGNORMDIST function returns the lognormal distribution. @x "
#~ "is the value for which you want the distribution, @mean is the mean of "
#~ "the distribution, and @stddev is the standard deviation of the "
#~ "distribution.\n"
#~ "\n"
#~ "* If @stddev = 0 LOGNORMDIST returns #DIV/0! error.\n"
#~ "* If @x <= 0, @mean < 0 or @stddev < 0 LOGNORMDIST returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LOGNORMDIST(3,1,2) equals 0.519662338.\n"
#~ "\n"
#~ "@SEEALSO=NORMDIST"
#~ msgstr ""
#~ "@FUNCTION=LOGNORMDIST\n"
#~ "@SYNTAX=LOGNORMDIST(x,média,desvpad)\n"
#~ "@DESCRIPTION=A função LOGNORMDIST devolve a distribuição lognormal. @x é "
#~ "o valor para o qual deseja a distribuição, @média é a média da "
#~ "distribuição, e @desvpad é o desvio padrão da distribuição.\n"
#~ "\n"
#~ "* Se @desvpad = 0 LOGNORMDIST devolve o erro #DIV/0!.\n"
#~ "* Se @x <= 0, @média < 0 ou @desvpad < 0 LOGNORMDIST devolve o erro "
#~ "#NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LOGNORMDIST(3,1,2) igual a 0.519662338.\n"
#~ "\n"
#~ "@SEEALSO=NORMDIST"

#~ msgid ""
#~ "@FUNCTION=LOGINV\n"
#~ "@SYNTAX=LOGINV(p,mean,stddev)\n"
#~ "@DESCRIPTION=LOGINV function returns the inverse of the lognormal "
#~ "cumulative distribution. @p is the given probability corresponding to the "
#~ "normal distribution, @mean is the arithmetic mean of the distribution, "
#~ "and @stddev is the standard deviation of the distribution.\n"
#~ "\n"
#~ "* If @p < 0 or @p > 1 or @stddev <= 0 LOGINV returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LOGINV(0.5,2,3) equals 7.389056099.\n"
#~ "\n"
#~ "@SEEALSO=EXP,LN,LOG,LOG10,LOGNORMDIST"
#~ msgstr ""
#~ "@FUNCTION=LOGINV\n"
#~ "@SYNTAX=LOGINV(p,média,desvpad)\n"
#~ "@DESCRIPTION=A função LOGINV devolve a inversa da distribuição lognormal "
#~ "acumulada. @p é a probabilidade indicada correspondendo à distribuição "
#~ "normal, @média é a média aritmética da distribuição, e @desvpad é o "
#~ "desvio padrão da distribuição.\n"
#~ "\n"
#~ "* Se @p < 0 ou @p > 1 ou @desvpad <= 0 LOGINV devolve o erro #NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LOGINV(0.5,2,3) igual a 7.389056099.\n"
#~ "\n"
#~ "@SEEALSO=EXP,LN,LOG,LOG10,LOGNORMDIST"

#~ msgid ""
#~ "@FUNCTION=FISHERINV\n"
#~ "@SYNTAX=FISHERINV(x)\n"
#~ "@DESCRIPTION=FISHERINV function returns the inverse of the Fisher "
#~ "transformation at @x.\n"
#~ "\n"
#~ "* If @x is non-number FISHERINV returns #VALUE! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FISHERINV(2) equals 0.96402758.\n"
#~ "\n"
#~ "@SEEALSO=FISHER"
#~ msgstr ""
#~ "@FUNCTION=FISHERINV\n"
#~ "@SYNTAX=FISHERINV(x)\n"
#~ "@DESCRIPTION=A função FISHERINV devolve o inverso da transformação de "
#~ "Fisher aplicada sobre @x.\n"
#~ "\n"
#~ "* Se @x for não-numérico FISHERINV devolve o erro #VALUE!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FISHERINV(2) igual a 0.96402758.\n"
#~ "\n"
#~ "@SEEALSO=FISHER"

#~ msgid ""
#~ "@FUNCTION=MODE\n"
#~ "@SYNTAX=MODE(n1, n2, ...)\n"
#~ "@DESCRIPTION=MODE returns the most common number of the data set. If the "
#~ "data set has many most common numbers MODE returns the first one of "
#~ "them.\n"
#~ "\n"
#~ "* Strings and empty cells are simply ignored.\n"
#~ "* If the data set does not contain any duplicates MODE returns #N/A "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "11.4, 25.9, and 40.1.  Then\n"
#~ "MODE(A1:A5) equals 11.4.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,MEDIAN"
#~ msgstr ""
#~ "@FUNCTION=MODE\n"
#~ "@SYNTAX=MODE(n1, n2, ...)\n"
#~ "@DESCRIPTION=MODE devolve o número mais comum no conjunto de dados. Se o "
#~ "conjunto de dados tiver vários números mais comuns MODE devolve o "
#~ "primeiro. \n"
#~ "\n"
#~ "* Expressões e células vazias são simplesmente ignoradas.\n"
#~ "* Se o conjunto de dados não contiver quaisquer duplicados MODE devolve o "
#~ "erro #N/A!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1, A2, ..., A5 contêm os números 11.4, "
#~ "17.3, 21.3, 25.9, e 40.1.  Então\n"
#~ "MODE(A1:A5) igual a 11.4.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,MEDIAN"

#~ msgid ""
#~ "@FUNCTION=HARMEAN\n"
#~ "@SYNTAX=HARMEAN(b1, b2, ...)\n"
#~ "@DESCRIPTION=HARMEAN returns the harmonic mean of the N data points (that "
#~ "is, N divided by the sum of the inverses of the data points).\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "HARMEAN(A1:A5) equals 19.529814427.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,GEOMEAN,MEDIAN,MODE,TRIMMEAN"
#~ msgstr ""
#~ "@FUNCTION=HARMEAN\n"
#~ "@SYNTAX=HARMEAN(b1, b2, ...)\n"
#~ "@DESCRIPTION=HARMEAN devolve a média harmónica dos N pontos de dados "
#~ "(isto é, N dividido pela soma dos inversos dos pontos de dados).\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1, A2, ..., A5 contêm os números 11.4, "
#~ "17.3, 21.3, 25.9, e 40.1.  Então\n"
#~ "HARMEAN(A1:A5) igual a 19.529814427.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,GEOMEAN,MEDIAN,MODE,TRIMMEAN"

#~ msgid ""
#~ "@FUNCTION=GEOMEAN\n"
#~ "@SYNTAX=GEOMEAN(b1, b2, ...)\n"
#~ "@DESCRIPTION=GEOMEAN returns the geometric mean of the given arguments. "
#~ "This is equal to the Nth root of the product of the terms.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "GEOMEAN(A1:A5) equals 21.279182482.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,HARMEAN,MEDIAN,MODE,TRIMMEAN"
#~ msgstr ""
#~ "@FUNCTION=GEOMEAN\n"
#~ "@SYNTAX=GEOMEAN(b1, b2, ...)\n"
#~ "@DESCRIPTION=GEOMEAN devolve a média geométrica dos argumentos passados. "
#~ "Isto é igual à Nésima raíz do produto dos termos.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1, A2, ..., A5 contêm os números 11.4, "
#~ "17.3, 21.3, 25.9, e 40.1.  Então\n"
#~ "GEOMEAN(A1:A5) igual a 21.279182482.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,HARMEAN,MEDIAN,MODE,TRIMMEAN"

#~ msgid ""
#~ "@FUNCTION=COUNT\n"
#~ "@SYNTAX=COUNT(b1, b2, ...)\n"
#~ "@DESCRIPTION=COUNT returns the total number of integer or floating point "
#~ "arguments passed.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "COUNT(A1:A5) equals 5.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE"
#~ msgstr ""
#~ "@FUNCTION=COUNT\n"
#~ "@SYNTAX=COUNT(b1, b2, ...)\n"
#~ "@DESCRIPTION=COUNT devolve o número total de argumentos inteiros ou de "
#~ "vírgula flutuante que foram passados.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1, A2, ..., A5 contêm os números 11.4, "
#~ "17.3, 21.3, 25.9, e 40.1.  Então\n"
#~ "COUNT(A1:A5) igual a 5.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE"

#~ msgid ""
#~ "@FUNCTION=COUNTA\n"
#~ "@SYNTAX=COUNTA(b1, b2, ...)\n"
#~ "@DESCRIPTION=COUNTA returns the number of arguments passed not including "
#~ "empty cells.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers and strings "
#~ "11.4, \"missing\", \"missing\", 25.9, and 40.1.  Then\n"
#~ "COUNTA(A1:A5) equals 5.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,COUNT,DCOUNT,DCOUNTA,PRODUCT,SUM"
#~ msgstr ""
#~ "@FUNCTION=COUNTA\n"
#~ "@SYNTAX=COUNTA(b1, b2, ...)\n"
#~ "@DESCRIPTION=COUNTA devolve o número de argumentos passados não incluindo "
#~ "células vazias.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1, A2, ..., A5 contêm os números e "
#~ "expressões 11.4, \"em falta\", \"em falta\", 25.9, e 40.1.  Então\n"
#~ "COUNTA(A1:A5) igual a 5.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,COUNT,DCOUNT,DCOUNTA,PRODUCT,SUM"

#~ msgid ""
#~ "@FUNCTION=AVERAGE\n"
#~ "@SYNTAX=AVERAGE(value1, value2,...)\n"
#~ "@DESCRIPTION=AVERAGE computes the average of all the values and cells "
#~ "referenced in the argument list.  This is equivalent to the sum of the "
#~ "arguments divided by the count of the arguments.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "AVERAGE(A1:A5) equals 23.2.\n"
#~ "\n"
#~ "@SEEALSO=SUM, COUNT"
#~ msgstr ""
#~ "@FUNCTION=AVERAGE\n"
#~ "@SYNTAX=AVERAGE(valor1, valor2,...)\n"
#~ "@DESCRIPTION=AVERAGE calcula a média de todos os valores e células "
#~ "referenciadas na lista de argumentos.  Isto é equivalente à soma dos "
#~ "argumentos dividida pela número dos mesmos.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1, A2, ..., A5 contêm os números 11.4, "
#~ "17.3, 21.3, 25.9, e 40.1.  Então\n"
#~ "AVERAGE(A1:A5) igual a 23.2.\n"
#~ "\n"
#~ "@SEEALSO=SUM, COUNT"

#~ msgid ""
#~ "@FUNCTION=MIN\n"
#~ "@SYNTAX=MIN(b1, b2, ...)\n"
#~ "@DESCRIPTION=MIN returns the value of the element of the values passed "
#~ "that has the smallest value, with negative numbers considered smaller "
#~ "than positive numbers.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "MIN(A1:A5) equals 11.4.\n"
#~ "\n"
#~ "@SEEALSO=MAX,ABS"
#~ msgstr ""
#~ "@FUNCTION=MIN\n"
#~ "@SYNTAX=MIN(b1, b2, ...)\n"
#~ "@DESCRIPTION=MIN devolve o valor do elemento de entre os argumentos "
#~ "indicados que tem o menor valor, sendo os números negativos considerados "
#~ "menores que os números positivos.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1, A2, ..., A5 contêm os números 11.4, "
#~ "17.3, 21.3, 25.9, e 40.1.  Então\n"
#~ "MIN(A1:A5) igual a 11.4.\n"
#~ "\n"
#~ "@SEEALSO=MAX,ABS"

#~ msgid ""
#~ "@FUNCTION=MAX\n"
#~ "@SYNTAX=MAX(b1, b2, ...)\n"
#~ "@DESCRIPTION=MAX returns the value of the element of the values passed "
#~ "that has the largest value, with negative numbers considered smaller than "
#~ "positive numbers.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "MAX(A1:A5) equals 40.1.\n"
#~ "\n"
#~ "@SEEALSO=MIN,ABS"
#~ msgstr ""
#~ "@FUNCTION=MAX\n"
#~ "@SYNTAX=MAX(b1, b2, ...)\n"
#~ "@DESCRIPTION=MAX devolve o valor do elemento de entre os argumentos "
#~ "indicados que tem o maior valor, sendo os números negativos considerados "
#~ "menores que os números positivos.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1, A2, ..., A5 contêm os números 11.4, "
#~ "17.3, 21.3, 25.9, e 40.1.  Então\n"
#~ "MAX(A1:A5) igual a 40.1.\n"
#~ "\n"
#~ "@SEEALSO=MIN,ABS"

#~ msgid ""
#~ "@FUNCTION=SKEW\n"
#~ "@SYNTAX=SKEW(n1, n2, ...)\n"
#~ "@DESCRIPTION=SKEW returns an unbiased estimate for skewness of a "
#~ "distribution.\n"
#~ "\n"
#~ "Note, that this is only meaningful if the underlying distribution really "
#~ "has a third moment.  The skewness of a symmetric (e.g., normal) "
#~ "distribution is zero.\n"
#~ "\n"
#~ "* Strings and empty cells are simply ignored.\n"
#~ "* If less than three numbers are given, SKEW returns #DIV/0! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "SKEW(A1:A5) equals 0.976798268.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,VAR,SKEWP,KURT"
#~ msgstr ""
#~ "@FUNCTION=SKEW\n"
#~ "@SYNTAX=SKEW(n1, n2, ...)\n"
#~ "@DESCRIPTION=SKEW devolve a estimativa não influenciada do desvio de uma "
#~ "distribuição.\n"
#~ "\n"
#~ "Note, que isto apenas tem sentido se a distribuição subjacente tiver "
#~ "realmente um terceiro momento. O desvio de uma distribuição simétrica "
#~ "(por ex., normal) é zero.\n"
#~ "\n"
#~ "* Expressões e células vazias são simplesmente ignoradas.\n"
#~ "* Se forem indicados menos do que três números, SKEW devolve o erro "
#~ "#DIV/0!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1, A2, ..., A5 contêm os números 11.4, "
#~ "17.3, 21.3, 25.9, e 40.1.  Então\n"
#~ "SKEW(A1:A5) igual a 0.976798268.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,VAR,SKEWP,KURT"

#~ msgid ""
#~ "@FUNCTION=SKEWP\n"
#~ "@SYNTAX=SKEWP(n1, n2, ...)\n"
#~ "@DESCRIPTION=SKEWP returns the population skewness of a data set.\n"
#~ "\n"
#~ "* Strings and empty cells are simply ignored.\n"
#~ "* If less than two numbers are given, SKEWP returns #DIV/0! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "SKEWP(A1:A5) equals 0.655256198.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,VARP,SKEW,KURTP"
#~ msgstr ""
#~ "@FUNCTION=SKEWP\n"
#~ "@SYNTAX=SKEWP(n1, n2, ...)\n"
#~ "@DESCRIPTION=SKEWP devolve o desvio de um conjunto de dados.\n"
#~ "\n"
#~ "* Expressões e células vazias são simplesmente ignoradas.\n"
#~ "* Se forem passados menos de dois números, SKEWP devolve o erro #DIV/0!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1, A2, ..., A5 contêm os números 11.4, "
#~ "17.3, 21.3, 25.9, e 40.1.  Então\n"
#~ "SKEWP(A1:A5) igual a 0.655256198.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,VARP,SKEW,KURTP"

#~ msgid ""
#~ "@FUNCTION=EXPONDIST\n"
#~ "@SYNTAX=EXPONDIST(x,y,cumulative)\n"
#~ "@DESCRIPTION=EXPONDIST function returns the exponential distribution. If "
#~ "the @cumulative boolean is false it will return:\n"
#~ "\n"
#~ "\t@y * exp (-@y*@x),\n"
#~ "\n"
#~ "otherwise it will return\n"
#~ "\n"
#~ "\t1 - exp (-@y*@x).\n"
#~ "\n"
#~ "* If @x < 0 or @y <= 0 this will return an error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "EXPONDIST(2,4,0) equals 0.001341851.\n"
#~ "\n"
#~ "@SEEALSO=POISSON"
#~ msgstr ""
#~ "@FUNCTION=EXPONDIST\n"
#~ "@SYNTAX=EXPONDIST(x,y,acumulativa)\n"
#~ "@DESCRIPTION=A função EXPONDIST devolve a distribuição exponencial. Se a "
#~ "boleana @acumulativa for falsa irá devolver:\n"
#~ "\n"
#~ "\t@y * exp (-@y*@x),\n"
#~ "\n"
#~ "caso conrário devolverá\n"
#~ "\n"
#~ "\t1 - exp (-@y*@x).\n"
#~ "\n"
#~ "* Se @x < 0 ou @y <= 0 irá devolver um erro.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "EXPONDIST(2,4,0) igual a 0.001341851.\n"
#~ "\n"
#~ "@SEEALSO=POISSON"

#~ msgid ""
#~ "@FUNCTION=BERNOULLI\n"
#~ "@SYNTAX=BERNOULLI(k,p)\n"
#~ "@DESCRIPTION=BERNOULLI returns the probability p(k) of obtaining @k from "
#~ "a Bernoulli distribution with probability parameter @p.\n"
#~ "\n"
#~ "* If @k != 0 and @k != 1 BERNOULLI returns #NUM! error.\n"
#~ "* If @p < 0 or @p > 1 BERNOULLI returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BERNOULLI(0,0.5).\n"
#~ "\n"
#~ "@SEEALSO=RANDBERNOULLI"
#~ msgstr ""
#~ "@FUNCTION=BERNOULLI\n"
#~ "@SYNTAX=BERNOULLI(k,p)\n"
#~ "@DESCRIPTION=BERNOULLI devolve a probabilidade p(k) de obter @k de uma "
#~ "distribuição de Bernoulli com o parâmetro de probabilidade @p.\n"
#~ "\n"
#~ "* Se @k != 0 e @k != 1 BERNOULLI devolve o erro #NUM!.\n"
#~ "* Se @p < 0 ou @p > 1 BERNOULLI devolve o erro #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BERNOULLI(0,0.5).\n"
#~ "\n"
#~ "@SEEALSO=RANDBERNOULLI"

#~ msgid ""
#~ "@FUNCTION=GAMMALN\n"
#~ "@SYNTAX=GAMMALN(x)\n"
#~ "@DESCRIPTION=GAMMALN function returns the natural logarithm of the gamma "
#~ "function.\n"
#~ "\n"
#~ "* If @x is non-number then GAMMALN returns #VALUE! error.\n"
#~ "* If @x <= 0 then GAMMALN returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "GAMMALN(23) equals 48.471181352.\n"
#~ "\n"
#~ "@SEEALSO=POISSON"
#~ msgstr ""
#~ "@FUNCTION=GAMMALN\n"
#~ "@SYNTAX=GAMMALN(x)\n"
#~ "@DESCRIPTION=A função GAMMALN devolve o logaritmo natural da função "
#~ "gamma.\n"
#~ "\n"
#~ "* Se @x for não-numérico então o GAMMALN devolve o erro #VALOR!.\n"
#~ "* Se @x <= 0 então GAMMALN devolve o erro #NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "GAMMALN(23) igual a 48.471181352.\n"
#~ "\n"
#~ "@SEEALSO=POISSON"

#~ msgid ""
#~ "@FUNCTION=GAMMADIST\n"
#~ "@SYNTAX=GAMMADIST(x,alpha,beta,cum)\n"
#~ "@DESCRIPTION=GAMMADIST function returns the gamma distribution. If @cum "
#~ "is TRUE, GAMMADIST returns the incomplete gamma function, otherwise it "
#~ "returns the probability mass function.\n"
#~ "\n"
#~ "* If @x < 0 GAMMADIST returns #NUM! error.\n"
#~ "* If @alpha <= 0 or @beta <= 0, GAMMADIST returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "GAMMADIST(1,2,3,0) equals 0.07961459.\n"
#~ "\n"
#~ "@SEEALSO=GAMMAINV"
#~ msgstr ""
#~ "@FUNCTION=GAMMADIST\n"
#~ "@SYNTAX=GAMMADIST(x,alfa,beta,cum)\n"
#~ "@DESCRIPTION=A função GAMMADIST devolve a distribuição gamma. Se @cum for "
#~ "VERDADE, GAMMADIST devolve a função gamma incompleta, vaso contrário "
#~ "devolve a função de probabilidade de massa.\n"
#~ "\n"
#~ "* Se @x < 0 GAMMADIST devolve o erro #NUM!.\n"
#~ "* Se @alfa <= 0 ou @beta <= 0, GAMMADIST devolve o erro #NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "GAMMADIST(1,2,3,0) igual a 0.07961459.\n"
#~ "\n"
#~ "@SEEALSO=GAMMAINV"

#~ msgid ""
#~ "@FUNCTION=GAMMAINV\n"
#~ "@SYNTAX=GAMMAINV(p,alpha,beta)\n"
#~ "@DESCRIPTION=GAMMAINV function returns the inverse of the cumulative "
#~ "gamma distribution.\n"
#~ "\n"
#~ "* If @p < 0 or @p > 1 GAMMAINV returns #NUM! error.\n"
#~ "* If @alpha <= 0 or @beta <= 0 GAMMAINV returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "GAMMAINV(0.34,2,4) equals 4.829093908.\n"
#~ "\n"
#~ "@SEEALSO=GAMMADIST"
#~ msgstr ""
#~ "@FUNCTION=GAMMAINV\n"
#~ "@SYNTAX=GAMMAINV(p,alfa,beta)\n"
#~ "@DESCRIPTION=A função GAMMAINV devolve a inversa da distribuição gamma "
#~ "acumulativa.\n"
#~ "\n"
#~ "* Se @p < 0 ou @p > 1 GAMMAINV devolve o erro #NUM!.\n"
#~ "* Se @alfa <= 0 ou @beta <= 0 GAMMAINV devolve o erro #NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "GAMMAINV(0.34,2,4) igual a 4.829093908.\n"
#~ "\n"
#~ "@SEEALSO=GAMMADIST"

#~ msgid ""
#~ "@FUNCTION=CHIDIST\n"
#~ "@SYNTAX=CHIDIST(x,dof)\n"
#~ "@DESCRIPTION=CHIDIST function returns the one-tailed probability of the "
#~ "chi-squared distribution. @dof is the number of degrees of freedom.\n"
#~ "\n"
#~ "* If @dof is non-integer it is truncated.\n"
#~ "* If @dof < 1 CHIDIST returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CHIDIST(5.3,2) equals 0.070651213.\n"
#~ "\n"
#~ "@SEEALSO=CHIINV,CHITEST"
#~ msgstr ""
#~ "@FUNCTION=CHIDIST\n"
#~ "@SYNTAX=CHIDIST(x,dof)\n"
#~ "@DESCRIPTION=A função CHIDIST devolve a probabilidade de uma-cauda da "
#~ "distribuição 'chi-quadrada'. @dof é o número de graus de liberdade.\n"
#~ "\n"
#~ "* Se @dof for não-inteiro será truncado.\n"
#~ "* Se @dof < 1 CHIDIST devolve o erro #NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CHIDIST(5.3,2) igual a 0.070651213.\n"
#~ "\n"
#~ "@SEEALSO=CHIINV,CHITEST"

#~ msgid ""
#~ "@FUNCTION=CHIINV\n"
#~ "@SYNTAX=CHIINV(p,dof)\n"
#~ "@DESCRIPTION=CHIINV function returns the inverse of the one-tailed "
#~ "probability of the chi-squared distribution.\n"
#~ "\n"
#~ "* If @p < 0 or @p > 1 or @dof < 1 CHIINV returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CHIINV(0.98,7) equals 1.564293004.\n"
#~ "\n"
#~ "@SEEALSO=CHIDIST,CHITEST"
#~ msgstr ""
#~ "@FUNCTION=CHIINV\n"
#~ "@SYNTAX=CHIINV(p,dof)\n"
#~ "@DESCRIPTION=A função CHIINV devolve o inverso da probabilidade de uma "
#~ "distribuição chi-quadrada de uma cauda.\n"
#~ "\n"
#~ "* Se @p < 0 ou @p > 1 ou @dof < 1 CHIINV devolve o erro #NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CHIINV(0.98,7) igual a 1.564293004.\n"
#~ "\n"
#~ "@SEEALSO=CHIDIST,CHITEST"

#~ msgid ""
#~ "@FUNCTION=CHITEST\n"
#~ "@SYNTAX=CHITEST(actual_range,theoretical_range)\n"
#~ "@DESCRIPTION=CHITEST function returns the test for independence of chi-"
#~ "squared distribution.\n"
#~ "\n"
#~ "@actual_range is a range that contains the observed data points. "
#~ "@theoretical_range is a range that contains the expected values of the "
#~ "data points.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=CHIDIST,CHIINV"
#~ msgstr ""
#~ "@FUNCTION=CHITEST\n"
#~ "@SYNTAX=CHITEST(área_actual,área_teórica)\n"
#~ "@DESCRIPTION=A função CHITEST devolve o teste de independência de uma "
#~ "distribuição chi-quadrada.\n"
#~ "\n"
#~ "@área_actual é uma área que contém os pontos de dados observados. "
#~ "@área_teórica é uma área que contém os valores experados dos pontos de "
#~ "dados.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=CHIDIST,CHIINV"

#~ msgid ""
#~ "@FUNCTION=BETADIST\n"
#~ "@SYNTAX=BETADIST(x,alpha,beta[,a,b])\n"
#~ "@DESCRIPTION=BETADIST function returns the cumulative beta distribution. "
#~ "@a is the optional lower bound of @x and @b is the optional upper bound "
#~ "of @x.\n"
#~ "* If @a is not given, BETADIST uses 0.\n"
#~ "* If @b is not given, BETADIST uses 1.\n"
#~ "* If @x < @a or @x > @b BETADIST returns #NUM! error.\n"
#~ "* If @alpha <= 0 or @beta <= 0, BETADIST returns #NUM! error.\n"
#~ "* If @a >= @b BETADIST returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BETADIST(0.12,2,3) equals 0.07319808.\n"
#~ "\n"
#~ "@SEEALSO=BETAINV"
#~ msgstr ""
#~ "@FUNCTION=BETADIST\n"
#~ "@SYNTAX=BETADIST(x,alfa,beta[,a,b])\n"
#~ "@DESCRIPTION=A função BETADIST devolve a distribuição acumulada beta. @a "
#~ "é o limite inferior opcional de @x e @b é o limite superior opcional de "
#~ "@x.\n"
#~ "* Se @a não for indicado, BETADIST utiliza 0.\n"
#~ "* Se @b não for indicado, BETADIST utiliza 1.\n"
#~ "* Se @x < @a ou @x > @b BETADIST devolve o erro #NUM!.\n"
#~ "* Se @alfa <= 0 ou @beta <= 0, BETADIST devolve o erro #NUM!.\n"
#~ "* Se @a >= @b BETADIST devolve o erro #NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BETADIST(0.12,2,3) igual a 0.07319808.\n"
#~ "\n"
#~ "@SEEALSO=BETAINV"

#~ msgid ""
#~ "@FUNCTION=BETAINV\n"
#~ "@SYNTAX=BETAINV(p,alpha,beta[,a,b])\n"
#~ "@DESCRIPTION=BETAINV function returns the inverse of cumulative beta "
#~ "distribution.  @a is the optional lower bound of @x and @b is the "
#~ "optional upper bound of @x.\n"
#~ "\n"
#~ "* If @a is not given, BETAINV uses 0.\n"
#~ "* If @b is not given, BETAINV uses 1.\n"
#~ "* If @p < 0 or @p > 1 BETAINV returns #NUM! error.\n"
#~ "* If @alpha <= 0 or @beta <= 0, BETAINV returns #NUM! error.\n"
#~ "* If @a >= @b BETAINV returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BETAINV(0.45,1.6,1) equals 0.607096629.\n"
#~ "\n"
#~ "@SEEALSO=BETADIST"
#~ msgstr ""
#~ "@FUNCTION=BETAINV\n"
#~ "@SYNTAX=BETAINV(p,alfa,beta[,a,b])\n"
#~ "@DESCRIPTION=A função BETAINV devolve o inverso da distribuição beta "
#~ "acumulada.  @a é o limite inferior opcional de @x e @b é o limite "
#~ "superior opcional de @x.\n"
#~ "\n"
#~ "* Se @a não for indicado, BETAINV utiliza 0.\n"
#~ "* Se @b não for indicado, BETAINV utiliza 1.\n"
#~ "* Se @p < 0 ou @p > 1 BETAINV devolve o erro #NUM!.\n"
#~ "* Se @alfa <= 0 ou @beta <= 0, BETAINV devolve o erro #NUM!.\n"
#~ "* Se @a >= @b BETAINV devolve o erro #NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BETAINV(0.45,1.6,1) igual a 0.607096629.\n"
#~ "\n"
#~ "@SEEALSO=BETADIST"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=TDIST\n"
#~ "@SYNTAX=TDIST(x,dof,tails)\n"
#~ "@DESCRIPTION=TDIST function returns the Student's t-distribution. @dof is "
#~ "the degree of freedom and @tails is 1 or 2 depending on whether you want "
#~ "one-tailed or two-tailed distribution.\n"
#~ "@tails = 1 returns the size of the right tail.\n"
#~ "\n"
#~ "* If @dof < 1 TDIST returns #NUM! error.\n"
#~ "* If @tails is neither 1 or 2 TDIST returns #NUM! error.\n"
#~ "* This function is Excel compatible for non-negative @x.\n"
#~ "\n"
#~ "Warning: the parameterization of this function is different from what is "
#~ "used for, e.g., NORMSDIST.  This is a common source of mistakes, but "
#~ "necessary for compatibility.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TDIST(2,5,1) equals 0.050969739.\n"
#~ "TDIST(-2,5,1) equals 0.949030261.\n"
#~ "TDIST(0,5,2) equals 1.\n"
#~ "\n"
#~ "@SEEALSO=TINV,TTEST"
#~ msgstr ""
#~ "@FUNCTION=TDIST\n"
#~ "@SYNTAX=TDIST(x,dof,caudas)\n"
#~ "@DESCRIPTION=A função TDIST devolve a distribuição-t Student. @dof são os "
#~ "graus de liberdade e @caudas é 1 ou 2 dependendo de se desejar a "
#~ "distribuição de uma-cauda ou duas-caudas.\n"
#~ "\n"
#~ "* Se @dof < 1 TDIST devolve o erro #NUM!.\n"
#~ "* Se @caudas não for nem 1 nem 2 TDIST devolve o erro #NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TDIST(2,5,1) igual a 0.050969739.\n"
#~ "\n"
#~ "@SEEALSO=TINV,TTEST"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=TINV\n"
#~ "@SYNTAX=TINV(p,dof)\n"
#~ "@DESCRIPTION=TINV function returns the inverse of the two-tailed "
#~ "Student's t-distribution.\n"
#~ "\n"
#~ "* If @p < 0 or @p > 1 or @dof < 1 TINV returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "Warning: the parameterization of this function is different from what is "
#~ "used for, e.g., NORMSINV.  This is a common source of mistakes, but "
#~ "necessary for compatibility.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TINV(0.4,32) equals 0.852998454.\n"
#~ "\n"
#~ "@SEEALSO=TDIST,TTEST"
#~ msgstr ""
#~ "@FUNCTION=TINV\n"
#~ "@SYNTAX=TINV(p,dof)\n"
#~ "@DESCRIPTION=A função TINV devolve o inverso da distribuição-t de duas-"
#~ "caudas.\n"
#~ "\n"
#~ "* Se @p < 0 ou @p > 1 ou @dof < 1 TINV devolve o erro #NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TINV(0.4,32) igual a 0.852998454.\n"
#~ "\n"
#~ "@SEEALSO=TDIST,TTEST"

#~ msgid ""
#~ "@FUNCTION=FDIST\n"
#~ "@SYNTAX=FDIST(x,dof1,dof2)\n"
#~ "@DESCRIPTION=FDIST function returns the F probability distribution. @dof1 "
#~ "is the numerator degrees of freedom and @dof2 is the denominator degrees "
#~ "of freedom.\n"
#~ "\n"
#~ "* If @x < 0 FDIST returns #NUM! error.\n"
#~ "* If @dof1 < 1 or @dof2 < 1, FDIST returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FDIST(2,5,5) equals 0.232511319.\n"
#~ "\n"
#~ "@SEEALSO=FINV"
#~ msgstr ""
#~ "@FUNCTION=FDIST\n"
#~ "@SYNTAX=FDIST(x,dof1,dof2)\n"
#~ "@DESCRIPTION=A função FDIST devolve a probabilidade F da distribuição. "
#~ "@dof1 são os graus de liberdade do numerador e @dof2 são os graus de "
#~ "liberdade do denominador.\n"
#~ "\n"
#~ "* Se @x < 0 FDIST devolve o erro #NUM!.\n"
#~ "* Se @dof1 < 1 ou @dof2 < 1, FDIST devolve o erro #NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FDIST(2,5,5) igual a 0.232511319.\n"
#~ "\n"
#~ "@SEEALSO=FINV"

#~ msgid ""
#~ "@FUNCTION=LANDAU\n"
#~ "@SYNTAX=LANDAU(x)\n"
#~ "@DESCRIPTION=LANDAU returns the probability density p(x) at @x for the "
#~ "Landau distribution using an approximation method. \n"
#~ "@EXAMPLES=\n"
#~ "LANDAU(0.34).\n"
#~ "\n"
#~ "@SEEALSO=RANDLANDAU"
#~ msgstr ""
#~ "@FUNCTION=LANDAU\n"
#~ "@SYNTAX=LANDAU(x)\n"
#~ "@DESCRIPTION=LANDAU devlve a desidade da probabilidade p(x) em @x para a "
#~ "distribuição de Landau utilizando um método de aproximação. \n"
#~ "@EXAMPLES=\n"
#~ "LANDAU(0.34).\n"
#~ "\n"
#~ "@SEEALSO=RANDLANDAU"

#~ msgid ""
#~ "@FUNCTION=FINV\n"
#~ "@SYNTAX=FINV(p,dof1,dof2)\n"
#~ "@DESCRIPTION=FINV function returns the inverse of the F probability "
#~ "distribution.\n"
#~ "\n"
#~ "* If @p < 0 or @p > 1 FINV returns #NUM! error.\n"
#~ "* If @dof1 < 1 or @dof2 < 1 FINV returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FINV(0.2,2,4) equals 2.472135955.\n"
#~ "\n"
#~ "@SEEALSO=FDIST"
#~ msgstr ""
#~ "@FUNCTION=FINV\n"
#~ "@SYNTAX=FINV(p,dof1,dof2)\n"
#~ "@DESCRIPTION=A função FINV devolve a inversa da probabilidade F da "
#~ "distribuição.\n"
#~ "\n"
#~ "* Se @p < 0 ou @p > 1 FINV devolve o erro #NUM!.\n"
#~ "* Se @dof1 < 1 ou @dof2 < 1 FINV devolve o erro #NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FINV(0.2,2,4) igual a 2.472135955.\n"
#~ "\n"
#~ "@SEEALSO=FDIST"

#~ msgid ""
#~ "@FUNCTION=BINOMDIST\n"
#~ "@SYNTAX=BINOMDIST(n,trials,p,cumulative)\n"
#~ "@DESCRIPTION=BINOMDIST function returns the binomial distribution. @n is "
#~ "the number of successes, @trials is the total number of independent "
#~ "trials, @p is the probability of success in trials, and @cumulative "
#~ "describes whether to return the sum of the binomial function from 0 to "
#~ "@n.\n"
#~ "\n"
#~ "* If @n or @trials are non-integer they are truncated.\n"
#~ "* If @n < 0 or @trials < 0 BINOMDIST returns #NUM! error.\n"
#~ "* If @n > @trials BINOMDIST returns #NUM! error.\n"
#~ "* If @p < 0 or @p > 1 BINOMDIST returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BINOMDIST(3,5,0.8,0) equals 0.2048.\n"
#~ "\n"
#~ "@SEEALSO=POISSON"
#~ msgstr ""
#~ "@FUNCTION=BINOMDIST\n"
#~ "@SYNTAX=BINOMDIST(n,tentativas,p,acumulada)\n"
#~ "@DESCRIPTION=A função BINOMDIST devolve a distribuição binomial. @n é o "
#~ "número de sucessos, @tentativas o número total de tentativas "
#~ "independentes, @p a probabilidade de sucesso nas tentativas, e @acumulada "
#~ "indica se deverá ser devolvida a soma da função binomial de 0 até @n.\n"
#~ "\n"
#~ "* Se @n ou @tentativas forem não-inteiros serão truncados.\n"
#~ "* Se @n < 0 ou @tentativas < 0 BINOMDIST devolve o erro #NUM!.\n"
#~ "* Se @n > @tentativas BINOMDIST devolve o erro #NUM!.\n"
#~ "* Se @p < 0 ou @p > 1 BINOMDIST devolve o erro #NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BINOMDIST(3,5,0.8,0) igual a 0.2048.\n"
#~ "\n"
#~ "@SEEALSO=POISSON"

#~ msgid ""
#~ "@FUNCTION=CAUCHY\n"
#~ "@SYNTAX=CAUCHY(x,a,cum)\n"
#~ "@DESCRIPTION=CAUCHY returns the Cauchy distribution with scale parameter "
#~ "@a. If @cum is TRUE, CAUCHY returns the cumulative distribution.\n"
#~ "\n"
#~ "* If @a < 0 CAUCHY returns #NUM! error.\n"
#~ "* If @cum != TRUE and @cum != FALSE CAUCHY returns #VALUE! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CAUCHY(0.43,1,TRUE) returns 0.370735.\n"
#~ "\n"
#~ "@SEEALSO=RANDCAUCHY"
#~ msgstr ""
#~ "@FUNCTION=CAUCHY\n"
#~ "@SYNTAX=CAUCHY(x,a,cum)\n"
#~ "@DESCRIPTION=CAUCHY devolve a distribuição de Cauchy com parâmetro de "
#~ "escala @a. Se @cum for VERDADE, CAUCHY devolve a distribuição "
#~ "cumulativa.\n"
#~ "\n"
#~ "* Se @a < 0 CAUCHY devolve o erro #NUM!.\n"
#~ "* Se @cum != VERDADE e @cum != FALSO CAUCHY devolve o erro #VALOR!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CAUCHY(0.43,1,TRUE) devolve 0.370735.\n"
#~ "\n"
#~ "@SEEALSO=RANDCAUCHY"

#~ msgid ""
#~ "@FUNCTION=CRITBINOM\n"
#~ "@SYNTAX=CRITBINOM(trials,p,alpha)\n"
#~ "@DESCRIPTION=CRITBINOM function returns the smallest value for which the "
#~ "cumulative is greater than or equal to a given value. @n is the number of "
#~ "trials, @p is the probability of success in trials, and @alpha is the "
#~ "criterion value.\n"
#~ "\n"
#~ "* If @trials is a non-integer it is truncated.\n"
#~ "* If @trials < 0 CRITBINOM returns #NUM! error.\n"
#~ "* If @p < 0 or @p > 1 CRITBINOM returns #NUM! error.\n"
#~ "* If @alpha < 0 or @alpha > 1 CRITBINOM returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CRITBINOM(10,0.5,0.75) equals 6.\n"
#~ "\n"
#~ "@SEEALSO=BINOMDIST"
#~ msgstr ""
#~ "@FUNCTION=CRITBINOM\n"
#~ "@SYNTAX=CRITBINOM(tentativas,p,alfa)\n"
#~ "@DESCRIPTION=A função CRITBINOM devolve o menor valor para o qual a "
#~ "acumulada é maior ou igual a um dado valor. @n é o número de tentativas, "
#~ "@p é a probabilidade de sucesso em tentativas, e @alfa é o valor de "
#~ "critério.\n"
#~ "\n"
#~ "* Se @tentativas for um não-inteiro será truncado.\n"
#~ "* Se @tentativas < 0 CRITBINOM devolve o erro #NUM!.\n"
#~ "* Se @p < 0 ou @p > 1 CRITBINOM devolve o erro #NUM!.\n"
#~ "* Se @alfa < 0 ou @alfa > 1 CRITBINOM devolve o erro #NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CRITBINOM(10,0.5,0.75) igual a 6.\n"
#~ "\n"
#~ "@SEEALSO=BINOMDIST"

#~ msgid ""
#~ "@FUNCTION=PERMUT\n"
#~ "@SYNTAX=PERMUT(n,k)\n"
#~ "@DESCRIPTION=PERMUT function returns the number of permutations. @n is "
#~ "the number of objects, @k is the number of objects in each permutation.\n"
#~ "\n"
#~ "* If @n = 0 PERMUT returns #NUM! error.\n"
#~ "* If @n < @k PERMUT returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "PERMUT(7,3) equals 210.\n"
#~ "\n"
#~ "@SEEALSO=COMBIN"
#~ msgstr ""
#~ "@FUNCTION=PERMUT\n"
#~ "@SYNTAX=PERMUT(n,k)\n"
#~ "@DESCRIPTION=A função PERMUT devolve o número de permutações. @n é o "
#~ "número de objectos, @k é o número de objectos em cada permutação.\n"
#~ "\n"
#~ "* Se @n = 0 PERMUT devolve o erro #NUM!.\n"
#~ "* Se @n < @k PERMUT devolve o erro #NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "PERMUT(7,3) igual a 210.\n"
#~ "\n"
#~ "@SEEALSO=COMBIN"

#~ msgid ""
#~ "@FUNCTION=HYPGEOMDIST\n"
#~ "@SYNTAX=HYPGEOMDIST(x,n,M,N[,cumulative])\n"
#~ "@DESCRIPTION=HYPGEOMDIST function returns the hypergeometric "
#~ "distribution. @x is the number of successes in the sample, @n is the "
#~ "number of trials, @M is the number of successes overall, and @N is the "
#~ "population size.\n"
#~ "\n"
#~ "If the optional argument @cumulative is TRUE, the cumulative left tail "
#~ "will be returned.\n"
#~ "\n"
#~ "* If @x,@n,@M or @N is a non-integer it is truncated.\n"
#~ "* If @x,@n,@M or @N < 0 HYPGEOMDIST returns #NUM! error.\n"
#~ "* If @x > @M or @n > @N HYPGEOMDIST returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "HYPGEOMDIST(1,2,3,10) equals 0.4666667.\n"
#~ "\n"
#~ "@SEEALSO=BINOMDIST,POISSON"
#~ msgstr ""
#~ "@FUNCTION=HYPGEOMDIST\n"
#~ "@SYNTAX=HYPGEOMDIST(x,n,M,N)\n"
#~ "@DESCRIPTION=A função HYPGEOMDIST devolve a distribuição hipergeométrica. "
#~ "@x é o número de sucessos na amostra, @n é o número de tentativas, @M é o "
#~ "número total de sucessos, e @N é o tamanho da população.\n"
#~ "\n"
#~ "* Se @x,@n,@M ou @N for um não-inteiro será truncado.\n"
#~ "* Se @x,@n,@M ou @N < 0 HYPGEOMDIST devolve o erro #NUM!.\n"
#~ "* Se @x > @M ou @n > @N HYPGEOMDIST devolve o erro #NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "HYPGEOMDIST(1,2,3,10) igual a 0.4666667.\n"
#~ "\n"
#~ "@SEEALSO=BINOMDIST,POISSON"

#~ msgid ""
#~ "@FUNCTION=CONFIDENCE\n"
#~ "@SYNTAX=CONFIDENCE(x,stddev,size)\n"
#~ "@DESCRIPTION=CONFIDENCE function returns the confidence interval for a "
#~ "mean. @x is the significance level, @stddev is the population standard "
#~ "deviation, and @size is the size of the sample.\n"
#~ "\n"
#~ "* If @size is non-integer it is truncated.\n"
#~ "* If @size < 0 CONFIDENCE returns #NUM! error.\n"
#~ "* If @size is 0 CONFIDENCE returns #DIV/0! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CONFIDENCE(0.05,1,33) equals 0.341185936.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE"
#~ msgstr ""
#~ "@FUNCTION=CONFIDENCE\n"
#~ "@SYNTAX=CONFIDENCE(x,desvpad,tamanho)\n"
#~ "@DESCRIPTION=A função CONFIDENCE devolve o intervalo de confiança de uma "
#~ "média. @x é o nível de significância, @desvpad é o desvio padrão da "
#~ "população, e @tamanho é o tamanho da amostra.\n"
#~ "\n"
#~ "* Se @tamanho for não-inteiro será truncado.\n"
#~ "* Se @tamanho < 0 CONFIDENCE devolve o erro #NUM!.\n"
#~ "* Se @tamanho for 0 CONFIDENCE devolve o erro #DIV/0!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CONFIDENCE(0.05,1,33) igual a 0.341185936.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE"

#~ msgid ""
#~ "@FUNCTION=STANDARDIZE\n"
#~ "@SYNTAX=STANDARDIZE(x,mean,stddev)\n"
#~ "@DESCRIPTION=STANDARDIZE function returns a normalized value. @x is the "
#~ "number to be normalized, @mean is the mean of the distribution, @stddev "
#~ "is the standard deviation of the distribution.\n"
#~ "\n"
#~ "* If @stddev is 0 STANDARDIZE returns #DIV/0! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "STANDARDIZE(3,2,4) equals 0.25.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE"
#~ msgstr ""
#~ "@FUNCTION=STANDARDIZE\n"
#~ "@SYNTAX=STANDARDIZE(x,média,desvpad)\n"
#~ "@DESCRIPTION=A função STANDARDIZE devolve o valor normalizado. @x é o "
#~ "número a ser normalizado, @média é a média da distribuição, @desvpad é o "
#~ "desvio padrão da distribuição.\n"
#~ "\n"
#~ "* Se @stddev for 0 STANDARDIZE devolve o erro #DIV/0!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "STANDARDIZE(3,2,4) igual a 0.25.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE"

#~ msgid ""
#~ "@FUNCTION=WEIBULL\n"
#~ "@SYNTAX=WEIBULL(x,alpha,beta,cumulative)\n"
#~ "@DESCRIPTION=WEIBULL function returns the Weibull distribution. If the "
#~ "@cumulative boolean is true it will return:\n"
#~ "\n"
#~ "\t1 - exp (-(@x/@beta)^@alpha),\n"
#~ "\n"
#~ "otherwise it will return\n"
#~ "\n"
#~ "\t(@alpha/@beta^@alpha) * @x^(@alpha-1) * exp(-(@x/@beta^@alpha)).\n"
#~ "\n"
#~ "* If @x < 0 WEIBULL returns #NUM! error.\n"
#~ "* If @alpha <= 0 or @beta <= 0 WEIBULL returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "WEIBULL(3,2,4,0) equals 0.213668559.\n"
#~ "\n"
#~ "@SEEALSO=POISSON"
#~ msgstr ""
#~ "@FUNCTION=WEIBULL\n"
#~ "@SYNTAX=WEIBULL(x,alfa,beta,acumulativa)\n"
#~ "@DESCRIPTION=A função WEIBULL devolve a distribuição de Weibull. Se a "
#~ "boleana @acumulativa for verdadeira irá devolver:\n"
#~ "\n"
#~ "\t1 - exp (-(@x/@beta)^@alfa),\n"
#~ "\n"
#~ "caso contrário irá devolver\n"
#~ "\n"
#~ "\t(@alfa/@beta^@alfa) * @x^(@alfa-1) * exp(-(@x/@beta^@alfa)).\n"
#~ "\n"
#~ "* Se @x < 0 WEIBULL devolve o erro #NUM!.\n"
#~ "* Se @alfa <= 0 ou @beta <= 0 WEIBULL devolve o erro #NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "WEIBULL(3,2,4,0) igual a 0.213668559.\n"
#~ "\n"
#~ "@SEEALSO=POISSON"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=NORMDIST\n"
#~ "@SYNTAX=NORMDIST(x,mean,stddev,cumulative)\n"
#~ "@DESCRIPTION=The NORMDIST function returns the value of the probability "
#~ "density function or the cumulative distribution function for the normal "
#~ "distribution with the mean given by @mean, and the standard deviation "
#~ "given by @stddev. If @cumulative is FALSE, NORMDIST returns the value of "
#~ "the probability density function at the value @x. If @cumulative is TRUE, "
#~ "NORMDIST returns the value of the cumulative distribution function at "
#~ "@x.\n"
#~ "\n"
#~ "* If @stddev is 0 NORMDIST returns #DIV/0! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "NORMDIST(2,1,2,0) equals 0.176032663.\n"
#~ "\n"
#~ "@SEEALSO=POISSON"
#~ msgstr ""
#~ "@FUNCTION=NORMDIST\n"
#~ "@SYNTAX=NORMDIST(x,média,desvpad,acumulada)\n"
#~ "@DESCRIPTION=A função NORMDIST devolve a distribuição normal acumulada. "
#~ "@x é o valor para o qual deseja a distribuição, @média é a média da "
#~ "distribuição, @desvpad é o desvio padrão.\n"
#~ "\n"
#~ "* Se @desvpad for 0 NORMDIST devolve o erro #DIV/0!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "NORMDIST(2,1,2,0) igual a 0.176032663.\n"
#~ "\n"
#~ "@SEEALSO=POISSON"

#~ msgid ""
#~ "@FUNCTION=NORMINV\n"
#~ "@SYNTAX=NORMINV(p,mean,stddev)\n"
#~ "@DESCRIPTION=NORMINV function returns the inverse of the normal "
#~ "cumulative distribution. @p is the given probability corresponding to the "
#~ "normal distribution, @mean is the arithmetic mean of the distribution, "
#~ "and @stddev is the standard deviation of the distribution.\n"
#~ "\n"
#~ "* If @p < 0 or @p > 1 or @stddev <= 0 NORMINV returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "NORMINV(0.76,2,3) equals 4.118907689.\n"
#~ "\n"
#~ "@SEEALSO=NORMDIST,NORMSDIST,NORMSINV,STANDARDIZE,ZTEST"
#~ msgstr ""
#~ "@FUNCTION=NORMINV\n"
#~ "@SYNTAX=NORMINV(p,média,desvpad)\n"
#~ "@DESCRIPTION=A função NORMINV devolve o inverso da distribuição acumulada "
#~ "normal. @p é a probabilidade dada correspondente à distribuição normal, "
#~ "@média é a média aritmética da distribuição, e @desvpad é o desvio padrão "
#~ "da distribuição.\n"
#~ "\n"
#~ "* Se @p < 0 ou @p > 1 ou @stdev <= 0 NORMINV devolve o erro #NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "NORMINV(0.76,2,3) igual a 4.118907689.\n"
#~ "\n"
#~ "@SEEALSO=NORMDIST,NORMSDIST,NORMSINV,STANDARDIZE,ZTEST"

#~ msgid ""
#~ "@FUNCTION=KURT\n"
#~ "@SYNTAX=KURT(n1, n2, ...)\n"
#~ "@DESCRIPTION=KURT returns an unbiased estimate of the kurtosis of a data "
#~ "set.\n"
#~ "Note, that this is only meaningful if the underlying distribution really "
#~ "has a fourth moment.  The kurtosis is offset by three such that a normal "
#~ "distribution will have zero kurtosis.\n"
#~ "\n"
#~ "* Strings and empty cells are simply ignored.\n"
#~ "* If fewer than four numbers are given or all of them are equal KURT "
#~ "returns #DIV/0! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "KURT(A1:A5) equals 1.234546305.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,VAR,SKEW,KURTP"
#~ msgstr ""
#~ "@FUNCTION=KURT\n"
#~ "@SYNTAX=KURT(n1, n2, ...)\n"
#~ "@DESCRIPTION=KURT devolve uma estimativa não influenciada do kurtosis de "
#~ "um conjunto de dados.\n"
#~ "\n"
#~ "Note, que isto apenas tem sentido se a distribuição subjacente tiver "
#~ "realmente um quarto momento. A kurtosis é deslocada por três de tal modo "
#~ "que uma distribuição normal terá zero kurtosis.\n"
#~ "\n"
#~ "* Expressões e células vazias são simplesmente ignoradas.\n"
#~ "* Se forem passados menos de quatro membros ou todos eles forem iguais "
#~ "KURT devolve o erro #DIV/0!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1, A2, ..., A5 contêm os números 11.4, "
#~ "17.3, 21.3, 25.9, e 40.1.  Então\n"
#~ "KURT(A1:A5) igual a 1.234546305.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,VAR,SKEW,KURTP"

#~ msgid ""
#~ "@FUNCTION=KURTP\n"
#~ "@SYNTAX=KURTP(n1, n2, ...)\n"
#~ "@DESCRIPTION=KURTP returns the population kurtosis of a data set.\n"
#~ "\n"
#~ "* Strings and empty cells are simply ignored.\n"
#~ "* If fewer than two numbers are given or all of them are equal KURTP "
#~ "returns #DIV/0! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "KURTP(A1:A5) equals -0.691363424.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,VARP,SKEWP,KURT"
#~ msgstr ""
#~ "@FUNCTION=KURTP\n"
#~ "@SYNTAX=KURTP(n1, n2, ...)\n"
#~ "@DESCRIPTION=KURTP devolve a população de kurtosis de um conjunto de "
#~ "dados.\n"
#~ "\n"
#~ "* Expressões e células vazias são simplesmente ignoradas.\n"
#~ "* Se forem passados menos de dois números ou todos eles forem iguais "
#~ "KURTP devolve o erro #DIV/0!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1, A2, ..., A5 contêm os números 11.4, "
#~ "17.3, 21.3, 25.9, e 40.1.  Então\n"
#~ "KURTP(A1:A5) igual a -0.691363424.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,VARP,SKEWP,KURT"

#~ msgid ""
#~ "@FUNCTION=AVEDEV\n"
#~ "@SYNTAX=AVEDEV(n1, n2, ...)\n"
#~ "@DESCRIPTION=AVEDEV returns the average of the absolute deviations of a "
#~ "data set from their mean.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "AVEDEV(A1:A5) equals 7.84.\n"
#~ "\n"
#~ "@SEEALSO=STDEV"
#~ msgstr ""
#~ "@FUNCTION=AVEDEV\n"
#~ "@SYNTAX=AVEDEV(n1, n2, ...)\n"
#~ "@DESCRIPTION=AVEDEV devolve a média dos desvios absolutos de um conjunto "
#~ "de dados em relação à sua média.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1, A2, ..., A5 contêm os números 11.4, "
#~ "17.3, 21.3, 25.9, e 40.1.  Então\n"
#~ "AVEDEV(A1:A5) igual a 7.84.\n"
#~ "\n"
#~ "@SEEALSO=STDEV"

#~ msgid ""
#~ "@FUNCTION=DEVSQ\n"
#~ "@SYNTAX=DEVSQ(n1, n2, ...)\n"
#~ "@DESCRIPTION=DEVSQ returns the sum of squares of deviations of a data set "
#~ "from the sample mean.\n"
#~ "\n"
#~ "* Strings and empty cells are simply ignored.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "DEVSQ(A1:A5) equals 470.56.\n"
#~ "\n"
#~ "@SEEALSO=STDEV"
#~ msgstr ""
#~ "@FUNCTION=DEVSQ\n"
#~ "@SYNTAX=DEVSQ(n1, n2, ...)\n"
#~ "@DESCRIPTION=DEVSQ devolve a soma dos quadrados dos desvios de um "
#~ "conjunto de dados em relação à média.\n"
#~ "\n"
#~ "* Expressões e células vazias são simplesmente ignoradas.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1, A2, ..., A5 contêm os números 11.4, "
#~ "17.3, 21.3, 25.9, e 40.1.  Então\n"
#~ "DEVSQ(A1:A5) igual a 470.56.\n"
#~ "\n"
#~ "@SEEALSO=STDEV"

#~ msgid ""
#~ "@FUNCTION=FISHER\n"
#~ "@SYNTAX=FISHER(x)\n"
#~ "@DESCRIPTION=FISHER function returns the Fisher transformation at @x.\n"
#~ "\n"
#~ "* If @x is not a number, FISHER returns #VALUE! error.\n"
#~ "* If @x <= -1 or @x >= 1, FISHER returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FISHER(0.332) equals 0.345074339.\n"
#~ "\n"
#~ "@SEEALSO=SKEW"
#~ msgstr ""
#~ "@FUNCTION=FISHER\n"
#~ "@SYNTAX=FISHER(x)\n"
#~ "@DESCRIPTION=A função FISHER devolve a transformação de Fisher em @x.\n"
#~ "\n"
#~ "* Se @x for não-numérico FISHER devolve o erro #VALOR!.\n"
#~ "* Se @x <= -1 ou @x >= 1 FISHER devolve o erro #NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FISHER(0.332) igual a 0.345074339.\n"
#~ "\n"
#~ "@SEEALSO=SKEW"

#~ msgid ""
#~ "@FUNCTION=POISSON\n"
#~ "@SYNTAX=POISSON(x,mean,cumulative)\n"
#~ "@DESCRIPTION=POISSON function returns the Poisson distribution. @x is the "
#~ "number of events, @mean is the expected numeric value @cumulative "
#~ "describes whether to return the sum of the Poisson function from 0 to "
#~ "@x.\n"
#~ "\n"
#~ "* If @x is a non-integer it is truncated.\n"
#~ "* If @x < 0 POISSON returns #NUM! error.\n"
#~ "* If @mean <= 0 POISSON returns the #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "POISSON(3,6,0) equals 0.089235078.\n"
#~ "\n"
#~ "@SEEALSO=NORMDIST, WEIBULL"
#~ msgstr ""
#~ "@FUNCTION=POISSON\n"
#~ "@SYNTAX=POISSON(x,média,acumulado)\n"
#~ "@DESCRIPTION=A função POISSON devolve a distribuição de Poisson. @x é o "
#~ "número de eventos, @média é o valor numérico esperado e @cumulative "
#~ "indica se deverá ou não ser devolvida a soma da função Poisson de 0 a "
#~ "@x.\n"
#~ "\n"
#~ "* Se @x for um não-inteiro será truncado.\n"
#~ "* Se @x <= 0 POISSON devolve o erro #NUM!.\n"
#~ "* Se @média <= 0 POISSON devolve o erro #NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "POISSON(3,6,0) igual a 0.089235078.\n"
#~ "\n"
#~ "@SEEALSO=NORMDIST, WEIBULL"

#~ msgid ""
#~ "@FUNCTION=PEARSON\n"
#~ "@SYNTAX=PEARSON(array1,array2)\n"
#~ "@DESCRIPTION=PEARSON returns the Pearson correlation coefficient of two "
#~ "data sets.\n"
#~ "\n"
#~ "* Strings and empty cells are simply ignored.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=INTERCEPT,LINEST,RSQ,SLOPE,STEYX"
#~ msgstr ""
#~ "@FUNCTION=PEARSON\n"
#~ "@SYNTAX=PEARSON(matriz1,matriz2)\n"
#~ "@DESCRIPTION=PEARSON devolve o coeficiente de correlação de Pearson de "
#~ "dois conjuntos de dados.\n"
#~ "\n"
#~ "* Expressões e células vazias são simplesmente ignoradas.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=INTERCEPT,LINEST,RSQ,SLOPE,STEYX"

#~ msgid ""
#~ "@FUNCTION=RSQ\n"
#~ "@SYNTAX=RSQ(array1,array2)\n"
#~ "@DESCRIPTION=RSQ returns the square of the Pearson correlation "
#~ "coefficient of two data sets.\n"
#~ "\n"
#~ "* Strings and empty cells are simply ignored.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=CORREL,COVAR,INTERCEPT,LINEST,LOGEST,PEARSON,SLOPE,STEYX,TREND"
#~ msgstr ""
#~ "@FUNCTION=RSQ\n"
#~ "@SYNTAX=RSQ(matriz1,matriz2)\n"
#~ "@DESCRIPTION=RSQ devolve o quadrado do coeficiente de correlação de "
#~ "Pearson de dois conjuntos de dados.\n"
#~ "\n"
#~ "* Expressões e células vazias são simplesmente ignoradas.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=CORREL,COVAR,INTERCEPT,LINEST,LOGEST,PEARSON,SLOPE,STEYX,TREND"

#~ msgid ""
#~ "@FUNCTION=MEDIAN\n"
#~ "@SYNTAX=MEDIAN(n1, n2, ...)\n"
#~ "@DESCRIPTION=MEDIAN returns the median of the given data set.\n"
#~ "\n"
#~ "* Strings and empty cells are simply ignored.\n"
#~ "* If even numbers are given MEDIAN returns the average of the two numbers "
#~ "in the middle.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "MEDIAN(A1:A5) equals 21.3.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,COUNT,COUNTA,DAVERAGE,MODE,SSMEDIAN,SUM"
#~ msgstr ""
#~ "@FUNCTION=MEDIAN\n"
#~ "@SYNTAX=MEDIAN(n1, n2, ...)\n"
#~ "@DESCRIPTION=MEDIAN devolve a mediana do conjunto de dados "
#~ "especificados.\n"
#~ "\n"
#~ "* Expressões e células vazias são simplesmente ignoradas.\n"
#~ "* Se for passado um número par de dados MEDIAN devolve a média dos dois "
#~ "números do meio.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1, A2, ..., A5 contêm os números 11.4, "
#~ "17.3, 21.3, 25.9, e 40.1.  Então\n"
#~ "MEDIAN(A1:A5) igual a 21.3.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,COUNT,COUNTA,DAVERAGE,MODE,SSMEDIAN,SUM"

#~ msgid ""
#~ "@FUNCTION=SSMEDIAN\n"
#~ "@SYNTAX=SSMEDIAN(array[,interval)]\n"
#~ "@DESCRIPTION=The SSMEDIAN function returns the median for grouped data as "
#~ "commonly determined in the social sciences. The data points given in "
#~ "@array are assumed to be the result of grouping data into intervals of "
#~ "length @interval\n"
#~ "\n"
#~ "* If @interval is not given, SSMEDIAN uses 1.\n"
#~ "* If @array is empty, SSMEDIAN returns #NUM! error.\n"
#~ "* If @interval <= 0, SSMEDIAN returns #NUM! error.\n"
#~ "* SSMEDIAN does not check whether the data points are at least @interval "
#~ "apart.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, A3 contain numbers 7, 8, 8.  Then\n"
#~ "SSMEDIAN(A1:A3, 1) equals 7.75.\n"
#~ "\n"
#~ "@SEEALSO=MEDIAN"
#~ msgstr ""
#~ "@FUNCTION=SSMEDIAN\n"
#~ "@SYNTAX=SSMEDIAN(matriz[,intervalo])\n"
#~ "@DESCRIPTION=A função SSMEDIAN devolve a mediana para dados agrupados tal "
#~ "como normalmente determinada em ciências sociais. Os pontos de dados "
#~ "indicados em @matriz são assumidos como sendo o resultado de agrupar "
#~ "dados em intervalos de comprimento @intervalo\n"
#~ "\n"
#~ "* Se @intervalo não for indicado, SSMEDIAN utiliza 1.\n"
#~ "* Se @matriz for vazia, SSMEDIAN devolve o erro #NUM!.\n"
#~ "* Se @intervalo <= 0, SSMEDIAN devolve o erro #NUM!.\n"
#~ "* SSMEDIAN não verifica se os pontos de daods têm pelo menos @intervalo "
#~ "de separação.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1, A2, A3 contêm os números 7, 8, 8.  "
#~ "Então\n"
#~ "SSMEDIAN(A1:A3, 1) é igual a 7.75.\n"
#~ "\n"
#~ "@SEEALSO=MEDIAN"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=LARGE\n"
#~ "@SYNTAX=LARGE(n, k)\n"
#~ "@DESCRIPTION=LARGE returns the k-th largest value in a data set.\n"
#~ "\n"
#~ "* If data set is empty LARGE returns #NUM! error.\n"
#~ "* If @k <= 0 or @k is greater than the number of data items given LARGE "
#~ "returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "LARGE(A1:A5,2) equals 25.9.\n"
#~ "LARGE(A1:A5,4) equals 17.3.\n"
#~ "\n"
#~ "@SEEALSO=PERCENTILE,PERCENTRANK,QUARTILE,SMALL"
#~ msgstr ""
#~ "@FUNCTION=LARGE\n"
#~ "@SYNTAX=LARGE(n1, n2, ..., k)\n"
#~ "@DESCRIPTION=LARGE devolve o k-ésimo maior valor num conjunto de dados.\n"
#~ "\n"
#~ "* Se o conjunto de dados estiver vazio LARGE devolve o erro #NUM!.\n"
#~ "* Se @k <= 0 ou @k for maior que o número de itens de dados passados "
#~ "LARGE devolve o erro #NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1, A2, ..., A5 contêm os números 11.4, "
#~ "17.3, 21.3, 25.9, e 40.1.  Então\n"
#~ "LARGE(A1:A5,2) igual a 25.9.\n"
#~ "LARGE(A1:A5,4) igual a 17.3.\n"
#~ "\n"
#~ "@SEEALSO=PERCENTILE,PERCENTRANK,QUARTILE,SMALL"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=SMALL\n"
#~ "@SYNTAX=SMALL(n, k)\n"
#~ "@DESCRIPTION=SMALL returns the k-th smallest value in a data set.\n"
#~ "\n"
#~ "* If data set is empty SMALL returns #NUM! error.\n"
#~ "* If @k <= 0 or @k is greater than the number of data items given SMALL "
#~ "returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "SMALL(A1:A5,2) equals 17.3.\n"
#~ "SMALL(A1:A5,4) equals 25.9.\n"
#~ "\n"
#~ "@SEEALSO=PERCENTILE,PERCENTRANK,QUARTILE,LARGE"
#~ msgstr ""
#~ "@FUNCTION=SMALL\n"
#~ "@SYNTAX=SMALL(n1, n2, ..., k)\n"
#~ "@DESCRIPTION=SMALL devolve o k-ésimo menor valor num conjunto de dados.\n"
#~ "\n"
#~ "* Se o conjunto de dados estiver vazio SMALL devolve o erro #NUM!.\n"
#~ "* Se @k <= 0 ou @k for maior que o número de itens de dados passados "
#~ "SMALL devolve o erro #NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1, A2, ..., A5 contêm os números 11.4, "
#~ "17.3, 21.3, 25.9, e 40.1.  Então\n"
#~ "SMALL(A1:A5,2) igual a 17.3.\n"
#~ "SMALL(A1:A5,4) igual a 25.9.\n"
#~ "\n"
#~ "@SEEALSO=PERCENTILE,PERCENTRANK,QUARTILE,LARGE"

#~ msgid ""
#~ "@FUNCTION=PROB\n"
#~ "@SYNTAX=PROB(x_range,prob_range,lower_limit[,upper_limit])\n"
#~ "@DESCRIPTION=PROB function returns the probability that values in a range "
#~ "or an array are between two limits. If @upper_limit is not given, PROB "
#~ "returns the probability that values in @x_range are equal to "
#~ "@lower_limit.\n"
#~ "\n"
#~ "* If the sum of the probabilities in @prob_range is not equal to 1 PROB "
#~ "returns #NUM! error.\n"
#~ "* If any value in @prob_range is <=0 or > 1, PROB returns #NUM! error.\n"
#~ "* If @x_range and @prob_range contain a different number of data entries, "
#~ "PROB returns #N/A error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=BINOMDIST,CRITBINOM"
#~ msgstr ""
#~ "@FUNCTION=PROB\n"
#~ "@SYNTAX=PROB(área_x,área_prob,limite_inf[,limite_sup])\n"
#~ "@DESCRIPTION=A função PROB devolve a probabilidade de valores numa área "
#~ "ou matriz estarem entre dois limites. Se @limit_sup não for dado, PROB "
#~ "devolve a probabilidade de valores na @área_x serem iguais ao "
#~ "@limite_inf.\n"
#~ "\n"
#~ "* Se a soma das probabilidades em @área_prob não for igual a 1, PROB "
#~ "devolve o erro #NUM!.\n"
#~ "* Se qualquer valor na @área_prob for <=0 ou > 1, PROB devolve o erro "
#~ "#NUM!.\n"
#~ "* Se @área_x e @área_prob contiverem um número diferente de dados, PROB "
#~ "devolve o erro #N/A.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=BINOMDIST,CRITBINOM"

#~ msgid ""
#~ "@FUNCTION=STEYX\n"
#~ "@SYNTAX=STEYX(known_y's,known_x's)\n"
#~ "@DESCRIPTION=STEYX function returns the standard error of the predicted y-"
#~ "value for each x in the regression.\n"
#~ "\n"
#~ "* If @known_y's and @known_x's are empty or have a different number of "
#~ "arguments then STEYX returns #N/A error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1, and the cells B1, B2, ... B5 23.2, 25.8, 29.9, "
#~ "33.5, and 42.7.  Then\n"
#~ "STEYX(A1:A5,B1:B5) equals 1.101509979.\n"
#~ "\n"
#~ "@SEEALSO=PEARSON,RSQ,SLOPE"
#~ msgstr ""
#~ "@FUNCTION=STEYX\n"
#~ "@SYNTAX=STEYX(y's_conhecidos,x's_conhecidos)\n"
#~ "@DESCRIPTION=A função STEYX devolve o desvio padrão do valor-y previsto "
#~ "para cada x na regressão.\n"
#~ "\n"
#~ "* Se @y's_conhecidos e @x's_conhecidos estiverem vazios ou possuírem um "
#~ "número distinto de argumentos, STEYX devolve o erro #N/A.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1, A2, ..., A5 contêm os números 11.4, "
#~ "17.3, 21.3, 25.9, e 40.1, e as células B1, B2, ... B5 23.2, 25.8, 29.9, "
#~ "33.5, e 42.7.  Então\n"
#~ "STEYX(A1:A5,B1:B5) igual a 1.101509979.\n"
#~ "\n"
#~ "@SEEALSO=PEARSON,RSQ,SLOPE"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=ZTEST\n"
#~ "@SYNTAX=ZTEST(ref,x[,stddev])\n"
#~ "@DESCRIPTION=ZTEST returns the two-tailed probability of a z-test.\n"
#~ "\n"
#~ "@ref is the data set and @x is the value to be tested.\n"
#~ "@stddev is optionally an assumed standard deviation.\n"
#~ "\n"
#~ "* If @ref contains less than two data items ZTEST returns #DIV/0! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "ZTEST(A1:A5,20) equals 0.254717826.\n"
#~ "\n"
#~ "@SEEALSO=CONFIDENCE,NORMDIST,NORMINV,NORMSDIST,NORMSINV,STANDARDIZE"
#~ msgstr ""
#~ "@FUNCTION=ZTEST\n"
#~ "@SYNTAX=ZTEST(ref,x)\n"
#~ "@DESCRIPTION=ZTEST devolve a probabilidade de duas-caudas de um teste-z.\n"
#~ "\n"
#~ "@ref é o conjunto de dados e @x é o valor a ser testado.\n"
#~ "\n"
#~ "* Se @ref contiver menos de dois itens de dados ZTEST devolve o erro "
#~ "#DIV/0!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1, A2, ..., A5 contêm os números 11.4, "
#~ "17.3, 21.3, 25.9, e 40.1.  Então\n"
#~ "ZTEST(A1:A5,20) igual a 0.254717826.\n"
#~ "\n"
#~ "@SEEALSO=CONFIDENCE,NORMDIST,NORMINV,NORMSDIST,NORMSINV,STANDARDIZE"

#~ msgid ""
#~ "@FUNCTION=AVERAGEA\n"
#~ "@SYNTAX=AVERAGEA(number1,number2,...)\n"
#~ "@DESCRIPTION=AVERAGEA returns the average of the given arguments.  "
#~ "Numbers, text and logical values are included in the calculation too. If "
#~ "the cell contains text or the argument evaluates to FALSE, it is counted "
#~ "as value zero (0).  If the argument evaluates to TRUE, it is counted as "
#~ "one (1).  Note that empty cells are not counted.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers and strings "
#~ "11.4, 17.3, \"missing\", 25.9, and 40.1.  Then\n"
#~ "AVERAGEA(A1:A5) equals 18.94.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE"
#~ msgstr ""
#~ "@FUNCTION=AVERAGEA\n"
#~ "@SYNTAX=AVERAGEA(número1,número2,...)\n"
#~ "@DESCRIPTION=AVERAGEA devolve a média dos argumentos passados. Números, "
#~ "texto e valores lógicos são também incluidos nos cálculos. Se a célula "
#~ "contiver texto ou o argumento for avaliado como FALSO, será contado como "
#~ "o valor zero (0).  Se o argumento for avaliado como VERDADE, será contado "
#~ "como um (1).  Note que células vazias não serão contadas.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1, A2, ..., A5 contêm os números e "
#~ "expressões 11.4, 17.3, \"em falta\", 25.9, e 40.1.  Então\n"
#~ "AVERAGEA(A1:A5) igual a 18.94.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE"

#~ msgid ""
#~ "@FUNCTION=MAXA\n"
#~ "@SYNTAX=MAXA(number1,number2,...)\n"
#~ "@DESCRIPTION=MAXA returns the largest value of the given arguments.  "
#~ "Numbers, text and logical values are included in the calculation too. If "
#~ "the cell contains text or the argument evaluates to FALSE, it is counted "
#~ "as value zero (0).  If the argument evaluates to TRUE, it is counted as "
#~ "one (1).  Note that empty cells are not counted.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers and strings "
#~ "11.4, 17.3, \"missing\", 25.9, and 40.1.  Then\n"
#~ "MAXA(A1:A5) equals 40.1.\n"
#~ "\n"
#~ "@SEEALSO=MAX,MINA"
#~ msgstr ""
#~ "@FUNCTION=MAXA\n"
#~ "@SYNTAX=MAXA(número1,número2,...)\n"
#~ "@DESCRIPTION=MAXA devolve o maior valor dos argumentos passados.  "
#~ "Números, texto e valores lógicos são também incluidos nos cálculos. Se a "
#~ "célula contiver texto ou o argumento for avaliado como FALSO, será "
#~ "contado como o valor zero (0).  Se o argumento for avaliado como VERDADE, "
#~ "será contado como um (1).  Note que células vazias não serão contadas.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1, A2, ..., A5 contêm os números e "
#~ "expressões 11.4, 17.3, \"em falta\", 25.9, e 40.1.  Então\n"
#~ "MAXA(A1:A5) igual a 40.1.\n"
#~ "\n"
#~ "@SEEALSO=MAX,MINA"

#~ msgid ""
#~ "@FUNCTION=MINA\n"
#~ "@SYNTAX=MINA(number1,number2,...)\n"
#~ "@DESCRIPTION=MINA returns the smallest value of the given arguments.  "
#~ "Numbers, text and logical values are included in the calculation too. If "
#~ "the cell contains text or the argument evaluates to FALSE, it is counted "
#~ "as value zero (0).  If the argument evaluates to TRUE, it is counted as "
#~ "one (1).  Note that empty cells are not counted.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers and strings "
#~ "11.4, 17.3, \"missing\", 25.9, and 40.1.  Then\n"
#~ "MINA(A1:A5) equals 0.\n"
#~ "\n"
#~ "@SEEALSO=MIN,MAXA"
#~ msgstr ""
#~ "@FUNCTION=MINA\n"
#~ "@SYNTAX=MINA(número1,número2,...)\n"
#~ "@DESCRIPTION=MINA devolve o menor valor dos argumentos passados.  "
#~ "Números, texto e valores lógicos são também incluidos nos cálculos. Se a "
#~ "célula contiver texto ou o argumento for avaliado como FALSO, será "
#~ "contado como o valor zero (0).  Se o argumento for avaliado como VERDADE, "
#~ "será contado como um (1).  Note que células vazias não serão contadas.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1, A2, ..., A5 contêm os números e "
#~ "expressões 11.4, 17.3, \"em falta\", 25.9, e 40.1.  Então\n"
#~ "MINA(A1:A5) igual a 0.\n"
#~ "\n"
#~ "@SEEALSO=MAX,MINA"

#~ msgid ""
#~ "@FUNCTION=VARA\n"
#~ "@SYNTAX=VARA(number1,number2,...)\n"
#~ "@DESCRIPTION=VARA calculates sample variance of the given sample.\n"
#~ "To get the true variance of a complete population use VARPA.\n"
#~ "VARA is also known as the N-1-variance.\n"
#~ "Under reasonable conditions, it is the maximum-likelihood estimator for "
#~ "the true variance.\n"
#~ "Numbers, text and logical values are included in the calculation too. If "
#~ "the cell contains text or the argument evaluates to FALSE, it is counted "
#~ "as value zero (0).  If the argument evaluates to TRUE, it is counted as "
#~ "one (1).  Note that empty cells are not counted.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers and strings "
#~ "11.4, 17.3, \"missing\", 25.9, and 40.1.  Then\n"
#~ "VARA(A1:A5) equals 228.613.\n"
#~ "\n"
#~ "@SEEALSO=VAR,VARPA"
#~ msgstr ""
#~ "@FUNCTION=VARA\n"
#~ "@SYNTAX=VARA(número1,número2,...)\n"
#~ "@DESCRIPTION=VARA devolve a variância baseada numa amostra. Números, "
#~ "texto e valores lógicos são também incluidos nos cálculos. Se a célula "
#~ "contiver texto ou o argumento for avaliado como FALSO, será contado como "
#~ "o valor zero (0).  Se o argumento for avaliado como VERDADE, será contado "
#~ "como um (1).  Note que células vazias não serão contadas.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1, A2, ..., A5 contêm os números e "
#~ "expressões 11.4, 17.3, \"em falta\", 25.9, e 40.1.  Então\n"
#~ "VARA(A1:A5) igual a 228.613.\n"
#~ "\n"
#~ "@SEEALSO=VAR,VARPA"

#~ msgid ""
#~ "@FUNCTION=VARPA\n"
#~ "@SYNTAX=VARPA(number1,number2,...)\n"
#~ "@DESCRIPTION=VARPA calculates the variance of an entire population.\n"
#~ "VARPA is also known as the N-variance.\n"
#~ "Numbers, text and logical values are included in the calculation too.  If "
#~ "the cell contains text or the argument evaluates to FALSE, it is counted "
#~ "as value zero (0).  If the argument evaluates to TRUE, it is counted as "
#~ "one (1).  Note that empty cells are not counted.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers and strings "
#~ "11.4, 17.3, \"missing\", 25.9, and 40.1.  Then\n"
#~ "VARPA(A1:A5) equals 182.8904.\n"
#~ "\n"
#~ "@SEEALSO=VARA,VARP"
#~ msgstr ""
#~ "@FUNCTION=VARPA\n"
#~ "@SYNTAX=VARPA(número1,número2,...)\n"
#~ "@DESCRIPTION=VARPA devolve a variância baseada em toda a população.  "
#~ "Números, texto e valores lógicos são também incluidos nos cálculos. Se a "
#~ "célula contiver texto ou o argumento for avaliado como FALSO, será "
#~ "contado como o valor zero (0).  Se o argumento for avaliado como "
#~ "VERDADEIRO, será contado como um (1).  Note que células vazias não serão "
#~ "contadas.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1, A2, ..., A5 contêm os números e "
#~ "expressões 11.4, 17.3, \"em falta\", 25.9, e 40.1.  Então\n"
#~ "VARPA(A1:A5) igual a 182.8904.\n"
#~ "\n"
#~ "@SEEALSO=VARA,VARP"

#~ msgid ""
#~ "@FUNCTION=STDEVA\n"
#~ "@SYNTAX=STDEVA(number1,number2,...)\n"
#~ "@DESCRIPTION=STDEVA returns the sample standard deviation of the given "
#~ "sample.\n"
#~ "To obtain the population standard deviation of a whole population use "
#~ "STDEVPA.\n"
#~ "STDEVA is also known as the N-1-standard deviation.\n"
#~ "Under reasonable conditions, it is the maximum-likelihood estimator for "
#~ "the true population standard deviation.\n"
#~ "Numbers, text and logical values are included in the calculation too.  If "
#~ "the cell contains text or the argument evaluates to FALSE, it is counted "
#~ "as value zero (0).  If the argument evaluates to TRUE, it is counted as "
#~ "one (1).  Note that empty cells are not counted.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers and strings "
#~ "11.4, 17.3, \"missing\", 25.9, and 40.1.  Then\n"
#~ "STDEVA(A1:A5) equals 15.119953704.\n"
#~ "\n"
#~ "@SEEALSO=STDEV,STDEVPA"
#~ msgstr ""
#~ "@FUNCTION=STDEVA\n"
#~ "@SYNTAX=STDEVA(número1,número2,...)\n"
#~ "@DESCRIPTION=STDEVA devolve o desvio padrão baseado numa amostra. "
#~ "Números, texto e valores lógicos são também incluidos nos cálculos. Se a "
#~ "célula contiver texto ou o argumento for avaliado como FALSO, será "
#~ "contado como o valor zero (0).  Se o argumento for avaliado como VERDADE, "
#~ "será contado como um (1).  Note que células vazias não serão contadas.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1, A2, ..., A5 contêm os números e "
#~ "expressões 11.4, 17.3, \"em falta\", 25.9, e 40.1.  Então\n"
#~ "STDEVA(A1:A5) igual a 15.119953704.\n"
#~ "\n"
#~ "@SEEALSO=STDEV,STDEVPA"

#~ msgid ""
#~ "@FUNCTION=STDEVPA\n"
#~ "@SYNTAX=STDEVPA(number1,number2,...)\n"
#~ "@DESCRIPTION=STDEVPA returns the population standard deviation of an "
#~ "entire population.\n"
#~ "This is also known as the N-standard deviation\n"
#~ "Numbers, text and logical values are included in the calculation too.  If "
#~ "the cell contains text or the argument evaluates to FALSE, it is counted "
#~ "as value zero (0).  If the argument evaluates to TRUE, it is counted as "
#~ "one (1).  Note that empty cells are not counted.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers and strings "
#~ "11.4, 17.3, \"missing\", 25.9, and 40.1.  Then\n"
#~ "STDEVPA(A1:A5) equals 13.523697719.\n"
#~ "\n"
#~ "@SEEALSO=STDEVA,STDEVP"
#~ msgstr ""
#~ "@FUNCTION=STDEVPA\n"
#~ "@SYNTAX=STDEVPA(número1,número2,...)\n"
#~ "@DESCRIPTION=STDEVPA devolve o desvio padrão baseado em toda a população. "
#~ "Números, texto e valores lógicos são também incluidos nos cálculos. Se a "
#~ "célula contiver texto ou o argumento for avaliado como FALSO, será "
#~ "contado como sendo o valor zero (0).  Se o argumento for avaliado como "
#~ "VERDADE, será contado como um (1).  Note que células vazias não serão "
#~ "contadas.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1, A2, ..., A5 contêm os números e "
#~ "expressões 11.4, 17.3, \"em falta\", 25.9, e 40.1.  Então\n"
#~ "STDEVPA(A1:A5) igual a 13.523697719.\n"
#~ "\n"
#~ "@SEEALSO=STDEVA,STDEVP"

#~ msgid ""
#~ "@FUNCTION=PERCENTRANK\n"
#~ "@SYNTAX=PERCENTRANK(array,x[,significance])\n"
#~ "@DESCRIPTION=PERCENTRANK function returns the rank of a data point in a "
#~ "data set.  @array is the range of numeric values, @x is the data point "
#~ "which you want to rank, and the optional @significance specifies the "
#~ "number of significant digits for the returned value, truncating the "
#~ "remainder.  If @significance is omitted, PERCENTRANK uses three digits.\n"
#~ "\n"
#~ "* If @array contains no data points, PERCENTRANK returns #NUM! error.\n"
#~ "* If @significance is less than one, PERCENTRANK returns #NUM! error.\n"
#~ "* If @x exceeds the largest value or is less than the smallest value in "
#~ "@array, PERCENTRANK returns #NUM! error.\n"
#~ "* If @x does not match any of the values in @array or @x matches more "
#~ "than once, PERCENTRANK interpolates the returned value.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=LARGE,MAX,MEDIAN,MIN,PERCENTILE,QUARTILE,SMALL"
#~ msgstr ""
#~ "@FUNCTION=PERCENTRANK\n"
#~ "@SYNTAX=PERCENTRANK(matriz,x[,significância])\n"
#~ "@DESCRIPTION=A função PERCENTRANK devolve a posição de um ponto de dados "
#~ "num conjunto de dados.  @matriz é o intervalo de valores numéricos, @x é "
#~ "o ponto de dados de que deseja saber a posição, e a @significância "
#~ "opcional indentifica o número de dígitos significantes para o valor "
#~ "devolvido, truncando o remanescente. Se @significância for omitida, "
#~ "PERCENTRANK utiliza três dígitos.\n"
#~ "\n"
#~ "* Se @matriz não contiver pontos de dados, PERCENTRANK devolve o erro "
#~ "#NUM!.\n"
#~ "* Se @significância for menor do que um, PERCENTRANK devolve o erro "
#~ "#NUM!.\n"
#~ "* Se @x exceder o maior valor ou for menor do que o menor valor dentro de "
#~ "@matriz, PERCENTRANK devolve o erro #NUM!.\n"
#~ "* Se @x não equivaler a nenhum dos valores na @matriz ou @x equivaler a "
#~ "mais do que um, PERCENTRANK interpola o valor devolvido.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=LARGE,MAX,MEDIAN,MIN,PERCENTILE,QUARTILE,SMALL"

#~ msgid ""
#~ "@FUNCTION=PERCENTILE\n"
#~ "@SYNTAX=PERCENTILE(array,k)\n"
#~ "@DESCRIPTION=PERCENTILE function returns the 100*@k-th percentile of the "
#~ "given data points (that is, a number x such that a fraction @k of the "
#~ "data points are less than x).\n"
#~ "\n"
#~ "* If @array is empty, PERCENTILE returns #NUM! error.\n"
#~ "* If @k < 0 or @k > 1, PERCENTILE returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "PERCENTILE(A1:A5,0.42) equals 20.02.\n"
#~ "\n"
#~ "@SEEALSO=QUARTILE"
#~ msgstr ""
#~ "@FUNCTION=PERCENTILE\n"
#~ "@SYNTAX=PERCENTILE(matriz,k)\n"
#~ "@DESCRIPTION=A função PERCENTILE devolve o percentil 100*@k-esimo dos "
#~ "pontos de dados indicados (isto é, um número x tal que uma fracção @k dos "
#~ "pontos de dados são menos do que x).\n"
#~ "\n"
#~ "* Se @matriz estiver vazia, PERCENTILE devolve o erro #NUM!.\n"
#~ "* Se @k < 0 ou @k > 1, PERCENTILE devolve o erro #NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1, A2, ..., A5 contêm os números 11.4, "
#~ "17.3, 21.3, 25.9, e 40.1.  Então\n"
#~ "PERCENTILE(A1:A5,0.42) igual a 20.02.\n"
#~ "\n"
#~ "@SEEALSO=QUARTILE"

#~ msgid ""
#~ "@FUNCTION=QUARTILE\n"
#~ "@SYNTAX=QUARTILE(array,quart)\n"
#~ "@DESCRIPTION=QUARTILE function returns the quartile of the given data "
#~ "points.\n"
#~ "\n"
#~ "If @quart is equal to: QUARTILE returns:\n"
#~ "0                      the smallest value of @array.\n"
#~ "1                      the first quartile\n"
#~ "2                      the second quartile\n"
#~ "3                      the third quartile\n"
#~ "4                      the largest value of @array.\n"
#~ "\n"
#~ "* If @array is empty, QUARTILE returns #NUM! error.\n"
#~ "* If @quart < 0 or @quart > 4, QUARTILE returns #NUM! error.\n"
#~ "* If @quart is not an integer, it is truncated.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "QUARTILE(A1:A5,1) equals 17.3.\n"
#~ "\n"
#~ "@SEEALSO=LARGE,MAX,MEDIAN,MIN,PERCENTILE,SMALL"
#~ msgstr ""
#~ "@FUNCTION=QUARTILE\n"
#~ "@SYNTAX=QUARTILE(matriz,quart)\n"
#~ "@DESCRIPTION=A função QUARTILE devolve o quartilho dos pontos de dados "
#~ "indicados.\n"
#~ "\n"
#~ "Se @quart for igual a: QUARTILE devolve:\n"
#~ "0                      o valor mais pequeno da @matriz.\n"
#~ "1                      o primeiro quartil\n"
#~ "2                      o segundo quartil\n"
#~ "3                      o terceiro quartil\n"
#~ "4                      o maior valor da @matriz.\n"
#~ "\n"
#~ "* Se @matriz estiver vazia, QUARTILE devolve o erro #NUM!.\n"
#~ "* Se @quart < 0 ou @quart > 4, QUARTILE devolve o erro #NUM!.\n"
#~ "* Se @quart não for um inteiro, será truncado.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1, A2, ..., A5 contêm os números 11.4, "
#~ "17.3, 21.3, 25.9, e 40.1.  Então\n"
#~ "QUARTILE(A1:A5,1) igual a 17.3.\n"
#~ "\n"
#~ "@SEEALSO=LARGE,MAX,MEDIAN,MIN,PERCENTILE,SMALL"

#~ msgid ""
#~ "@FUNCTION=FTEST\n"
#~ "@SYNTAX=FTEST(array1,array2)\n"
#~ "@DESCRIPTION=FTEST function returns the two-tailed probability that the "
#~ "variances in the given two data sets are not significantly different.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1, and the cells B1, B2, ... B5 23.2, 25.8, 29.9, "
#~ "33.5, and 42.7.  Then\n"
#~ "FTEST(A1:A5,B1:B5) equals 0.510815017.\n"
#~ "\n"
#~ "@SEEALSO=FDIST,FINV"
#~ msgstr ""
#~ "@FUNCTION=FTEST\n"
#~ "@SYNTAX=FTEST(matriz1,matriz2)\n"
#~ "@DESCRIPTION=A função FTEST devolve a probabilidade de duas-caudas de que "
#~ "as variâncias nos dois conjuntos de dados não são significativamente "
#~ "diferentes.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1, A2, ..., A5 contêm os números 11.4, "
#~ "17.3, 21.3, 25.9, e 40.1, e as células B1, B2, ... B5 23.2, 25.8, 29.9, "
#~ "33.5, e 42.7. Então\n"
#~ "FTEST(A1:A5,B1:B5) igual a 0.510815017.\n"
#~ "\n"
#~ "@SEEALSO=FDIST,FINV"

#~ msgid ""
#~ "@FUNCTION=TTEST\n"
#~ "@SYNTAX=TTEST(array1,array2,tails,type)\n"
#~ "@DESCRIPTION=TTEST function returns the probability of a Student's t-"
#~ "Test. \n"
#~ "@array1 is the first data set and @array2 is the second data set.  If "
#~ "@tails is one, TTEST uses the one-tailed distribution and if @tails is "
#~ "two, TTEST uses the two-tailed distribution.  @type determines the kind "
#~ "of the test:\n"
#~ "\n"
#~ "\t1  Paired test\n"
#~ "\t2  Two-sample equal variance\n"
#~ "\t3  Two-sample unequal variance\n"
#~ "\n"
#~ "* If the data sets contain a different number of data points and the test "
#~ "is paired (@type one), TTEST returns the #N/A error.\n"
#~ "* @tails and @type are truncated to integers.\n"
#~ "* If @tails is not one or two, TTEST returns #NUM! error.\n"
#~ "* If @type is any other than one, two, or three, TTEST returns #NUM! "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1, and the cells B1, B2, ... B5 23.2, 25.8, 29.9, "
#~ "33.5, and 42.7.  Then\n"
#~ "TTEST(A1:A5,B1:B5,1,1) equals 0.003127619.\n"
#~ "TTEST(A1:A5,B1:B5,2,1) equals 0.006255239.\n"
#~ "TTEST(A1:A5,B1:B5,1,2) equals 0.111804322.\n"
#~ "TTEST(A1:A5,B1:B5,1,3) equals 0.113821797.\n"
#~ "\n"
#~ "@SEEALSO=FDIST,FINV"
#~ msgstr ""
#~ "@FUNCTION=TTEST\n"
#~ "@SYNTAX=TTEST(matriz1,matriz2,caudas,tipo)\n"
#~ "@DESCRIPTION=A função TTEST devolve a probabilidade de um Student's Teste-"
#~ "T. \n"
#~ "@matriz1 é o primeiro conjunto de dados e @matriz2 é o segundo conjunto "
#~ "de dados. Se @caudas for um, TTEST utiliza a distribuição de uma-cauda e "
#~ "se @caudas for dois, TTEST utiliza a distribuição de duas-caudas. @tipo "
#~ "determina o tipo do teste:\n"
#~ "\n"
#~ "\t1  Teste de pares\n"
#~ "\t2  Variância igual de duas-amostras\n"
#~ "\t3  Variância diferente de duas-amostras\n"
#~ "\n"
#~ "* Se os conjuntos de dados tiverem um diferente número de pontos de dados "
#~ "e o teste é de pares (@tipo um), TTEST devolve o erro #N/A.\n"
#~ "* @caudas e @tipo são truncados para inteiros.\n"
#~ "* Se @caudas não for nem um nem dois, TTEST devolve o erro #NUM!.\n"
#~ "* Se @tipo for outro que não um, dois ou três, TTEST devolve o erro "
#~ "#NUM!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1, A2, ..., A5 contêm os números 11.4, "
#~ "17.3, 21.3, 25.9, e 40.1, e as células B1, B2, ... B5 23.2, 25.8, 29.9, "
#~ "33.5, e 42.7. Então\n"
#~ "TTEST(A1:A5,B1:B5,1,1) igual a 0.003127619.\n"
#~ "TTEST(A1:A5,B1:B5,2,1) igual a 0.006255239.\n"
#~ "TTEST(A1:A5,B1:B5,1,2) igual a 0.111804322.\n"
#~ "TTEST(A1:A5,B1:B5,1,3) igual a 0.113821797.\n"
#~ "\n"
#~ "@SEEALSO=FDIST,FINV"

#~ msgid ""
#~ "@FUNCTION=FREQUENCY\n"
#~ "@SYNTAX=FREQUENCY(data_array,bins_array)\n"
#~ "@DESCRIPTION=FREQUENCY function counts how often given values occur "
#~ "within a range of values.  The results are given as an array.\n"
#~ "\n"
#~ "@data_array is a data array for which you want to count the frequencies.  "
#~ "@bin_array is an array containing the intervals into which you want to "
#~ "group the values in data_array.  If the @bin_array is empty, FREQUENCY "
#~ "returns the number of data points in @data_array.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=FREQUENCY\n"
#~ "@SYNTAX=FREQUENCY(matriz_dados,matriz_bins)\n"
#~ "@DESCRIPTION=A função FREQUENCY conta com que frequência dados valores "
#~ "ocorrem dentro de um conjunto de valores. Os resultados são devolvidos "
#~ "como uma matriz. \n"
#~ "\n"
#~ "@matriz_dados é a matriz dos dados para os quais deseja contar as "
#~ "frequências.  @matriz_bins é a matriz que contém os intervalos sob os "
#~ "quais deseja agrupar os valores na matriz_dados. Se @matriz_bins for "
#~ "vazia, FREQUENCY devolve o número de pontos de dados na @matriz_dados.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=LINEST\n"
#~ "@SYNTAX=LINEST(known_y's[,known_x's[,const[,stat]]])\n"
#~ "@DESCRIPTION=LINEST function calculates the ``least squares'' line that "
#~ "best fit to your data in @known_y's.  @known_x's contains the "
#~ "corresponding x's where y=mx+b.\n"
#~ "\n"
#~ "LINEST returns an array having two columns and one row.  The slope (m) of "
#~ "the regression line y=mx+b is given in the first column and the y-"
#~ "intercept (b) in the second.\n"
#~ "\n"
#~ "If @stat is TRUE, extra statistical information will be returned. Extra "
#~ "statistical information is written below the regression line coefficients "
#~ "in the result array.  Extra statistical information consists of four rows "
#~ "of data.  In the first row the standard error values for the coefficients "
#~ "m1, (m2, ...), b are represented.  The second row contains the square of "
#~ "R and the standard error for the y estimate.  The third row contains the "
#~ "F-observed value and the degrees of freedom.  The last row contains the "
#~ "regression sum of squares and the residual sum of squares.\n"
#~ "\n"
#~ "* If @known_x's is omitted, an array {1, 2, 3, ...} is used.\n"
#~ "* If @known_y's and @known_x's have unequal number of data points, LINEST "
#~ "returns #NUM! error.\n"
#~ "* If @const is FALSE, the line will be forced to go through the origin, i."
#~ "e., b will be zero. The default is TRUE.\n"
#~ "* The default of @stat is FALSE.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=LOGEST,TREND"
#~ msgstr ""
#~ "@FUNCTION=LINEST\n"
#~ "@SYNTAX=LINEST(y's_conhecidos[,x's_conhecidos[,const[,stat]]])\n"
#~ "@DESCRIPTION=A função LINEST calcula a linha ``menores quadrados'' que "
#~ "melhor se encaixa nos seus dados em @y's_conhecidos. @x's_conhecidos "
#~ "contém os x's correspondentes onde y=mx+b.\n"
#~ "\n"
#~ "LINEST devolve uma matriz com duas colunas e uma linha. A inclinação (m) "
#~ "da linha de regressão y=mx+b é dada na primeira coluna e a intercepção de "
#~ "y (b) na segunda.\n"
#~ "\n"
#~ "Se @stat for VERDADE, informação estatística adicional será devolvida. "
#~ "Informação estatística adicional é escrita por baixo dos coeficientes da "
#~ "linha de regressão na matriz de resultado. Informação estatística "
#~ "adicional consiste em quatro linhas de dados. Na primeira linha são "
#~ "representados os valores de desvio padrão para os coeficientes m1, "
#~ "(m2, ...), b. A segunda linha contém o quadrado de R e o desvio padrão "
#~ "para a estimativa de y. A terceira linha contém o valor observado de F e "
#~ "o grau de liberdade. A última linha contém a regressão da soma dos "
#~ "quadrados e o resíduo da soma dos quadrados. \n"
#~ "\n"
#~ "* Se @x's_conhecidos for omitido, é utilizada uma matriz {1, 2, 3, ...}.\n"
#~ "* Se @y's_conhecidos e @x's_conhecidos tiverem um número desigual de "
#~ "pontos de dados, LINEST devolve o erro #NUM!.\n"
#~ "* Se @const for FALSO, a linha será forçada a passar pelo ponto de "
#~ "origem, isto é, b será zero. A omissão é VERDADE.\n"
#~ "* A omissão de @stat é FALSO.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=LOGEST,TREND"

#~ msgid ""
#~ "@FUNCTION=LOGREG\n"
#~ "@SYNTAX=LOGREG(known_y's[,known_x's[,const[,stat]]])\n"
#~ "@DESCRIPTION=LOGREG function transforms your x's to z=ln(x) and applies "
#~ "the ``least squares'' method to fit the linear equation\n"
#~ "y = m * z + b \n"
#~ "to your y's and z's --- equivalent to fitting the equation\n"
#~ "y = m * ln(x) + b \n"
#~ "to y's and x's. \n"
#~ "\n"
#~ "If @known_x's is omitted, an array {1, 2, 3, ...} is used. LOGREG returns "
#~ "an array having two columns and one row. m is given in the first column "
#~ "and b in the second. \n"
#~ "\n"
#~ "If @known_y's and @known_x's have unequal number of data points, LOGREG "
#~ "returns #NUM! error.\n"
#~ "\n"
#~ "If @const is FALSE, the curve will be forced to go through [1; 0], i.e., "
#~ "b will be zero. The default is TRUE.\n"
#~ "\n"
#~ "If @stat is TRUE, extra statistical information will be returned which "
#~ "applies to the state AFTER transformation to z. Extra statistical "
#~ "information is written below m and b in the result array.  Extra "
#~ "statistical information consists of four rows of data.  In the first row "
#~ "the standard error values for the coefficients m, b are represented.  The "
#~ "second row contains the square of R and the standard error for the y "
#~ "estimate. The third row contains the F-observed value and the degrees of "
#~ "freedom.  The last row contains the regression sum of squares and the "
#~ "residual sum of squares.The default of @stat is FALSE.\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=LOGFIT,LINEST,LOGEST"
#~ msgstr ""
#~ "@FUNCTION=LOGREG\n"
#~ "@SYNTAX=LOGREG(y's_conhecidos[,x's_conhecidos[,const[,stat]]])\n"
#~ "@DESCRIPTION=A função LOGREG transforma os seus x's em z=ln(x) e aplica o "
#~ "método dos ``menores quadrados'' para determinar a equação linear\n"
#~ "y = m * z + b \n"
#~ "para os seus y's e z's --- equivalente a encaixar a equação\n"
#~ "y = m * ln(x) + b \n"
#~ "para y's e x's. \n"
#~ "\n"
#~ "Se @x's_conhecidos for omitido, é utilizada uma matriz {1, 2, 3, ...}. "
#~ "LOGREG devolve uma matriz com duas colunas e uma linha. m é dado na "
#~ "primeira coluna e b na segunda.\n"
#~ "\n"
#~ "Se @y's_conhecidos e @x's_conhecidos tiverem um número desigual de pontos "
#~ "de dados, LOGREG devolve o erro #NUM!.\n"
#~ "\n"
#~ "Se @const for FALSO, a curva será obrigada a passar pelo ponto [1; 0], "
#~ "isto é, b será zero. A omissão é VERDADE.\n"
#~ "\n"
#~ "Se @stat for VERDADE, informação estatística adicional será devolvida que "
#~ "se aplicará ao estado APÓS a transformação para z. Informação estatística "
#~ "adicional é escrita por baixo de m e b na matriz de resultado. Informação "
#~ "estatística adicional consiste em quatro linhas de dados. Na primeira "
#~ "linha são representados os valores de erro padrão para os coeficientes m, "
#~ "b. A segunda linha contém o quadrado de R e o erro padrão para o y "
#~ "estimado. A terceira linha contém o valor F-observado e os graus de "
#~ "liberdade. A última linha contém a soma dos quadrados da regressão e a "
#~ "soma dos quadrados residual. O valor por omissão de @stat é FALSO.\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=LOGFIT,LINEST,LOGEST"

#~ msgid ""
#~ "@FUNCTION=LOGFIT\n"
#~ "@SYNTAX=LOGFIT(known_y's,known_x's)\n"
#~ "@DESCRIPTION=LOGFIT function applies the ``least squares'' method to fit "
#~ "the logarithmic equation\n"
#~ "y = a + b * ln(sign * (x - c)) ,   sign = +1 or -1 \n"
#~ "to your data. The graph of the equation is a logarithmic curve moved "
#~ "horizontally by c and possibly mirrored across the y-axis (if sign = "
#~ "-1).\n"
#~ "\n"
#~ "LOGFIT returns an array having five columns and one row. `Sign' is given "
#~ "in the first column, `a', `b', and `c' are given in columns 2 to 4. "
#~ "Column 5 holds the sum of squared residuals.\n"
#~ "\n"
#~ "An error is returned when there are less than 3 different x's or y's, or "
#~ "when the shape of the point cloud is too different from a ``logarithmic'' "
#~ "one.\n"
#~ "\n"
#~ "You can use the above formula \n"
#~ "= a + b * ln(sign * (x - c)) \n"
#~ "or rearrange it to \n"
#~ "= (exp((y - a) / b)) / sign + c \n"
#~ "to compute unknown y's or x's, respectively. \n"
#~ "\n"
#~ "Technically, this is non-linear fitting by trial-and-error. The accuracy "
#~ "of `c' is: width of x-range -> rounded to the next smaller (10^integer), "
#~ "times 0.000001. There might be cases in which the returned fit is not the "
#~ "best possible.\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=LOGREG,LINEST,LOGEST"
#~ msgstr ""
#~ "@FUNCTION=LOGFIT\n"
#~ "@SYNTAX=LOGFIT(y's_conhecidos,x's_conhecidos)\n"
#~ "@DESCRIPTION=A função LOGFIT aplica o método dos ``menores quadrados'' "
#~ "para encaixar a seguinte equação logarítmica\n"
#~ "y = a + b * ln(sign * (x - c)) ,   sign = +1 or -1 \n"
#~ "aos seus dados. O gráfico da equação é uma curva logarítmica movida "
#~ "horizontalmente por c e possivelmente replicada ao longo do eixo-y (se "
#~ "sinal = -1).\n"
#~ "\n"
#~ "LOGFIT devolve uma matriz com cinco colunas e uma linha. `Sinal' é dado "
#~ "na primeira coluna, `a', `b', e `c' são dados nas colunas 2 a 4. A coluna "
#~ "5 contém a soma dos quadrados residuais.\n"
#~ "\n"
#~ "É devolvido um erro quando existem menos de 3 x's ou y's diferentes ou "
#~ "quando a forma da núvem de pontos é demasiado diferente de uma "
#~ "``logarítmica''.\n"
#~ "\n"
#~ "Pode utilizar a seguinte fórmula \n"
#~ "= a + b * ln(sinal * (x - c)) \n"
#~ "ou reorganiza-la para \n"
#~ "= (exp((y - a) / b)) / sinal + c \n"
#~ "para calcular respectivamente y's ou x's desconhecidos. \n"
#~ "\n"
#~ "Tecnicamente, isto é um encaixe não-linear por tentativa e erro. A "
#~ "precisão dos `c' é: largura da área-x -> arredondada ao menor seguinte "
#~ "(10^inteiro), multiplicado por 0.000001. Podem existir casos em que o "
#~ "encaixe retornado não é o melhor possível.\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=LOGREG,LINEST,LOGEST"

#~ msgid ""
#~ "@FUNCTION=TREND\n"
#~ "@SYNTAX=TREND(known_y's[,known_x's[,new_x's[,const]]])\n"
#~ "@DESCRIPTION=TREND function estimates future values of a given data set "
#~ "using the ``least squares'' line that best fit to your data. @known_y's "
#~ "is the y-values where y=mx+b and @known_x's contains the corresponding x-"
#~ "values.  @new_x's contains the x-values for which you want to estimate "
#~ "the y-values. If @const is FALSE, the line will be forced to go through "
#~ "the origin, i.e., b will be zero.\n"
#~ "\n"
#~ "* If @known_x's is omitted, an array {1, 2, 3, ...} is used.\n"
#~ "* If @new_x's is omitted, it is assumed to be the same as @known_x's.\n"
#~ "* If @const is omitted, it is assumed to be TRUE.\n"
#~ "* If @known_y's and @known_x's have unequal number of data points, TREND "
#~ "returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1, and the cells B1, B2, ... B5 23.2, 25.8, 29.9, "
#~ "33.5, and 42.7.  Then\n"
#~ "TREND(A1:A5,B1:B5) equals {12.1, 15.7, 21.6, 26.7, 39.7}.\n"
#~ "\n"
#~ "@SEEALSO=LINEST"
#~ msgstr ""
#~ "@FUNCTION=TREND\n"
#~ "@SYNTAX=TREND(y's_conhecidos[,x's_conhecidos[,novos_x's[,const]]])\n"
#~ "@DESCRIPTION=A função TREND estima valores futuros de um dado conjunto de "
#~ "dados utilizando a linha de ``menores quadrados'' que melhor se encaixa "
#~ "nos seus dados. @y's_conhecidos são os valores-y onde y=mx+b e "
#~ "@x's_conhecidos contêm os valores-x correspondentes. @novos_x's contêm os "
#~ "valores-x para os quais deseja estimar os valores-y. Se @const for FALSO, "
#~ "a linha será forçada a passar pela origem, isto é, b será zero.\n"
#~ "\n"
#~ "* Se @x's_conhecidos for omitido, é utilizada uma matriz {1, 2, 3, ...}.\n"
#~ "* Se @novos_x's for omitido, assume-se que sejam os mesmos que "
#~ "@x's_conhecidos.\n"
#~ "* Se @const for omitida, assume-se como VERDADEIRO.\n"
#~ "* Se @y's_conhecidos e @x's_conhecidos tiverem um número desigual de "
#~ "pontos de dados, TREND devolve o erro #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1, A2, ..., A5 contêm os números 11.4, "
#~ "17.3, 21.3, 25.9, e 40.1, e as células B1, B2, ... B5 23.2, 25.8, 29.9, "
#~ "33.5, e 42.7.  Então\n"
#~ "TREND(A1:A5,B1:B5) igual a {12.1, 15.7, 21.6, 26.7, 39.7}.\n"
#~ "\n"
#~ "@SEEALSO=LINEST"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=LOGEST\n"
#~ "@SYNTAX=LOGEST(known_y's[,known_x's,const,stat])\n"
#~ "@DESCRIPTION=LOGEST function applies the ``least squares'' method to fit "
#~ "an exponential curve of the form\n"
#~ "\n"
#~ "\ty = b * m{1}^x{1} * m{2}^x{2}... to your data.\n"
#~ "\n"
#~ "If @stat is TRUE, extra statistical information will be returned. Extra "
#~ "statistical information is written below the regression line coefficients "
#~ "in the result array.  Extra statistical information consists of four rows "
#~ "of data.  In the first row the standard error values for the coefficients "
#~ "m1, (m2, ...), b are represented.  The second row contains the square of "
#~ "R and the standard error for the y estimate.  The third row contains the "
#~ "F-observed value and the degrees of freedom.  The last row contains the "
#~ "regression sum of squares and the residual sum of squares.\n"
#~ "\n"
#~ "* If @known_x's is omitted, an array {1, 2, 3, ...} is used. LOGEST "
#~ "returns an array { m{n},m{n-1}, ...,m{1},b }.\n"
#~ "* If @known_y's and @known_x's have unequal number of data points, LOGEST "
#~ "returns #NUM! error.\n"
#~ "* If @const is FALSE, the line will be forced to go through (0,1),i.e., b "
#~ "will be one.  The default is TRUE.\n"
#~ "* The default of @stat is FALSE.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=GROWTH,TREND"
#~ msgstr ""
#~ "@FUNCTION=LOGEST\n"
#~ "@SYNTAX=LOGEST(y's_conhecidos[,x's_conhecidos,const,stat])\n"
#~ "@DESCRIPTION=A função LOGEST aplica o método de ``menores quadrados'' "
#~ "para encaixar uma curva exponencial na forma\n"
#~ "\n"
#~ "\ty = b * m{1}^x{1} * m{2}^x{2}... aos seus dados.\n"
#~ "\n"
#~ "Se @stat for VERDADEIRO, informação estatística adicional será devolvida. "
#~ "Informação estatística adicional é escrita abaixo dos coeficientes de "
#~ "linha da regressão na matriz de resultado. Informação estatística "
#~ "adicional consiste em quatro linhas de dados. Na primeira linha são "
#~ "apresentados os valores de erro padrão para os coeficientes m1, "
#~ "(m2, ...), b.  A segunda linha contém o quadrado de R e os erros padrão "
#~ "para a estimativa y. A terceira linha contém o valor observado-F e os "
#~ "graus de liberdade. A última linha contém a soma dos quadrados da "
#~ "regressão e a soma residual dos quadrados.\n"
#~ "\n"
#~ "* Se @x's_conhecidos for omitido, é utilizada uma matriz {1, 2, 3, ...}. "
#~ "LOGEST devolve uma matriz { m{n},m{n-1}, ...,m{1},b }.\n"
#~ "* Se @y's_conhecidos e @x's_conhecidos tiverem um número desigual de "
#~ "pontos de dados, LOGEST devolve o erro #NUM!.\n"
#~ "* Se @const for FALSO, a linha será forçada a passar por (0,1), isto é, b "
#~ "será um. O valor por omissão é VERDADEIRO.\n"
#~ "* O valor por omissão de @stat é FALSO.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=GROWTH,TREND"

#~ msgid ""
#~ "@FUNCTION=GROWTH\n"
#~ "@SYNTAX=GROWTH(known_y's[,known_x's,new_x's,const])\n"
#~ "@DESCRIPTION=GROWTH function applies the ``least squares'' method to fit "
#~ "an exponential curve to your data and predicts the exponential growth by "
#~ "using this curve. \n"
#~ "GROWTH returns an array having one column and a row for each data point "
#~ "in @new_x.\n"
#~ "\n"
#~ "* If @known_x's is omitted, an array {1, 2, 3, ...} is used.\n"
#~ "* If @new_x's is omitted, it is assumed to be the same as @known_x's.\n"
#~ "* If @known_y's and @known_x's have unequal number of data points, GROWTH "
#~ "returns #NUM! error.\n"
#~ "* If @const is FALSE, the line will be forced to go through the origin, i."
#~ "e., b will be zero. The default is TRUE.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=LOGEST,GROWTH,TREND"
#~ msgstr ""
#~ "@FUNCTION=GROWTH\n"
#~ "@SYNTAX=GROWTH(y's_conhecidos[,x's_conhecidos,novos_x's,const])\n"
#~ "@DESCRIPTION=A função GROWTH aplica o método ``menores quadrados'' para "
#~ "encaixar uma curva exponencial nos seus dados e prediz o crescimento "
#~ "exponencial utilizando esta curva.\n"
#~ "GROWTH devolve uma matriz com uma coluna e uma linha para cada ponto de "
#~ "dados em @novos_x.\n"
#~ "\n"
#~ "* Se @x's_conhecidos for omitido, é utilizada uma matriz {1, 2, 3, ...}.\n"
#~ "* Se @novos_x's for omitido, assume-se que sejam os mesmos que "
#~ "@x's_conhecidos.\n"
#~ "* Se @y's_conhecidos e @x's_conhecidos tiverem um número desigual de "
#~ "pontos de dados, GROWTH devolve o erro #NUM!.\n"
#~ "* Se @const for FALSO, a linha será forçada a passar pelo ponto de "
#~ "origem, isto é, b será zero. A omissão é VERDADE.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=LOGEST,GROWTH,TREND"

#~ msgid ""
#~ "@FUNCTION=FORECAST\n"
#~ "@SYNTAX=FORECAST(x,known_y's,known_x's)\n"
#~ "@DESCRIPTION=FORECAST function estimates a future value according to "
#~ "existing values using simple linear regression.  The estimated future "
#~ "value is a y-value for a given x-value (@x).\n"
#~ "\n"
#~ "* If @known_x or @known_y contains no data entries or different number of "
#~ "data entries, FORECAST returns #N/A error.\n"
#~ "* If the variance of the @known_x is zero, FORECAST returns #DIV/0 "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1, and the cells B1, B2, ... B5 23.2, 25.8, 29.9, "
#~ "33.5, and 42.7.  Then\n"
#~ "FORECAST(7,A1:A5,B1:B5) equals -10.859397661.\n"
#~ "\n"
#~ "@SEEALSO=INTERCEPT,TREND"
#~ msgstr ""
#~ "@FUNCTION=FORECAST\n"
#~ "@SYNTAX=FORECAST(y's_conhecidos,x's_conhecidos)\n"
#~ "@DESCRIPTION=A função FORECAST estima um valor futuro com base nos "
#~ "valores existentes utilizando uma regressão linear simples. O valor "
#~ "estimado futuro é um valor-y para um dado valor-x (@x).\n"
#~ "\n"
#~ "* Se @x_conhecidos ou @y_conhecidos não contiverem dados ou um número de "
#~ "dados for diferente, FORECAST devolve o erro #N/A!.\n"
#~ "* Se a variância dos @x_conhecidos for zero, FORECAST devolve o erro "
#~ "#DIV/0.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1, A2, ..., A5 contêm os números 11.4, "
#~ "17.3, 21.3, 25.9, e 40.1, e as células B1, B2, ... B5 23.2, 25.8, 29.9, "
#~ "33.5, e 42.7.  Então\n"
#~ "FORECAST(7,A1:A5,B1:B5) igual a -10.859397661.\n"
#~ "\n"
#~ "@SEEALSO=INTERCEPT,TREND"

#~ msgid ""
#~ "@FUNCTION=INTERCEPT\n"
#~ "@SYNTAX=INTERCEPT(known_y's,known_x's)\n"
#~ "@DESCRIPTION=INTERCEPT function calculates the point where the linear "
#~ "regression line intersects the y-axis.\n"
#~ "\n"
#~ "* If @known_x or @known_y contains no data entries or different number of "
#~ "data entries, INTERCEPT returns #N/A error.\n"
#~ "* If the variance of the @known_x is zero, INTERCEPT returns #DIV/0 "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1, and the cells B1, B2, ... B5 23.2, 25.8, 29.9, "
#~ "33.5, and 42.7.  Then\n"
#~ "INTERCEPT(A1:A5,B1:B5) equals -20.785117212.\n"
#~ "\n"
#~ "@SEEALSO=FORECAST,TREND"
#~ msgstr ""
#~ "@FUNCTION=INTERCEPT\n"
#~ "@SYNTAX=INTERCEPT(y_conhecido,x_conhecido)\n"
#~ "@DESCRIPTION=A função INTERCEPT calcula o ponto onde a linha de regressão "
#~ "linear intercepta o eixo-y.\n"
#~ "\n"
#~ "* Se @x_conhecido ou @y_conhecido não contêm dados ou o número de dados é "
#~ "diferente, INTERCEPT devolve o erro #N/A!.\n"
#~ "* Se a variância do @x_conhecido for zero, INTERCEPT devolve o erro "
#~ "#DIV/0.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1, A2, ..., A5 contêm os números 11.4, "
#~ "17.3, 21.3, 25.9, e 40.1, e as células B1, B2, ... B5 23.2, 25.8, 29.9, "
#~ "33.5, e 42.7.  Então\n"
#~ "INTERCEPT(A1:A5,B1:B5) igual a -20.785117212.\n"
#~ "\n"
#~ "@SEEALSO=FORECAST,TREND"

#~ msgid ""
#~ "@FUNCTION=SLOPE\n"
#~ "@SYNTAX=SLOPE(known_y's,known_x's)\n"
#~ "@DESCRIPTION=SLOPE returns the slope of the linear regression line.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1, and the cells B1, B2, ... B5 23.2, 25.8, 29.9, "
#~ "33.5, and 42.7.  Then\n"
#~ "SLOPE(A1:A5,B1:B5) equals 1.417959936.\n"
#~ "\n"
#~ "@SEEALSO=STDEV,STDEVPA"
#~ msgstr ""
#~ "@FUNCTION=SLOPE\n"
#~ "@SYNTAX=SLOPE(y's_conhecidos,x's_conhecidos)\n"
#~ "@DESCRIPTION=SLOPE devolve a inclinação da linha de regressão linear.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1, A2, ..., A5 contêm os números 11.4, "
#~ "17.3, 21.3, 25.9, e 40.1, e as células B1, B2, ... B5 23.2, 25.8, 29.9, "
#~ "33.5, e 42.7.  Então\n"
#~ "SLOPE(A1:A5,B1:B5) igual a 1.417959936.\n"
#~ "\n"
#~ "@SEEALSO=STDEV,STDEVPA"

#~ msgid ""
#~ "@FUNCTION=SUBTOTAL\n"
#~ "@SYNTAX=SUBTOTAL(function_nbr,ref1,ref2,...)\n"
#~ "@DESCRIPTION=SUBTOTAL function returns a subtotal of given list of "
#~ "arguments. @function_nbr is the number that specifies which function to "
#~ "use in calculating the subtotal.\n"
#~ "\n"
#~ "The following functions are available:\n"
#~ "\n"
#~ "\t1   AVERAGE\n"
#~ "\t2   COUNT\n"
#~ "\t3   COUNTA\n"
#~ "\t4   MAX\n"
#~ "\t5   MIN\n"
#~ "\t6   PRODUCT\n"
#~ "\t7   STDEV\n"
#~ "\t8   STDEVP\n"
#~ "\t9   SUM\n"
#~ "\t10   VAR\n"
#~ "\t11   VARP\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 23, 27, 28, "
#~ "33, and 39.  Then\n"
#~ "SUBTOTAL(1,A1:A5) equals 30.\n"
#~ "SUBTOTAL(6,A1:A5) equals 22378356.\n"
#~ "SUBTOTAL(7,A1:A5) equals 6.164414003.\n"
#~ "SUBTOTAL(9,A1:A5) equals 150.\n"
#~ "SUBTOTAL(11,A1:A5) equals 30.4.\n"
#~ "\n"
#~ "@SEEALSO=COUNT,SUM"
#~ msgstr ""
#~ "@FUNCTION=SUBTOTAL\n"
#~ "@SYNTAX=SUBTOTAL(num_função,ref1,ref2,...)\n"
#~ "@DESCRIPTION=A função SUBTOTAL devolve um subtotal da lista de argumentos "
#~ "indicada. @num_função é o número que especifica que função utilizar ao "
#~ "calcular o subtotal.\n"
#~ "\n"
#~ "Estão disponíveis as seguintes funções:\n"
#~ "\t1   AVERAGE\n"
#~ "\t2   COUNT\n"
#~ "\t3   COUNTA\n"
#~ "\t4   MAX\n"
#~ "\t5   MIN\n"
#~ "\t6   PRODUCT\n"
#~ "\t7   STDEV\n"
#~ "\t8   STDEVP\n"
#~ "\t9   SUM\n"
#~ "\t10   VAR\n"
#~ "\t11   VARP\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1, A2, ..., A5 contêm os números 23, 27, "
#~ "28, 33, e 39.  Então\n"
#~ "SUBTOTAL(1,A1:A5) igual a 30.\n"
#~ "SUBTOTAL(6,A1:A5) igual a 22378356.\n"
#~ "SUBTOTAL(7,A1:A5) igual a 6.164414003.\n"
#~ "SUBTOTAL(9,A1:A5) igual a 150.\n"
#~ "SUBTOTAL(11,A1:A5) igual a 30.4.\n"
#~ "\n"
#~ "@SEEALSO=COUNT,SUM"

#~ msgid ""
#~ "@FUNCTION=CRONBACH\n"
#~ "@SYNTAX=CRONBACH(ref1,ref2,...)\n"
#~ "@DESCRIPTION=CRONBACH returns Cronbach's alpha for the given cases.\n"
#~ "@ref1 is a data set, @ref2 the second data set, etc..\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=CRONBACH\n"
#~ "@SYNTAX=CRONBACH(ref1,ref2,...)\n"
#~ "@DESCRIPTION=CRONBACH devolve o alfa Cronbach para os casos "
#~ "especificados.\n"
#~ "@ref1 é um conjunto de dados, @ref2 o segundo conjunto de dados, etc..\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=GEOMDIST\n"
#~ "@SYNTAX=GEOMDIST(k,p,cum)\n"
#~ "@DESCRIPTION=GEOMDIST returns the probability p(k) of obtaining @k from a "
#~ "geometric distribution with probability parameter @p.\n"
#~ "\n"
#~ "* If @k < 0 GEOMDIST returns #NUM! error.\n"
#~ "* If @p < 0 or @p > 1 GEOMDIST returns #NUM! error.\n"
#~ "* If @cum != TRUE and @cum != FALSE GEOMDIST returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "GEOMDIST(2,10.4,TRUE).\n"
#~ "\n"
#~ "@SEEALSO=RANDGEOM"
#~ msgstr ""
#~ "@FUNCTION=GEOMDIST\n"
#~ "@SYNTAX=GEOMDIST(k,p,cum)\n"
#~ "@DESCRIPTION=A função GEOMDIST devolve a probabilidade p(k) de obter @k "
#~ "de uma distribuição geométrica com o parâmetro de probabilidade @p.\n"
#~ "\n"
#~ "* Se @k < 0 GEOMDIST devolve o erro #NUM!.\n"
#~ "* Se @p < 0 ou @p > 1, GEOMDIST devolve o erro #NUM!.\n"
#~ "* Se @cum != VERDADE e @cum != FALSO GEOMDIST devolve o erro #NUM!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "GEOMDIST(2,10.4,TRUE).\n"
#~ "\n"
#~ "@SEEALSO=RANDGEOM"

#~ msgid ""
#~ "@FUNCTION=LOGISTIC\n"
#~ "@SYNTAX=LOGISTIC(x,a)\n"
#~ "@DESCRIPTION=LOGISTIC returns the probability density p(x) at @x for a "
#~ "logistic distribution with scale parameter @a.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LOGISTIC(0.4,1).\n"
#~ "\n"
#~ "@SEEALSO=RANDLOGISTIC"
#~ msgstr ""
#~ "@FUNCTION=LOGISTIC\n"
#~ "@SYNTAX=LOGISTIC(x,a)\n"
#~ "@DESCRIPTION=LOGISTIC devolve a probabilidade de densidade p(x) em @x "
#~ "para uma distribuição logística com o parâmetro de escala @a.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LOGISTIC(0.4,1).\n"
#~ "\n"
#~ "@SEEALSO=RANDLOGISTIC"

#~ msgid ""
#~ "@FUNCTION=PARETO\n"
#~ "@SYNTAX=PARETO(x,a,b)\n"
#~ "@DESCRIPTION=PARETO returns the probability density p(x) at @x for a "
#~ "Pareto distribution with exponent @a and scale @b.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "PARETO(0.6,1,2).\n"
#~ "\n"
#~ "@SEEALSO=RANDPARETO"
#~ msgstr ""
#~ "@FUNCTION=PARETO\n"
#~ "@SYNTAX=PARETO(x,a,b)\n"
#~ "@DESCRIPTION=PARETO devolve a probabilidade de densidade p(x) em @x para "
#~ "uma distribuição de Pareto com expoente @a e escala @b.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "PARETO(0.6,1,2).\n"
#~ "\n"
#~ "@SEEALSO=RANDPARETO"

#~ msgid ""
#~ "@FUNCTION=RAYLEIGH\n"
#~ "@SYNTAX=RAYLEIGH(x,sigma)\n"
#~ "@DESCRIPTION=RAYLEIGH returns the probability density p(x) at @x for a "
#~ "Rayleigh distribution with scale parameter @sigma.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RAYLEIGH(0.4,1).\n"
#~ "\n"
#~ "@SEEALSO=RANDRAYLEIGH"
#~ msgstr ""
#~ "@FUNCTION=RAYLEIGH\n"
#~ "@SYNTAX=RAYLEIGH(x,sigma)\n"
#~ "@DESCRIPTION=RAYLEIGH devolve a probabilidade de densidade p(x) em @x "
#~ "para uma distribuição de Rayleigh com parâmetro de escala @sigma.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RAYLEIGH(0.4,1).\n"
#~ "\n"
#~ "@SEEALSO=RANDRAYLEIGH"

#~ msgid ""
#~ "@FUNCTION=RAYLEIGHTAIL\n"
#~ "@SYNTAX=RAYLEIGHTAIL(x,a,sigma)\n"
#~ "@DESCRIPTION=RAYLEIGHTAIL returns the probability density p(x) at @x for "
#~ "a Rayleigh tail distribution with scale parameter @sigma and lower limit "
#~ "@a.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RAYLEIGHTAIL(0.6,0.3,1).\n"
#~ "\n"
#~ "@SEEALSO=RANDRAYLEIGHTAIL"
#~ msgstr ""
#~ "@FUNCTION=RAYLEIGHTAIL\n"
#~ "@SYNTAX=RAYLEIGHTAIL(x,a,sigma)\n"
#~ "@DESCRIPTION=RAYLEIGHTAIL devolve a probabilidade de densidade p(x) em @x "
#~ "para uma distribuição de cauda de Rayleigh com parâmetro de escala @sigma "
#~ "e limite inferior @a.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RAYLEIGHTAIL(0.6,0.3,1).\n"
#~ "\n"
#~ "@SEEALSO=RANDRAYLEIGHTAIL"

#~ msgid ""
#~ "@FUNCTION=LAPLACE\n"
#~ "@SYNTAX=LAPLACE(x,a)\n"
#~ "@DESCRIPTION=LAPLACE returns the probability density p(x) at @x for "
#~ "Laplace distribution with mean @a. \n"
#~ "@EXAMPLES=\n"
#~ "LAPLACE(0.4,1).\n"
#~ "\n"
#~ "@SEEALSO=RANDLAPLACE"
#~ msgstr ""
#~ "@FUNCTION=LAPLACE\n"
#~ "@SYNTAX=LAPLACE(x,a)\n"
#~ "@DESCRIPTION=LAPLACE devolve a probabilidade de densidade p(x) em @x para "
#~ "uma distribuição de Laplace com média @a. \n"
#~ "@EXAMPLES=\n"
#~ "LAPLACE(0.4,1).\n"
#~ "\n"
#~ "@SEEALSO=RANDLAPLACE"

#~ msgid ""
#~ "@FUNCTION=CHAR\n"
#~ "@SYNTAX=CHAR(x)\n"
#~ "@DESCRIPTION=CHAR returns the ASCII character represented by the number "
#~ "@x.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CHAR(65) equals A.\n"
#~ "\n"
#~ "@SEEALSO=CODE"
#~ msgstr ""
#~ "@FUNCTION=CHAR\n"
#~ "@SYNTAX=CHAR(x)\n"
#~ "@DESCRIPTION=CHAR devolve o caracter ASCII representado pelo número @x.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CHAR(65) igual a A.\n"
#~ "\n"
#~ "@SEEALSO=CODE"

#~ msgid ""
#~ "@FUNCTION=UNICHAR\n"
#~ "@SYNTAX=UNICHAR(x)\n"
#~ "@DESCRIPTION=UNICHAR returns the Unicode character represented by the "
#~ "number @x.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "UNICHAR(65) equals A.\n"
#~ "UNICHAR(960) equals a small Greek pi.\n"
#~ "\n"
#~ "@SEEALSO=CHAR,UNICODE,CODE"
#~ msgstr ""
#~ "@FUNCTION=UNICHAR\n"
#~ "@SYNTAX=UNICHAR(x)\n"
#~ "@DESCRIPTION=UNICHAR devolve o caracter Unicode representado pelo número "
#~ "@x.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "UNICHAR(65) igual a A.\n"
#~ "CHAR(960) igual a um pequeno pi grego.\n"
#~ "\n"
#~ "@SEEALSO=CHAR,UNICODE,CODE"

#~ msgid ""
#~ "@FUNCTION=CODE\n"
#~ "@SYNTAX=CODE(char)\n"
#~ "@DESCRIPTION=CODE returns the ASCII number for the character @char.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CODE(\"A\") equals 65.\n"
#~ "\n"
#~ "@SEEALSO=CHAR"
#~ msgstr ""
#~ "@FUNCTION=CODE\n"
#~ "@SYNTAX=CODE(char)\n"
#~ "@DESCRIPTION=CODE devolve o número ASCII do caracter @char.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CODE(\"A\") igual a 65.\n"
#~ "\n"
#~ "@SEEALSO=CHAR"

#~ msgid ""
#~ "@FUNCTION=UNICODE\n"
#~ "@SYNTAX=UNICODE(char)\n"
#~ "@DESCRIPTION=UNICODE returns the Unicode number for the character @char.\n"
#~ "\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "UNICODE(\"A\") equals 65.\n"
#~ "\n"
#~ "@SEEALSO=UNICHAR,CODE,CHAR"
#~ msgstr ""
#~ "@FUNCTION=UNICODE\n"
#~ "@SYNTAX=UNICODE(char)\n"
#~ "@DESCRIPTION=UNICODE devolve o número Unicode do caracter @char.\n"
#~ "\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "UNICODE(\"A\") igual a 65.\n"
#~ "\n"
#~ "@SEEALSO=UNICHAR,CODE,CHAR"

#~ msgid ""
#~ "@FUNCTION=EXACT\n"
#~ "@SYNTAX=EXACT(string1, string2)\n"
#~ "@DESCRIPTION=EXACT returns true if @string1 is exactly equal to @string2 "
#~ "(this routine is case sensitive).\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "EXACT(\"key\",\"key\") equals TRUE.\n"
#~ "EXACT(\"key\",\"Key\") equals FALSE.\n"
#~ "\n"
#~ "@SEEALSO=LEN, SEARCH, DELTA"
#~ msgstr ""
#~ "@FUNCTION=EXACT\n"
#~ "@SYNTAX=EXACT(expressão1, expressão2)\n"
#~ "@DESCRIPTION=EXACT devolve verdade se @expressão1 for exactamente igual a "
#~ "@expressão2 (esta rotina é sensível à capitalização).\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "EXACT(\"chave\",\"chave\") igual a VERDADE.\n"
#~ "EXACT(\"chave\",\"Chave\") igual a FALSO.\n"
#~ "\n"
#~ "@SEEALSO=LEN, SEARCH, DELTA"

#~ msgid ""
#~ "@FUNCTION=LEN\n"
#~ "@SYNTAX=LEN(string)\n"
#~ "@DESCRIPTION=LEN returns the length in characters of the string @string.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LEN(\"Helsinki\") equals 8.\n"
#~ "\n"
#~ "@SEEALSO=CHAR, CODE, LENB"
#~ msgstr ""
#~ "@FUNCTION=LEN\n"
#~ "@SYNTAX=LEN(expressão)\n"
#~ "@DESCRIPTION=LEN devolve o comprimento em caracteres da expressão "
#~ "@expressão.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LEN(\"Lisboa\") igual a 6.\n"
#~ "\n"
#~ "@SEEALSO=CHAR, CODE, LENB"

#~ msgid ""
#~ "@FUNCTION=LEFT\n"
#~ "@SYNTAX=LEFT(text[,num_chars])\n"
#~ "@DESCRIPTION=LEFT returns the leftmost @num_chars characters or the left "
#~ "character if @num_chars is not specified.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LEFT(\"Directory\",3) equals \"Dir\".\n"
#~ "\n"
#~ "@SEEALSO=MID, RIGHT"
#~ msgstr ""
#~ "@FUNCTION=LEFT\n"
#~ "@SYNTAX=LEFT(texto[,num_chars])\n"
#~ "@DESCRIPTION=LEFT devolve o número de caracteres @num_chars mais à "
#~ "esquerda ou o caracter à esquerda se @num_chars não for especificado.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LEFT(\"Directório\",3) igual a \"Dir\".\n"
#~ "\n"
#~ "@SEEALSO=MID, RIGHT"

#~ msgid ""
#~ "@FUNCTION=LOWER\n"
#~ "@SYNTAX=LOWER(text)\n"
#~ "@DESCRIPTION=LOWER returns a lower-case version of the string in @text.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LOWER(\"J. F. Kennedy\") equals \"j. f. kennedy\".\n"
#~ "\n"
#~ "@SEEALSO=UPPER"
#~ msgstr ""
#~ "@FUNCTION=LOWER\n"
#~ "@SYNTAX=LOWER(texto)\n"
#~ "@DESCRIPTION=LOWER devolve uma versão em minúsculas da expressão em "
#~ "@texto.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LOWER(\"J. F. Kennedy\") igual a \"j. f. kennedy\".\n"
#~ "\n"
#~ "@SEEALSO=UPPER"

#~ msgid ""
#~ "@FUNCTION=MID\n"
#~ "@SYNTAX=MID(string, position, length)\n"
#~ "@DESCRIPTION=MID returns a substring from @string starting at @position "
#~ "for @length characters.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "MID(\"testing\",2,3) equals \"est\".\n"
#~ "\n"
#~ "@SEEALSO=LEFT, RIGHT"
#~ msgstr ""
#~ "@FUNCTION=MID\n"
#~ "@SYNTAX=MID(expressão, posição, comprimento)\n"
#~ "@DESCRIPTION=MID devolve a sub-expressão de @expressão a começar na "
#~ "@posição e com @comprimento de caracteres.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "MID(\"testar\",2,3) igual a \"est\".\n"
#~ "\n"
#~ "@SEEALSO=LEFT, RIGHT"

#~ msgid ""
#~ "@FUNCTION=RIGHT\n"
#~ "@SYNTAX=RIGHT(text[,num_chars])\n"
#~ "@DESCRIPTION=RIGHT returns the rightmost @num_chars characters or the "
#~ "right character if @num_chars is not specified.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RIGHT(\"end\") equals \"d\".\n"
#~ "RIGHT(\"end\",2) equals \"nd\".\n"
#~ "\n"
#~ "@SEEALSO=MID, LEFT"
#~ msgstr ""
#~ "@FUNCTION=RIGHT\n"
#~ "@SYNTAX=RIGHT(texto[,num_chars])\n"
#~ "@DESCRIPTION=RIGHT devolve o @num_chars caracteres mais à direita ou o "
#~ "caracter da direita se @num_chars não for especificado.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RIGHT(\"fim\") igual a \"m\".\n"
#~ "RIGHT(\"fim\",2) igual a \"im\".\n"
#~ "\n"
#~ "@SEEALSO=MID, LEFT"

#~ msgid ""
#~ "@FUNCTION=UPPER\n"
#~ "@SYNTAX=UPPER(text)\n"
#~ "@DESCRIPTION=UPPER returns a upper-case version of the string in @text.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "UPPER(\"cancelled\") equals \"CANCELLED\".\n"
#~ "\n"
#~ "@SEEALSO=LOWER"
#~ msgstr ""
#~ "@FUNCTION=UPPER\n"
#~ "@SYNTAX=UPPER(texto)\n"
#~ "@DESCRIPTION=UPPER devolve a versão em maiúsculas da expressão em "
#~ "@texto.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "UPPER(\"cancelado\") igual a \"CANCELADO\".\n"
#~ "\n"
#~ "@SEEALSO=LOWER"

#~ msgid ""
#~ "@FUNCTION=CONCATENATE\n"
#~ "@SYNTAX=CONCATENATE(string1[,string2...])\n"
#~ "@DESCRIPTION=CONCATENATE returns the string obtained by concatenation of "
#~ "the given strings.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CONCATENATE(\"aa\",\"bb\") equals \"aabb\".\n"
#~ "\n"
#~ "@SEEALSO=LEFT, MID, RIGHT"
#~ msgstr ""
#~ "@FUNCTION=CONCATENATE\n"
#~ "@SYNTAX=CONCATENATE(expressão1[,expressão2...])\n"
#~ "@DESCRIPTION=CONCATENATE devolve a expressão resultante da concatenação "
#~ "das expressões indicadas.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CONCATENATE(\"aa\",\"bb\") igual a \"aabb\".\n"
#~ "\n"
#~ "@SEEALSO=LEFT, MID, RIGHT"

#~ msgid ""
#~ "@FUNCTION=REPT\n"
#~ "@SYNTAX=REPT(string,num)\n"
#~ "@DESCRIPTION=REPT returns @num repetitions of @string.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ " \n"
#~ "@EXAMPLES=\n"
#~ "REPT(\".\",3) equals \"...\".\n"
#~ "\n"
#~ "@SEEALSO=CONCATENATE"
#~ msgstr ""
#~ "@FUNCTION=REPT\n"
#~ "@SYNTAX=REPT(expressão,num)\n"
#~ "@DESCRIPTION=REPT devolve @num repetições da @expressão.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "REPT(\".\",3) igual a \"...\".\n"
#~ "\n"
#~ "@SEEALSO=CONCATENATE"

#~ msgid ""
#~ "@FUNCTION=CLEAN\n"
#~ "@SYNTAX=CLEAN(string)\n"
#~ "@DESCRIPTION=CLEAN removes any non-printable characters from @string.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CLEAN(\"one\"\\&char(7)) equals \"one\".\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=CLEAN\n"
#~ "@SYNTAX=CLEAN(expressão)\n"
#~ "@DESCRIPTION=CLEAN remove quaisquer caracteres não-imprimíveis de uma "
#~ "@expressão.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CLEAN(\"um\"\\&char(7)) igual a \"um\".\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=FIND\n"
#~ "@SYNTAX=FIND(string1,string2[,start])\n"
#~ "@DESCRIPTION=FIND returns position of @string1 in @string2 (case-"
#~ "sensitive), searching only from character @start onwards (assuming 1 if "
#~ "omitted).\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FIND(\"ac\",\"Jack\") equals 2.\n"
#~ "\n"
#~ "@SEEALSO=EXACT, LEN, MID, SEARCH"
#~ msgstr ""
#~ "@FUNCTION=FIND\n"
#~ "@SYNTAX=FIND(expressão1,expressão2[,início])\n"
#~ "@DESCRIPTION=FIND devolve a posição de @expressão1 em @expressão2 "
#~ "(sensível à capitalização), procurando apenas a partir do caracter "
#~ "@início (assumindo 1 se omitido).\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FIND(\"ac\",\"Jack\") igual a 2.\n"
#~ "\n"
#~ "@SEEALSO=EXACT, LEN, MID, SEARCH"

#~ msgid ""
#~ "@FUNCTION=FIXED\n"
#~ "@SYNTAX=FIXED(num,[decimals, no_commas])\n"
#~ "@DESCRIPTION=FIXED returns @num as a formatted string with @decimals "
#~ "numbers after the decimal point, omitting commas if requested by "
#~ "@no_commas.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FIXED(1234.567,2) equals \"1,234.57\".\n"
#~ "\n"
#~ "@SEEALSO=TEXT, VALUE, DOLLAR"
#~ msgstr ""
#~ "@FUNCTION=FIXED\n"
#~ "@SYNTAX=FIXED(num,[decimais, sem_vírgulas])\n"
#~ "@DESCRIPTION=FIXED devolve @num como uma expressão formatada com "
#~ "@decimais números após o separador decimal, omitindo as vírgulas se "
#~ "pedido pelo @sem_vírgulas.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FIXED(1234.567,2) igual a \"1,234.57\".\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=PROPER\n"
#~ "@SYNTAX=PROPER(string)\n"
#~ "@DESCRIPTION=PROPER returns @string with initial of each word "
#~ "capitalised.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "PROPER(\"j. f. kennedy\") equals \"J. F. Kennedy\".\n"
#~ "\n"
#~ "@SEEALSO=LOWER, UPPER"
#~ msgstr ""
#~ "@FUNCTION=PROPER\n"
#~ "@SYNTAX=PROPER(expressão)\n"
#~ "@DESCRIPTION=PROPER devolve @expressão com a primeira letra de cada "
#~ "palavra em maiúsculas.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "PROPER(\"j. f. kennedy\") igual a \"J. F. Kennedy\".\n"
#~ "\n"
#~ "@SEEALSO=LOWER, UPPER"

#~ msgid ""
#~ "@FUNCTION=REPLACE\n"
#~ "@SYNTAX=REPLACE(old,start,num,new)\n"
#~ "@DESCRIPTION=REPLACE returns @old with @new replacing @num characters "
#~ "from @start.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "REPLACE(\"testing\",2,3,\"*****\") equals \"t*****ing\".\n"
#~ "\n"
#~ "@SEEALSO=MID, SEARCH, SUBSTITUTE, TRIM"
#~ msgstr ""
#~ "@FUNCTION=REPLACE\n"
#~ "@SYNTAX=REPLACE(velha,início,num,nova)\n"
#~ "@DESCRIPTION=REPLACE substitui @velha por @nova substituindo @num "
#~ "caracteres a partir do @início.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "REPLACE(\"testar\",2,3,\"*****\") igual a \"t*****ar\".\n"
#~ "\n"
#~ "@SEEALSO=MID, SEARCH, SUBSTITUTE, TRIM"

#~ msgid ""
#~ "@FUNCTION=T\n"
#~ "@SYNTAX=T(value)\n"
#~ "@DESCRIPTION=T returns @value if and only if it is text, otherwise a "
#~ "blank string.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "T(\"text\") equals \"text\".\n"
#~ "T(64) returns an empty cell.\n"
#~ "\n"
#~ "@SEEALSO=CELL, N, VALUE"
#~ msgstr ""
#~ "@FUNCTION=T\n"
#~ "@SYNTAX=T(valor)\n"
#~ "@DESCRIPTION=T devolve @valor se e apenas se for texto, caso contrário "
#~ "devolve uma expressão vazia.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "T(\"text\") igual a \"text\".\n"
#~ "T(64) devolve uma célula vazia.\n"
#~ "\n"
#~ "@SEEALSO=CELL, N, VALUE"

#~ msgid ""
#~ "@FUNCTION=TEXT\n"
#~ "@SYNTAX=TEXT(value,format_text)\n"
#~ "@DESCRIPTION=TEXT returns @value as a string with the specified format.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TEXT(3.223,\"$0.00\") equals \"$3.22\".\n"
#~ "TEXT(date(1999,4,15),\"mmmm, dd, yy\") equals \"April, 15, 99\".\n"
#~ "\n"
#~ "@SEEALSO=DOLLAR, FIXED, VALUE"
#~ msgstr ""
#~ "@FUNCTION=TEXT\n"
#~ "@SYNTAX=TEXT(valor,formato_texto)\n"
#~ "@DESCRIPTION=TEXT devolve @valor como uma expressão com o formato "
#~ "especificado.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TEXT(3.223,\"$0.00\") igual a \"$3.22\".\n"
#~ "TEXT(date(1999,4,15),\"mmmm, dd, yy\") igual a \"Abril, 15, 99\".\n"
#~ "\n"
#~ "@SEEALSO=DOLLAR"

#~ msgid ""
#~ "@FUNCTION=TRIM\n"
#~ "@SYNTAX=TRIM(text)\n"
#~ "@DESCRIPTION=TRIM returns @text with only single spaces between words.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TRIM(\"  a bbb  cc\") equals \"a bbb cc\".\n"
#~ "\n"
#~ "@SEEALSO=CLEAN, MID, REPLACE, SUBSTITUTE"
#~ msgstr ""
#~ "@FUNCTION=TRIM\n"
#~ "@SYNTAX=TRIM(texto)\n"
#~ "@DESCRIPTION=TRIM devolve @texto com apenas um espaço entre as palavras.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TRIM(\"  a bbb  cc\") igual a \"a bbb cc\".\n"
#~ "\n"
#~ "@SEEALSO=CLEAN, MID, REPLACE, SUBSTITUTE"

#~ msgid ""
#~ "@FUNCTION=VALUE\n"
#~ "@SYNTAX=VALUE(text)\n"
#~ "@DESCRIPTION=VALUE returns numeric value of @text.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "VALUE(\"$1,000\") equals 1000.\n"
#~ "\n"
#~ "@SEEALSO=DOLLAR, FIXED, TEXT"
#~ msgstr ""
#~ "@FUNCTION=VALUE\n"
#~ "@SYNTAX=VALUE(texto)\n"
#~ "@DESCRIPTION=VALUE devolve o valor numérico de @texto.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "VALUE(\"$1,000\") igual a 1000.\n"
#~ "\n"
#~ "@SEEALSO=DOLLAR, FIXED, TEXT"

#~ msgid ""
#~ "@FUNCTION=SUBSTITUTE\n"
#~ "@SYNTAX=SUBSTITUTE(text, old, new [,num])\n"
#~ "@DESCRIPTION=SUBSTITUTE replaces @old with @new in @text.  Substitutions "
#~ "are only applied to instance @num of @old in @text, otherwise every one "
#~ "is changed.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "SUBSTITUTE(\"testing\",\"test\",\"wait\") equals \"waiting\".\n"
#~ "\n"
#~ "@SEEALSO=REPLACE, TRIM"
#~ msgstr ""
#~ "@FUNCTION=SUBSTITUTE\n"
#~ "@SYNTAX=SUBSTITUTE(texto, velho, novo [,num])\n"
#~ "@DESCRIPTION=SUBSTITUTE substitui @velho por @novo no @texto. As "
#~ "substituições são apenas aplicadas à instância @num de @velho em @texto, "
#~ "caso contrário todas serão modificadas.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "SUBSTITUTE(\"testar\",\"test\",\"esper\") igual a \"esperar\".\n"
#~ "\n"
#~ "@SEEALSO=REPLACE, TRIM"

#~ msgid ""
#~ "@FUNCTION=DOLLAR\n"
#~ "@SYNTAX=DOLLAR(num[,decimals])\n"
#~ "@DESCRIPTION=DOLLAR returns @num formatted as currency.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DOLLAR(12345) equals \"$12,345.00\".\n"
#~ "\n"
#~ "@SEEALSO=FIXED, TEXT, VALUE"
#~ msgstr ""
#~ "@FUNCTION=DOLLAR\n"
#~ "@SYNTAX=DOLLAR(num[,decimais])\n"
#~ "@DESCRIPTION=DOLLAR devolve @num formatado como moeda.\n"
#~ "\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DOLLAR(12345) igual a \"$12,345.00\".\n"
#~ "\n"
#~ "@SEEALSO=FIXED, TEXT, VALUE"

#~ msgid ""
#~ "@FUNCTION=SEARCH\n"
#~ "@SYNTAX=SEARCH(search_string,text[,start_num])\n"
#~ "@DESCRIPTION=SEARCH returns the location of the @search_ string within "
#~ "@text. The search starts  with the @start_num character of text @text.  "
#~ "If @start_num is omitted, it is assumed to be one.  The search is not "
#~ "case sensitive.\n"
#~ "\n"
#~ "@search_string can contain wildcard characters (*) and question marks "
#~ "(?). A question mark matches any character and a wildcard matches any "
#~ "string including the empty string.  If you want the actual wildcard or "
#~ "question mark to be found, use tilde (~) before the character.\n"
#~ "\n"
#~ "* If @search_string is not found, SEARCH returns #VALUE! error.\n"
#~ "* If @start_num is less than one or it is greater than the length of "
#~ "@text, SEARCH returns #VALUE! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "SEARCH(\"c\",\"Cancel\") equals 1.\n"
#~ "SEARCH(\"c\",\"Cancel\",2) equals 4.\n"
#~ "\n"
#~ "@SEEALSO=FIND"
#~ msgstr ""
#~ "@FUNCTION=SEARCH\n"
#~ "@SYNTAX=SEARCH(texto,expressão[,num_início])\n"
#~ "@DESCRIPTION=SEARCH devolve a localização do @texto dentro de @expressão. "
#~ "A procura começa no caracter @num_início na expressão @expressão. Se "
#~ "@num_início for omitido, assume-se que seja um.  A procura não é sensível "
#~ "à capitalização.\n"
#~ "\n"
#~ "@texto pode conter caracteres 'wildcard' (*) e pontos de interrogação (?) "
#~ "para controlar a procura. Um ponto de interrogação coincide com qualquer "
#~ "caracter e 'wildcard' coincide com qualquer expressão incluindo "
#~ "expressões vazias. Se desejar que o 'wildcard' ou ponto de interrogação "
#~ "sejam procurados, utilize um til (~) antes do caracter.\n"
#~ "\n"
#~ "* Se @texto não for encontrado, SEARCH devolve o erro #VALOR!.\n"
#~ "* Se @num_início for menor que um ou maior que o tamanho da @expressão, "
#~ "SEARCH devolve o erro #VALOR!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "SEARCH(\"c\",\"Cancelar\") igual a 1.\n"
#~ "SEARCH(\"c\",\"Cancelar\",2) igual a 4.\n"
#~ "\n"
#~ "@SEEALSO=FIND"

#~ msgid ""
#~ "@FUNCTION=EXECSQL\n"
#~ "@SYNTAX=EXECSQL(dsn,username,password,sql)\n"
#~ "@DESCRIPTION=The EXECSQL function lets you execute a command in a "
#~ "database server, and show the results returned in current sheet. It uses "
#~ "libgda as the means for accessing the databases.\n"
#~ "For using it, you need first to set up a libgda data source.\n"
#~ "@EXAMPLES=\n"
#~ "To get all the data from the table \"Customers\" present in the "
#~ "\"mydatasource\" GDA data source, you would use:\n"
#~ "EXECSQL(\"mydatasource\",\"username\",\"password\",\"SELECT * FROM "
#~ "customers\")\n"
#~ "@SEEALSO=READDBTABLE"
#~ msgstr ""
#~ "@FUNCTION=EXECSQL\n"
#~ "@SYNTAX=EXECSQL(dns, utilizador, senha, sql)\n"
#~ "@DESCRIPTION=A função EXECSQL permite-lhe executar um comando sobre um "
#~ "servidor de base de dados, e mostrar o resultado devolvido na folha "
#~ "actual. Utiliza a libgda como forma de aceder à base de dados.\n"
#~ "Para a utilizar, tem primeiro de definir uma fonte de dados libgda.\n"
#~ "@EXAMPLES=\n"
#~ "Para obter todos os dados da tabela \"Clientes\" presente na fonte de "
#~ "dados GDA \"minhabasedados\", utilizaria:\n"
#~ "EXECSQL(\"minhabasedados\",\"utilizador\",\"senha\",\"SELECT * FROM "
#~ "clientes\")\n"
#~ "@SEEALSO=READDBTABLE"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=READDBTABLE\n"
#~ "@SYNTAX=READDBTABLE(dsn,username,password,table)\n"
#~ "@DESCRIPTION=The READDBTABLE function lets you get the contents of a "
#~ "table, as stored in a database. For using it, you need first to set up a "
#~ "libgda data source.\n"
#~ "Note that this function returns all the rows in the given table. If you "
#~ "want to get data from more than one table or want a more precise "
#~ "selection (conditions), use the EXECSQL function.\n"
#~ "@EXAMPLES=\n"
#~ "To get all the data from the table \"Customers\" present in the "
#~ "\"mydatasource\" GDA data source, you would use:\n"
#~ "READDBTABLE(\"mydatasource\",\"username\",\"password\",\"customers\")\n"
#~ "@SEEALSO=EXECSQL"
#~ msgstr ""
#~ "@FUNCTION=READDBTABLE\n"
#~ "@SYNTAX=READDBTABLE(dsn,utilizador,senha,tabela)\n"
#~ "@DESCRIPTION=A função READDBTABLE permite-lhe obter o conteúdo de uma "
#~ "tabela, tal como armazenada na base de dados. Para a utilizar, tem "
#~ "primeiro de definir uma fonte de dados libgda.\n"
#~ "Note que esta função devolve todas as linhas da tabela especificada. Se "
#~ "desejar obter dados de mais do que uma tabela ou deseja uma selecção mais "
#~ "precisa (condições), utilize a função EXECSQL.\n"
#~ "@EXAMPLES=\n"
#~ "Para obter todos os dados da tabela \"Clientes\" existente na fonte de "
#~ "dados GDA \"minhabasedados\", utilizaria:\n"
#~ "READDBTABLE(\"minhabasedados\",\"utilizador\",\"senha\",\"clientes\")\n"
#~ "@SEEALSO=EXECSQL"

#~ msgid ""
#~ "@FUNCTION=NT_PHI\n"
#~ "@SYNTAX=NT_PHI(n)\n"
#~ "@DESCRIPTION=NT_PHI function calculates the number of integers less than "
#~ "or equal to @n that are relatively prime to @n.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=NT_D, ITHPRIME, NT_SIGMA"
#~ msgstr ""
#~ "@FUNCTION=NT_PHI\n"
#~ "@SYNTAX=NT_PHI(n)\n"
#~ "@DESCRIPTION=A função NT_PHI calcula o número de inteiros menores ou "
#~ "iguais ao @n que são primos relativamente a @n.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=NT_D, ITHPRIME, NT_SIGMA"

#~ msgid ""
#~ "@FUNCTION=NT_D\n"
#~ "@SYNTAX=NT_D(n)\n"
#~ "@DESCRIPTION=NT_D function calculates the number of divisors of @n.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=ITHPRIME, NT_PHI, NT_SIGMA"
#~ msgstr ""
#~ "@FUNCTION=NT_D\n"
#~ "@SYNTAX=NT_D(n)\n"
#~ "@DESCRIPTION=A função NT_D calcula o número de divisores de @n.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=ITHPRIME, NT_PHI, NT_SIGMA"

#~ msgid ""
#~ "@FUNCTION=NT_SIGMA\n"
#~ "@SYNTAX=NT_SIGMA(n)\n"
#~ "@DESCRIPTION=NT_SIGMA function calculates the sum of the divisors of @n.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=NT_D, ITHPRIME, NT_PHI"
#~ msgstr ""
#~ "@FUNCTION=NT_SIGMA\n"
#~ "@SYNTAX=NT_SIGMA(n)\n"
#~ "@DESCRIPTION=A função NT_SIGMA calcula a soma dos divisores de @n.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=NT_D, ITHPRIME, NT_PHI"

#~ msgid ""
#~ "@FUNCTION=ITHPRIME\n"
#~ "@SYNTAX=ITHPRIME(i)\n"
#~ "@DESCRIPTION=ITHPRIME function returns the @ith prime.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=NT_D, NT_SIGMA"
#~ msgstr ""
#~ "@FUNCTION=ITHPRIME\n"
#~ "@SYNTAX=ITHPRIME(i)\n"
#~ "@DESCRIPTION=A função ITHPRIME devolve o @iº primo.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=NT_D, NT_SIGMA"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=ISPRIME\n"
#~ "@SYNTAX=ISPRIME(i)\n"
#~ "@DESCRIPTION=ISPRIME function returns TRUE if @i is prime and FALSE "
#~ "otherwise.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=ITHPRIME, NT_D, NT_SIGMA"
#~ msgstr ""
#~ "@FUNCTION=ISPRIME\n"
#~ "@SYNTAX=ISPRIME(i)\n"
#~ "@DESCRIPTION=A função ISPRIME devolve TRUE se @i for primo e FALSE caso "
#~ "contrário.\n"
#~ "\n"
#~ "@SEEALSO=ITHPRIME, NT_D, NT_SIGMA"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=PFACTOR\n"
#~ "@SYNTAX=PFACTOR(n)\n"
#~ "@DESCRIPTION=PFACTOR function returns the smallest prime factor of its "
#~ "argument.\n"
#~ "\n"
#~ "The argument must be at least 2, or else a #VALUE! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=ITHPRIME"
#~ msgstr ""
#~ "@FUNCTION=BITXOR\n"
#~ "@SYNTAX=BITXOR(a,b)\n"
#~ "@DESCRIPTION=A função BITXOR devolve um \"ou\" bitwise exclusivo (XOR) "
#~ "dos seus argumentos.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=BITOR,BITAND"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=NT_PI\n"
#~ "@SYNTAX=NT_PI(n)\n"
#~ "@DESCRIPTION=NT_PI function returns the number of primes less than or "
#~ "equal to @n.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=ITHPRIME, NT_PHI, NT_D, NT_SIGMA"
#~ msgstr ""
#~ "@FUNCTION=NT_PI\n"
#~ "@SYNTAX=NT_PI(n)\n"
#~ "@DESCRIPTION=A função NT_PI devolve o número de primos menores ou iguais "
#~ "a @n.\n"
#~ "\n"
#~ "@SEEALSO=ITHPRIME, NT_PHI, NT_D, NT_SIGMA"

#~ msgid ""
#~ "@FUNCTION=BITOR\n"
#~ "@SYNTAX=BITOR(a,b)\n"
#~ "@DESCRIPTION=BITOR function returns bitwise or-ing of its arguments.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=BITXOR,BITAND"
#~ msgstr ""
#~ "@FUNCTION=BITOR\n"
#~ "@SYNTAX=BITOR(a,b)\n"
#~ "@DESCRIPTION=A função BITOR devolve um \"ou\" bitwise (OR) dos seus "
#~ "argumentos.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=BITXOR,BITAND"

#~ msgid ""
#~ "@FUNCTION=BITXOR\n"
#~ "@SYNTAX=BITXOR(a,b)\n"
#~ "@DESCRIPTION=BITXOR function returns bitwise exclusive or-ing of its "
#~ "arguments.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=BITOR,BITAND"
#~ msgstr ""
#~ "@FUNCTION=BITXOR\n"
#~ "@SYNTAX=BITXOR(a,b)\n"
#~ "@DESCRIPTION=A função BITXOR devolve um \"ou\" bitwise exclusivo (XOR) "
#~ "dos seus argumentos.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=BITOR,BITAND"

#~ msgid ""
#~ "@FUNCTION=BITAND\n"
#~ "@SYNTAX=BITAND(a,b)\n"
#~ "@DESCRIPTION=BITAND function returns bitwise and-ing of its arguments.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=BITOR,BITXOR"
#~ msgstr ""
#~ "@FUNCTION=BITAND\n"
#~ "@SYNTAX=BITAND(a,b)\n"
#~ "@DESCRIPTION=A função BITAND devolve um \"e\" bitwise (AND) dos seus "
#~ "argumentos.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=BITOR,BITXOR"

#~ msgid ""
#~ "@FUNCTION=BITLSHIFT\n"
#~ "@SYNTAX=BITLSHIFT(x,n)\n"
#~ "@DESCRIPTION=BITLSHIFT function returns @x bit-shifted left by @n bits.\n"
#~ "\n"
#~ "* If @n is negative, a right shift will in effect be performed.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=BITRSHIFT"
#~ msgstr ""
#~ "@FUNCTION=BITLSHIFT\n"
#~ "@SYNTAX=BITLSHIFT(x,n)\n"
#~ "@DESCRIPTION=A função BITLSHIFT devolve @x movido à esquerda @n bits.\n"
#~ "\n"
#~ "* Se @n for negativo, na realidade uma movimentação à direita será "
#~ "efectuada.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=BITRSHIFT"

#~ msgid ""
#~ "@FUNCTION=BITRSHIFT\n"
#~ "@SYNTAX=BITRSHIFT(x,n)\n"
#~ "@DESCRIPTION=BITRSHIFT function returns @x bit-shifted right by @n bits.\n"
#~ "\n"
#~ "* If @n is negative, a left shift will in effect be performed.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=BITLSHIFT"
#~ msgstr ""
#~ "@FUNCTION=BITRSHIFT\n"
#~ "@SYNTAX=BITRSHIFT(x,n)\n"
#~ "@DESCRIPTION=A função BITRSHIFT devolve @x movido à direita @n bits.\n"
#~ "\n"
#~ "* Se @n for negativo, uma movimentação à esquerda será efectuada.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=BITLSHIFT"

#~ msgid ""
#~ "@FUNCTION=COLUMN\n"
#~ "@SYNTAX=COLUMN([reference])\n"
#~ "@DESCRIPTION=COLUMN function returns the column number of the current "
#~ "cell unless @reference is given. In that case, it returns an array of the "
#~ "column numbers of all cells in @reference. \n"
#~ "* If @reference is neither an array nor a reference nor a range, COLUMN "
#~ "returns #VALUE! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COLUMN() in E1 equals 5.\n"
#~ "\n"
#~ "@SEEALSO=COLUMNS,ROW,ROWS"
#~ msgstr ""
#~ "@FUNCTION=COLUMN\n"
#~ "@SYNTAX=COLUMN([referência])\n"
#~ "@DESCRIPTION=A função COLUMN devolve o número de coluna da célula actual "
#~ "excepto se for dada @referência. Nesse caso, devolve uma matriz do número "
#~ "de colunas de todas as células em @referência. \n"
#~ "* Se @referência não for nem uma matriz nem uma referência nem uma área, "
#~ "COLUMN devolve o erro #VALOR!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COLUMN() em E1 igual a 5.\n"
#~ "\n"
#~ "@SEEALSO=COLUMNS,ROW,ROWS"

#~ msgid ""
#~ "@FUNCTION=ROW\n"
#~ "@SYNTAX=ROW([reference])\n"
#~ "@DESCRIPTION=ROW function returns an array of the row numbers taking a "
#~ "default argument of the containing cell position.\n"
#~ "\n"
#~ "* If @reference is neither an array nor a reference nor a range, ROW "
#~ "returns #VALUE! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ROW() in G13 equals 13.\n"
#~ "\n"
#~ "@SEEALSO=COLUMN,COLUMNS,ROWS"
#~ msgstr ""
#~ "@FUNCTION=ROW\n"
#~ "@SYNTAX=ROW([referência])\n"
#~ "@DESCRIPTION=A função ROW devolve uma matriz do número de linhas "
#~ "recebendo como argumento por omissão com a posição da célula que a "
#~ "contém.\n"
#~ "\n"
#~ "* Se @referência não for nem uma matriz nem uma referência nem uma área "
#~ "devolve o erro #VALOR!.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ROW() em G13 igual a 13.\n"
#~ "\n"
#~ "@SEEALSO=COLUMN,COLUMNS,ROWS"

#~ msgid ""
#~ "@FUNCTION=FLOOR\n"
#~ "@SYNTAX=FLOOR(x[,significance])\n"
#~ "@DESCRIPTION=FLOOR function rounds @x down to the next nearest multiple "
#~ "of @significance.\n"
#~ "\n"
#~ "* @significance defaults to 1.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FLOOR(0.5) equals 0.\n"
#~ "FLOOR(5,2) equals 4.\n"
#~ "FLOOR(-5,-2) equals -4.\n"
#~ "FLOOR(-5,2) equals #NUM!.\n"
#~ "\n"
#~ "@SEEALSO=CEIL, CEILING, ABS, INT, MOD"
#~ msgstr ""
#~ "@FUNCTION=FLOOR\n"
#~ "@SYNTAX=FLOOR(x[,significância])\n"
#~ "@DESCRIPTION=A função FLOOR arredonda @x para baixo até ao mais próximo "
#~ "múltiplo de @significância.\n"
#~ "\n"
#~ "* @significância é 1 por omissão.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FLOOR(0.5) igual a 0.\n"
#~ "FLOOR(5,2) igual a 4.\n"
#~ "FLOOR(-5,-2) igual a -4.\n"
#~ "FLOOR(-5,2) igual a #NUM!.\n"
#~ "\n"
#~ "@SEEALSO=CEIL, ABS, INT"

#~ msgid ""
#~ "@FUNCTION=SUMPRODUCT\n"
#~ "@SYNTAX=SUMPRODUCT(range1,range2,...)\n"
#~ "@DESCRIPTION=SUMPRODUCT function multiplies corresponding data entries in "
#~ "the given arrays or ranges, and then returns the sum of those products.  "
#~ "If an array entry is not numeric, the value zero is used instead.\n"
#~ "\n"
#~ "* If arrays or range arguments do not have the same dimensions, "
#~ "SUMPRODUCT returns #VALUE! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11, 15, 17, "
#~ "21, and 43 and the cells B1, B2, ..., B5 hold numbers 13, 22, 31, 33, and "
#~ "39.  Then\n"
#~ "SUMPRODUCT(A1:A5,B1:B5) equals 3370.\n"
#~ "\n"
#~ "@SEEALSO=SUM,PRODUCT"
#~ msgstr ""
#~ "@FUNCTION=SUMPRODUCT\n"
#~ "@SYNTAX=SUMPRODUCT(área1,área2,...)\n"
#~ "@DESCRIPTION=A função SUMPRODUCT multiplica entradas de dados "
#~ "correspondentes nas matrizes ou áreas indicadas, e depois devolve a soma "
#~ "destes produtos.  Se uma entrada numa matriz não for numérica, o valor "
#~ "zero é utilizado no seu lugar.\n"
#~ "\n"
#~ "* Se as matrizes ou áreas indicadas como argumentos não tiverem as mesmas "
#~ "dimensões, SUMPRODUCT devolve o erro #VALOR!.\n"
#~ "* Esta função é compatível com o Excel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Vamos assumir que as células A1, A2, ..., A5 contêm os números 11, 15, "
#~ "17, 21, e 43 e as células B1, B2, ..., B5 os números 13, 22, 31, 33, e "
#~ "39.  Então\n"
#~ "SUMPRODUCT(A1:A5,B1:B5) igual a 3370.\n"
#~ "\n"
#~ "@SEEALSO=SUM,PRODUCT"
