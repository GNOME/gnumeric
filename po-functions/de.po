# German translation of gnumeric-functions.
# Copyright (C) 1998-2000 Miguel de Icaza, 2001-2002 Jody Goldberg.
# This file is distributed under the same license as the Gnumeric package.
#
# Datei README.translators unbedingt lesen!
#
# Thanks for improvements to "Andreas J. Guelzow" <aguelzow@taliesin.ca>, 2001.
#
# Future translators, please take care to translate error messages correctly:
# #3D MULT? == #3D-MULT?
# #ARG! == #ARG!
# #DIV/0! == #DIV/0!
# #N/A == #-/-
# #NAME? == #NAME?
# #NULL! == #NULL!
# #NUM! == #ZAHL!
# #RECALC! == #NEU-BER!
# #REF! == #BEZUG!
# #UNKNOWN! == #UNBEKANNT!
# #VALUE! == #WERT!
#
# asset         -  Vermögenswert
# deprecation   - Abschreibung
# maturity date - Fälligkeitsdatum
# security      - Bürgschaft
#
# TODO:
#
# - translate all functions (the untranslated ones are translated with LATER)
#
#
# Here is a short description of the analysis-tools:
#
# SS = Sum of Squares
# MS = Mean Square   (MS = SS/df)
# df = degree of freedom
#
# Multiple R = Multiple Regression
# R Square   = coefficient of determination, but in some langs mathematics
# 	     use R^2, so ask you math teacher :)
# ANOVA      = ANalysis Of VAriance
#
# Ask if you want :)
#
# Valek <frob@df.ru> and Kenneth <kenneth@gnu.org>
# Created with help from Pete.
#
# t-test: technically called Student's t-test
# F-test: used to test whether the variances of two samples are different
# Named after Fischer
# t-test: used to test whether the means of two samples are  different
# http://stat.ethz.ch/R-alpha/library/base/html/t.test.html
# http://www.statsol.com/tools/stattools/ttestindependenttoolhelp.html
#
# Ralf Baechle <ralf@gnu.org>, 1999.
# Karsten Weiss <karsten@addx.au.s.shuttle.de>, 1999.
# Matthias Warkus <mawa@iname.com>, 1999-2000.
# Karl Eichwalder <ke@suse.de>, 1999-2001.
# Andreas J. Guelzow <aguelzow@taliesin.ca>, 2001.
# Christian Meyer <chrisime@gnome.org>, 2001.
# Christian Neumair <chris@gnome-de.org>, 2002.
# Hendrik Richter <hendrik@gnome-de.org>, 2005.
# Mario Blättermann <mariobl@freenet.de>, 2009-2011.
# Paul Seyfert <pseyfert@mathphys.fsk.uni-heidelberg.de>, 2010, 2011.
# Christian Kirbach <Christian.Kirbach@googlemail.com>, 2010, 2011, 2012.
#
msgid ""
msgstr ""
"Project-Id-Version: gnumeric master\n"
"Report-Msgid-Bugs-To: http://bugzilla.gnome.org/enter_bug.cgi?"
"product=gnumeric&keywords=I18N+L10N&component=general\n"
"POT-Creation-Date: 2013-07-20 23:02+0000\n"
"PO-Revision-Date: 2013-07-21 18:20+0100\n"
"Last-Translator: Benjamin Steinwender <b@stbe.at>\n"
"Language-Team: Deutsch <gnome-de@gnome.org>\n"
"Language: de_DE\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Generator: Poedit 1.5.7\n"

#: ../plugins/fn-christian-date/functions.c:140
msgid ""
"EASTERSUNDAY:Easter Sunday in the Gregorian calendar according to the Roman "
"rite of the Christian Church"
msgstr ""
"EASTERSUNDAY:Ostersonntag im Gregorianischen Kalender gemäß den römischen "
"Riten der Christlichen Kirche"

#: ../plugins/fn-christian-date/functions.c:142
msgid ""
"year:year between 1582 and 9956, defaults to the year of the next Easter "
"Sunday"
msgstr ""
"year:Jahr zwischen 1582 und 9956, Vorgabe ist das Jahr des nächsten "
"Ostersonntags"

#: ../plugins/fn-christian-date/functions.c:143
#: ../plugins/fn-christian-date/functions.c:166
#: ../plugins/fn-christian-date/functions.c:186
#: ../plugins/fn-christian-date/functions.c:205
#: ../plugins/fn-christian-date/functions.c:224
msgid ""
"Two digit years are adjusted as elsewhere in Gnumeric. Dates before 1904 may "
"also be prohibited."
msgstr ""
"Jahreszahlen aus zwei Ziffern werden wie anderenorts in Gnumeric angepasst. "
"Daten vor 1904 könnten auch untersagt sein."

#: ../plugins/fn-christian-date/functions.c:146
msgid ""
"The 1-argument version of EASTERSUNDAY is compatible with OpenOffice for "
"years after 1904. This function is not specified in ODF/OpenFormula."
msgstr ""
"Die Version von EASTERSUNDAY mit einem Argument ist kompatibel mit "
"OpenOffice für alle Jahre nach 1904. Diese Funktion ist nicht in ODF/"
"OpenFormula spezifiziert."

#: ../plugins/fn-christian-date/functions.c:163
msgid ""
"ASHWEDNESDAY:Ash Wednesday in the Gregorian calendar according to the Roman "
"rite of the Christian Church"
msgstr ""
"ASHWEDNESDAY:Aschermittwoch im Gregorianischen Kalender gemäß den Riten der "
"Römisch-Katholischen Kirche"

#: ../plugins/fn-christian-date/functions.c:165
msgid ""
"year:year between 1582 and 9956, defaults to the year of the next Ash "
"Wednesday"
msgstr ""
"year:Jahr zwischen 1582 und 9956, Vorgabe ist das Jahr des nächsten "
"Aschermittwochs"

#: ../plugins/fn-christian-date/functions.c:183
msgid ""
"PENTECOSTSUNDAY:Pentecost Sunday in the Gregorian calendar according to the "
"Roman rite of the Christian Church"
msgstr ""
"PENTECOSTSUNDAY:Pfingstsonntag im Gregorianischen Kalender gemäß den Riten "
"der Römisch-Katholischen Kirche"

#: ../plugins/fn-christian-date/functions.c:185
msgid ""
"year:year between 1582 and 9956, defaults to the year of the next Pentecost "
"Sunday"
msgstr ""
"year:Jahr zwischen 1582 und 9956, Vorgabe ist das Jahr des nächsten "
"Pfingstsonntags"

#: ../plugins/fn-christian-date/functions.c:202
msgid ""
"GOODFRIDAY:Good Friday in the Gregorian calendar according to the Roman rite "
"of the Christian Church"
msgstr ""
"GOODFRIDAY:Karfreitag im Gregorianischen Kalender gemäß den Riten der "
"Römisch-Katholischen Kirche"

#: ../plugins/fn-christian-date/functions.c:204
msgid ""
"year:year between 1582 and 9956, defaults to the year of the next Good Friday"
msgstr ""
"year:Jahr zwischen 1582 und 9956, Vorgabe ist das Jahr des nächsten "
"Karfreitags"

#: ../plugins/fn-christian-date/functions.c:221
msgid ""
"ASCENSIONTHURSDAY:Ascension Thursday in the Gregorian calendar according to "
"the Roman rite of the Christian Church"
msgstr ""
"ASCENSIONTHURSDAY:Himmelfahrtstag im Gregorianischen Kalender gemäß den "
"Riten der Römisch-Katholischen Kirche"

#: ../plugins/fn-christian-date/functions.c:223
msgid ""
"year:year between 1582 and 9956, defaults to the year of the next Ascension "
"Thursday"
msgstr ""
"year:Jahr zwischen 1582 und 9956, Vorgabe ist das Jahr des nächsten "
"Himmelfahrtstags"

#: ../plugins/fn-complex/functions.c:78
msgid "COMPLEX:a complex number of the form @{x} + @{y}@{i}"
msgstr "COMPLEX:eine komplexe Zahl der Form @{x} + @{y}@{i}."

#: ../plugins/fn-complex/functions.c:79
msgid "x:real part"
msgstr "x:reeller Teil"

#: ../plugins/fn-complex/functions.c:80
msgid "y:imaginary part"
msgstr "y:imaginärer Teil"

#: ../plugins/fn-complex/functions.c:81
msgid ""
"i:the suffix for the complex number, either \"i\" or \"j\"; defaults to \"i\""
msgstr ""
"i:das Suffix der komplexen Zahl, entweder »i« oder »j«, Vorgabe ist »i«"

#: ../plugins/fn-complex/functions.c:82
msgid "If @{i} is neither \"i\" nor \"j\", COMPLEX returns #VALUE!"
msgstr "Falls @{i} weder »i« noch »j« ist, gibt COMPLEX  #WERT! zurück"

#: ../plugins/fn-complex/functions.c:83 ../plugins/fn-complex/functions.c:111
#: ../plugins/fn-complex/functions.c:138 ../plugins/fn-complex/functions.c:162
#: ../plugins/fn-complex/functions.c:189 ../plugins/fn-complex/functions.c:260
#: ../plugins/fn-complex/functions.c:286 ../plugins/fn-complex/functions.c:392
#: ../plugins/fn-complex/functions.c:420 ../plugins/fn-complex/functions.c:446
#: ../plugins/fn-complex/functions.c:471 ../plugins/fn-complex/functions.c:498
#: ../plugins/fn-complex/functions.c:525 ../plugins/fn-complex/functions.c:560
#: ../plugins/fn-complex/functions.c:592
#: ../plugins/fn-complex/functions.c:1075
#: ../plugins/fn-complex/functions.c:1102
#: ../plugins/fn-complex/functions.c:1132
#: ../plugins/fn-complex/functions.c:1201 ../plugins/fn-date/functions.c:84
#: ../plugins/fn-date/functions.c:197 ../plugins/fn-date/functions.c:219
#: ../plugins/fn-date/functions.c:354 ../plugins/fn-date/functions.c:389
#: ../plugins/fn-date/functions.c:406 ../plugins/fn-date/functions.c:431
#: ../plugins/fn-date/functions.c:492 ../plugins/fn-date/functions.c:511
#: ../plugins/fn-date/functions.c:534 ../plugins/fn-date/functions.c:557
#: ../plugins/fn-date/functions.c:579 ../plugins/fn-date/functions.c:603
#: ../plugins/fn-date/functions.c:627 ../plugins/fn-date/functions.c:655
#: ../plugins/fn-date/functions.c:696 ../plugins/fn-date/functions.c:734
#: ../plugins/fn-eng/functions.c:236 ../plugins/fn-eng/functions.c:261
#: ../plugins/fn-eng/functions.c:285 ../plugins/fn-eng/functions.c:314
#: ../plugins/fn-eng/functions.c:340 ../plugins/fn-eng/functions.c:363
#: ../plugins/fn-eng/functions.c:407 ../plugins/fn-eng/functions.c:434
#: ../plugins/fn-eng/functions.c:457 ../plugins/fn-eng/functions.c:480
#: ../plugins/fn-eng/functions.c:503 ../plugins/fn-eng/functions.c:523
#: ../plugins/fn-eng/functions.c:612 ../plugins/fn-eng/functions.c:641
#: ../plugins/fn-eng/functions.c:1130 ../plugins/fn-eng/functions.c:1153
#: ../plugins/fn-info/functions.c:97 ../plugins/fn-info/functions.c:1285
#: ../plugins/fn-info/functions.c:1351 ../plugins/fn-info/functions.c:1440
#: ../plugins/fn-info/functions.c:1458 ../plugins/fn-info/functions.c:1480
#: ../plugins/fn-info/functions.c:1507 ../plugins/fn-info/functions.c:1534
#: ../plugins/fn-info/functions.c:1571 ../plugins/fn-info/functions.c:1587
#: ../plugins/fn-info/functions.c:1609 ../plugins/fn-info/functions.c:1626
#: ../plugins/fn-info/functions.c:1644 ../plugins/fn-info/functions.c:1661
#: ../plugins/fn-info/functions.c:1683 ../plugins/fn-info/functions.c:1703
#: ../plugins/fn-info/functions.c:1722 ../plugins/fn-info/functions.c:1759
#: ../plugins/fn-logical/functions.c:52 ../plugins/fn-logical/functions.c:103
#: ../plugins/fn-logical/functions.c:131 ../plugins/fn-logical/functions.c:269
#: ../plugins/fn-logical/functions.c:287 ../plugins/fn-math/functions.c:64
#: ../plugins/fn-math/functions.c:127 ../plugins/fn-math/functions.c:228
#: ../plugins/fn-math/functions.c:246 ../plugins/fn-math/functions.c:268
#: ../plugins/fn-math/functions.c:328 ../plugins/fn-math/functions.c:354
#: ../plugins/fn-math/functions.c:378 ../plugins/fn-math/functions.c:397
#: ../plugins/fn-math/functions.c:432 ../plugins/fn-math/functions.c:478
#: ../plugins/fn-math/functions.c:557 ../plugins/fn-math/functions.c:669
#: ../plugins/fn-math/functions.c:737 ../plugins/fn-math/functions.c:766
#: ../plugins/fn-math/functions.c:786 ../plugins/fn-math/functions.c:840
#: ../plugins/fn-math/functions.c:859 ../plugins/fn-math/functions.c:893
#: ../plugins/fn-math/functions.c:954 ../plugins/fn-math/functions.c:1032
#: ../plugins/fn-math/functions.c:1089 ../plugins/fn-math/functions.c:1122
#: ../plugins/fn-math/functions.c:1144 ../plugins/fn-math/functions.c:1172
#: ../plugins/fn-math/functions.c:1196 ../plugins/fn-math/functions.c:1330
#: ../plugins/fn-math/functions.c:1373 ../plugins/fn-math/functions.c:1391
#: ../plugins/fn-math/functions.c:1488 ../plugins/fn-math/functions.c:1506
#: ../plugins/fn-math/functions.c:1553 ../plugins/fn-math/functions.c:1577
#: ../plugins/fn-math/functions.c:1623 ../plugins/fn-math/functions.c:1640
#: ../plugins/fn-math/functions.c:1677 ../plugins/fn-math/functions.c:1712
#: ../plugins/fn-math/functions.c:1747 ../plugins/fn-math/functions.c:1784
#: ../plugins/fn-math/functions.c:1863 ../plugins/fn-math/functions.c:1888
#: ../plugins/fn-math/functions.c:1915 ../plugins/fn-math/functions.c:1941
#: ../plugins/fn-math/functions.c:1965 ../plugins/fn-math/functions.c:2006
#: ../plugins/fn-math/functions.c:2051 ../plugins/fn-math/functions.c:2178
#: ../plugins/fn-math/functions.c:2426 ../plugins/fn-math/functions.c:2470
#: ../plugins/fn-math/functions.c:2513 ../plugins/fn-math/functions.c:2556
#: ../plugins/fn-math/functions.c:2613 ../plugins/fn-math/functions.c:2802
#: ../plugins/fn-math/functions.c:2900 ../plugins/fn-math/functions.c:2945
#: ../plugins/fn-random/functions.c:48 ../plugins/fn-random/functions.c:249
#: ../plugins/fn-stat/functions.c:83 ../plugins/fn-stat/functions.c:111
#: ../plugins/fn-stat/functions.c:138 ../plugins/fn-stat/functions.c:166
#: ../plugins/fn-stat/functions.c:276 ../plugins/fn-stat/functions.c:324
#: ../plugins/fn-stat/functions.c:354 ../plugins/fn-stat/functions.c:384
#: ../plugins/fn-stat/functions.c:417 ../plugins/fn-stat/functions.c:441
#: ../plugins/fn-stat/functions.c:485 ../plugins/fn-stat/functions.c:535
#: ../plugins/fn-stat/functions.c:564 ../plugins/fn-stat/functions.c:593
#: ../plugins/fn-stat/functions.c:613 ../plugins/fn-stat/functions.c:640
#: ../plugins/fn-stat/functions.c:667 ../plugins/fn-stat/functions.c:693
#: ../plugins/fn-stat/functions.c:718 ../plugins/fn-stat/functions.c:743
#: ../plugins/fn-stat/functions.c:769 ../plugins/fn-stat/functions.c:804
#: ../plugins/fn-stat/functions.c:844 ../plugins/fn-stat/functions.c:898
#: ../plugins/fn-stat/functions.c:966 ../plugins/fn-stat/functions.c:998
#: ../plugins/fn-stat/functions.c:1028 ../plugins/fn-stat/functions.c:1055
#: ../plugins/fn-stat/functions.c:1085 ../plugins/fn-stat/functions.c:1173
#: ../plugins/fn-stat/functions.c:1210 ../plugins/fn-stat/functions.c:1251
#: ../plugins/fn-stat/functions.c:1336 ../plugins/fn-stat/functions.c:1373
#: ../plugins/fn-stat/functions.c:1539 ../plugins/fn-stat/functions.c:1571
#: ../plugins/fn-stat/functions.c:1667 ../plugins/fn-stat/functions.c:1694
#: ../plugins/fn-stat/functions.c:1724 ../plugins/fn-stat/functions.c:1759
#: ../plugins/fn-stat/functions.c:1786 ../plugins/fn-stat/functions.c:1818
#: ../plugins/fn-stat/functions.c:1850 ../plugins/fn-stat/functions.c:1882
#: ../plugins/fn-stat/functions.c:1915 ../plugins/fn-stat/functions.c:1965
#: ../plugins/fn-stat/functions.c:1990 ../plugins/fn-stat/functions.c:2015
#: ../plugins/fn-stat/functions.c:2042 ../plugins/fn-stat/functions.c:2071
#: ../plugins/fn-stat/functions.c:2090 ../plugins/fn-stat/functions.c:2116
#: ../plugins/fn-stat/functions.c:2248 ../plugins/fn-stat/functions.c:2291
#: ../plugins/fn-stat/functions.c:2340 ../plugins/fn-stat/functions.c:2420
#: ../plugins/fn-stat/functions.c:2478 ../plugins/fn-stat/functions.c:2537
#: ../plugins/fn-stat/functions.c:2562 ../plugins/fn-stat/functions.c:2589
#: ../plugins/fn-stat/functions.c:2621 ../plugins/fn-stat/functions.c:2648
#: ../plugins/fn-stat/functions.c:2678 ../plugins/fn-stat/functions.c:2705
#: ../plugins/fn-stat/functions.c:2829 ../plugins/fn-stat/functions.c:2872
#: ../plugins/fn-stat/functions.c:2913 ../plugins/fn-stat/functions.c:2979
#: ../plugins/fn-stat/functions.c:3148 ../plugins/fn-stat/functions.c:4078
#: ../plugins/fn-stat/functions.c:4135 ../plugins/fn-stat/functions.c:4183
#: ../plugins/fn-stat/functions.c:4248 ../plugins/fn-string/functions.c:68
#: ../plugins/fn-string/functions.c:140 ../plugins/fn-string/functions.c:247
#: ../plugins/fn-string/functions.c:266 ../plugins/fn-string/functions.c:283
#: ../plugins/fn-string/functions.c:303 ../plugins/fn-string/functions.c:367
#: ../plugins/fn-string/functions.c:387 ../plugins/fn-string/functions.c:514
#: ../plugins/fn-string/functions.c:583 ../plugins/fn-string/functions.c:603
#: ../plugins/fn-string/functions.c:625 ../plugins/fn-string/functions.c:669
#: ../plugins/fn-string/functions.c:700 ../plugins/fn-string/functions.c:738
#: ../plugins/fn-string/functions.c:795 ../plugins/fn-string/functions.c:841
#: ../plugins/fn-string/functions.c:942 ../plugins/fn-string/functions.c:966
#: ../plugins/fn-string/functions.c:1019 ../plugins/fn-string/functions.c:1066
#: ../plugins/fn-string/functions.c:1162 ../plugins/fn-string/functions.c:1233
#: ../plugins/fn-string/functions.c:1316
msgid "This function is Excel compatible."
msgstr "Diese Funktion ist mit Excel kompatibel."

#: ../plugins/fn-complex/functions.c:108
msgid "IMAGINARY:the imaginary part of the complex number @{z}"
msgstr "IMAGINARY:der imaginäre Teil der komplexen Zahl @{z}"

#: ../plugins/fn-complex/functions.c:109 ../plugins/fn-complex/functions.c:136
#: ../plugins/fn-complex/functions.c:160 ../plugins/fn-complex/functions.c:187
#: ../plugins/fn-complex/functions.c:212 ../plugins/fn-complex/functions.c:235
#: ../plugins/fn-complex/functions.c:258 ../plugins/fn-complex/functions.c:284
#: ../plugins/fn-complex/functions.c:310 ../plugins/fn-complex/functions.c:337
#: ../plugins/fn-complex/functions.c:363 ../plugins/fn-complex/functions.c:390
#: ../plugins/fn-complex/functions.c:417 ../plugins/fn-complex/functions.c:441
#: ../plugins/fn-complex/functions.c:469 ../plugins/fn-complex/functions.c:496
#: ../plugins/fn-complex/functions.c:590 ../plugins/fn-complex/functions.c:615
#: ../plugins/fn-complex/functions.c:639 ../plugins/fn-complex/functions.c:664
#: ../plugins/fn-complex/functions.c:689 ../plugins/fn-complex/functions.c:713
#: ../plugins/fn-complex/functions.c:738 ../plugins/fn-complex/functions.c:762
#: ../plugins/fn-complex/functions.c:789 ../plugins/fn-complex/functions.c:816
#: ../plugins/fn-complex/functions.c:843 ../plugins/fn-complex/functions.c:867
#: ../plugins/fn-complex/functions.c:892 ../plugins/fn-complex/functions.c:916
#: ../plugins/fn-complex/functions.c:943 ../plugins/fn-complex/functions.c:971
#: ../plugins/fn-complex/functions.c:999
#: ../plugins/fn-complex/functions.c:1023
#: ../plugins/fn-complex/functions.c:1048
#: ../plugins/fn-complex/functions.c:1073
msgid "z:a complex number"
msgstr "z:eine komplexe Zahl"

#: ../plugins/fn-complex/functions.c:110 ../plugins/fn-complex/functions.c:137
#: ../plugins/fn-complex/functions.c:161 ../plugins/fn-complex/functions.c:188
#: ../plugins/fn-complex/functions.c:213 ../plugins/fn-complex/functions.c:236
#: ../plugins/fn-complex/functions.c:259 ../plugins/fn-complex/functions.c:285
#: ../plugins/fn-complex/functions.c:312 ../plugins/fn-complex/functions.c:339
#: ../plugins/fn-complex/functions.c:365 ../plugins/fn-complex/functions.c:391
#: ../plugins/fn-complex/functions.c:419 ../plugins/fn-complex/functions.c:445
#: ../plugins/fn-complex/functions.c:470 ../plugins/fn-complex/functions.c:497
#: ../plugins/fn-complex/functions.c:591 ../plugins/fn-complex/functions.c:616
#: ../plugins/fn-complex/functions.c:640 ../plugins/fn-complex/functions.c:665
#: ../plugins/fn-complex/functions.c:690 ../plugins/fn-complex/functions.c:714
#: ../plugins/fn-complex/functions.c:739 ../plugins/fn-complex/functions.c:765
#: ../plugins/fn-complex/functions.c:792 ../plugins/fn-complex/functions.c:819
#: ../plugins/fn-complex/functions.c:844 ../plugins/fn-complex/functions.c:868
#: ../plugins/fn-complex/functions.c:893 ../plugins/fn-complex/functions.c:919
#: ../plugins/fn-complex/functions.c:947 ../plugins/fn-complex/functions.c:975
#: ../plugins/fn-complex/functions.c:1000
#: ../plugins/fn-complex/functions.c:1024
#: ../plugins/fn-complex/functions.c:1049
#: ../plugins/fn-complex/functions.c:1074
msgid "If @{z} is not a valid complex number, #VALUE! is returned."
msgstr "Falls @{z} keine gültige komplexe Zahl ist, wird #WERT! zurückgegeben."

#: ../plugins/fn-complex/functions.c:135
msgid "IMABS:the absolute value of the complex number @{z}"
msgstr "IMABS:der absolute Wert der komplexen Zahl @{z}"

#: ../plugins/fn-complex/functions.c:159
msgid "IMREAL:the real part of the complex number @{z}"
msgstr "IMREAL:der reelle Teil der komplexen Zahl @{z}"

#: ../plugins/fn-complex/functions.c:186
msgid "IMCONJUGATE:the complex conjugate of the complex number @{z}"
msgstr "IMCONJUGATE:die komplex konjugierte der komplexen Zahl @{z}"

#: ../plugins/fn-complex/functions.c:211
msgid "IMINV:the reciprocal, or inverse, of the complex number @{z}"
msgstr "IMINV:die reziproke, oder der Kehrwert, der komplexen Zahl @{z}"

#: ../plugins/fn-complex/functions.c:234
msgid "IMNEG:the negative of the complex number @{z}"
msgstr "IMNEG:die negative der komplexen Zahl @{z}"

#: ../plugins/fn-complex/functions.c:257
msgid "IMCOS:the cosine of the complex number @{z}"
msgstr "IMCOS:der Kosinus der komplexen Zahl @{z}"

#: ../plugins/fn-complex/functions.c:283
msgid "IMTAN:the tangent of the complex number @{z}"
msgstr "IMTAN:der Tangens der komplexen Zahl @{z}"

#: ../plugins/fn-complex/functions.c:309
msgid "IMSEC:the secant of the complex number @{z}"
msgstr "IMSEC:der Sekans der komplexen Zahl @{z}"

#: ../plugins/fn-complex/functions.c:311
msgid "IMSEC(@{z}) = 1/IMCOS(@{z})."
msgstr "IMSEC(@{z}) = 1/IMCOS(@{z})."

#: ../plugins/fn-complex/functions.c:336
msgid "IMCSC:the cosecant of the complex number @{z}"
msgstr "IMCSC:der Kosekans er komplexen Zahl @{z}"

#: ../plugins/fn-complex/functions.c:338
msgid "IMCSC(@{z}) = 1/IMSIN(@{z})."
msgstr "IMCSC(@{z}) = 1/IMSIN(@{z})."

#: ../plugins/fn-complex/functions.c:362
msgid "IMCOT:the cotangent of the complex number @{z}"
msgstr "IMCOT:der Kotangens der komplexen Zahl @{z}"

#: ../plugins/fn-complex/functions.c:364
msgid "IMCOT(@{z}) = IMCOS(@{z})/IMSIN(@{z})."
msgstr "IMCOT(@{z}) = IMCOS(@{z})/IMSIN(@{z})."

#: ../plugins/fn-complex/functions.c:389
msgid "IMEXP:the exponential of the complex number @{z}"
msgstr "IMEXP:der Exponent der komplexen Zahl @{z}"

#: ../plugins/fn-complex/functions.c:416
msgid "IMARGUMENT:the argument theta of the complex number @{z} "
msgstr "IMARGUMENT:Das Argument Theta der komplexen Zahl @{z}"

#: ../plugins/fn-complex/functions.c:418
msgid ""
"The argument theta of a complex number is its angle in radians from the real "
"axis."
msgstr ""
"Das Argument Theta einer komplexen Zahl entspricht dem Winkel im Bogenmaß "
"von der realen Achse."

#: ../plugins/fn-complex/functions.c:440
msgid "IMLN:the natural logarithm of the complex number @{z}"
msgstr "IMLN:der natürliche Logarithmus der komplexen Zahl @{z}"

#: ../plugins/fn-complex/functions.c:442
msgid ""
"The result will have an imaginary part between -π and +π.\n"
"The natural logarithm is not uniquely defined on complex numbers. You may "
"need to add or subtract an even multiple of π to the imaginary part."
msgstr ""
"Das Ergebnis hat einen imaginären Teil zwischen -π und +π.\n"
"Der natürliche Logarithmus ist nicht eindeutig für komplexe Zahlen "
"definiert. Gegebenenfalls muss ein gerades Vielfaches von π zum imaginären "
"Teil addiert oder von ihm subtrahiert werden."

#: ../plugins/fn-complex/functions.c:468
msgid "IMLOG2:the base-2 logarithm of the complex number @{z}"
msgstr "IMLOG2:der Logarithmus zur Basis 2 der komplexen Zahl @{z}"

#: ../plugins/fn-complex/functions.c:495
msgid "IMLOG10:the base-10 logarithm of the complex number @{z}"
msgstr "IMLOG2:der Logarithmus zur Basis 10 der komplexen Zahl @{z}"

#: ../plugins/fn-complex/functions.c:521
msgid "IMPOWER:the complex number @{z1} raised to the @{z2}th power"
msgstr "IMPOWER:die komplexe Zahl @{z1} hoch @{z2}"

#: ../plugins/fn-complex/functions.c:522 ../plugins/fn-complex/functions.c:557
#: ../plugins/fn-complex/functions.c:1099
#: ../plugins/fn-complex/functions.c:1129
#: ../plugins/fn-complex/functions.c:1198
msgid "z1:a complex number"
msgstr "z1:eine komplexe Zahl"

#: ../plugins/fn-complex/functions.c:523 ../plugins/fn-complex/functions.c:558
#: ../plugins/fn-complex/functions.c:1100
#: ../plugins/fn-complex/functions.c:1130
#: ../plugins/fn-complex/functions.c:1199
msgid "z2:a complex number"
msgstr "z2:eine komplexe Zahl"

#: ../plugins/fn-complex/functions.c:524 ../plugins/fn-complex/functions.c:559
#: ../plugins/fn-complex/functions.c:1101
msgid "If @{z1} or @{z2} is not a valid complex number, #VALUE! is returned."
msgstr ""
"Falls @{z1} oder @{z2} keine gültige komplexe Zahl ist, wird #WERT! "
"zurückgegeben."

#: ../plugins/fn-complex/functions.c:556
msgid "IMDIV:the quotient of two complex numbers @{z1}/@{z2}"
msgstr "IMDIV:der Quotient zweier komplexer Zahlen @{z1}/@{z2}"

#: ../plugins/fn-complex/functions.c:589
msgid "IMSIN:the sine of the complex number @{z}"
msgstr "IMSIN:der Sinus der komplexen Zahl @{z}"

#: ../plugins/fn-complex/functions.c:614
msgid "IMSINH:the hyperbolic sine of the complex number @{z}"
msgstr "IMSINH:der hyperbolische Sinus der komplexen Zahl @{z}"

#: ../plugins/fn-complex/functions.c:638
msgid "IMCOSH:the hyperbolic cosine of the complex number @{z}"
msgstr "IMCOSH:der hyperbolische Kosinus der komplexen Zahl @{z}"

#: ../plugins/fn-complex/functions.c:663
msgid "IMTANH:the hyperbolic tangent of the complex number @{z}"
msgstr "IMTANH:der hyperbolische Tangens der komplexen Zahl @{z}"

#: ../plugins/fn-complex/functions.c:688
msgid "IMSECH:the hyperbolic secant of the complex number @{z}"
msgstr "IMSECH:der hyperbolische Sekans der komplexen Zahl @{z}"

#: ../plugins/fn-complex/functions.c:712
msgid "IMCSCH:the hyperbolic cosecant of the complex number @{z}"
msgstr "IMCSCH:der hyperbolische Kosekans der komplexen Zahl @{z}"

#: ../plugins/fn-complex/functions.c:737
msgid "IMCOTH:the hyperbolic cotangent of the complex number @{z}"
msgstr "IMCOTH:der hyperbolische Kotangens der komplexen Zahl @{z}"

#: ../plugins/fn-complex/functions.c:761
msgid "IMARCSIN:the complex arcsine of the complex number @{z}"
msgstr "IMARCSIN:der komplexe Arkussinus der komplexen Zahl @{z}"

#: ../plugins/fn-complex/functions.c:763
#, fuzzy
msgid ""
"IMARCSIN returns the complex arcsine of the complex number @{z}. The branch "
"cuts are on the real axis, less than -1 and greater than 1."
msgstr ""
"IMARCSIN gibt den komplexen Arkussinus der komplexen Zahl @{z} zurück. (?)"
"auf der realen Achse, kleines als -1 und größer als 1."

#: ../plugins/fn-complex/functions.c:788
msgid "IMARCCOS:the complex arccosine of the complex number "
msgstr "IMARCCOS:der komplexe Arkuskosinus der komplexen Zahl"

#: ../plugins/fn-complex/functions.c:790
#, fuzzy
msgid ""
"IMARCCOS returns the complex arccosine of the complex number @{z}. The "
"branch cuts are on the real axis, less than -1 and greater than 1."
msgstr ""
"IMARCCOS gibt den Arkuskosinus  der komplexen Zahl @{z} zurück. (?) auf der "
"realen Achse, kleiner als -1 und größer als 1."

#: ../plugins/fn-complex/functions.c:815
msgid "IMARCTAN:the complex arctangent of the complex number "
msgstr "IMARCTAN:der komplexe Arkustangens der komplexen Zahl"

#: ../plugins/fn-complex/functions.c:817
msgid ""
"IMARCTAN returns the complex arctangent of the complex number @{z}. The "
"branch cuts are on the imaginary axis, below -i and above i."
msgstr ""
"IMARCTAN gibt den komplexen Arkustangens der komplexen Zahl @{z} zurück. Die "
"Schnitte der komplexen Ebene sind entlang der imaginären Achse, über i und "
"unter -i."

#: ../plugins/fn-complex/functions.c:842
msgid "IMARCSEC:the complex arcsecant of the complex number @{z}"
msgstr "IMARCSEC:der komplexe Arkussekans der komplexen Zahl @{z}"

#: ../plugins/fn-complex/functions.c:866
msgid "IMARCCSC:the complex arccosecant of the complex number @{z}"
msgstr "IMARCCSC:der komplexe Arkuskosekans der komplexen Zahl @{z}"

#: ../plugins/fn-complex/functions.c:891
msgid "IMARCCOT:the complex arccotangent of the complex number @{z}"
msgstr "IMARCCOT:der komplexe Arkuskotangens der komplexen Zahl @{z}"

#: ../plugins/fn-complex/functions.c:915
msgid "IMARCSINH:the complex hyperbolic arcsine of the complex number @{z}"
msgstr "IMARCSINH:der komplexe hyperbolische Areasinus der komplexen Zahl @{z}"

#: ../plugins/fn-complex/functions.c:917
msgid ""
"IMARCSINH returns the complex hyperbolic arcsine of the complex number @"
"{z}.  The branch cuts are on the imaginary axis, below -i and above i."
msgstr ""
"IMARCSINH gibt den komplexen Areasinus Hypberbolicus einer komplexen Zahl @"
"{z} zurück. Die Schnitte der komplexen Ebene sind entlang der imaginären "
"Achse über i und unter -i."

#: ../plugins/fn-complex/functions.c:942
msgid "IMARCCOSH:the complex hyperbolic arccosine of the complex number @{z}"
msgstr ""
"IMARCCOSH:der komplexe hyperbolische Areakosinus der komplexen Zahl @{z}"

#: ../plugins/fn-complex/functions.c:944
msgid ""
"IMARCCOSH returns the complex hyperbolic arccosine of the complex number @"
"{z}. The branch cut is on the real axis, less than 1."
msgstr ""
"IMARCCOSH gibt den komplexen Areakosinus Hyperbolicus einer komplexen Zahl @"
"{z} zurück. Der Schnitt der komplexen Ebene ist entlang der reellen Achse "
"kleiner als 1."

#: ../plugins/fn-complex/functions.c:970
msgid "IMARCTANH:the complex hyperbolic arctangent of the complex number @{z}"
msgstr ""
"IMARCTANH:der komplexe hyperbolische Areatangens der komplexen Zahl @{z}"

#: ../plugins/fn-complex/functions.c:972
msgid ""
"IMARCTANH returns the complex hyperbolic arctangent of the complex number @"
"{z}. The branch cuts are on the real axis, less than -1 and greater than 1."
msgstr ""
"IMARCTANH gibt den komplexen Areatangens Hyperbolicus einer komplexen Zahl @"
"{z} zurück. Die Schnitte der komplexen Ebene sind entlang der reellen Achse "
"kleiner als -1 und größer als 1."

#: ../plugins/fn-complex/functions.c:998
msgid "IMARCSECH:the complex hyperbolic arcsecant of the complex number @{z}"
msgstr ""
"IMARCSECH:der komplexe hyperbolische Areasekans der komplexen Zahl @{z}"

#: ../plugins/fn-complex/functions.c:1022
msgid "IMARCCSCH:the complex hyperbolic arccosecant of the complex number @{z}"
msgstr ""
"IMARCCSCH:der komplexe hyperbolische Areakosekans der komplexen Zahl @{z}"

#: ../plugins/fn-complex/functions.c:1047
msgid ""
"IMARCCOTH:the complex hyperbolic arccotangent of the complex number @{z}"
msgstr ""
"IMARCCOTH:der komplexe hyperbolische Areakotangens der komplexen Zahl @{z}"

#: ../plugins/fn-complex/functions.c:1072
msgid "IMSQRT:the square root of the complex number @{z}"
msgstr "IMSQRT:Die Quadratwurzel der komplexen Zahl @{z}"

#: ../plugins/fn-complex/functions.c:1098
msgid "IMSUB:the difference of two complex numbers"
msgstr "IMSUB:Die Differenz der zwei komplexen Zahlen."

#: ../plugins/fn-complex/functions.c:1128
msgid "IMPRODUCT:the product of the given complex numbers"
msgstr "IMPRODUCT:Das Produkt der angegebenen komplexen Zahlen."

#: ../plugins/fn-complex/functions.c:1131
#: ../plugins/fn-complex/functions.c:1200
msgid ""
"If any of @{z1}, @{z2},... is not a valid complex number, #VALUE! is "
"returned."
msgstr ""
"Falls irgeneines von @{z1}, @{z2},… keine komplexe Zahl ist, wird #WERT! "
"zurückgegeben."

#: ../plugins/fn-complex/functions.c:1197
msgid "IMSUM:the sum of the given complex numbers"
msgstr "IMSUM:Die Summe der angegebenen komplexen Zahlen"

#: ../plugins/fn-database/functions.c:45
msgid ""
"database:a range in which rows of related information are records and "
"columns of data are fields"
msgstr ""
"database:Ein Bereich, in dem Zeilen aufeinander bezogener Informationen als "
"Datensätze und Spalten als Felder betrachtet werden"

#: ../plugins/fn-database/functions.c:48
msgid "field:a string or integer specifying which field is to be used"
msgstr ""
"field:Eine Zeichenkette oder Ganzzahl, die das zu verwendende Feld angibt"

#: ../plugins/fn-database/functions.c:50
msgid "criteria:a range containing conditions"
msgstr "criteria:Ein Bereich, der Bedingungen enthält"

#: ../plugins/fn-database/functions.c:52
msgid ""
"@{database} is a range in which rows of related information are records and "
"columns of data are fields. The first row of a database contains labels for "
"each column."
msgstr ""
"@{database} ist ein Bereich, in dem Zeilen aufeinander bezogener "
"Informationen als Datensätze und Spalten als Felder betrachtet werden. Die "
"erste Zeile einer Datenbank enthält Bezeichnungen für jede Spalte."

#: ../plugins/fn-database/functions.c:57
msgid ""
"@{field} is a string or integer specifying which field is to be used. If @"
"{field} is an integer n then the nth column will be used. If @{field} is a "
"string, then the column with the matching label will be used."
msgstr ""
"@{field} ist eine Zeichenkette oder eine Ganzzahl, die angibt, welches Feld "
"verwendet werden soll. Wenn @{field} eine Ganzzahl n ist, dann wird die n-te "
"Spalte verwendet. Wenn @{field} eine Zeichenkette ist, dann wird die so "
"beschriftete Spalte verwendet."

#: ../plugins/fn-database/functions.c:62
msgid ""
"@{criteria} is a range containing conditions. The first row of a @{criteria} "
"should contain labels. Each label specifies to which field the conditions "
"given in that column apply. Each cell below the label specifies a condition "
"such as \">3\" or \"<9\". An equality condition can be given by simply "
"specifying a value, e. g. \"3\" or \"Jody\". For a record to be considered "
"it must satisfy all conditions in at least one of the rows of @{criteria}."
msgstr ""
"@{criteria} ist ein Bereich mit Bedingungen. Die erste Zeile von @{criteria} "
"enthält Bezeichnungen. Jede Bezeichnung legt fest, für welches Feld die "
"Bedingungen in dieser Spalte zutreffen. Jede Zelle unter der Bezeichnung "
"definiert eine Bedingung wie z.B. »>3« oder »<9«. Eine Gleichheitsbedingung "
"kann einfach durch Angabe eines Wertes angegeben werden, wie z.B. »3« oder "
"»Jody«. Damit ein Dateneintrag berücksichtigt wird, müssen alle Bedingungen "
"mindestens einer Zeile der @{criteria} erfüllt werden."

#: ../plugins/fn-database/functions.c:73
msgid ""
"Let us assume that the range A1:C7 contain the following values:\n"
"\n"
"Name    \tAge     \tSalary\n"
"John    \t34      \t54342\n"
"Bill    \t35      \t22343\n"
"Clark   \t29      \t34323\n"
"Bob     \t43      \t47242\n"
"Susan   \t37      \t42932\n"
"Jill    \t\t45      \t45324\n"
"\n"
"In addition, the cells A9:B11 contain the following values:\n"
"Age     \tSalary\n"
"<30\n"
">40     \t>46000\n"
msgstr ""
"Nehmen wir an, dass der Bereich A1:C7 die folgenden Werte enthält:\n"
"\n"
"Name    \tAlter    \tGehalt\n"
"John    \t34      \t54342\n"
"Bill    \t35      \t22343\n"
"Clark   \t29      \t34323\n"
"Bob     \t43      \t47242\n"
"Susan   \t37      \t42932\n"
"Jill    \t\t45      \t45324\n"
"\n"
"Außerdem enthalten die Zellen A9:B11 die folgenden Werte:\n"
"Alter    \tGehalt\n"
"<30\n"
">40     \t>46000\n"

#: ../plugins/fn-database/functions.c:323
msgid ""
"DAVERAGE:average of the values in @{field} in @{database} belonging to "
"records that match @{criteria}"
msgstr ""
"DAVERAGE:Durchschnitt der Werte in @{field} in @{database} bezogen auf "
"Datensätze, die auf @{criteria} passen"

#: ../plugins/fn-database/functions.c:332
msgid "DAVERAGE(A1:C7, \"Salary\", A9:A11) equals 42296.3333."
msgstr "DAVERAGE(A1:C7; \"Gehalt\"; A9:A11) ist gleich 42296.3333."

#: ../plugins/fn-database/functions.c:333
msgid "DAVERAGE(A1:C7, \"Age\", A9:A11) equals 39."
msgstr "DAVERAGE(A1:C7; \"Alter\"; A9:A11) ist gleich 39."

#: ../plugins/fn-database/functions.c:334
msgid "DAVERAGE(A1:C7, \"Salary\", A9:B11) equals 40782.5."
msgstr "DAVERAGE(A1:C7; \"Gehalt\"; A9:B11) ist gleich 40782.5."

#: ../plugins/fn-database/functions.c:335
msgid "DAVERAGE(A1:C7, \"Age\", A9:B11) equals 36."
msgstr "DAVERAGE(A1:C7; \"Alter\"; A9:B11) ist gleich 36."

#: ../plugins/fn-database/functions.c:359
msgid ""
"DCOUNT:count of numbers in @{field} in @{database} belonging to records that "
"match @{criteria}"
msgstr ""
"DCOUNT:Anzahl der Zahlen in @{field} in @{database}, die zu Datensätzen "
"gehören, die mit @{criteria} übereinstimmen"

#: ../plugins/fn-database/functions.c:368
msgid "DCOUNT(A1:C7, \"Salary\", A9:A11) equals 3."
msgstr "DCOUNT(A1:C7; \"Gehalt\"; A9:A11) ist gleich 3."

#: ../plugins/fn-database/functions.c:369
msgid "DCOUNT(A1:C7, \"Salary\", A9:B11) equals 2."
msgstr "DCOUNT(A1:C7; \"Gehalt\"; A9:A11) ist gleich 2."

#: ../plugins/fn-database/functions.c:370
msgid "DCOUNT(A1:C7, \"Name\", A9:B11) equals 0."
msgstr "DCOUNT(A1:C7, \"Name\", A9:B11) ist gleich 0."

#: ../plugins/fn-database/functions.c:394
msgid ""
"DCOUNTA:count of cells with data in @{field} in @{database} belonging to "
"records that match @{criteria}"
msgstr ""
"DCOUNTA:Anzahl der Zellen mit Daten in @{field} in @{database}, die zu "
"Datensätzen gehören, die mit @{criteria} übereinstimmen"

#: ../plugins/fn-database/functions.c:403
msgid "DCOUNTA(A1:C7, \"Salary\", A9:A11) equals 3."
msgstr "DCOUNTA(A1:C7; \"Gehalt\"; A9:A11) ist gleich 3."

#: ../plugins/fn-database/functions.c:404
msgid "DCOUNTA(A1:C7, \"Salary\", A9:B11) equals 2."
msgstr "DCOUNTA(A1:C7; \"Gehalt\"; A9:B11) ist gleich 2."

#: ../plugins/fn-database/functions.c:405
msgid "DCOUNTA(A1:C7, \"Name\", A9:B11) equals 2."
msgstr "DCOUNTA(A1:C7, \"Name\", A9:B11) ist gleich 2."

#: ../plugins/fn-database/functions.c:426
msgid ""
"DGET:a value from @{field} in @{database} belonging to records that match @"
"{criteria}"
msgstr ""
"DGET:Wert aus @{field} in @{database} bezogen auf Datensätze, die auf @"
"{criteria} passen"

#: ../plugins/fn-database/functions.c:435
msgid "If none of the records match the conditions, DGET returns #VALUE!"
msgstr ""
"Falls keiner der Datensätze die Bedingungen erfüllt, gibt DGET #WERT! zurück"

#: ../plugins/fn-database/functions.c:436
msgid "If more than one record match the conditions, DGET returns #NUM!"
msgstr ""
"Falls mehr als ein Datensatz die Bedingungen erfüllt, gibt DGET #ZAHL! zurück"

#: ../plugins/fn-database/functions.c:437
msgid "DGET(A1:C7, \"Salary\", A9:A10) equals 34323."
msgstr "DGET(A1:C7; \"Gehalt\"; A9:A10) ist gleich 34323."

#: ../plugins/fn-database/functions.c:438
msgid "DGET(A1:C7, \"Name\", A9:A10) equals \"Clark\"."
msgstr "DGET(A1:C7; \"Name\"; A9:A10) ist gleich \"Clark\"."

#: ../plugins/fn-database/functions.c:467
msgid ""
"DMAX:largest number in @{field} in @{database} belonging to a record that "
"match @{criteria}"
msgstr ""
"DMAX:Größte Zahl in @{field} in @{database} bezogen auf einen Datensatz, der "
"auf @{criteria} passt"

#: ../plugins/fn-database/functions.c:476
msgid "DMAX(A1:C7, \"Salary\", A9:A11) equals 47242."
msgstr "DMAX(A1:C7; \"Gehalt\"; A9:A11) ist gleich 47242."

#: ../plugins/fn-database/functions.c:477
msgid "DMAX(A1:C7, \"Age\", A9:A11) equals 45."
msgstr "DMAX(A1:C7; \"Alter\"; A9:A11) ist gleich 45."

#: ../plugins/fn-database/functions.c:478
msgid "DMAX(A1:C7, \"Age\", A9:B11) equals 43."
msgstr "DMAX(A1:C7; \"Alter\"; A9:B11) ist gleich 43."

#: ../plugins/fn-database/functions.c:503
msgid ""
"DMIN:smallest number in @{field} in @{database} belonging to a record that "
"match @{criteria}"
msgstr ""
"DMIN:Kleinste Zahl in @{field} in @{database} bezogen auf einen Datensatz, "
"der auf @{criteria} passt"

#: ../plugins/fn-database/functions.c:512
msgid "DMIN(A1:C7, \"Salary\", A9:B11) equals 34323."
msgstr "DMIN(A1:C7; \"Gehalt\"; A9:B11) ist gleich 34323."

#: ../plugins/fn-database/functions.c:513
msgid "DMIN(A1:C7, \"Age\", A9:B11) equals 29."
msgstr "DMIN(A1:C7; \"Alter\"; A9:B11) ist gleich 29."

#: ../plugins/fn-database/functions.c:536
msgid ""
"DPRODUCT:product of all values in @{field} in @{database} belonging to "
"records that match @{criteria}"
msgstr ""
"DPRODUCT:Produkt aller Werte in @{field} in @{database} bezogen auf "
"Datensätze, die auf @{criteria} passen"

#: ../plugins/fn-database/functions.c:545
msgid "DPRODUCT(A1:C7, \"Age\", A9:B11) equals 1247."
msgstr "DPRODUCT(A1:C7; \"Alter\"; A9:B11) ist gleich 1247."

#: ../plugins/fn-database/functions.c:569
msgid ""
"DSTDEV:sample standard deviation of the values in @{field} in @{database} "
"belonging to records that match @{criteria}"
msgstr ""
"DSTDEV:empirische Standardabweichung der Werte in @{field} in @{database}, "
"die zu Datensätzen gehören, die das Kriterium @{criteria} erfüllen."

#: ../plugins/fn-database/functions.c:578
msgid "DSTDEV(A1:C7, \"Age\", A9:B11) equals 9.89949."
msgstr "DSTDEV(A1:C7; \"Alter\"; A9:B11) ist gleich 9.89949."

#: ../plugins/fn-database/functions.c:579
msgid "DSTDEV(A1:C7, \"Salary\", A9:B11) equals 9135.112506."
msgstr "DSTDEV(A1:C7; \"Gehalt\"; A9:B11) ist gleich 9135.112506."

#: ../plugins/fn-database/functions.c:602
msgid ""
"DSTDEVP:standard deviation of the population of values in @{field} in @"
"{database} belonging to records that match @{criteria}"
msgstr ""
"DSTDEVP: Standardabweichung der Population der Werte in @{field} in @"
"{database}, die zu Datensätzen gehören, die @{criteria} erfüllen."

#: ../plugins/fn-database/functions.c:612
msgid "DSTDEVP(A1:C7, \"Age\", A9:B11) equals 7."
msgstr "DSTDEVP(A1:C7; \"Alter\"; A9:B11) ist gleich 7."

#: ../plugins/fn-database/functions.c:613
msgid "DSTDEVP(A1:C7, \"Salary\", A9:B11) equals 6459.5."
msgstr "DSTDEVP(A1:C7; \"Gehalt\"; A9:B11) ist gleich 6459.5."

#: ../plugins/fn-database/functions.c:636
msgid ""
"DSUM:sum of the values in @{field} in @{database} belonging to records that "
"match @{criteria}"
msgstr ""
"DSUM:Summe aller Werte in @{field} in @{database} bezogen auf Datensätze, "
"die auf @{criteria} passen"

#: ../plugins/fn-database/functions.c:645
msgid "DSUM(A1:C7, \"Age\", A9:B11) equals 72."
msgstr "DSUM(A1:C7; \"Alter\"; A9:B11) ist gleich 72."

#: ../plugins/fn-database/functions.c:646
msgid "DSUM(A1:C7, \"Salary\", A9:B11) equals 81565."
msgstr "DSUM(A1:C7; \"Gehalt\"; A9:B11) ist gleich 81565."

#: ../plugins/fn-database/functions.c:670
msgid ""
"DVAR:sample variance of the values in @{field} in @{database} belonging to "
"records that match @{criteria}"
msgstr ""
"DVAR: Beispielabweichung der Werte in @{field} in @{database}, die zu "
"Datensätzen gehören, die @{criteria} erfüllen."

#: ../plugins/fn-database/functions.c:679
msgid "DVAR(A1:C7, \"Age\", A9:B11) equals 98."
msgstr "DVAR(A1:C7; \"Alter\"; A9:B11) ist gleich 98."

#: ../plugins/fn-database/functions.c:680
msgid "DVAR(A1:C7, \"Salary\", A9:B11) equals 83450280.5."
msgstr "DVAR(A1:C7; \"Gehalt\"; A9:B11) ist gleich 83450280.5."

#: ../plugins/fn-database/functions.c:703
msgid ""
"DVARP:variance of the population of values in @{field} in @{database} "
"belonging to records that match @{criteria}"
msgstr ""
"DVARP: Abweichung der Population der Werte in @{field} in @{database}, die "
"zu Datensätzen gehören, die @{criteria} erfüllen."

#: ../plugins/fn-database/functions.c:713
msgid "DVARP(A1:C7, \"Age\", A9:B11) equals 49."
msgstr "DVARP(A1:C7; \"Alter\"; A9:B11) ist gleich 49."

#: ../plugins/fn-database/functions.c:714
msgid "DVARP(A1:C7, \"Salary\", A9:B11) equals 41725140.25."
msgstr "DVARP(A1:C7; \"Gehalt\"; A9:B11) ist gleich 41725140.25."

#: ../plugins/fn-database/functions.c:737
msgid "GETPIVOTDATA:summary data from a pivot table"
msgstr "GETPIVOTDATA:Zusammenfassende Daten einer Pivot-Tabelle"

#: ../plugins/fn-database/functions.c:738
msgid "pivot_table:cell range containing the pivot table"
msgstr "pivot_table:Zellenbereich, der die Pivot-Tabelle enthält"

#: ../plugins/fn-database/functions.c:739
msgid "field_name:name of the field for which the summary data is requested"
msgstr ""
"field_name:Name des Feldes, für das die Datenzusammenfassung abgefragt wird"

#: ../plugins/fn-database/functions.c:740
msgid "If the summary data is unavailable, GETPIVOTDATA returns #REF!"
msgstr ""
"Falls die Datenzusammenfassung nicht verfügbar ist, gibt GETPIVOTDATA "
"#BEZUG! zurück."

#: ../plugins/fn-date/functions.c:74
msgid "DATE:create a date serial value"
msgstr "DATE:erstellt einen seriellen Datumswert"

#: ../plugins/fn-date/functions.c:75
msgid "year:year of date"
msgstr "year:Jahr des Datums"

#: ../plugins/fn-date/functions.c:76
msgid "month:month of year"
msgstr "month:Monat des Jahres"

#: ../plugins/fn-date/functions.c:77
msgid "day:day of month"
msgstr "day:Tag des Monats"

#: ../plugins/fn-date/functions.c:78
msgid ""
"The DATE function creates date serial values.  1-Jan-1900 is serial value 1, "
"2-Jan-1900 is serial value 2, and so on.  For compatibility reasons, a "
"serial value is reserved for the non-existing date 29-Feb-1900."
msgstr ""
"Die Funktion DATE erzeugt serielle Datumswerte. Der 1. Januar 1900 "
"entspricht dem seriellen Wert 1, der 2. Januar dem seriellen Wert 2 usw. Aus "
"Kompatibilitätsgründen ist ein serieller Wert reserviert für das nicht "
"existierende Datum 29. Februar 1900."

#: ../plugins/fn-date/functions.c:79
msgid ""
"If @{month} or @{day} is less than 1 or too big, then the year and/or month "
"will be adjusted."
msgstr ""
"Falls @{month} oder @{day} kleiner als 1 oder zu groß ist, werden Jahr und/"
"oder Monat entsprechend angepasst."

#: ../plugins/fn-date/functions.c:80
msgid ""
"For spreadsheets created with the Mac version of Excel, serial 1 is 1-"
"Jan-1904."
msgstr ""
"Für Tabellendokumente, die mit der Mac-Version von Excel erstellt wurden, "
"bezeichnet die serielle 1 den 1. Januar 1904."

#: ../plugins/fn-date/functions.c:137
msgid "UNIX2DATE:date value corresponding to the Unix timestamp @{t}"
msgstr "UNIX2DATE:einen Datumswert von einem Unix-Zeitstempel @{t} erstellen"

#: ../plugins/fn-date/functions.c:138
msgid "t:Unix time stamp"
msgstr "t:Unix-Zeitstempel"

#: ../plugins/fn-date/functions.c:139
msgid ""
"The UNIX2DATE function translates Unix timestamps into the corresponding "
"date.  A Unix timestamp is the number of seconds since midnight (0:00) of "
"January 1st, 1970 GMT."
msgstr ""
"Die Funktion UNIX2DATE wandelt Unix-Zeitstempel in serielle Datumswerte um. "
"Der Unix-Zeitstempel zeigt die Anzahl der Sekunden seit dem 1. Januar 1970, "
"0.00 Uhr GMT."

#: ../plugins/fn-date/functions.c:167
msgid "DATE2UNIX:the Unix timestamp corresponding to a date @{d}"
msgstr "DATE2UNIX:Der Unix-Zeitstempel zum Datum @{d}"

#: ../plugins/fn-date/functions.c:168
msgid "d:date"
msgstr "d:Datum"

#: ../plugins/fn-date/functions.c:169
msgid ""
"The DATE2UNIX function translates a date into a Unix timestamp. A Unix "
"timestamp is the number of seconds since midnight (0:00) of January 1st, "
"1970 GMT."
msgstr ""
"Die Funktion DATE2UNIX wandelt serielle Datumswerte in Unix-Zeitstempel um. "
"Der Unix-Zeitstempel zeigt die Anzahl der Sekunden seit dem 1. Januar 1970, "
"0.00 Uhr GMT."

#: ../plugins/fn-date/functions.c:193
msgid "DATEVALUE:the date part of a date and time serial value"
msgstr "DATEVALUE:Der Datumsteil des seriellen Datums- und Zeitwertes"

#: ../plugins/fn-date/functions.c:194 ../plugins/fn-date/functions.c:489
msgid "serial:date and time serial value"
msgstr "serial:serieller Wert für Datum und Zeit"

#: ../plugins/fn-date/functions.c:195
msgid ""
"DATEVALUE returns the date serial value part of a date and time serial value."
msgstr ""
"DATEVALUE gibt den Datumsteil des seriellen Datums- und Zeitwertes zurück."

#: ../plugins/fn-date/functions.c:211
msgid "DATEDIF:difference between dates"
msgstr "DATEDIF:Differenz zwischen Daten"

#: ../plugins/fn-date/functions.c:212 ../plugins/fn-date/functions.c:689
#: ../plugins/fn-date/functions.c:994 ../plugins/fn-date/functions.c:1260
#: ../plugins/fn-date/functions.c:1290
msgid "start_date:starting date serial value"
msgstr "start_date:Startdatum des seriellen Wertes"

#: ../plugins/fn-date/functions.c:213 ../plugins/fn-date/functions.c:690
#: ../plugins/fn-date/functions.c:995 ../plugins/fn-date/functions.c:1261
#: ../plugins/fn-date/functions.c:1289
msgid "end_date:ending date serial value"
msgstr "end_date:Enddatum des seriellen Wertes"

#: ../plugins/fn-date/functions.c:214
msgid "interval:counting unit"
msgstr "interval:Zähleinheit"

#: ../plugins/fn-date/functions.c:215
msgid ""
"DATEDIF returns the distance from @{start_date} to @{end_date} according to "
"the unit specified by @{interval}."
msgstr ""
"DATEDIF gibt den Unterschied zwischen @{start_date} und @{end_date} "
"entsprechend der durch @{interval} festgelegten Einheit zurück."

#: ../plugins/fn-date/functions.c:216
msgid ""
"If @{interval} is \"y\", \"m\", or \"d\" then the distance is measured in "
"complete years, months, or days respectively."
msgstr ""
"Wenn @{interval}  »y«, »m« oder »d« ist, dann wird die Differenz "
"entsprechend in vollständigen Jahren, Monaten oder Tagen gemessen."

#: ../plugins/fn-date/functions.c:217
msgid ""
"If @{interval} is \"ym\" or \"yd\" then the distance is measured in complete "
"months or days, respectively, but excluding any difference in years."
msgstr ""
"Wenn @{interval}  »ym« oder »yd« ist, dann wird die Differenz entsprechend "
"in vollständigen Monaten oder Tagen gemessen, aber die Jahresdifferenz wird "
"nicht berücksichtigt."

#: ../plugins/fn-date/functions.c:218
msgid ""
"If @{interval} is \"md\" then the distance is measured in complete days but "
"excluding any difference in months."
msgstr ""
"Wenn @{interval} »md« ist, dann wird die Differenz in vollständigen Tagen "
"gemessen, aber die Monatsdifferenz wird nicht berücksichtigt."

#: ../plugins/fn-date/functions.c:350
msgid "EDATE:adjust a date by a number of months"
msgstr "EDATE:Ein Datum um eine Anzahl Monate anpassen"

#: ../plugins/fn-date/functions.c:351 ../plugins/fn-date/functions.c:577
#: ../plugins/fn-date/functions.c:601 ../plugins/fn-date/functions.c:625
#: ../plugins/fn-date/functions.c:649 ../plugins/fn-date/functions.c:731
#: ../plugins/fn-date/functions.c:771 ../plugins/fn-date/functions.c:1161
#: ../plugins/fn-date/functions.c:1185 ../plugins/fn-date/functions.c:1221
msgid "date:date serial value"
msgstr "date:serieller Datumswert"

#: ../plugins/fn-date/functions.c:352 ../plugins/fn-date/functions.c:732
msgid "months:signed number of months"
msgstr "months:Vorzeichenbehaftete Zahl von Monaten"

#: ../plugins/fn-date/functions.c:353
msgid ""
"EDATE returns @{date} moved forward or backward the number of months "
"specified by @{months}."
msgstr ""
"EDATE gibt @{date} um die mit @{months} angegebenen Monate verschoben zurück."

#: ../plugins/fn-date/functions.c:387
msgid "TODAY:the date serial value of today"
msgstr "TODAY:Der serielle Datumswert des heutigen Tages"

#: ../plugins/fn-date/functions.c:388
msgid ""
"The TODAY function returns the date serial value of the day it is computed.  "
"Recomputing on a later date will produce a different value."
msgstr ""
"Die Funktion TODAY gibt den seriellen Datumswert des heutigen Tages zurück. "
"Eine Neuberechnung zu einem späteren Zeitpunkt erzeugt einen neuen Wert."

#: ../plugins/fn-date/functions.c:404
msgid "NOW:the date and time serial value of the current time"
msgstr "NOW:Der serielle Wert für Datum und Zeit zum aktuellen Zeitpunkt"

#: ../plugins/fn-date/functions.c:405
msgid ""
"The NOW function returns the date and time serial value of the moment it is "
"computed.  Recomputing later will produce a different value."
msgstr ""
"Die Funktion NOW gibt den seriellen Wert für Datum und Zeit zum aktuellen "
"Zeitpunkt zurück. Eine Neuberechnung zu einem späteren Zeitpunkt erzeugt "
"einen neuen Wert."

#: ../plugins/fn-date/functions.c:421
msgid "TIME:create a time serial value"
msgstr "TIME:Einen seriellen Zeitwert erzeugen"

#: ../plugins/fn-date/functions.c:422
msgid "hour:hour of the day"
msgstr "hour:Stunde des Tages"

#: ../plugins/fn-date/functions.c:423
msgid "minute:minute within the hour"
msgstr "minute:Minute innerhalb der Stunde"

#: ../plugins/fn-date/functions.c:424
msgid "second:second within the minute"
msgstr "second:Sekunde innerhalb der Minute"

#: ../plugins/fn-date/functions.c:425
msgid ""
"The TIME function computes the fractional day after midnight at the time "
"given by @{hour}, @{minute}, and @{second}."
msgstr ""
"Die Funktion TIME berechnet den anteiligen Tag nach Mitternacht zu der durch "
"@{hour}, @{minute} und @{second} angegebenen Zeit."

#: ../plugins/fn-date/functions.c:426
msgid ""
"While the return value is automatically formatted to look like a time "
"between 0:00 and 24:00, the underlying serial time value is a number between "
"0 and 1."
msgstr ""
"Während der Rückgabewert automatisch so formatiert wird, dass er eine "
"Uhrzeit zwischen 0:00 und 24:00 Uhr ist, ist der zugrunde liegende serielle "
"Uhrzeitwert eine Zahl zwischen 0 und 1."

#: ../plugins/fn-date/functions.c:428
msgid ""
"If any of @{hour}, @{minute}, and @{second} is negative, #NUM! is returned"
msgstr ""
"Falls eines von @{hour}, @{minute} oder @{second} negativ ist, so wird "
"#ZAHL! zurückgegeben"

#: ../plugins/fn-date/functions.c:458
msgid "ODF.TIME:create a time serial value"
msgstr "ODF.TIME:Einen seriellen Zeitwert erzeugen"

#: ../plugins/fn-date/functions.c:459
msgid "hour:hour"
msgstr "hour:Stunde"

#: ../plugins/fn-date/functions.c:460
msgid "minute:minute"
msgstr "minute:Minute"

#: ../plugins/fn-date/functions.c:461
msgid "second:second"
msgstr "second:Sekunde"

#: ../plugins/fn-date/functions.c:462
msgid ""
"The ODF.TIME function computes the time given by @{hour}, @{minute}, and @"
"{second} as a fraction of a day."
msgstr ""
"Die Funktion ODF.TIME berechnet den anteiligen Tag der durch @{hour}, @"
"{minute} und @{second} angegebenen Zeit."

#: ../plugins/fn-date/functions.c:463
msgid ""
"While the return value is automatically formatted to look like a time "
"between 0:00 and 24:00, the underlying serial time value can be any number."
msgstr ""
"Während der Rückgabewert automatisch so formatiert wird, dass er eine "
"Uhrzeit zwischen 0:00 und 24:00 Uhr ist, kann der zugrunde liegende serielle "
"Uhrzeitwert irgendeine Zahl sein."

#: ../plugins/fn-date/functions.c:467 ../plugins/fn-date/functions.c:780
#: ../plugins/fn-date/functions.c:1002 ../plugins/fn-date/functions.c:1292
#: ../plugins/fn-eng/functions.c:211 ../plugins/fn-eng/functions.c:315
#: ../plugins/fn-eng/functions.c:384 ../plugins/fn-eng/functions.c:752
#: ../plugins/fn-financial/functions.c:1312 ../plugins/fn-math/functions.c:433
#: ../plugins/fn-math/functions.c:1033 ../plugins/fn-math/functions.c:1060
#: ../plugins/fn-math/functions.c:1411 ../plugins/fn-math/functions.c:1431
#: ../plugins/fn-math/functions.c:2099 ../plugins/fn-math/functions.c:2763
#: ../plugins/fn-math/functions.c:2962 ../plugins/fn-stat/functions.c:1606
#: ../plugins/fn-stat/functions.c:2479 ../plugins/fn-stat/functions.c:4667
#: ../plugins/fn-string/functions.c:304 ../plugins/fn-string/functions.c:388
#: ../plugins/fn-string/functions.c:515 ../plugins/fn-string/functions.c:1103
#: ../plugins/fn-string/functions.c:1445 ../plugins/fn-string/functions.c:1575
msgid "This function is OpenFormula compatible."
msgstr "Diese Funktion ist OpenFormula-kompatibel."

#: ../plugins/fn-date/functions.c:488
msgid "TIMEVALUE:the time part of a date and time serial value"
msgstr "TIMEVALUE:Der Zeitanteil des seriellen Wertes für Datum und Zeit"

#: ../plugins/fn-date/functions.c:490
msgid "TIMEVALUE returns the time-of-day part of a date and time serial value."
msgstr ""
"TIMEVALUE gibt den Zeitanteil des seriellen Wertes für Datum und Zeit zurück."

#: ../plugins/fn-date/functions.c:507
msgid "HOUR:compute hour part of fractional day"
msgstr "HOUR:berechnet die Stunden des anteiligen Tages"

#: ../plugins/fn-date/functions.c:508 ../plugins/fn-date/functions.c:531
#: ../plugins/fn-date/functions.c:554
msgid "time:time of day as fractional day"
msgstr "Zeit:die Tageszeit als anteiliger Tag."

#: ../plugins/fn-date/functions.c:509
msgid ""
"The HOUR function computes the hour part of the fractional day given by @"
"{time}."
msgstr ""
"Die Funktion HOUR berechnet die Stunden des anteiligen Tages, der durch @"
"{Zeit} gegebenen ist."

#: ../plugins/fn-date/functions.c:530
msgid "MINUTE:compute minute part of fractional day"
msgstr "MINUTE:berechnet die Minuten des anteiligen Tages"

#: ../plugins/fn-date/functions.c:532
msgid ""
"The MINUTE function computes the minute part of the fractional day given by @"
"{time}."
msgstr ""
"Die Funktion MINUTE berechnet die Minuten des anteiligen Tages, der durch @"
"{Zeit} gegebenen ist."

#: ../plugins/fn-date/functions.c:553
msgid "SECOND:compute seconds part of fractional day"
msgstr "SECOND:berechnet die Sekunden des anteiligen Tages"

#: ../plugins/fn-date/functions.c:555
msgid ""
"The SECOND function computes the seconds part of the fractional day given by "
"@{time}."
msgstr ""
"Die Funktion SECOND berechnet die Sekunden des anteiligen Tages, der durch @"
"{Zeit} gegebenen ist."

#: ../plugins/fn-date/functions.c:576
msgid "YEAR:the year part of a date serial value"
msgstr "YEAR:Der Jahresanteil des seriellen Wertes für das Datum"

#: ../plugins/fn-date/functions.c:578
msgid "The YEAR function returns the year part of @{date}."
msgstr "Die Funktion YEAR gibt den Jahresteil von @{date} zurück."

#: ../plugins/fn-date/functions.c:600
msgid "MONTH:the month part of a date serial value"
msgstr "MONTH:Der Monatsanteil des seriellen Wertes für das Datum"

#: ../plugins/fn-date/functions.c:602
msgid "The MONTH function returns the month part of @{date}."
msgstr "Die Funktion MONTH gibt den Monatsteil von @{date} zurück."

#: ../plugins/fn-date/functions.c:624
msgid "DAY:the day-of-month part of a date serial value"
msgstr "DAY:Der Tagesanteil des seriellen Wertes für das Datum"

#: ../plugins/fn-date/functions.c:626
msgid "The DAY function returns the day-of-month part of @{date}."
msgstr "Die Funktion DAY gibt den Tag des Monats von @{date} zurück."

#: ../plugins/fn-date/functions.c:648
msgid "WEEKDAY:day-of-week"
msgstr "WEEKDAY:Tag der Woche"

#: ../plugins/fn-date/functions.c:650 ../plugins/fn-date/functions.c:1222
msgid "method:numbering system, defaults to 1"
msgstr "Methode:Nummerierungssystem, Vorgabe ist 1"

#: ../plugins/fn-date/functions.c:651
msgid ""
"The WEEKDAY function returns the day-of-week of @{date}.  The value of @"
"{method} determines how days are numbered; it defaults to 1. "
msgstr ""
"Die Funktion WEEKDAY gibt den Tag der Woche zu @{date} zurück. Der Wert von @"
"{Methode} bestimmt, wie die Tage der Woche nummeriert werden, Vorgabe ist 1."

#: ../plugins/fn-date/functions.c:652
msgid "If @{method} is 1, then Sunday is 1, Monday is 2, etc."
msgstr "Falls @{Methode} 1 ist, dann ist Sonntag 1, Montag 2 usw."

#: ../plugins/fn-date/functions.c:653
msgid "If @{method} is 2, then Monday is 1, Tuesday is 2, etc."
msgstr "Falls @{Methode} 2 ist, dann ist Montag 1, Dienstag 2 usw."

#: ../plugins/fn-date/functions.c:654
msgid "If @{method} is 3, then Monday is 0, Tuesday is 1, etc."
msgstr "Falls @{Methode} 3 ist , dann ist Montag 0, Dienstag 1 usw."

#: ../plugins/fn-date/functions.c:688
msgid "DAYS360:days between dates"
msgstr "DAYS360:Tage zwischen Daten"

#: ../plugins/fn-date/functions.c:691
msgid "method:counting method"
msgstr "Methode:Zählmethode"

#: ../plugins/fn-date/functions.c:692
msgid "DAYS360 returns the number of days from @{start_date} to @{end_date}."
msgstr ""
"DAYS360 gibt die Anzahl der Tage von @{start_date} bis @{end_date} zurück."

#: ../plugins/fn-date/functions.c:693
msgid ""
"If @{method} is 0, the default, the MS Excel (tm) US method will be used. "
"This is a somewhat complicated industry standard method where the last day "
"of February is considered to be the 30th day of the month, but only for @"
"{start_date}."
msgstr ""
"Falls @{Methode} 0 ist (Vorgabe), dann die Methode der US-Version von MS "
"Excel (tm) angewendet. Dies ist eine etwas komplizierte, einem "
"Industriestandard folgende Methode, wobei der letzte Tag des Februars als "
"30. Tag des Monats angenommen wird, aber nur für @{start_date}."

#: ../plugins/fn-date/functions.c:694
msgid ""
"If @{method} is 1, the European method will be used.  In this case, if the "
"day of the month is 31 it will be considered as 30"
msgstr ""
"Falls @{Methode} 1 ist, dann wird die europäische Methode benutzt. In diesem "
"Fall wird der Tag des Monats als 30 angenommen, falls dieser 31 ist."

#: ../plugins/fn-date/functions.c:695
msgid ""
"If @{method} is 2, a saner version of the US method is used in which both "
"dates get the same February treatment."
msgstr ""
"Falls @{Methode} 2 ist, so wird eine vernünftigere Version der "
"amerikanischen Methode verwendet, in der beide Daten für Februar gleich "
"behandelt werden."

#: ../plugins/fn-date/functions.c:730
msgid "EOMONTH:end of month"
msgstr "EOMONTH:Ende des Monats"

#: ../plugins/fn-date/functions.c:733
msgid ""
"EOMONTH returns the date serial value of the end of the month specified by @"
"{date} adjusted forward or backward the number of months specified by @"
"{months}."
msgstr ""
"EOMONTH gibt den seriellen Datumswert des durch @{date} angegeben "
"Monatsendes zurück, um @{months} Monate mehr oder weniger angepasst."

#: ../plugins/fn-date/functions.c:770
msgid "WORKDAY:add working days"
msgstr "WORKDAY:Arbeitstage hinzufügen"

#: ../plugins/fn-date/functions.c:772
msgid "days:number of days to add"
msgstr "days:Anzahl der hinzuzufügenden Tage"

#: ../plugins/fn-date/functions.c:773 ../plugins/fn-date/functions.c:996
msgid "holidays:array of holidays"
msgstr "holidays:Feld von Urlaubstagen"

#: ../plugins/fn-date/functions.c:774 ../plugins/fn-date/functions.c:997
msgid ""
"weekend:array of 0s and 1s, indicating whether a weekday (S, M, T, W, T, F, "
"S) is on the weekend, defaults to {1,0,0,0,0,0,1}"
msgstr ""
"weekend:Feld von Nullen und Einsen, die angeben, ob ein Wochentag (S, M, D, "
"M, D, F, S) auf ein Wochenende fällt. Die Voreinstellung lautet "
"{1,0,0,0,0,0,1}"

#: ../plugins/fn-date/functions.c:776
msgid ""
"WORKDAY adjusts @{date} by @{days} skipping over weekends and @{holidays} in "
"the process."
msgstr ""
"WORKDAY passt @{date} um @{days} an, wobei Wochenenden und @{holidays} "
"übersprungen werden."

#: ../plugins/fn-date/functions.c:777
msgid "@{days} may be negative."
msgstr "@{days} kann negativ sein."

#: ../plugins/fn-date/functions.c:778 ../plugins/fn-date/functions.c:1000
msgid ""
"If an entry of @{weekend} is non-zero, the corresponding weekday is not a "
"work day."
msgstr ""
"Wenn ein Eintrag von @{weekend} ungleich Null ist, so ist der entsprechende "
"Wochentag kein Arbeitstag."

#: ../plugins/fn-date/functions.c:779 ../plugins/fn-date/functions.c:1001
msgid "This function is Excel compatible if the last argument is omitted."
msgstr ""
"Diese Funktion ist mit Excel kompatibel, wenn das letzte Argument "
"weggelassen wird."

#: ../plugins/fn-date/functions.c:993
msgid "NETWORKDAYS:number of workdays in range"
msgstr "NETWORKDAYS:Anzahl der Arbeitstage in einem Zeitraum"

#: ../plugins/fn-date/functions.c:999
msgid ""
"NETWORKDAYS calculates the number of days from @{start_date} to @{end_date} "
"skipping weekends and @{holidays} in the process."
msgstr ""
"NETWORKDAYS berechnet die Anzahl der Tage von @{start_date} bis @{end_date}, "
"wobei Wochenenden und @{holidays} übersprungen werden."

#: ../plugins/fn-date/functions.c:1160
msgid "ISOWEEKNUM:ISO week number"
msgstr "ISOWEEKNUM:Wochennummer nach ISO-Standard"

#: ../plugins/fn-date/functions.c:1162
msgid ""
"ISOWEEKNUM calculates the week number according to the ISO 8601 standard.  "
"Weeks start on Mondays and week 1 contains the first Thursday of the year."
msgstr ""
"ISOWEEKNUM berechnet die Wochennummer nach dem Standard ISO 8601.  Wochen "
"beginnen Montags und Woche 1 enthält den ersten Donnerstag des Jahres."

#: ../plugins/fn-date/functions.c:1163 ../plugins/fn-date/functions.c:1187
msgid ""
"January 1 of a year is sometimes in week 52 or 53 of the previous year.  "
"Similarly, December 31 is sometimes in week 1 of the following year."
msgstr ""
"Der 1.Januar eines Jahres ist manchmal in Kalenderwoche 52 oder 53 des "
"vorhergehenden Jahres.  Ähnlich ist der 31.Dezember manchmal in Woche 1 des "
"folgenden Jahres."

#: ../plugins/fn-date/functions.c:1184
msgid "ISOYEAR:year corresponding to the ISO week number"
msgstr "ISOYEAR:das Jahr entsprechend der ISO-Wochenzahl"

#: ../plugins/fn-date/functions.c:1186
msgid ""
"ISOYEAR calculates the year to go with week number according to the ISO 8601 "
"standard."
msgstr ""
"ISOYEAR berechnet das Jahr mit Wochennummer nach dem Standard ISE 8601."

#: ../plugins/fn-date/functions.c:1220
msgid "WEEKNUM:week number"
msgstr "WEEKNUM:Wochennummer"

#: ../plugins/fn-date/functions.c:1223
msgid ""
"WEEKNUM calculates the week number according to @{method} which defaults to "
"1."
msgstr "WEEKNUM berechnet die Wochennummer gemäß @{Methode}, Vorgabe ist 1."

#: ../plugins/fn-date/functions.c:1224
msgid ""
"If @{method} is 1, then weeks start on Sundays and January 1 is in week 1."
msgstr ""
"Falls @{Methode} 1 ist, dann beginnt die Woche am Sonntag und der 1.Januar "
"ist in Kalenderwoche 1."

#: ../plugins/fn-date/functions.c:1225
msgid ""
"If @{method} is 2, then weeks start on Mondays and January 1 is in week 1."
msgstr ""
"Falls @{Methode} 2 ist, dann beginnt die Woche am Montag und der 1.Januar "
"ist in Kalenderwoche 1."

#: ../plugins/fn-date/functions.c:1226
msgid "If @{method} is 150, then the ISO 8601 numbering is used."
msgstr ""
"Falls @{Methode} 150 ist, dann geschieht die Nummerierung gemäß ISO 8601."

#: ../plugins/fn-date/functions.c:1259
msgid "YEARFRAC:fractional number of years between dates"
msgstr "YEARFRAC:anteilige Anzahl Jahre zwischen Daten"

#: ../plugins/fn-date/functions.c:1262 ../plugins/fn-financial/functions.c:454
#: ../plugins/fn-financial/functions.c:492
#: ../plugins/fn-financial/functions.c:530
#: ../plugins/fn-financial/functions.c:571
#: ../plugins/fn-financial/functions.c:608
#: ../plugins/fn-financial/functions.c:652
#: ../plugins/fn-financial/functions.c:1895
#: ../plugins/fn-financial/functions.c:2261
#: ../plugins/fn-financial/functions.c:2311
#: ../plugins/fn-financial/functions.c:2418
#: ../plugins/fn-financial/functions.c:2464
#: ../plugins/fn-financial/functions.c:2506
#: ../plugins/fn-financial/functions.c:2656
#: ../plugins/fn-financial/functions.c:2751
#: ../plugins/fn-financial/functions.c:2829
#: ../plugins/fn-financial/functions.c:2906
#: ../plugins/fn-financial/functions.c:2962
#: ../plugins/fn-financial/functions.c:3005
#: ../plugins/fn-financial/functions.c:3029
#: ../plugins/fn-financial/functions.c:3053
#: ../plugins/fn-financial/functions.c:3077
#: ../plugins/fn-financial/functions.c:3103
#: ../plugins/fn-financial/functions.c:3129
#: ../plugins/fn-financial/functions.c:3243
msgid "basis:calendar basis"
msgstr "basis:Kalenderbasis"

#: ../plugins/fn-date/functions.c:1263
msgid ""
"YEARFRAC calculates the number of days from @{start_date} to @{end_date} "
"according to the calendar specified by @{basis}, which defaults to 0, and "
"expresses the result as a fractional number of years."
msgstr ""
"YEARFRAC berechnet die Zahl der Tage von @{start_date} bis @{end_date} "
"entsprechend dem in @{basis} festgelegten Kalender, der auf 0 voreingestellt "
"ist. Das Ergebnis wird als gebrochene Zahl in Jahren angegeben."

#: ../plugins/fn-date/functions.c:1288
msgid "DAYS:difference between dates in days"
msgstr "DAYS:Differenz zwischen Daten in Tagen"

#: ../plugins/fn-date/functions.c:1291
msgid ""
"DAYS returns the positive or negative number of days from @{start_date} to @"
"{end_date}."
msgstr ""
"DAYS gibt die positive oder negative Anzahl der Tage von @{start_date} bis @"
"{end_date} zurück."

#. Some common decriptors
#: ../plugins/fn-derivatives/options.c:46
msgid "call_put_flag:'c' for a call and 'p' for a put"
msgstr "call_put_flag: »c« für Call und »p« für einen Put"

#: ../plugins/fn-derivatives/options.c:47
msgid "spot:spot price"
msgstr "spot:Barpreis"

#: ../plugins/fn-derivatives/options.c:48
msgid "strike:strike price"
msgstr "strike:Basispreis"

#: ../plugins/fn-derivatives/options.c:49
msgid "time:time to maturity in years"
msgstr "Zeit:Zeit bis zur Fälligkeit in Jahren"

#: ../plugins/fn-derivatives/options.c:50
msgid "time:time to maturity in days"
msgstr "Zeit:Zeit bis zur Fälligkeit in Tagen"

#: ../plugins/fn-derivatives/options.c:51
msgid "time_payout:time to dividend payout"
msgstr "time_payout:Zeit bis zur Auszahlung der Dividende"

#: ../plugins/fn-derivatives/options.c:52
msgid "time_exp:time to expiration"
msgstr "time_exp:Zeit bis zum Ablauf"

#: ../plugins/fn-derivatives/options.c:53
msgid "rate:risk-free interest rate to the exercise date in percent"
msgstr "rate:Risikofreier Zinssatz zum Ausübungstag in Prozent"

#: ../plugins/fn-derivatives/options.c:54
msgid "rate:annualized interest rate"
msgstr "rate:auf das Jahr bezogener Zinssatz"

#: ../plugins/fn-derivatives/options.c:55
msgid "rate:annualized risk-free interest rate"
msgstr "rate:auf das Jahr bezogener risikofreier Zinssatz"

#: ../plugins/fn-derivatives/options.c:56
msgid ""
"volatility:annualized volatility of the asset in percent for the period "
"through to the exercise date"
msgstr ""
"volatility:Auf das Jahr bezogene Volatilität des Vermögenswerts in Prozent "
"für den Zeitraum bis zum Ausübungstag"

#: ../plugins/fn-derivatives/options.c:57
msgid "volatility:annualized volatility of the asset"
msgstr "volatility:auf das Jahr bezogene Volatilität des Vermögenswerts"

#: ../plugins/fn-derivatives/options.c:58
msgid "d:amount of the dividend to be paid expressed in currency"
msgstr "d:Auszuzahlende Dividende, ausgedrückt als Währung"

#: ../plugins/fn-derivatives/options.c:59
#, fuzzy
msgid ""
"cost_of_carry:net cost of holding the underlying asset (for common stocks, "
"the risk free rate less the dividend yield), defaults to 0"
msgstr ""
"cost_of_carry: Nettokosten zum Halten des Vermögenswerts (?), defaults to 0"

#: ../plugins/fn-derivatives/options.c:60
msgid "cost_of_carry:net cost of holding the underlying asset"
msgstr "cost_of_carry: Nettokosten zum Halten des Vermögenswerts"

#: ../plugins/fn-derivatives/options.c:62
msgid ""
"The returned value will be expressed in the same units as @{strike} and @"
"{spot}."
msgstr ""
"Der zurückgegebene Wert wird in den gleichen Einheiten wie @{strike} und @"
"{spot} ausgedrückt."

#: ../plugins/fn-derivatives/options.c:192
msgid "CUM_BIV_NORM_DIST:cumulative bivariate normal distribution"
msgstr ""

#: ../plugins/fn-derivatives/options.c:193
msgid "a:limit for first random variable"
msgstr "a:Grenzwert für die erste Zufallsvariable"

#: ../plugins/fn-derivatives/options.c:194
msgid "b:limit for second random variable"
msgstr "b:Grenzwert für die zweite Zufallsvariable"

#: ../plugins/fn-derivatives/options.c:195
msgid "rho:correlation of the two random variables"
msgstr "rho:Korrelation der zwei Zufallsvariablen"

#: ../plugins/fn-derivatives/options.c:196
msgid ""
"CUM_BIV_NORM_DIST calculates the probability that two standard normal "
"distributed random variables with correlation @{rho} are respectively each "
"less than @{a} and @{b}."
msgstr ""

#: ../plugins/fn-derivatives/options.c:245
msgid "OPT_BS:price of a European option"
msgstr "OPT_BS:Preis einer europäischen Kaufoption"

#: ../plugins/fn-derivatives/options.c:253
msgid ""
"OPT_BS uses the Black-Scholes model to calculate the price of a European "
"option struck at @{strike} on an asset with spot price @{spot}."
msgstr ""

#: ../plugins/fn-derivatives/options.c:302
msgid "OPT_BS_DELTA:delta of a European option"
msgstr "OPT_BS_DELTA:Delta  einer europäischen Kaufoption"

#: ../plugins/fn-derivatives/options.c:310
msgid ""
"OPT_BS_DELTA uses the Black-Scholes model to calculate the 'delta' of a "
"European option struck at @{strike} on an asset with spot price @{spot}."
msgstr ""

#: ../plugins/fn-derivatives/options.c:344
msgid "OPT_BS_GAMMA:gamma of a European option"
msgstr "OPT_BS_GAMMA:Gamma einer europäischen Kaufoption"

#: ../plugins/fn-derivatives/options.c:351
msgid ""
"OPT_BS_GAMMA uses the Black-Scholes model to calculate the 'gamma' of a "
"European option struck at @{strike} on an asset with spot price @{spot}. The "
"gamma of an option is the second derivative of its price with respect to the "
"price of the underlying asset."
msgstr ""

#: ../plugins/fn-derivatives/options.c:356
msgid ""
"Gamma is expressed as the rate of change of delta per unit change in @{spot}."
msgstr ""
"Gamma wird angegeben als die Änderungsrate des Delta pro Einheitenwechsel in "
"@{spot}."

#: ../plugins/fn-derivatives/options.c:358
msgid "Gamma is the same for calls and puts."
msgstr "Gamma ist das gleiche für Calls und Puts."

#: ../plugins/fn-derivatives/options.c:401
msgid "OPT_BS_THETA:theta of a European option"
msgstr "OPT_BS_THETA:Theta einer europäischen Kaufoption"

#: ../plugins/fn-derivatives/options.c:409
msgid ""
"OPT_BS_THETA uses the Black-Scholes model to calculate the 'theta' of a "
"European option struck at @{strike} on an asset with spot price @{spot}. The "
"theta of an option is the rate of change of its price with respect to time "
"to expiry."
msgstr ""

#: ../plugins/fn-derivatives/options.c:414
msgid ""
"Theta is expressed as the negative of the rate of change of the option "
"value, per 365.25 days."
msgstr ""
"Theta wird als die negative Änderungsrate des Optionswerts je 365,25 Tage "
"angegeben."

#: ../plugins/fn-derivatives/options.c:445
msgid "OPT_BS_VEGA:vega of a European option"
msgstr "OPT_BS_VEGA:Vega einer europäischen Kaufoption"

#: ../plugins/fn-derivatives/options.c:452
msgid ""
"OPT_BS_VEGA uses the Black-Scholes model to calculate the 'vega' of a "
"European option struck at @{strike} on an asset with spot price @{spot}. The "
"vega of an option is the rate of change of its price with respect to "
"volatility."
msgstr ""

#: ../plugins/fn-derivatives/options.c:457
msgid "Vega is the same for calls and puts."
msgstr "Wega ist das gleiche für Calls und Puts."

#: ../plugins/fn-derivatives/options.c:459
#, no-c-format
msgid ""
"Vega is expressed as the rate of change of option value, per 100% volatility."
msgstr ""
"Vega wird als die Änderungsrate des Optionswerts je 100% Volatilität "
"angegeben."

#: ../plugins/fn-derivatives/options.c:510
msgid "OPT_BS_RHO:rho of a European option"
msgstr "OPT_BS_RHO:Rho einer europäischen Kaufoption"

#: ../plugins/fn-derivatives/options.c:518
msgid ""
"OPT_BS_RHO uses the Black-Scholes model to calculate the 'rho' of a European "
"option struck at @{strike} on an asset with spot price @{spot}. The rho of "
"an option is the rate of change of its price with respect to the risk free "
"interest rate."
msgstr ""

#: ../plugins/fn-derivatives/options.c:524
#, no-c-format
msgid ""
"Rho is expressed as the rate of change of the option value, per 100% change "
"in @{rate}."
msgstr ""
"Rho wird als die Änderungsrate des Optionswerts je 100% Wechsel in @{rate} "
"angegeben."

#: ../plugins/fn-derivatives/options.c:566
msgid "OPT_BS_CARRYCOST:elasticity of a European option"
msgstr "OPT_BS_CARRYCOST:Elastizität einer europäischen Kaufoption"

#: ../plugins/fn-derivatives/options.c:574
msgid ""
"OPT_BS_CARRYCOST uses the Black-Scholes model to calculate the 'elasticity' "
"of a European option struck at @{strike} on an asset with spot price @"
"{spot}. The elasticity of an option is the rate of change of its price with "
"respect to its @{cost_of_carry}."
msgstr ""

#: ../plugins/fn-derivatives/options.c:580
#, no-c-format
msgid ""
"Elasticity is expressed as the rate of change of the option value, per 100% "
"volatility."
msgstr ""
"Elastizität wird als die Änderungsrate des Optionswerts je 100% "
"Preisschwankung ausgedrückt."

#: ../plugins/fn-derivatives/options.c:624
msgid "OPT_GARMAN_KOHLHAGEN:theoretical price of a European currency option"
msgstr ""
"OPT_GARMAN_KOHLHAGEN: Theoretischer Preis der europäischen Währungs-Option"

#: ../plugins/fn-derivatives/options.c:628
msgid "time:number of days to exercise"
msgstr "Zeit:Anzahl der Tage zur Beschaffung"

#: ../plugins/fn-derivatives/options.c:629
msgid ""
"domestic_rate:domestic risk-free interest rate to the exercise date in "
"percent"
msgstr ""
"domestic_rate:Nationaler riskofreier Zinssatz zum Ausübungstag in Prozent"

#: ../plugins/fn-derivatives/options.c:630
msgid ""
"foreign_rate:foreign risk-free interest rate to the exercise date in percent"
msgstr "foreign_rate:Fremder riskofreier Zinssatz zum Ausübungstag in Prozent"

#: ../plugins/fn-derivatives/options.c:632
msgid ""
"OPT_GARMAN_KOHLHAGEN values the theoretical price of a European currency "
"option struck at @{strike} on an asset with spot price @{spot}."
msgstr ""

#: ../plugins/fn-derivatives/options.c:678
msgid ""
"OPT_FRENCH:theoretical price of a European option adjusted for trading day "
"volatility"
msgstr ""

#: ../plugins/fn-derivatives/options.c:682
msgid ""
"time:ratio of the number of calendar days to exercise and the number of "
"calendar days in the year"
msgstr ""
"Zeit:Das Verhältnis der Kalendertage bis zur Ausgabe zu der Gesamtzahl "
"Kalendertage des Jahres"

#: ../plugins/fn-derivatives/options.c:683
msgid ""
"ttime:ratio of the number of trading days to exercise and the number of "
"trading days in the year"
msgstr ""
"tZeit:Verhältnis der Handelstage bis zur Ausgabe und der Anzahl der "
"Handelstage im Jahr"

#: ../plugins/fn-derivatives/options.c:687
msgid ""
"OPT_FRENCH values the theoretical price of a European option adjusted for "
"trading day volatility, struck at @{strike} on an asset with spot price @"
"{spot}."
msgstr ""

#: ../plugins/fn-derivatives/options.c:731
msgid ""
"OPT_JUMP_DIFF:theoretical price of an option according to the Jump Diffusion "
"process"
msgstr ""

#: ../plugins/fn-derivatives/options.c:736
msgid "rate:the annualized rate of interest"
msgstr "rate:auf das Jahr bezogener Zinssatz"

#: ../plugins/fn-derivatives/options.c:738
msgid "lambda:expected number of 'jumps' per year"
msgstr "lambda:erwartete Anzahl an »Sprüngen« pro Jahr"

#: ../plugins/fn-derivatives/options.c:739
msgid "gamma:proportion of volatility explained by the 'jumps'"
msgstr ""

#: ../plugins/fn-derivatives/options.c:740
msgid ""
"OPT_JUMP_DIFF models the theoretical price of an option according to the "
"Jump Diffusion process (Merton)."
msgstr ""

#: ../plugins/fn-derivatives/options.c:818
msgid ""
"OPT_MILTERSEN_SCHWARTZ:theoretical price of options on commodities futures "
"according to Miltersen & Schwartz"
msgstr ""

#: ../plugins/fn-derivatives/options.c:820
msgid "p_t:zero coupon bond with expiry at option maturity"
msgstr ""

#: ../plugins/fn-derivatives/options.c:821
msgid "f_t:futures price"
msgstr "f_t:zukünftiger Preis"

#: ../plugins/fn-derivatives/options.c:823
msgid "t1:time to maturity of the option"
msgstr "t1:Dauer bis zur Fälligkeit der Option"

#: ../plugins/fn-derivatives/options.c:824
msgid "t2:time to maturity of the underlying commodity futures contract"
msgstr ""
"t2:Dauer bis zur Fälligkeit des Vertrags swe damit verbundenen Handelsware"

#: ../plugins/fn-derivatives/options.c:825
msgid "v_s:volatility of the spot commodity price"
msgstr "v_s:Volatilität des Barpreises der Handelsware"

#: ../plugins/fn-derivatives/options.c:826
#, fuzzy
msgid "v_e:volatility of the future convenience yield"
msgstr "v_e:Volatilität des zukünftigen Ertrags"

#: ../plugins/fn-derivatives/options.c:827
#, fuzzy
msgid "v_f:volatility of the forward rate of interest"
msgstr "v_f:Volatilität des Zinssatzes"

#: ../plugins/fn-derivatives/options.c:828
msgid ""
"rho_se:correlation between the spot commodity price and the convenience yield"
msgstr ""

#: ../plugins/fn-derivatives/options.c:829
msgid ""
"rho_sf:correlation between the spot commodity price and the forward interest "
"rate"
msgstr ""

#: ../plugins/fn-derivatives/options.c:830
msgid ""
"rho_ef:correlation between the forward interest rate and the convenience "
"yield"
msgstr ""

#: ../plugins/fn-derivatives/options.c:831
msgid "kappa_e:speed of mean reversion of the convenience yield"
msgstr ""

#: ../plugins/fn-derivatives/options.c:832
msgid "kappa_f:speed of mean reversion of the forward interest rate"
msgstr ""

#: ../plugins/fn-derivatives/options.c:915
msgid ""
"OPT_RGW:theoretical price of an American option according to the Roll-Geske-"
"Whaley approximation"
msgstr ""

#: ../plugins/fn-derivatives/options.c:958
msgid ""
"OPT_BAW_AMER:theoretical price of an option according to the Barone Adesie & "
"Whaley approximation"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1130
msgid ""
"OPT_BJER_STENS:theoretical price of American options according to the "
"Bjerksund & Stensland approximation technique"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1204
msgid "OPT_EXEC:theoretical price of executive stock options"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1212
msgid "lambda:jump rate for executives"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1213
msgid ""
"The model assumes executives forfeit their options if they leave the company."
msgstr ""
"Das Modell geht davon aus, dass leitende Angestellte ihre Optionen "
"verlieren, sobald sie das Unternehmen verlassen."

#: ../plugins/fn-derivatives/options.c:1242
msgid "OPT_FORWARD_START:theoretical price of forward start options"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1245
msgid ""
"alpha:fraction setting the strike price at the future date @{time_start}"
msgstr ""
"alpha:Bruchteil, der den Basispreis an dem zukünftigen Datum @{time_start} "
"festlegt"

#: ../plugins/fn-derivatives/options.c:1246
msgid "time_start:time until the option starts in days"
msgstr "time_start:Zeit in Tagen, bis die Option beginnt"

#: ../plugins/fn-derivatives/options.c:1294
msgid "OPT_TIME_SWITCH:theoretical price of time switch options"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1298
msgid "a:amount received for each time period"
msgstr "a:der in jeder Zeitperiode erhaltene Betrag"

#: ../plugins/fn-derivatives/options.c:1300
msgid "m:number of time units the option has already met the condition"
msgstr ""
"m:Zahl der Zeiteinheiten, während derer die Option bereits die Bediungung "
"erfüllt"

#: ../plugins/fn-derivatives/options.c:1301
msgid "dt:agreed upon discrete time period expressed as a fraction of a year"
msgstr "dt:vereinbarte Zeitperiode, angegeben als Anteil eines Jahres"

#: ../plugins/fn-derivatives/options.c:1306
msgid ""
"OPT_TIME_SWITCH models the theoretical price of time switch options. (Pechtl "
"1995). The holder receives @{a} * @{dt} for each period that the asset price "
"was greater than @{strike} (for a call) or below it (for a put)."
msgstr ""

#: ../plugins/fn-derivatives/options.c:1336
msgid "OPT_SIMPLE_CHOOSER:theoretical price of a simple chooser option"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1340
msgid "time1:time in years until the holder chooses a put or a call option"
msgstr ""
"time1:Zeit in Jahren, bis sich ein Besitzer für eine Put- oder Call-Option "
"entscheidet"

#: ../plugins/fn-derivatives/options.c:1341
msgid "time2:time in years until the chosen option expires"
msgstr "Zeit2:Zeit in Jahren, bis die gewählte Option verfällt"

#: ../plugins/fn-derivatives/options.c:1385
msgid "OPT_COMPLEX_CHOOSER:theoretical price of a complex chooser option"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1387
msgid "strike_call:strike price, if exercised as a call option"
msgstr "strike_call:Basispreis im Falle einer Call-Option"

#: ../plugins/fn-derivatives/options.c:1388
msgid "strike_put:strike price, if exercised as a put option"
msgstr "strike_put:Basispreis im Falle einer Put-Option"

#: ../plugins/fn-derivatives/options.c:1389
msgid "time:time in years until the holder chooses a put or a call option"
msgstr ""
"time:Zeit in Jahren, bis sich ein Besitzer für eine Put- oder Call-Option "
"entscheidet"

#: ../plugins/fn-derivatives/options.c:1390
msgid "time_call:time in years to maturity of the call option if chosen"
msgstr ""
"time_call:Zeit in Jahren bis zur Fälligkeit der Call-Option, falls gewählt"

#: ../plugins/fn-derivatives/options.c:1391
msgid "time_put:time in years  to maturity of the put option if chosen"
msgstr ""
"time_put:Zeit in Jahren bis zur Fälligkeit der Put-Option, falls gewählt"

#: ../plugins/fn-derivatives/options.c:1486
msgid "OPT_ON_OPTIONS:theoretical price of options on options"
msgstr "OPT_ON_OPTIONS:Theoretischer Preis für Optionen auf Optionen"

#: ../plugins/fn-derivatives/options.c:1487
msgid ""
"type_flag:'cc' for calls on calls, 'cp' for calls on puts, and so on for "
"'pc', and 'pp'"
msgstr ""
"type_flag:»cc« für Calls auf Calls, »cp« für Calls auf Puts und so weiter "
"für »pc«, and »pp«"

#: ../plugins/fn-derivatives/options.c:1489
#, fuzzy
msgid "strike1:strike price at which the option being valued is struck"
msgstr "strike1:Basispreis, zu dem die zu bewertende Option greift"

#: ../plugins/fn-derivatives/options.c:1490
#, fuzzy
msgid "strike2:strike price at which the underlying option is struck"
msgstr "strike2:Basispreis, zu dem die ? Option greift"

#: ../plugins/fn-derivatives/options.c:1491
msgid "time1:time in years to maturity of the option"
msgstr "Zeit1:Zeit in Jahren bis zur Fälligkeit der Option"

#: ../plugins/fn-derivatives/options.c:1492
msgid "time2:time in years to the maturity of the underlying option"
msgstr "Zeit2:Zeit in Jahren bis zur Fälligkeit der Basisoption"

#: ../plugins/fn-derivatives/options.c:1494
msgid ""
"cost_of_carry:net cost of holding the underlying asset of the underlying "
"option"
msgstr ""
"cost_of_carry:Nettokosten zum Halten des Vermögenswerts der Basisoption"

#: ../plugins/fn-derivatives/options.c:1495
#, fuzzy
msgid ""
"volatility:annualized volatility in price of the underlying asset of the "
"underlying option"
msgstr "volatility:Jahresvolalität des Preises des Basiswerts der Basisoption"

#: ../plugins/fn-derivatives/options.c:1496
msgid ""
"For common stocks, @{cost_of_carry} is the risk free rate less the dividend "
"yield."
msgstr ""

#: ../plugins/fn-derivatives/options.c:1497
msgid "@{time2} ≥ @{time1}"
msgstr "@{Zeit2} ≥ @{Zeit1}"

#: ../plugins/fn-derivatives/options.c:1563
msgid "OPT_EXTENDIBLE_WRITER:theoretical price of extendible writer options"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1566
msgid "strike1:strike price at which the option is struck"
msgstr "strike1:Basispreis, zu dem die Option greift"

#: ../plugins/fn-derivatives/options.c:1567
msgid ""
"strike2:strike price at which the option is re-struck if out of the money at "
"@{time1}"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1568
msgid "time1:initial maturity of the option in years"
msgstr "Zeit1:Erste Fälligkeit der Option in Jahren"

#: ../plugins/fn-derivatives/options.c:1569
msgid "time2:extended maturity in years if chosen"
msgstr "Zeit2:Erweiterte Fälligkeit der Option in Jahren, falls gewählt"

#: ../plugins/fn-derivatives/options.c:1573
msgid ""
"OPT_EXTENDIBLE_WRITER models the theoretical price of extendible writer "
"options. These are options that have their maturity extended to @{time2} if "
"the option is out of the money at @{time1}."
msgstr ""

#: ../plugins/fn-derivatives/options.c:1615
msgid ""
"OPT_2_ASSET_CORRELATION:theoretical price of options on 2 assets with "
"correlation @{rho}"
msgstr ""
"OPT_2_ASSET_CORRELATION:Theoretischer Preis einer Option auf zwei "
"Vermögenswerte mit Korrelation @{rho}"

#: ../plugins/fn-derivatives/options.c:1617
msgid "spot1:spot price of the underlying asset of the first option"
msgstr "spot1:Barpreis des Vermögenswerts der ersten Option"

#: ../plugins/fn-derivatives/options.c:1618
msgid "spot2:spot price of the underlying asset of the second option"
msgstr "spot2:Barpreis des Vermögenswerts der zweiten Option"

#: ../plugins/fn-derivatives/options.c:1619
msgid "strike1:strike prices of the first option"
msgstr "strike1:Basispreis der erste Option"

#: ../plugins/fn-derivatives/options.c:1620
msgid "strike2:strike prices of the second option"
msgstr "strike2:Basispreis der zweiten Option"

#: ../plugins/fn-derivatives/options.c:1622
#, fuzzy
msgid ""
"cost_of_carry1:net cost of holding the underlying asset of the first option "
"(for common stocks, the risk free rate less the dividend yield)"
msgstr ""
"cost_of_carry1:Nettokosten zum Halten des Basiswerts der ersten Option "
"(für ? ist die risikofreie Rate kleiner als der Dividendenertrag)"

#: ../plugins/fn-derivatives/options.c:1624
#, fuzzy
msgid ""
"cost_of_carry2:net cost of holding the underlying asset of the second option "
"(for common stocks, the risk free rate less the dividend yield)"
msgstr ""
"cost_of_carry2:Nettokosten zum Halten des Basiswerts der ersten Option "
"(für ? ist die risikofreie Rate kleiner als der Dividendenertrag)"

#: ../plugins/fn-derivatives/options.c:1627
msgid ""
"volatility1:annualized volatility in price of the underlying asset of the "
"first option"
msgstr ""
"volatility1:Jahresvolatilität des Preises des Vermögenswerts der ersten "
"Option"

#: ../plugins/fn-derivatives/options.c:1628
msgid ""
"volatility2:annualized volatility in price of the underlying asset of the "
"second option"
msgstr ""
"volatility2:Jahresvolatilität des Preises des Vermögenswerts der zweiten "
"Option"

#: ../plugins/fn-derivatives/options.c:1629
msgid "rho:correlation between the two underlying assets"
msgstr "rho:Korrelation zwischen den Vermögenswerten"

#: ../plugins/fn-derivatives/options.c:1630
msgid ""
"OPT_2_ASSET_CORRELATION models the theoretical price of options on 2 assets "
"with correlation @{rho}. The payoff for a call is max(@{spot2} - @"
"{strike2},0) if @{spot1} > @{strike1} or 0 otherwise. The payoff for a put "
"is max (@{strike2} - @{spot2}, 0) if @{spot1} < @{strike1} or 0 otherwise."
msgstr ""
"OPT_2_ASSET_CORRELATION modelliert den theoretischer Preis von Optionen auf "
"zwei Vermögenswerte mit Korrelation @{rho}. Die Amortisation für einen Call "
"ist max(@{spot2} - @{strike2},0), wenn @{spot1} > @{strike1}, andernfalls 0. "
"Die Amortisation für einen Put ist max(@{strike2} - @{spot2}, 0), wenn @"
"{spot1} < @{strike1}, andernfalls 0."

#: ../plugins/fn-derivatives/options.c:1665
msgid ""
"OPT_EURO_EXCHANGE:theoretical price of a European option to exchange assets"
msgstr ""
"OPT_EURO_EXCHANGE:Theoretischer Preis einer europäischen Option zum Wechseln "
"von Vermögenswerten"

#: ../plugins/fn-derivatives/options.c:1666
#: ../plugins/fn-derivatives/options.c:1710
msgid "spot1:spot price of asset 1"
msgstr "spot1:Barpreis von Vermögenswert 1"

#: ../plugins/fn-derivatives/options.c:1667
#: ../plugins/fn-derivatives/options.c:1711
msgid "spot2:spot price of asset 2"
msgstr "spot2:Barpreis von Vermögenswert 2"

#: ../plugins/fn-derivatives/options.c:1668
#: ../plugins/fn-derivatives/options.c:1712
msgid "qty1:quantity of asset 1"
msgstr "qty1:Quantität des Vermögenswerts 1"

#: ../plugins/fn-derivatives/options.c:1669
#: ../plugins/fn-derivatives/options.c:1713
msgid "qty2:quantity of asset 2"
msgstr "qty2:Quantität des Vermögenswerts 2"

#: ../plugins/fn-derivatives/options.c:1672
#: ../plugins/fn-derivatives/options.c:1716
msgid ""
"cost_of_carry1:net cost of holding asset 1 (for common stocks, the risk free "
"rate less the dividend yield)"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1674
#: ../plugins/fn-derivatives/options.c:1718
msgid ""
"cost_of_carry2:net cost of holding asset 2 (for common stocks, the risk free "
"rate less the dividend yield)"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1676
#: ../plugins/fn-derivatives/options.c:1720
msgid "volatility1:annualized volatility in price of asset 1"
msgstr "volatility1:Jährliche Volatilität des Preises von Vermögenswert 1"

#: ../plugins/fn-derivatives/options.c:1677
#: ../plugins/fn-derivatives/options.c:1721
msgid "volatility2:annualized volatility in price of asset 2"
msgstr "volatility2:Jährliche Volatilität des Preises von Vermögenswert 2"

#: ../plugins/fn-derivatives/options.c:1678
#: ../plugins/fn-derivatives/options.c:1722
#, fuzzy
msgid "rho:correlation between the prices of the two assets"
msgstr "rho:Korrelation zwischen den Basiswerten"

#: ../plugins/fn-derivatives/options.c:1679
msgid ""
"OPT_EURO_EXCHANGE models the theoretical price of a European option to "
"exchange one asset with quantity @{qty2} and spot price @{spot2} for another "
"with quantity @{qty1} and spot price @{spot1}."
msgstr ""
"OPT_EURO_EXCHANGE modelliert den theoretischen Preis einer europäischen "
"Option, um einen Vermögenswert mit Quantität @{qty2} und Barpreis @{spot2} "
"gegen ein anderes mit Quantität @{qty1} and Barpreis @{spot1} zu tauschen."

#: ../plugins/fn-derivatives/options.c:1709
msgid ""
"OPT_AMER_EXCHANGE:theoretical price of an American option to exchange assets"
msgstr ""
"OPT_AMER_EXCHANGE:Theoretischer Preis einer amerikanischen Option zum "
"Wechseln von Vermögenswerten"

#: ../plugins/fn-derivatives/options.c:1723
msgid ""
"OPT_AMER_EXCHANGE models the theoretical price of an American option to "
"exchange one asset with quantity @{qty2} and spot price @{spot2} for another "
"with quantity @{qty1} and spot price @{spot1}."
msgstr ""
"OPT_AMER_EXCHANGE modelliert den theoretischen Preis einer amerikanischen "
"Option, um einen Vermögenswert mit Quantität @{qty2} und Barpreis @{spot2} "
"gegen ein anderes mit Quantität @{qty1} and Barpreis @{spot1} zu tauschen."

#: ../plugins/fn-derivatives/options.c:1753
msgid ""
"OPT_SPREAD_APPROX:theoretical price of a European option on the spread "
"between two futures contracts"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1755
msgid "fut_price1:price of the first futures contract"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1756
msgid "fut_price2:price of the second futures contract"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1760
msgid ""
"volatility1:annualized volatility in price of the first underlying futures "
"contract"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1761
msgid ""
"volatility2:annualized volatility in price of the second underlying futures "
"contract"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1762
msgid "rho:correlation between the two futures contracts"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1808
msgid ""
"OPT_FLOAT_STRK_LKBK:theoretical price of floating-strike lookback option"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1811
#: ../plugins/fn-derivatives/options.c:1875
msgid "spot_min:minimum spot price of the underlying asset so far observed"
msgstr "spot_min:Kleinster bisher gesehener Barpreis des Vermögenswerts"

#: ../plugins/fn-derivatives/options.c:1812
#: ../plugins/fn-derivatives/options.c:1876
msgid "spot_max:maximum spot price of the underlying asset so far observed"
msgstr "spot_max:Größter bisher gesehener Barpreis des Vermögenswerts"

#: ../plugins/fn-derivatives/options.c:1817
msgid ""
"OPT_FLOAT_STRK_LKBK determines the theoretical price of a floating-strike "
"lookback option where the holder of the option may exercise on expiry at the "
"most favourable price observed during the options life of the underlying "
"asset."
msgstr ""

#: ../plugins/fn-derivatives/options.c:1872
msgid "OPT_FIXED_STRK_LKBK:theoretical price of a fixed-strike lookback option"
msgstr ""

#: ../plugins/fn-derivatives/options.c:1882
msgid ""
"OPT_FIXED_STRK_LKBK determines the theoretical price of a fixed-strike "
"lookback option where the holder of the option may exercise on expiry at the "
"most favourable price observed during the options life of the underlying "
"asset."
msgstr ""

#: ../plugins/fn-derivatives/options.c:1956
msgid ""
"OPT_BINOMIAL:theoretical price of either an American or European style "
"option using a binomial tree"
msgstr ""
"OPT_BINOMIAL:Theoretischer Preis einer amerikanischen oder europäischen "
"Option unter Verwendung eines Binomialbaums"

#: ../plugins/fn-derivatives/options.c:1957
msgid ""
"amer_euro_flag:'a' for an American style option or 'e' for a European style "
"option"
msgstr ""
"amer_euro_flag:»a« steht für eine Kaufoption amerikanischen Stils und »e« "
"steht für eine Kaufoption europäischen Stils"

#: ../plugins/fn-derivatives/options.c:1959
msgid "num_time_steps:number of time steps used in the valuation"
msgstr "num_time_steps:Anzahl der verwendeten Zeitschritte in der Schätzung"

#: ../plugins/fn-derivatives/options.c:1966
msgid ""
"A larger @{num_time_steps} yields greater accuracy but  OPT_BINOMIAL is "
"slower to calculate."
msgstr ""
"Ein größeres @{num_time_steps} ergibt mehr Genauigkeit, aber OPT_BINOMIAL "
"ist nur langsam in der Berechnung."

#: ../plugins/fn-eng/functions.c:205
msgid "BASE:string of digits representing the number @{n} in base @{b}"
msgstr ""
"BASE:Zeichenkette aus Ziffern, die die Zahl @{n} zur Basis @{b} darstellen"

#: ../plugins/fn-eng/functions.c:206 ../plugins/fn-math/functions.c:1327
#: ../plugins/fn-numtheory/numtheory.c:612
#: ../plugins/fn-numtheory/numtheory.c:642
msgid "n:integer"
msgstr "n:Ganzzahl"

#: ../plugins/fn-eng/functions.c:207
msgid "b:base (2 ≤ @{b} ≤ 36)"
msgstr "b:Basis (2 ≤ @{b} ≤ 36)"

#: ../plugins/fn-eng/functions.c:208
msgid "length:minimum length of the resulting string"
msgstr "length:Minimale Länge der resultierenden Zeichenkette"

#: ../plugins/fn-eng/functions.c:209
msgid ""
"BASE converts @{n} to its string representation in base @{b}. Leading zeroes "
"will be added to reach the minimum length given by @{length}."
msgstr ""
"BASE wandelt @{n} in seine Zeichenketten-Repräsentation in Basis @{b} um. "
"Führende Nullen werden hinzugefügt, um die durch @{length} festgelegte "
"minimale Länge zu erreichen."

#: ../plugins/fn-eng/functions.c:234
msgid "BIN2DEC:decimal representation of the binary number @{x}"
msgstr "BIN2DEC:Dezimaldarstellung der Binärzahl @{x}"

#: ../plugins/fn-eng/functions.c:235 ../plugins/fn-eng/functions.c:257
#: ../plugins/fn-eng/functions.c:281
msgid ""
"x:a binary number, either as a string or as a number involving only the "
"digits 0 and 1"
msgstr ""
"x:Eine Binärzahl, entweder als Zeichenkette oder als Zahl, die nur die "
"Stellen 0 und 1 enthält."

#: ../plugins/fn-eng/functions.c:256
msgid "BIN2OCT:octal representation of the binary number @{x}"
msgstr "BIN2OCT:Oktaldarstellung der Binärzahl @{x}"

#: ../plugins/fn-eng/functions.c:258 ../plugins/fn-eng/functions.c:282
#: ../plugins/fn-eng/functions.c:307 ../plugins/fn-eng/functions.c:337
#: ../plugins/fn-eng/functions.c:360 ../plugins/fn-eng/functions.c:431
#: ../plugins/fn-eng/functions.c:454 ../plugins/fn-eng/functions.c:477
#: ../plugins/fn-eng/functions.c:500
msgid "places:number of digits"
msgstr "places:Anzahl der Stellen"

#: ../plugins/fn-eng/functions.c:259
msgid ""
"If @{places} is given, BIN2OCT pads the result with zeros to achieve exactly "
"@{places} digits. If this is not possible, BIN2OCT returns #NUM!"
msgstr ""
"Falls @{places} angegeben ist, dann füllt BIN2OCT das Ergebnis mit Nullen "
"auf, um exakt @{places} Stellen zu erreichen. Falls das nicht möglich ist, "
"gibt BIN2OCT  #ZAHL! zurück."

#: ../plugins/fn-eng/functions.c:280
msgid "BIN2HEX:hexadecimal representation of the binary number @{x}"
msgstr "BIN2HEX:Hexadezimaldarstellung der Binärzahl @{x}"

#: ../plugins/fn-eng/functions.c:283
msgid ""
"If @{places} is given, BIN2HEX pads the result with zeros to achieve exactly "
"@{places} digits. If this is not possible, BIN2HEX returns #NUM!"
msgstr ""
"Falls @{places} angegeben ist, dann füllt BIN2HEX das Ergebnis mit Nullen "
"auf, um exakt @{places} Stellen zu erreichen. Falls das nicht möglich ist, "
"gibt BIN2HEX  #ZAHL! zurück."

#: ../plugins/fn-eng/functions.c:305
msgid "DEC2BIN:binary representation of the decimal number @{x}"
msgstr "DEC2BIN:Binärdarstellung der Dezimalzahl @{x}"

#: ../plugins/fn-eng/functions.c:306
msgid "x:integer (− 513 < @{x} < 512)"
msgstr "x:Ganzzahl (− 513 < @{x} < 512)"

#: ../plugins/fn-eng/functions.c:308
msgid ""
"If @{places} is given and @{x} is non-negative, DEC2BIN pads the result with "
"zeros to achieve exactly @{places} digits. If this is not possible, DEC2BIN "
"returns #NUM!"
msgstr ""
"Falls @{places} angegeben ist und @{x} nicht negativ ist, dann füllt DEC2BIN "
"das Ergebnis mit Nullen auf, um exakt @{places} Stellen zu erreichen. Falls "
"das nicht möglich ist, gibt DEC2BIN  #ZAHL! zurück."

#: ../plugins/fn-eng/functions.c:312
msgid "If @{places} is given and @{x} is negative, @{places} is ignored."
msgstr ""
"Wenn @{places} bekannt ist und @{x} negativ ist, so wird @{places} ignoriert."

#: ../plugins/fn-eng/functions.c:313
msgid "If @{x} < − 512 or @{x} > 511, DEC2BIN returns #NUM!"
msgstr "Falls @{x} < - 512 oder @{x} > 511, dann gibt DEC2BIN #ZAHL! zurück."

#: ../plugins/fn-eng/functions.c:335
msgid "DEC2OCT:octal representation of the decimal number @{x}"
msgstr "DEC2OCT:Oktaldarstellung der Dezimalzahl @{x}"

#: ../plugins/fn-eng/functions.c:336 ../plugins/fn-eng/functions.c:359
#: ../plugins/fn-math/functions.c:1326
msgid "x:integer"
msgstr "x:Ganzzahl"

#: ../plugins/fn-eng/functions.c:338
msgid ""
"If @{places} is given, DEC2OCT pads the result with zeros to achieve exactly "
"@{places} digits. If this is not possible, DEC2OCT returns #NUM!"
msgstr ""
"Falls @{places} angegeben ist, dann füllt DEC2OCT das Ergebnis mit Nullen "
"auf, um exakt @{places} Stellen zu erreichen. Falls das nicht möglich ist, "
"gibt DEC2OCT  #ZAHL! zurück."

#: ../plugins/fn-eng/functions.c:358
msgid "DEC2HEX:hexadecimal representation of the decimal number @{x}"
msgstr "DEC2HEX:Hexadezimaldarstellung der Dezimalzahl @{x}"

#: ../plugins/fn-eng/functions.c:361
msgid ""
"If @{places} is given, DEC2HEX pads the result with zeros to achieve exactly "
"@{places} digits. If this is not possible, DEC2HEX returns #NUM!"
msgstr ""
"Falls @{places} angegeben ist, dann füllt DEC2HEX das Ergebnis mit Nullen "
"auf, um exakt @{places} Stellen zu erreichen. Falls das nicht möglich ist, "
"gibt DEC2HEX  #ZAHL! zurück."

#: ../plugins/fn-eng/functions.c:381
msgid "DECIMAL:decimal representation of @{x}"
msgstr "DECIMAL:Dezimaldarstellung von @{x}"

#: ../plugins/fn-eng/functions.c:382
msgid "x:number in base @{base}"
msgstr "x:Zahl in Basis @{base}"

#: ../plugins/fn-eng/functions.c:383
msgid "base:base of @{x}, (2 ≤ @{base} ≤ 36)"
msgstr "base:Basis von @{x}, (2 ≤ @{b} ≤ 36)"

#: ../plugins/fn-eng/functions.c:405
msgid "OCT2DEC:decimal representation of the octal number @{x}"
msgstr "OCT2DEC:Dezimaldarstellung der Oktalzahl @{x}"

#: ../plugins/fn-eng/functions.c:406 ../plugins/fn-eng/functions.c:430
#: ../plugins/fn-eng/functions.c:453
msgid "x:a octal number, either as a string or as a number"
msgstr "x:Eine Oktalzahl, entweder als Zeichenkette oder als Zahl"

#: ../plugins/fn-eng/functions.c:429
msgid "OCT2BIN:binary representation of the octal number @{x}"
msgstr "OCT2BIN:Binärdarstellung der Oktalzahl @{x}"

#: ../plugins/fn-eng/functions.c:432
msgid ""
"If @{places} is given, OCT2BIN pads the result with zeros to achieve exactly "
"@{places} digits. If this is not possible, OCT2BIN returns #NUM!"
msgstr ""
"Falls @{places} angegeben ist, dann füllt OCT2BIN das Ergebnis mit Nullen "
"auf, um exakt @{places} Stellen zu erreichen. Falls das nicht möglich ist, "
"gibt OCT2BIN  #ZAHL! zurück."

#: ../plugins/fn-eng/functions.c:452
msgid "OCT2HEX:hexadecimal representation of the octal number @{x}"
msgstr "OCT2HEX:Hexadezimaldarstellung der Oktalzahl @{x}"

#: ../plugins/fn-eng/functions.c:455
msgid ""
"If @{places} is given, OCT2HEX pads the result with zeros to achieve exactly "
"@{places} digits. If this is not possible, OCT2HEX returns #NUM!"
msgstr ""
"Falls @{places} angegeben ist, dann füllt OCT2HEX das Ergebnis mit Nullen "
"auf, um exakt @{places} Stellen zu erreichen. Falls das nicht möglich ist, "
"gibt OCT2HEX  #ZAHL! zurück."

#: ../plugins/fn-eng/functions.c:475
msgid "HEX2BIN:binary representation of the hexadecimal number @{x}"
msgstr "HEX2BIN:Binärdarstellung der Hexadezimalzahl @{x}"

#: ../plugins/fn-eng/functions.c:476 ../plugins/fn-eng/functions.c:499
#: ../plugins/fn-eng/functions.c:522
msgid ""
"x:a hexadecimal number, either as a string or as a number if no A to F are "
"needed"
msgstr ""
"x:Eine Hexadezimalzahl, entweder als Zeichenkette oder als Zahl, falls die "
"Zeichen A bis F nicht notwendig sind"

#: ../plugins/fn-eng/functions.c:478
msgid ""
"If @{places} is given, HEX2BIN pads the result with zeros to achieve exactly "
"@{places} digits. If this is not possible, HEX2BIN returns #NUM!"
msgstr ""
"Falls @{places} angegeben ist, dann füllt HEX2BIN das Ergebnis mit Nullen "
"auf, um exakt @{places} Stellen zu erreichen. Falls das nicht möglich ist, "
"gibt HEX2BIN  #ZAHL! zurück."

#: ../plugins/fn-eng/functions.c:498
msgid "HEX2OCT:octal representation of the hexadecimal number @{x}"
msgstr "HEX2OCT:Oktaldarstellung der Hexadezimalzahl @{x}"

#: ../plugins/fn-eng/functions.c:501
msgid ""
"If @{places} is given, HEX2OCT pads the result with zeros to achieve exactly "
"@{places} digits. If this is not possible, HEX2OCT returns #NUM!"
msgstr ""
"Falls @{places} angegeben ist, dann füllt HEX2OCT das Ergebnis mit Nullen "
"auf, um exakt @{places} Stellen zu erreichen. Falls das nicht möglich ist, "
"gibt HEX2OCT  #ZAHL! zurück."

#: ../plugins/fn-eng/functions.c:521
msgid "HEX2DEC:decimal representation of the hexadecimal number @{x}"
msgstr "HEX2DEC:Dezimaldarstellung der Hexadezimalzahl @{x}"

#: ../plugins/fn-eng/functions.c:544
msgid ""
"BESSELI:Modified Bessel function of the first kind of order @{α} at @{x}"
msgstr "BESSELI:modifizierte Besselfunktion der ersten Ordnung @{α} bei @{x}"

#: ../plugins/fn-eng/functions.c:545 ../plugins/fn-eng/functions.c:583
#: ../plugins/fn-eng/functions.c:607 ../plugins/fn-eng/functions.c:636
msgid "X:number"
msgstr "X:Zahl"

#: ../plugins/fn-eng/functions.c:546 ../plugins/fn-eng/functions.c:584
msgid "α:order (any non-negative number)"
msgstr "α:Ordnung (eine nicht negative Zahl)"

#: ../plugins/fn-eng/functions.c:547 ../plugins/fn-eng/functions.c:585
msgid ""
"If @{x} or @{α} are not numeric, #VALUE! is returned. If @{α} < 0, #NUM! is "
"returned."
msgstr ""
"Falls @{x} oder @{α} nicht numerisch sind, wird #WERT! zurückgegeben. Falls @"
"{α} < 0, wird #ZAHL! zurückgegeben."

#: ../plugins/fn-eng/functions.c:548 ../plugins/fn-eng/functions.c:586
#, fuzzy
msgid "This function is Excel compatible if only integer orders @{α} are used."
msgstr ""
"Diese Funktion ist nur dann mit Excel kompatibel, wenn Ganzzahlen ? @{α} "
"verwendet werden."

#: ../plugins/fn-eng/functions.c:551 ../plugins/fn-eng/functions.c:589
#: ../plugins/fn-eng/functions.c:615
msgid "wiki:en:Bessel_function"
msgstr "wiki:de:Besselsche_Differentialgleichung"

#: ../plugins/fn-eng/functions.c:582
msgid ""
"BESSELK:Modified Bessel function of the second kind of order @{α} at @{x}"
msgstr "BESSELK:Veränderte Besselfunktion der zweiten Ordnung @{α} bei @{x}"

#: ../plugins/fn-eng/functions.c:606
msgid "BESSELJ:Bessel function of the first kind of order @{α} at @{x}"
msgstr "BESSELJ:Besselfunktion der ersten Ordnung @{α} bei @{x}"

#: ../plugins/fn-eng/functions.c:608 ../plugins/fn-eng/functions.c:637
msgid "α:order (any non-negative integer)"
msgstr "α:Ordnung (eine positive Ganzzahl)"

#: ../plugins/fn-eng/functions.c:609 ../plugins/fn-eng/functions.c:638
msgid ""
"If @{x} or @{α} are not numeric, #VALUE! is returned. If @{α} < 0, #NUM! is "
"returned. If @{α} is not an integer, it is truncated."
msgstr ""
"Falls @{x} oder @{α} nicht numerisch sind, wird #WERT! zurückgegeben. Falls @"
"{α} < 0, wird #ZAHL! zurückgegeben. Falls @{α} keine Ganzzahl ist, wird es "
"abgeschnitten."

#: ../plugins/fn-eng/functions.c:635
msgid "BESSELY:Bessel function of the second kind of order @{α} at @{x}"
msgstr "BESSELY:Besselfunktion der zweiten Ordnung @{α} bei @{x}"

#: ../plugins/fn-eng/functions.c:662
msgid "CONVERT:a converted measurement"
msgstr "CONVERT:eine konvertierte Maßeinheit"

#: ../plugins/fn-eng/functions.c:663 ../plugins/fn-eng/functions.c:1106
#: ../plugins/fn-eng/functions.c:1172 ../plugins/fn-math/functions.c:226
#: ../plugins/fn-math/functions.c:245 ../plugins/fn-math/functions.c:267
#: ../plugins/fn-math/functions.c:308 ../plugins/fn-math/functions.c:326
#: ../plugins/fn-math/functions.c:352 ../plugins/fn-math/functions.c:371
#: ../plugins/fn-math/functions.c:395 ../plugins/fn-math/functions.c:456
#: ../plugins/fn-math/functions.c:732 ../plugins/fn-math/functions.c:785
#: ../plugins/fn-math/functions.c:803 ../plugins/fn-math/functions.c:821
#: ../plugins/fn-math/functions.c:857 ../plugins/fn-math/functions.c:875
#: ../plugins/fn-math/functions.c:892 ../plugins/fn-math/functions.c:923
#: ../plugins/fn-math/functions.c:953 ../plugins/fn-math/functions.c:977
#: ../plugins/fn-math/functions.c:1001 ../plugins/fn-math/functions.c:1085
#: ../plugins/fn-math/functions.c:1121 ../plugins/fn-math/functions.c:1217
#: ../plugins/fn-math/functions.c:1259 ../plugins/fn-math/functions.c:1429
#: ../plugins/fn-math/functions.c:1469 ../plugins/fn-math/functions.c:1487
#: ../plugins/fn-math/functions.c:1639 ../plugins/fn-math/functions.c:1674
#: ../plugins/fn-math/functions.c:1711 ../plugins/fn-math/functions.c:1746
#: ../plugins/fn-math/functions.c:1886 ../plugins/fn-math/functions.c:1936
#: ../plugins/fn-math/functions.c:1960 ../plugins/fn-math/functions.c:2001
#: ../plugins/fn-math/functions.c:2048 ../plugins/fn-stat/functions.c:440
#: ../plugins/fn-stat/functions.c:530 ../plugins/fn-stat/functions.c:591
#: ../plugins/fn-stat/functions.c:891 ../plugins/fn-stat/functions.c:960
#: ../plugins/fn-stat/functions.c:1023 ../plugins/fn-stat/functions.c:1165
#: ../plugins/fn-stat/functions.c:1200 ../plugins/fn-stat/functions.c:1278
#: ../plugins/fn-stat/functions.c:1367 ../plugins/fn-stat/functions.c:1397
#: ../plugins/fn-stat/functions.c:1630 ../plugins/fn-stat/functions.c:1809
#: ../plugins/fn-stat/functions.c:1845 ../plugins/fn-stat/functions.c:2012
#: ../plugins/fn-stat/functions.c:4467 ../plugins/fn-stat/functions.c:4498
#: ../plugins/fn-stat/functions.c:4532 ../plugins/fn-stat/functions.c:4567
#: ../plugins/fn-stat/functions.c:4606 ../plugins/fn-stat/functions.c:4639
msgid "x:number"
msgstr "x:Zahl"

#: ../plugins/fn-eng/functions.c:664
msgid "from:unit (string)"
msgstr "from:Einheit (Zeichenkette)"

#: ../plugins/fn-eng/functions.c:665
msgid "to:unit (string)"
msgstr "to:Einheit (Zeichenkette)"

#: ../plugins/fn-eng/functions.c:666
msgid ""
"CONVERT returns a conversion from one measurement system to another. @{x} is "
"a value in @{from} units that is to be converted into @{to} units."
msgstr ""
"CONVERT gibt die Umrechnung von einem Einheitensystem in ein anderes zurück. "
"@{x} ist der Wert in @{from} Einheiten, der in @{to} Einheiten umgerechnet "
"werden soll."

#: ../plugins/fn-eng/functions.c:668
msgid "If @{from} and @{to} are different types, CONVERT returns #N/A!"
msgstr ""
"Falls @{from} und @{to} verschiedenen Typs sind, gibt CONVERT #N/A! zurück."

#: ../plugins/fn-eng/functions.c:669
msgid ""
"@{from} and @{to} can be any of the following:\n"
"\n"
"Weight and mass:\n"
"\t'g'  \t\t\tGram\n"
"\t'sg' \t\t\tSlug\n"
"\t'lbm'\t\tPound\n"
"\t'u'  \t\t\tU (atomic mass)\n"
"\t'ozm'\t\tOunce\n"
"\n"
"Distance:\n"
"\t'm'   \t\tMeter\n"
"\t'mi'  \t\tStatute mile\n"
"\t'Nmi' \t\tNautical mile\n"
"\t'in'  \t\t\tInch\n"
"\t'ft'  \t\t\tFoot\n"
"\t'yd'  \t\tYard\n"
"\t'ang' \t\tAngstrom\n"
"\t'Pica'\t\tPica Points\n"
"\t'picapt'\t\tPica Points\n"
"\t'pica'\t\tPica\n"
"\n"
"Time:\n"
"\t'yr'  \t\t\tYear\n"
"\t'day' \t\tDay\n"
"\t'hr'  \t\t\tHour\n"
"\t'mn'  \t\tMinute\n"
"\t'sec' \t\tSecond\n"
"\n"
"Pressure:\n"
"\t'Pa'  \t\tPascal\n"
"\t'atm' \t\tAtmosphere\n"
"\t'mmHg'\t\tmm of Mercury\n"
"\n"
"Force:\n"
"\t'N'   \t\t\tNewton\n"
"\t'dyn' \t\tDyne\n"
"\t'lbf' \t\t\tPound force\n"
"\n"
"Energy:\n"
"\t'J'    \t\t\tJoule\n"
"\t'e'    \t\tErg\n"
"\t'c'    \t\tThermodynamic calorie\n"
"\t'cal'  \t\tIT calorie\n"
"\t'eV'   \t\tElectron volt\n"
"\t'HPh'  \t\tHorsepower-hour\n"
"\t'Wh'   \t\tWatt-hour\n"
"\t'flb'  \t\tFoot-pound\n"
"\t'BTU'  \t\tBTU\n"
"\n"
"Power:\n"
"\t'HP'   \t\tHorsepower\n"
"\t'W'    \t\tWatt\n"
"\n"
"Magnetism:\n"
"\t'T'    \t\tTesla\n"
"\t'ga'   \t\tGauss\n"
"\n"
"Temperature:\n"
"\t'C'    \t\tDegree Celsius\n"
"\t'F'    \t\tDegree Fahrenheit\n"
"\t'K'    \t\tDegree Kelvin\n"
"\n"
"Liquid measure:\n"
"\t'tsp'  \t\tTeaspoon\n"
"\t'tbs'  \t\tTablespoon\n"
"\t'oz'   \t\tFluid ounce\n"
"\t'cup'  \t\tCup\n"
"\t'pt'   \t\tPint\n"
"\t'qt'   \t\tQuart\n"
"\t'gal'  \t\tGallon\n"
"\t'l'    \t\t\tLiter\n"
"\n"
"For metric units any of the following prefixes can be used:\n"
"\t'Y'  \tyotta \t\t1E+24\n"
"\t'Z'  \tzetta \t\t1E+21\n"
"\t'E'  \texa   \t\t1E+18\n"
"\t'P'  \tpeta  \t\t1E+15\n"
"\t'T'  \ttera  \t\t1E+12\n"
"\t'G'  \tgiga  \t\t1E+09\n"
"\t'M'  \tmega  \t\t1E+06\n"
"\t'k'  \tkilo  \t\t1E+03\n"
"\t'h'  \thecto \t\t1E+02\n"
"\t'e'  \tdeca (deka)\t1E+01\n"
"\t'd'  \tdeci  \t\t1E-01\n"
"\t'c'  \tcenti \t\t1E-02\n"
"\t'm'  \tmilli \t\t1E-03\n"
"\t'u'  \tmicro \t\t1E-06\n"
"\t'n'  \tnano  \t\t1E-09\n"
"\t'p'  \tpico  \t\t1E-12\n"
"\t'f'  \tfemto \t\t1E-15\n"
"\t'a'  \tatto  \t\t1E-18\n"
"\t'z'  \tzepto \t\t1E-21\n"
"\t'y'  \tyocto \t\t1E-24"
msgstr ""
"@{from} und @{to} können eines der folgenden sein:\n"
"\n"
"Gewicht und Masse:\n"
"\t'g'  \t\t\tGramm\n"
"\t'sg' \t\t\tSlug\n"
"\t'lbm'\t\tPfund\n"
"\t'u'  \t\t\tU (atomare Masse)\n"
"\t'ozm'\t\tUnze\n"
"\n"
"Entfernung:\n"
"\t'm'   \t\tMeter\n"
"\t'mi'  \t\tBrit. Landmeile\n"
"\t'Nmi' \t\tSeemeile\n"
"\t'in'  \t\t\tZoll (Inch)\n"
"\t'ft'  \t\t\tFuß\n"
"\t'yd'  \t\tYard\n"
"\t'ang' \t\tAngstrom\n"
"\t'Pica'\t\tPica\n"
"\n"
"Zeit:\n"
"\t'yr'  \t\t\tJahr\n"
"\t'day' \t\tTag\n"
"\t'hr'  \t\t\tStunde\n"
"\t'mn'  \t\tMinute\n"
"\t'sec' \t\tSekunde\n"
"\n"
"Druck:\n"
"\t'Pa'  \t\tPascal\n"
"\t'atm' \t\tAtmosphäre\n"
"\t'mmHg'\t\tmm Quecksilbersäule\n"
"\n"
"Kraft:\n"
"\t'N'   \t\t\tNewton\n"
"\t'dyn' \t\tDyne\n"
"\t'lbf' \t\t\tPfund\n"
"\n"
"Energie:\n"
"\t'J'    \t\t\tJoule\n"
"\t'e'    \t\tErg\n"
"\t'c'    \t\tThermodynamische Kalorie\n"
"\t'cal'  \t\tIT Kalorie\n"
"\t'eV'   \t\tElektronen-Volt\n"
"\t'HPh'  \t\tPferdestärke-Stunde\n"
"\t'Wh'   \t\tWatt-Stunde\n"
"\t'flb'  \t\tFuß-Pfund\n"
"\t'BTU'  \t\tBTU\n"
"\n"
"Leistung:\n"
"\t'HP'   \t\tPS (Pferdestärke)\n"
"\t'W'    \t\tWatt\n"
"\n"
"Magnetismus:\n"
"\t'T'    \t\tTesla\n"
"\t'ga'   \t\tGauss\n"
"\n"
"Temperatur:\n"
"\t'C'    \t\tGrad Celsius\n"
"\t'F'    \t\tGrad Fahrenheit\n"
"\t'K'    \t\tGrad Kelvin\n"
"\n"
"Flüssigkeitsmaß:\n"
"\t'tsp'  \t\tTeelöffel\n"
"\t'tbs'  \t\tEsslöffel\n"
"\t'oz'   \t\tFlüssigunze\n"
"\t'cup'  \t\tTasse\n"
"\t'pt'   \t\tPint\n"
"\t'qt'   \t\tQuart\n"
"\t'gal'  \t\tGallone\n"
"\t'l'    \t\t\tLiter\n"
"\n"
"Für Metrische Einheiten kann eines der folgenden Präfixe verwendet werden:\n"
"\t'Y'  \tyotta \t\t1E+24\n"
"\t'Z'  \tzetta \t\t1E+21\n"
"\t'E'  \texa   \t\t1E+18\n"
"\t'P'  \tpeta  \t\t1E+15\n"
"\t'T'  \ttera  \t\t1E+12\n"
"\t'G'  \tgiga  \t\t1E+09\n"
"\t'M'  \tmega  \t\t1E+06\n"
"\t'k'  \tkilo  \t\t1E+03\n"
"\t'h'  \thecto \t\t1E+02\n"
"\t'e'  \tdeca (deka)\t1E+01\n"
"\t'd'  \tdeci  \t\t1E-01\n"
"\t'c'  \tcenti \t\t1E-02\n"
"\t'm'  \tmilli \t\t1E-03\n"
"\t'u'  \tmicro \t\t1E-06\n"
"\t'n'  \tnano  \t\t1E-09\n"
"\t'p'  \tpico  \t\t1E-12\n"
"\t'f'  \tfemto \t\t1E-15\n"
"\t'a'  \tatto  \t\t1E-18\n"
"\t'z'  \tzepto \t\t1E-21\n"
"\t'y'  \tyocto \t\t1E-24"

#: ../plugins/fn-eng/functions.c:751
msgid "This function is Excel compatible (except \"picapt\")."
msgstr "Diese Funktion ist mit Excel kompatibel (außer »picapt«)."

#: ../plugins/fn-eng/functions.c:1074
msgid "ERF:Gauss error function"
msgstr "ERF:Gaußsche Fehlerfunktion"

#: ../plugins/fn-eng/functions.c:1075
msgid "lower:lower limit of the integral, defaults to 0"
msgstr "lower:untere Grenze des Integrals, Vorgabe ist 0"

#: ../plugins/fn-eng/functions.c:1076
msgid "upper:upper limit of the integral"
msgstr "upper:obere Grenze des Integrals"

#: ../plugins/fn-eng/functions.c:1077
msgid ""
"ERF returns 2/sqrt(π)* integral from @{lower} to @{upper} of exp(-t*t) dt"
msgstr ""
"ERF gibt 1/sqrt(π) mal dem Integral von @{lower} bis @{upper} von exp(-t²) "
"dt zurück."

#: ../plugins/fn-eng/functions.c:1078
msgid ""
"This function is Excel compatible if two arguments are supplied and neither "
"is negative."
msgstr ""
"Diese Funktion ist mit Excel kompatibel, wenn zwei Argumente gegeben werden "
"und keines negativ ist."

#: ../plugins/fn-eng/functions.c:1083 ../plugins/fn-eng/functions.c:1110
msgid "wiki:en:Error_function"
msgstr "wiki:de:Error-Function"

#: ../plugins/fn-eng/functions.c:1105
msgid "ERFC:Complementary Gauss error function"
msgstr "ERFC:Komplementäre Gaußsche Fehlerfunktion"

#: ../plugins/fn-eng/functions.c:1107
msgid "ERFC returns 2/sqrt(π)* integral from @{x} to ∞ of exp(-t*t) dt"
msgstr ""
"ERFC gibt 2/sqrt(π) mal dem Integral von @{x} bis ∞ von exp(-t²) dt zurück."

#: ../plugins/fn-eng/functions.c:1125
msgid "DELTA:Kronecker delta function"
msgstr "DELTA:Kronecker-Delta-Funktion"

#: ../plugins/fn-eng/functions.c:1126 ../plugins/fn-eng/functions.c:1149
msgid "x0:number"
msgstr "x0:Zahl"

#: ../plugins/fn-eng/functions.c:1127 ../plugins/fn-eng/functions.c:1150
msgid "x1:number, defaults to 0"
msgstr "x1:Zahl, Vorgabe ist 0"

#: ../plugins/fn-eng/functions.c:1128
msgid "DELTA  returns 1 if  @{x1} = @{x0} and 0 otherwise."
msgstr "DELTA  gibt 1 zurück, falls  @{x1} = @{x0} und sonst 0."

#: ../plugins/fn-eng/functions.c:1129 ../plugins/fn-eng/functions.c:1152
msgid "If either argument is non-numeric, #VALUE! is returned."
msgstr ""
"Falls irgendein Argument nicht numerisch ist, wird #WERT! zurückgegeben"

#: ../plugins/fn-eng/functions.c:1148
msgid "GESTEP:step function with step at @{x1} evaluated at @{x0}"
msgstr "GESTEP: Schrittfunktion mit Sprung bei @{x1} ausgewertet in @{x0}"

#: ../plugins/fn-eng/functions.c:1151
msgid "GESTEP returns 1 if  @{x1} ≤ @{x0} and 0 otherwise."
msgstr "GESTEP gibt 1 zurück, falls  @{x1} ≤ @{x0} und sonst 0."

#: ../plugins/fn-eng/functions.c:1171
msgid "HEXREP:hexadecimal representation of numeric value"
msgstr "HEXREP:Hexadezimaldarstellung eines numerischen Werts"

#: ../plugins/fn-eng/functions.c:1173
msgid "HEXREP returns a hexadecimal string representation of @{x}."
msgstr "HEXREP gibt eine hexadezimale Zeichenkette zurück, die @{x} darstellt."

#: ../plugins/fn-eng/functions.c:1174
msgid ""
"This is a function meant for debugging.  The layout of the result may change "
"and even depend on how Gnumeric was compiled."
msgstr ""
"Dies ist eine Funktion zur Fehlerdiagnose. Das Layout des Ergebnisses kann "
"sich ändern und sogar davon abhängen, wie Gnumeric übersetzt wurde."

#: ../plugins/fn-eng/functions.c:1202
msgid "INVSUMINV:the reciprocal of the sum of reciprocals of the arguments"
msgstr "INVSUMINV:Der Kehrwert der Summe der Kehrwerte der Argumente"

#: ../plugins/fn-eng/functions.c:1203
msgid "x0:non-negative number"
msgstr "x0:nicht-negative Zahl"

#: ../plugins/fn-eng/functions.c:1204
msgid "x1:non-negative number"
msgstr "x1:nicht-negative Zahl"

#: ../plugins/fn-eng/functions.c:1205
msgid ""
"If any of the arguments is negative, #VALUE! is returned.\n"
"If any argument is zero, the result is zero."
msgstr ""
"Falls irgendein Argument negativ ist, wird #WERT! zurückgegeben.\n"
"Falls irgendein Argument Null ist, so ist das Ergebnis auch Null."

#: ../plugins/fn-eng/functions.c:1207
msgid ""
"INVSUMINV sum calculates the reciprocal (the inverse) of the sum of "
"reciprocals (inverses) of all its arguments."
msgstr ""
"INVSUMINV berechnet die reziproke Summe (den Kehrwert der Summe) aller "
"Kehrwerte aller ihrer Argumente."

#: ../plugins/fn-erlang/functions.c:105
msgid "PROBBLOCK:probability of blocking"
msgstr "PROBBLOCK: Wahrscheinlichkeit einer Blockierung"

#: ../plugins/fn-erlang/functions.c:106 ../plugins/fn-erlang/functions.c:191
msgid "traffic:number of calls"
msgstr "traffic:Anzahl der Calls"

#: ../plugins/fn-erlang/functions.c:107 ../plugins/fn-erlang/functions.c:132
#: ../plugins/fn-erlang/functions.c:229
msgid "circuits:number of circuits"
msgstr "circuits:Anzahl der Kreise"

#: ../plugins/fn-erlang/functions.c:108
msgid ""
"PROBBLOCK returns probability of blocking when @{traffic} calls load into @"
"{circuits} circuits."
msgstr ""

#: ../plugins/fn-erlang/functions.c:110 ../plugins/fn-erlang/functions.c:134
msgid "@{traffic} cannot exceed @{circuits}."
msgstr "@{traffic} darf nicht @{circuits} übersteigen."

#: ../plugins/fn-erlang/functions.c:130
msgid "OFFTRAF:predicted number of offered calls"
msgstr "OFFTRAF:vorhergesagte Anzahl angebotener Calls"

#: ../plugins/fn-erlang/functions.c:131
msgid "traffic:number of carried calls"
msgstr "traffic:Anzahl der ausgeführten Calls"

#: ../plugins/fn-erlang/functions.c:133
msgid ""
"OFFTRAF returns the predicted number of offered calls given @{traffic} "
"carried calls (taken from measurements) on @{circuits} circuits."
msgstr ""
"OFFTRAF gibt die vorhergesagte Anzahl angebotener Calls zurück, bei @"
"{traffic} ausgeführten Calls (aus der Messung bezogen) bei @{circuits} "
"circuits."

#: ../plugins/fn-erlang/functions.c:190
msgid "DIMCIRC:number of circuits required"
msgstr "DIMCIRC: Anzahl erforderlicher Schaltkreise"

#: ../plugins/fn-erlang/functions.c:192 ../plugins/fn-erlang/functions.c:230
msgid "gos:grade of service"
msgstr "gos:Dienstgrad"

#: ../plugins/fn-erlang/functions.c:193
msgid ""
"DIMCIRC returns the number of circuits required given @{traffic} calls with "
"grade of service @{gos}."
msgstr ""

#: ../plugins/fn-erlang/functions.c:228
msgid "OFFCAP:traffic capacity"
msgstr "OFFCAP:Verkehrskapazität"

#: ../plugins/fn-erlang/functions.c:231
msgid ""
"OFFCAP returns the traffic capacity given @{circuits} circuits with grade of "
"service @{gos}."
msgstr ""

#. *************************************************************************
#: ../plugins/fn-financial/functions.c:53
msgid "@{frequency} may be 1 (annual), 2 (semi-annual), or 4 (quarterly)."
msgstr ""
"@{Häufigkeit} kann 1 (jährlich), 2 (halbjährlich) oder 4 (vierteljährlich) "
"sein."

#: ../plugins/fn-financial/functions.c:56
msgid ""
"If @{type} is 0, the default, payment is at the end of each period.  If @"
"{type} is 1, payment is at the beginning of each period."
msgstr ""
"Wenn @{type} 0 ist, so erfolgt normalerweise die Zahlung am Ende jeder "
"Periode. Wenn @{type} 1 ist, so erfolgt die Zahlung zu Beginn jeder Periode."

#: ../plugins/fn-financial/functions.c:362
msgid "ACCRINT:accrued interest"
msgstr "ACCRINT:aufgelaufene Zinsen"

#: ../plugins/fn-financial/functions.c:363
#: ../plugins/fn-financial/functions.c:450
#: ../plugins/fn-financial/functions.c:605
#: ../plugins/fn-financial/functions.c:2461
#: ../plugins/fn-financial/functions.c:2500
#: ../plugins/fn-financial/functions.c:2650
msgid "issue:date of issue"
msgstr "issue:Datum der Ausgabe"

#: ../plugins/fn-financial/functions.c:364
msgid "first_interest:date of first interest payment"
msgstr "first_interest:Datum der ersten Zinszahlung"

#: ../plugins/fn-financial/functions.c:365
#: ../plugins/fn-financial/functions.c:488
#: ../plugins/fn-financial/functions.c:526
#: ../plugins/fn-financial/functions.c:567
#: ../plugins/fn-financial/functions.c:603
#: ../plugins/fn-financial/functions.c:648
#: ../plugins/fn-financial/functions.c:1086
#: ../plugins/fn-financial/functions.c:1124
#: ../plugins/fn-financial/functions.c:1158
#: ../plugins/fn-financial/functions.c:1890
#: ../plugins/fn-financial/functions.c:2255
#: ../plugins/fn-financial/functions.c:2305
#: ../plugins/fn-financial/functions.c:2414
#: ../plugins/fn-financial/functions.c:2459
#: ../plugins/fn-financial/functions.c:2498
#: ../plugins/fn-financial/functions.c:2648
#: ../plugins/fn-financial/functions.c:2744
#: ../plugins/fn-financial/functions.c:2822
#: ../plugins/fn-financial/functions.c:3002
#: ../plugins/fn-financial/functions.c:3026
#: ../plugins/fn-financial/functions.c:3050
#: ../plugins/fn-financial/functions.c:3074
#: ../plugins/fn-financial/functions.c:3100
#: ../plugins/fn-financial/functions.c:3126
#: ../plugins/fn-financial/functions.c:3238
#, fuzzy
msgid "settlement:settlement date"
msgstr "Datum und Zeit"

#: ../plugins/fn-financial/functions.c:366
#: ../plugins/fn-financial/functions.c:452
#: ../plugins/fn-financial/functions.c:529
#: ../plugins/fn-financial/functions.c:686
#: ../plugins/fn-financial/functions.c:2257
#: ../plugins/fn-financial/functions.c:2307
#: ../plugins/fn-financial/functions.c:2462
#: ../plugins/fn-financial/functions.c:2502
#: ../plugins/fn-financial/functions.c:2652
#: ../plugins/fn-financial/functions.c:2747
#: ../plugins/fn-financial/functions.c:2825
msgid "rate:nominal annual interest rate"
msgstr "rate:nomineller jährlicher Zinssatz "

#: ../plugins/fn-financial/functions.c:367
msgid "par:par value, defaults to $1000"
msgstr "par:Par-Wert, Vorgabe für ist $1000."

#: ../plugins/fn-financial/functions.c:368
#: ../plugins/fn-financial/functions.c:1894
#: ../plugins/fn-financial/functions.c:2260
#: ../plugins/fn-financial/functions.c:2310
#: ../plugins/fn-financial/functions.c:2505
#: ../plugins/fn-financial/functions.c:2655
#: ../plugins/fn-financial/functions.c:2750
#: ../plugins/fn-financial/functions.c:2828
#: ../plugins/fn-financial/functions.c:3004
#: ../plugins/fn-financial/functions.c:3028
#: ../plugins/fn-financial/functions.c:3052
#: ../plugins/fn-financial/functions.c:3076
#: ../plugins/fn-financial/functions.c:3102
#: ../plugins/fn-financial/functions.c:3128
#: ../plugins/fn-financial/functions.c:3242
msgid "frequency:number of interest payments per year"
msgstr "Häufigkeit: Anzahl der Zinszahlungen pro Jahr"

#: ../plugins/fn-financial/functions.c:369
msgid "basis:calendar basis, defaults to 0"
msgstr "basis:Kalenderbasis, Vorgabe ist 0"

#: ../plugins/fn-financial/functions.c:370
msgid "calc_method:calculation method, defaults to TRUE"
msgstr "calc_method:Die Berechnungsmethode. Vorgabe ist »WAHR«"

#: ../plugins/fn-financial/functions.c:372
msgid ""
"If @{first_interest} < @{settlement} and @{calc_method} is TRUE, then "
"ACCRINT returns the sum of the interest accrued in all coupon periods from @"
"{issue}  date until @{settlement} date."
msgstr ""
"Wenn @{first_interest} < @{settlement} und @{calc_method} WAHR ist, so gibt "
"ACCRINT die Summe der aufgelaufene Zinsen in allen Anleihezinszeiträumen vom "
"@{issue}-Datum bis zum @{settlement}-Datum zurück."

#: ../plugins/fn-financial/functions.c:377
msgid ""
"If @{first_interest} < @{settlement} and @{calc_method} is FALSE, then "
"ACCRINT returns the sum of the interest accrued in all coupon periods from @"
"{first_interest}  date until @{settlement} date."
msgstr ""
"Wenn @{first_interest} < @{settlement} und @{calc_method} FALSCH ist, so "
"gibt ACCRINT die Summe der aufgelaufene Zinsen in allen "
"Anleihezinszeiträumen vom @{first_interest}-Datum bis zum @{settlement}-"
"Datum zurück."

#: ../plugins/fn-financial/functions.c:382
msgid ""
"Otherwise ACCRINT returns the sum of the interest accrued in all coupon "
"periods from @{issue}  date until @{settlement} date."
msgstr ""
"Andernfalls gibt ACCRINT die Summe der aufgelaufene Zinsen in allen "
"Anleihezinszeiträumen vom @{issue}-Datum bis zum @{settlement}-Datum zurück."

#: ../plugins/fn-financial/functions.c:385
msgid ""
"@{frequency} must be one of 1, 2 or 4, but the exact value does not affect "
"the result."
msgstr ""
"@{Häufigkeit} muss entweder 1, 2 oder 4 sein, aber der genaue Wert "
"beeinflusst nicht das Ergebnis."

#: ../plugins/fn-financial/functions.c:387
msgid "@{issue} must precede both @{first_interest} and @{settlement}."
msgstr ""
"@{issue} muss sowohl @{first_interest} als auch @{settlement} vorausgehen."

#: ../plugins/fn-financial/functions.c:449
msgid "ACCRINTM:accrued interest"
msgstr "ACCRINTM:aufgelaufene Zinsen"

#: ../plugins/fn-financial/functions.c:451
#: ../plugins/fn-financial/functions.c:489
#: ../plugins/fn-financial/functions.c:527
#: ../plugins/fn-financial/functions.c:568
#: ../plugins/fn-financial/functions.c:604
#: ../plugins/fn-financial/functions.c:649
#: ../plugins/fn-financial/functions.c:1087
#: ../plugins/fn-financial/functions.c:1125
#: ../plugins/fn-financial/functions.c:1159
#: ../plugins/fn-financial/functions.c:1891
#: ../plugins/fn-financial/functions.c:2256
#: ../plugins/fn-financial/functions.c:2306
#: ../plugins/fn-financial/functions.c:2415
#: ../plugins/fn-financial/functions.c:2460
#: ../plugins/fn-financial/functions.c:2499
#: ../plugins/fn-financial/functions.c:2649
#: ../plugins/fn-financial/functions.c:2745
#: ../plugins/fn-financial/functions.c:2823
#: ../plugins/fn-financial/functions.c:3003
#: ../plugins/fn-financial/functions.c:3027
#: ../plugins/fn-financial/functions.c:3051
#: ../plugins/fn-financial/functions.c:3075
#: ../plugins/fn-financial/functions.c:3101
#: ../plugins/fn-financial/functions.c:3127
#: ../plugins/fn-financial/functions.c:3239
msgid "maturity:maturity date"
msgstr "Fälligkeit:Fälligkeitsdatum"

#: ../plugins/fn-financial/functions.c:453
#, fuzzy
msgid "par:par value"
msgstr "Vorgabe-Wert"

#: ../plugins/fn-financial/functions.c:455
msgid "ACCRINTM calculates the accrued interest from @{issue} to @{maturity}."
msgstr ""
"ACCRINTM berechnet die aufgelaufene Zinsen von @{issue} bis @{maturity}."

#: ../plugins/fn-financial/functions.c:456
msgid "@{par} defaults to $1000."
msgstr "Vorgabe für @{par} ist $1000."

#: ../plugins/fn-financial/functions.c:487
msgid "INTRATE:interest rate"
msgstr "INTRATE:Zinssatz"

#: ../plugins/fn-financial/functions.c:490
#: ../plugins/fn-financial/functions.c:528
msgid "investment:amount paid on settlement"
msgstr ""

#: ../plugins/fn-financial/functions.c:491
#: ../plugins/fn-financial/functions.c:570
#: ../plugins/fn-financial/functions.c:651
#: ../plugins/fn-financial/functions.c:2259
#: ../plugins/fn-financial/functions.c:2309
#: ../plugins/fn-financial/functions.c:2417
#: ../plugins/fn-financial/functions.c:2504
#: ../plugins/fn-financial/functions.c:2654
#: ../plugins/fn-financial/functions.c:2749
#: ../plugins/fn-financial/functions.c:2827
#, fuzzy
msgid "redemption:amount received at maturity"
msgstr "RECEIVED:Zu erhaltender Betrag bei Fälligkeit"

#: ../plugins/fn-financial/functions.c:493
msgid "INTRATE calculates the interest of a fully vested security."
msgstr ""

#: ../plugins/fn-financial/functions.c:525
msgid "RECEIVED:amount to be received at maturity"
msgstr "RECEIVED:Zu erhaltender Betrag bei Fälligkeit"

#: ../plugins/fn-financial/functions.c:531
msgid "RECEIVED calculates the amount to be received when a security matures."
msgstr ""
"RECEIVED berechnet den zu erhaltenden Betrag bei Fälligkeit einer Sicherheit."

#: ../plugins/fn-financial/functions.c:566
msgid "PRICEDISC:discounted price"
msgstr "PRICEDISC:abgezinster Preis"

#: ../plugins/fn-financial/functions.c:569
#: ../plugins/fn-financial/functions.c:606
#: ../plugins/fn-financial/functions.c:1088
#: ../plugins/fn-financial/functions.c:1126
msgid "discount:annual rate at which to discount"
msgstr "discount:jährliche Abschlagsrate"

#: ../plugins/fn-financial/functions.c:572
#, fuzzy
msgid ""
"PRICEDISC calculates the price per $100 face value of a bond that does not "
"pay interest at maturity."
msgstr ""
"PRICEDISC berechnet den Preis je 100$ Nennwert eines ?, das nicht Zinsen bei "
"Fälligkeit zahlt."

#: ../plugins/fn-financial/functions.c:602
msgid "PRICEMAT:price at maturity"
msgstr "PRICEMAT:Preis bei Fälligkeit"

#: ../plugins/fn-financial/functions.c:607
#: ../plugins/fn-financial/functions.c:1893
#: ../plugins/fn-financial/functions.c:2258
#: ../plugins/fn-financial/functions.c:2503
#: ../plugins/fn-financial/functions.c:2748
#: ../plugins/fn-financial/functions.c:3241
msgid "yield:annual yield of security"
msgstr "yield:Jährlicher Ertrag einer Sicherheit"

#: ../plugins/fn-financial/functions.c:609
#, fuzzy
msgid ""
"PRICEMAT calculates the price per $100 face value of a bond that pays "
"interest at maturity."
msgstr ""
"PRICEMAT berechnet den Preis je 100$ Nennwert eines ?, das Zinsen bei "
"Fälligkeit zahlt."

#: ../plugins/fn-financial/functions.c:647
msgid "DISC:discount rate"
msgstr "DISC:Abschlagsrate"

#: ../plugins/fn-financial/functions.c:650
msgid "par:price per $100 face value"
msgstr "par:Preis je 100$ Nennwert"

#: ../plugins/fn-financial/functions.c:653
msgid "DISC calculates the discount rate for a security."
msgstr "DISC berechnet den Diskontfaktor für eine Bürgschaft."

#: ../plugins/fn-financial/functions.c:654
msgid "@{redemption} is the redemption value per $100 face value."
msgstr ""

#: ../plugins/fn-financial/functions.c:685
msgid "EFFECT:effective interest rate"
msgstr "EFFECT:effektiver Zinssatz"

#: ../plugins/fn-financial/functions.c:687
#: ../plugins/fn-financial/functions.c:712
msgid "nper:number of periods used for compounding"
msgstr ""

#: ../plugins/fn-financial/functions.c:688
msgid ""
"EFFECT calculates the effective interest rate using the formula (1+@{rate}/@"
"{nper})^@{nper}-1."
msgstr ""
"EFFECT berechnet den effektiven Zinssatz mit der Formel (1+@{rate}/@{nper})^@"
"{nper}-1."

#: ../plugins/fn-financial/functions.c:710
msgid "NOMINAL:nominal interest rate"
msgstr "NOMINAL:nomineller Zinssatz"

#: ../plugins/fn-financial/functions.c:711
#: ../plugins/fn-financial/functions.c:736
#: ../plugins/fn-financial/functions.c:1542
#: ../plugins/fn-financial/functions.c:1728
#: ../plugins/fn-financial/functions.c:1758
#: ../plugins/fn-financial/functions.c:1798
#: ../plugins/fn-financial/functions.c:1842
#: ../plugins/fn-financial/functions.c:1936
msgid "rate:effective annual interest rate"
msgstr "rate:effektiver jährlicher Zinssatz"

#: ../plugins/fn-financial/functions.c:713
msgid "NOMINAL calculates the nominal interest rate from the effective rate."
msgstr "NOMINAL berechnet die Normalverzinsung aus dem effektiven Zins."

#: ../plugins/fn-financial/functions.c:735
msgid "ISPMT:interest payment for period"
msgstr "ISPMT:Zinszahlung für die Periode"

#: ../plugins/fn-financial/functions.c:737
#: ../plugins/fn-financial/functions.c:1759
#: ../plugins/fn-financial/functions.c:1799
msgid "per:period number"
msgstr "per:Periodenzahl"

#: ../plugins/fn-financial/functions.c:738
#: ../plugins/fn-financial/functions.c:1192
#: ../plugins/fn-financial/functions.c:1459
#: ../plugins/fn-financial/functions.c:1693
#: ../plugins/fn-financial/functions.c:1729
#: ../plugins/fn-financial/functions.c:1760
#: ../plugins/fn-financial/functions.c:1800
#: ../plugins/fn-financial/functions.c:3151
#: ../plugins/fn-financial/functions.c:3195
msgid "nper:number of periods"
msgstr "nper:Anzahl der Perioden"

#: ../plugins/fn-financial/functions.c:739
#: ../plugins/fn-financial/functions.c:1194
#: ../plugins/fn-financial/functions.c:1307
#: ../plugins/fn-financial/functions.c:1695
#: ../plugins/fn-financial/functions.c:1730
#: ../plugins/fn-financial/functions.c:1761
#: ../plugins/fn-financial/functions.c:1801
#: ../plugins/fn-financial/functions.c:1844
#: ../plugins/fn-financial/functions.c:1937
#: ../plugins/fn-financial/functions.c:3152
#: ../plugins/fn-financial/functions.c:3196
msgid "pv:present value"
msgstr ""

#: ../plugins/fn-financial/functions.c:740
msgid "ISPMT calculates the interest payment for period number @{per}."
msgstr ""

#: ../plugins/fn-financial/functions.c:771
msgid "DB:depreciation of an asset"
msgstr "DB:Abschreibung eines Vermögenswerts"

#: ../plugins/fn-financial/functions.c:772
#: ../plugins/fn-financial/functions.c:822
#: ../plugins/fn-financial/functions.c:871
#: ../plugins/fn-financial/functions.c:901
#: ../plugins/fn-financial/functions.c:2900
#: ../plugins/fn-financial/functions.c:2956
#: ../plugins/fn-financial/functions.c:3285
msgid "cost:initial cost of asset"
msgstr "cost:Anfängliche Kosten eines Vermögenswerts"

#: ../plugins/fn-financial/functions.c:773
#: ../plugins/fn-financial/functions.c:823
#: ../plugins/fn-financial/functions.c:872
#: ../plugins/fn-financial/functions.c:902
#: ../plugins/fn-financial/functions.c:2903
#: ../plugins/fn-financial/functions.c:2959
#: ../plugins/fn-financial/functions.c:3286
msgid "salvage:value after depreciation"
msgstr "salvage:Wert nach der Abschreibung"

#: ../plugins/fn-financial/functions.c:774
#: ../plugins/fn-financial/functions.c:824
#: ../plugins/fn-financial/functions.c:873
#: ../plugins/fn-financial/functions.c:903
#: ../plugins/fn-financial/functions.c:3287
msgid "life:number of periods"
msgstr "life:Anzahl der Perioden"

#: ../plugins/fn-financial/functions.c:775
#: ../plugins/fn-financial/functions.c:825
#: ../plugins/fn-financial/functions.c:904
#: ../plugins/fn-financial/functions.c:2904
#: ../plugins/fn-financial/functions.c:2960
msgid "period:subject period"
msgstr ""

#: ../plugins/fn-financial/functions.c:776
msgid "month:number of months in first year of depreciation"
msgstr "month: Anzahl der Monate im ersten Jahr der Abschreibung"

#: ../plugins/fn-financial/functions.c:777
msgid ""
"DB calculates the depreciation of an asset for a given period using the "
"fixed-declining balance method."
msgstr ""

#: ../plugins/fn-financial/functions.c:821
msgid "DDB:depreciation of an asset"
msgstr "DDB:Abschreibung eines Vermögenswerts"

#: ../plugins/fn-financial/functions.c:826
#: ../plugins/fn-financial/functions.c:3290
msgid "factor:factor at which the balance declines"
msgstr ""

#: ../plugins/fn-financial/functions.c:827
msgid ""
"DDB calculates the depreciation of an asset for a given period using the "
"double-declining balance method."
msgstr ""

#: ../plugins/fn-financial/functions.c:870
msgid "SLN:depreciation of an asset"
msgstr "SLN:Abschreibung eines Vermögenswerts"

#: ../plugins/fn-financial/functions.c:874
#, fuzzy
msgid ""
"SLN calculates the depreciation of an asset using the straight-line method."
msgstr ""
"SLN berechnet die Abschreibung eines Vermögenswerts mit der Methode der (?)"

#: ../plugins/fn-financial/functions.c:900
#, fuzzy
msgid "SYD:sum-of-years depreciation"
msgstr "Sum-of-the-Years-Digits-Abschreibung"

#: ../plugins/fn-financial/functions.c:905
msgid ""
"SYD calculates the depreciation of an asset using the sum-of-years method."
msgstr ""

#: ../plugins/fn-financial/functions.c:933
msgid "DOLLARDE:convert to decimal dollar amount"
msgstr "DOLLARDE:in dezimalen Dollarbetrag umwandeln"

#: ../plugins/fn-financial/functions.c:934
msgid "fractional_dollar:amount to convert"
msgstr "fractional_dollar:der umzuwandelnde Wert"

#: ../plugins/fn-financial/functions.c:935
#: ../plugins/fn-financial/functions.c:983
msgid "fraction:denominator"
msgstr "fraction:Nenner"

#: ../plugins/fn-financial/functions.c:936
msgid ""
"DOLLARDE converts a fractional dollar amount into a decimal amount.  This is "
"the inverse of the DOLLARFR function."
msgstr ""
"DOLLARDE wandelt einen Dollar-Bruchteil in einen dezimalen Betrag um. Dies "
"entspricht dem Gegenteil der Funktion »DOLLARFR«."

#: ../plugins/fn-financial/functions.c:981
msgid "DOLLARFR:convert to dollar fraction"
msgstr "DOLLARFR:wandelt in einen Dollar-Bruchteil um"

#: ../plugins/fn-financial/functions.c:982
msgid "decimal_dollar:amount to convert"
msgstr "decimal_dollar:umzuwandelnder Betrag"

#: ../plugins/fn-financial/functions.c:984
msgid ""
"DOLLARFR converts a decimal dollar amount into a fractional amount which is "
"represented as the digits after the decimal point.  For example, 2/8 would "
"be represented as .2 while 3/16 would be represented as .03. This is the "
"inverse of the DOLLARDE function."
msgstr ""
"DOLLARFR wandelt einen dezimalen Dollarbetrag in einen Bruchteil um, welcher "
"als die Ziffer nach dem Dezimalkomma dargestellt wird. Zum Beispiel wird 2/8 "
"als »,2« dargestellt, während 3/16 als »,03« dargestellt wird. Dies "
"entspricht der Umkehrung der Funktion »DOLLARDE«."

#: ../plugins/fn-financial/functions.c:1027
msgid "MIRR:modified internal rate of return"
msgstr ""

#: ../plugins/fn-financial/functions.c:1028
#: ../plugins/fn-financial/functions.c:1341
#: ../plugins/fn-financial/functions.c:1543
#: ../plugins/fn-financial/functions.c:1598
msgid "values:cash flow"
msgstr "values:Geldfluss"

#: ../plugins/fn-financial/functions.c:1029
msgid "finance_rate:interest rate for financing cost"
msgstr ""

#: ../plugins/fn-financial/functions.c:1030
msgid "reinvest_rate:interest rate for reinvestments"
msgstr ""

#: ../plugins/fn-financial/functions.c:1031
msgid ""
"MIRR calculates the modified internal rate of return of a periodic cash flow."
msgstr ""

#: ../plugins/fn-financial/functions.c:1085
msgid "TBILLEQ:bond-equivalent yield for a treasury bill"
msgstr ""

#: ../plugins/fn-financial/functions.c:1089
msgid "TBILLEQ calculates the bond-equivalent yield for a treasury bill."
msgstr ""

#: ../plugins/fn-financial/functions.c:1123
msgid "TBILLPRICE:price of a treasury bill"
msgstr ""

#: ../plugins/fn-financial/functions.c:1127
msgid ""
"TBILLPRICE calculates the price per $100 face value for a treasury bill."
msgstr ""

#: ../plugins/fn-financial/functions.c:1157
msgid "TBILLYIELD:yield of a treasury bill"
msgstr ""

#: ../plugins/fn-financial/functions.c:1160
msgid "price:price"
msgstr "price:Preis"

#: ../plugins/fn-financial/functions.c:1161
msgid "TBILLYIELD calculates the yield of a treasury bill."
msgstr ""

#: ../plugins/fn-financial/functions.c:1191
msgid "RATE:rate of investment"
msgstr "RATE:Investitionsquote"

#: ../plugins/fn-financial/functions.c:1193
#: ../plugins/fn-financial/functions.c:1460
#: ../plugins/fn-financial/functions.c:1694
#: ../plugins/fn-financial/functions.c:1843
msgid "pmt:payment at each period"
msgstr "pmt:Zahlung in jeder Periode"

#: ../plugins/fn-financial/functions.c:1195
#: ../plugins/fn-financial/functions.c:1308
#: ../plugins/fn-financial/functions.c:1461
#: ../plugins/fn-financial/functions.c:1731
#: ../plugins/fn-financial/functions.c:1762
#: ../plugins/fn-financial/functions.c:1802
#: ../plugins/fn-financial/functions.c:1845
#: ../plugins/fn-financial/functions.c:1938
msgid "fv:future value"
msgstr "fv:Zukunftswert"

#: ../plugins/fn-financial/functions.c:1196
#: ../plugins/fn-financial/functions.c:1462
#: ../plugins/fn-financial/functions.c:1696
#: ../plugins/fn-financial/functions.c:1732
#: ../plugins/fn-financial/functions.c:1763
#: ../plugins/fn-financial/functions.c:1803
#: ../plugins/fn-financial/functions.c:1846
#: ../plugins/fn-financial/functions.c:3155
#: ../plugins/fn-financial/functions.c:3199
msgid "type:payment type"
msgstr "type:Zahlungsweise"

#: ../plugins/fn-financial/functions.c:1197
#: ../plugins/fn-financial/functions.c:1342
#: ../plugins/fn-financial/functions.c:1600
msgid "guess:an estimate of what the result should be"
msgstr "guess:Eine Schätzung, wie das Ergebnis sein sollte"

#: ../plugins/fn-financial/functions.c:1198
msgid "RATE calculates the rate of return."
msgstr "RATE berechnet die Rendite"

#: ../plugins/fn-financial/functions.c:1200
#: ../plugins/fn-financial/functions.c:1345
#: ../plugins/fn-financial/functions.c:1602
msgid ""
"The optional @{guess} is needed because there can be more than one valid "
"result.  It defaults to 10%."
msgstr ""
"Das optionale @{guess} ist notwendig, weil es mehr als ein gültiges Ergebnis "
"geben kann. Die Voreinstellung ist 10%."

#: ../plugins/fn-financial/functions.c:1305
msgid "RRI:equivalent interest rate for an investment increasing in value"
msgstr ""

#: ../plugins/fn-financial/functions.c:1306
msgid "p:number of periods"
msgstr "p:Anzahl der Perioden"

#: ../plugins/fn-financial/functions.c:1309
msgid ""
"RRI determines an equivalent interest rate for an investment that increases "
"in value. The interest is compounded after each complete period."
msgstr ""

#: ../plugins/fn-financial/functions.c:1311
msgid ""
"Note that @{p} need not be an integer but for fractional value the "
"calculated rate is only approximate."
msgstr ""
"Beachten Sie, dass @{p} keine Ganzzahl sein muss. Für Bruchzahlen aber ist "
"die berechnete Rate nur eine Näherung."

#: ../plugins/fn-financial/functions.c:1340
msgid "IRR:internal rate of return"
msgstr ""

#: ../plugins/fn-financial/functions.c:1343
msgid ""
"IRR calculates the internal rate of return of a cash flow with periodic "
"payments.  @{values} lists the payments (negative values) and receipts "
"(positive values) for each period."
msgstr ""

#: ../plugins/fn-financial/functions.c:1457
msgid "PV:present value"
msgstr "PV:Barwert"

#: ../plugins/fn-financial/functions.c:1458
#: ../plugins/fn-financial/functions.c:1498
#: ../plugins/fn-financial/functions.c:1692
msgid "rate:effective interest rate per period"
msgstr "rate:effektiver Zinssatz pro Periode"

#: ../plugins/fn-financial/functions.c:1463
msgid ""
"PV calculates the present value of @{fv} which is @{nper} periods into the "
"future, assuming a periodic payment of @{pmt} and an interest rate of @"
"{rate} per period."
msgstr ""
"PV berechnet den Barwert von @{fv}, der @{nper} Perioden in der Zukunft "
"liegt, ausgehend von einer regelmäßigen Zahlung von @{pmt} und einem "
"Zinssatz von @{rate} pro Periode."

#: ../plugins/fn-financial/functions.c:1497
msgid "NPV:net present value"
msgstr "NPV:Netto-Kapitalwert"

#: ../plugins/fn-financial/functions.c:1499
msgid "value1:cash flow for period 1"
msgstr "value1:Kapitalfluss in Periode 1"

#: ../plugins/fn-financial/functions.c:1500
msgid "value2:cash flow for period 2"
msgstr "value2:Kapitalfluss in Periode 2"

#: ../plugins/fn-financial/functions.c:1501
msgid "NPV calculates the net present value of a cash flow."
msgstr "NPV berechnet den Netto-Kapitalwert eines Finanzflusses."

#: ../plugins/fn-financial/functions.c:1541
msgid "XNPV:net present value"
msgstr "XNPV:Netto-Kapitalwert"

#: ../plugins/fn-financial/functions.c:1544
#: ../plugins/fn-financial/functions.c:1599
#, fuzzy
msgid "dates:dates of cash flow"
msgstr "values:Geldfluss"

#: ../plugins/fn-financial/functions.c:1545
msgid "XNPV calculates the net present value of a cash flow at irregular times"
msgstr ""
"XNPV berechnet den Netto-Kapitalwert eines Finanzflusses zu unregelmäßigen "
"Zeiten"

#: ../plugins/fn-financial/functions.c:1597
msgid "XIRR:internal rate of return"
msgstr ""

#: ../plugins/fn-financial/functions.c:1601
msgid ""
"XIRR calculates the annualized internal rate of return of a cash flow at "
"arbitrary points in time.  @{values} lists the payments (negative values) "
"and receipts (positive values) with one value for each entry in @{dates}."
msgstr ""

#: ../plugins/fn-financial/functions.c:1691
msgid "FV:future value"
msgstr "FV:Zukunftswert"

#: ../plugins/fn-financial/functions.c:1697
msgid ""
"FV calculates the future value of @{pv} moved @{nper} periods into the "
"future, assuming a periodic payment of @{pmt} and an interest rate of @"
"{rate} per period."
msgstr ""

#: ../plugins/fn-financial/functions.c:1727
msgid "PMT:payment for annuity"
msgstr ""

#: ../plugins/fn-financial/functions.c:1733
msgid "PMT calculates the payment amount for an annuity."
msgstr ""

#: ../plugins/fn-financial/functions.c:1757
msgid "IPMT:interest payment for period"
msgstr "IPMT:Zinszahlung für Periode"

#: ../plugins/fn-financial/functions.c:1764
msgid ""
"IPMT calculates the interest part of an annuity's payment for period number @"
"{per}."
msgstr ""

#: ../plugins/fn-financial/functions.c:1797
msgid "PPMT:interest payment for period"
msgstr "PPMT:Zinszahlung für die Periode"

#: ../plugins/fn-financial/functions.c:1804
msgid ""
"PPMT calculates the principal part of an annuity's payment for period number "
"@{per}."
msgstr ""

#: ../plugins/fn-financial/functions.c:1841
msgid "NPER:number of periods"
msgstr "NPER:Anzahl der Perioden"

#: ../plugins/fn-financial/functions.c:1847
msgid ""
"NPER calculates the number of periods of an investment based on periodic "
"constant payments and a constant interest rate."
msgstr ""

#: ../plugins/fn-financial/functions.c:1889
msgid "DURATION:the (Macaulay) duration of a security"
msgstr "DURATION:Die Dauer (Macaulay) einer Bürgschaft"

#: ../plugins/fn-financial/functions.c:1892
#: ../plugins/fn-financial/functions.c:3240
#, fuzzy
msgid "coupon:annual coupon rate"
msgstr "rate:nomineller jährlicher Zinssatz "

#: ../plugins/fn-financial/functions.c:1896
msgid "DURATION calculates the (Macaulay) duration of a security."
msgstr "DURATION berechnet die (Macaulay)-Dauer einer Bürgschaft."

#: ../plugins/fn-financial/functions.c:1935
#, fuzzy
msgid "G_DURATION:the duration of a investment"
msgstr "RATE:Investitionsquote"

#: ../plugins/fn-financial/functions.c:1939
msgid ""
"G_DURATION calculates the number of periods needed for an investment to "
"attain a desired value."
msgstr ""

#: ../plugins/fn-financial/functions.c:1940
msgid "G_DURATION is the OpenFormula function PDURATION."
msgstr ""

#: ../plugins/fn-financial/functions.c:1969
msgid "FVSCHEDULE:future value"
msgstr "FVSCHEDULE:Zukunftswert"

#: ../plugins/fn-financial/functions.c:1970
msgid "principal:initial value"
msgstr "principal:Ausgangswert"

#: ../plugins/fn-financial/functions.c:1971
msgid "schedule:range of interest rates"
msgstr "schedule:Spanne von Zinssätzen"

#: ../plugins/fn-financial/functions.c:1972
msgid ""
"FVSCHEDULE calculates the future value of @{principal} after applying a "
"range of interest rates with compounding."
msgstr ""

#: ../plugins/fn-financial/functions.c:2005
msgid "EURO:equivalent of 1 EUR"
msgstr "EURO:Wert von 1 EUR"

#: ../plugins/fn-financial/functions.c:2006
msgid "currency:three-letter currency code"
msgstr "currency:Aus drei Buchstaben bestehender Währungscode"

#: ../plugins/fn-financial/functions.c:2007
msgid ""
"EURO calculates the national currency amount corresponding to 1 EUR for any "
"of the national currencies that were replaced by the Euro on its "
"introduction."
msgstr ""
"EURO berechnet den Betrag einer nationalen Währung, der 1 EUR bei Einführung "
"des Euro als Ersatz für eine nationale Währung entspricht."

#: ../plugins/fn-financial/functions.c:2008
msgid ""
"@{currency} must be one of ATS (Austria), BEF (Belgium), CYP (Cyprus), DEM "
"(Germany), EEK (Estonia), ESP (Spain), EUR (Euro), FIM (Finland), FRF "
"(France), GRD (Greece), IEP (Ireland), ITL (Italy), LUF (Luxembourg), MTL "
"(Malta), NLG (The Netherlands), PTE (Portugal), SIT (Slovenia), or SKK "
"(Slovakia)."
msgstr ""
"@{currency} muss einer der folgenden Werte sein: ATS (Österreich), BEF "
"(Belgien), CYP (Zypern), DEM (Deutschland), EEK (Estland), ESP (Spanien), "
"EUR (Euro), FIM (Finnland), FRF (Frankreich), GRD (Griechenland), IEP "
"(Irland), ITL (Italien), LUF (Luxemburg), MTL (Malta), NLG (Niederlande), "
"PTE (Portugal), SIT (Slowenien) oder SKK (Slowakei)."

#: ../plugins/fn-financial/functions.c:2027
#: ../plugins/fn-financial/functions.c:2211
msgid "This function is not likely to be useful anymore."
msgstr "Diese Funktion ist wahrscheinlich nicht mehr nützlich."

#: ../plugins/fn-financial/functions.c:2202
msgid "EUROCONVERT:pre-Euro amount from one currency to another"
msgstr ""
"EUROCONVERT:Betrag von einer Währung in eine andere vor Einführung des Euro"

#: ../plugins/fn-financial/functions.c:2203
msgid "n:amount"
msgstr "n:Betrag"

#: ../plugins/fn-financial/functions.c:2204
msgid "source:three-letter source currency code"
msgstr "source:Aus drei Buchstaben bestehender Code der Quellwährung"

#: ../plugins/fn-financial/functions.c:2205
msgid "target:three-letter target currency code"
msgstr "target:Aus drei Buchstaben bestehender Code der Zielwährung"

#: ../plugins/fn-financial/functions.c:2206
msgid "full_precision:whether to provide the full precision; defaults to false"
msgstr ""

#: ../plugins/fn-financial/functions.c:2207
msgid ""
"triangulation_precision:number of digits (at least 3) to be rounded to after "
"conversion of the source currency to euro; defaults to no rounding"
msgstr ""

#: ../plugins/fn-financial/functions.c:2208
msgid ""
"EUROCONVERT converts @{n} units of currency @{source} to currency @"
"{target}.  The rates used are the official ones used on the introduction of "
"the Euro."
msgstr ""
"EUROCONVERT wandelt @{n} Einheiten der Währung @{source} in Währung @"
"{target} um. Die verwendeten Umrechnungsraten entsprechen den offiziellen "
"bei Einführung des Euro."

#: ../plugins/fn-financial/functions.c:2209
msgid ""
"If @{full_precision} is true, the result is not rounded; if it false the "
"result is rounded to 0 or 2 decimals depending on the target currency; "
"defaults to false."
msgstr ""
"Falls @{full_precision} »wahr« ist, wird das Ergebnis nicht gerundet, wenn "
"es »falsch« ist, wird das Ergebnis auf 0 oder 2 Dezimalstellen gerundet, "
"abhängig von der Zielwährung. Vorgabe ist »falsch«."

#: ../plugins/fn-financial/functions.c:2210
msgid ""
"@{source} and @{target} must be one of the currencies listed for the EURO "
"function."
msgstr ""
"@{source} und @{target} müssen in der Liste der EURO-Funktionen aufgeführte "
"Währungen sein."

#: ../plugins/fn-financial/functions.c:2254
msgid "PRICE:price of a security"
msgstr "PRICE:Preis einer Bürgschaft"

#: ../plugins/fn-financial/functions.c:2262
msgid ""
"PRICE calculates the price per $100 face value of a security that pays "
"periodic interest."
msgstr ""
"PRICE berechnet den Preis je $100 Nennwert einer Bürgschaft, die periodisch "
"Zinsen liefert."

#: ../plugins/fn-financial/functions.c:2304
msgid "YIELD:yield of a security"
msgstr "YIELD:Ertrag einer Bürgschaft"

#: ../plugins/fn-financial/functions.c:2308
#: ../plugins/fn-financial/functions.c:2416
#: ../plugins/fn-financial/functions.c:2463
#: ../plugins/fn-financial/functions.c:2653
#: ../plugins/fn-financial/functions.c:2826
msgid "price:price of security"
msgstr "price:Preis einer Bürgschaft"

#: ../plugins/fn-financial/functions.c:2312
msgid "YIELD calculates the yield of a security that pays periodic interest."
msgstr ""
"YIELD berechnet den Ertrag einer Bürgschaft, die periodisch Zinsen liefert."

#: ../plugins/fn-financial/functions.c:2413
msgid "YIELDDISC:yield of a discounted security"
msgstr "YIELDDISC:Ertrag einer abgezinsten Sicherheit"

#: ../plugins/fn-financial/functions.c:2419
msgid "YIELDDISC calculates the yield of a discounted security."
msgstr "YIELDDISC berechnet den Ertrag einer abgezinsten Sicherheit."

#: ../plugins/fn-financial/functions.c:2458
msgid "YIELDMAT:yield of a security"
msgstr "YIELDMAT:Ertrag einer Bürgschaft"

#: ../plugins/fn-financial/functions.c:2465
msgid ""
"YIELDMAT calculates the yield of a security for which the interest is paid "
"at maturity date."
msgstr ""
"YIELDMAT berechnet den Ertrag einer Bürgschaft, für welche der Zins zu einem "
"Fälligkeitsdatum gezahlt wird."

#: ../plugins/fn-financial/functions.c:2497
#, fuzzy
msgid "ODDFPRICE:price of a security that has an odd first period"
msgstr "ODDFPRICE:Preis einer Bürgschaft, welche ?"

#: ../plugins/fn-financial/functions.c:2501
#: ../plugins/fn-financial/functions.c:2651
msgid "first_interest:first interest date"
msgstr "first_interest:Datum der ersten Zinszahlung"

#: ../plugins/fn-financial/functions.c:2507
#, fuzzy
msgid ""
"ODDFPRICE calculates the price per $100 face value of a security that pays "
"periodic interest, but has an odd first period."
msgstr ""
"ODDFPRICE berechnet den Preis je $100 Nennwert einer Bürgschaft, die "
"periodisch Zinsen liefert, aber ?"

#: ../plugins/fn-financial/functions.c:2647
#, fuzzy
msgid "ODDFYIELD:yield of a security that has an odd first period"
msgstr "ODDFYIELD:Ertrag einer Bürgschaft, welche ?"

#: ../plugins/fn-financial/functions.c:2657
#, fuzzy
msgid ""
"ODDFYIELD calculates the yield of a security that pays periodic interest, "
"but has an odd first period."
msgstr ""
"ODDFYIELD berechnet den Ertrag einer Bürgschaft, die periodisch Zinsen "
"liefert, aber ?"

#: ../plugins/fn-financial/functions.c:2743
#, fuzzy
msgid "ODDLPRICE:price of a security that has an odd last period"
msgstr "ODDLPRICE:Preis einer Bürgschaft, welche ?"

#: ../plugins/fn-financial/functions.c:2746
#: ../plugins/fn-financial/functions.c:2824
msgid "last_interest:last interest date"
msgstr "last_interest:Datum der letzten Zinszahlung"

#: ../plugins/fn-financial/functions.c:2752
#, fuzzy
msgid ""
"ODDLPRICE calculates the price per $100 face value of a security that pays "
"periodic interest, but has an odd last period."
msgstr ""
"ODDLPRICE berechnet den Preis je $100 Nennwert einer Bürgschaft, die "
"periodisch Zinsen liefert, aber ?"

#: ../plugins/fn-financial/functions.c:2821
#, fuzzy
msgid "ODDLYIELD:yield of a security that has an odd last period"
msgstr "ODDLYIELD:Ertrag einer Bürgschaft, welche ?"

#: ../plugins/fn-financial/functions.c:2830
msgid ""
"ODDLYIELD calculates the yield of a security that pays periodic interest, "
"but has an odd last period."
msgstr ""

#: ../plugins/fn-financial/functions.c:2899
msgid "AMORDEGRC:depreciation of an asset using French accounting conventions"
msgstr ""

#: ../plugins/fn-financial/functions.c:2901
#: ../plugins/fn-financial/functions.c:2957
msgid "purchase_date:date of purchase"
msgstr "purchase_date:Kaufdatum"

#: ../plugins/fn-financial/functions.c:2902
#: ../plugins/fn-financial/functions.c:2958
msgid "first_period:end of first period"
msgstr "first_period:Ende der ersten Periode"

#: ../plugins/fn-financial/functions.c:2905
#: ../plugins/fn-financial/functions.c:2961
msgid "rate:depreciation rate"
msgstr "rate:Abschreibungsrate"

#: ../plugins/fn-financial/functions.c:2908
msgid ""
"AMORDEGRC calculates the depreciation of an asset using French accounting "
"conventions. Assets purchased in the middle of a period take prorated "
"depreciation into account. This is similar to AMORLINC, except that a "
"depreciation coefficient is applied in the calculation depending on the life "
"of the assets."
msgstr ""

#: ../plugins/fn-financial/functions.c:2912
msgid ""
"The depreciation coefficient used is:\n"
"1.0 for an expected lifetime less than 3 years,\n"
"1.5 for an expected lifetime of at least 3 years but less than 5 years,\n"
"2.0 for an expected lifetime of at least 5 years but at most 6 years,\n"
"2.5 for an expected lifetime of more than 6 years."
msgstr ""

#: ../plugins/fn-financial/functions.c:2917
msgid ""
"Special depreciation rules are applied for the last two periods resulting in "
"a possible total depreciation exceeding the difference of @{cost} - @"
"{salvage}."
msgstr ""

#: ../plugins/fn-financial/functions.c:2919
msgid "Named for AMORtissement DEGRessif Comptabilite."
msgstr ""

#: ../plugins/fn-financial/functions.c:2955
msgid "AMORLINC:depreciation of an asset using French accounting conventions"
msgstr ""

#: ../plugins/fn-financial/functions.c:2964
msgid ""
"AMORLINC calculates the depreciation of an asset using French accounting "
"conventions. Assets purchased in the middle of a period take prorated "
"depreciation into account. "
msgstr ""

#: ../plugins/fn-financial/functions.c:2966
msgid "Named for AMORtissement LINeaire Comptabilite."
msgstr ""

#: ../plugins/fn-financial/functions.c:3001
msgid "COUPDAYBS:number of days from coupon period to settlement"
msgstr ""

#: ../plugins/fn-financial/functions.c:3006
#: ../plugins/fn-financial/functions.c:3030
#: ../plugins/fn-financial/functions.c:3054
#: ../plugins/fn-financial/functions.c:3078
#: ../plugins/fn-financial/functions.c:3104
#: ../plugins/fn-financial/functions.c:3130
msgid "eom:end-of-month flag"
msgstr "eom:Markierung »Ende des Monats«"

#: ../plugins/fn-financial/functions.c:3007
msgid ""
"COUPDAYBS calculates the number of days from the beginning of the coupon "
"period to the settlement date."
msgstr ""

#: ../plugins/fn-financial/functions.c:3025
msgid "COUPDAYS:number of days in the coupon period of the settlement date"
msgstr ""

#: ../plugins/fn-financial/functions.c:3031
msgid ""
"COUPDAYS calculates the number of days in the coupon period of the "
"settlement date."
msgstr ""

#: ../plugins/fn-financial/functions.c:3049
msgid ""
"COUPDAYSNC:number of days from the settlement date to the next coupon period"
msgstr ""

#: ../plugins/fn-financial/functions.c:3055
msgid ""
"COUPDAYSNC calculates number of days from the settlement date to the next "
"coupon period."
msgstr ""

#: ../plugins/fn-financial/functions.c:3073
msgid "COUPNCD:the next coupon date after settlement"
msgstr ""

#: ../plugins/fn-financial/functions.c:3079
msgid "COUPNCD calculates the coupon date following settlement."
msgstr ""

#: ../plugins/fn-financial/functions.c:3099
msgid "COUPPCD:the last coupon date before settlement"
msgstr ""

#: ../plugins/fn-financial/functions.c:3105
msgid "COUPPCD calculates the coupon date preceding settlement."
msgstr ""

#: ../plugins/fn-financial/functions.c:3125
msgid "COUPNUM:number of coupons"
msgstr ""

#: ../plugins/fn-financial/functions.c:3131
msgid ""
"COUPNUM calculates the number of coupons to be paid between the settlement "
"and maturity dates, rounded up."
msgstr ""

#: ../plugins/fn-financial/functions.c:3149
msgid "CUMIPMT:cumulative interest payment"
msgstr ""

#: ../plugins/fn-financial/functions.c:3150
#: ../plugins/fn-financial/functions.c:3194
msgid "rate:interest rate per period"
msgstr "rate:Zinssatz pro Periode"

#: ../plugins/fn-financial/functions.c:3153
#: ../plugins/fn-financial/functions.c:3197
#: ../plugins/fn-financial/functions.c:3288
msgid "start_period:first period to accumulate for"
msgstr ""

#: ../plugins/fn-financial/functions.c:3154
#: ../plugins/fn-financial/functions.c:3198
#: ../plugins/fn-financial/functions.c:3289
msgid "end_period:last period to accumulate for"
msgstr ""

#: ../plugins/fn-financial/functions.c:3156
msgid ""
"CUMIPMT calculates the cumulative interest paid on a loan from @"
"{start_period} to @{end_period}."
msgstr ""

#: ../plugins/fn-financial/functions.c:3193
msgid "CUMPRINC:cumulative principal"
msgstr ""

#: ../plugins/fn-financial/functions.c:3200
msgid ""
"CUMPRINC calculates the cumulative principal paid on a loan from @"
"{start_period} to @{end_period}."
msgstr ""

#: ../plugins/fn-financial/functions.c:3237
msgid "MDURATION:the modified (Macaulay) duration of a security"
msgstr "MDURATION:Die veränderte (Macaulay)-Dauer einer Bürgschaft"

#: ../plugins/fn-financial/functions.c:3244
msgid "MDURATION calculates the modified (Macaulay) duration of a security."
msgstr "MDURATION berechnet die veränderte (Macaulay)-Dauer einer Bürgschaft."

#: ../plugins/fn-financial/functions.c:3284
msgid "VDB:depreciation of an asset"
msgstr "VDB: Abschreibung eines Vermögenswerts"

#: ../plugins/fn-financial/functions.c:3291
msgid "no_switch:do not switch to straight-line depreciation"
msgstr ""

#: ../plugins/fn-financial/functions.c:3292
msgid ""
"VDB calculates the depreciation of an asset for a given period range using "
"the variable-rate declining balance method."
msgstr ""

#: ../plugins/fn-financial/functions.c:3293
msgid ""
"If @{no_switch} is FALSE, the calculation switches to straight-line "
"depreciation when depreciation is greater than the declining balance "
"calculation."
msgstr ""

#: ../plugins/fn-hebrew-date/functions.c:92
msgid "HDATE:Hebrew date"
msgstr "HDATE:Hebräisches Datum"

#: ../plugins/fn-hebrew-date/functions.c:93
#: ../plugins/fn-hebrew-date/functions.c:162
#: ../plugins/fn-hebrew-date/functions.c:235
#: ../plugins/fn-hebrew-date/functions.c:262
#: ../plugins/fn-hebrew-date/functions.c:289
#: ../plugins/fn-hebrew-date/functions.c:316
msgid "year:Gregorian year of date, defaults to the current year"
msgstr "year:Gregorianisches Jahr des Datums, Vorgabe ist das aktuelle Jahr"

#: ../plugins/fn-hebrew-date/functions.c:94
#: ../plugins/fn-hebrew-date/functions.c:163
#: ../plugins/fn-hebrew-date/functions.c:236
#: ../plugins/fn-hebrew-date/functions.c:263
#: ../plugins/fn-hebrew-date/functions.c:290
#: ../plugins/fn-hebrew-date/functions.c:317
msgid "month:Gregorian month of year, defaults to the current month"
msgstr "month:Gregorianischer Monat des Jahres, Vorgabe ist der aktuelle Monat"

#: ../plugins/fn-hebrew-date/functions.c:95
#: ../plugins/fn-hebrew-date/functions.c:164
#: ../plugins/fn-hebrew-date/functions.c:237
#: ../plugins/fn-hebrew-date/functions.c:264
#: ../plugins/fn-hebrew-date/functions.c:291
#: ../plugins/fn-hebrew-date/functions.c:318
msgid "day:Gregorian day of month, defaults to the current day"
msgstr "day:Gregorianischer Tag des Monats, Vorgabe ist der heutige Tag"

#: ../plugins/fn-hebrew-date/functions.c:127
msgid "DATE2HDATE:Hebrew date"
msgstr "DATE2HDATE:Hebräisches Datum"

#: ../plugins/fn-hebrew-date/functions.c:128
#: ../plugins/fn-hebrew-date/functions.c:203
#: ../plugins/fn-hebrew-date/functions.c:342
msgid "date:Gregorian date, defaults to today"
msgstr "date:Gregorianisches Datum, Vorgabe ist der heutige Tag"

#: ../plugins/fn-hebrew-date/functions.c:161
msgid "HDATE_HEB:Hebrew date in Hebrew"
msgstr "HDATE_HEB:Hebräisches Datum in Hebräisch"

#: ../plugins/fn-hebrew-date/functions.c:202
msgid "DATE2HDATE_HEB:Hebrew date in Hebrew"
msgstr "DATE2HDATE_HEB:Hebräisches Datum in Hebräisch"

#: ../plugins/fn-hebrew-date/functions.c:234
msgid "HDATE_MONTH:Hebrew month of Gregorian date"
msgstr "HDATE_MONTH:Hebräischer Monat des Gregorianischen Datums"

#: ../plugins/fn-hebrew-date/functions.c:261
msgid "HDATE_DAY:Hebrew day of Gregorian date"
msgstr "HDATE_DAY:Hebräischer Tag des Gregorianischen Datums"

#: ../plugins/fn-hebrew-date/functions.c:288
msgid "HDATE_YEAR:Hebrew year of Gregorian date"
msgstr "HDATE_YEAR:Hebräisches Jahr des Gregorianischen Datums"

#: ../plugins/fn-hebrew-date/functions.c:315
msgid "HDATE_JULIAN:Julian day number for given Gregorian date"
msgstr ""
"HDATE_JULIAN:Julianische Tagesnummer des angegebenen Gregorianischen Datums"

#: ../plugins/fn-hebrew-date/functions.c:341
msgid "DATE2JULIAN:Julian day number for given Gregorian date"
msgstr ""
"DATE2JULIAN:Julianische Tagesnummer des angegebenen Gregorianischen Datums"

#: ../plugins/fn-info/functions.c:68
msgid "CELL:information of @{type} about @{cell}"
msgstr "CELL:Information von @{type} über @{cell}"

#: ../plugins/fn-info/functions.c:69
msgid "type:string specifying the type of information requested"
msgstr "type:Zeichenkette, welche den Typ der angeforderten Information angibt"

#: ../plugins/fn-info/functions.c:70
msgid "cell:cell reference"
msgstr "cell:Zellenreferenz"

#: ../plugins/fn-info/functions.c:71
msgid ""
"@{type} specifies the type of information you want to obtain:\n"
"  address        \t\tReturns the given cell reference as text.\n"
"  col            \t\tReturns the number of the column in @{cell}.\n"
"  color          \t\tReturns 0.\n"
"  contents       \t\tReturns the contents of the cell in @{cell}.\n"
"  column         \t\tReturns the number of the column in @{cell}.\n"
"  columnwidth    \tReturns the column width.\n"
"  coord          \t\tReturns the absolute address of @{cell}.\n"
"  datatype       \tsame as type\n"
"  filename       \t\tReturns the name of the file of @{cell}.\n"
"  format         \t\tReturns the code of the format of the cell.\n"
"  formulatype    \tsame as type\n"
"  locked         \t\tReturns 1 if @{cell} is locked.\n"
"  parentheses    \tReturns 1 if @{cell} contains a negative value\n"
"                 \t\tand its format displays it with parentheses.\n"
"  prefix         \t\tReturns a character indicating the horizontal\n"
"                 \t\talignment of @{cell}.\n"
"  prefixcharacter  \tsame as prefix\n"
"  protect        \t\tReturns 1 if @{cell} is locked.\n"
"  row            \t\tReturns the number of the row in @{cell}.\n"
"  sheetname      \tReturns the name of the sheet of @{cell}.\n"
"  type           \t\tReturns \"l\" if @{cell} contains a string, \n"
"                 \t\t\"v\" if it contains some other value, and \n"
"                 \t\t\"b\" if @{cell} is blank.\n"
"  value          \t\tReturns the contents of the cell in @{cell}.\n"
"  width          \t\tReturns the column width."
msgstr ""
"@{type} legt den Informationstyp fest, den Sie erhalten möchten:\n"
"  address        \t\tGibt die gegebene Zellreferenz als Text zurück.\n"
"  col            \t\tGibt die Spaltenzahl in @{cell} zurück.\n"
"  color          \t\tGibt 0 zurück.\n"
"  contents       \t\tGibt den Inhalt der Zelle in @{cell} zurück.\n"
"  column         \t\tGibt die Spaltenzahl in @{cell} zurück.\n"
"  columnwidth    \tGibt die Spaltenbreite zurück.\n"
"  coord          \t\tGibt die absolute Adresse von @{cell} zurück.\n"
"  datatype       \tder selbe wie »type«\n"
"  filename       \t\tGibt den Dateinamen von @{cell} zurück.\n"
"  format         \t\tGibt den Code des Formats der Zelle zurück.\n"
"  formulatype    \tder selbe wie »type«\n"
"  locked         \t\tGibt 1 zurück, falls @{cell} gesperrt ist.\n"
"  parentheses    \tGibt 1 zurück, falls @{cell} einen negativen Wert "
"enthält\n"
"                 \t\tund deren Format mit Klammern dargestellt wird.\n"
"  prefix         \t\tGibt ein Zeichen zurück, das die horizontale\n"
"                 \t\tAusrichtung von @{cell} angibt.\n"
"  prefixcharacter  \tder selbe wie »prefix«\n"
"  protect        \t\tGibt 1 zurück, falls @{cell} gesperrt ist.\n"
"  row            \t\tGibt die Anzahl der Reihen in @{cell} zurück.\n"
"  sheetname      \tGibt den Namen der Tabelle von @{cell} zurück.\n"
"  type           \t\tGibt »l« zurück, falls @{cell} eine Zeichenkette "
"enthält, \n"
"                 \t\t»v« falls sie einen anderen Wert enthält und \n"
"                 \t\t»b« falls @{cell} leer ist.\n"
"  value          \t\tGibt den Inhalt der Zelle in @{cell} zurück.\n"
"  width          \t\tGibt die Spaltenbreite zurück."

#: ../plugins/fn-info/functions.c:1173
msgid "EXPRESSION:expression in @{cell} as a string"
msgstr "EXPRESSION:Ausdruck in @{cell} als Zeichenkette"

#: ../plugins/fn-info/functions.c:1174
msgid "cell:a cell reference"
msgstr "cell:Eine Zellenreferenz"

#: ../plugins/fn-info/functions.c:1175
msgid "If @{cell} contains no expression, EXPRESSION returns empty."
msgstr ""
"Falls @{cell} keinen Ausdruck enthält, gibt EXPRESSION einen leeren Wert "
"zurück."

#: ../plugins/fn-info/functions.c:1210
msgid "GET.FORMULA:the formula in @{cell} as a string"
msgstr "GET.FORMULA:Die Formel in @{cell} als Zeichenkette."

#: ../plugins/fn-info/functions.c:1211 ../plugins/fn-info/functions.c:1253
#: ../plugins/fn-info/functions.c:1816
msgid "cell:the referenced cell"
msgstr "cell:Die referenzierte Zelle"

#: ../plugins/fn-info/functions.c:1212
msgid "GET.FORMULA is the OpenFormula function FORMULA."
msgstr "GET.FORMULA ist die OpenFormula-Funktion FORMULA."

#: ../plugins/fn-info/functions.c:1213
msgid ""
"If A1 is empty and A2 contains =B1+B2, then\n"
"GET.FORMULA(A2) yields '=B1+B2' and\n"
"GET.FORMULA(A1) yields ''."
msgstr ""
"Wenn A1 leer ist und A2 =B1+B2 enthält, dann\n"
"ergibt GET.FORMULA(A2)  »=B1+B2« und\n"
"GET.FORMULA(A1) ergibt »«."

#: ../plugins/fn-info/functions.c:1252
msgid "ISFORMULA:TRUE if @{cell} contains a formula"
msgstr "ISFORMULA:WAHR, wenn @{cell} eine Formel enthält."

#: ../plugins/fn-info/functions.c:1254
msgid "ISFORMULA is OpenFormula compatible."
msgstr "ISFORMULA ist OpenFormula-kompatibel."

#: ../plugins/fn-info/functions.c:1283
msgid "COUNTBLANK:the number of blank cells in @{range}"
msgstr "COUNTBLANK:Die Anzahl leerer Zellen in @{range}"

#: ../plugins/fn-info/functions.c:1284
msgid "range:a cell range"
msgstr "range:Ein Zellenbereich"

#: ../plugins/fn-info/functions.c:1286
msgid "COUNTBLANK(A1:A20) returns the number of blank cell in A1:A20."
msgstr "COUNTBLANK(A1:A20) gibt die Anzahl leerer Zellen in A1:A20 zurück."

#: ../plugins/fn-info/functions.c:1338
msgid ""
"INFO:information about the current operating environment according to @{type}"
msgstr "INFO:Information über die aktuelle Betriebsumgebung nach @{type}"

#: ../plugins/fn-info/functions.c:1340
msgid "type:string giving the type of information requested"
msgstr "type:Zeichenkette mit dem Typ der erwünschten Information"

#: ../plugins/fn-info/functions.c:1341
msgid ""
"INFO returns information about the current operating environment according "
"to @{type}:\n"
"  memavail     \t\tReturns the amount of memory available, bytes.\n"
"  memused      \tReturns the amount of memory used (bytes).\n"
"  numfile      \t\tReturns the number of active worksheets.\n"
"  osversion    \t\tReturns the operating system version.\n"
"  recalc       \t\tReturns the recalculation mode (automatic).\n"
"  release      \t\tReturns the version of Gnumeric as text.\n"
"  system       \t\tReturns the name of the environment.\n"
"  totmem       \t\tReturns the amount of total memory available."
msgstr ""
"INFO liefert Informationen zur aktuellen Arbeitsumgebung je nach @{type}:\n"
"  memavail \tLiefert den freien Speicher in Bytes.\n"
"  memused  \tLiefert den belegten Speicher in Bytes.\n"
"  numfile  \t\tLiefert die Anzahl geöffneter Arbeitsbücher.\n"
"  osversion\t\tLiefert die Version des Betriebssystems.\n"
"  recalc   \t\tLiefert den Modus für die Neuberechnung (automatisch).\n"
"  release  \t\tLiefert die Version von Gnumeric als Text.\n"
"  system   \t\tLiefert den Umgebungsname.\n"
"  totmem   \t\tLiefert den verfügbaren Gesamtspeicher in Bytes."

#: ../plugins/fn-info/functions.c:1438
msgid "ISERROR:TRUE if @{value} is any error value"
msgstr "ISERROR:WAHR, falls @{value} ein beliebiger Fehlerwert ist"

#: ../plugins/fn-info/functions.c:1439 ../plugins/fn-info/functions.c:1457
#: ../plugins/fn-info/functions.c:1479 ../plugins/fn-info/functions.c:1569
#: ../plugins/fn-info/functions.c:1607 ../plugins/fn-info/functions.c:1625
#: ../plugins/fn-info/functions.c:1642 ../plugins/fn-info/functions.c:1681
#: ../plugins/fn-info/functions.c:1702 ../plugins/fn-info/functions.c:1752
msgid "value:a value"
msgstr "value:Ein Wert"

#: ../plugins/fn-info/functions.c:1456
msgid "ISNA:TRUE if @{value} is the #N/A error value"
msgstr "ISERROR:WAHR, falls @{value} der Fehlerwert #N/A ist"

#: ../plugins/fn-info/functions.c:1478
msgid "ISERR:TRUE if @{value} is any error value except #N/A"
msgstr "ISERR:WAHR, falls @{value} ein beliebiger Fehlerwert außer #N/V ist"

#: ../plugins/fn-info/functions.c:1497
msgid "ERROR.TYPE:the type of @{error}"
msgstr "ERROR.TYPE:Der Typ von @{error}"

#: ../plugins/fn-info/functions.c:1498
msgid "error:an error"
msgstr "error:Ein Fehler"

#: ../plugins/fn-info/functions.c:1499
msgid ""
"ERROR.TYPE returns an error number corresponding to the given error value.  "
"The error numbers for error values are:\n"
"\n"
"\t#DIV/0!  \t\t2\n"
"\t#VALUE!  \t3\n"
"\t#REF!    \t\t4\n"
"\t#NAME?   \t5\n"
"\t#NUM!    \t6\n"
"\t#N/A     \t\t7"
msgstr ""
"ERROR.TYP liefert eine Fehlernummer, die dem angegebenen Fehlerwert "
"entspricht. Die Fehlernummern für die Fehlerwerte sind:\n"
"\n"
"\t#DIV/0!  \t\t2\n"
"\t#WERT!   \t3\n"
"\t#BEZUG!  \t4\n"
"\t#NAME?   \t5\n"
"\t#ZAHL!   \t6\n"
"\t#NV      \t\t7"

#: ../plugins/fn-info/functions.c:1533
msgid "NA:the error value #N/A"
msgstr "NA:der Fehlerwert #N/A"

#: ../plugins/fn-info/functions.c:1551
msgid "ERROR:the error with the given @{name}"
msgstr "ERROR:Der Fehler mit dem Namen @{name}"

#: ../plugins/fn-info/functions.c:1552
msgid "name:string"
msgstr "name:Zeichenkette"

#: ../plugins/fn-info/functions.c:1568
msgid "ISBLANK:TRUE if @{value} is blank"
msgstr "ISBLANK:WAHR, falls @{value} leer ist."

#: ../plugins/fn-info/functions.c:1570
msgid ""
"This function checks if a value is blank.  Empty cells are blank, but empty "
"strings are not."
msgstr ""
"Diese Funktion überprüft, ob ein Wert leer ist. Leere Zellen sind leer, "
"leere Zeichenketten jedoch nicht."

#: ../plugins/fn-info/functions.c:1585
msgid "ISEVEN:TRUE if @{n} is even"
msgstr "ISEVEN:WAHR, falls @{value} gerade ist."

#: ../plugins/fn-info/functions.c:1586 ../plugins/fn-info/functions.c:1660
#: ../plugins/fn-math/functions.c:1260
msgid "n:number"
msgstr "n:Zahl"

#: ../plugins/fn-info/functions.c:1606
msgid "ISLOGICAL:TRUE if @{value} is a logical value"
msgstr "ISLOGICAL:WAHR, falls @{value} ein logischer Wert ist."

#: ../plugins/fn-info/functions.c:1608
msgid "This function checks if a value is either TRUE or FALSE."
msgstr "Diese Funktion überprüft, ob ein Wert entweder WAHR oder FALSCH ist."

#: ../plugins/fn-info/functions.c:1624
msgid "ISNONTEXT:TRUE if @{value} is not text"
msgstr "ISNONTEXT:WAHR, falls @{value} kein Text ist."

#: ../plugins/fn-info/functions.c:1641
msgid "ISNUMBER:TRUE if @{value} is a number"
msgstr "ISNUMBER:WAHR, falls @{value} eine Zahl ist."

#: ../plugins/fn-info/functions.c:1643
msgid ""
"This function checks if a value is a number.  Neither TRUE nor FALSE are "
"numbers for this purpose."
msgstr ""
"Diese Funktion prüft, ob ein Wert eine Zahl ist.  Weder WAHR noch FALSCH "
"werden als Zahlen angesehen."

#: ../plugins/fn-info/functions.c:1659
msgid "ISODD:TRUE if @{n} is odd"
msgstr "ISODD:WAHR, falls @{n} ungerade ist."

#: ../plugins/fn-info/functions.c:1680
msgid "ISREF:TRUE if @{value} is a reference"
msgstr "ISREF:WAHR, falls @{value} eine Referenz ist."

#: ../plugins/fn-info/functions.c:1682
msgid "This function checks if a value is a cell reference."
msgstr "Diese Funktion prüft, ob ein Wert eine Zellenreferenz ist."

#: ../plugins/fn-info/functions.c:1701
msgid "ISTEXT:TRUE if @{value} is text"
msgstr "ISTEXT:WAHR, falls @{value} ein Text ist."

#: ../plugins/fn-info/functions.c:1719
msgid "N:@{text} converted to a number"
msgstr "N:@{text} in eine Zahl umgewandelt"

#: ../plugins/fn-info/functions.c:1720 ../plugins/fn-string/functions.c:366
#: ../plugins/fn-string/functions.c:582 ../plugins/fn-string/functions.c:623
#: ../plugins/fn-string/functions.c:667 ../plugins/fn-string/functions.c:794
#: ../plugins/fn-string/functions.c:1018 ../plugins/fn-string/functions.c:1065
#: ../plugins/fn-string/functions.c:1098 ../plugins/fn-string/functions.c:1440
msgid "text:string"
msgstr "text:Zeichenkette"

#: ../plugins/fn-info/functions.c:1721
msgid "If @{text} contains non-numerical text, 0 is returned."
msgstr "Falls @{text} etwas außer Ziffern enthält, so wird 0 zurück gegeben."

#: ../plugins/fn-info/functions.c:1724
msgid "=N(\"eleven\")"
msgstr "=N(\"elf\")"

#: ../plugins/fn-info/functions.c:1751
msgid "TYPE:a number indicating the data type of @{value}"
msgstr "TYPE:Eine Zahl, die den Datentyp von @{value} angibt."

#: ../plugins/fn-info/functions.c:1753
msgid ""
"TYPE returns a number indicating the data type of @{value}:\n"
"1  \t= number\n"
"2  \t= text\n"
"4  \t= boolean\n"
"16 \t= error\n"
"64 \t= array"
msgstr ""
"TYPE gibt eine Zahl zurück, die den Datentyp von @{value} angibt:\n"
"1  \t= Zahl\n"
"2  \t= Text\n"
"4  \t= Boolesche Variable\n"
"16 \t= Fehler\n"
"64 \t= Feld"

#: ../plugins/fn-info/functions.c:1792
msgid "GETENV:the value of execution environment variable @{name}"
msgstr "GETENV:Der Wert der ausgeführten Umgebungsvariable @{name}"

#: ../plugins/fn-info/functions.c:1793
msgid "name:the name of the environment variable"
msgstr "name:Der Name der Umgebungsvariable"

#: ../plugins/fn-info/functions.c:1794
msgid "If a variable called @{name} does not exist, #N/A! will be returned."
msgstr ""
"Falls eine Variable namens @{name} nicht existiert, wird #N/A! zurückgegeben."

#: ../plugins/fn-info/functions.c:1795
msgid "Variable names are case sensitive."
msgstr "Bei Variablennamen wird Groß-/Kleinschreibung berücksichtigt."

#: ../plugins/fn-info/functions.c:1815
msgid "GET.LINK:the target of the hyperlink attached to @{cell} as a string"
msgstr ""
"GET.LINK:Das Ziel des an @{cell} angehängten Hyperlinks als Zeichenkette."

#: ../plugins/fn-info/functions.c:1817
msgid ""
"The value return is not updated automatically when the link attached to @"
"{cell} changes but requires a recalculation."
msgstr ""
"Der Rückgabewert wird nicht automatisch aktualisiert, wenn sich der an @"
"{cell} angehängte Link ändert, aber eine Neuberechnung erfordert."

#: ../plugins/fn-logical/functions.c:44
msgid "AND:logical conjunction"
msgstr "AND:logische Konjugation"

#: ../plugins/fn-logical/functions.c:45 ../plugins/fn-logical/functions.c:124
#: ../plugins/fn-logical/functions.c:178
msgid "b0:logical value"
msgstr "b0:Logischer Wert"

#: ../plugins/fn-logical/functions.c:46 ../plugins/fn-logical/functions.c:125
#: ../plugins/fn-logical/functions.c:179
msgid "b1:logical value"
msgstr "b1:Logischer Wert"

#: ../plugins/fn-logical/functions.c:47
msgid "AND calculates the logical conjunction of its arguments @{b0},@{b1},..."
msgstr "AND berechnet die logische Konjugation der Argumente @{b0},@{b1},..."

#: ../plugins/fn-logical/functions.c:48 ../plugins/fn-logical/functions.c:127
#: ../plugins/fn-logical/functions.c:181
msgid ""
"If an argument is numerical, zero is considered FALSE and anything else TRUE."
msgstr ""
"Wenn ein Argument numerisch ist, so wird Null als FALSCH und alles andere "
"als WAHR angesehen."

#: ../plugins/fn-logical/functions.c:49 ../plugins/fn-logical/functions.c:102
#: ../plugins/fn-logical/functions.c:128 ../plugins/fn-logical/functions.c:182
msgid "Strings and empty values are ignored."
msgstr "Zeichenketten und leere Werte werden ignoriert."

#: ../plugins/fn-logical/functions.c:50 ../plugins/fn-logical/functions.c:129
#: ../plugins/fn-logical/functions.c:183
msgid "If no logical values are provided, then the error #VALUE! is returned."
msgstr ""
"Falls keine logischen Werte zurückgegeben werden, wird der Fehler #WERT! "
"zurückgegeben."

#: ../plugins/fn-logical/functions.c:51 ../plugins/fn-logical/functions.c:130
#: ../plugins/fn-logical/functions.c:184
msgid ""
"This function is strict: if any argument is an error, the result will be the "
"first such error."
msgstr ""
"Diese Funktion ist streng: Wenn irgendein Argument ein Fehler ist, so ist "
"das Ergebnis der erste Fehler."

#: ../plugins/fn-logical/functions.c:57
msgid "wiki:en:Logical_conjunction"
msgstr "wiki:de:Konjunktion_(Logik)"

#: ../plugins/fn-logical/functions.c:98
msgid "NOT:logical negation"
msgstr "NOT:logische Negation"

#: ../plugins/fn-logical/functions.c:99
msgid "b:logical value"
msgstr "b:Logischer Wert"

#: ../plugins/fn-logical/functions.c:100
msgid "NOT calculates the logical negation of its argument."
msgstr "NOT berechnet die logische Negation seines Arguments."

#: ../plugins/fn-logical/functions.c:101
msgid ""
"If the argument is numerical, zero is considered FALSE and anything else "
"TRUE."
msgstr ""
"Falls das Argument numerisch ist, wird 0 als FALSCH angenommen und alles "
"andere als WAHR."

#: ../plugins/fn-logical/functions.c:107
msgid "wiki:en:Negation"
msgstr "wiki:de:Negation#Logik"

#: ../plugins/fn-logical/functions.c:123
msgid "OR:logical disjunction"
msgstr "OR:logische Disjunktion"

#: ../plugins/fn-logical/functions.c:126
msgid "OR calculates the logical disjunction of its arguments @{b0},@{b1},..."
msgstr "OR berechnet die logische Disjunktion der Argumente @{b0},@{b1},..."

#: ../plugins/fn-logical/functions.c:136
msgid "wiki:en:Logical_disjunction"
msgstr "wiki:de:Logisches_Oder"

#: ../plugins/fn-logical/functions.c:177
msgid "XOR:logical exclusive disjunction"
msgstr "XOR:logische exklusive Disjunktion"

#: ../plugins/fn-logical/functions.c:180
msgid ""
"XOR calculates the logical exclusive disjunction of its arguments @{b0},@"
"{b1},..."
msgstr ""
"XOR berechnet die logische exklusive Disjunktion der Argumente @{b0},@"
"{b1},..."

#: ../plugins/fn-logical/functions.c:189
msgid "wiki:en:Exclusive_disjunction"
msgstr "wiki:de:Exklusives_Oder"

#: ../plugins/fn-logical/functions.c:230
msgid "IFERROR:test for error"
msgstr "IFERROR:Test auf Fehler."

#: ../plugins/fn-logical/functions.c:231
msgid "x:value to test for error"
msgstr "x:Wert zum Testen auf Fehler"

#: ../plugins/fn-logical/functions.c:232 ../plugins/fn-logical/functions.c:250
#, fuzzy
msgid "y:alternate value"
msgstr "Vorgabe-Wert"

#: ../plugins/fn-logical/functions.c:233
msgid ""
"This function returns the first value, unless that is an error, in which "
"case it returns the second."
msgstr ""
"Diese Funktion gibt den ersten Wert zurück, es sei denn, es ist ein Fehler. "
"In diesem Fall wird der zweite Wert zurückgegeben."

#: ../plugins/fn-logical/functions.c:248
msgid "IFNA:test for #NA! error"
msgstr "IFERROR:Test auf einen #N/A-Fehler."

#: ../plugins/fn-logical/functions.c:249
msgid "x:value to test for #NA! error"
msgstr "x:Wert zum Testen auf #NA!-Fehler"

#: ../plugins/fn-logical/functions.c:251
msgid ""
"This function returns the first value, unless that is #NA!, in which case it "
"returns the second."
msgstr ""
"Diese Funktion gibt den ersten Wert zurück, es sei denn, es ist #NA!. In "
"diesem Fall wird der zweite Wert zurückgegeben."

#: ../plugins/fn-logical/functions.c:267
msgid "TRUE:the value TRUE"
msgstr "TRUE:Der Wert WAHR."

#: ../plugins/fn-logical/functions.c:268
msgid "TRUE returns the value TRUE."
msgstr "TRUE gibt den Wert WAHR zurück."

#: ../plugins/fn-logical/functions.c:272 ../plugins/fn-logical/functions.c:290
msgid "wiki:en:Logical_value"
msgstr "wiki:de:Logischer Wert"

#: ../plugins/fn-logical/functions.c:285
msgid "FALSE:the value FALSE"
msgstr "FALSE:Der Wert FALSCH."

#: ../plugins/fn-logical/functions.c:286
msgid "FALSE returns the value FALSE."
msgstr "FALSE gibt den Wert FALSCH zurück."

#: ../plugins/fn-lookup/functions.c:730
msgid "ADDRESS:cell address as text"
msgstr "ADDRESS:Zellenadresse als Text"

#: ../plugins/fn-lookup/functions.c:731
msgid "row_num:row number"
msgstr "row_num:Zeilennummer"

#: ../plugins/fn-lookup/functions.c:732
msgid "col_num:column number"
msgstr "col_num:Spaltennummer"

#: ../plugins/fn-lookup/functions.c:733
msgid ""
"abs_num:1 for an absolute, 2 for a row absolute and column relative, 3 for a "
"row relative and column absolute, and 4 for a relative reference; defaults "
"to 1"
msgstr ""
"abs_num:1 für eine absolute, 2 für eine absolute Zeile und relative Spalte, "
"3 für eine relative Zeile und absolute Spalte, und 4 für eine relative "
"Referenz. Voreinstellung ist 1"

#: ../plugins/fn-lookup/functions.c:736
msgid ""
"a1:if TRUE, an A1-style reference is provided, otherwise an R1C1-style "
"reference; defaults to TRUE"
msgstr ""

#: ../plugins/fn-lookup/functions.c:738
msgid "text:name of the worksheet, defaults to no sheet"
msgstr "text:Name des Arbeitsblatts. Die Voreinstellung ist kein Blatt."

#: ../plugins/fn-lookup/functions.c:739
msgid "If @{row_num} or @{col_num} is less than one, ADDRESS returns #VALUE!"
msgstr ""
"Falls @{row_num} oder @{col_num} kleiner als 1 ist, gibt ADDRESS #WERT! "
"zurück."

#: ../plugins/fn-lookup/functions.c:741
msgid "If @{abs_num} is greater than 4 ADDRESS returns #VALUE!"
msgstr "Falls @{abs_num} größer als 4 ist, gibt ADDRESS #WERT! zurück."

#: ../plugins/fn-lookup/functions.c:828
msgid "AREAS:number of areas in @{reference}"
msgstr "AREAS:Anzahl der Bereiche in @{reference}"

#: ../plugins/fn-lookup/functions.c:829
msgid "reference:range"
msgstr "reference:Bereich"

#: ../plugins/fn-lookup/functions.c:896
msgid "CHOOSE:the (@{index}+1)th argument"
msgstr "CHOOSE:Das (@{index}+1)-te Argument"

#: ../plugins/fn-lookup/functions.c:897
msgid "index:positive number"
msgstr "index:positive Zahl"

#: ../plugins/fn-lookup/functions.c:898
msgid "value1:first value"
msgstr "value1:Erster Wert"

#: ../plugins/fn-lookup/functions.c:899
msgid "value2:second value"
msgstr "value2:Zweiter Wert"

#: ../plugins/fn-lookup/functions.c:900
msgid "CHOOSE returns its (@{index}+1)th argument."
msgstr "CHOOSE gibt sein (@{index}+1)-tes Argument zurück."

#: ../plugins/fn-lookup/functions.c:901
msgid ""
"@{index} is truncated to an integer. If @{index} < 1 or the truncated @"
"{index} > number of values, CHOOSE returns #VALUE!"
msgstr ""
"@{index} wird auf eine Ganzzahl abgeschnitten. Wenn @{index} < 1 oder der "
"abgeschnittene @{index} > Anzahl der Werte, so gibt CHOOSE #VALUE! zurück."

#: ../plugins/fn-lookup/functions.c:943
msgid "VLOOKUP:search the first column of @{range} for @{value}"
msgstr "VLOOKUP:die erste Spalte in @{range} nach @{value} durchsuchen"

#: ../plugins/fn-lookup/functions.c:944 ../plugins/fn-lookup/functions.c:1012
msgid "value:search value"
msgstr "value:Suchwert"

#: ../plugins/fn-lookup/functions.c:945 ../plugins/fn-lookup/functions.c:1013
msgid "range:range to search"
msgstr "range:Suchbereich"

#: ../plugins/fn-lookup/functions.c:946
msgid "column:1-based column offset indicating the return values"
msgstr ""

#: ../plugins/fn-lookup/functions.c:947 ../plugins/fn-lookup/functions.c:1015
msgid ""
"approximate:if false, an exact match of @{value} must be found; defaults to "
"TRUE"
msgstr ""
"approximate:Falls FALSCH, so muss eine genaue Übereinstimmung von @{value} "
"gefunden werden. Voreinstellung ist WAHR"

#: ../plugins/fn-lookup/functions.c:949
msgid "as_index:if true, the 0-based row offset is returned; defaults to FALSE"
msgstr ""

#: ../plugins/fn-lookup/functions.c:951
#, fuzzy
msgid ""
"VLOOKUP function finds the row in @{range} that has a first cell similar to @"
"{value}.  If @{approximate} is not true it finds the row with an exact "
"equality. If @{approximate} is true, it finds the last row with first value "
"less than or equal to @{value}. If @{as_index} is true the 0-based row "
"offset is returned."
msgstr ""
"Die VLOOKUP-Funktion sucht die Zeile in @{range}, welche die erste zu @"
"{value} ähnliche Zelle enthält. Wenn @{approximate} nicht WAHR ist, so wird "
"die Zeile mit einer exakten Übereinstimmung gesucht. Wenn @{approximate} "
"WAHR ist, so wird die letzte Zeile mit dem ersten Wert kleiner oder gleich @"
"{value} gesucht. Wenn @{as_index} WAHR ist, so wird ??? the 0-based row "
"offset is returned."

#: ../plugins/fn-lookup/functions.c:958 ../plugins/fn-lookup/functions.c:1026
msgid ""
"If @{approximate} is true, then the values must be sorted in order of "
"ascending value."
msgstr ""
"Falls @{approximate} WAHR ist, dann müssen die Werte aufsteigend sortiert "
"werden."

#: ../plugins/fn-lookup/functions.c:960
msgid "VLOOKUP returns #REF! if @{column} falls outside @{range}."
msgstr ""
"VLOOKUP gibt #BEZUG! zurück, falls @{column} außerhalb von @{range} liegt."

#: ../plugins/fn-lookup/functions.c:1011
msgid "HLOOKUP:search the first row of @{range} for @{value}"
msgstr "HLOOKUP:Die erste Zeile von @{range} nach @{value} suchen"

#: ../plugins/fn-lookup/functions.c:1014
msgid "row:1-based row offset indicating the return values "
msgstr ""

#: ../plugins/fn-lookup/functions.c:1017
#, fuzzy
msgid ""
"as_index:if true, the 0-based column offset is returned; defaults to FALSE"
msgstr ""
"as_index: Falls wahr, so wird die ? Spaltenverschiebung zurück gegeben; "
"Vorgabe ist FALSCH"

#: ../plugins/fn-lookup/functions.c:1019
#, fuzzy
msgid ""
"HLOOKUP function finds the row in @{range} that has a first cell similar to @"
"{value}.  If @{approximate} is not true it finds the column with an exact "
"equality. If @{approximate} is true, it finds the last column with first "
"value less than or equal to @{value}. If @{as_index} is true the 0-based "
"column offset is returned."
msgstr ""
"Die HLOOKUP-Funktion sucht die Zeile in @{range}, welche die erste zu @"
"{value} ähnliche Zelle enthält. Wenn @{approximate} nicht WAHR ist, so wird "
"die Zeile mit einer exakten Übereinstimmung gesucht. Wenn @{approximate} "
"WAHR ist, so wird die letzte Zeile mit dem ersten Wert kleiner oder gleich @"
"{value} gesucht. Wenn @{as_index} Wahr ist, so wird ??? the 0-based row "
"offset is returned."

#: ../plugins/fn-lookup/functions.c:1028
msgid "HLOOKUP returns #REF! if @{row} falls outside @{range}."
msgstr ""
"HLOOKUP gibt #BEZUG! zurück, falls @{row} außerhalb von @{range} liegt."

#: ../plugins/fn-lookup/functions.c:1079
msgid ""
"LOOKUP:contents of @{vector2} at the corresponding location to @{value} in @"
"{vector1}"
msgstr ""
"LOOKUP:Inhalt von @{vector2} an der @{value} entsprechenden Stelle in @"
"{vector1}"

#: ../plugins/fn-lookup/functions.c:1081
msgid "value:value to look up"
msgstr "value:nachzuschlagender Wert"

#: ../plugins/fn-lookup/functions.c:1082
msgid "vector1:range to search:"
msgstr "vector1:Zu durchsuchender Bereich:"

#: ../plugins/fn-lookup/functions.c:1083
msgid "vector2:range of return values"
msgstr "vector2:Bereich der Rückgabewerte"

#: ../plugins/fn-lookup/functions.c:1084
msgid ""
"If  @{vector1} has more rows than columns, LOOKUP searches the first row of @"
"{vector1}, otherwise the first column. If @{vector2} is omitted the return "
"value is taken from the last row or column of @{vector1}."
msgstr ""
"Wenn  @{vector1} mehr Zeilen als Spalten hat, so durchsucht LOOKUP die erste "
"Zeile von @{vector1}, andernfalls die erste Spalte. Wenn @{vector2} "
"ausgelassen wird, so wird der Rückgabewert aus der letzten Zeile oder Spalte "
"von @{vector1} verwendet."

#: ../plugins/fn-lookup/functions.c:1088
msgid ""
"If LOOKUP can't find @{value} it uses the largest value less than @{value}."
msgstr ""
"Wenn LOOKUP @{value} nicht finden kann, so verwendet es den größten Wert "
"kleiner als @{value}."

#: ../plugins/fn-lookup/functions.c:1090
msgid "The data must be sorted."
msgstr "Die Daten müssen sortiert sein."

#: ../plugins/fn-lookup/functions.c:1091
msgid "If @{value} is smaller than the first value it returns #N/A."
msgstr ""
"Falls @{value} kleiner als der erste Wert ist, wird #N/A zurückgegeben."

#: ../plugins/fn-lookup/functions.c:1092
msgid ""
"If the corresponding location does not exist in @{vector2}, it returns #N/A."
msgstr ""
"Falls der korrespondierende Ort in @{vector2} nicht existiert, wird #N/A "
"zurückgegeben."

#: ../plugins/fn-lookup/functions.c:1179
msgid "MATCH:the index of @{seek} in @{vector}"
msgstr "MATCH:Der Index von @{seek} in @{vector}"

#: ../plugins/fn-lookup/functions.c:1180
msgid "seek:value to find"
msgstr "seek:Zu findender Wert"

#: ../plugins/fn-lookup/functions.c:1181
msgid "vector:n by 1 or 1 by n range to be searched"
msgstr "vector:Zu durchsuchender n-mal-1 oder 1-mal-n Bereich"

#: ../plugins/fn-lookup/functions.c:1182
msgid ""
"type:+1 (the default) to find the largest value ≤ @{seek}, 0 to find the "
"first value = @{seek}, or-1 to find the smallest value ≥ @{seek}"
msgstr ""
"type:+1 (die Voreinstellung) um den größten Wert ≤ @{seek} zu finden, 0 um "
"den ersten Wert = @{seek} zu finden, oder -1 um den kleinsten Wert ≥ @{seek} "
"zu finden"

#: ../plugins/fn-lookup/functions.c:1185
msgid "MATCH searches @{vector} for @{seek} and returns the 1-based index."
msgstr ""

#: ../plugins/fn-lookup/functions.c:1186
msgid ""
" For @{type} = -1 the data must be sorted in descending order; for @{type} = "
"+1 the data must be sorted in ascending order."
msgstr ""
" Für @{type} = -1 müssen die Daten in absteigender Reihenfolge geordnet "
"sein; für @{type} = +1 müssen die Daten in aufsteigender Reihenfolge "
"geordnet sein."

#: ../plugins/fn-lookup/functions.c:1188
msgid "If @{seek} could not be found, #N/A is returned."
msgstr "Falls @{seek} nicht gefunden werden kann, wird #N/A zurückgegeben."

#: ../plugins/fn-lookup/functions.c:1189
msgid "If @{vector} is neither n by 1 nor 1 by n, #N/A is returned."
msgstr ""
"Wenn @{vector} weder n-mal-1 noch 1-mal-n ist, so wird #N/V zurück gegeben."

#: ../plugins/fn-lookup/functions.c:1233
msgid "INDIRECT:contents of the cell pointed to by the @{ref_text} string"
msgstr ""
"INDIRECT:Inhalt der Zelle, auf den die Zeichenkette @{ref_text} verweist"

#: ../plugins/fn-lookup/functions.c:1234
msgid "ref_text:textual reference"
msgstr "ref_text:Textreferenz"

#: ../plugins/fn-lookup/functions.c:1235
msgid ""
"format:if true, @{ref_text} is given in A1-style, otherwise it is given in "
"R1C1 style; defaults to true"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1237
msgid ""
"If @{ref_text} is not a valid reference in the style determined by @"
"{format}, INDIRECT returns #REF!"
msgstr ""
"Falls @{ref_text} keine gültige Referenz im von @{format} angegebenen Stil "
"ist, gibt INDIRECT #BEZUG! zurück."

#: ../plugins/fn-lookup/functions.c:1271
msgid "INDEX:reference to a cell in the given @{array}"
msgstr "INDEX:Verweis auf eine Zelle im gegebenen @{array}"

#: ../plugins/fn-lookup/functions.c:1272
msgid "array:cell or inline array"
msgstr "array:Zelle oder eingebettetes Feld"

#: ../plugins/fn-lookup/functions.c:1273
msgid "row:desired row, defaults to 1"
msgstr "row:Gewünschte Zeile, Vorgabe ist 1"

#: ../plugins/fn-lookup/functions.c:1274
msgid "col:desired column, defaults to 1"
msgstr "col:Gewünschte Spalte, Vorgabe ist 1"

#: ../plugins/fn-lookup/functions.c:1275
msgid "area:from which area to select a cell, defaults to 1"
msgstr ""
"area:Bereich, aus welchem eine Zelle gewählt werden soll. Vorgabe ist 1"

#: ../plugins/fn-lookup/functions.c:1276
msgid ""
"INDEX gives a reference to a cell in the given @{array}. The cell is "
"selected by @{row} and @{col}, which count the rows and columns in the array."
msgstr ""
"INDEX liefert einen Verweis auf eine Zelle im gegebenen @{array}. Die Zelle "
"wird über @{row} und @{col} ausgewählt, welche Zeile und Spalte im Feld "
"festlegen."

#: ../plugins/fn-lookup/functions.c:1281
msgid ""
"If the reference falls outside the range of @{array}, INDEX returns #REF!"
msgstr ""
"Falls die Referenz außerhalb des Bereichs von @{array} liegt, gibt INDEX "
"#BEZUG! zurück."

#: ../plugins/fn-lookup/functions.c:1283
msgid ""
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
"21.3, 25.9, and 40.1. Then INDEX(A1:A5,4,1,1) equals 25.9"
msgstr ""
"Angenommen, die Zellen A1, A2 ... A5 enthalten die Zahlen 11.4, 17.3, 21.3, "
"25.9 und 40.1. Dann ist INDEX(A1:A5,4,1,1) gleich 25.9"

#: ../plugins/fn-lookup/functions.c:1372
msgid "COLUMN:vector of column numbers"
msgstr "COLUMN:Vektor aus Spaltennummern"

#: ../plugins/fn-lookup/functions.c:1373 ../plugins/fn-lookup/functions.c:1525
msgid "x:reference, defaults to the position of the current expression"
msgstr "x:Referenz, Vorgabe ist die Position des aktuellen Ausdrucks"

#: ../plugins/fn-lookup/functions.c:1374
msgid ""
"COLUMN function returns a Nx1 array containing the sequence of integers from "
"the first column to the last column of @{x}."
msgstr ""
"Die COLUMN-Funktion gibt ein Nx1-Feld mit der Ganzzahlen-Reihenfolge aus der "
"ersten bis zur letzten Spalte von @{x} zurück."

#: ../plugins/fn-lookup/functions.c:1377 ../plugins/fn-lookup/functions.c:1529
msgid ""
"If @{x} is neither an array nor a reference nor a range, returns #VALUE!"
msgstr ""
"Falls @{x} weder ein Feld, eine Referenz noch ein Bereich ist, wird #WERT! "
"zurückgegeben."

#: ../plugins/fn-lookup/functions.c:1381
msgid "column() in G13 equals 7."
msgstr "column() in G13 ist gleich 7."

#: ../plugins/fn-lookup/functions.c:1421
msgid "COLUMNNUMBER:column number for the given column called @{name}"
msgstr "COLUMNNUMBER:Spaltennummer für gegebene Spalte namens @{name}"

#: ../plugins/fn-lookup/functions.c:1422
msgid "name:column name such as \"IV\""
msgstr "name:Spaltenname, z.B. »IV«"

#: ../plugins/fn-lookup/functions.c:1423
msgid "If @{name} is invalid, COLUMNNUMBER returns #VALUE!"
msgstr "Falls @{name} ungültig ist, gibt COLUMNNUMBER #WERT! zurück."

#: ../plugins/fn-lookup/functions.c:1448
msgid "COLUMNS:number of columns in @{reference}"
msgstr "COLUMNS:Anzahl der Spalten in @{reference}"

#: ../plugins/fn-lookup/functions.c:1449
msgid "reference:array or area"
msgstr "reference:Feld oder Bereich"

#: ../plugins/fn-lookup/functions.c:1450
msgid ""
"If @{reference} is neither an array nor a reference nor a range, COLUMNS "
"returns #VALUE!"
msgstr ""
"Falls @{reference} weder ein Feld, eine Referenz noch ein Bereich ist, gibt "
"COLUMNS #WERT! zurück."

#: ../plugins/fn-lookup/functions.c:1466
#, fuzzy
msgid "OFFSET:an offset cell range"
msgstr "range:Zellenbereich"

#: ../plugins/fn-lookup/functions.c:1467
msgid "range:reference or range"
msgstr "range:Referenz oder Bereich"

#: ../plugins/fn-lookup/functions.c:1468
msgid "row:number of rows to offset @{range}"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1469
msgid "col:number of columns to offset @{range}"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1470
msgid "height:height of the offset range, defaults to height of @{range}"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1471
msgid "width:width of the offset range, defaults to width of @{range}"
msgstr ""

#: ../plugins/fn-lookup/functions.c:1472
msgid ""
"OFFSET returns the cell range starting at offset (@{row},@{col}) from @"
"{range} of height @{height} and width @{width}."
msgstr ""

#: ../plugins/fn-lookup/functions.c:1475
msgid "If @{range} is neither a reference nor a range, OFFSET returns #VALUE!"
msgstr ""
"Falls @{range} weder eine Referenz noch ein Bereich ist, gibt OFFSET #WERT! "
"zurück."

#: ../plugins/fn-lookup/functions.c:1524
msgid "ROW:vector of row numbers"
msgstr "ROW:Vektor aus Zeilennummern"

#: ../plugins/fn-lookup/functions.c:1526
msgid ""
"ROW function returns a 1xN array containing the sequence of integers from "
"the first row to the last row of @{x}."
msgstr ""

#: ../plugins/fn-lookup/functions.c:1572
msgid "ROWS:number of rows in @{reference}"
msgstr "ROW:Anzahl der Zeilen in @{reference}"

#: ../plugins/fn-lookup/functions.c:1573
msgid "reference:array, reference, or range"
msgstr "reference:Feld, Referenz oder Bereich"

#: ../plugins/fn-lookup/functions.c:1574
msgid ""
"If @{reference} is neither an array nor a reference nor a range, ROWS "
"returns #VALUE!"
msgstr ""
"Falls @{reference} weder eine Referenz noch ein Bereich ist, gibt ROWS "
"#WERT! zurück."

#: ../plugins/fn-lookup/functions.c:1590
msgid "SHEETS:number of sheets in @{reference}"
msgstr "SHEETS:Anzahl der Blätter in @{reference}"

#: ../plugins/fn-lookup/functions.c:1591
msgid "reference:array, reference, or range, defaults to the maximum range"
msgstr "reference:Feld, Referenz oder Bereich. Voreinstellung ist Bereich"

#: ../plugins/fn-lookup/functions.c:1592
msgid ""
"If @{reference} is neither an array nor a reference nor a range, SHEETS "
"returns #VALUE!"
msgstr ""
"Falls @{reference} weder ein Feld, eine Referenz noch ein Bereich ist, gibt "
"SHEETS #WERT! zurück."

#: ../plugins/fn-lookup/functions.c:1628
msgid "SHEET:sheet number of @{reference}"
msgstr "SHEET:Blattnummer von @{reference}"

#: ../plugins/fn-lookup/functions.c:1629
msgid ""
"reference:reference or literal sheet name, defaults to the current sheet"
msgstr ""
"reference:Referenz oder wörtlicher Blattname, Vorgabe ist das aktuelle Blatt"

#: ../plugins/fn-lookup/functions.c:1630
msgid ""
"If @{reference} is neither a reference nor a literal sheet name, SHEET "
"returns #VALUE!"
msgstr ""
"Falls @{reference} weder eine Referenz noch ein wörtlicher Blattname ist, "
"gibt SHEETS #WERT! zurück."

#: ../plugins/fn-lookup/functions.c:1676
msgid "HYPERLINK:second or first arguments"
msgstr "HYPERLINK:zweite oder erste Argumente"

#: ../plugins/fn-lookup/functions.c:1677
msgid "link_location:string"
msgstr "link_location:Zeichenkette"

#: ../plugins/fn-lookup/functions.c:1678
msgid "label:string, optional"
msgstr "label:Zeichenkette, optional"

#: ../plugins/fn-lookup/functions.c:1679
msgid ""
"HYPERLINK function currently returns its 2nd argument, or if that is omitted "
"the 1st argument."
msgstr ""
"Die Funktion HYPERLINK gibt derzeit das zweite Argument zurück. Falls es "
"weggelassen wurde wir das erste Argument zurückgegeben."

#: ../plugins/fn-lookup/functions.c:1698
msgid "TRANSPOSE:the transpose of @{matrix}"
msgstr "TRANSPOSE:die transponierte Matrix der Matrix @{matrix}"

#: ../plugins/fn-lookup/functions.c:1699 ../plugins/fn-lookup/functions.c:1737
msgid "matrix:range"
msgstr "matrix:Bereich"

#: ../plugins/fn-lookup/functions.c:1736
msgid "FLIP:@{matrix} flipped"
msgstr "FLIP:@{matrix} gespiegelt"

#: ../plugins/fn-lookup/functions.c:1738
msgid ""
"vertical:if true, @{matrix} is flipped vertically, otherwise horizontally; "
"defaults to TRUE"
msgstr ""
"vertical:falls wahr ist @{matrix} vertikal gespiegelt, andernfalls "
"horizontal. Vorgabe ist WAHR"

#: ../plugins/fn-lookup/functions.c:1783
msgid "ARRAY:vertical array of the arguments"
msgstr "ARRAY:vertikales Feld der Argumente"

#: ../plugins/fn-lookup/functions.c:1784
msgid "v:value"
msgstr "v:Wert"

#: ../plugins/fn-lookup/functions.c:1840
msgid "SORT:sorted list of numbers as vertical array"
msgstr "SORT:sortierte Liste von Zahlen als vertikales Feld"

#: ../plugins/fn-lookup/functions.c:1841 ../plugins/fn-stat/functions.c:163
#: ../plugins/fn-stat/functions.c:215
msgid "ref:list of numbers"
msgstr "ref:Liste von Zahlen"

#: ../plugins/fn-lookup/functions.c:1842
msgid "order:0 (descending order) or 1 (ascending order); defaults to 0"
msgstr ""
"Reihenfolge: 0 (absteigend) oder 1 (aufsteigend); die Voreinstellung ist 0"

#: ../plugins/fn-lookup/functions.c:1843
msgid "Strings, booleans, and empty cells are ignored."
msgstr "Zeichenketten, boolesche Werte und leere Zellen werden ignoriert."

#: ../plugins/fn-lookup/functions.c:1844
msgid "SORT({4,3,5}) evaluates to {5,4,3}"
msgstr "SORT({4,3,5}) ergibt {5,4,3}"

#: ../plugins/fn-math/functions.c:51
msgid ""
"Numbers, text and logical values are included in the calculation too. If the "
"cell contains text or the argument evaluates to FALSE, it is counted as "
"value zero (0). If the argument evaluates to TRUE, it is counted as one (1)."
msgstr ""
"Zahlen, Text und logische Werte werden ebenfalls in die Berechnung "
"einbezogen. Falls die Zelle Text enthält oder das Argument als FALSCH "
"ausgewertet wird, dann wird der Wert als Null (0) gezählt. Falls das "
"Argument WAHR ergibt, dann wird es als Eins (1) gezählt."

#: ../plugins/fn-math/functions.c:59
msgid "GCD:the greatest common divisor"
msgstr "GCD:der größte gemeinsame Teiler"

#: ../plugins/fn-math/functions.c:60 ../plugins/fn-math/functions.c:123
msgid "n0:positive integer"
msgstr "n0:positive Ganzzahl"

#: ../plugins/fn-math/functions.c:61 ../plugins/fn-math/functions.c:124
msgid "n1:positive integer"
msgstr "n1:positive Ganzzahl"

#: ../plugins/fn-math/functions.c:62
msgid ""
"GCD calculates the greatest common divisor of the given numbers @{n0},@"
"{n1},..., the greatest integer that is a divisor of each argument."
msgstr ""
"GCD berechnet den größten gemeinsamen Teiler der gegebenen Zahlen @{n0},@"
"{n1},..., die größte Ganzzahl, die ein Teiler jedes der Argumente ist."

#: ../plugins/fn-math/functions.c:63 ../plugins/fn-math/functions.c:126
msgid "If any of the arguments is not an integer, it is truncated."
msgstr ""
"Falls eines der Argumente keine Ganzzahl ist, wird diese abgeschnitten."

#: ../plugins/fn-math/functions.c:122
msgid "LCM:the least common multiple"
msgstr "LCM:das kleinste gemeinsame Vielfache"

#: ../plugins/fn-math/functions.c:125
msgid ""
"LCM calculates the least common multiple of the given numbers @{n0},@"
"{n1},..., the smallest integer that is a multiple of each argument."
msgstr ""
"LCM berechnet das kleinste gemeinsame Vielfache der gegebenen Zahlen @{n0},@"
"{n1},..., die kleinste Ganzzahl, die ein Vielfaches jedes der Argumente ist."

#: ../plugins/fn-math/functions.c:178
msgid "GD:Gudermannian function"
msgstr "GD:Gudermannfunktion"

#: ../plugins/fn-math/functions.c:179 ../plugins/fn-math/functions.c:290
#: ../plugins/fn-stat/functions.c:1782
msgid "x:value"
msgstr "x:Wert"

#: ../plugins/fn-math/functions.c:182
msgid "wolfram:Gudermannian.html"
msgstr "wolfram:Gudermannian.html"

#: ../plugins/fn-math/functions.c:183
msgid "wiki:en:Gudermannian_function"
msgstr "wiki:de:Gudermannfunktion"

#: ../plugins/fn-math/functions.c:202
msgid "HYPOT:the square root of the sum of the squares of the arguments"
msgstr "HYPOT:die Quadratwurzel der Summe der Quadratwurzeln der Argumente."

#: ../plugins/fn-math/functions.c:203
msgid "n0:number"
msgstr "n0:Zahl"

#: ../plugins/fn-math/functions.c:204
msgid "n1:number"
msgstr "n1:Zahl"

#: ../plugins/fn-math/functions.c:225
msgid "ABS:absolute value"
msgstr "ABS:absoluter Wert"

#: ../plugins/fn-math/functions.c:227
msgid ""
"ABS gives the absolute value of @{x}, i.e. the non-negative number of the "
"same magnitude as @{x}."
msgstr ""
"ABS gibt den Absolutbetrag von @{x} zurück. D.h. die nicht negative Zahl der "
"selben Größe wie @{x}."

#: ../plugins/fn-math/functions.c:244
msgid "ACOS:the arc cosine of @{x}"
msgstr "ACOS:der Arkuskosinus von @{x}"

#: ../plugins/fn-math/functions.c:266
msgid "ACOSH:the hyperbolic arc cosine of @{x}"
msgstr "ACOSH:Der hyperbolische Areakosinus von @{x}"

#: ../plugins/fn-math/functions.c:289
msgid "ACOT:inverse cotangent of @{x}"
msgstr "ACOT:Der Kehrwert des Kotangens von @{x}"

#: ../plugins/fn-math/functions.c:293
msgid "wolfram:InverseCotangent.html"
msgstr "wolfram:InverseCotangent.html"

#: ../plugins/fn-math/functions.c:294 ../plugins/fn-math/functions.c:768
#: ../plugins/fn-math/functions.c:807 ../plugins/fn-math/functions.c:1395
#: ../plugins/fn-math/functions.c:1415 ../plugins/fn-math/functions.c:1455
msgid "wiki:en:Trigonometric_functions"
msgstr "wiki:de:Trigonometrische_Funktion"

#: ../plugins/fn-math/functions.c:307
msgid "ACOTH:the inverse hyperbolic cotangent of @{x}"
msgstr "ACOTH:Der Kehrwert des hyperbolischen Kotangens von @{x}"

#: ../plugins/fn-math/functions.c:311
msgid "wolfram:InverseHyperbolicCotangent.html"
msgstr "wolfram:InverseHyperbolicCotangent.html"

#: ../plugins/fn-math/functions.c:312
msgid "wiki:en:Inverse_hyperbolic_function"
msgstr "wiki:de:Hyperbolische_Funktion#Umkehrfunktionen"

#: ../plugins/fn-math/functions.c:325
msgid "ASIN:the arc sine of @{x}"
msgstr "ASIN:Der Arkussinus von @{x}"

#: ../plugins/fn-math/functions.c:327
msgid ""
"ASIN calculates the arc sine of @{x}; that is the value whose sine is @{x}."
msgstr ""
"ASIN berechnet den Arkussinus von @{x}; das ist der Wert, dessen Sinus @{x} "
"ist."

#: ../plugins/fn-math/functions.c:329
msgid "If @{x} falls outside the range -1 to 1, ASIN returns #NUM!"
msgstr ""
"Falls @{x} außerhalb des Bereichs -1 bis 1 liegt, gibt ASIN #ZAHL! zurück."

#: ../plugins/fn-math/functions.c:351
msgid "ASINH:the inverse hyperbolic sine of @{x}"
msgstr "ASINH:Der Kehrwert des hyperbolischen Sinus von @{x}"

#: ../plugins/fn-math/functions.c:353
msgid ""
"ASINH calculates the inverse hyperbolic sine of @{x}; that is the value "
"whose hyperbolic sine is @{x}."
msgstr ""
"ASIN berechnet den Kehrwert des hyperbolischen Sinus von @{x}; das ist der "
"Wert, dessen hyperbolischer Sinus @{x} ist."

#: ../plugins/fn-math/functions.c:370
msgid "ATAN:the arc tangent of @{x}"
msgstr "ATAN:Der Arkustangens von @{x}"

#: ../plugins/fn-math/functions.c:372
msgid ""
"ATAN calculates the arc tangent of @{x}; that is the value whose tangent is @"
"{x}."
msgstr ""
"ATAN berechnet den Arkustangens von @{x}; das ist der Wert, dessen Tangens @"
"{x} ist."

#: ../plugins/fn-math/functions.c:375
msgid "The result will be between −π/2 and +π/2."
msgstr "Das Ergebnis liegt zwischen -π/2 und +π/2."

#: ../plugins/fn-math/functions.c:394
msgid "ATANH:the inverse hyperbolic tangent of @{x}"
msgstr "ATANH:Der Kehrwert des hyperbolischen Tangens von @{x}"

#: ../plugins/fn-math/functions.c:396
msgid ""
"ATANH calculates the inverse hyperbolic tangent of @{x}; that is the value "
"whose hyperbolic tangent is @{x}."
msgstr ""
"ATANH berechnet den Kehrwert des hyperbolischen Tangens von @{x}; das ist "
"der Wert, dessen hyperbolischer Tangens @{x} ist."

#: ../plugins/fn-math/functions.c:398
msgid "If the absolute value of @{x} is greater than 1.0, ATANH returns #NUM!"
msgstr ""
"Falls der absolute Wert von @{x} größer als 1.0 ist, gibt ATANH #ZAHL! "
"zurück."

#: ../plugins/fn-math/functions.c:419
msgid "ATAN2:the arc tangent of the ratio @{y}/@{x}"
msgstr "ATAN2:Arkustangens des Verhältnisses von @{y}/@{x}"

#: ../plugins/fn-math/functions.c:421
msgid "x:x-coordinate"
msgstr "x:x-Koordinate"

#: ../plugins/fn-math/functions.c:422
msgid "y:y-coordinate"
msgstr "y:y-Koordinate"

#: ../plugins/fn-math/functions.c:423
msgid ""
"ATAN2 calculates the direction from the origin to the point (@{x},@{y}) as "
"an angle from the x-axis in radians."
msgstr ""
"ATAN2 berechnet die Richtung vom Ursprung bis zum Punkt (@{x},@{y}) als "
"Winkel zur x-Achse im Bogenmaß."

#: ../plugins/fn-math/functions.c:427
msgid "The result will be between −π and +π."
msgstr "Das Ergebnis liegt zwischen -π und +π."

#: ../plugins/fn-math/functions.c:430
msgid "The order of the arguments may be unexpected."
msgstr "Die Reihenfolge der Argumente kann unerwartet sein."

#: ../plugins/fn-math/functions.c:455
msgid "CEIL:smallest integer larger than or equal to @{x}"
msgstr "CEIL:Kleinste Ganzzahl größer oder gleich @{x}"

#: ../plugins/fn-math/functions.c:457
msgid "CEIL(@{x}) is the smallest integer that is at least as large as @{x}."
msgstr ""
"CEIL(@{x}) ist die kleinste Ganzzahl, die mindestens so groß ist wie @{x}."

#: ../plugins/fn-math/functions.c:458
msgid "This function is the OpenFormula function CEILING(@{x})."
msgstr "Diese Funktion ist die OpenFormula-Funktion CEILING(@{x})."

#: ../plugins/fn-math/functions.c:475
msgid "COUNTIF:count of the cells meeting the given @{criteria}"
msgstr "COUNTIF:Anzahl der Zellen, die das angegebene @{criteria} erfüllen."

#: ../plugins/fn-math/functions.c:476 ../plugins/fn-math/functions.c:549
#: ../plugins/fn-math/functions.c:666
msgid "range:cell area"
msgstr "range:Zellenbereich"

#: ../plugins/fn-math/functions.c:477
msgid "criteria:condition for a cell to be counted"
msgstr "criteria:Bedingung für eine zu erfassende Zelle"

#: ../plugins/fn-math/functions.c:548
msgid ""
"SUMIF:sum of the cells in @{actual_range} for which the corresponding cells "
"in the range meet the given @{criteria}"
msgstr ""
"SUMIF:Summe der Zellen in @{actual_range}, für die die zugehörige Zelle im "
"Bereich das gegebene Kriterium @{criteria} erfüllt."

#: ../plugins/fn-math/functions.c:550
msgid "criteria:condition for a cell to be summed"
msgstr "criteria:Bedingung für eine zu erfassende Zelle"

#: ../plugins/fn-math/functions.c:551 ../plugins/fn-math/functions.c:668
msgid "actual_range:cell area, defaults to @{range}"
msgstr "actual_range:Zellenbereich, Vorgabe ist @{range}"

#: ../plugins/fn-math/functions.c:552
msgid ""
"If the @{actual_range} has a size that differs from the size of @{range}, @"
"{actual_range} is resized (retaining the top-left corner) to match the size "
"of @{range}."
msgstr ""

#: ../plugins/fn-math/functions.c:665
msgid ""
"AVERAGEIF:average of the cells in @{actual range} for which the "
"corresponding cells in the range meet the given @{criteria}"
msgstr ""
"AVERAGEIF:arithmetisches Mittel der Zellen in @{actual range}, für die die "
"zugehörige Zelle in Bereich das Kriterium @{criteria} erfüllt."

#: ../plugins/fn-math/functions.c:667
msgid "criteria:condition for a cell to be included"
msgstr "criteria:Bedingung für eine einzuschließende Zelle"

#: ../plugins/fn-math/functions.c:731
msgid ""
"CEILING:nearest multiple of @{significance} whose absolute value is at least "
"ABS(@{x})"
msgstr ""
"CEILING:das nächstgelegene Vielfache von @{significance}, dessen absoluter "
"Wert mindestens ABS(@{x}) beträgt"

#: ../plugins/fn-math/functions.c:733 ../plugins/fn-math/functions.c:1086
msgid ""
"significance:base multiple (defaults to 1 for @{x} > 0 and -1 for @{x} <0)"
msgstr ""

#: ../plugins/fn-math/functions.c:734
msgid ""
"CEILING(@{x},@{significance}) is the nearest multiple of @{significance} "
"whose absolute value is at least ABS(@{x})."
msgstr ""
"CEILING(@{x},@{significance}) ist das nächstgelegene Vielfache von @"
"{significance}, dessen absoluter Wert mindestens ABS(@{x}) beträgt."

#: ../plugins/fn-math/functions.c:735
msgid ""
"If @{x} or @{significance} is non-numeric, CEILING returns a #VALUE! error."
msgstr ""
"Falls @{x} oder @{significance} nicht-numerisch ist, gibt CEILING einen "
"#WERT!-Fehler zurück."

#: ../plugins/fn-math/functions.c:736
msgid ""
"If @{x} and @{significance} have different signs, CEILING returns a #NUM! "
"error."
msgstr ""
"Falls @{x} und @{significance} unterschiedliche Vorzeichen haben, gibt "
"CEILING einen #ZAHL!-Fehler zurück."

#: ../plugins/fn-math/functions.c:738
msgid ""
"CEILING(@{x}) is exported to ODF as CEILING(@{x},SIGN(@{x}),1). CEILING(@{x},"
"@{significance}) is the OpenFormula function CEILING(@{x},@{significance},1)."
msgstr ""
"CEILING(@{x}) wird nach ODF als CEILING(@{x},SIGN(@{x}),1) exportiert. "
"CEILING(@{x},@{significance}) ist die OpenFormula-Funktion CEILING(@{x},@"
"{significance},1)."

#: ../plugins/fn-math/functions.c:764
msgid "COS:the cosine of @{x}"
msgstr "COS:Der Kosinus von @{x}"

#: ../plugins/fn-math/functions.c:765 ../plugins/fn-math/functions.c:839
#: ../plugins/fn-math/functions.c:1390 ../plugins/fn-math/functions.c:1409
#: ../plugins/fn-math/functions.c:1449 ../plugins/fn-math/functions.c:1622
msgid "x:angle in radians"
msgstr "x:Winkel in Radiant"

#: ../plugins/fn-math/functions.c:767
msgid "wolfram:Cosine.html"
msgstr "wolfram:Cosine.html"

#: ../plugins/fn-math/functions.c:784
msgid "COSH:the hyperbolic cosine of @{x}"
msgstr "COSH:Der hyperbolische Kosinus von @{x}"

#: ../plugins/fn-math/functions.c:802
msgid "COT:the cotangent of @{x}"
msgstr "COT:Kotangens von @{x}"

#: ../plugins/fn-math/functions.c:806
msgid "wolfram:Cotangent.html"
msgstr "wolfram:Cotangent.html"

#: ../plugins/fn-math/functions.c:820
msgid "COTH:the hyperbolic cotangent of @{x}"
msgstr "COTH:Hyperbolischer Kotangens von @{x}"

#: ../plugins/fn-math/functions.c:824
msgid "wolfram:HyperbolicCotangent.html"
msgstr "wolfram:HyperbolicCotangent.html"

#: ../plugins/fn-math/functions.c:825 ../plugins/fn-math/functions.c:1435
#: ../plugins/fn-math/functions.c:1475
msgid "wiki:en:Hyperbolic_function"
msgstr "wiki:de:Hyperbolische_Funktion"

#: ../plugins/fn-math/functions.c:838
msgid "DEGREES:equivalent degrees to @{x} radians"
msgstr "DEGREES:Winkel im Gradmaß des Winkels @{x} im Bogenmaß"

#: ../plugins/fn-math/functions.c:856
msgid "EXP:e raised to the power of @{x}"
msgstr "EXP:Wert der Potenz e hoch @{x}"

#: ../plugins/fn-math/functions.c:858
msgid "e is the base of the natural logarithm."
msgstr "e ist die Basis des natürlichen Logarithmus."

#: ../plugins/fn-math/functions.c:874
msgid "EXPM1:EXP(@{x})-1"
msgstr "EXPM1:EXP(@{x})-1"

#: ../plugins/fn-math/functions.c:876
msgid ""
"This function has a higher resulting precision than evaluating EXP(@{x})-1."
msgstr ""
"Das Ergebnis dieser Funktion ist präziser als die Berechnung von EXP(@{x})-1."

#: ../plugins/fn-math/functions.c:891
msgid "FACT:the factorial of @{x}, i.e. @{x}!"
msgstr "FACT:die Fakultät der Zahl @{x}. D.h. @{x}!"

#: ../plugins/fn-math/functions.c:894
msgid "The domain of this function has been extended using the GAMMA function."
msgstr ""
"Der Definitionsbereich dieser Funktion wurde durch Benutzung der "
"Gammafunktion erweitert."

#: ../plugins/fn-math/functions.c:922
msgid "GAMMA:the Gamma function"
msgstr "GAMMA:Die Gammafunktion"

#: ../plugins/fn-math/functions.c:952
msgid "GAMMALN:natural logarithm of the Gamma function"
msgstr "GAMMALN:Natürlicher Logarithmus der Gammafunktion."

#: ../plugins/fn-math/functions.c:976
msgid "BETA:Euler beta function"
msgstr "BETA:Eulersche Betafunktion"

#: ../plugins/fn-math/functions.c:978 ../plugins/fn-math/functions.c:1002
#: ../plugins/fn-math/functions.c:1218
msgid "y:number"
msgstr "y:Zahl"

#: ../plugins/fn-math/functions.c:979
msgid ""
"BETA function returns the value of the Euler beta function extended to all "
"real numbers except 0 and negative integers."
msgstr ""
"Die BETA-Funktion gibt den Wert der Eulerschen Betafunktion zurück, die auf "
"alle realen Zahlen außer 0 und negativen Ganzzahlen erweitert ist."

#: ../plugins/fn-math/functions.c:980
msgid ""
"If @{x}, @{y}, or (@{x} + @{y}) are non-positive integers, BETA returns #NUM!"
msgstr ""
"Falls @{x}, @{y} oder (@{x} + @{y}) nicht-positive Ganzzahlen sind, gibt "
"BETA #ZAHL! zurück."

#: ../plugins/fn-math/functions.c:984 ../plugins/fn-math/functions.c:1008
msgid "wiki:en:Beta_function"
msgstr "wiki:de:Betafunktion"

#: ../plugins/fn-math/functions.c:1000
msgid ""
"BETALN:natural logarithm of the absolute value of the Euler beta function"
msgstr ""
"BETALN:Natürlicher Logarithmus des absoluten Wertes der Eulerschen "
"Betafunktion"

#: ../plugins/fn-math/functions.c:1003
msgid ""
"BETALN function returns the natural logarithm of the absolute value of the "
"Euler beta function extended to all real numbers except 0 and negative "
"integers."
msgstr ""
"Die BETALN-Funktion gibt den natürlichen Logarithmus des absoluten Wertes "
"der Eulerschen Betafunktion zurück, die auf alle realen Zahlen außer 0 und "
"negativen Ganzzahlen erweitert ist."

#: ../plugins/fn-math/functions.c:1004
msgid ""
"If @{x}, @{y}, or (@{x} + @{y}) are non-positive integers, BETALN returns "
"#NUM!"
msgstr ""
"Falls @{x}, @{y}, oder (@{x} + @{y}) nicht-positive Ganzzahlen sind, gibt "
"BETALN #ZAHL! zurück."

#: ../plugins/fn-math/functions.c:1025
msgid "COMBIN:binomial coefficient"
msgstr "COMBIN:Binomialkoeffizient"

#: ../plugins/fn-math/functions.c:1026 ../plugins/fn-math/functions.c:1058
#: ../plugins/fn-math/functions.c:2172
msgid "n:non-negative integer"
msgstr "n:nicht-negative Ganzzahl"

#: ../plugins/fn-math/functions.c:1027 ../plugins/fn-math/functions.c:1059
msgid "k:non-negative integer"
msgstr "k:nicht-negative Ganzzahl"

#: ../plugins/fn-math/functions.c:1028
msgid ""
"COMBIN returns the binomial coefficient \"@{n} choose @{k}\", the number of @"
"{k}-combinations of an @{n}-element set without repetition."
msgstr ""
"COMBIN gibt den Binomialkoeffizienten »@{n} über @{k}« zurück, also die "
"Anzahl @{k} Elemente einer @{n}-elementigen Menge ohne Wiederholung "
"auszuwählen."

#: ../plugins/fn-math/functions.c:1031
msgid "If @{n} is less than @{k} COMBIN returns #NUM!"
msgstr ""
"Falls @{n} kleiner als @{k} ist, gibt COMBIN einen #ZAHL!-Fehler zurück."

#: ../plugins/fn-math/functions.c:1036
msgid "wiki:en:Binomial_coefficient"
msgstr "wiki:de:Binomialkoeffizient"

#: ../plugins/fn-math/functions.c:1056
msgid ""
"COMBINA:the number of @{k}-combinations of an @{n}-element set with "
"repetition"
msgstr ""
"COMBINA:Die Anzahl der @{k}-Kombinationen eines @{n}-Elementsatzes mit "
"Wiederholung."

#: ../plugins/fn-math/functions.c:1064
msgid "wiki:en:Multiset"
msgstr "wiki:de:Multimenge"

#: ../plugins/fn-math/functions.c:1084
msgid ""
"FLOOR:nearest multiple of @{significance} whose absolute value is at most ABS"
"(@{x})"
msgstr ""
"FLOOR:das nächstgelegene Vielfache von @{significance}, dessen absoluter "
"Wert höchstens ABS(@{x}) beträgt"

#: ../plugins/fn-math/functions.c:1088
msgid ""
"FLOOR(@{x},@{significance}) is the nearest multiple of @{significance} whose "
"absolute value is at most ABS(@{x})"
msgstr ""
"FLOOR(@{x},@{significance}) ist das nächstgelegene Vielfache von @"
"{significance}, dessen absoluter Wert höchstens ABS(@{x}) beträgt"

#: ../plugins/fn-math/functions.c:1090
msgid ""
"FLOOR(@{x}) is exported to ODF as FLOOR(@{x},SIGN(@{x}),1). FLOOR(@{x},@"
"{significance}) is the OpenFormula function FLOOR(@{x},@{significance},1)."
msgstr ""
"FLOOR(@{x}) wird nach ODF als FLOOR(@{x},SIGN(@{x}),1) exportiert. FLOOR(@"
"{x},@{significance}) ist die OpenFormula-Funktion FLOOR(@{x},@"
"{significance},1)."

#: ../plugins/fn-math/functions.c:1120
msgid "INT:largest integer not larger than @{x}"
msgstr "INT:Größte Ganzzahl, die nicht größer als @{x} ist"

#: ../plugins/fn-math/functions.c:1139
msgid "LOG:logarithm of @{x} with base @{base}"
msgstr "LOG:Logarithmus von @{x} zur Basis @{base}"

#: ../plugins/fn-math/functions.c:1140 ../plugins/fn-math/functions.c:1170
#: ../plugins/fn-math/functions.c:1193 ../plugins/fn-math/functions.c:1282
#: ../plugins/fn-math/functions.c:1304
msgid "x:positive number"
msgstr "x:positive Zahl"

#: ../plugins/fn-math/functions.c:1141
msgid "base:base of the logarithm, defaults to 10"
msgstr "base:Basis des Logarithmus, Vorgabe ist 10"

#: ../plugins/fn-math/functions.c:1142
msgid "@{base} must be positive and not equal to 1."
msgstr "@{base} muss positiv und ungleich 1 sein."

#: ../plugins/fn-math/functions.c:1143
msgid "If @{x} ≤ 0, LOG returns #NUM! error."
msgstr "Falls @{x} ≤ 0, gibt LOG einen #ZAHL!-Fehler zurück."

#: ../plugins/fn-math/functions.c:1169
msgid "LN:the natural logarithm of @{x}"
msgstr "LN:Der natürliche Logarithmus von @{x}."

#: ../plugins/fn-math/functions.c:1171
msgid "If @{x} ≤ 0, LN returns #NUM! error."
msgstr "Falls @{x} ≤ 0, gibt LN einen #ZAHL!-Fehler zurück."

#: ../plugins/fn-math/functions.c:1192
msgid "LN1P:LN(1+@{x})"
msgstr "LN1P:LN(1+@{x})"

#: ../plugins/fn-math/functions.c:1194
msgid ""
"LN1P calculates LN(1+@{x}) but yielding a higher precision than evaluating LN"
"(1+@{x})."
msgstr "LN1P berechnet LN(1+@{x}) mit größerer Genauigkeit als LN(1+@{x})."

#: ../plugins/fn-math/functions.c:1195
msgid "If @{x} ≤ -1, LN returns #NUM! error."
msgstr "Falls @{x} ≤ -1, gibt LN einen #ZAHL!-Fehler zurück."

#: ../plugins/fn-math/functions.c:1216
msgid ""
"POWER:the value of @{x} raised to the power @{y} raised to the power of 1/@"
"{z}"
msgstr "POWER:Der Wert von @{x} hoch @{y} hoch 1/@{z}"

#: ../plugins/fn-math/functions.c:1219
msgid "z:number"
msgstr "z:Zahl"

#: ../plugins/fn-math/functions.c:1220
msgid "If both @{x} and @{y} equal 0, POWER returns #NUM!"
msgstr ""
"Falls sowohl @{x} als auch @{y} gleich 0 sind, gibt POWER #ZAHL! zurück."

#: ../plugins/fn-math/functions.c:1221
msgid "If @{x} = 0 and @{y} < 0, POWER returns #DIV/0!"
msgstr "Falls @{x} = 0 und @{y} < 0, gibt POWER #DIV/0! zurück."

#: ../plugins/fn-math/functions.c:1222
msgid "If @{x} < 0 and @{y} is not an integer, POWER returns #NUM!"
msgstr "Falls @{x} < 0 und @{y} keine Ganzzahl ist, gibt POWER #ZAHL! zurück."

#: ../plugins/fn-math/functions.c:1223
msgid "@{z} defaults to 1"
msgstr "Vorgabe für @{z} ist 1"

#: ../plugins/fn-math/functions.c:1224
msgid "If @{z} is not a positive integer, POWER returns #NUM!"
msgstr "Falls @{z} keine positive Ganzzahl ist, gibt POWER #ZAHL! zurück"

#: ../plugins/fn-math/functions.c:1225
msgid "If @{x} < 0, @{y} is odd, and @{z} is even, POWER returns #NUM!"
msgstr ""
"Falls @{x} < 0, @{y} ungerade und @{z} eine gerade Zahl ist, so gibt POWER "
"#ZAHL! zurück"

#: ../plugins/fn-math/functions.c:1258
msgid "POCHHAMMER:the value of GAMMA(@{x}+@{n})/GAMMA(@{x})"
msgstr "POCHHAMMER:der Wert von GAMMA(@{x}+@{n})/GAMMA(@{x})"

#: ../plugins/fn-math/functions.c:1261 ../plugins/fn-r/functions.c:22
#: ../plugins/fn-r/functions.c:98 ../plugins/fn-r/functions.c:174
#: ../plugins/fn-r/functions.c:250 ../plugins/fn-r/functions.c:325
#: ../plugins/fn-r/functions.c:396 ../plugins/fn-r/functions.c:471
#: ../plugins/fn-r/functions.c:545 ../plugins/fn-r/functions.c:620
#: ../plugins/fn-r/functions.c:690 ../plugins/fn-r/functions.c:761
#: ../plugins/fn-r/functions.c:837 ../plugins/fn-r/functions.c:914
#: ../plugins/fn-r/functions.c:994 ../plugins/fn-r/functions.c:1065
#: ../plugins/fn-r/functions.c:1198 ../plugins/fn-r/functions.c:1279
msgid "give_log:if true, log of the result will be returned instead"
msgstr ""
"give_log:falls wahr, so wird das Protokoll des Ergebnisses stattdessen "
"zurück gegeben"

#: ../plugins/fn-math/functions.c:1281
msgid "LOG2:the base-2 logarithm of @{x}"
msgstr "LOG2:Der Logarithmus von @{x} zur Basis 2."

#: ../plugins/fn-math/functions.c:1283
msgid "If @{x} ≤ 0, LOG2 returns #NUM!"
msgstr "Falls @{x} ≤ 0, gibt LOG2 #ZAHL! zurück"

#: ../plugins/fn-math/functions.c:1303
msgid "LOG10:the base-10 logarithm of @{x}"
msgstr "LOG10:Der Logarithmus von @{x} zur Basis 10."

#: ../plugins/fn-math/functions.c:1305
msgid "If @{x} ≤ 0, LOG10 returns #NUM!"
msgstr "Falls @{x} ≤ 0, gibt LOG10 #ZAHL! zurück"

#: ../plugins/fn-math/functions.c:1325
msgid "MOD:the remainder of @{x} under division by @{n}"
msgstr "MOD:Der Rest von @{x} bei Division durch @{n}"

#: ../plugins/fn-math/functions.c:1328
msgid "MOD function returns the remainder when @{x} is divided by @{n}."
msgstr "MOD gibt den Rest zurück, wenn @{x} durch @{n} dividiert wird."

#: ../plugins/fn-math/functions.c:1329
msgid "If @{n} is 0, MOD returns #DIV/0!"
msgstr "Falls @{n} 0 ist, gibt MOD #DIV/0! zurück."

#: ../plugins/fn-math/functions.c:1371
msgid "RADIANS:the number of radians equivalent to @{x} degrees"
msgstr "RADIANS:Anzahl Radiant äquivalent zu @{x} Grad."

#: ../plugins/fn-math/functions.c:1372
msgid "x:angle in degrees"
msgstr "x:Winkel in Grad"

#: ../plugins/fn-math/functions.c:1389
msgid "SIN:the sine of @{x}"
msgstr "SIN:Der Sinus von @{x}"

#: ../plugins/fn-math/functions.c:1394
msgid "wolfram:Sine.html"
msgstr "wolfram:Sine.html"

#: ../plugins/fn-math/functions.c:1408
msgid "CSC:the cosecant of @{x}"
msgstr "CSC:Der Kosekans von @{x}"

#: ../plugins/fn-math/functions.c:1410 ../plugins/fn-math/functions.c:1430
#: ../plugins/fn-math/functions.c:1450 ../plugins/fn-math/functions.c:1470
msgid "This function is not Excel compatible."
msgstr "Diese Funktion ist nicht mit Excel kompatibel."

#: ../plugins/fn-math/functions.c:1414
msgid "wolfram:Cosecant.html"
msgstr "wolfram:Cosecant.html"

#: ../plugins/fn-math/functions.c:1428
msgid "CSCH:the hyperbolic cosecant of @{x}"
msgstr "CSCH:Der hyperbolische Kosekans von @{x}"

#: ../plugins/fn-math/functions.c:1434
msgid "wolfram:HyperbolicCosecant.html"
msgstr "wolfram:HyperbolicCosecant.html"

#: ../plugins/fn-math/functions.c:1448
msgid "SEC:Secant"
msgstr "SEC:Sekans"

#: ../plugins/fn-math/functions.c:1451
msgid "SEC(@{x}) is exported to OpenFormula as 1/COS(@{x})."
msgstr "SEC(@{x}) wird zu OpenFormula als 1/COS(@{x}) exportiert."

#: ../plugins/fn-math/functions.c:1454
msgid "wolfram:Secant.html"
msgstr "wolfram:Secant.html"

#: ../plugins/fn-math/functions.c:1468
msgid "SECH:the hyperbolic secant of @{x}"
msgstr "SECH:Der hyperbolische Sekans von @{x}"

#: ../plugins/fn-math/functions.c:1471
msgid "SECH(@{x}) is exported to OpenFormula as 1/COSH(@{x})."
msgstr "SECH(@{x}) wird zu OpenFormula als 1/COSH(@{x}) exportiert."

#: ../plugins/fn-math/functions.c:1474
msgid "wolfram:HyperbolicSecant.html"
msgstr "wolfram:HyperbolicSecant.html"

#: ../plugins/fn-math/functions.c:1486
msgid "SINH:the hyperbolic sine of @{x}"
msgstr "SINH:der hyperbolische Sinus von @{x}"

#: ../plugins/fn-math/functions.c:1504
msgid "SQRT:square root of @{x}"
msgstr "SQRT:Quadratwurzel von @{x}"

#: ../plugins/fn-math/functions.c:1505 ../plugins/fn-math/functions.c:1914
msgid "x:non-negative number"
msgstr "x:nicht-negative Zahl"

#: ../plugins/fn-math/functions.c:1507
msgid "If @{x} is negative, SQRT returns #NUM!"
msgstr "Falls @{x} negativ ist, gibt SQRT #ZAHL! zurück"

#: ../plugins/fn-math/functions.c:1526
msgid "SUMA:sum of all values and cells referenced"
msgstr "SUMA:Summe aller referenzierten Werte und Zellen"

#: ../plugins/fn-math/functions.c:1527 ../plugins/fn-math/functions.c:1551
msgid "area0:first cell area"
msgstr "area0:erster Zellenbereich"

#: ../plugins/fn-math/functions.c:1528 ../plugins/fn-math/functions.c:1552
msgid "area1:second cell area"
msgstr "area1:zweiter Zellenbereich"

#: ../plugins/fn-math/functions.c:1550
msgid "SUMSQ:sum of the squares of all values and cells referenced"
msgstr "SUMSQ:Summe der Quadratwurzeln aller referenzierten Werte und Zellen"

#: ../plugins/fn-math/functions.c:1573
msgid ""
"MULTINOMIAL:multinomial coefficient (@{x1}+⋯+@{xn}) choose (@{x1},…,@{xn})"
msgstr ""
"MULTINOMIAL:Multinomialkoeffizient »(@{x1}+⋯+@{xn}) über (@{x1},…,@{xn})«"

#: ../plugins/fn-math/functions.c:1574
msgid "x1:first number"
msgstr "x1:erste Zahl"

#: ../plugins/fn-math/functions.c:1575
msgid "x2:second number"
msgstr "x2:zweite Zahl"

#: ../plugins/fn-math/functions.c:1576
msgid "xn:nth number"
msgstr "xn:n-te Zahl"

#: ../plugins/fn-math/functions.c:1580
msgid "wiki:en:Multinomial_theorem"
msgstr "wiki:de:Multinomialtheorem"

#: ../plugins/fn-math/functions.c:1598
msgid "G_PRODUCT:product of all the values and cells referenced"
msgstr "G_PRODUCT:Produkt aller Werte und referenzierten Zellen."

#: ../plugins/fn-math/functions.c:1599
msgid "x1:number"
msgstr "x1:Zahl"

#: ../plugins/fn-math/functions.c:1600
msgid "x2:number"
msgstr "x2:Zahl"

#: ../plugins/fn-math/functions.c:1601
msgid "Empty cells are ignored and the empty product is 1."
msgstr "Leere Zellen werden ignoriert und das leere Produkt ist 1."

#: ../plugins/fn-math/functions.c:1621
msgid "TAN:the tangent of @{x}"
msgstr "TAN:Der Tangens von @{x}"

#: ../plugins/fn-math/functions.c:1638
msgid "TANH:the hyperbolic tangent of @{x}"
msgstr "TANH:Der hyperbolische Tangens von @{x}"

#: ../plugins/fn-math/functions.c:1655
msgid "PI:the constant 𝜋"
msgstr "PI:die Konstante 𝜋"

#: ../plugins/fn-math/functions.c:1656
msgid ""
"This function is Excel compatible, but it returns 𝜋 with a better precision."
msgstr ""
"Diese Funktion ist Excel-kompatibel, gibt allerdings 𝜋 mit einer höheren "
"Genauigkeit zurück."

#: ../plugins/fn-math/functions.c:1673
msgid "TRUNC:@{x} truncated to @{d} digits"
msgstr "TRUNC:@{x} auf @{d} Stellen abgeschnitten"

#: ../plugins/fn-math/functions.c:1675
msgid "d:non-negative integer, defaults to 0"
msgstr "d:nicht-negative Ganzzahl, Vorgabe ist 0"

#: ../plugins/fn-math/functions.c:1676
msgid ""
"If @{d} is omitted or negative then it defaults to zero. If it is not an "
"integer then it is truncated to an integer."
msgstr ""
"Wenn @{d} ausgelassen wird oder negativ ist, dann lautet die Vorgabe Null. "
"Wenn es keine Ganzzahl ist, dann werden die Nachkommastellen abgeschnitten."

#: ../plugins/fn-math/functions.c:1710
msgid "EVEN:@{x} rounded away from 0 to the next even integer"
msgstr "EVEN:@{x} weg von 0 zur nächsten geraden Ganzzahl gerundet"

#: ../plugins/fn-math/functions.c:1745
msgid "ODD:@{x} rounded away from 0 to the next odd integer"
msgstr "Odd:@{x} weg von 0 zur nächsten ungeraden Ganzzahl gerundet"

#: ../plugins/fn-math/functions.c:1780
msgid "FACTDOUBLE:double factorial"
msgstr "FACTDOUBLE:doppelte Fakultät"

#: ../plugins/fn-math/functions.c:1781
msgid "x:non-negative integer"
msgstr "x:nicht-negative Ganzzahl"

#: ../plugins/fn-math/functions.c:1782
msgid "FACTDOUBLE function returns the double factorial @{x}!!"
msgstr "Die FACTDOUBLE-Funktion gibt die doppelte Fakultät @{x}!! zurück"

#: ../plugins/fn-math/functions.c:1783
msgid ""
"If @{x} is not an integer, it is truncated. If @{x} is negative, FACTDOUBLE "
"returns #NUM!"
msgstr ""
"Falls @{x} keine Ganzzahl ist, wird es abgeschnitten. Falls @{x} negativ "
"ist, gitb FACTDOUBLE #ZAHL! zurück."

#: ../plugins/fn-math/functions.c:1817
msgid "FIB:Fibonacci numbers"
msgstr "FIB:Fibonacci-Zahlen"

#: ../plugins/fn-math/functions.c:1818 ../plugins/fn-numtheory/numtheory.c:220
#: ../plugins/fn-numtheory/numtheory.c:253
#: ../plugins/fn-numtheory/numtheory.c:287
#: ../plugins/fn-numtheory/numtheory.c:328
#: ../plugins/fn-numtheory/numtheory.c:360
#: ../plugins/fn-numtheory/numtheory.c:420
#: ../plugins/fn-numtheory/numtheory.c:476
#: ../plugins/fn-numtheory/numtheory.c:507
msgid "n:positive integer"
msgstr "n:Positive Ganzzahl"

#: ../plugins/fn-math/functions.c:1819
msgid "FIB(@{n}) is the @{n}th Fibonacci number."
msgstr "FIB(@{n}) ist die @{n}te Fibonacci-Zahl."

#: ../plugins/fn-math/functions.c:1820
msgid ""
"If @{n} is not an integer, it is truncated. If it is negative or zero FIB "
"returns #NUM!"
msgstr ""
"Falls @{x} keine Ganzzahl ist, wird es abgeschnitten. Falls es negativ oder "
"Null ist, gibt FIB #ZAHL! zurück."

#: ../plugins/fn-math/functions.c:1858
msgid "QUOTIENT:integer portion of a division"
msgstr "QUOTIENT:Ganzzahliger Anteil einer Division"

#: ../plugins/fn-math/functions.c:1859
msgid "numerator:integer"
msgstr "numerator:Ganzzahl"

#: ../plugins/fn-math/functions.c:1860
msgid "denominator:non-zero integer"
msgstr "denominator:Von Null verschiedene Ganzzahl"

#: ../plugins/fn-math/functions.c:1861
msgid ""
"QUOTIENT yields the integer portion of the division @{numerator}/@"
"{denominator}.\n"
"QUOTIENT (@{numerator},@{denominator})⨉@{denominator}+MOD(@{numerator},@"
"{denominator})=@{numerator}"
msgstr ""
"QUOTIENT ergibt den ganzzahligen Anteil der Division @{numerator}/@"
"{denominator}.\n"
"QUOTIENT (@{numerator},@{denominator})⨉@{denominator}+MOD(@{numerator},@"
"{denominator})=@{numerator}"

#: ../plugins/fn-math/functions.c:1885
msgid "SIGN:sign of @{x}"
msgstr "SIGN:Vorzeichen von @{x}"

#: ../plugins/fn-math/functions.c:1887
msgid ""
"SIGN returns 1 if the @{x} is positive and it returns -1 if @{x} is negative."
msgstr "SIGN liefert 1, wenn @{x} positiv ist und -1, wenn @{x} negativ ist."

#: ../plugins/fn-math/functions.c:1912
msgid "SQRTPI:the square root of @{x} times 𝜋"
msgstr "SQRTPI:die Quadratwurzel von @{x} mal 𝜋"

#: ../plugins/fn-math/functions.c:1935
msgid "ROUNDDOWN:@{x} rounded towards 0"
msgstr "ROUNDDOWN:@{x} gerundet gegen 0."

#: ../plugins/fn-math/functions.c:1937 ../plugins/fn-math/functions.c:1961
#: ../plugins/fn-math/functions.c:2002
msgid "d:integer, defaults to 0"
msgstr "d:Ganzzahl, Vorgabe ist 0"

#: ../plugins/fn-math/functions.c:1938
msgid ""
"If @{d} is greater than zero, @{x} is rounded toward 0 to the given number "
"of digits.\n"
"If @{d} is zero, @{x} is rounded toward 0 to the next integer.\n"
"If @{d} is less than zero, @{x} is rounded toward 0 to the left of the "
"decimal point"
msgstr ""
"Wenn @{d} größer ist als Null, wird @{x} gegen 0 auf die gegebene Anzahl "
"Ziffern gerundet.\n"
"Wenn @{d} Null ist, wird @{x} gegen 0 auf die nächste Ganzzahl gerundet.\n"
"Wenn @{d} kleiner ist als Null, wird @{x} gegen 0 links des Dezimalpunkts "
"gerundet"

#: ../plugins/fn-math/functions.c:1959
msgid "ROUND:rounded @{x}"
msgstr "ROUND:gerundetes @{x}"

#: ../plugins/fn-math/functions.c:1962
msgid ""
"If @{d} is greater than zero, @{x} is rounded to the given number of "
"digits.\n"
"If @{d} is zero, @{x} is rounded to the next integer.\n"
"If @{d} is less than zero, @{x} is rounded to the left of the decimal point"
msgstr ""
"Wenn @{d} größer ist als Null, wird @{x} auf die gegebene Anzahl Ziffern "
"gerundet.\n"
"Wenn @{d} Null ist, wird @{x} auf die nächste Ganzzahl gerundet.\n"
"Wenn @{d} kleiner ist als Null, wird @{x} links des Dezimalpunkts gerundet"

#: ../plugins/fn-math/functions.c:2000
msgid "ROUNDUP:@{x} rounded away from 0"
msgstr "ROUNDUP:@{x} gerundet weg von 0."

#: ../plugins/fn-math/functions.c:2003
msgid ""
"If @{d} is greater than zero, @{x} is rounded away from 0 to the given "
"number of digits.\n"
"If @{d} is zero, @{x} is rounded away from 0 to the next integer.\n"
"If @{d} is less than zero, @{x} is rounded away from 0 to the left of the "
"decimal point"
msgstr ""
"Wenn @{d} größer ist als Null, wird @{x} von 0 weg auf die gegebene Anzahl "
"Ziffern gerundet.\n"
"Wenn @{d} Null ist, wird @{x} von 0 weg auf die nächste Ganzzahl gerundet.\n"
"Wenn @{d} kleiner ist als Null, wird @{x} von 0 weg links des Dezimalpunkts "
"gerundet"

#: ../plugins/fn-math/functions.c:2047
msgid "MROUND:@{x} rounded to a multiple of @{m}"
msgstr "MROUND:@{x} wird auf ein Vielfaches von @{m} gerundet"

#: ../plugins/fn-math/functions.c:2049
msgid "m:number"
msgstr "m:Zahl"

#: ../plugins/fn-math/functions.c:2050
msgid "If @{x} and @{m} have different sign, MROUND returns #NUM!"
msgstr ""
"Falls @{x} und @{m} unterschiedliche Vorzeichen haben, gibt MROUND #ZAHL! "
"zurück."

#: ../plugins/fn-math/functions.c:2093
msgid "ARABIC:the Roman numeral @{roman} as number"
msgstr "ARABIC:Die römische Zahl @{roman} als Zahl"

#: ../plugins/fn-math/functions.c:2094
msgid "roman:Roman numeral"
msgstr "roman:Römische Zahl"

#: ../plugins/fn-math/functions.c:2095
msgid ""
"Any Roman symbol to the left of a larger symbol (directly or indirectly) "
"reduces the final value by the symbol amount, otherwise, it increases the "
"final amount by the symbol's amount."
msgstr ""
"Jede römische Zahl links eines höheren Symbols (direkt oder indirekt) "
"vermindert den Endwert um den Symbolwert. Andernfalls wird der Endwert um "
"den Symbolwert erhöht."

#: ../plugins/fn-math/functions.c:2171
msgid "ROMAN:@{n} as a roman numeral text"
msgstr "ROMAN:@{n} als römische Zahl"

#: ../plugins/fn-math/functions.c:2173
msgid "type:0,1,2,3,or 4, defaults to 0"
msgstr "type:0,1,2,3,oder 4, Vorgabe ist 0"

#: ../plugins/fn-math/functions.c:2174
msgid ""
"ROMAN returns the arabic number @{n} as a roman numeral text.\n"
"If @{type} is 0 or it is omitted, ROMAN returns classic roman numbers.\n"
"Type 1 is more concise than classic type, type 2 is more concise than type "
"1, and type 3 is more concise than type 2. Type 4 is a simplified type."
msgstr ""
"ROMAN gibt die arabische Zahl @{n} als römische Zahl zurück.\n"
"Wenn @{type} 0 ist oder weggelassen wird, gibt ROMAN klassische römische "
"Zahlen zurück.\n"
"Typ 1 ist knapper als der der klassische Typ, Typ 2 ist knapper als Typ1, "
"Typ3 ist knapper als Typ2. Typ4 ist vereinfacht."

#: ../plugins/fn-math/functions.c:2421
msgid "SUMX2MY2:sum of the difference of squares"
msgstr "SUMX2MY2: Summe der Differenz von Quadraten"

#: ../plugins/fn-math/functions.c:2422 ../plugins/fn-math/functions.c:2464
#: ../plugins/fn-math/functions.c:2507
msgid "array0:first cell area"
msgstr "array0:erster Zellenbereich"

#: ../plugins/fn-math/functions.c:2423 ../plugins/fn-math/functions.c:2465
#: ../plugins/fn-math/functions.c:2508
msgid "array1:second cell area"
msgstr "array1:zweiter Zellenbereich"

#: ../plugins/fn-math/functions.c:2424
msgid ""
"SUMX2MY2 function returns the sum of the difference of squares of "
"corresponding values in two arrays. The equation of SUMX2MY2 is SUM(x^2-y^2)."
msgstr ""
"Die Funktion SUMX2MY2 gibt die Summe der Differenzen der Quadrate der "
"entsprechenden Werte in zwei Feldern zurück. Die Gleichung von SUMX2MY2 "
"lautet SUM(x^2-y^2)."

#: ../plugins/fn-math/functions.c:2427 ../plugins/fn-math/functions.c:2471
#: ../plugins/fn-math/functions.c:2514
msgid ""
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11, 15, 17, 21, "
"and 43 and the cells B1, B2, ..., B5 hold numbers 13, 22, 31, 33, and 39."
msgstr ""
"Angenommen, die Zellen A1, A2 … A5 enthalten die Zahlen 11, 15, 17, 21 und "
"43, und die Zellen B1, B2 … B5 enthalten die Zahlen 13, 22, 31, 33 und 39."

#: ../plugins/fn-math/functions.c:2428
msgid "Then SUMX2MY2(A1:A5,B1:B5) yields -1299."
msgstr "Dann ist SUMX2MY2(A1:A5,B1:B5) gleich -1299."

#: ../plugins/fn-math/functions.c:2463
msgid "SUMX2PY2:sum of the sum of squares"
msgstr "SUMX2PY2: Summe der Summe der Quadrate"

#: ../plugins/fn-math/functions.c:2466
msgid ""
"SUMX2PY2 function returns the sum of the sum of squares of corresponding "
"values in two arrays. The equation of SUMX2PY2 is SUM(x^2+y^2)."
msgstr ""
"Die Funktion SUMX2PY2 gibt die Summe der Summe der Quadrate der "
"entsprechenden Werte in zwei Feldern zurück. Die Gleichung von SUMX2PY2 "
"lautet SUM(x^2+y^2)."

#: ../plugins/fn-math/functions.c:2468
msgid ""
"If @{array0} and @{array1} have different number of data points, SUMX2PY2 "
"returns #N/A.\n"
"Strings and empty cells are simply ignored."
msgstr ""
"Wenn @{array0} und @{array1} verschiedene Anzahlen von Datenpunkten haben, "
"so gibt SUMX2PY2 #-/- zurück.\n"
"Zeichenketten und leere Zellen werden einfach ignoriert."

#: ../plugins/fn-math/functions.c:2472
msgid "Then SUMX2PY2(A1:A5,B1:B5) yields 7149."
msgstr "Dann ist SUMX2PY2(A1:A5,B1:B5) gleich 7149."

#: ../plugins/fn-math/functions.c:2506
msgid "SUMXMY2:sum of the squares of differences"
msgstr "SUMX2MY2:Summe der Quadrate von Differenzen"

#: ../plugins/fn-math/functions.c:2509
msgid ""
"SUMXMY2 function returns the sum of the squares of the differences of "
"corresponding values in two arrays. The equation of SUMXMY2 is SUM((x-y)^2)."
msgstr ""
"Die Funktion SUMXMY2 gibt die Summe der Quadrate der Differenzen der "
"entsprechenden Werte in zwei Feldern zurück. Die Gleichung von SUMXMY2 "
"lautet SUM((x-y)^2)."

#: ../plugins/fn-math/functions.c:2511
msgid ""
"If @{array0} and @{array1} have different number of data points, SUMXMY2 "
"returns #N/A.\n"
"Strings and empty cells are simply ignored."
msgstr ""
"Wenn @{array0} und @{array1} verschiedene Anzahlen von Datenpunkten haben, "
"so gibt SUMXMY2 #-/- zurück.\n"
"Zeichenketten und leere Zellen werden einfach ignoriert."

#: ../plugins/fn-math/functions.c:2515
msgid "Then SUMXMY2(A1:A5,B1:B5) yields 409."
msgstr "Dann ist SUMXMY2(A1:A5,B1:B5) gleich 409."

#: ../plugins/fn-math/functions.c:2551
msgid "SERIESSUM:sum of a power series at @{x}"
msgstr "SERIESSUM:Summe einer Potenzreihe bei @{x}"

#: ../plugins/fn-math/functions.c:2552
msgid "x:number where to evaluate the power series"
msgstr "x:Stelle für die die Potenzreihe ausgewertet werden soll"

#: ../plugins/fn-math/functions.c:2553
msgid "n:non-negative integer, exponent of the lowest term of the series"
msgstr ""
"n:nicht negative Zahl, Exponent der kleinsten Potenz in der Potenzreihe"

#: ../plugins/fn-math/functions.c:2554
msgid "m:increment to each exponent"
msgstr "m:jeden Exponenten erhöhen"

#: ../plugins/fn-math/functions.c:2555
msgid "coeff:coefficients of the power series"
msgstr "coeff:Koeffizienten der Potenzreihe"

#: ../plugins/fn-math/functions.c:2557
msgid ""
"Let us assume that the cells A1, A2, ..., A5 contain numbers 1.23, 2.32, "
"2.98, 3.42, and 4.33."
msgstr ""
"Nehmen wir an, die Zellen A1, A2, ... A5 enthalten die Zahlen 1.23, 2.32, "
"2.98, 3.42 und 4.33."

#: ../plugins/fn-math/functions.c:2558
msgid "Then SERIESSUM(2,1,2.23,A1:A5) evaluates as 5056.37439843926"
msgstr "Dann wird SERIESSUM(2,1,2.23,A1:A5) gewertet als 5056.37439843926"

#: ../plugins/fn-math/functions.c:2609
msgid "MINVERSE:the inverse matrix of @{matrix}"
msgstr "MINVERSE:die inverse Matrix der Matrix @{matrix}"

#: ../plugins/fn-math/functions.c:2610 ../plugins/fn-math/functions.c:2898
msgid "matrix:a square matrix"
msgstr "matrix:Eine quadratische Matrix"

#: ../plugins/fn-math/functions.c:2611
msgid "If @{matrix} is not invertible, MINVERSE returns #NUM!"
msgstr "Falls @{matrix} nicht invertierbar ist, gibt MINVERSE #ZAHL! zurück."

#: ../plugins/fn-math/functions.c:2612
msgid ""
"If @{matrix} does not contain an equal number of columns and rows, MINVERSE "
"returns #VALUE!"
msgstr ""
"Falls @{matrix} nicht die gleiche Anzahl Zeilen und Spalten enthält, gibt "
"MINVERSE #WERT! zurück."

#: ../plugins/fn-math/functions.c:2646
msgid "MPSEUDOINVERSE:the pseudo-inverse matrix of @{matrix}"
msgstr "MPSEUDOINVERSE:die pseudo-inverse Matrix der Matrix @{matrix}"

#: ../plugins/fn-math/functions.c:2647
msgid "matrix:a matrix"
msgstr "matrix:Eine Matrix"

#: ../plugins/fn-math/functions.c:2648
msgid "threshold:a relative size threshold for discarding eigenvalues"
msgstr ""

#: ../plugins/fn-math/functions.c:2683
msgid ""
"CHOLESKY:the Cholesky decomposition of the symmetric positive-definite @"
"{matrix}"
msgstr ""
"CHOLESKY:Die Cholesky-Zerlegung der symmetrischen positiven definiten Matrix "
"@{matrix}"

#: ../plugins/fn-math/functions.c:2684
msgid "matrix:a symmetric positive definite matrix"
msgstr "matrix:eine symmetrische positiv definite Matrix"

#: ../plugins/fn-math/functions.c:2685
msgid ""
"If the Cholesky-Banachiewicz algorithm applied to @{matrix} fails, Cholesky "
"returns #NUM!"
msgstr ""
"Falls der auf @{matrix} angewendete Cholesky-Banachiewicz-Algorithmus "
"scheitert, gibt Cholesky #ZAHL! zurück."

#: ../plugins/fn-math/functions.c:2686
msgid ""
"If @{matrix} does not contain an equal number of columns and rows, CHOLESKY "
"returns #VALUE!"
msgstr ""
"Falls @{matrix} nicht die gleiche Anzahl von Zeilen und Spalten enthält, "
"gibt CHOLESKY #WERT! zurück."

#: ../plugins/fn-math/functions.c:2761
msgid "MUNIT:the @{n} by @{n} identity matrix"
msgstr "MUNIT:die @{n} x @{n} Einheitsmatrix"

#: ../plugins/fn-math/functions.c:2762
msgid "n:size of the matrix"
msgstr "n:Größe der Matrix"

#: ../plugins/fn-math/functions.c:2799
msgid "MMULT:the matrix product of @{mat1} and @{mat2}"
msgstr "MMULT:Produkt der Matrixmultiplikation von @{mat1} und @{mat2}"

#: ../plugins/fn-math/functions.c:2800
msgid "mat1:a matrix"
msgstr "mat1:eine Matrix"

#: ../plugins/fn-math/functions.c:2801
msgid "mat2:a matrix"
msgstr "mat2:eine Matrix"

#: ../plugins/fn-math/functions.c:2841
msgid "LINSOLVE:solve linear equation"
msgstr "LINSOLVE:lineare Gleichung lösen"

#: ../plugins/fn-math/functions.c:2842 ../plugins/fn-stat/functions.c:3210
msgid "A:a matrix"
msgstr "A:Eine Matrix"

#: ../plugins/fn-math/functions.c:2843
msgid "B:a matrix"
msgstr "B:Eine Matrix"

#: ../plugins/fn-math/functions.c:2845
msgid "Solves the equation @{A}*X=@{B} and returns X."
msgstr "Löst die Gleichung @{A}*X=@{B} und gibt X zurück."

#: ../plugins/fn-math/functions.c:2846
msgid "If the matrix @{A} is singular, #VALUE! is returned."
msgstr "Falls die Matrix @{A} singulär ist, wird #WERT! zurückgegeben."

#: ../plugins/fn-math/functions.c:2897
msgid "MDETERM:the determinant of the matrix @{matrix}"
msgstr "MDETERM:Determinante der Matrix @{matrix}"

#: ../plugins/fn-math/functions.c:2899
msgid ""
"Let us assume that A1,...,A4 contain numbers 2, 3, 7, and 3; B1,..., B4 4, "
"2, 4, and 1; C1,...,C4 9, 4, 3; and 2; and D1,...,D4 7, 3, 6, and 5. Then "
"MDETERM(A1:D4) yields 148."
msgstr ""
"Angenommen A1 … A4 enthalten die Zahlen 2, 3, 7 und 3. B1 … B4 die Zahlen 4, "
"2, 4 und 1. C1 … C4 die Zahlen 9, 4, 3 und 2, und D1 … D4  7, 3, 6 und 5. "
"Dann ergibt MDETERM(A1:D4) 148."

#: ../plugins/fn-math/functions.c:2929
msgid "SUMPRODUCT:multiplies components and adds the results"
msgstr "SUMPRODUCT:multipliziert Komponenten und addiert das Ergebnis"

#: ../plugins/fn-math/functions.c:2931 ../plugins/fn-math/functions.c:2954
msgid ""
"Multiplies corresponding data entries in the given arrays or ranges, and "
"then returns the sum of those products."
msgstr ""
"Multipliziert entsprechende Dateneinträge in gegebenen Feldern oder "
"Bereichen und gibt dann die Summe dieser Produkte zurück."

#: ../plugins/fn-math/functions.c:2934
msgid "If an entry is not numeric, the value zero is used instead."
msgstr ""
"Falls ein Eintrag nicht numerisch ist, wird stattdessen der Wert Null "
"verwendet."

#: ../plugins/fn-math/functions.c:2935 ../plugins/fn-math/functions.c:2958
msgid ""
"If arrays or range arguments do not have the same dimensions, return #VALUE! "
"error."
msgstr ""
"Wenn Felder oder Bereichargumente nicht die gleiche Dimension haben, so wird "
"der Fehler #WERT! zurückgegeben."

#: ../plugins/fn-math/functions.c:2937
#, fuzzy
msgid ""
"This function ignores logicals, so using SUMPRODUCT(A1:A5>0) will not work.  "
"Instead use SUMPRODUCT(--(A1:A5>0))"
msgstr ""
"Diese Funktion ignoriert ?, d.h. SUMPRODUCT(A1:A5>0) funktioniert nicht. "
"Verwenden Sie stattdessen SUMPRODUCT(--(A1:A5>0))"

#: ../plugins/fn-math/functions.c:2946
msgid ""
"This function is not OpenFormula compatible. Use ODF.SUMPRODUCT instead."
msgstr ""
"Diese Funktion ist nicht OpenFormula-kompatibel. Verwenden sie ODF."
"SUMPRODUCT stattdessen."

#: ../plugins/fn-math/functions.c:2952
msgid "ODF.SUMPRODUCT:multiplies components and adds the results"
msgstr "ODF.SUMPRODUCT:multipliziert Komponenten und addiert das Ergebnis"

#: ../plugins/fn-math/functions.c:2957
msgid "If an entry is not numeric or logical, the value zero is used instead."
msgstr ""
"Falls ein Eintrag nicht numerisch oder logisch ist, wird stattdessen der "
"Wert Null verwendet."

#: ../plugins/fn-math/functions.c:2960
msgid "This function differs from SUMPRODUCT by considering booleans."
msgstr ""
"Diese Funktion unterscheidet sich von SUMPRODUCT indem Sie Booleans "
"berücksichtigt."

#: ../plugins/fn-math/functions.c:2961
msgid "This function is not Excel compatible. Use SUMPRODUCT instead."
msgstr ""
"Diese Funktion ist nicht mit Excel kompatibel. Verwenden Sie stattdessen "
"SUMPRODUCT."

#: ../plugins/fn-math/functions.c:3096
msgid "EIGEN:eigenvalues and eigenvectors of the symmetric @{matrix}"
msgstr "EIGEN:Eigenwerte und Eigenvektoren der symmetrischen Matrix @{matrix}"

#: ../plugins/fn-math/functions.c:3097
msgid "matrix:a symmetric matrix"
msgstr "matrix:eine symmetrische Matrix"

#: ../plugins/fn-math/functions.c:3098
msgid "If @{matrix} is not symmetric, EIGEN returns #NUM!"
msgstr "Falls @{matrix} nicht symmetrisch ist, gibt EIGEN #ZAHL! zurück"

#: ../plugins/fn-math/functions.c:3099
msgid ""
"If @{matrix} does not contain an equal number of columns and rows, EIGEN "
"returns #VALUE!"
msgstr ""
"Falls @{matrix} nicht die gleiche Anzahl von Zeilen und Spalten enthält, "
"gibt EIGEN #WERT! zurück."

#: ../plugins/fn-numtheory/numtheory.c:219
msgid "NT_OMEGA:Number of distinct prime factors"
msgstr "NT_OMEGA:Anzahl der eindeutigen Primfaktoren"

#: ../plugins/fn-numtheory/numtheory.c:221
msgid "Returns the number of distinct prime factors without multiplicity."
msgstr "Gibt die Anzahl der eindeutigen Primfaktoren ohne Vielfachheit zurück."

#: ../plugins/fn-numtheory/numtheory.c:252
msgid "NT_PHI:Euler's totient function"
msgstr "NT_PHI:Eulersche Phi-Funktion"

#: ../plugins/fn-numtheory/numtheory.c:254
msgid ""
"Euler's totient function gives the number of integers less than or equal to @"
"{n} that are relatively prime (coprime) to @{n}."
msgstr ""
"Die Eulersche Phi-Funktion gibt an, wie viele ganze Zahlen, die kleiner oder "
"gleich @{n} sind, teilerfremd zu @{n} sind."

#: ../plugins/fn-numtheory/numtheory.c:257
msgid "wiki:en:Euler's_totient_function"
msgstr "wiki:de:Eulersche_%CF%86-Funktion"

#: ../plugins/fn-numtheory/numtheory.c:286
msgid "NT_MU:Möbius mu function"
msgstr "NT_MU:Möbiusfunktion"

#: ../plugins/fn-numtheory/numtheory.c:289
msgid ""
"NT_MU function (Möbius mu function) returns 0  if @{n} is divisible by the "
"square of a prime. Otherwise, if @{n} has an odd  number of different prime "
"factors, NT_MU returns -1, and if @{n} has an even number of different prime "
"factors, it returns 1. If @{n} = 1, NT_MU returns 1."
msgstr ""
"NT_MU (Möbius Mu-Funktion) liefert 0, falls @{n} durch das Quadrat einer "
"Primzahl teilbar ist. Andernfalls liefert es -1, falls @n eine ungerade "
"Anzahl verschiedener Primfaktoren besitzt. Sie liefert 1, falls @{n} eine "
"gerade Anzahl verschiedener Primfaktoren besitzt. Falls @{n} = 1 ist, "
"liefert NT_MU 1."

#: ../plugins/fn-numtheory/numtheory.c:296
msgid "wiki:en:Möbius_function"
msgstr "wiki:de:Möbiusfunktion"

#: ../plugins/fn-numtheory/numtheory.c:297
msgid "wolfram:MoebiusFunction.html"
msgstr "wolfram:MoebiusFunction.html"

#: ../plugins/fn-numtheory/numtheory.c:327
msgid "NT_D:number of divisors"
msgstr "NT_D:Anzahl der Teiler"

#: ../plugins/fn-numtheory/numtheory.c:329
msgid "NT_D calculates the number of divisors of @{n}."
msgstr "NT_D berechnet die Anzahl der Teiler von @{n}."

#: ../plugins/fn-numtheory/numtheory.c:359
msgid "NT_SIGMA:sigma function"
msgstr "NT_SIGMA:Sigma-Funktion"

#: ../plugins/fn-numtheory/numtheory.c:361
msgid "NT_SIGMA calculates the sum of the divisors of @{n}."
msgstr "NT_SIGMA berechnet die Summe der Teiler von @{n}."

#: ../plugins/fn-numtheory/numtheory.c:364
msgid "wiki:en:Divisor_function"
msgstr "wiki:de:Teileranzahlfunktion"

#: ../plugins/fn-numtheory/numtheory.c:393
msgid "ITHPRIME:@{i}th prime"
msgstr "ITHPRIME:@{i}-te Primzahl"

#: ../plugins/fn-numtheory/numtheory.c:394
msgid "i:positive integer"
msgstr "i:positive Ganzzahl"

#: ../plugins/fn-numtheory/numtheory.c:395
msgid "ITHPRIME finds the @{i}th prime."
msgstr "ITHPRIME findet die @{i}-te Primzahl."

#: ../plugins/fn-numtheory/numtheory.c:419
msgid "ISPRIME:whether @{n} is prime"
msgstr "ISPRIME:Gibt an, ob @{n} eine Primzahl ist"

#: ../plugins/fn-numtheory/numtheory.c:421
msgid "ISPRIME returns TRUE if @{n} is prime and FALSE otherwise."
msgstr ""
"ISPRIME gibt WAHR zurück, falls @{n} eine Primzahl ist, ansonsten FALSCH."

#: ../plugins/fn-numtheory/numtheory.c:424
msgid "wolfram:PrimeNumber.html"
msgstr "wolfram:PrimeNumber.html"

#: ../plugins/fn-numtheory/numtheory.c:475
msgid "PFACTOR:smallest prime factor"
msgstr "PFACTOR:kleinster Primfaktor"

#: ../plugins/fn-numtheory/numtheory.c:477
msgid "PFACTOR finds the smallest prime factor of its argument."
msgstr "PFACTOR findet den kleinsten Primfaktor seines Arguments."

#: ../plugins/fn-numtheory/numtheory.c:478
msgid ""
"The argument @{n} must be at least 2. Otherwise a #VALUE! error is returned."
msgstr ""
"Das Argument @{n} muss mindestens 2 sein, sonst wird ein #WERT!-Fehler "
"zurückgegeben. "

#: ../plugins/fn-numtheory/numtheory.c:506
msgid "NT_PI:number of primes upto @{n}"
msgstr "NT_PI:Anzahl der Primzahlen bis @{n}"

#: ../plugins/fn-numtheory/numtheory.c:508
msgid "NT_PI returns the number of primes less than or equal to @{n}."
msgstr ""
"NT_PI gibt die Anzahl der Primzahlen zurück, die kleiner oder gleich @{n} "
"sind."

#: ../plugins/fn-numtheory/numtheory.c:511
msgid "wolfram:PrimeCountingFunction.html"
msgstr "wolfram:PrimeCountingFunction.html"

#: ../plugins/fn-numtheory/numtheory.c:537
msgid "BITOR:bitwise or"
msgstr "BITOR:bitweises ODER"

#: ../plugins/fn-numtheory/numtheory.c:538
#: ../plugins/fn-numtheory/numtheory.c:562
#: ../plugins/fn-numtheory/numtheory.c:586
#: ../plugins/fn-numtheory/numtheory.c:611
#: ../plugins/fn-numtheory/numtheory.c:641
msgid "a:non-negative integer"
msgstr "a:nicht-negative Ganzzahl"

#: ../plugins/fn-numtheory/numtheory.c:539
#: ../plugins/fn-numtheory/numtheory.c:563
#: ../plugins/fn-numtheory/numtheory.c:587
msgid "b:non-negative integer"
msgstr "b:nicht-negative Ganzzahl"

#: ../plugins/fn-numtheory/numtheory.c:540
msgid ""
"BITOR returns the bitwise or of the binary representations of its arguments."
msgstr ""
"BITOR gibt das bitweise ODER der binäre Darstellung der Argumente zurück."

#: ../plugins/fn-numtheory/numtheory.c:561
msgid "BITXOR:bitwise exclusive or"
msgstr "BITXOR:bitweises exklusives ODER"

#: ../plugins/fn-numtheory/numtheory.c:564
msgid ""
"BITXOR returns the bitwise exclusive or of the binary representations of its "
"arguments."
msgstr ""
"BITXOR gibt das bitweise exklusive ODER der binäre Darstellung der Argumente "
"zurück."

#: ../plugins/fn-numtheory/numtheory.c:585
msgid "BITAND:bitwise and"
msgstr "BITAND:bitweises UND"

#: ../plugins/fn-numtheory/numtheory.c:588
msgid ""
"BITAND returns the bitwise and of the binary representations of its "
"arguments."
msgstr ""
"BITAND gibt das bitweise UND der binäre Darstellung der Argumente zurück."

#: ../plugins/fn-numtheory/numtheory.c:610
msgid "BITLSHIFT:bit-shift to the left"
msgstr "BITLSHIFT:Bit-Shift nach links"

#: ../plugins/fn-numtheory/numtheory.c:613
msgid ""
"BITLSHIFT returns the binary representations of @{a} shifted @{n} positions "
"to the left."
msgstr ""
"BITLSHIFT gibt die binäre Darstellung von @{a} um @{n} Stellen nach links "
"verschoben zurück."

#: ../plugins/fn-numtheory/numtheory.c:614
msgid ""
"If @{n} is negative, BITLSHIFT shifts the bits to the right by ABS(@{n}) "
"positions."
msgstr ""
"Wenn @{n} negativ ist, so verschiebt BITLSHIFT die Bits nach rechts um ABS(@"
"{n}) Stellen."

#: ../plugins/fn-numtheory/numtheory.c:640
msgid "BITRSHIFT:bit-shift to the right"
msgstr "BITLSHIFT:Bit-Shift nach rechts"

#: ../plugins/fn-numtheory/numtheory.c:643
msgid ""
"BITRSHIFT returns the binary representations of @{a} shifted @{n} positions "
"to the right."
msgstr ""
"BITRSHIFT gibt die binäre Darstellung von @{a} um @{n} Stellen nach rechts "
"verschoben zurück."

#: ../plugins/fn-numtheory/numtheory.c:644
msgid ""
"If @{n} is negative, BITRSHIFT shifts the bits to the left by ABS(@{n}) "
"positions."
msgstr ""
"Wenn @{n} negativ ist, so verschiebt BITRSHIFT die Bits nach rechts um ABS(@"
"{n}) Stellen."

#: ../plugins/fn-r/functions.c:18
msgid "R.DNORM:probability density function of the normal distribution"
msgstr "R.DNORM:Wahrscheinlichkeitsdichtefunktion der Normalverteilung"

#: ../plugins/fn-r/functions.c:19 ../plugins/fn-r/functions.c:43
#: ../plugins/fn-r/functions.c:95 ../plugins/fn-r/functions.c:119
#: ../plugins/fn-r/functions.c:171 ../plugins/fn-r/functions.c:195
#: ../plugins/fn-r/functions.c:247 ../plugins/fn-r/functions.c:271
#: ../plugins/fn-r/functions.c:323 ../plugins/fn-r/functions.c:345
#: ../plugins/fn-r/functions.c:393 ../plugins/fn-r/functions.c:417
#: ../plugins/fn-r/functions.c:469 ../plugins/fn-r/functions.c:492
#: ../plugins/fn-r/functions.c:542 ../plugins/fn-r/functions.c:566
#: ../plugins/fn-r/functions.c:618 ../plugins/fn-r/functions.c:640
#: ../plugins/fn-r/functions.c:688 ../plugins/fn-r/functions.c:710
#: ../plugins/fn-r/functions.c:758 ../plugins/fn-r/functions.c:782
#: ../plugins/fn-r/functions.c:910 ../plugins/fn-r/functions.c:936
#: ../plugins/fn-r/functions.c:992 ../plugins/fn-r/functions.c:1014
#: ../plugins/fn-r/functions.c:1062 ../plugins/fn-r/functions.c:1086
#: ../plugins/fn-r/functions.c:1112 ../plugins/fn-r/functions.c:1194
#: ../plugins/fn-r/functions.c:1220 ../plugins/fn-r/functions.c:1276
#: ../plugins/fn-r/functions.c:1300
msgid "x:observation"
msgstr "x:Beobachtung"

#: ../plugins/fn-r/functions.c:20 ../plugins/fn-r/functions.c:44
#: ../plugins/fn-r/functions.c:70
msgid "mu:mean of the distribution"
msgstr "mu:Erwartungswert der Verteilung"

#: ../plugins/fn-r/functions.c:21 ../plugins/fn-r/functions.c:45
#: ../plugins/fn-r/functions.c:71
msgid "sigma:standard deviation of the distribution"
msgstr "sigma:Standardabweichung der Verteilung"

#: ../plugins/fn-r/functions.c:23
msgid ""
"This function returns the probability density function of the normal "
"distribution."
msgstr ""
"Diese Funktion gibt die Wahrscheinlichkeitsdichtefunktion der "
"Normalverteilung zurück."

#: ../plugins/fn-r/functions.c:42
msgid "R.PNORM:cumulative distribution function of the normal distribution"
msgstr "R.PNORM:(kumulative) Verteilungsfunktion der Normalverteilung"

#: ../plugins/fn-r/functions.c:46 ../plugins/fn-r/functions.c:72
#: ../plugins/fn-r/functions.c:122 ../plugins/fn-r/functions.c:148
#: ../plugins/fn-r/functions.c:198 ../plugins/fn-r/functions.c:224
#: ../plugins/fn-r/functions.c:274 ../plugins/fn-r/functions.c:300
#: ../plugins/fn-r/functions.c:347 ../plugins/fn-r/functions.c:371
#: ../plugins/fn-r/functions.c:420 ../plugins/fn-r/functions.c:446
#: ../plugins/fn-r/functions.c:494 ../plugins/fn-r/functions.c:519
#: ../plugins/fn-r/functions.c:569 ../plugins/fn-r/functions.c:595
#: ../plugins/fn-r/functions.c:642 ../plugins/fn-r/functions.c:666
#: ../plugins/fn-r/functions.c:712 ../plugins/fn-r/functions.c:736
#: ../plugins/fn-r/functions.c:785 ../plugins/fn-r/functions.c:811
#: ../plugins/fn-r/functions.c:861 ../plugins/fn-r/functions.c:887
#: ../plugins/fn-r/functions.c:940 ../plugins/fn-r/functions.c:968
#: ../plugins/fn-r/functions.c:1016 ../plugins/fn-r/functions.c:1040
#: ../plugins/fn-r/functions.c:1089 ../plugins/fn-r/functions.c:1116
#: ../plugins/fn-r/functions.c:1144 ../plugins/fn-r/functions.c:1171
#: ../plugins/fn-r/functions.c:1224 ../plugins/fn-r/functions.c:1252
#: ../plugins/fn-r/functions.c:1303 ../plugins/fn-r/functions.c:1329
msgid ""
"lower_tail:if true (the default), the lower tail of the distribution is "
"considered"
msgstr ""

#: ../plugins/fn-r/functions.c:47 ../plugins/fn-r/functions.c:73
#: ../plugins/fn-r/functions.c:123 ../plugins/fn-r/functions.c:149
#: ../plugins/fn-r/functions.c:199 ../plugins/fn-r/functions.c:225
#: ../plugins/fn-r/functions.c:275 ../plugins/fn-r/functions.c:301
#: ../plugins/fn-r/functions.c:348 ../plugins/fn-r/functions.c:372
#: ../plugins/fn-r/functions.c:421 ../plugins/fn-r/functions.c:447
#: ../plugins/fn-r/functions.c:495 ../plugins/fn-r/functions.c:520
#: ../plugins/fn-r/functions.c:570 ../plugins/fn-r/functions.c:596
#: ../plugins/fn-r/functions.c:643 ../plugins/fn-r/functions.c:667
#: ../plugins/fn-r/functions.c:713 ../plugins/fn-r/functions.c:737
#: ../plugins/fn-r/functions.c:786 ../plugins/fn-r/functions.c:812
#: ../plugins/fn-r/functions.c:862 ../plugins/fn-r/functions.c:888
#: ../plugins/fn-r/functions.c:941 ../plugins/fn-r/functions.c:969
#: ../plugins/fn-r/functions.c:1017 ../plugins/fn-r/functions.c:1041
#: ../plugins/fn-r/functions.c:1090 ../plugins/fn-r/functions.c:1117
#: ../plugins/fn-r/functions.c:1145 ../plugins/fn-r/functions.c:1172
#: ../plugins/fn-r/functions.c:1225 ../plugins/fn-r/functions.c:1253
#: ../plugins/fn-r/functions.c:1304 ../plugins/fn-r/functions.c:1330
#, fuzzy
#| msgid ""
#| "Separate:if true, the real and imaginary parts are given separately, "
#| "defaults to false"
msgid ""
"log_p:if true, the natural logarithm of the probability is given or "
"returned; defaults to false"
msgstr ""
"Separate:Falls wahr, so werden der Real- und Imaginärteil separat angegeben. "
"Vorgabe lautet »falsch«"

#: ../plugins/fn-r/functions.c:48
msgid ""
"This function returns the cumulative distribution function of the normal "
"distribution."
msgstr ""
"Diese Funktion gibt die kumulative Verteilungsfunktion der Normalverteilung "
"zurück."

#: ../plugins/fn-r/functions.c:68
msgid "R.QNORM:probability quantile function of the normal distribution"
msgstr "R.QNORM:Quantilfunktion der Normalverteilung"

#: ../plugins/fn-r/functions.c:69 ../plugins/fn-r/functions.c:145
#: ../plugins/fn-r/functions.c:221 ../plugins/fn-r/functions.c:297
#: ../plugins/fn-r/functions.c:369 ../plugins/fn-r/functions.c:443
#: ../plugins/fn-r/functions.c:517 ../plugins/fn-r/functions.c:592
#: ../plugins/fn-r/functions.c:664 ../plugins/fn-r/functions.c:734
#: ../plugins/fn-r/functions.c:808 ../plugins/fn-r/functions.c:884
#: ../plugins/fn-r/functions.c:964 ../plugins/fn-r/functions.c:1038
#: ../plugins/fn-r/functions.c:1140 ../plugins/fn-r/functions.c:1168
#: ../plugins/fn-r/functions.c:1248 ../plugins/fn-r/functions.c:1326
#, fuzzy
#| msgid "p:probability of a success"
msgid "p:probability or natural logarithm of the probability"
msgstr "p:Wahrscheinlichkeit eines Treffers"

#: ../plugins/fn-r/functions.c:74
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the normal distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:94
msgid "R.DLNORM:probability density function of the log-normal distribution"
msgstr ""
"R.DLNORM:Wahrscheinlichkeitsdichtefunktion der logarithmischen "
"Normalverteilung"

#: ../plugins/fn-r/functions.c:96 ../plugins/fn-r/functions.c:120
#: ../plugins/fn-r/functions.c:146
msgid "logmean:mean of the underlying normal distribution"
msgstr "logmean:Erwartungswert der zugrunde liegenden Normalverteilung"

#: ../plugins/fn-r/functions.c:97 ../plugins/fn-r/functions.c:121
#: ../plugins/fn-r/functions.c:147
msgid "logsd:standard deviation of the underlying normal distribution"
msgstr "logsd:Standardabweichung der zugrunde liegenden Normalverteilung"

#: ../plugins/fn-r/functions.c:99
msgid ""
"This function returns the probability density function of the log-normal "
"distribution."
msgstr ""
"Diese Funktion gibt die Wahrscheinlichkeitsdichtefunktion der "
"logarithmischen Normalverteilung zurück."

#: ../plugins/fn-r/functions.c:118
msgid ""
"R.PLNORM:cumulative distribution function of the log-normal distribution"
msgstr ""
"R.PLNORM:(kumulative) Verteilungsfunktion der logarithmischen "
"Normalverteilung"

#: ../plugins/fn-r/functions.c:124
msgid ""
"This function returns the cumulative distribution function of the log-normal "
"distribution."
msgstr ""
"Diese Funktion gibt die kumulative Verteilungsfunktion der logarithmischen "
"Normalverteilung zurück."

#: ../plugins/fn-r/functions.c:144
msgid "R.QLNORM:probability quantile function of the log-normal distribution"
msgstr "R.QLNORM:Quantilfunktion der logarithmischen Normalverteilung"

#: ../plugins/fn-r/functions.c:150
#, fuzzy
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the log-normal distribution."
msgstr ""
"Diese Funktion gibt die Wahrscheinlichkeitsdichtefunktion der "
"Normalverteilung zurück, d.h. der inversen kumulativen Verteilungsfunktion"

#: ../plugins/fn-r/functions.c:170
msgid "R.DGAMMA:probability density function of the gamma distribution"
msgstr "R.DGAMMA:Wahrscheinlichkeitsdichtefunktion der Gammaverteilung"

#: ../plugins/fn-r/functions.c:172 ../plugins/fn-r/functions.c:196
#: ../plugins/fn-r/functions.c:222 ../plugins/fn-r/functions.c:543
#: ../plugins/fn-r/functions.c:567 ../plugins/fn-r/functions.c:593
#: ../plugins/fn-r/functions.c:1195 ../plugins/fn-r/functions.c:1221
#: ../plugins/fn-r/functions.c:1249 ../plugins/fn-r/functions.c:1278
#: ../plugins/fn-r/functions.c:1302 ../plugins/fn-r/functions.c:1328
msgid "shape:the shape parameter of the distribution"
msgstr "shape:Der Formparameter der Verteilung"

#: ../plugins/fn-r/functions.c:173 ../plugins/fn-r/functions.c:197
#: ../plugins/fn-r/functions.c:223 ../plugins/fn-r/functions.c:544
#: ../plugins/fn-r/functions.c:568 ../plugins/fn-r/functions.c:594
#: ../plugins/fn-r/functions.c:689 ../plugins/fn-r/functions.c:711
#: ../plugins/fn-r/functions.c:735 ../plugins/fn-r/functions.c:1064
#: ../plugins/fn-r/functions.c:1088 ../plugins/fn-r/functions.c:1170
#: ../plugins/fn-r/functions.c:1197 ../plugins/fn-r/functions.c:1223
#: ../plugins/fn-r/functions.c:1251
msgid "scale:the scale parameter of the distribution"
msgstr "scale:Der Skalierungsparameter der Verteilung"

#: ../plugins/fn-r/functions.c:175
msgid ""
"This function returns the probability density function of the gamma "
"distribution."
msgstr ""
"Diese Funktion gibt die Wahrscheinlichkeitsdichtefunktion der Gamma-"
"Verteilung zurück."

#: ../plugins/fn-r/functions.c:194
msgid "R.PGAMMA:cumulative distribution function of the gamma distribution"
msgstr "R.PGAMMA:(kumulative) Verteilungsfunktion der Gammaverteilung"

#: ../plugins/fn-r/functions.c:200
msgid ""
"This function returns the cumulative distribution function of the gamma "
"distribution."
msgstr ""
"Diese Funktion gibt die kumulative Verteilungsfunktion der Gamma-Verteilung "
"zurück."

#: ../plugins/fn-r/functions.c:220
msgid "R.QGAMMA:probability quantile function of the gamma distribution"
msgstr "R.QGAMMA:Quantilfunktion der Gammaverteilung"

#: ../plugins/fn-r/functions.c:226
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the gamma distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:246
msgid "R.DBETA:probability density function of the beta distribution"
msgstr "R.DBETA:Wahrscheinlichkeitsdichtefunktion der Beta-Verteilung"

#: ../plugins/fn-r/functions.c:248 ../plugins/fn-r/functions.c:272
#: ../plugins/fn-r/functions.c:298
msgid "a:the first shape parameter of the distribution"
msgstr "a:Der erste Formparameter der Verteilung"

#: ../plugins/fn-r/functions.c:249 ../plugins/fn-r/functions.c:273
#: ../plugins/fn-r/functions.c:299
msgid "b:the second scale parameter of the distribution"
msgstr "b:Der zweite Skalierungsparameter der Verteilung"

#: ../plugins/fn-r/functions.c:251
msgid ""
"This function returns the probability density function of the beta "
"distribution."
msgstr ""
"Diese Funktion gibt die Wahrscheinlichkeitsdichtefunktion der Beta-"
"Verteilung zurück."

#: ../plugins/fn-r/functions.c:270
msgid "R.PBETA:cumulative distribution function of the beta distribution"
msgstr "R.PBETA:Kumulative Verteilungsfunktion der Beta-Verteilung"

#: ../plugins/fn-r/functions.c:276
msgid ""
"This function returns the cumulative distribution function of the beta "
"distribution."
msgstr ""
"Diese Funktion gibt die kumulative Verteilungsfunktion der Beta-Verteilung "
"zurück."

#: ../plugins/fn-r/functions.c:296
msgid "R.QBETA:probability quantile function of the beta distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:302
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the beta distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:322
msgid "R.DT:probability density function of the Student t distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:324 ../plugins/fn-r/functions.c:346
#: ../plugins/fn-r/functions.c:370 ../plugins/fn-r/functions.c:1277
#: ../plugins/fn-r/functions.c:1301 ../plugins/fn-r/functions.c:1327
msgid "n:the number of degrees of freedom of the distribution"
msgstr "n:die Anzahl der Freiheitsgrade der Verteilung"

#: ../plugins/fn-r/functions.c:326
#, fuzzy
msgid ""
"This function returns the probability density function of the Student t "
"distribution."
msgstr ""
"Diese Funktion gibt die Wahrscheinlichkeitsdichtefunktion der "
"Normalverteilung zurück."

#: ../plugins/fn-r/functions.c:344
msgid "R.PT:cumulative distribution function of the Student t distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:349
#, fuzzy
msgid ""
"This function returns the cumulative distribution function of the Student t "
"distribution."
msgstr ""
"Diese Funktion gibt die kumulative Verteilungsfunktion der Normalverteilung "
"zurück."

#: ../plugins/fn-r/functions.c:368
msgid "R.QT:probability quantile function of the Student t distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:373
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the Student t distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:392
msgid "R.DF:probability density function of the F distribution"
msgstr "R.DF:Wahrscheinlichkeitsdichtefunktion der F-Verteilung"

#: ../plugins/fn-r/functions.c:394 ../plugins/fn-r/functions.c:418
#: ../plugins/fn-r/functions.c:444
msgid "n1:the first number of degrees of freedom of the distribution"
msgstr "n1:die erste Zahl der Freiheitsgrade der Verteilung"

#: ../plugins/fn-r/functions.c:395 ../plugins/fn-r/functions.c:419
#: ../plugins/fn-r/functions.c:445
msgid "n2:the second number of degrees of freedom of the distribution"
msgstr "n2:die zweite Zahl der Freiheitsgrade der Verteilung"

#: ../plugins/fn-r/functions.c:397
msgid ""
"This function returns the probability density function of the F distribution."
msgstr ""
"Diese Funktion gibt die Wahrscheinlichkeitsdichtefunktion der F-Verteilung "
"zurück."

#: ../plugins/fn-r/functions.c:416
msgid "R.PF:cumulative distribution function of the F distribution"
msgstr "R.PF:Kumulative Verteilungsfunktion der F-Verteilung"

#: ../plugins/fn-r/functions.c:422
msgid ""
"This function returns the cumulative distribution function of the F "
"distribution."
msgstr ""
"Diese Funktion gibt die kumulative Verteilungsfunktion der F-Verteilung "
"zurück."

#: ../plugins/fn-r/functions.c:442
#, fuzzy
msgid "R.QF:probability quantile function of the F distribution"
msgstr "R.QNORM:Quantilfunktion der Normalverteilung"

#: ../plugins/fn-r/functions.c:448
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the F distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:468
msgid "R.DCHISQ:probability density function of the chi-square distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:470 ../plugins/fn-r/functions.c:493
#: ../plugins/fn-r/functions.c:518 ../plugins/fn-r/functions.c:1114
#: ../plugins/fn-r/functions.c:1142
msgid "df:the number of degrees of freedom of the distribution"
msgstr "df:die Anzahl der Freiheitsgrade der Verteilung"

#: ../plugins/fn-r/functions.c:472
msgid ""
"This function returns the probability density function of the chi-square "
"distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:473
msgid ""
"A two argument invocation R.DCHISQ(@{x},@{df}) is exported to OpenFormula as "
"CHISQDIST(@{x},@{df},FALSE())."
msgstr ""
"Ein Aufruf mit zwei Argumenten von R.DCHISQ(@{x},@{df}) wird nach "
"OpenFormula exportiert als CHISQDIST(@{x},@{df},FALSE())."

#: ../plugins/fn-r/functions.c:491
msgid ""
"R.PCHISQ:cumulative distribution function of the chi-square distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:496
msgid ""
"This function returns the cumulative distribution function of the chi-square "
"distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:497
msgid ""
"A two argument invocation R.PCHISQ(@{x},@{df}) is exported to OpenFormula as "
"CHISQDIST(@{x},@{df})."
msgstr ""
"Ein Aufruf mit zwei Argumenten von R.PCHISQ(@{x},@{df}) wird nach "
"OpenFormula exportiert als CHISQDIST(@{x},@{df})."

#: ../plugins/fn-r/functions.c:516
msgid "R.QCHISQ:probability quantile function of the chi-square distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:521
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the chi-square distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:522
msgid ""
"A two argument invocation R.QCHISQ(@{p},@{df}) is exported to OpenFormula as "
"CHISQINV(@{p},@{df})."
msgstr ""
"Ein Aufruf mit zwei Argumenten von R.QCHISQ(@{p},@{df}) wird nach "
"OpenFormula exportiert als CHISQINV(@{p},@{df})."

#: ../plugins/fn-r/functions.c:541
msgid "R.DWEIBULL:probability density function of the Weibull distribution"
msgstr "R.DWEIBULL:Wahrscheinlichkeitsdichtefunktion der Weibull-Verteilung"

#: ../plugins/fn-r/functions.c:546
msgid ""
"This function returns the probability density function of the Weibull "
"distribution."
msgstr ""
"Diese Funktion gibt die Wahrscheinlichkeitsdichtefunktion der Weibull-"
"Verteilung zurück."

#: ../plugins/fn-r/functions.c:565
msgid "R.PWEIBULL:cumulative distribution function of the Weibull distribution"
msgstr "R.PWEIBULL:Kumulative Verteilungsfunktion der Weibull-Verteilung"

#: ../plugins/fn-r/functions.c:571
msgid ""
"This function returns the cumulative distribution function of the Weibull "
"distribution."
msgstr ""
"Diese Funktion gibt die kumulative Verteilungsfunktion der Weibull-"
"Verteilung zurück."

#: ../plugins/fn-r/functions.c:591
msgid "R.QWEIBULL:probability quantile function of the Weibull distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:597
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the Weibull distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:617
msgid "R.DPOIS:probability density function of the Poisson distribution"
msgstr "R.DPOIS:Wahrscheinlichkeitsdichtefunktion der Poisson-Verteilung"

#: ../plugins/fn-r/functions.c:619 ../plugins/fn-r/functions.c:641
#: ../plugins/fn-r/functions.c:665
msgid "lambda:the mean of the distribution"
msgstr "lambda:der Erwartungswert der Verteilung"

#: ../plugins/fn-r/functions.c:621
msgid ""
"This function returns the probability density function of the Poisson "
"distribution."
msgstr ""
"Diese Funktion gibt die Wahrscheinlichkeitsdichtefunktion der Poisson-"
"Verteilung zurück."

#: ../plugins/fn-r/functions.c:639
msgid "R.PPOIS:cumulative distribution function of the Poisson distribution"
msgstr "R.PPOIS:Kumulative Verteilungsfunktion der Poisson-Verteilung"

#: ../plugins/fn-r/functions.c:644
msgid ""
"This function returns the cumulative distribution function of the Poisson "
"distribution."
msgstr ""
"Diese Funktion gibt die kumulative Verteilungsfunktion der Poisson-"
"Verteilung zurück."

#: ../plugins/fn-r/functions.c:663
msgid "R.QPOIS:probability quantile function of the Poisson distribution"
msgstr "R.QPOIS:Quantilfunktion der Poisson-Verteilung"

#: ../plugins/fn-r/functions.c:668
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the Poisson distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:687
msgid "R.DEXP:probability density function of the exponential distribution"
msgstr "R.DEXP:Wahrscheinlichkeitsdichtefunktion der Exponentialverteilung"

#: ../plugins/fn-r/functions.c:691
msgid ""
"This function returns the probability density function of the exponential "
"distribution."
msgstr ""
"Diese Funktion gibt die Wahrscheinlichkeitsdichtefunktion der "
"Exponentialverteilung zurück."

#: ../plugins/fn-r/functions.c:709
msgid "R.PEXP:cumulative distribution function of the exponential distribution"
msgstr "R.PEXP:Kumulative Verteilungsfunktion der Exponentialverteilung"

#: ../plugins/fn-r/functions.c:714
msgid ""
"This function returns the cumulative distribution function of the "
"exponential distribution."
msgstr ""
"Diese Funktion gibt die kumulative Verteilungsfunktion der "
"Exponentialverteilung zurück."

#: ../plugins/fn-r/functions.c:733
msgid "R.QEXP:probability quantile function of the exponential distribution"
msgstr "R.QEXP:Quantilfunktion der Exponentialverteilung"

#: ../plugins/fn-r/functions.c:738
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the exponential distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:757
msgid "R.DBINOM:probability density function of the binomial distribution"
msgstr "R.DBINOM:Wahrscheinlichkeitsdichtefunktion der Binomialverteilung"

#: ../plugins/fn-r/functions.c:759 ../plugins/fn-r/functions.c:783
#: ../plugins/fn-r/functions.c:809
msgid "n:the number of trials"
msgstr "n:Die Anzahl der Versuche"

#: ../plugins/fn-r/functions.c:760 ../plugins/fn-r/functions.c:784
#: ../plugins/fn-r/functions.c:810 ../plugins/fn-r/functions.c:836
#: ../plugins/fn-r/functions.c:860 ../plugins/fn-r/functions.c:886
#: ../plugins/fn-r/functions.c:993 ../plugins/fn-r/functions.c:1015
#: ../plugins/fn-r/functions.c:1039
msgid "psuc:the probability of success in each trial"
msgstr "psuc:die Wahrscheinlichkeit des Erfolgs für jeden Versuch"

#: ../plugins/fn-r/functions.c:762
msgid ""
"This function returns the probability density function of the binomial "
"distribution."
msgstr ""
"Diese Funktion gibt die Wahrscheinlichkeitsdichtefunktion der "
"Binomialverteilung zurück."

#: ../plugins/fn-r/functions.c:781
msgid "R.PBINOM:cumulative distribution function of the binomial distribution"
msgstr "R.PBINOM:kumulative Verteilungsfunktion der Binomialverteilung"

#: ../plugins/fn-r/functions.c:787
msgid ""
"This function returns the cumulative distribution function of the binomial "
"distribution."
msgstr ""
"Diese Funktion gibt die kumulative Verteilungsfunktion der "
"Binomialverteilung zurück."

#: ../plugins/fn-r/functions.c:807
msgid "R.QBINOM:probability quantile function of the binomial distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:813
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the binomial distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:833
msgid ""
"R.DNBINOM:probability density function of the negative binomial distribution"
msgstr ""
"R.DNBINOM:Wahrscheinlichkeitsdichtefunktion der negativen Binomialverteilung"

#: ../plugins/fn-r/functions.c:834 ../plugins/fn-r/functions.c:858
#, fuzzy
#| msgid "n:number of failures"
msgid "x:observation (number of failures)"
msgstr "n:Anzahl der Fehlversuche"

#: ../plugins/fn-r/functions.c:835 ../plugins/fn-r/functions.c:859
#: ../plugins/fn-r/functions.c:885
#, fuzzy
#| msgid "n:number of successes"
msgid "n:required number of successes"
msgstr "n:Anzahl der erfolgreichen Versuche"

#: ../plugins/fn-r/functions.c:838
msgid ""
"This function returns the probability density function of the negative "
"binomial distribution."
msgstr ""
"Diese Funktion gibt die Wahrscheinlichkeitsdichtefunktion der negativen "
"Binomialverteilung zurück."

#: ../plugins/fn-r/functions.c:857
msgid ""
"R.PNBINOM:cumulative distribution function of the negative binomial "
"distribution"
msgstr ""
"R.PNBINOM:kumulative Wahrscheinlichkeitsdichtefunktion der negativen "
"Binomialverteilung"

#: ../plugins/fn-r/functions.c:863
msgid ""
"This function returns the cumulative distribution function of the negative "
"binomial distribution."
msgstr ""
"Diese Funktion gibt die kumulative Wahrscheinlichkeitsdichtefunktion der "
"negativen Binomialverteilung zurück."

#: ../plugins/fn-r/functions.c:883
msgid ""
"R.QNBINOM:probability quantile function of the negative binomial distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:889
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the negative binomial "
"distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:909
msgid ""
"R.DHYPER:probability density function of the hypergeometric distribution"
msgstr ""
"R.DHYPER:Wahrscheinlichkeitsdichtefunktion der hypergeometrischen Verteilung"

#: ../plugins/fn-r/functions.c:911 ../plugins/fn-r/functions.c:937
#: ../plugins/fn-r/functions.c:965
msgid "r:the number of red balls"
msgstr "r:Anzahl der roten Kugeln"

#: ../plugins/fn-r/functions.c:912 ../plugins/fn-r/functions.c:938
#: ../plugins/fn-r/functions.c:966
msgid "b:the number of black balls"
msgstr "b:Anzahl der schwarzen Kugeln"

#: ../plugins/fn-r/functions.c:913 ../plugins/fn-r/functions.c:939
#: ../plugins/fn-r/functions.c:967
msgid "n:the number of balls drawn"
msgstr "n:Anzahl der dargestellten Kugeln"

#: ../plugins/fn-r/functions.c:915
msgid ""
"This function returns the probability density function of the hypergeometric "
"distribution."
msgstr ""
"Diese Funktion gibt die Wahrscheinlichkeitsdichtefunktion der "
"hypergeometrischen Verteilung zurück."

#: ../plugins/fn-r/functions.c:935
msgid ""
"R.PHYPER:cumulative distribution function of the hypergeometric distribution"
msgstr ""
"R.PHYPER:Kumulative Verteilungsfuntion der hypergeometrischen Verteilung"

#: ../plugins/fn-r/functions.c:942
msgid ""
"This function returns the cumulative distribution function of the "
"hypergeometric distribution."
msgstr ""
"Diese Funktion gibt die kumulative Verteilungsfunktion der "
"hypergeometrischen Verteilung zurück."

#: ../plugins/fn-r/functions.c:963
msgid ""
"R.QHYPER:probability quantile function of the hypergeometric distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:970
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the hypergeometric distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:991
msgid "R.DGEOM:probability density function of the geometric distribution"
msgstr "R.DGEOM:Wahrscheinlichkeitsdichtefunktion der geometrischen Verteilung"

#: ../plugins/fn-r/functions.c:995
msgid ""
"This function returns the probability density function of the geometric "
"distribution."
msgstr ""
"Diese Funktion gibt die Wahrscheinlichkeitsdichtefunktion der geometrischen "
"Verteilung zurück."

#: ../plugins/fn-r/functions.c:1013
msgid "R.PGEOM:cumulative distribution function of the geometric distribution"
msgstr "R.PGEOM:Kumulative Verteilungsfunktion der geometrischen Verteilung"

#: ../plugins/fn-r/functions.c:1018
msgid ""
"This function returns the cumulative distribution function of the geometric "
"distribution."
msgstr ""
"Diese Funktion gibt die kumulative Verteilungsfunktion der geometrischen "
"Verteilung zurück."

#: ../plugins/fn-r/functions.c:1037
msgid "R.QGEOM:probability quantile function of the geometric distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:1042
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the geometric distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:1061
msgid "R.DCAUCHY:probability density function of the Cauchy distribution"
msgstr "R.DCAUCHY:Wahrscheinlichkeitsdichtefunktion der Cauchy-Verteilung"

#: ../plugins/fn-r/functions.c:1063 ../plugins/fn-r/functions.c:1087
#: ../plugins/fn-r/functions.c:1169
msgid "location:the center of the distribution"
msgstr "location:Die Mitte der Verteilung"

#: ../plugins/fn-r/functions.c:1066
msgid ""
"This function returns the probability density function of the Cauchy "
"distribution."
msgstr ""
"Diese Funktion gibt die Wahrscheinlichkeitsdichtefunktion der Cauchy-"
"Verteilung zurück."

#: ../plugins/fn-r/functions.c:1085
msgid "R.PCAUCHY:cumulative distribution function of the Cauchy distribution"
msgstr "R.PCAUCHY:Kumulative Verteilungsfunktion der Cauchy-Verteilung"

#: ../plugins/fn-r/functions.c:1091
msgid ""
"This function returns the cumulative distribution function of the Cauchy "
"distribution."
msgstr ""
"Diese Funktion gibt die kumulative Verteilungsfunktion der Cauchy-Verteilung "
"zurück."

#: ../plugins/fn-r/functions.c:1111
#, fuzzy
#| msgid "R.PBETA:cumulative distribution function of the beta distribution"
msgid ""
"R.PTUKEY:cumulative distribution function of the Studentized range "
"distribution"
msgstr "R.PTUKEY:Kumulative Verteilungsfunktion der Studentschen ? Verteilung"

#: ../plugins/fn-r/functions.c:1113 ../plugins/fn-r/functions.c:1141
msgid "nmeans:the number of means"
msgstr "nmeans:Die Anzahl der Mittelwerte"

#: ../plugins/fn-r/functions.c:1115 ../plugins/fn-r/functions.c:1143
msgid "nranges:the number of ranges; default is 1"
msgstr "nranges:Anzahl der Bereiche. Vorgabe ist 1"

#: ../plugins/fn-r/functions.c:1118
#, fuzzy
#| msgid ""
#| "This function returns the cumulative distribution function of the beta "
#| "distribution."
msgid ""
"This function returns the cumulative distribution function of the "
"Studentized range distribution."
msgstr ""
"Diese Funktion gibt die kumulative Verteilungsfunktion der Beta-Verteilung "
"zurück."

#: ../plugins/fn-r/functions.c:1139
#, fuzzy
#| msgid "R.QEXP:probability quantile function of the exponential distribution"
msgid ""
"R.QTUKEY:probability quantile function of the Studentized range distribution"
msgstr "R.QEXP:Quantilfunktion der Exponentialverteilung"

#: ../plugins/fn-r/functions.c:1146
#, fuzzy
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the Studentized range "
"distribution."
msgstr ""
"Diese Funktion gibt die Wahrscheinlichkeitsdichtefunktion der "
"Normalverteilung zurück."

#: ../plugins/fn-r/functions.c:1167
msgid "R.QCAUCHY:probability quantile function of the Cauchy distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:1173
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the Cauchy distribution."
msgstr ""

#: ../plugins/fn-r/functions.c:1193
msgid "R.DSNORM:probability density function of the skew-normal distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:1196 ../plugins/fn-r/functions.c:1222
#: ../plugins/fn-r/functions.c:1250
msgid "location:the location parameter of the distribution"
msgstr "location:Der Ort der Verteilung"

#: ../plugins/fn-r/functions.c:1199
#, fuzzy
msgid ""
"This function returns the probability density function of the skew-normal "
"distribution."
msgstr ""
"Diese Funktion gibt die Wahrscheinlichkeitsdichtefunktion der "
"logarithmischen Normalverteilung zurück."

#: ../plugins/fn-r/functions.c:1219
msgid ""
"R.PSNORM:cumulative distribution function of the skew-normal distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:1226
#, fuzzy
msgid ""
"This function returns the cumulative distribution function of the skew-"
"normal distribution."
msgstr ""
"Diese Funktion gibt die kumulative Verteilungsfunktion der logarithmischen "
"Normalverteilung zurück."

#: ../plugins/fn-r/functions.c:1247
#, fuzzy
#| msgid "R.QNORM:probability quantile function of the normal distribution"
msgid "R.QSNORM:probability quantile function of the skew-normal distribution"
msgstr "R.QNORM:Quantilfunktion der Normalverteilung"

#: ../plugins/fn-r/functions.c:1254
#, fuzzy
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the skew-normal distribution."
msgstr ""
"Diese Funktion gibt die Wahrscheinlichkeitsdichtefunktion der "
"Normalverteilung zurück."

#: ../plugins/fn-r/functions.c:1275
msgid "R.DST:probability density function of the skew-t distribution"
msgstr ""

#: ../plugins/fn-r/functions.c:1280
#, fuzzy
msgid ""
"This function returns the probability density function of the skew-t "
"distribution."
msgstr ""
"Diese Funktion gibt die Wahrscheinlichkeitsdichtefunktion der "
"Normalverteilung zurück."

#: ../plugins/fn-r/functions.c:1299
#, fuzzy
#| msgid "R.PBETA:cumulative distribution function of the beta distribution"
msgid "R.PST:cumulative distribution function of the skew-t distribution"
msgstr "R.PBETA:Kumulative Verteilungsfunktion der Beta-Verteilung"

#: ../plugins/fn-r/functions.c:1305
#, fuzzy
#| msgid ""
#| "This function returns the cumulative distribution function of the beta "
#| "distribution."
msgid ""
"This function returns the cumulative distribution function of the skew-t "
"distribution."
msgstr ""
"Diese Funktion gibt die kumulative Verteilungsfunktion der Normalverteilung "
"zurück."

#: ../plugins/fn-r/functions.c:1325
#, fuzzy
#| msgid "R.QPOIS:probability quantile function of the Poisson distribution"
msgid "R.QST:probability quantile function of the skew-t distribution"
msgstr "R.QPOIS:Quantilfunktion der Poisson-Verteilung"

#: ../plugins/fn-r/functions.c:1331
#, fuzzy
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the skew-t distribution."
msgstr ""
"Diese Funktion gibt die Wahrscheinlichkeitsdichtefunktion der "
"Normalverteilung zurück."

#: ../plugins/fn-random/functions.c:47
msgid "RAND:a random number between zero and one"
msgstr "RAND:Zufallszahl zwischen 0 und 1"

#: ../plugins/fn-random/functions.c:64
msgid ""
"RANDUNIFORM:random variate from the uniform distribution from @{a} to @{b}"
msgstr "RANDUNIFORM:Zufallsvariable der Gleichverteilung von @{a} bis @{b}"

#: ../plugins/fn-random/functions.c:65
msgid "a:lower limit of the uniform distribution"
msgstr "b:untere Grenze der Gleichverteilung"

#: ../plugins/fn-random/functions.c:66
msgid "b:upper limit of the uniform distribution"
msgstr "b:obere Grenze der Gleichverteilung"

#: ../plugins/fn-random/functions.c:67
msgid "If @{a} > @{b} RANDUNIFORM returns #NUM!"
msgstr "Falls @{a} > @{b} ist, gibt RANDUNIFORM #ZAHL! zurück."

#: ../plugins/fn-random/functions.c:89
msgid "RANDDISCRETE:random variate from a finite discrete distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:90
msgid "val_range:possible values of the random variable"
msgstr "val_range:mögliche Werte einer Zufallsvariable"

#: ../plugins/fn-random/functions.c:91
msgid ""
"prob_range:probabilities of the corresponding values in @{val_range}, "
"defaults to equal probabilities"
msgstr ""

#: ../plugins/fn-random/functions.c:93
msgid ""
"RANDDISCRETE returns one of the values in the @{val_range}. The "
"probabilities for each value are given in the @{prob_range}."
msgstr ""
"RANDDISCRETE gibt einen der Werte aus @{val_range} zurück. Die "
"Wahrscheinlichkeit für jeden Wert ist durch @{prob_range} festgelegt."

#: ../plugins/fn-random/functions.c:95
msgid ""
"If the sum of all values in @{prob_range} is not one, RANDDISCRETE returns "
"#NUM!"
msgstr ""
"Falls die Summe aller Werte in @{prob_range} nicht 1 ist, gibt RANDDISCRETE "
"#ZAHL! zurück."

#: ../plugins/fn-random/functions.c:96
msgid ""
"If @{val_range} and @{prob_range} are not the same size, RANDDISCRETE "
"returns #NUM!"
msgstr ""
"Falls @{val_range} und @{prob_range} nicht gleich groß sind, gibt "
"RANDDISCRETE #ZAHL! zurück."

#: ../plugins/fn-random/functions.c:97
msgid ""
"If @{val_range} or @{prob_range} is not a range, RANDDISCRETE returns #VALUE!"
msgstr ""
"Falls @{val_range} oder @{prob_range} kein Bereich ist, gibt RANDDISCRETE "
"#WERT! zurück."

#: ../plugins/fn-random/functions.c:175
msgid "RANDEXP:random variate from an exponential distribution"
msgstr "RANDEXP:Zufallsvariable einer Exponentialverteilung"

#: ../plugins/fn-random/functions.c:176
msgid "b:parameter of the exponential distribution"
msgstr "b:Parameter einer Exponentialverteilung"

#: ../plugins/fn-random/functions.c:194
msgid "RANDPOISSON:random variate from a Poisson distribution"
msgstr "RANDPOISSON:Zufallsvariablen einer Poisson-Verteilung"

#: ../plugins/fn-random/functions.c:195
msgid "λ:parameter of the Poisson distribution"
msgstr "λ:Parameter der Poisson-Verteilung"

#: ../plugins/fn-random/functions.c:196
msgid "If @{λ} < 0 RANDPOISSON returns #NUM!"
msgstr "Falls @{λ} < 0 ist, gibt RANDPOISSON #ZAHL! zurück."

#: ../plugins/fn-random/functions.c:218
msgid "RANDBINOM:random variate from a binomial distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:219 ../plugins/fn-random/functions.c:276
#: ../plugins/fn-random/functions.c:582
msgid "p:probability of success in a single trial"
msgstr "p:Wahrscheinlichkeit des Erfolges für einen einzelnen Versuch"

#: ../plugins/fn-random/functions.c:220
msgid "n:number of trials"
msgstr "n:Anzahl der Versuche"

#: ../plugins/fn-random/functions.c:221
msgid "If @{p} < 0 or @{p} > 1 RANDBINOM returns #NUM!"
msgstr "Falls @{p} < 0 oder @{p} > 1, dann gibt RANDBINOM #ZAHL! zurück."

#: ../plugins/fn-random/functions.c:222
msgid "If @{n} < 0 RANDBINOM returns #NUM!"
msgstr "Falls @{n} < 0, gibt RANDBINOM #ZAHL! zurück."

#: ../plugins/fn-random/functions.c:244
msgid ""
"RANDBETWEEN:a random integer number between and including @{bottom} and @"
"{top}"
msgstr ""
"RANDBETWEEN:Eine zufällige Ganzzahl zwischen und einschließlich @{bottom} "
"und @{top}"

#: ../plugins/fn-random/functions.c:246
msgid "bottom:lower limit"
msgstr "bottom:Unterer Grenzwert"

#: ../plugins/fn-random/functions.c:247
msgid "top:upper limit"
msgstr "top:Oberer Grenzwert"

#: ../plugins/fn-random/functions.c:248
msgid "If @{bottom} > @{top}, RANDBETWEEN returns #NUM!"
msgstr "Falls @{bottom} > @{top}, dann gibt RANDBETWEEN #ZAHL! zurück."

#: ../plugins/fn-random/functions.c:275
msgid "RANDNEGBINOM:random variate from a negative binomial distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:277
msgid "n:number of failures"
msgstr "n:Anzahl der Fehlversuche"

#: ../plugins/fn-random/functions.c:278
msgid "If @{p} < 0 or @{p} > 1 RANDNEGBINOM returns #NUM!"
msgstr "Falls @{p} < 0 oder @{p} > 1, dann gibt RANDNEGBINOM #ZAHL! zurück."

#: ../plugins/fn-random/functions.c:279
msgid "If @{n} < 1 RANDNEGBINOM returns #NUM!"
msgstr "Falls @{n} < 1, dann gibt RANDNEGBINOM #ZAHL! zurück."

#: ../plugins/fn-random/functions.c:300
msgid "RANDBERNOULLI:random variate from a Bernoulli distribution"
msgstr "RANDBERNOULLI:Zufallsvariable einer Bernoulli-Verteilung"

#: ../plugins/fn-random/functions.c:301 ../plugins/fn-stat/functions.c:925
msgid "p:probability of success"
msgstr "p:Wahrscheinlichkeit des Erfolgs"

#: ../plugins/fn-random/functions.c:302
msgid "If @{p} < 0 or @{p} > 1 RANDBERNOULLI returns #NUM!"
msgstr "Falls @{p} < 0 oder @{p} > 1, dann gibt RANDBERNOULLI #ZAHL! zurück."

#: ../plugins/fn-random/functions.c:324
msgid "RANDNORM:random variate from a normal distribution"
msgstr "RANDNORM:Zufallsvariable einer Normalverteilung"

#: ../plugins/fn-random/functions.c:325
msgid "μ:mean of the distribution"
msgstr "µ:Erwartungswert der Verteilung"

#: ../plugins/fn-random/functions.c:326 ../plugins/fn-random/functions.c:374
msgid "σ:standard deviation of the distribution"
msgstr "σ:Standardabweichung der Verteilung"

#: ../plugins/fn-random/functions.c:327
msgid "If @{σ} < 0, RANDNORM returns #NUM!"
msgstr "Falls @{σ} < 0, dann gibt RANDNORM #ZAHL! zurück"

#: ../plugins/fn-random/functions.c:349
msgid "RANDCAUCHY:random variate from a Cauchy or Lorentz distribution"
msgstr "RANDCAUCHY:Zufallsvariable einer Cauchy- oder Lorentz-Verteilung"

#: ../plugins/fn-random/functions.c:350
msgid "a:scale parameter of the distribution"
msgstr "a:Skalierungsparameter der Verteilung"

#: ../plugins/fn-random/functions.c:351
msgid "If @{a} < 0 RANDCAUCHY returns #NUM!"
msgstr "Falls @{a} < 0, dann gibt RANDCAUCHY #ZAHL! zurück"

#: ../plugins/fn-random/functions.c:372
msgid "RANDLOGNORM:random variate from a lognormal distribution"
msgstr "RANDLOGNORM:Zufallsvariable einer logarithmischen Normalverteilung"

#: ../plugins/fn-random/functions.c:373
msgid "ζ:parameter of the lognormal distribution"
msgstr "ζ:Parameter der logarithmischen Normalverteilung"

#: ../plugins/fn-random/functions.c:375
msgid "If @{σ} < 0, RANDLOGNORM returns #NUM!"
msgstr "Falls @{σ} < 0, dann gibt RANDLOGNORM #ZAHL! zurück"

#: ../plugins/fn-random/functions.c:394
msgid "RANDWEIBULL:random variate from a Weibull distribution"
msgstr "RANDWEIBULL:Zufallsvariable einer Weibull-Verteilung"

#: ../plugins/fn-random/functions.c:395
msgid "a:parameter of the Weibull distribution"
msgstr "a:Parameter der Weibull-Verteilung"

#: ../plugins/fn-random/functions.c:396
msgid "b:parameter of the Weibull distribution"
msgstr "b:Parameter der Weibull-Verteilung"

#: ../plugins/fn-random/functions.c:415
msgid "RANDLAPLACE:random variate from a Laplace distribution"
msgstr "RANDLAPLACE:Zufallsvariable einer Laplace-Verteilung"

#: ../plugins/fn-random/functions.c:416
msgid "a:parameter of the Laplace distribution"
msgstr "a:Parameter der Laplace-Verteilung"

#: ../plugins/fn-random/functions.c:434
msgid "RANDRAYLEIGH:random variate from a Rayleigh distribution"
msgstr "RANDRAYLEIGH:Zufallsvariable einer Rayleigh-Verteilung"

#: ../plugins/fn-random/functions.c:435 ../plugins/fn-random/functions.c:455
msgid "σ:scale parameter of the Rayleigh distribution"
msgstr "σ:Skalierungsparameter der Rayleigh-Verteilung"

#: ../plugins/fn-random/functions.c:453
msgid ""
"RANDRAYLEIGHTAIL:random variate from the tail of a Rayleigh distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:454 ../plugins/fn-random/functions.c:793
#, fuzzy
msgid "a:lower limit of the tail"
msgstr "Untergrenze (Tag)"

#: ../plugins/fn-random/functions.c:474
msgid "RANDGAMMA:random variate from a Gamma distribution"
msgstr "RANDGAMMA:Zufallsvariable einer Gamma-Verteilung"

#: ../plugins/fn-random/functions.c:475
msgid "a:parameter of the Gamma distribution"
msgstr "a:Parameter der Gamma-Verteilung"

#: ../plugins/fn-random/functions.c:476
msgid "b:parameter of the Gamma distribution"
msgstr "b:Parameter der Gamma-Verteilung"

#: ../plugins/fn-random/functions.c:477
msgid "If @{a} ≤ 0, RANDGAMMA returns #NUM!"
msgstr "Falls @{a} ≤ 0, gibt RANDGAMMA #ZAHL! zurück."

#: ../plugins/fn-random/functions.c:499
msgid "RANDPARETO:random variate from a Pareto distribution"
msgstr "RANDPARETO:Zufallsvariable einer Pareto-Verteilung"

#: ../plugins/fn-random/functions.c:500
msgid "a:parameter of the Pareto distribution"
msgstr "a:Parameter der Pareto-Verteilung"

#: ../plugins/fn-random/functions.c:501
msgid "b:parameter of the Pareto distribution"
msgstr "b:Parameter der Pareto-Verteilung"

#: ../plugins/fn-random/functions.c:520
#, fuzzy
msgid "RANDFDIST:random variate from an F distribution"
msgstr "RANDEXP:Zufallsvariable einer Exponentialverteilung"

#: ../plugins/fn-random/functions.c:521
msgid "df1:numerator degrees of freedom"
msgstr "df1:Freiheitsgrad des Zählers"

#: ../plugins/fn-random/functions.c:522
msgid "df2:denominator degrees of freedom"
msgstr "df2:Freiheitsgrad des Nenners"

#: ../plugins/fn-random/functions.c:541
msgid "RANDBETA:random variate from a Beta distribution"
msgstr "RANDBETA:Zufallsvariable einer  Beta-Verteilung"

#: ../plugins/fn-random/functions.c:542
msgid "a:parameter of the Beta distribution"
msgstr "a:Parameter der Beta-Verteilung"

#: ../plugins/fn-random/functions.c:543
msgid "b:parameter of the Beta distribution"
msgstr "b:Parameter der Beta-Verteilung"

#: ../plugins/fn-random/functions.c:562
msgid "RANDLOGISTIC:random variate from a logistic distribution"
msgstr "RANDLOGISTIC:Zufallsvariable einer logistischen Verteilung"

#: ../plugins/fn-random/functions.c:563
msgid "a:parameter of the logistic distribution"
msgstr "a:Parameter der logistischen Verteilung"

#: ../plugins/fn-random/functions.c:581
msgid "RANDGEOM:random variate from a geometric distribution"
msgstr "RANDGEOM:Zufallsvariable einer geometrischen Verteilung"

#: ../plugins/fn-random/functions.c:583
msgid "If @{p} < 0 or @{p} > 1 RANDGEOM returns #NUM!"
msgstr "Falls @{p} < 0 oder @{p} > 1 ist, gibt RANDGEOM #ZAHL! zurück."

#: ../plugins/fn-random/functions.c:604
msgid "RANDHYPERG:random variate from a hypergeometric distribution"
msgstr "RANDHYPERG:Zufallsvariable einer hypergeometrischen Verteilung"

#: ../plugins/fn-random/functions.c:605
msgid "n1:number of objects of type 1"
msgstr "n1:Anzahl der Objekte des Typs 1"

#: ../plugins/fn-random/functions.c:606
msgid "n2:number of objects of type 2"
msgstr "n2:Anzahl der Objekte des Typs 2"

#: ../plugins/fn-random/functions.c:607
msgid "t:total number of objects selected"
msgstr "t:Anzahl der insgesamt ausgewählten Objekte"

#: ../plugins/fn-random/functions.c:629
msgid "RANDLOG:random variate from a logarithmic distribution"
msgstr "RANDLOG:Zufallsvariable einer logarithmischen Verteilung"

#: ../plugins/fn-random/functions.c:630 ../plugins/fn-stat/functions.c:560
#: ../plugins/fn-stat/functions.c:993 ../plugins/fn-stat/functions.c:1051
#: ../plugins/fn-stat/functions.c:1243 ../plugins/fn-stat/functions.c:1533
#: ../plugins/fn-stat/functions.c:1878
msgid "p:probability"
msgstr "p:Wahrscheinlichkeit"

#: ../plugins/fn-random/functions.c:631
msgid "If @{p} < 0 or @{p} > 1 RANDLOG returns #NUM!"
msgstr "Falls @{p} < 0 oder @{p} > 1 ist, gibt RANDLOG #ZAHL! zurück."

#: ../plugins/fn-random/functions.c:652
msgid "RANDCHISQ:random variate from a Chi-square distribution"
msgstr "RANDCHISQ:Zufallsvariable einer Chi-Quadrat-Verteilung"

#: ../plugins/fn-random/functions.c:653 ../plugins/fn-random/functions.c:672
#: ../plugins/fn-random/functions.c:942
msgid "df:degrees of freedom"
msgstr "df:Freiheitsgrade"

#: ../plugins/fn-random/functions.c:671
msgid "RANDTDIST:random variate from a Student t distribution"
msgstr "RANDTDIST:Zufallsvariable einer Studentschen t-Verteilung"

#: ../plugins/fn-random/functions.c:690
msgid "RANDGUMBEL:random variate from a Gumbel distribution"
msgstr "RANDGUMBEL:Zufallsvariable einer Gumbel-Verteilung"

#: ../plugins/fn-random/functions.c:691
msgid "a:parameter of the Gumbel distribution"
msgstr "a:Parameter einer Gumbel-Verteilung"

#: ../plugins/fn-random/functions.c:692
msgid "b:parameter of the Gumbel distribution"
msgstr "b:Parameter einer Gumbel-Verteilung"

#: ../plugins/fn-random/functions.c:693
msgid "type:type of the Gumbel distribution, defaults to 1"
msgstr "type:Typ einer Gumbel-Verteilung, Vorgabe ist 1"

#: ../plugins/fn-random/functions.c:694
msgid "If @{type} is neither 1 nor 2, RANDGUMBEL returns #NUM!"
msgstr "Falls @{type} weder 1 noch 2 ist, gibt RANDGUMBEL #ZAHL! zurück."

#: ../plugins/fn-random/functions.c:719
msgid "RANDLEVY:random variate from a Lévy distribution"
msgstr "RANDLEVY:Zufallsvariable einer Lévy-Verteilung"

#: ../plugins/fn-random/functions.c:720
msgid "c:parameter of the Lévy distribution"
msgstr "c:Parameter der Lévy-Verteilung"

#: ../plugins/fn-random/functions.c:721
msgid "α:parameter of the Lévy distribution"
msgstr "α:Parameter der Lévy-Verteilung"

#: ../plugins/fn-random/functions.c:722
msgid "β:parameter of the Lévy distribution, defaults to 0"
msgstr "β:Parameter der Lévy-Verteilung, Vorgabe ist 0"

#: ../plugins/fn-random/functions.c:723
msgid ""
"For @{α} = 1, @{β}=0, the Lévy distribution reduces to the Cauchy (or "
"Lorentzian) distribution."
msgstr ""

#: ../plugins/fn-random/functions.c:725
msgid ""
"For @{α} = 2, @{β}=0, the Lévy distribution reduces to the normal "
"distribution."
msgstr ""

#: ../plugins/fn-random/functions.c:727
msgid "If @{α} ≤ 0 or @{α} > 2, RANDLEVY returns #NUM!"
msgstr "Falls @{α} ≤ 0 oder @{α} > 2, dann gibt RANDLEVY #ZAHL! zurück."

#: ../plugins/fn-random/functions.c:728
msgid "If @{β} < -1 or @{β} > 1, RANDLEVY returns #NUM!"
msgstr "Falls @{β} < -1 oder @{β} > 1, dann gibt RANDLEVY #ZAHL! zurück."

#: ../plugins/fn-random/functions.c:751
msgid "RANDEXPPOW:random variate from an exponential power distribution"
msgstr "RANDEXPPOW:Zufallsvariable einer exponentiellen Leistungsverteilung"

#: ../plugins/fn-random/functions.c:752
msgid "a:scale parameter of the exponential power distribution"
msgstr "a:Skalierungsparameter der exponentiellen Leistungsverteilung"

#: ../plugins/fn-random/functions.c:753
msgid "b:exponent of the exponential power distribution"
msgstr "b:Exponent der exponentiellen Leistungsverteilung"

#: ../plugins/fn-random/functions.c:754
msgid ""
"For @{b} = 1 the exponential power distribution reduces to the Laplace "
"distribution."
msgstr ""
"Für @{b} = 1 reduziert sich die exponentielle Leistungsverteilung zur "
"Laplace-Verteilung"

#: ../plugins/fn-random/functions.c:756
msgid ""
"For @{b} = 2 the exponential power distribution reduces to the normal "
"distribution with σ = a/sqrt(2)"
msgstr ""
"Für @{b} = 2 reduziert sich die exponentielle Leistungsverteilung zur "
"Normalverteilung mit σ = a/sqrt(2)"

#: ../plugins/fn-random/functions.c:776
msgid "RANDLANDAU:random variate from the Landau distribution"
msgstr ""

#: ../plugins/fn-random/functions.c:792
msgid ""
"RANDNORMTAIL:random variate from the upper tail of a normal distribution "
"with mean 0"
msgstr ""

#: ../plugins/fn-random/functions.c:794
msgid "σ:standard deviation of the normal distribution"
msgstr "σ:Standardabweichung der Normalverteilung"

#: ../plugins/fn-random/functions.c:795
msgid ""
"The method is based on Marsaglia's famous rectangle-wedge-tail algorithm "
"(Ann Math Stat 32, 894-899 (1961)), with this aspect explained in Knuth, v2, "
"3rd ed, p139, 586 (exercise 11)."
msgstr ""

#: ../plugins/fn-random/functions.c:816
msgid ""
"SIMTABLE:one of the values in the given argument list depending on the round "
"number of the simulation tool"
msgstr ""

#: ../plugins/fn-random/functions.c:818
msgid "d1:first value"
msgstr "d1:Erster Wert"

#: ../plugins/fn-random/functions.c:819
msgid "d2:second value"
msgstr "d2:Zweiter Wert"

#: ../plugins/fn-random/functions.c:820
msgid ""
"SIMTABLE returns one of the values in the given argument list depending on "
"the round number of the simulation tool. When the simulation tool is not "
"activated, SIMTABLE returns @{d1}.\n"
"With the simulation tool and the SIMTABLE function you can test given "
"decision variables. Each SIMTABLE function contains the possible values of a "
"simulation variable. In most valid simulation models you should have the "
"same number of values @{dN} for all decision variables.  If the simulation "
"is run more rounds than there are values defined, SIMTABLE returns #N/A! "
"error (e.g. if A1 contains `=SIMTABLE(1)' and A2 `=SIMTABLE(1,2)', A1 yields "
"#N/A! error on the second round).\n"
"The successive use of the simulation tool also requires that you give to the "
"tool at least one input variable having RAND() or any other "
"RAND<distribution name>() function in it. On each round, the simulation tool "
"iterates for the given number of rounds over all the input variables to "
"reevaluate them. On each iteration, the values of the output variables are "
"stored, and when the round is completed, descriptive statistical information "
"is created according to the values."
msgstr ""

#: ../plugins/fn-random/functions.c:884
#, fuzzy
msgid "RANDSNORM:random variate from a skew-normal distribution"
msgstr "RANDNORM:Zufallsvariable einer Normalverteilung"

#: ../plugins/fn-random/functions.c:885
#, fuzzy
msgid "𝛼:shape parameter of the skew-normal distribution, defaults to 0"
msgstr "β:Parameter der Lévy-Verteilung, Vorgabe ist 0"

#: ../plugins/fn-random/functions.c:887
#, fuzzy
msgid "𝜉:location parameter of the skew-normal distribution, defaults to 0"
msgstr "β:Parameter der Lévy-Verteilung, Vorgabe ist 0"

#: ../plugins/fn-random/functions.c:889
#, fuzzy
msgid "𝜔:scale parameter of the skew-normal distribution, defaults to 1"
msgstr "β:Parameter der Lévy-Verteilung, Vorgabe ist 0"

#: ../plugins/fn-random/functions.c:891
msgid ""
"The random variates are drawn from a skew-normal distribution with shape "
"parameter @{𝛼}. When @{𝛼}=0, the skewness vanishes, and we obtain the "
"standard normal density; as 𝛼 increases (in absolute value), the skewness of "
"the distribution increases; when @{𝛼} approaches infinity  the density "
"converges to the so-called half-normal (or folded normal) density function; "
"if the sign of @{𝛼} changes, the density is reflected on the opposite side "
"of the vertical axis."
msgstr ""

#: ../plugins/fn-random/functions.c:901
msgid ""
"The mean of a skew-normal distribution with location parameter @{𝜉}=0 is not "
"0."
msgstr ""

#: ../plugins/fn-random/functions.c:903
#, fuzzy
msgid ""
"The standard deviation of a skew-normal distribution with scale parameter @"
"{𝜔}=1 is not 1."
msgstr ""
"σ:Standardabweichung der zugrunde liegenden Normalverteilung, Vorgabe ist 1"

#: ../plugins/fn-random/functions.c:905
msgid "The skewness of a skew-normal distribution is in general not @{𝛼}."
msgstr ""

#: ../plugins/fn-random/functions.c:906
msgid "If @{𝜔} < 0, RANDSNORM returns #NUM!"
msgstr "Falls @{𝜔} < 0, dann gibt RANDSNORM #ZAHL! zurück"

#: ../plugins/fn-random/functions.c:941
#, fuzzy
msgid "RANDSTDIST:random variate from a skew-t distribution"
msgstr "RANDTDIST:Zufallsvariable einer Studentschen t-Verteilung"

#: ../plugins/fn-random/functions.c:943
#, fuzzy
msgid "𝛼:shape parameter of the skew-t distribution, defaults to 0"
msgstr "β:Parameter der Lévy-Verteilung, Vorgabe ist 0"

#: ../plugins/fn-random/functions.c:944
msgid "The mean of a skew-t distribution is not 0."
msgstr ""

#: ../plugins/fn-random/functions.c:945
#, fuzzy
msgid "The standard deviation of a skew-t distribution is not 1."
msgstr "σ:Standardabweichung der Verteilung"

#: ../plugins/fn-random/functions.c:946
msgid "The skewness of a skew-t distribution is in general not @{𝛼}."
msgstr ""

#: ../plugins/fn-stat/functions.c:45
msgid ""
"Numbers, text and logical values are included in the calculation too. If the "
"cell contains text or the argument evaluates to FALSE, it is counted as "
"value zero (0). If the argument evaluates to TRUE, it is counted as one (1). "
"Note that empty cells are not counted."
msgstr ""
"Zahlen, Text und logische Werte werden ebenfalls in die Berechnung "
"einbezogen. Falls die Zelle Text enthält oder ein Argument, das FALSCH "
"ergibt, wird diese als Wert Null (0) gezählt. Falls das Argument WAHR "
"ergibt, wird es als Eins (1) gezählt. Beachten Sie, dass leere Zellen nicht "
"mitgezählt werden."

#: ../plugins/fn-stat/functions.c:50
msgid "VARP:variance of an entire population"
msgstr "VARP:Varianz der gesamten Population"

#: ../plugins/fn-stat/functions.c:51 ../plugins/fn-stat/functions.c:77
#: ../plugins/fn-stat/functions.c:107 ../plugins/fn-stat/functions.c:135
#: ../plugins/fn-stat/functions.c:2613 ../plugins/fn-stat/functions.c:2644
#: ../plugins/fn-stat/functions.c:2672 ../plugins/fn-stat/functions.c:2701
msgid "area1:first cell area"
msgstr "area1:Erster Zellenbereich"

#: ../plugins/fn-stat/functions.c:52 ../plugins/fn-stat/functions.c:78
#: ../plugins/fn-stat/functions.c:108 ../plugins/fn-stat/functions.c:136
#: ../plugins/fn-stat/functions.c:2614 ../plugins/fn-stat/functions.c:2645
#: ../plugins/fn-stat/functions.c:2673 ../plugins/fn-stat/functions.c:2702
msgid "area2:second cell area"
msgstr "area2:Zweiter Zellenbereich"

#: ../plugins/fn-stat/functions.c:53
msgid "VARP is also known as the N-variance."
msgstr "VARP ist auch als N-Varianz bekannt."

#: ../plugins/fn-stat/functions.c:54
msgid ""
"Let us assume that the cells A1, A2, ..., A5 contain number 11.4, 17.3, "
"21.3, 25.9, and 40.1."
msgstr ""
"Nehmen wir an, die Zellen A1, A2, ..., A5  enthalten die Zahlen 11.4, 17.3, "
"21.3, 25.9 und 40.1."

#: ../plugins/fn-stat/functions.c:55
msgid "Then VARP(A1:A5) equals 94.112"
msgstr "Dann ist VARP(A1:A5) gleich 94.112"

#: ../plugins/fn-stat/functions.c:57 ../plugins/fn-stat/functions.c:87
msgid "wiki:en:Variance"
msgstr "wiki:de:Varianz"

#: ../plugins/fn-stat/functions.c:58 ../plugins/fn-stat/functions.c:88
msgid "wolfram:Variance.html"
msgstr "wolfram:Variance.html"

#: ../plugins/fn-stat/functions.c:76
msgid "VAR:sample variance of the given sample"
msgstr ""

#: ../plugins/fn-stat/functions.c:79
msgid "VAR is also known as the N-1-variance."
msgstr "VAR ist auch als die N-1-Varianz bekannt."

#: ../plugins/fn-stat/functions.c:80 ../plugins/fn-stat/functions.c:2618
msgid ""
"Since the N-1-variance includes Bessel's correction, whereas the N-variance "
"calculated by VARPA or VARP does not, under reasonable conditions the N-1-"
"variance is an unbiased estimator of the variance of the population from "
"which the sample is drawn."
msgstr ""

#: ../plugins/fn-stat/functions.c:84 ../plugins/fn-stat/functions.c:112
#: ../plugins/fn-stat/functions.c:139 ../plugins/fn-stat/functions.c:277
#: ../plugins/fn-stat/functions.c:641 ../plugins/fn-stat/functions.c:668
#: ../plugins/fn-stat/functions.c:694 ../plugins/fn-stat/functions.c:744
#: ../plugins/fn-stat/functions.c:770 ../plugins/fn-stat/functions.c:805
#: ../plugins/fn-stat/functions.c:845 ../plugins/fn-stat/functions.c:870
#: ../plugins/fn-stat/functions.c:1916 ../plugins/fn-stat/functions.c:1942
#: ../plugins/fn-stat/functions.c:1966 ../plugins/fn-stat/functions.c:1991
#: ../plugins/fn-stat/functions.c:2117 ../plugins/fn-stat/functions.c:2249
#: ../plugins/fn-stat/functions.c:2292 ../plugins/fn-stat/functions.c:2480
#: ../plugins/fn-stat/functions.c:2830 ../plugins/fn-stat/functions.c:2873
msgid ""
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
"21.3, 25.9, and 40.1."
msgstr ""
"Angenommen, die Zellen A1, A2 ... A5 enthalten die Zahlen 11.4, 17.3, 21.3, "
"25.9 und 40.1."

#: ../plugins/fn-stat/functions.c:85
msgid "Then VAR(A1:A5) equals 117.64."
msgstr "Dann ist VAR(A1:A5) gleich 117.64."

#: ../plugins/fn-stat/functions.c:106
msgid "STDEV:sample standard deviation of the given sample"
msgstr ""

#: ../plugins/fn-stat/functions.c:109
msgid "STDEV is also known as the N-1-standard deviation."
msgstr "STDEV ist auch als die N-1-Standardabweichung bekannt."

#: ../plugins/fn-stat/functions.c:110
msgid ""
"To obtain the population standard deviation of a whole population use STDEVP."
msgstr ""

#: ../plugins/fn-stat/functions.c:113
msgid "Then STDEV(A1:A5) equals 10.84619749."
msgstr "Dann ist STDEV(A1:A5) gleich 10.84619749."

#: ../plugins/fn-stat/functions.c:115 ../plugins/fn-stat/functions.c:142
msgid "wiki:en:Standard_deviation"
msgstr "wiki:de:Standardabweichung"

#: ../plugins/fn-stat/functions.c:116 ../plugins/fn-stat/functions.c:143
msgid "wolfram:StandardDeviation.html"
msgstr "wolfram:StandardDeviation.html"

#: ../plugins/fn-stat/functions.c:134
msgid "STDEVP:population standard deviation of the given population"
msgstr ""

#: ../plugins/fn-stat/functions.c:137 ../plugins/fn-stat/functions.c:2703
msgid "This is also known as the N-standard deviation"
msgstr "Dies ist auch als die N-Standardverteilung bekannt"

#: ../plugins/fn-stat/functions.c:140
msgid "Then STDEVP(A1:A5) equals 9.701133954."
msgstr "Dann ist STDEVP(A1:A5) gleich 9.701133954."

#: ../plugins/fn-stat/functions.c:161
msgid "RANK:rank of a number in a list of numbers"
msgstr "RANK:Platzierung einer Zahl in einer Liste aus Zahlen"

#: ../plugins/fn-stat/functions.c:162 ../plugins/fn-stat/functions.c:214
msgid "x:number whose rank you want to find"
msgstr "x:Zahl, deren Platzierung Sie suchen wollen"

#: ../plugins/fn-stat/functions.c:164 ../plugins/fn-stat/functions.c:216
msgid "order:0 (descending order) or non-zero (ascending order); defaults to 0"
msgstr ""
"Reihenfolge:0 (absteigende Reihenfolge) oder ungleich 0 (aufsteigende "
"Reihenfolge); Voreinstellung ist 0"

#: ../plugins/fn-stat/functions.c:165
msgid "In case of a tie, RANK returns the largest possible rank."
msgstr "Im Falle eines Gleichstands gibt RANK den größtmöglichen Rang zurück."

#: ../plugins/fn-stat/functions.c:167
msgid ""
"Let us assume that the cells A1, A2, …, A5 contain numbers 11.4, 17.3, 21.3, "
"25.9, and 25.9."
msgstr ""
"Angenommen, die Zellen A1, A2 … A5 enthalten die Zahlen 11.4, 17.3, 21.3, "
"25.9 und 25.9."

#: ../plugins/fn-stat/functions.c:168
msgid "Then RANK(17.3,A1:A5) equals 4."
msgstr "Dann ist RANK(17.3,A1:A5) gleich 4."

#: ../plugins/fn-stat/functions.c:169
msgid "Then RANK(25.9,A1:A5) equals 1."
msgstr "Dann ist RANK(25.9,A1:A5) gleich 1."

#: ../plugins/fn-stat/functions.c:213
msgid "RANK.AVG:rank of a number in a list of numbers"
msgstr "RANK.AVG:Rang einer Zahl in einer Zahlenliste"

#: ../plugins/fn-stat/functions.c:217
msgid "In case of a tie, RANK returns the average rank."
msgstr ""

#: ../plugins/fn-stat/functions.c:218
msgid "This function is Excel 2010 compatible."
msgstr "Diese Funktion ist kompatibel zu Excel 2010."

#: ../plugins/fn-stat/functions.c:219
msgid ""
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
"21.3, 25.9, and 25.9."
msgstr ""
"Angenommen, die Zellen A1, A2 … A5 enthalten die Zahlen 11.4, 17.3, 21.3, "
"25.9 und 25.9."

#: ../plugins/fn-stat/functions.c:220
msgid "Then RANK.AVG(17.3,A1:A5) equals 4."
msgstr "Dann ist RANK.AVG(17.3,A1:A5) gleich 4."

#: ../plugins/fn-stat/functions.c:221
msgid "Then RANK.AVG(25.9,A1:A5) equals 1.5."
msgstr "Dann ist RANK.AVG(25.9,A1:A5) gleich 1.5."

#: ../plugins/fn-stat/functions.c:271
msgid "TRIMMEAN:mean of the interior of a data set"
msgstr ""

#: ../plugins/fn-stat/functions.c:272
msgid "ref:list of numbers whose mean you want to calculate"
msgstr "ref:Zahlenliste, deren Erwartungswert errechnet werden soll"

#: ../plugins/fn-stat/functions.c:273
msgid "fraction:fraction of the data set excluded from the mean"
msgstr ""

#: ../plugins/fn-stat/functions.c:274
msgid ""
"If @{fraction}=0.2 and the data set contains 40 numbers, 8 numbers are "
"trimmed from the data set (40 x 0.2): the 4 largest and the 4 smallest. To "
"avoid a bias, the number of points to be excluded is always rounded down to "
"the nearest even number."
msgstr ""
"Wenn @{fraction}=0.2 ist und der Datensatz 40 Zahlen enthält, so werden 8 "
"Zahlen aus der Datenmenge (40 x 0.2) entfernt: Die 4 größten und die 4 "
"kleinsten. Um eine Tendenz zu vermeiden, wird die Zahl der auszuschließenden "
"Punkte immer auf die nächste gerade Zahl abgerundet."

#: ../plugins/fn-stat/functions.c:278
msgid ""
"Then TRIMMEAN(A1:A5,0.2) equals 23.2 and TRIMMEAN(A1:A5,0.4) equals 21.5."
msgstr ""
"Dann ist TRIMMEAN(A1:A5,0.2) gleich 23.2 und TRIMMEAN(A1:A5,0.4) ergibt 21.5."

#: ../plugins/fn-stat/functions.c:320
msgid "COVAR:covariance of two data sets"
msgstr "COVAR:Kovarianz zweier Datensätze"

#: ../plugins/fn-stat/functions.c:321 ../plugins/fn-stat/functions.c:351
#: ../plugins/fn-stat/functions.c:381
msgid "array1:first data set"
msgstr "array1:Erster Datensatz"

#: ../plugins/fn-stat/functions.c:322 ../plugins/fn-stat/functions.c:352
msgid "array2:set data set"
msgstr "array2:Zweiter Datensatz"

#: ../plugins/fn-stat/functions.c:323 ../plugins/fn-stat/functions.c:353
#: ../plugins/fn-stat/functions.c:383 ../plugins/fn-stat/functions.c:611
#: ../plugins/fn-stat/functions.c:839 ../plugins/fn-stat/functions.c:868
#: ../plugins/fn-stat/functions.c:1908 ../plugins/fn-stat/functions.c:1939
#: ../plugins/fn-stat/functions.c:1989 ../plugins/fn-stat/functions.c:2070
#: ../plugins/fn-stat/functions.c:2089 ../plugins/fn-stat/functions.c:2113
msgid "Strings and empty cells are simply ignored."
msgstr "Zeichenketten und leere Zellen werden einfach ignoriert."

#: ../plugins/fn-stat/functions.c:325 ../plugins/fn-stat/functions.c:355
#: ../plugins/fn-stat/functions.c:385 ../plugins/fn-stat/functions.c:2421
#: ../plugins/fn-stat/functions.c:2914 ../plugins/fn-stat/functions.c:2980
#: ../plugins/fn-stat/functions.c:4079 ../plugins/fn-stat/functions.c:4136
#: ../plugins/fn-stat/functions.c:4188
msgid ""
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
"21.3, 25.9, and 40.1, and the cells B1, B2, ... B5 23.2, 25.8, 29.9, 33.5, "
"and 42.7."
msgstr ""
"Angenommen, die Zellen A1, A2 … A5 enthalten die Zahlen 11.4, 17.3, 21.3, "
"25.9 und 40.1, und die Zellen B1, B2 … B5 enthalten die Zahlen 23.2, 25.8, "
"29.9, 33.5 und 42.7."

#: ../plugins/fn-stat/functions.c:328 ../plugins/fn-stat/functions.c:358
msgid "Then COVAR(A1:A5,B1:B5) equals 65.858."
msgstr "Dann ist COVAR(A1:A5,B1:B5) gleich 65.858."

#: ../plugins/fn-stat/functions.c:330 ../plugins/fn-stat/functions.c:360
msgid "wiki:en:Covariance"
msgstr "wiki:de:Kovarianz"

#: ../plugins/fn-stat/functions.c:331 ../plugins/fn-stat/functions.c:361
#: ../plugins/fn-stat/functions.c:391
msgid "wolfram:Covariance.html"
msgstr "wolfram:Covariance.html"

#: ../plugins/fn-stat/functions.c:350
#, fuzzy
msgid "COVARIANCE.S:sample covariance of two data sets"
msgstr "COVAR:Kovarianz zweier Datensätze"

#: ../plugins/fn-stat/functions.c:380
msgid "CORREL:Pearson correlation coefficient of two data sets"
msgstr "CORREL:Pearson-Korrelationskoeffizient zweier Datensätze"

#: ../plugins/fn-stat/functions.c:382
msgid "array2:second data set"
msgstr "array2:Zweiter Datensatz"

#: ../plugins/fn-stat/functions.c:388
msgid "Then CORREL(A1:A5,B1:B5) equals 0.996124788."
msgstr "Dann ist CORREL(A1:A5,B1:B5) gleich 0.996124788."

#: ../plugins/fn-stat/functions.c:390
msgid "wiki:en:CorrelationCoefficient.html"
msgstr "wiki:de:Korrelationskoeffizient"

#: ../plugins/fn-stat/functions.c:410
msgid ""
"NEGBINOMDIST:probability mass function of the negative binomial distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:411
msgid "f:number of failures"
msgstr "f:Anzahl der Fehlversuche"

#: ../plugins/fn-stat/functions.c:412
msgid "t:threshold number of successes"
msgstr ""

#: ../plugins/fn-stat/functions.c:413
msgid "p:probability of a success"
msgstr "p:Wahrscheinlichkeit eines Treffers"

#: ../plugins/fn-stat/functions.c:414
msgid "If @{f} or @{t} is a non-integer it is truncated."
msgstr "Falls @{f} oder @{t} keine Ganzzahlen sind, werden sie abgeschnitten."

#: ../plugins/fn-stat/functions.c:415
msgid "If (@{f} + @{t} -1) <= 0 this function returns a #NUM! error."
msgstr ""
"Wenn (@{f} + @{t} -1) <= 0, dann gibt diese Funktion den Fehler #ZAHL! "
"zurück."

#: ../plugins/fn-stat/functions.c:416 ../plugins/fn-stat/functions.c:927
#: ../plugins/fn-stat/functions.c:996 ../plugins/fn-stat/functions.c:1248
#: ../plugins/fn-stat/functions.c:1537 ../plugins/fn-stat/functions.c:1570
#: ../plugins/fn-stat/functions.c:1604 ../plugins/fn-stat/functions.c:1665
#: ../plugins/fn-stat/functions.c:4440
msgid "If @{p} < 0 or @{p} > 1 this function returns a #NUM! error."
msgstr ""
"Falls @{p} < 0 oder @{p} > 1, gibt diese Funktion einen #ZAHL!-Fehler zurück."

#: ../plugins/fn-stat/functions.c:439
msgid ""
"NORMSDIST:cumulative distribution function of the standard normal "
"distribution"
msgstr "NORMSDIST:Kumulative Dichtefunktion der Standard-Normalverteilun"

#: ../plugins/fn-stat/functions.c:442
msgid "NORMSDIST is the OpenFormula function LEGACY.NORMSDIST."
msgstr "NORMSDIST ist die OpenFormula-Funktion LEGACY.NORMSDIST."

#: ../plugins/fn-stat/functions.c:445 ../plugins/fn-stat/functions.c:489
msgid "wiki:en:Normal_distribution"
msgstr "wiki:de:Normalverteilung"

#: ../plugins/fn-stat/functions.c:446 ../plugins/fn-stat/functions.c:490
msgid "wolfram:NormalDistribution.html"
msgstr "wolfram:NormalDistribution.html"

#: ../plugins/fn-stat/functions.c:461
msgid ""
"SNORM.DIST.RANGE:probability of the standard normal distribution over an "
"interval"
msgstr ""
"SNORM.DIST.RANGE:Wahrscheinlichkeit der Standardnormal-Verteilung über ein "
"Intervall"

#: ../plugins/fn-stat/functions.c:462
msgid "x1:start of the interval"
msgstr "x1:Start des Intervalls"

#: ../plugins/fn-stat/functions.c:463
msgid "x2:end of the interval"
msgstr "x2:Ende des Intervalls"

#: ../plugins/fn-stat/functions.c:464
msgid ""
"This function returns the cumulative probability over a range of the "
"standard normal distribution; that is the integral over the probability "
"density function from @{x1} to @{x2}."
msgstr ""
"Diese Funktion gibt die kumulative Wahrscheinlichkeit für einen Bereich der "
"Standard-Normalverteilung zurück, d.h. das Integral über die "
"Wahrscheinlichkeitsdichtefunktion von @{x1} bis @{x2}."

#: ../plugins/fn-stat/functions.c:465
msgid "If @{x1}>@{x2}, this function returns a negative value."
msgstr "Falls @{x1} > @{x2}, gibt diese Funktion einen negativen Wert zurück."

#: ../plugins/fn-stat/functions.c:482
msgid ""
"NORMSINV:inverse of the cumulative distribution function of the standard "
"normal distribution"
msgstr ""
"NORMSINV:Umkehrung der kumulativen Verteilungsfunktion der Standard-"
"Normalverteilung"

#: ../plugins/fn-stat/functions.c:483
msgid "p:given probability"
msgstr "p:gegebene Wahrscheinlichkeit"

#: ../plugins/fn-stat/functions.c:484
msgid "If @{p} < 0 or @{p} > 1 this function returns #NUM! error."
msgstr ""
"Falls @{p} < 0 oder @{p} > 1 ist, gibt diese Funktion einen #ZAHL!-Fehler "
"zurück."

#: ../plugins/fn-stat/functions.c:486
msgid "NORMSINV is the OpenFormula function LEGACY.NORMSINV."
msgstr "NORMSINV ist die OpenFormula-Funktion LEGACY.NORMSINV."

#: ../plugins/fn-stat/functions.c:509
#, fuzzy
#| msgid "SIN:Sine function"
msgid "OWENT:Owen's T function"
msgstr "SIN:Sinusfunktion"

#: ../plugins/fn-stat/functions.c:510
msgid "h:number"
msgstr "h:Zahl"

#: ../plugins/fn-stat/functions.c:511
msgid "a:number"
msgstr "a:Zahl"

#: ../plugins/fn-stat/functions.c:529
msgid ""
"LOGNORMDIST:cumulative distribution function of the lognormal distribution"
msgstr ""
"LOGNORMDIST:Kumulative Verteilungsfunktion der logarithmischen "
"Normalverteilung"

#: ../plugins/fn-stat/functions.c:531 ../plugins/fn-stat/functions.c:561
msgid "mean:mean"
msgstr "mean:Erwartungswert"

#: ../plugins/fn-stat/functions.c:532 ../plugins/fn-stat/functions.c:562
msgid "stddev:standard deviation"
msgstr "stddev:Standardabweichung"

#: ../plugins/fn-stat/functions.c:533
msgid "If @{stddev} = 0 LOGNORMDIST returns a #DIV/0! error."
msgstr "Falls @{stddev} = 0 ist, gibt LOGNORMDIST einen #DIV/0!-Fehler zurück."

#: ../plugins/fn-stat/functions.c:534
msgid ""
"If @{x} <= 0, @{mean} < 0 or @{stddev} <= 0 this function returns a #NUM! "
"error."
msgstr ""
"Wenn @{x} <= 0, @{mean} < 0 oder @{stddev} <= 0, dann gibt diese Funktion "
"den Fehler #ZAHL! zurück."

#: ../plugins/fn-stat/functions.c:538 ../plugins/fn-stat/functions.c:567
msgid "wiki:en:Log-normal_distribution"
msgstr "wiki:de:Logarithmische_Normalverteilung"

#: ../plugins/fn-stat/functions.c:539 ../plugins/fn-stat/functions.c:568
msgid "wolfram:LogNormalDistribution.html"
msgstr "wolfram:LogNormalDistribution.html"

#: ../plugins/fn-stat/functions.c:559
msgid ""
"LOGINV:inverse of the cumulative distribution function of the lognormal "
"distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:563
msgid ""
"If @{p} < 0 or @{p} > 1 or @{stddev} <= 0 this function returns #NUM! error."
msgstr ""
"Falls @{p} < 0 oder @{p} > 1 oder @{stddev} <= 0 ist, gibt diese Funktion "
"einen #ZAHL!-Fehler zurück."

#: ../plugins/fn-stat/functions.c:590
msgid "FISHERINV:inverse of the Fisher transformation"
msgstr "FISHERINV:Umkehrung der Fisher-Transformation"

#: ../plugins/fn-stat/functions.c:592
msgid "If @{x} is a non-number this function returns a #VALUE! error."
msgstr ""
"Falls @{x} keine Zahl ist, gibt diese Funktion einen #WERT!-Fehler zurück."

#: ../plugins/fn-stat/functions.c:608
msgid "MODE:first most common number in the dataset"
msgstr ""

#: ../plugins/fn-stat/functions.c:609 ../plugins/fn-stat/functions.c:637
#: ../plugins/fn-stat/functions.c:664 ../plugins/fn-stat/functions.c:691
#: ../plugins/fn-stat/functions.c:716 ../plugins/fn-stat/functions.c:741
#: ../plugins/fn-stat/functions.c:767 ../plugins/fn-stat/functions.c:802
#: ../plugins/fn-stat/functions.c:837 ../plugins/fn-stat/functions.c:866
#: ../plugins/fn-stat/functions.c:1906 ../plugins/fn-stat/functions.c:1937
#: ../plugins/fn-stat/functions.c:1963 ../plugins/fn-stat/functions.c:1987
#: ../plugins/fn-stat/functions.c:2111 ../plugins/fn-stat/functions.c:2534
#: ../plugins/fn-stat/functions.c:2559 ../plugins/fn-stat/functions.c:2586
msgid "number1:first value"
msgstr "number1:erster Wert"

#: ../plugins/fn-stat/functions.c:610 ../plugins/fn-stat/functions.c:638
#: ../plugins/fn-stat/functions.c:665 ../plugins/fn-stat/functions.c:692
#: ../plugins/fn-stat/functions.c:717 ../plugins/fn-stat/functions.c:742
#: ../plugins/fn-stat/functions.c:768 ../plugins/fn-stat/functions.c:803
#: ../plugins/fn-stat/functions.c:838 ../plugins/fn-stat/functions.c:867
#: ../plugins/fn-stat/functions.c:1907 ../plugins/fn-stat/functions.c:1938
#: ../plugins/fn-stat/functions.c:1964 ../plugins/fn-stat/functions.c:1988
#: ../plugins/fn-stat/functions.c:2112 ../plugins/fn-stat/functions.c:2535
#: ../plugins/fn-stat/functions.c:2560 ../plugins/fn-stat/functions.c:2587
msgid "number2:second value"
msgstr "number2:zweiter Wert"

#: ../plugins/fn-stat/functions.c:612
msgid ""
"If the data set does not contain any duplicates this function returns a #N/A "
"error."
msgstr ""
"Falls der Datensatz keinerlei Duplikate enthält, gibt diese Funktion einen "
"#N/V-Fehler zurück."

#: ../plugins/fn-stat/functions.c:614
msgid ""
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
"11.4, 25.9, and 40.1."
msgstr ""
"Angenommen, die Zellen A1, A2 … A5 enthalten die Zahlen 11.4, 17.3, 21.3, "
"25.9 und 40.1."

#: ../plugins/fn-stat/functions.c:615
msgid "Then MODE(A1:A5) equals 11.4."
msgstr "Dann ist MODE(A1:A5) gleich 11.4."

#: ../plugins/fn-stat/functions.c:617
msgid "wiki:en:Mode_(statistics)"
msgstr "wiki:de:Modus_(Statistik)"

#: ../plugins/fn-stat/functions.c:618
msgid "wolfram:Mode.html"
msgstr "wolfram:Mode.html"

#: ../plugins/fn-stat/functions.c:636
msgid "HARMEAN:harmonic mean"
msgstr "HARMEAN:harmonisches Mittel"

#: ../plugins/fn-stat/functions.c:639
msgid ""
"The harmonic mean of N data points is  N divided by the sum of the "
"reciprocals of the data points)."
msgstr ""
"Das harmonische Mittel von N Datenpunkten ist N dividiert durch die Summe "
"der Kehrwerte der Datenpunkte."

#: ../plugins/fn-stat/functions.c:642
msgid "Then HARMEAN(A1:A5) equals 19.529814427."
msgstr "Dann ist HARMEAN(A1:A5) gleich 19.529814427."

#: ../plugins/fn-stat/functions.c:644
msgid "wiki:en:Harmonic_mean"
msgstr "wiki:de:Harmonisches_Mittel"

#: ../plugins/fn-stat/functions.c:645
msgid "wolfram:HarmonicMean.html"
msgstr "wolfram:HarmonicMean.html"

#: ../plugins/fn-stat/functions.c:663
msgid "GEOMEAN:geometric mean"
msgstr "GEOMEAN:Geometrischer Mittelwert"

#: ../plugins/fn-stat/functions.c:666
msgid ""
"The geometric mean is equal to the Nth root of the product of the N values."
msgstr ""
"Der geometrische Mittelwert entspricht der N-ten Wurzel des Produkts aller N "
"Werte."

#: ../plugins/fn-stat/functions.c:669
msgid "Then GEOMEAN(A1:A5) equals 21.279182482."
msgstr "Dann ist GEOMEAN(A1:A5) gleich 21.279182482."

#: ../plugins/fn-stat/functions.c:671
msgid "wiki:en:Geometric_mean"
msgstr "wiki:de:Geometrisches_Mittel"

#: ../plugins/fn-stat/functions.c:672
msgid "wolfram:GeometricMean.html"
msgstr "wolfram:GeometricMean.html"

#: ../plugins/fn-stat/functions.c:690
msgid "COUNT:total number of integer or floating point arguments passed"
msgstr "COUNT:Anzahl der übergebenen Ganzzahl- oder Gleitkomma-Argumente"

#: ../plugins/fn-stat/functions.c:695
msgid "Then COUNT(A1:A5) equals 5."
msgstr "Dann ist COUNT(A1:A5) gleich 5."

#: ../plugins/fn-stat/functions.c:715
msgid "COUNTA:number of arguments passed not including empty cells"
msgstr "COUNTA:Anzahl der übergebenen Argumente, ohne leere Zellen"

#: ../plugins/fn-stat/functions.c:719
msgid ""
"Let us assume that the cells A1, A2, ..., A5 contain numbers and strings "
"11.4, \"missing\", \"missing\", 25.9, and 40.1."
msgstr ""
"Angenommen, die Zellen A1, A2 … A5 enthalten die Zahlen und Zeichenketten "
"11.4, »missing«, »missing«, 25.9 und 40.1."

#: ../plugins/fn-stat/functions.c:720
msgid "Then COUNTA(A1:A5) equals 5."
msgstr "Dann ist COUNTA(A1:A5) gleich 5."

#: ../plugins/fn-stat/functions.c:740
msgid "AVERAGE:average of all the numeric values and cells"
msgstr "AVERAGE:Durchschnitt aller numerischen Werte und Zellen"

#: ../plugins/fn-stat/functions.c:745
msgid "Then AVERAGE(A1:A5) equals 23.2."
msgstr "Dann ist AVERAGE(A1:A5) gleich 23.2."

#: ../plugins/fn-stat/functions.c:747
msgid "wiki:en:Arithmetic_mean"
msgstr "wiki:de:Arithmetisches_Mittel"

#: ../plugins/fn-stat/functions.c:748
msgid "wolfram:ArithmeticMean.html"
msgstr "wolfram:ArithmeticMean.html"

#: ../plugins/fn-stat/functions.c:766
msgid ""
"MIN:smallest value, with negative numbers considered smaller than positive "
"numbers"
msgstr ""
"MIN:Kleinster Wert, wobei negative Zahlen als kleiner als positive Zahlen "
"betrachtet werden."

#: ../plugins/fn-stat/functions.c:771
msgid "Then MIN(A1:A5) equals 11.4."
msgstr "Dann ist MIN(A1:A5 )gleich 11.4."

#: ../plugins/fn-stat/functions.c:801
msgid ""
"MAX:largest value, with negative numbers considered smaller than positive "
"numbers"
msgstr ""
"MAX:Größter Wert, wobei negative Zahlen als kleiner als positive Zahlen "
"betrachtet werden."

#: ../plugins/fn-stat/functions.c:806
msgid "Then MAX(A1:A5) equals 40.1."
msgstr "Dann ist MAX(A1:A5) gleich 40.1."

#: ../plugins/fn-stat/functions.c:836
msgid "SKEW:unbiased estimate for skewness of a distribution"
msgstr "SKEW:Wertfreie Schätzung der Schiefe einer Verteilung"

#: ../plugins/fn-stat/functions.c:840
msgid ""
"This is only meaningful if the underlying distribution really has a third "
"moment.  The skewness of a symmetric (e.g., normal) distribution is zero."
msgstr ""
"Dies ist nur von Bedeutung, wenn die zugrunde liegende Verteilung "
"tatsächlich ein drittes Moment hat. Die Schiefe einer symmetrischen "
"Verteilung (z.B. Normalverteilung) ist 0."

#: ../plugins/fn-stat/functions.c:843
msgid ""
"If less than three numbers are given, this function returns a #DIV/0! error."
msgstr ""
"Falls weniger als drei Zahlen angegeben werden, gibt diese Funktion einen "
"#DIV/0!-Fehler zurück."

#: ../plugins/fn-stat/functions.c:846
msgid "Then SKEW(A1:A5) equals 0.976798268."
msgstr "Dann ist SKEW(A1:A5) gleich 0.976798268."

#: ../plugins/fn-stat/functions.c:865
msgid "SKEWP:population skewness of a data set"
msgstr ""

#: ../plugins/fn-stat/functions.c:869
msgid "If less than two numbers are given, SKEWP returns a #DIV/0! error."
msgstr ""
"Falls weniger als zwei Zahlen angegeben werden, gibt SKEWP einen #DIV/0!-"
"Fehler zurück."

#: ../plugins/fn-stat/functions.c:871
msgid "Then SKEWP(A1:A5) equals 0.655256198."
msgstr "Dann ist SKEWP(A1:A5) gleich 0.655256198."

#: ../plugins/fn-stat/functions.c:890
msgid ""
"EXPONDIST:probability density or cumulative distribution function of the "
"exponential distribution"
msgstr ""
"EXPONDIST:Wahrscheinlichkeitsdichtefunktion oder kumulative "
"Verteilungsfunktion der Exponentialverteilung"

#: ../plugins/fn-stat/functions.c:892
msgid "y:scale parameter"
msgstr "y:Skalierungsparameter"

#: ../plugins/fn-stat/functions.c:893 ../plugins/fn-stat/functions.c:963
#: ../plugins/fn-stat/functions.c:1203 ../plugins/fn-stat/functions.c:1632
#: ../plugins/fn-stat/functions.c:1812 ../plugins/fn-stat/functions.c:1848
msgid ""
"cumulative:whether to evaluate the density function or the cumulative "
"distribution function"
msgstr ""

#: ../plugins/fn-stat/functions.c:894
msgid ""
"If @{cumulative} is false it will return:\t@{y} * exp (-@{y}*@{x}),otherwise "
"it will return\t1 - exp (-@{y}*@{x})."
msgstr ""
"Wenn @{cumulative} falsch ist, so wird \t@{y} * exp (-@{y}*@{x}) "
"zurückgegeben, andernfalls \t1 - exp (-@{y}*@{x})."

#: ../plugins/fn-stat/functions.c:897
msgid "If @{x} < 0 or @{y} <= 0 this will return an error."
msgstr "Falls @{x} < 0 oder @{y} <= 0 ist, wird ein Fehler zurückgegeben."

#: ../plugins/fn-stat/functions.c:923
msgid "BERNOULLI:probability mass function of a Bernoulli distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:924
msgid "k:integer"
msgstr "k:Ganzzahl"

#: ../plugins/fn-stat/functions.c:926
msgid "If @{k} != 0 and @{k} != 1 this function returns a #NUM! error."
msgstr ""
"Falls @{k} != 0 und @{k} != 1, gibt diese Funktion einen #ZAHL!-Fehler "
"zurück."

#: ../plugins/fn-stat/functions.c:959
msgid ""
"GAMMADIST:probability density or cumulative distribution function of the "
"gamma distribution"
msgstr ""
"LOGISTIC:Wahrscheinlichkeitsdichtefunktion oder kumulative "
"Verteilungsfunktion der Gamma-Verteilung"

#: ../plugins/fn-stat/functions.c:961 ../plugins/fn-stat/functions.c:994
#: ../plugins/fn-stat/functions.c:1166 ../plugins/fn-stat/functions.c:1201
#: ../plugins/fn-stat/functions.c:1244 ../plugins/fn-stat/functions.c:1810
msgid "alpha:scale parameter"
msgstr "alpha:Skalierungsparameter"

#: ../plugins/fn-stat/functions.c:962 ../plugins/fn-stat/functions.c:995
#: ../plugins/fn-stat/functions.c:1167 ../plugins/fn-stat/functions.c:1202
#: ../plugins/fn-stat/functions.c:1245 ../plugins/fn-stat/functions.c:1811
msgid "beta:scale parameter"
msgstr "beta:Skalierungsparameter"

#: ../plugins/fn-stat/functions.c:964 ../plugins/fn-stat/functions.c:1371
#: ../plugins/fn-stat/functions.c:1816 ../plugins/fn-stat/functions.c:2040
msgid "If @{x} < 0 this function returns a #NUM! error."
msgstr "Falls @{x} < 0 ist, gibt diese Funktion einen #ZAHL!-Fehler zurück."

#: ../plugins/fn-stat/functions.c:965 ../plugins/fn-stat/functions.c:1171
#: ../plugins/fn-stat/functions.c:1208 ../plugins/fn-stat/functions.c:1249
msgid "If @{alpha} <= 0 or @{beta} <= 0, this function returns a #NUM! error."
msgstr ""
"Falls @{alpha} <= 0 oder @{beta} <= 0, gibt diese Funktion einen #ZAHL!-"
"Fehler zurück."

#: ../plugins/fn-stat/functions.c:992
msgid "GAMMAINV:inverse of the cumulative gamma distribution"
msgstr "GAMMAINV:Umkehrung der kumulativen Gamma-Verteilung"

#: ../plugins/fn-stat/functions.c:997 ../plugins/fn-stat/functions.c:1817
msgid "If @{alpha} <= 0 or @{beta} <= 0 this function returns a #NUM! error."
msgstr ""
"Falls @{alpha} <= 0 oder @{beta} <= 0, gibt diese Funktion einen #ZAHL!-"
"Fehler zurück."

#: ../plugins/fn-stat/functions.c:1022
msgid "CHIDIST:survival function of the chi-squared distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:1024 ../plugins/fn-stat/functions.c:1052
#: ../plugins/fn-stat/functions.c:1279 ../plugins/fn-stat/functions.c:1331
msgid "dof:number of degrees of freedom"
msgstr "dof:Anzahl der Freiheitsgrade"

#: ../plugins/fn-stat/functions.c:1025 ../plugins/fn-stat/functions.c:1053
#: ../plugins/fn-stat/functions.c:1281 ../plugins/fn-stat/functions.c:1370
#: ../plugins/fn-stat/functions.c:1536
msgid "The survival function is 1 minus the cumulative distribution function."
msgstr ""

#: ../plugins/fn-stat/functions.c:1026
msgid "If @{dof} is non-integer it is truncated."
msgstr "Falls @{dof} keine Ganzzahl ist, wird sie abgeschnitten."

#: ../plugins/fn-stat/functions.c:1027 ../plugins/fn-stat/functions.c:1282
msgid "If @{dof} < 1 this function returns a #NUM! error."
msgstr "Falls @{dof} < 1, gibt diese Funbktion einen #ZAHL!-Fehler zurück."

#: ../plugins/fn-stat/functions.c:1029
msgid ""
"CHIDIST(@{x},@{dof}) is the OpenFormula function LEGACY.CHIDIST(@{x},@{dof})."
msgstr ""
"CHIDIST(@{x},@{dof}) ist die OpenFormula-Funktion LEGACY.CHIDIST(@{x},@"
"{dof})."

#: ../plugins/fn-stat/functions.c:1050
msgid "CHIINV:inverse of the survival function of the chi-squared distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:1054 ../plugins/fn-stat/functions.c:1335
msgid ""
"If @{p} < 0 or @{p} > 1 or @{dof} < 1 this function returns a #NUM! error."
msgstr ""
"Falls @{p} < 0 oder @{p} > 1 oder @{dof} < 1, gibt diese Funktion einen "
"#ZAHL!-Fehler zurück."

#: ../plugins/fn-stat/functions.c:1056
msgid ""
"CHIINV(@{p},@{dof}) is the OpenFormula function LEGACY.CHIDIST(@{p},@{dof})."
msgstr ""
"CHIINV(@{p},@{dof}) ist die OpenFormula-Funktion LEGACY.CHIDIST(@{p},@{dof})."

#: ../plugins/fn-stat/functions.c:1077
msgid "CHITEST:p value of the Goodness of Fit Test"
msgstr ""

#: ../plugins/fn-stat/functions.c:1078
msgid "actual_range:observed data"
msgstr "actual_range:betrachtete Daten"

#: ../plugins/fn-stat/functions.c:1079
msgid "theoretical_range:expected values"
msgstr "theoretical_range:erwartete Werte"

#: ../plugins/fn-stat/functions.c:1080
msgid ""
"If the actual range is not an n by 1 or 1 by n range, but an n by m range, "
"then CHITEST uses (n-1) times (m-1) as degrees of freedom. This is useful if "
"the expected values were calculated from the observed value in a test of "
"independence or test of homogeneity."
msgstr ""

#: ../plugins/fn-stat/functions.c:1086
msgid "CHITEST is the OpenFormula function LEGACY.CHITEST."
msgstr "CHITEST ist die OpenFormula-Funktion LEGACY.CHITEST."

#: ../plugins/fn-stat/functions.c:1164
#, fuzzy
msgid "BETADIST:cumulative distribution function of the beta distribution"
msgstr "R.PBETA:Kumulative Verteilungsfunktion der Beta-Verteilung"

#: ../plugins/fn-stat/functions.c:1168 ../plugins/fn-stat/functions.c:1205
#: ../plugins/fn-stat/functions.c:1246
msgid "a:optional lower bound, defaults to 0"
msgstr "a:Optionale untere Grenze, Vorgabe ist 0"

#: ../plugins/fn-stat/functions.c:1169 ../plugins/fn-stat/functions.c:1206
#: ../plugins/fn-stat/functions.c:1247
msgid "b:optional upper bound, defaults to 1"
msgstr "b:Optionale obere Grenze, Vorgabe ist 1"

#: ../plugins/fn-stat/functions.c:1170 ../plugins/fn-stat/functions.c:1207
msgid "If @{x} < @{a} or @{x} > @{b} this function returns a #NUM! error."
msgstr ""
"Falls @{x} < @{a} oder @{x} > @{b}, gibt diese Funktion einen #NUM!-Fehler "
"zurück."

#: ../plugins/fn-stat/functions.c:1172 ../plugins/fn-stat/functions.c:1209
#: ../plugins/fn-stat/functions.c:1250
msgid "If @{a} >= @{b} this function returns a #NUM! error."
msgstr "Falls @{a} >= @{b}, gibt diese Funktion einen #ZAHL!-Fehler zurück."

#: ../plugins/fn-stat/functions.c:1199
#, fuzzy
msgid "BETA.DIST:cumulative distribution function of the beta distribution"
msgstr "R.PBETA:Kumulative Verteilungsfunktion der Beta-Verteilung"

#: ../plugins/fn-stat/functions.c:1242
msgid ""
"BETAINV:inverse of the cumulative distribution function of the beta "
"distribution"
msgstr ""
"BETAINV:Umkehrung der kumulativen Verteilungsfunktion der Beta-Verteilung"

#: ../plugins/fn-stat/functions.c:1277
msgid "TDIST:survival function of the Student t-distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:1280
msgid "tails:1 or 2"
msgstr "tails:1 oder 2."

#: ../plugins/fn-stat/functions.c:1283
msgid "If @{tails} is neither 1 or 2 this function returns a #NUM! error."
msgstr ""
"Falls @{tails} weder 1 noch 2 ist, gibt diese Funktion einen #ZAHL!-Fehler "
"zurück."

#: ../plugins/fn-stat/functions.c:1284
msgid ""
"The parameterization of this function is different from what is used for, e."
"g., NORMSDIST.  This is a common source of mistakes, but necessary for "
"compatibility."
msgstr ""
"Die Parametrisierung dieser Funktion ist unterschiedlich im Vergleich zu z."
"B. NORMSDIST.  Dies ist eine übliche Fehlerquelle, aber zu Zwecken der "
"Kompatibilität notwendig."

#: ../plugins/fn-stat/functions.c:1287
msgid "This function is Excel compatible for non-negative @{x}."
msgstr "Diese Funktion ist Excel-kompatibel, wenn @{x} nicht negativ ist."

#: ../plugins/fn-stat/functions.c:1329
#, fuzzy
#| msgid "GAMMAINV:inverse of the cumulative gamma distribution"
msgid "TINV:two tailed inverse of the Student t-distribution"
msgstr "GAMMAINV:Umkehrung der kumulativen Gamma-Verteilung"

#: ../plugins/fn-stat/functions.c:1330
#, fuzzy
#| msgid "p:probability of a success"
msgid "p:probability in both tails"
msgstr "p:Wahrscheinlichkeit eines Treffers"

#: ../plugins/fn-stat/functions.c:1332
msgid ""
"This function returns the non-negative value x such that the area under the "
"Student t density with @{dof} degrees of freedom to the right of x is @{p}/2."
msgstr ""

#: ../plugins/fn-stat/functions.c:1337
msgid ""
"The parameterization of this function is different from what is used for, e."
"g., NORMSINV.  This is a common source of mistakes, but necessary for "
"compatibility."
msgstr ""
"Die Parametrisierung dieser Funktion ist unterschiedlich im Vergleich zu z."
"B. NORMSINV.  Dies ist eine übliche Fehlerquelle, aber zu Zwecken der "
"Kompatibilität notwendig."

#: ../plugins/fn-stat/functions.c:1366
msgid "FDIST:survival function of the F distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:1368 ../plugins/fn-stat/functions.c:1534
msgid "dof_of_num:numerator degrees of freedom"
msgstr ""

#: ../plugins/fn-stat/functions.c:1369 ../plugins/fn-stat/functions.c:1535
msgid "dof_of_denom:denominator degrees of freedom"
msgstr ""

#: ../plugins/fn-stat/functions.c:1372
msgid ""
"If @{dof_of_num} < 1 or @{dof_of_denom} < 1, this function returns a #NUM! "
"error."
msgstr ""
"Falls @{dof_of_num} < 1 oder @{dof_of_denom} < 1, gibt diese Funktion einen "
"#ZAHL!-Fehler zurück."

#: ../plugins/fn-stat/functions.c:1374
msgid "FDIST is the OpenFormula function LEGACY.FDIST."
msgstr "FDIST ist die OpenFormula-Funktion LEGACY.FDIST."

#: ../plugins/fn-stat/functions.c:1396
msgid ""
"LANDAU:approximate probability density function of the Landau distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:1532
msgid "FINV:inverse of the survival function of the F distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:1538
msgid ""
"If @{dof_of_num} < 1 or @{dof_of_denom} < 1 this function returns a #NUM! "
"error."
msgstr ""
"Falls @{dof_of_num} < 1 oder @{dof_of_denom} < 1, gibt diese Funktion einen "
"#ZAHL!-Fehler zurück."

#: ../plugins/fn-stat/functions.c:1540
msgid "FINV is the OpenFormula function LEGACY.FINV."
msgstr "FINV ist die OpenFormula-Funktion LEGACY.FINV."

#: ../plugins/fn-stat/functions.c:1562
msgid ""
"BINOMDIST:probability mass or cumulative distribution function of the "
"binomial distribution"
msgstr ""
"BINOMDIST:Wahrscheinlichkeitsfunktion oder kumulative Verteilungsfunktion "
"der Binomialverteilung"

#: ../plugins/fn-stat/functions.c:1563
msgid "n:number of successes"
msgstr "n:Anzahl der erfolgreichen Versuche"

#: ../plugins/fn-stat/functions.c:1564 ../plugins/fn-stat/functions.c:1598
#: ../plugins/fn-stat/functions.c:1660
msgid "trials:number of trials"
msgstr "trials:Anzahl der Versuche"

#: ../plugins/fn-stat/functions.c:1565 ../plugins/fn-stat/functions.c:1599
#: ../plugins/fn-stat/functions.c:1661
msgid "p:probability of success in each trial"
msgstr "p:Wahrscheinlichkeit des Erfolgs für jeden Versuch"

#: ../plugins/fn-stat/functions.c:1566 ../plugins/fn-stat/functions.c:1720
#: ../plugins/fn-stat/functions.c:2038 ../plugins/fn-stat/functions.c:4438
msgid ""
"cumulative:whether to evaluate the mass function or the cumulative "
"distribution function"
msgstr ""

#: ../plugins/fn-stat/functions.c:1567
msgid "If @{n} or @{trials} are non-integer they are truncated."
msgstr ""
"Falls @{n} oder @{trials} keine Ganzzahlen sind, werden sie abgeschnitten."

#: ../plugins/fn-stat/functions.c:1568
msgid "If @{n} < 0 or @{trials} < 0 this function returns a #NUM! error."
msgstr ""
"Falls @{n} < 0 oder @{trials} < 0, gibt diese Funktion einen #ZAHL!-Fehler "
"zurück."

#: ../plugins/fn-stat/functions.c:1569
msgid "If @{n} > @{trials} this function returns a #NUM! error."
msgstr ""
"Falls @{n} > @{trials}, gibt diese Funktion einen #ZAHL!-Fehler zurück."

#: ../plugins/fn-stat/functions.c:1597
msgid ""
"BINOM.DIST.RANGE:probability of the binomial distribution over an interval"
msgstr ""
"BINOM.DIST.RANGE:Wahrscheinlichkeit der binomialen Verteilung über ein "
"Intervall"

#: ../plugins/fn-stat/functions.c:1600
msgid "start:start of the interval"
msgstr "start:Start des Intervalls"

#: ../plugins/fn-stat/functions.c:1601
msgid "end:end of the interval, defaults to @{start}"
msgstr "end:Ende des Intervalls, Vorgabe ist @{start}"

#: ../plugins/fn-stat/functions.c:1602
msgid "If @{start}, @{end} or @{trials} are non-integer they are truncated."
msgstr ""
"Falls @{start}, @{end} oder @{trials} keine Ganzzahlen sind, werden sie "
"abgeschnitten."

#: ../plugins/fn-stat/functions.c:1603 ../plugins/fn-stat/functions.c:1664
msgid "If @{trials} < 0 this function returns a #NUM! error."
msgstr "Falls @{trials} < 0, gibt diese Funktion einen #ZAHL!-Fehler zurück."

#: ../plugins/fn-stat/functions.c:1605
msgid "If @{start} > @{end} this function returns 0."
msgstr "Falls @{start} > @{end}, gibt diese Funktion 0 zurück."

#: ../plugins/fn-stat/functions.c:1628
msgid ""
"CAUCHY:probability density or cumulative distribution function of the "
"Cauchy, Lorentz or Breit-Wigner distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:1631 ../plugins/fn-stat/functions.c:4468
#: ../plugins/fn-stat/functions.c:4607
msgid "a:scale parameter"
msgstr "a:Skalierungsparameter"

#: ../plugins/fn-stat/functions.c:1633
msgid "If @{a} < 0 this function returns a #NUM! error."
msgstr "Falls @{a} < 0, gibt diese Funktion einen #ZAHL!-Fehler zurück."

#: ../plugins/fn-stat/functions.c:1634 ../plugins/fn-stat/functions.c:4441
msgid ""
"If @{cumulative} is neither TRUE nor FALSE this function returns a #VALUE! "
"error."
msgstr ""
"Falls @{cumulative} weder WAHR noch UNWAHR ist, gibt diese Funktion einen "
"#WERT!-Fehler zurück."

#: ../plugins/fn-stat/functions.c:1659
msgid "CRITBINOM:right-tailed critical value of the binomial distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:1662
msgid "alpha:significance level (area of the tail)"
msgstr ""

#: ../plugins/fn-stat/functions.c:1663
msgid "If @{trials} is a non-integer it is truncated."
msgstr "Falls @{trials} keine Ganzzahl ist, wird sie abgeschnitten."

#: ../plugins/fn-stat/functions.c:1666
msgid "If @{alpha} < 0 or @{alpha} > 1 this function returns a #NUM! error."
msgstr ""
"Falls @{alpha} < 0 oder @{alpha} > 1, gibt diese Funktion einen #ZAHL!-"
"Fehler zurück."

#: ../plugins/fn-stat/functions.c:1689
msgid "PERMUT:number of @{k}-permutations of a @{n}-set"
msgstr "PERMUT:Anzahl der @{k}-Permutationen einer @{n}-Menge"

#: ../plugins/fn-stat/functions.c:1690
#, fuzzy
msgid "n:size of the base set"
msgstr "Die Schrittgröße festlegen"

#: ../plugins/fn-stat/functions.c:1691
msgid "k:number of elements in each permutation"
msgstr "k:Anzahl der Elemente in jeder Permutation"

#: ../plugins/fn-stat/functions.c:1692
msgid "If @{n} = 0 this function returns a #NUM! error."
msgstr "Falls @{n} = 0, gibt diese Funktion einen #ZAHL!-Fehler zurück."

#: ../plugins/fn-stat/functions.c:1693
msgid "If @{n} < @{k} this function returns a #NUM! error."
msgstr "Falls @{n} < @{k}, gibt diese Funktion einen #ZAHL!-Fehler zurück."

#: ../plugins/fn-stat/functions.c:1715
msgid ""
"HYPGEOMDIST:probability mass or cumulative distribution function of the "
"hypergeometric distribution"
msgstr ""
"GEOMDIST:Wahrscheinlichkeitsfunktion oder kumulative Verteilungsfunktion der "
"hypergeometrischen Verteilung"

#: ../plugins/fn-stat/functions.c:1716
msgid "x:number of successes"
msgstr "x:Anzahl der erfolgreichen Versuche"

#: ../plugins/fn-stat/functions.c:1717
msgid "n:sample size"
msgstr "n:Beispielgröße"

#: ../plugins/fn-stat/functions.c:1718
msgid "M:number of possible successes in the population"
msgstr ""

#: ../plugins/fn-stat/functions.c:1719
msgid "N:population size"
msgstr "N:Populationsgröße"

#: ../plugins/fn-stat/functions.c:1721
msgid "If @{x},@{n},@{M} or @{N} is a non-integer it is truncated."
msgstr ""
"Falls @{x},@{n},@{M} oder @{N} keine Ganzzahl ist, wird diese abgeschnitten."

#: ../plugins/fn-stat/functions.c:1722
msgid "If @{x},@{n},@{M} or @{N} < 0 this function returns a #NUM! error."
msgstr ""
"Falls @{x},@{n},@{M} oder @{N} < 0, gibt diese Function einen #ZAHL!-Fehler "
"zurück."

#: ../plugins/fn-stat/functions.c:1723
msgid "If @{x} > @{M} or @{n} > @{N} this function returns a #NUM! error."
msgstr ""
"Falls @{x} > @{M} oder @{n} > @{N}, gibt diese Function einen #ZAHL!-Fehler "
"zurück."

#: ../plugins/fn-stat/functions.c:1751
msgid ""
"CONFIDENCE:margin of error of a confidence interval for the population mean"
msgstr ""

#: ../plugins/fn-stat/functions.c:1752
msgid "alpha:significance level"
msgstr ""

#: ../plugins/fn-stat/functions.c:1753
msgid "stddev:population standard deviation"
msgstr "stddev:Standardabweichung in der Population"

#: ../plugins/fn-stat/functions.c:1754
msgid "size:sample size"
msgstr "size:Beispielgröße"

#: ../plugins/fn-stat/functions.c:1755
msgid ""
"This function requires the usually unknown population standard deviation."
msgstr ""

#: ../plugins/fn-stat/functions.c:1756
msgid "If @{size} is non-integer it is truncated."
msgstr "Falls @{size} keine Ganzzahl ist, wird sie abgeschnitten."

#: ../plugins/fn-stat/functions.c:1757
msgid "If @{size} < 0 this function returns a #NUM! error."
msgstr "Falls @{size} < 0 ist, gibt diese Funktion einen #ZAHL!-Fehler zurück."

#: ../plugins/fn-stat/functions.c:1758
msgid "If @{size} is 0 this function returns a #DIV/0! error."
msgstr "Falls @{size} 0 ist, gibt diese Funktion einen #DIV/0!-Fehler zurück."

#: ../plugins/fn-stat/functions.c:1781
msgid "STANDARDIZE:z-score of a value"
msgstr ""

#: ../plugins/fn-stat/functions.c:1783
msgid "mean:mean of the original distribution"
msgstr "mean:Erwartungswert der Originalverteilung"

#: ../plugins/fn-stat/functions.c:1784
msgid "stddev:standard deviation of the original distribution"
msgstr "stddev:Standardabweichung der Originalverteilung"

#: ../plugins/fn-stat/functions.c:1785 ../plugins/fn-stat/functions.c:1849
msgid "If @{stddev} is 0 this function returns a #DIV/0! error."
msgstr ""
"Falls @{stddev} 0 ist, gibt diese Funktion einen #DIV/0!-Fehler zurück."

#: ../plugins/fn-stat/functions.c:1808
#, fuzzy
msgid ""
"WEIBULL:probability density or cumulative distribution function of the "
"Weibull distribution"
msgstr ""
"EXPONDIST:Wahrscheinlichkeitsdichtefunktion oder kumulative "
"Verteilungsfunktion der Exponentialverteilung"

#: ../plugins/fn-stat/functions.c:1813
msgid ""
"If the @{cumulative} boolean is true it will return: 1 - exp (-(@{x}/@{beta})"
"^@{alpha}),otherwise it will return (@{alpha}/@{beta}^@{alpha}) * @{x}^(@"
"{alpha}-1) * exp(-(@{x}/@{beta}^@{alpha}))."
msgstr ""
"Wenn der Boolean @{cumulative} war ist, so wird 1 - exp (-(@{x}/@{beta})^@"
"{alpha}) zurückgegeben, andernfalls (@{alpha}/@{beta}^@{alpha}) * @{x}^(@"
"{alpha}-1) * exp(-(@{x}/@{beta}^@{alpha}))."

#: ../plugins/fn-stat/functions.c:1844
msgid ""
"NORMDIST:probability density or cumulative distribution function of a normal "
"distribution"
msgstr ""
"NORMDIST:Wahrscheinlichkeitsdichtefunktion oder kumulative "
"Verteilungsfunktion der Normalverteilung"

#: ../plugins/fn-stat/functions.c:1846 ../plugins/fn-stat/functions.c:1879
#: ../plugins/fn-stat/functions.c:2037
msgid "mean:mean of the distribution"
msgstr "mean:Erwartungswert der Verteilung"

#: ../plugins/fn-stat/functions.c:1847 ../plugins/fn-stat/functions.c:1880
msgid "stddev:standard deviation of the distribution"
msgstr "stddev:Standardabweichung der Verteilung"

#: ../plugins/fn-stat/functions.c:1877
msgid ""
"NORMINV:inverse of the cumulative distribution function of a normal "
"distribution"
msgstr ""
"NORMINV:Umkehrungsfunktion der kumulativen Verteilungsfunktion einer "
"Normalverteilung"

#: ../plugins/fn-stat/functions.c:1881
msgid ""
"If @{p} < 0 or @{p} > 1 or @{stddev} <= 0 this function returns a #NUM! "
"error."
msgstr ""
"Wenn @{p} < 0 oder @{p} > 1 oder @{stddev} <= 0 ist, so gibt diese Funktion "
"den Fehler #ZAHL! zurück."

#: ../plugins/fn-stat/functions.c:1905
msgid "KURT:unbiased estimate of the kurtosis of a data set"
msgstr "KURT:Wertfreie Schätzung der Kurtosis eines Datensatzes"

#: ../plugins/fn-stat/functions.c:1909
msgid ""
"This is only meaningful if the underlying distribution really has a fourth "
"moment.  The kurtosis is offset by three such that a normal distribution "
"will have zero kurtosis."
msgstr ""

#: ../plugins/fn-stat/functions.c:1913
msgid ""
"If fewer than four numbers are given or all of them are equal this function "
"returns a #DIV/0! error."
msgstr ""
"Falls weniger als vier Zahlen angegeben werden oder alle Zahlen gleich sind, "
"gibt diese Funktion einen #DIV/0!-Fehler zurück."

#: ../plugins/fn-stat/functions.c:1917
msgid "Then KURT(A1:A5) equals 1.234546305."
msgstr "Dann ist KURT(A1:A5) gleich 1.234546305."

#: ../plugins/fn-stat/functions.c:1936
msgid "KURTP:population kurtosis of a data set"
msgstr ""

#: ../plugins/fn-stat/functions.c:1940
msgid ""
"If fewer than two numbers are given or all of them are equal this function "
"returns a #DIV/0! error."
msgstr ""
"Falls weniger als zwei Zahlen gegeben oder alle gleich sind, gibt diese "
"Funktion einen #DIV/0!-Fehler zurück."

#: ../plugins/fn-stat/functions.c:1943
msgid "Then KURTP(A1:A5) equals -0.691363424."
msgstr "Dann ist KURTP(A1:A5) gleich -0.691363424."

#: ../plugins/fn-stat/functions.c:1962
msgid "AVEDEV:average of the absolute deviations of a data set"
msgstr "AVEDEV:Erwartungswert der absoluten Abweichungen eines Datensatzes"

#: ../plugins/fn-stat/functions.c:1967
msgid "Then AVEDEV(A1:A5) equals 7.84."
msgstr "Dann ist AVEDEV(A1:A5) gleich 7.84."

#: ../plugins/fn-stat/functions.c:1986
msgid "DEVSQ:sum of squares of deviations of a data set"
msgstr "DEVSQ:Summe der Quadrate der Abweichungen eines Datensatzes"

#: ../plugins/fn-stat/functions.c:1992
msgid "Then DEVSQ(A1:A5) equals 470.56."
msgstr "Dann ist DEVSQ(A1:A5) gleich 470.56."

#: ../plugins/fn-stat/functions.c:2011
msgid "FISHER:Fisher transformation"
msgstr "FISHER:Fisher-Transformation"

#: ../plugins/fn-stat/functions.c:2013
msgid "If @{x} is not a number, this function returns a #VALUE! error."
msgstr ""
"Falls @{x} keine Zahl ist, gibt diese Funktion einen #WERT!-Fehler zurück."

#: ../plugins/fn-stat/functions.c:2014
msgid "If @{x} <= -1 or @{x} >= 1, this function returns a #NUM! error."
msgstr ""
"Falls @{x} <= -1 oder @{x} >= 1, gibt diese Funktion einen #ZAHL!-Fehler "
"zurück."

#: ../plugins/fn-stat/functions.c:2035
#, fuzzy
msgid ""
"POISSON:probability mass or cumulative distribution function of the Poisson "
"distribution"
msgstr ""
"BINOMDIST:Wahrscheinlichkeitsfunktion oder kumulative Verteilungsfunktion "
"der Binomialverteilung"

#: ../plugins/fn-stat/functions.c:2036
msgid "x:number of events"
msgstr "x:Anzahl der Ereignisse"

#: ../plugins/fn-stat/functions.c:2039
msgid "If @{x} is a non-integer it is truncated."
msgstr "Falls @{x} keine Ganzzahl ist, wird sie abgeschnitten."

#: ../plugins/fn-stat/functions.c:2041
msgid "If @{mean} <= 0 POISSON returns the #NUM! error."
msgstr "Falls @{mean} <= 0 ist, gibt POISSON einen #ZAHL!-Fehler zurück."

#: ../plugins/fn-stat/functions.c:2067
msgid "PEARSON:Pearson correlation coefficient of the paired set of data"
msgstr "PEARSON:Pearson-Korrelationskoeffizient des gepaarten Datensatzes"

#: ../plugins/fn-stat/functions.c:2068 ../plugins/fn-stat/functions.c:2087
msgid "array1:first component values"
msgstr "array1:Werte der ersten Komponente"

#: ../plugins/fn-stat/functions.c:2069 ../plugins/fn-stat/functions.c:2088
msgid "array2:second component values"
msgstr "array2:Werte der zweiten Komponente"

#: ../plugins/fn-stat/functions.c:2086
msgid ""
"RSQ:square of the Pearson correlation coefficient of the paired set of data"
msgstr ""
"RSQ:Quadrat des Pearson-Korrelationskoeffizienten des gepaarten Datensatzes"

#: ../plugins/fn-stat/functions.c:2110
msgid "MEDIAN:median of a data set"
msgstr "MEDIAN:Median (oder Zentralwert) eines Datensatzes"

#: ../plugins/fn-stat/functions.c:2114
msgid ""
"If even numbers are given MEDIAN returns the average of the two numbers in "
"the center."
msgstr ""
"Falls gerade Zahlen angegeben werden, gibt MEDIAN den Mittelwert der zwei "
"mittleren Zahlen zurück."

#: ../plugins/fn-stat/functions.c:2118
msgid "Then MEDIAN(A1:A5) equals 21.3."
msgstr "Dann ist MEDIAN(A1:A5) gleich 21.3."

#: ../plugins/fn-stat/functions.c:2120
msgid "wiki:en:Median"
msgstr "wiki:de:Median"

#: ../plugins/fn-stat/functions.c:2121
msgid "wolfram:StatisticalMedian.html"
msgstr "wolfram:StatisticalMedian.html"

#: ../plugins/fn-stat/functions.c:2140
msgid "SSMEDIAN:median for grouped data"
msgstr "SSMEDIAN:Median eines Datensatzes"

#: ../plugins/fn-stat/functions.c:2141
msgid "array:data set"
msgstr "array:Datensatz"

#: ../plugins/fn-stat/functions.c:2142
msgid "interval:length of each grouping interval, defaults to 1"
msgstr ""
"interval:Länge eines jeden Gruppierungsintervalls. Voreinstellung ist 1"

#: ../plugins/fn-stat/functions.c:2143
msgid ""
"The data are assumed to be grouped into intervals of width @{interval}. Each "
"data point in @{array} is the midpoint of the interval containing the true "
"value. The median is calculated by interpolation within the median interval "
"(the interval containing the median value), assuming that the true values "
"within that interval are distributed uniformly:\n"
"median = L + @{interval}*(N/2 - CF)/F\n"
"where:\n"
"L = the lower limit of the median interval\n"
"N = the total number of data points\n"
"CF = the number of data points below the median interval\n"
"F = the number of data points in the median interval"
msgstr ""

#: ../plugins/fn-stat/functions.c:2154 ../plugins/fn-stat/functions.c:2827
#: ../plugins/fn-stat/functions.c:2869
msgid "If @{array} is empty, this function returns a #NUM! error."
msgstr ""
"Falls @{array} leer ist, gibt diese Funktion einen #ZAHL!-Fehler zurück."

#: ../plugins/fn-stat/functions.c:2155
msgid ""
"If @{interval} <= 0, this function returns a #NUM! error. SSMEDIAN does not "
"check whether the data points are at least @{interval} apart."
msgstr ""
"Wenn @{interval} <= 0 gibt diese Funktion den Fehler #ZAHL! zurück. SSMEDIAN "
"prüft nicht, ob die Datenpunkte mindestens @{interval} auseinander liegen."

#: ../plugins/fn-stat/functions.c:2242
msgid "LARGE:@{k}-th largest value in a data set"
msgstr "LARGE:@{k}.-größter Wert in einem Datensatz"

#: ../plugins/fn-stat/functions.c:2243 ../plugins/fn-stat/functions.c:2286
msgid "data:data set"
msgstr "data:Datensatz"

#: ../plugins/fn-stat/functions.c:2244 ../plugins/fn-stat/functions.c:2287
msgid "k:which value to find"
msgstr "k:Zu findender Wert"

#: ../plugins/fn-stat/functions.c:2245 ../plugins/fn-stat/functions.c:2288
msgid "If data set is empty this function returns a #NUM! error."
msgstr ""
"Falls der Datensatz leer ist, gibt diese Funktion einen #ZAHL!-Fehler zurück."

#: ../plugins/fn-stat/functions.c:2246 ../plugins/fn-stat/functions.c:2289
msgid ""
"If @{k} <= 0 or @{k} is greater than the number of data items given this "
"function returns a #NUM! error."
msgstr ""
"Falls @{k} <= 0 oder @{k} größer als die Anzahl der gegebenen Datenobjekte "
"ist, gibt diese Funktion einen #ZAHL!-Fehler zurück."

#: ../plugins/fn-stat/functions.c:2251
msgid "Then LARGE(A1:A5,2) equals 25.9.LARGE(A1:A5,4) equals 17.3."
msgstr "Dann ist LARGE(A1:A5,2) gleich 25.9. LARGE(A1:A5,4) ist gleich 17.3."

#: ../plugins/fn-stat/functions.c:2285
msgid "SMALL:@{k}-th smallest value in a data set"
msgstr "SMALL:@{k}.-kleinster Wert in einem Datensatz"

#: ../plugins/fn-stat/functions.c:2294
msgid "Then SMALL(A1:A5,2) equals 17.3.SMALL(A1:A5,4) equals 25.9."
msgstr "Dann ist SMALL(A1:A5,2) gleich 17.3. SMALL(A1:A5,4) ergibt 25.9."

#: ../plugins/fn-stat/functions.c:2329
msgid ""
"PROB:probability of an interval for a discrete (and finite) probability "
"distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:2330
msgid "x_range:possible values"
msgstr "x_range:Mögliche Werte"

#: ../plugins/fn-stat/functions.c:2331
msgid "prob_range:probabilities of the corresponding values"
msgstr "prob_range:Wahrscheinlichkeiten der korrespondierenden Werte"

#: ../plugins/fn-stat/functions.c:2332
msgid "lower_limit:lower interval limit"
msgstr "lower_limit:Untere Grenze des Intervalls"

#: ../plugins/fn-stat/functions.c:2333
msgid "upper_limit:upper interval limit, defaults to @{lower_limit}"
msgstr "upper_limit:Obere Grenze des Intervalls, Vorgabe ist @{lower_limit}"

#: ../plugins/fn-stat/functions.c:2334
msgid ""
"If the sum of the probabilities in @{prob_range} is not equal to 1 this "
"function returns a #NUM! error."
msgstr ""
"Wenn die Summe der Wahrscheinlichkeiten in @{prob_range} nicht gleich 1 "
"ist,  so gibt diese Funktion den Fehler #ZAHL! zurück."

#: ../plugins/fn-stat/functions.c:2336
msgid ""
"If any value in @{prob_range} is <=0 or > 1, this function returns a #NUM! "
"error."
msgstr ""
"Wenn irgendein Wert in @{prob_range} <=0 oder > 1 ist, so gibt diese "
"Funktion den Fehler #ZAHL! zurück."

#: ../plugins/fn-stat/functions.c:2338
msgid ""
"If @{x_range} and @{prob_range} contain a different number of data entries, "
"this function returns a #N/A error."
msgstr ""
"Falls @{x_range} und @{prob_range} eine unterschiedliche Zahl von "
"Dateneinträgen enthalten, gibt diese Funktion einen #N/A-Fehler zurück."

#: ../plugins/fn-stat/functions.c:2415
msgid "STEYX:standard error of the predicted y-value in the regression"
msgstr "STEYX:Standardfehler des vorausgesagten y-Werts in der Abschreibung"

#: ../plugins/fn-stat/functions.c:2416 ../plugins/fn-stat/functions.c:3524
#: ../plugins/fn-stat/functions.c:3640 ../plugins/fn-stat/functions.c:3882
#: ../plugins/fn-stat/functions.c:3980 ../plugins/fn-stat/functions.c:4070
#: ../plugins/fn-stat/functions.c:4129 ../plugins/fn-stat/functions.c:4181
msgid "known_ys:known y-values"
msgstr "known_ys:bekannte y-Werte"

#: ../plugins/fn-stat/functions.c:2417 ../plugins/fn-stat/functions.c:3641
#: ../plugins/fn-stat/functions.c:4071 ../plugins/fn-stat/functions.c:4130
#: ../plugins/fn-stat/functions.c:4182
msgid "known_xs:known x-values"
msgstr "known_xs:bekannte x-Werte"

#: ../plugins/fn-stat/functions.c:2418
msgid ""
"If @{known_ys} and @{known_xs} are empty or have a different number of "
"arguments then this function returns a #N/A error."
msgstr ""
"Falls @{known_ys} und @{known_xs} leer sind oder eine unterschiedliche "
"Anzahl von Argumenten haben, gibt diese Funktion einen #N/A-Fehler zurück."

#: ../plugins/fn-stat/functions.c:2424
msgid "Then STEYX(A1:A5,B1:B5) equals 1.101509979."
msgstr "Dann ist STEYX(A1:A5,B1:B5) gleich 1.101509979."

#: ../plugins/fn-stat/functions.c:2468
msgid ""
"ZTEST:the probability of observing a sample mean as large as or larger than "
"the mean of the given sample"
msgstr ""

#: ../plugins/fn-stat/functions.c:2470
msgid "ref:data set (sample)"
msgstr "ref:Datensatz (Beispiel)"

#: ../plugins/fn-stat/functions.c:2471
#, fuzzy
msgid "x:population mean"
msgstr "goldener Schnitt"

#: ../plugins/fn-stat/functions.c:2472
msgid ""
"stddev:population standard deviation, defaults to the sample standard "
"deviation"
msgstr ""

#: ../plugins/fn-stat/functions.c:2473
msgid ""
"ZTEST calulates the probability of observing a sample mean as large as or "
"larger than the mean of the given sample for samples drawn from a normal "
"distribution with mean @{x} and standard deviation @{stddev}."
msgstr ""

#: ../plugins/fn-stat/functions.c:2476
msgid ""
"If @{ref} contains less than two data items ZTEST returns #DIV/0! error."
msgstr ""
"Falls @{ref} weniger als zwei Datenobjekte enthält, gibt ZTEST einen #DIV/0!-"
"Fehler zurück."

#: ../plugins/fn-stat/functions.c:2482
msgid "Then ZTEST(A1:A5,20) equals 0.254717826."
msgstr "Dann ist ZTEST(A1:A5,20) gleich 0.254717826."

#: ../plugins/fn-stat/functions.c:2533
msgid "AVERAGEA:average of all the values and cells"
msgstr "AVERAGEA:Mittelwert aller Werte und Zellen"

#: ../plugins/fn-stat/functions.c:2538 ../plugins/fn-stat/functions.c:2563
#: ../plugins/fn-stat/functions.c:2590 ../plugins/fn-stat/functions.c:2622
#: ../plugins/fn-stat/functions.c:2649 ../plugins/fn-stat/functions.c:2679
#: ../plugins/fn-stat/functions.c:2706
msgid ""
"Let us assume that the cells A1, A2, ..., A5 contain numbers and strings "
"11.4, 17.3, \"missing\", 25.9, and 40.1."
msgstr ""
"Nehmen wir an, dass die Zellen A1, A2 ... A5 die Zahlen und Zeichenketten "
"11.4, 17.3, »missing«, 25.9 und 40.1 enthalten."

#: ../plugins/fn-stat/functions.c:2539
msgid "Then AVERAGEA(A1:A5) equals 18.94."
msgstr "Dann ist AVERAGEA(A1:A5) gleich 18.94."

#: ../plugins/fn-stat/functions.c:2558
msgid ""
"MAXA:largest value, with negative numbers considered smaller than positive "
"numbers"
msgstr ""
"MAXA:Größter Wert, wobei negative Zahlen als kleiner als positive Zahlen "
"angenommen werden."

#: ../plugins/fn-stat/functions.c:2565
msgid "Then MAXA(A1:A5) equals 40.1."
msgstr "Dann ist MAXA(A1:A5) gleich 40.1."

#: ../plugins/fn-stat/functions.c:2585
msgid ""
"MINA:smallest value, with negative numbers considered smaller than positive "
"numbers"
msgstr ""
"MINA:Kleinster Wert, wobei negative Zahlen als kleiner als positive Zahlen "
"angenommen werden."

#: ../plugins/fn-stat/functions.c:2592
msgid "Then MINA(A1:A5) equals 0."
msgstr "Dann ist MINA(A1:A5) gleich 0."

#: ../plugins/fn-stat/functions.c:2612
msgid "VARA:sample variance of the given sample"
msgstr ""

#: ../plugins/fn-stat/functions.c:2615
msgid "VARA is also known as the N-1-variance."
msgstr "VARA ist auch als die N-1-Varianz bekannt."

#: ../plugins/fn-stat/functions.c:2616
msgid "To get the true variance of a complete population use VARPA."
msgstr ""

#: ../plugins/fn-stat/functions.c:2624
msgid "Then VARA(A1:A5) equals 228.613."
msgstr "Dann ist VARA(A1:A5) gleich 228.613."

#: ../plugins/fn-stat/functions.c:2643
msgid "VARPA:variance of an entire population"
msgstr "VARPA:Varianz der gesamten Population"

#: ../plugins/fn-stat/functions.c:2646
msgid "VARPA is also known as the N-variance."
msgstr "VARPA ist auch als die N-Varianz bekannt."

#: ../plugins/fn-stat/functions.c:2651
msgid "Then VARPA(A1:A5) equals 182.8904."
msgstr "Dann ist VARPA(A1:A5) gleich 182.8904."

#: ../plugins/fn-stat/functions.c:2670
msgid "STDEVA:sample standard deviation of the given sample"
msgstr ""

#: ../plugins/fn-stat/functions.c:2674
msgid "STDEVA is also known as the N-1-standard deviation."
msgstr "STDEVA ist auch als die N-1-Standardabweichung bekannt."

#: ../plugins/fn-stat/functions.c:2675
msgid ""
"To obtain the population standard deviation of a whole population use "
"STDEVPA."
msgstr ""

#: ../plugins/fn-stat/functions.c:2681
msgid "Then STDEVA(A1:A5) equals 15.119953704."
msgstr "Dann ist STDEVA(A1:A5) gleich 15.119953704."

#: ../plugins/fn-stat/functions.c:2700
msgid "STDEVPA:population standard deviation of an entire population"
msgstr ""

#: ../plugins/fn-stat/functions.c:2708
msgid "Then STDEVPA(A1:A5) equals 13.523697719."
msgstr "Dann ist STDEVPA(A1:A5) gleich 13.523697719."

#: ../plugins/fn-stat/functions.c:2727
msgid "PERCENTRANK:rank of a data point in a data set"
msgstr ""

#: ../plugins/fn-stat/functions.c:2728
msgid "array:range of numeric values"
msgstr "array:Bereich numerischer Werte"

#: ../plugins/fn-stat/functions.c:2729
msgid "x:data point to be ranked"
msgstr ""

#: ../plugins/fn-stat/functions.c:2730
msgid "significance:number of significant digits, defaults to 3"
msgstr "significance:Anzahl der signifikanten Ziffern. Voreinstellung ist 3"

#: ../plugins/fn-stat/functions.c:2731
msgid ""
"If @{array} contains no data points, this function returns a #NUM! error."
msgstr ""
"Falls @{array} keine Datenpunkte enthält, gibt diese Funktion einen #ZAHL!-"
"Fehler zurück."

#: ../plugins/fn-stat/functions.c:2733
msgid ""
"If @{significance} is less than one, this function returns a #NUM! error."
msgstr ""
"Falls @{significance} kleiner als 1 ist, gibt diese Funktion einen #ZAHL!-"
"Fehler zurück."

#: ../plugins/fn-stat/functions.c:2735
msgid ""
"If @{x} exceeds the largest value or is less than the smallest value in @"
"{array}, this function returns a #NUM! error."
msgstr ""
"Falls @{x} den größten Wert übersteigt oder kleiner als der kleinste Wert in "
"@{array} ist, gibt diese Funktion einen #ZAHL!-Fehler zurück."

#: ../plugins/fn-stat/functions.c:2737
msgid ""
"If @{x} does not match any of the values in @{array} or @{x} matches more "
"than once, this function interpolates the returned value."
msgstr ""
"Falls @{x} mit keinem der Werte in @{array} übereinstimmt oder @{x} mit mehr "
"als einem Wert übereinstimmt, dann interpoliert die Funktion den "
"zurückgegebenen Wert."

#: ../plugins/fn-stat/functions.c:2824
msgid ""
"PERCENTILE:determines the  100*@{k}-th percentile of the given data points"
msgstr "PERCENTILE:Gibt das 100*@{k}. Perzentil der gegebenen Datenpunkte an"

#: ../plugins/fn-stat/functions.c:2825 ../plugins/fn-stat/functions.c:2867
msgid "array:data points"
msgstr "array:Datenpunkte"

#: ../plugins/fn-stat/functions.c:2826
msgid "k:which percentile to calculate"
msgstr "k:Zu berechnendes Perzentil"

#: ../plugins/fn-stat/functions.c:2828
msgid "If @{k} < 0 or @{k} > 1, this function returns a #NUM! error."
msgstr ""
"Falls @{k} < 0 oder @{k} > 1, gibt diese Funktion einen #ZAHL!-Fehler zurück."

#: ../plugins/fn-stat/functions.c:2831
msgid "Then PERCENTILE(A1:A5,0.42) equals 20.02."
msgstr "Dann ist PERCENTILE(A1:A5,0.42) gleich 20.02."

#: ../plugins/fn-stat/functions.c:2866
msgid "QUARTILE:the @{k}-th quartile of the data points"
msgstr "QUARTILE:the @{k}-tes Quartil der Datenpunkte"

#: ../plugins/fn-stat/functions.c:2868
msgid "quart:a number from 0 to 4, indicating which quartile to calculate"
msgstr ""
"quart:Eine Zahl von 0 bis 4, welche angibt, welches Quartil berechnet werden "
"soll"

#: ../plugins/fn-stat/functions.c:2870
msgid ""
"If @{quart} < 0 or @{quart} > 4, this function returns a #NUM! error. If @"
"{quart} = 0, the smallest value of @{array} to be returned."
msgstr ""
"Falls @{quart} < 0 oder @{quart} > 4, gibt diese Funktion einen #ZAHL!-"
"Fehler zurück. Falls @{quart} = 0, wird der kleinste Wert von @{array} "
"zurückgegeben."

#: ../plugins/fn-stat/functions.c:2871
msgid "If @{quart} is not an integer, it is truncated."
msgstr "Falls @{quart} keine Ganzzahl ist, wird es abgeschnitten."

#: ../plugins/fn-stat/functions.c:2874
msgid "Then QUARTILE(A1:A5,1) equals 17.3."
msgstr "Dann ist QUARTILE(A1:A5,1) gleich 17.3."

#: ../plugins/fn-stat/functions.c:2909
msgid ""
"FTEST:p-value for the two-tailed hypothesis test comparing the variances of "
"two populations"
msgstr ""

#: ../plugins/fn-stat/functions.c:2911 ../plugins/fn-stat/functions.c:2968
msgid "array1:sample from the first population"
msgstr "array1:Stichprobe der ersten Population"

#: ../plugins/fn-stat/functions.c:2912 ../plugins/fn-stat/functions.c:2969
msgid "array2:sample from the second population"
msgstr "array2:Stichprobe der zweiten Population"

#: ../plugins/fn-stat/functions.c:2917
msgid "Then FTEST(A1:A5,B1:B5) equals 0.510815017."
msgstr "Dann ist FTEST(A1:A5,B1:B5) gleich 0.510815017."

#: ../plugins/fn-stat/functions.c:2966
msgid ""
"TTEST:p-value for a hypothesis test comparing the means of two populations "
"using the Student t-distribution"
msgstr ""

#: ../plugins/fn-stat/functions.c:2970
msgid "tails:number of tails to consider"
msgstr ""

#: ../plugins/fn-stat/functions.c:2971
msgid ""
"type:Type of test to perform. 1 indicates a test for paired variables, 2 a "
"test of unpaired variables with equal variances, and 3 a test of unpaired "
"variables with unequal variances"
msgstr ""

#: ../plugins/fn-stat/functions.c:2974
msgid ""
"If the data sets contain a different number of data points and the test is "
"paired (@{type} one), TTEST returns the #N/A error."
msgstr ""

#: ../plugins/fn-stat/functions.c:2976
msgid "@{tails} and @{type} are truncated to integers."
msgstr "@{tails} und @{type} werden auf Ganzzahlen abgerundet."

#: ../plugins/fn-stat/functions.c:2977
msgid "If @{tails} is not one or two, this function returns a #NUM! error."
msgstr ""
"Falls @{tails} nicht 1 oder zwei ist, gibt diese Funktion einen #ZAHL!-"
"Fehler zurück."

#: ../plugins/fn-stat/functions.c:2978
msgid ""
"If @{type} is any other than one, two, or three, this function returns a "
"#NUM! error."
msgstr ""
"Falls @{type} nicht 1, 2 oder 3 ist, gibt diese Funktion einen #ZAHL!-Fehler "
"zurück."

#: ../plugins/fn-stat/functions.c:2983
msgid ""
"Then TTEST(A1:A5,B1:B5,1,1) equals 0.003127619.TTEST(A1:A5,B1:B5,2,1) equals "
"0.006255239.TTEST(A1:A5,B1:B5,1,2) equals 0.111804322.TTEST(A1:A5,B1:B5,1,3) "
"equals 0.113821797."
msgstr ""
"Dann ist TTEST(A1:A5,B1:B5,1,1) gleich 0.003127619. TTEST(A1:A5,B1:B5,2,1) "
"ist gleich 0.006255239. TTEST(A1:A5,B1:B5,1,2) ist gleich 0.111804322. TTEST"
"(A1:A5,B1:B5,1,3) ist gleich 0.113821797."

#: ../plugins/fn-stat/functions.c:3141
msgid "FREQUENCY:frequency table"
msgstr "FREQUENCY:Die Häufigkeitstabelle"

#: ../plugins/fn-stat/functions.c:3142
msgid "data_array:data values"
msgstr "data_array:Datenwerte"

#: ../plugins/fn-stat/functions.c:3143
msgid "bins_array:array of cutoff values"
msgstr ""

#: ../plugins/fn-stat/functions.c:3144
msgid "The results are given as an array."
msgstr "Die Ergebnisse werden als Feld angegeben."

#: ../plugins/fn-stat/functions.c:3145
msgid ""
"If the @{bins_array} is empty, this function returns the number of data "
"points in @{data_array}."
msgstr ""
"Falls @{bin_array} leer ist, gibt diese Funktion die Anzahl der Datenpunkte "
"in @{data_array} zurück."

#: ../plugins/fn-stat/functions.c:3209
msgid "LEVERAGE:calculate regression leverage"
msgstr ""

#: ../plugins/fn-stat/functions.c:3212
#, fuzzy
#| msgid ""
#| "Returns the diagonal of @{A} (@{A}^T @{A})^-1 @{A}T as a column vector."
msgid ""
"Returns the diagonal of @{A} (@{A}^T @{A})^-1 @{A}^T as a column vector."
msgstr ""
"Gibt die Diagonale von @{A} (@{A}^T @{A})^-1 @{A}T als Spaltenvektor zurück."

#: ../plugins/fn-stat/functions.c:3213
msgid "If the matrix is singular, #VALUE! is returned."
msgstr "Falls die Matrix singulär ist, wird #WERT! zurückgegeben."

#: ../plugins/fn-stat/functions.c:3417
msgid "LINEST:multiple linear regression coefficients and statistics"
msgstr "LINEST:Mehrere lineare Abschreibungskoeffizienten und Statistiken"

#: ../plugins/fn-stat/functions.c:3418 ../plugins/fn-stat/functions.c:3735
msgid "known_ys:vector of values of dependent variable"
msgstr "known_ys:Vektor der Werte der abhängigen Variable"

#: ../plugins/fn-stat/functions.c:3419 ../plugins/fn-stat/functions.c:3736
msgid ""
"known_xs:array of values of independent variables, defaults to a single "
"vector {1,…,n}"
msgstr ""
"known_xs:Feld von Werten von unabhängigen Variablen. Vorgabe ist ein "
"einzelner Vektor {1,…,n}"

#: ../plugins/fn-stat/functions.c:3420 ../plugins/fn-stat/functions.c:3526
#: ../plugins/fn-stat/functions.c:3738 ../plugins/fn-stat/functions.c:3884
#: ../plugins/fn-stat/functions.c:3983
msgid "affine:if true, the model contains a constant term, defaults to true"
msgstr ""

#: ../plugins/fn-stat/functions.c:3421
msgid ""
"stats:if true, some additional statistics are provided, defaults to false"
msgstr ""
"stats:falls wahr werden einige zusätzliche Statistiken geliefert. Vorgabe "
"ist »falsch«"

#: ../plugins/fn-stat/functions.c:3422
msgid ""
"This function returns an array with the first row giving the regression "
"coefficients for the independent variables x_m, x_(m-1),…,x_2, x_1 followed "
"by the y-intercept if @{affine} is true."
msgstr ""

#: ../plugins/fn-stat/functions.c:3425
msgid ""
"If @{stats} is true, the second row contains the corresponding standard "
"errors of the regression coefficients.In this case, the third row contains "
"the R^2 value and the standard error for the predicted value. The fourth row "
"contains the observed F value and its degrees of freedom. Finally, the fifth "
"row contains the regression sum of squares and the residual sum of squares."
msgstr ""

#: ../plugins/fn-stat/functions.c:3432
msgid ""
"If @{affine} is false, R^2 is the uncentered version of the coefficient of "
"determination; that is the proportion of the sum of squares explained by the "
"model."
msgstr ""

#: ../plugins/fn-stat/functions.c:3435 ../plugins/fn-stat/functions.c:3739
msgid ""
"If the length of @{known_ys} does not match the corresponding length of @"
"{known_xs}, this function returns a #NUM! error."
msgstr ""
"Falls die Länge von @{known_ys} nicht mit der korrespondierenden Länge von @"
"{known_xs} übereinstimmt, gibt diese Funktion einen #ZAHL!-Fehler zurück."

#: ../plugins/fn-stat/functions.c:3523
msgid "LOGREG:the logarithmic regression"
msgstr "LOGREG:die logarithmische Regression"

#: ../plugins/fn-stat/functions.c:3525 ../plugins/fn-stat/functions.c:3981
msgid "known_xs:known x-values; defaults to the array {1, 2, 3, …}"
msgstr "known_xs:Bekannte x-Werte; Vorgabe ist das Array {1, 2, 3, …}"

#: ../plugins/fn-stat/functions.c:3527 ../plugins/fn-stat/functions.c:3885
msgid ""
"stat:if true, extra statistical information will be returned; defaults to "
"FALSE"
msgstr ""
"stat:Falls wahr, werden zusätzliche statistische Informationen "
"zurückgegeben; Vorgabe ist FALSCH"

#: ../plugins/fn-stat/functions.c:3528
msgid ""
"LOGREG function transforms your x's to z=ln(x) and applies the “least "
"squares” method to fit the linear equation y = m * z + b to your y's and z's "
"--- equivalent to fitting the equation y = m * ln(x) + b to y's and x's. "
"LOGREG returns an array having two columns and one row. m is given in the "
"first column and b in the second. "
msgstr ""

#: ../plugins/fn-stat/functions.c:3536
msgid ""
"Any extra statistical information is written below m and b in the result "
"array.  This extra statistical information consists of four rows of data:  "
"In the first row the standard error values for the coefficients m, b are "
"given.  The second row contains the square of R and the standard error for "
"the y estimate. The third row contains the F-observed value and the degrees "
"of freedom.  The last row contains the regression sum of squares and the "
"residual sum of squares.The default of @{stat} is FALSE."
msgstr ""

#: ../plugins/fn-stat/functions.c:3545 ../plugins/fn-stat/functions.c:3900
#: ../plugins/fn-stat/functions.c:3991
msgid ""
"If @{known_ys} and @{known_xs} have unequal number of data points, this "
"function returns a #NUM! error."
msgstr ""
"Falls @{known_ys} und @{known_xs} eine unterschiedliche Anzahl von "
"Datenpunkten haben, gibt diese Funktion einen #N/A-Fehler zurück."

#: ../plugins/fn-stat/functions.c:3639
msgid "LOGFIT:logarithmic least square fit (using a trial and error method)"
msgstr ""

#: ../plugins/fn-stat/functions.c:3643
msgid ""
"LOGFIT function applies the “least squares” method to fit the logarithmic "
"equation y = a + b * ln(sign * (x - c)) ,   sign = +1 or -1 to your data. "
"The graph of the equation is a logarithmic curve moved horizontally by c and "
"possibly mirrored across the y-axis (if sign = -1)."
msgstr ""

#: ../plugins/fn-stat/functions.c:3649
msgid ""
"LOGFIT returns an array having five columns and one row. `Sign' is given in "
"the first column, `a', `b', and `c' are given in columns 2 to 4. Column 5 "
"holds the sum of squared residuals."
msgstr ""

#: ../plugins/fn-stat/functions.c:3653
msgid ""
"An error is returned when there are less than 3 different x's or y's, or "
"when the shape of the point cloud is too different from a ``logarithmic'' "
"one."
msgstr ""

#: ../plugins/fn-stat/functions.c:3656
msgid ""
"You can use the above formula = a + b * ln(sign * (x - c)) or rearrange it "
"to = (exp((y - a) / b)) / sign + c to compute unknown y's or x's, "
"respectively. "
msgstr ""
"Sie können die obige Formel verwenden = a + b * ln(sign * (x - c)) oder sie "
"umformen zu = (exp((y - a) / b)) / sign + c , um die unbekannten y bzw. x zu "
"berechnen."

#: ../plugins/fn-stat/functions.c:3661
msgid ""
"This is non-linear fitting by trial-and-error. The accuracy of `c' is: width "
"of x-range -> rounded to the next smaller (10^integer), times 0.000001. "
"There might be cases in which the returned fit is not the best possible."
msgstr ""

#: ../plugins/fn-stat/functions.c:3734
msgid ""
"TREND:estimates future values of a given data set using a least squares "
"approximation"
msgstr ""

#: ../plugins/fn-stat/functions.c:3737
msgid ""
"new_xs:array of x-values for which to estimate the y-values; defaults to @"
"{known_xs}"
msgstr ""
"new_xs: Feld von x-Werten, deren y-Werte geschätzt werden sollen; Vorgabe "
"ist @{known_xs}"

#: ../plugins/fn-stat/functions.c:3741
msgid ""
"Let us assume that the cells A1, A2, …, A5 contain numbers 11.4, 17.3, 21.3, "
"25.9, and 40.1, and the cells B1, B2, ... B5 23.2, 25.8, 29.9, 33.5, and "
"42.7."
msgstr ""
"Angenommen, die Zellen  A1, A2 … A5 enthalten die Zahlen 11.4, 17.3, 21.3, "
"25.9, and 40.1, and the cells B1, B2, ... B5 23.2, 25.8, 29.9, 33.5, and "
"42.7."

#: ../plugins/fn-stat/functions.c:3744
msgid "Then TREND(A1:A5,B1:B5) equals {12.1, 15.7, 21.6, 26.7, 39.7}."
msgstr "Dann ist TREND(A1:A5,B1:B5) gleich {12.1, 15.7, 21.6, 26.7, 39.7}."

#: ../plugins/fn-stat/functions.c:3881
msgid "LOGEST:exponential least square fit"
msgstr ""

#: ../plugins/fn-stat/functions.c:3883
msgid "known_xs:known x-values; default to an array {1, 2, 3, …}"
msgstr "known_xs:Bekannte x-Werte; Vorgabe ist ein Array {1, 2, 3, …}"

#: ../plugins/fn-stat/functions.c:3886
msgid ""
"LOGEST function applies the “least squares” method to fit an exponential "
"curve of the form\ty = b * m{1}^x{1} * m{2}^x{2}... to your data."
msgstr ""

#: ../plugins/fn-stat/functions.c:3890
msgid "LOGEST returns an array { m{n},m{n-1}, ...,m{1},b }."
msgstr "LOGEST gibt ein Feld { m{n},m{n-1}, ...,m{1},b } zurück."

#: ../plugins/fn-stat/functions.c:3891
msgid ""
"Extra statistical information is written below the regression line "
"coefficients in the result array.  Extra statistical information consists of "
"four rows of data.  In the first row the standard error values for the "
"coefficients m1, (m2, ...), b are represented.  The second row contains the "
"square of R and the standard error for the y estimate.  The third row "
"contains the F-observed value and the degrees of freedom.  The last row "
"contains the regression sum of squares and the residual sum of squares."
msgstr ""

#: ../plugins/fn-stat/functions.c:3979
msgid "GROWTH:exponential growth prediction"
msgstr "GROWTH:exponenzielle Wachstumsvoraussage"

#: ../plugins/fn-stat/functions.c:3982
msgid ""
"new_xs:x-values for which to estimate the y-values; defaults to @{known_xs}"
msgstr ""
"new_xs:x--Werte als Grundlage zur Schätzung der y-Werte; Vorgabe ist @"
"{known_xs}"

#: ../plugins/fn-stat/functions.c:3984
msgid ""
"GROWTH function applies the “least squares” method to fit an exponential "
"curve to your data and predicts the exponential growth by using this curve."
msgstr ""

#: ../plugins/fn-stat/functions.c:3989
msgid ""
"GROWTH returns an array having one column and a row for each data point in @"
"{new_xs}."
msgstr ""

#: ../plugins/fn-stat/functions.c:4067
msgid ""
"FORECAST:estimates a future value according to existing values using simple "
"linear regression"
msgstr ""
"FORECAST:Schätzt einen Zukunftswert anhand der vorhandenen Werte mittels "
"linearer Regression"

#: ../plugins/fn-stat/functions.c:4069
msgid "x:x-value whose matching y-value should be forecast"
msgstr "x:x-Wert, dessen y-Wert vorausgesagt werden soll"

#: ../plugins/fn-stat/functions.c:4072
msgid ""
"This function estimates a future value according to existing values using "
"simple linear regression."
msgstr ""
"Diese Funktion schätzt einen Zukunftswert anhand der vorhandenen Werte "
"mittels linearer Abschreibung."

#: ../plugins/fn-stat/functions.c:4074 ../plugins/fn-stat/functions.c:4131
#: ../plugins/fn-stat/functions.c:4184
msgid ""
"If @{known_xs} or @{known_ys} contains no data entries or different number "
"of data entries, this function returns a #N/A error."
msgstr ""
"Falls @{known_xs} und @{known_ys} keine oder eine unterschiedliche Anzahl "
"von Dateneinträgen haben, gibt diese Funktion einen #N/A-Fehler zurück."

#: ../plugins/fn-stat/functions.c:4076
msgid ""
"If the variance of the @{known_xs} is zero, this function returns a #DIV/0 "
"error."
msgstr ""
"Falls die Varianz von @{known_xs} Null ist, gibt diese Funktion einen #DIV/0-"
"Fehler zurück."

#: ../plugins/fn-stat/functions.c:4082
msgid "Then FORECAST(7,A1:A5,B1:B5) equals -10.859397661."
msgstr "Dann ist FORECAST(7,A1:A5,B1:B5) gleich -10.859397661."

#: ../plugins/fn-stat/functions.c:4128
#, fuzzy
msgid "INTERCEPT:the intercept of a linear regression line"
msgstr "SLOPE:Die Neigung einer linearen Regressionskurve"

#: ../plugins/fn-stat/functions.c:4133 ../plugins/fn-stat/functions.c:4186
msgid ""
"If the variance of the @{known_xs} is zero, this function returns #DIV/0 "
"error."
msgstr ""
"Falls die Varianz von @{known_xs} Null ist, gibt diese Funktion einen #DIV/0-"
"Fehler zurück."

#: ../plugins/fn-stat/functions.c:4139
msgid "Then INTERCEPT(A1:A5,B1:B5) equals -20.785117212."
msgstr "Dann ist INTERCEPT(A1:A5,B1:B5) gleich -20.785117212."

#: ../plugins/fn-stat/functions.c:4180
msgid "SLOPE:the slope of a linear regression line"
msgstr "SLOPE:Die Neigung einer linearen Regressionskurve"

#: ../plugins/fn-stat/functions.c:4191
msgid "Then SLOPE(A1:A5,B1:B5) equals 1.417959936."
msgstr "Dann ist SLOPE(A1:A5,B1:B5) gleich 1.417959936."

#: ../plugins/fn-stat/functions.c:4232
msgid "SUBTOTAL:the subtotal of the given list of arguments"
msgstr "SUBTOTAL:die Zwischensumme der gegebenen Argumentenliste"

#: ../plugins/fn-stat/functions.c:4233
msgid ""
"function_nbr:determines which function to use according to the following "
"table:\n"
"\t1   AVERAGE\n"
"\t2   COUNT\n"
"\t3   COUNTA\n"
"\t4   MAX\n"
"\t5   MIN\n"
"\t6   PRODUCT\n"
"\t7   STDEV\n"
"\t8   STDEVP\n"
"\t9   SUM\n"
"\t10   VAR\n"
"\t11   VARP"
msgstr ""
"function_nbr:Legt fest, welche Funktion anhand der folgenden Tabelle "
"verwendet werden soll:\n"
"\t1   AVERAGE\n"
"\t2   COUNT\n"
"\t3   COUNTA\n"
"\t4   MAX\n"
"\t5   MIN\n"
"\t6   PRODUCT\n"
"\t7   STDEV\n"
"\t8   STDEVP\n"
"\t9   SUM\n"
"\t10   VAR\n"
"\t11   VARP"

#: ../plugins/fn-stat/functions.c:4246
msgid "ref1:first value"
msgstr "ref1:erster Wert"

#: ../plugins/fn-stat/functions.c:4247
msgid "ref2:second value"
msgstr "ref2:zweiter Wert"

#: ../plugins/fn-stat/functions.c:4249
msgid ""
"Let us assume that the cells A1, A2, ..., A5 contain numbers 23, 27, 28, 33, "
"and 39."
msgstr ""
"Nehmen wir an, die Zellen A1, A2, ... A5 enthalten die Zahlen 23, 27, 28, 33 "
"und 39."

#: ../plugins/fn-stat/functions.c:4250
msgid ""
"Then SUBTOTAL(1,A1:A5) equals 30.SUBTOTAL(6,A1:A5) equals 22378356.SUBTOTAL"
"(7,A1:A5) equals 6.164414003.SUBTOTAL(9,A1:A5) equals 150.SUBTOTAL(11,A1:A5) "
"equals 30.4."
msgstr ""
"Dann entspricht SUBTOTAL(1,A1:A5) genau 30. SUBTOTAL(6,A1:A5) entspricht "
"22378356. SUBTOTAL(7,A1:A5) entspricht 6,164414003. SUBTOTAL(9,A1:A5) "
"entspricht 150. SUBTOTAL(11,A1:A5) entspricht 30,44."

#: ../plugins/fn-stat/functions.c:4322
msgid "CRONBACH:Cronbach's alpha"
msgstr "CRONBACH:Cronbachs Alpha"

#: ../plugins/fn-stat/functions.c:4323
msgid "ref1:first data set"
msgstr "ref1:erster Datensatz"

#: ../plugins/fn-stat/functions.c:4324
msgid "ref2:second data set"
msgstr "ref2:zweiter Datensatz"

#: ../plugins/fn-stat/functions.c:4435
msgid ""
"GEOMDIST:probability mass or cumulative distribution function of the "
"geometric distribution"
msgstr ""
"GEOMDIST:Wahrscheinlichkeitsfunktion oder kumulative Verteilungsfunktion der "
"geometrischen Verteilung"

#: ../plugins/fn-stat/functions.c:4436
msgid "k:number of trials"
msgstr "k:Anzahl der Versuche"

#: ../plugins/fn-stat/functions.c:4437
msgid "p:probability of success in any trial"
msgstr "p:Wahrscheinlichkeit des Erfolgs in jedem Versuch"

#: ../plugins/fn-stat/functions.c:4439
msgid "If @{k} < 0 this function returns a #NUM! error."
msgstr "Falls @{k} < 0 ist, gibt diese Funktion einen #NUM!-Fehler zurück."

#: ../plugins/fn-stat/functions.c:4466
msgid "LOGISTIC:probability density function of the logistic distribution"
msgstr "LOGISTIC:Wahrscheinlichkeitsdichtefunktion der logistischen Verteilung"

#: ../plugins/fn-stat/functions.c:4497
msgid "PARETO:probability density function of the Pareto distribution"
msgstr "PARETO:Wahrscheinlichkeitsdichtefunktion der Pareto-Verteilung"

#: ../plugins/fn-stat/functions.c:4499
msgid "a:exponent"
msgstr "a:Exponent"

#: ../plugins/fn-stat/functions.c:4500 ../plugins/fn-stat/functions.c:4608
msgid "b:scale parameter"
msgstr "b:Skalierungsparameter"

#: ../plugins/fn-stat/functions.c:4531
msgid "RAYLEIGH:probability density function of the Rayleigh distribution"
msgstr "RAYLEIGH:Wahrscheinlichkeitsdichtefunktion der Rayleigh-Verteilung"

#: ../plugins/fn-stat/functions.c:4533 ../plugins/fn-stat/functions.c:4569
msgid "sigma:scale parameter"
msgstr "sigma:Skalierungsparameter"

#: ../plugins/fn-stat/functions.c:4566
#, fuzzy
msgid ""
"RAYLEIGHTAIL:probability density function of the Rayleigh tail distribution"
msgstr "RAYLEIGHTAIL:Wahrscheinlichkeitsdichtefunktion der ?verteilung"

#: ../plugins/fn-stat/functions.c:4568
msgid "a:lower limit"
msgstr "a:unterer Grenzwert"

#: ../plugins/fn-stat/functions.c:4604
msgid ""
"EXPPOWDIST:the probability density function of the Exponential Power "
"distribution"
msgstr ""
"EXPPOWDIS: die Wahrscheinlichkeitsdichtefunktion der exponentiellen "
"Energieverteilung"

#: ../plugins/fn-stat/functions.c:4610
msgid ""
"This distribution has been recommended for lifetime analysis when a U-shaped "
"hazard function is desired. This corresponds to rapid failure once the "
"product starts to wear out after a period of steady or even improving "
"reliability."
msgstr ""

#: ../plugins/fn-stat/functions.c:4638
msgid "LAPLACE:probability density function of the Laplace distribution"
msgstr "LAPLACE:Wahrscheinlichkeitsdichtefunktion der Laplace-Verteilung"

#: ../plugins/fn-stat/functions.c:4640
msgid "a:mean"
msgstr "a:Erwartungswert"

#: ../plugins/fn-stat/functions.c:4661
msgid ""
"PERMUTATIONA:the number of permutations of @{y} objects chosen from @{x} "
"objects with repetition allowed"
msgstr ""
"PERMUTATIONA:Die Anzahl der Permutationen von @{y} Objekten aus @{x} "
"Objekten, wobei Wiederholungen erlaubt sind."

#: ../plugins/fn-stat/functions.c:4662
msgid "x:total number of objects"
msgstr "x:gesamte Anzahl der Objekte"

#: ../plugins/fn-stat/functions.c:4663
msgid "y:number of selected objects"
msgstr "y:Anzahl der ausgewählten Objekte"

#: ../plugins/fn-stat/functions.c:4664
msgid "If both @{x} and @{y} equal 0, PERMUTATIONA returns 1."
msgstr ""
"Falls sowohl @{x} als auch @{y} gleich 0 sind, gibt PERMUTATIONA den Wert 1 "
"zurück."

#: ../plugins/fn-stat/functions.c:4665
msgid "If @{x} < 0 or @{y} < 0, PERMUTATIONA returns #NUM!"
msgstr "Falls @{x} < 0 oder @{y} < 0, gibt PERMUTATIONA #ZAHL! zurück."

#: ../plugins/fn-stat/functions.c:4666
msgid "If @{x} or @{y} are not integers, they are truncated"
msgstr "Falls @{x} oder @{y} keine Ganzzahlen sind, werden sie abgeschnitten"

#: ../plugins/fn-stat/functions.c:4694
msgid "LKSTEST:Lilliefors (Kolmogorov-Smirnov) Test of Normality"
msgstr "LKSTEST:Kolmogorow-Smirnow-Lilliefors-Anpassungstest"

#: ../plugins/fn-stat/functions.c:4695 ../plugins/fn-stat/functions.c:4812
#: ../plugins/fn-stat/functions.c:4896 ../plugins/fn-stat/functions.c:4981
msgid "x:array of sample values"
msgstr "x:Feld aus Beispielwerten"

#: ../plugins/fn-stat/functions.c:4696
msgid ""
"This function returns an array with the first row giving the p-value of the "
"Lilliefors (Kolmogorov-Smirnov) Test, the second row the test statistic of "
"the test, and the third the number of observations in the sample."
msgstr ""

#: ../plugins/fn-stat/functions.c:4698
msgid "If there are less than 5 sample values, LKSTEST returns #VALUE!"
msgstr ""
"Falls es weniger als 5 Beispielwerte gibt, dann gibt LKSTEST #WERT! zurück."

#: ../plugins/fn-stat/functions.c:4700
msgid "wiki:en:Lilliefors_test"
msgstr "wiki:de:Lilliefors-Test"

#: ../plugins/fn-stat/functions.c:4811
msgid "SFTEST:Shapiro-Francia Test of Normality"
msgstr "SFTEST:Shapiro-Francia-Normalitätstest"

#: ../plugins/fn-stat/functions.c:4813
msgid ""
"This function returns an array with the first row giving the p-value of the "
"Shapiro-Francia Test, the second row the test statistic of the test, and the "
"third the number of observations in the sample."
msgstr ""

#: ../plugins/fn-stat/functions.c:4815
msgid ""
"If there are less than 5 or more than 5000 sample values, SFTEST returns "
"#VALUE!"
msgstr ""
"Falls es weniger als 5 oder mehr als 5000 Beispielwerte gibt, gibt SFTEST "
"#WERT! zurück."

#: ../plugins/fn-stat/functions.c:4895
msgid "CVMTEST:Cramér-von Mises Test of Normality"
msgstr "CVMTEST: Cramér-von-Mises-Normalitätstest"

#: ../plugins/fn-stat/functions.c:4897
msgid ""
"This function returns an array with the first row giving the p-value of the "
"Cramér-von Mises Test, the second row the test statistic of the test, and "
"the third the number of observations in the sample."
msgstr ""

#: ../plugins/fn-stat/functions.c:4899
msgid "If there are less than 8 sample values, CVMTEST returns #VALUE!"
msgstr "Falls es weniger als 8 Beispielwerte gibt, gibt CVMTEST #WERT! zurück."

#: ../plugins/fn-stat/functions.c:4901
msgid "wiki:en:Cramér–von-Mises_criterion"
msgstr "wiki:de:Cramér-von-Mises-Test"

#: ../plugins/fn-stat/functions.c:4980
msgid "ADTEST:Anderson-Darling Test of Normality"
msgstr "ADTEST:Anderson-Darling-Anpassungstest"

#: ../plugins/fn-stat/functions.c:4982
msgid ""
"This function returns an array with the first row giving the p-value of the "
"Anderson-Darling Test, the second row the test statistic of the test, and "
"the third the number of observations in the sample."
msgstr ""

#: ../plugins/fn-stat/functions.c:4984
msgid "If there are less than 8 sample values, ADTEST returns #VALUE!"
msgstr "Falls es weniger als 8 Beispielwerte gibt, gibt ADTEST #WERT! zurück."

#: ../plugins/fn-stat/functions.c:4986
msgid "wiki:en:Anderson–Darling_test"
msgstr "wiki:de:Anderson–Darling-Test"

#: ../plugins/fn-string/functions.c:56
msgid "CHAR:the CP1252 (Windows-1252) character for the code point @{x}"
msgstr "CHAR:Das CP1252- (Windows-1252)-Zeichen für die Zeichennummer @{x}."

#: ../plugins/fn-string/functions.c:57
msgid "x:code point"
msgstr "x:Zeichennummer"

#: ../plugins/fn-string/functions.c:58
msgid "CHAR(@{x}) returns the CP1252 (Windows-1252) character with code @{x}."
msgstr ""
"CHAR(@{x}) gibt das CP1252-Zeichen (Windows-1252) mit Code @{x} zurück."

#: ../plugins/fn-string/functions.c:59
msgid "@{x} must be in the range 1 to 255."
msgstr "@{x} muss im Bereich zwischen 1 und 255 liegen."

#: ../plugins/fn-string/functions.c:60 ../plugins/fn-string/functions.c:136
msgid ""
"CP1252 (Windows-1252) is also known as the \"ANSI code page\", but it is not "
"an ANSI standard."
msgstr ""
"CP1252 (Windows-1252) ist auch bekannt unter dem Namen »ANSI code page«, ist "
"aber kein ANSI-Standard."

#: ../plugins/fn-string/functions.c:62
msgid ""
"CP1252 (Windows-1252) is based on an early draft of ISO-8859-1, and contains "
"all of its printable characters. It also contains all of ISO-8859-15's "
"printable characters (but partially at different positions.)"
msgstr ""
"CP1252 (Windows-1252) basiert auf einem frühen Entwurf von ISO-8859-1 und "
"enthält all deren darstellbare Zeichen. Sie enthält außerdem alle "
"darstellbaren Zeichen aus ISO-8859-15 (aber teilweise an anderen Stellen.)"

#: ../plugins/fn-string/functions.c:66 ../plugins/fn-string/functions.c:138
msgid ""
"In CP1252 (Windows-1252), 129, 141, 143, 144, and 157 do not have matching "
"characters."
msgstr ""
"In CP1252 (Windows-1252) haben 129, 141, 143, 144 und 157 keine "
"übereinstimmenden Zeichen."

#: ../plugins/fn-string/functions.c:67 ../plugins/fn-string/functions.c:139
msgid ""
"For @{x} from 1 to 255 except 129, 141, 143, 144, and 157 we have CODE(CHAR(@"
"{x}))=@{x}."
msgstr ""
"Für @{x} von 1 bis 255 außer 129, 141, 143, 144 und 157 ist CODE(CHAR(@{x}))"
"=@{x}."

#: ../plugins/fn-string/functions.c:105
msgid ""
"UNICHAR:the Unicode character represented by the Unicode code point @{x}"
msgstr ""
"UNICHAR:Das Unicode-Zeichen, durch die Unicode-Zeichennummer @{x} "
"repräsentiert."

#: ../plugins/fn-string/functions.c:106
msgid "x:Unicode code point"
msgstr "x:Unicode-Zeichennummer"

#: ../plugins/fn-string/functions.c:133
msgid "CODE:the CP1252 (Windows-1252) code point for the character @{c}"
msgstr "CODE:der Codepoint von CP1252 (Windows-1252) für das Zeichen @{c}"

#: ../plugins/fn-string/functions.c:134 ../plugins/fn-string/functions.c:179
msgid "c:character"
msgstr "c:Zeichen"

#: ../plugins/fn-string/functions.c:135
msgid "@{c} must be a valid CP1252 (Windows-1252) character."
msgstr "@{c} muss ein gültiges CP1252- (Windows-1252)-Zeichen sein."

#: ../plugins/fn-string/functions.c:137
msgid ""
"CP1252 (Windows-1252) is based on an early draft of ISO-8859-1, and contains "
"all of its printable characters (but partially at different positions.)"
msgstr ""
"CP1252 (Windows-1252) basiert auf einem frühen Entwurf von ISO-8859-1 und "
"enthält all deren darstellbare Zeichen (aber teilweise an anderen Stellen)."

#: ../plugins/fn-string/functions.c:178
msgid "UNICODE:the Unicode code point for the character @{c}"
msgstr "UNICODE:Die Unicode-Zeichennummer für das Zeichen @{c}"

#: ../plugins/fn-string/functions.c:244
msgid "EXACT:TRUE if @{string1} is exactly equal to @{string2}"
msgstr "EXACT:WAHR, falls @{string1} exakt gleich @{string2} ist"

#: ../plugins/fn-string/functions.c:245
msgid "string1:first string"
msgstr "string1:erste Zeichenkette"

#: ../plugins/fn-string/functions.c:246
msgid "string2:second string"
msgstr "string2:zweite Zeichenkette"

#: ../plugins/fn-string/functions.c:264
msgid "LEN:the number of characters of the string @{s}"
msgstr "LEN:die Anzahl der Zeichen in der Zeichenkette @{s}"

#: ../plugins/fn-string/functions.c:265 ../plugins/fn-string/functions.c:282
#: ../plugins/fn-string/functions.c:300 ../plugins/fn-string/functions.c:332
#: ../plugins/fn-string/functions.c:384 ../plugins/fn-string/functions.c:424
#: ../plugins/fn-string/functions.c:511 ../plugins/fn-string/functions.c:547
msgid "s:the string"
msgstr "s:die Zeichenkette"

#: ../plugins/fn-string/functions.c:281
msgid "LENB:the number of bytes in the string @{s}"
msgstr "LENB:die Anzahl der Bytes in der Zeichenkette @{s}"

#: ../plugins/fn-string/functions.c:299
msgid "LEFT:the first @{num_chars} characters of the string @{s}"
msgstr "LEFT:Die ersten @{num_chars} Zeichen der Zeichenkette @{s}"

#: ../plugins/fn-string/functions.c:301 ../plugins/fn-string/functions.c:512
msgid "num_chars:the number of characters to return (defaults to 1)"
msgstr "num_chars:die Anzahl der zurückzugebenden Zeichen (Vorgabe ist 1)"

#: ../plugins/fn-string/functions.c:302
msgid ""
"If the string @{s} is in a right-to-left script, the returned first "
"characters are from the right of the string."
msgstr ""
"Wenn die Zeichenkette @{s} in einem Links-nach-rechts-SKript ist, so sind "
"die ersten zurückgegebenen Zeichen aus dem rechten Teil der Zeichenkette."

#: ../plugins/fn-string/functions.c:331
msgid ""
"LEFTB:the first characters  of the string @{s} comprising at most @"
"{num_bytes} bytes"
msgstr ""
"LEFTB:die ersten Zeichen der Zeichenkette @{s}, bestehend aus höchstens @"
"{num_bytes} Bytes"

#: ../plugins/fn-string/functions.c:333 ../plugins/fn-string/functions.c:426
#: ../plugins/fn-string/functions.c:548
msgid "num_bytes:the maximum number of bytes to return (defaults to 1)"
msgstr ""
"num_bytes:Die maximale Anzahl der zurückzugebenden Bytes (Vorgabe ist 1)"

#: ../plugins/fn-string/functions.c:334 ../plugins/fn-string/functions.c:427
#: ../plugins/fn-string/functions.c:549 ../plugins/fn-string/functions.c:894
#: ../plugins/fn-string/functions.c:1385
msgid ""
"The semantics of this function is subject to change as various applications "
"implement it."
msgstr ""
"Die Semantik dieser Funktion unterliegt möglichen Variationen, je nach "
"Anwendung, die sie implementiert."

#: ../plugins/fn-string/functions.c:335
msgid ""
"If the string is in a right-to-left script, the returned first characters "
"are from the right of the string."
msgstr ""
"Falls die Schreibrichtung dieser Zeichenkette linksläufig ist, dann werden "
"die zurückzugebenden ersten Zeichen von rechts nach links gelesen."

#: ../plugins/fn-string/functions.c:336 ../plugins/fn-string/functions.c:428
#: ../plugins/fn-string/functions.c:472 ../plugins/fn-string/functions.c:551
#: ../plugins/fn-string/functions.c:895 ../plugins/fn-string/functions.c:1386
msgid ""
"While this function is syntactically Excel compatible, the differences in "
"the underlying text encoding will usually yield different results."
msgstr ""
"Obwohl diese Funktion syntaktisch mit Excel kompatibel ist, ergeben sich "
"gewöhnlich verschiedene Ergebnisse aufgrund der Unterschiede in der "
"Textcodierung."

#: ../plugins/fn-string/functions.c:337 ../plugins/fn-string/functions.c:430
#: ../plugins/fn-string/functions.c:474 ../plugins/fn-string/functions.c:552
#: ../plugins/fn-string/functions.c:897 ../plugins/fn-string/functions.c:1388
msgid ""
"While this function is OpenFormula compatible, most of its behavior is, at "
"this time, implementation specific."
msgstr ""
"Zwar ist diese Funktion zu OpenFormula kompatibel, aber derzeit ist das "
"Verhalten weitgehend abhängig von der Implementation."

#: ../plugins/fn-string/functions.c:365
msgid "LOWER:a lower-case version of the string @{text}"
msgstr "LOWER:Die in Kleinbuchstaben geschriebene Version von @text."

#: ../plugins/fn-string/functions.c:383
msgid ""
"MID:the substring of the string @{s} starting at position @{position} "
"consisting of @{length} characters"
msgstr ""
"MID: Die Teilzeichenkette der Zeichenkette @{s}, die bei Position @"
"{position} beginnt und aus @{length} Zeichen besteht"

#: ../plugins/fn-string/functions.c:385
msgid "position:the starting position"
msgstr "position:die Startposition"

#: ../plugins/fn-string/functions.c:386
msgid "length:the number of characters to return"
msgstr "length:Die Anzahl der zurückzugebenden Zeichen"

#: ../plugins/fn-string/functions.c:423
msgid ""
"MIDB:the characters following the first @{start_pos} bytes comprising at "
"most @{num_bytes} bytes"
msgstr ""
"MIDB: Die Buchstaben, welche den ersten @{start_pos} Bytes folgen und "
"höchstens @{num_bytes} Bytes umfassen"

#: ../plugins/fn-string/functions.c:425
msgid "start_pos:the number of the byte with which to start (defaults to 1)"
msgstr "start_pos: Die Nummer des Byte, bei dem gestartet wird (Vorgabe ist 1)"

#: ../plugins/fn-string/functions.c:467
msgid ""
"FINDB:first byte position of @{string1} in @{string2} following byte "
"position @{start}"
msgstr ""
"FINDB: Erste Byte-Position von @{string1} in @{string2} nach Byte-Position @"
"{start}"

#: ../plugins/fn-string/functions.c:468 ../plugins/fn-string/functions.c:696
msgid "string1:search string"
msgstr "string1:Suchzeichenkette"

#: ../plugins/fn-string/functions.c:469 ../plugins/fn-string/functions.c:697
msgid "string2:search field"
msgstr "string2:Suchfeld"

#: ../plugins/fn-string/functions.c:470 ../plugins/fn-string/functions.c:1375
msgid "start:starting byte position, defaults to 1"
msgstr "start:Startbyte-Position, Vorgabe ist 1"

#: ../plugins/fn-string/functions.c:471 ../plugins/fn-string/functions.c:699
msgid "This search is case-sensitive."
msgstr "Für diese Suche wird Groß-/Kleinschreibung berücksichtigt."

#: ../plugins/fn-string/functions.c:510
msgid "RIGHT:the last @{num_chars} characters of the string @{s}"
msgstr "RIGHT:Die letzten @{num_chars} Zeichen der Zeichenkette @{s}"

#: ../plugins/fn-string/functions.c:513 ../plugins/fn-string/functions.c:550
msgid ""
"If the string @{s} is in a right-to-left script, the returned last "
"characters are from the left of the string."
msgstr ""
"Falls die Zeichenkette @{s} linksläufig geschrieben ist, werden die "
"zurückegegebenen letzten Zeichen von der linken Seite der Zeichenkette "
"entnommen."

#: ../plugins/fn-string/functions.c:546
msgid ""
"RIGHTB:the last characters of the string @{s} comprising at most @"
"{num_bytes} bytes"
msgstr ""
"RIGHTB: Die letzten Zeichen der Zeichenkette @{s}, die höchstens @"
"{num_bytes} Bytes umfassen"

#: ../plugins/fn-string/functions.c:581
msgid "UPPER:an upper-case version of the string @{text}"
msgstr "UPPER:Die in Großbuchstaben geschriebene Version von @text."

#: ../plugins/fn-string/functions.c:600
msgid "CONCATENATE:the concatenation of the strings @{s1}, @{s2},…"
msgstr "CONCATENATE:Die Zusammenführung der Zeichenketten @{s1}, @{s2},…"

#: ../plugins/fn-string/functions.c:601
msgid "s1:first string"
msgstr "s1:erste Zeichenkette"

#: ../plugins/fn-string/functions.c:602
msgid "s2:second string"
msgstr "s2:zweite Zeichenkette"

#: ../plugins/fn-string/functions.c:622
msgid "REPT:@{num} repetitions of string @{text}"
msgstr "REPT:@{num} Wiederholungen der Zeichenkette @{text}"

#: ../plugins/fn-string/functions.c:624
msgid "num:non-negative integer"
msgstr "num:nicht-negative Ganzzahl"

#: ../plugins/fn-string/functions.c:666
msgid "CLEAN:@{text} with any non-printable characters removed"
msgstr "CLEAN:@{text}, aus dem nicht druckbare Zeichen entfernt wurden"

#: ../plugins/fn-string/functions.c:668
msgid ""
"CLEAN removes non-printable characters from its argument leaving only "
"regular characters and white-space."
msgstr ""
"CLEAN entfernt nicht druckbare Zeichen aus dem Argument, wobei nur reguläre "
"Zeichen und Leerzeichen verbleiben."

#: ../plugins/fn-string/functions.c:695
msgid ""
"FIND:first position of @{string1} in @{string2} following position @{start}"
msgstr ""
"FIND:erste Position von @{string1} in @{string2} nach der Position @{start}"

#: ../plugins/fn-string/functions.c:698 ../plugins/fn-string/functions.c:1306
msgid "start:starting position, defaults to 1"
msgstr "start:Startposition, Vorgabe ist 1"

#: ../plugins/fn-string/functions.c:733
msgid "FIXED:formatted string representation of @{num}"
msgstr "FIXED:als Zeichenkette formatierte Repräsentation von @{num}"

#: ../plugins/fn-string/functions.c:734 ../plugins/fn-string/functions.c:1231
msgid "num:number"
msgstr "num:Zahl"

#: ../plugins/fn-string/functions.c:735
msgid "decimals:number of decimals"
msgstr "decimals:Anzahl der Dezimalstellen"

#: ../plugins/fn-string/functions.c:736
msgid ""
"no_commas:TRUE if no thousand separators should be used, defaults to FALSE"
msgstr ""
"no_commas:WAHR, wenn Tausender-Trenner benutzt werden sollen, Vorgabe ist "
"UNWAHR"

#: ../plugins/fn-string/functions.c:793
msgid "PROPER:@{text} with initial of each word capitalised"
msgstr "PROPER:@{text} mit dem Anfangsbuchstaben jedes Worts als Großbuchstabe"

#: ../plugins/fn-string/functions.c:835
msgid ""
"REPLACE:string @{old} with @{num} characters starting at @{start} replaced "
"by @{new}"
msgstr ""
"REPLACE:Zeichenkette @{old} mit @{num} Zeichen wird ab Position @{start} "
"ersetzt durch @{new}"

#: ../plugins/fn-string/functions.c:837 ../plugins/fn-string/functions.c:888
msgid "old:original text"
msgstr "old:Originaltext"

#: ../plugins/fn-string/functions.c:838
msgid "start:starting position"
msgstr "start:Startposition"

#: ../plugins/fn-string/functions.c:839
msgid "num:number of characters to be replaced"
msgstr "num:Anzahl der zu ersetzenden Zeichen"

#: ../plugins/fn-string/functions.c:840 ../plugins/fn-string/functions.c:891
#: ../plugins/fn-string/functions.c:1159
msgid "new:replacement string"
msgstr "new:Ersetzungszeichenkette"

#: ../plugins/fn-string/functions.c:886
msgid ""
"REPLACEB:string @{old} with up to @{num} bytes starting at @{start} replaced "
"by @{new}"
msgstr ""
"REPLACEB:Zeichenkette @{old} mit bis zu @{num} Bytes wird ab Position @"
"{start} ersetzt durch @{new}"

#: ../plugins/fn-string/functions.c:889
msgid "start:starting byte position"
msgstr "start:Startbyte-Position"

#: ../plugins/fn-string/functions.c:890
msgid "num:number of bytes to be replaced"
msgstr "num:Anzahl der zu ersetzenden Bytes"

#: ../plugins/fn-string/functions.c:892
msgid ""
"REPLACEB replaces the string of valid unicode characters starting at the "
"byte @{start} and ending at @{start}+@{num}-1 with the string @{new}."
msgstr ""
"REPLACEB ersetzt eine aus Unicode-Zeichen bestehende Zeichenkette ab "
"Position @{start} bis zu Position @{start}+@{num}-1 durch die Zeichenkette @"
"{new}."

#: ../plugins/fn-string/functions.c:940
msgid "T:@{value} if and only if @{value} is text, otherwise empty"
msgstr "T:@{value}, genau dann, wenn @{value} Text ist, anderenfalls leer"

#: ../plugins/fn-string/functions.c:941
msgid "value:original value"
msgstr "value:Originalwert"

#: ../plugins/fn-string/functions.c:963
msgid "TEXT:@{value} as a string formatted as @{format}"
msgstr "TEXT:@{value} als Zeichenkette, formatiert in @{format}"

#: ../plugins/fn-string/functions.c:964
msgid "value:value to be formatted"
msgstr "value:zu formatierender Wert"

#: ../plugins/fn-string/functions.c:965
msgid "format:desired format"
msgstr "format:gewünschtes Format"

#: ../plugins/fn-string/functions.c:1017
msgid "TRIM:@{text} with only single spaces between words"
msgstr ""
"TRIM:@{text} mit ausschließlich einzelnen Leerzeichen zwischen den Wörtern."

#: ../plugins/fn-string/functions.c:1064
msgid "VALUE:numeric value of @{text}"
msgstr "VALUE:numerischer Wert von @{text}"

#: ../plugins/fn-string/functions.c:1097
msgid "NUMBERVALUE:numeric value of @{text}"
msgstr "NUMBERVALUE:numerischer Wert von @{text}"

#: ../plugins/fn-string/functions.c:1099
msgid "separator:decimal separator"
msgstr "separator:Dezimaltrenner"

#: ../plugins/fn-string/functions.c:1100
msgid ""
"If @{text} does not look like a decimal number, NUMBERVALUE returns the "
"value VALUE would return (ignoring the given @{separator})."
msgstr ""
"Falls @{text} keine Dezimalzahl zu sein scheint, gibt NUMBERVALUE den Wert "
"zurück, den VALUE zurückgeben würde (wobei der angegebene @{separator} "
"ignoriert wird)."

#: ../plugins/fn-string/functions.c:1156
msgid "SUBSTITUTE:@{text} with all occurrences of @{old} replaced by @{new}"
msgstr ""
"SUBSTITUTE:@{text} mit allen Vorkommen von @{old}, ersetzt durch @{new}"

#: ../plugins/fn-string/functions.c:1157 ../plugins/fn-string/functions.c:1567
msgid "text:original text"
msgstr "text:Originaltext"

#: ../plugins/fn-string/functions.c:1158
msgid "old:string to be replaced"
msgstr "old:zu ersetzende Zeichenkette"

#: ../plugins/fn-string/functions.c:1160
msgid ""
"num:if @{num} is specified and a number only the @{num}th occurrence of @"
"{old} is replaced"
msgstr ""
"num:Wenn @{num} angegeben und eine Zahl ist, dann wird nur das @{num}(s)te "
"Auftreten von @{old} ersetzt"

#: ../plugins/fn-string/functions.c:1230
msgid "DOLLAR:@{num} formatted as currency"
msgstr "DOLLAR:@{num}, als Währung formatiert."

#: ../plugins/fn-string/functions.c:1232
msgid "decimals:decimals"
msgstr "decimals:Dezimalstellen"

#: ../plugins/fn-string/functions.c:1302
msgid ""
"SEARCH:the location of the @{search} string within @{text} after position @"
"{start}"
msgstr ""
"SEARCH:der Ort der Zeichenkette @{search} innerhalb @{text} nach der "
"Position @{start}"

#: ../plugins/fn-string/functions.c:1304 ../plugins/fn-string/functions.c:1373
msgid "search:search string"
msgstr "search:Suchzeichenkette"

#: ../plugins/fn-string/functions.c:1305 ../plugins/fn-string/functions.c:1374
msgid "text:search field"
msgstr "text:Suchfeld"

#: ../plugins/fn-string/functions.c:1307 ../plugins/fn-string/functions.c:1376
msgid ""
"@{search} may contain wildcard characters (*) and question marks (?). A "
"question mark matches any single character, and a wildcard matches any "
"string including the empty string. To search for * or ?, precede the symbol "
"with ~."
msgstr ""
"@{search} kann Platzhalterzeichen (*) und Fragezeichen (?) enthalten. Ein "
"Fragezeichen steht für ein beliebiges Einzelzeichen, und ein "
"Platzhalterzeichen steht für eine beliebige Zeichenfolge, einschließlich "
"einer leeren. Um nach »*« oder »?« zu suchen, stellen Sie dem Zeichen ein "
"»~« voraus."

#: ../plugins/fn-string/functions.c:1312 ../plugins/fn-string/functions.c:1381
msgid "This search is not case sensitive."
msgstr "Für diese Suche wird Groß-/Kleinschreibung nicht berücksichtigt."

#: ../plugins/fn-string/functions.c:1313
msgid "If @{search} is not found, SEARCH returns #VALUE!"
msgstr "Falls @{search} nicht gefunden wird, gibt SEARCH #WERT! zurück."

#: ../plugins/fn-string/functions.c:1314
msgid ""
"If @{start} is less than one or it is greater than the length of @{text}, "
"SEARCH returns #VALUE!"
msgstr ""
"Falls @{start} kleiner als 1 oder größer als die Länge von @{text} ist, gibt "
"SEARCH #WERT! zurück."

#: ../plugins/fn-string/functions.c:1371
msgid ""
"SEARCHB:the location of the @{search} string within @{text} after byte "
"position @{start}"
msgstr ""
"SEARCHB:Der Ort der @{search}-Zeichenkette innerhalb von @{text} nach der "
"Byte-Position @{start}"

#: ../plugins/fn-string/functions.c:1382
msgid "If @{search} is not found, SEARCHB returns #VALUE!"
msgstr "Falls @{search} nicht gefunden wird, gibt SEARCHB #WERT! zurück."

#: ../plugins/fn-string/functions.c:1383
msgid ""
"If @{start} is less than one or it is greater than the byte length of @"
"{text}, SEARCHB returns #VALUE!"
msgstr ""
"Falls @{start} kleiner als 1 oder größer als die Byte-Länge von @{text} ist, "
"gibt SEARCHB #WERT! zurück."

#: ../plugins/fn-string/functions.c:1439
msgid ""
"ASC:text with full-width katakana and ASCII characters converted to half-"
"width"
msgstr ""

#: ../plugins/fn-string/functions.c:1441
msgid ""
"ASC converts full-width katakana and ASCII characters to half-width "
"equivalent characters, copying all others. "
msgstr ""

#: ../plugins/fn-string/functions.c:1442 ../plugins/fn-string/functions.c:1570
msgid ""
"The distinction between half-width and full-width characters is described in "
"http://www.unicode.org/reports/tr11/."
msgstr ""
"Der Unterschied zwischen Zeichen halber Breite und voller Breite wird in "
"http://www.unicode.org/reports/tr11/ beschrieben."

#: ../plugins/fn-string/functions.c:1443 ../plugins/fn-string/functions.c:1572
msgid "For most strings, this function has the same effect as in Excel."
msgstr ""
"Für die meisten Zeichenketten hat diese Funktion den gleichen Effekt wie in "
"Excel."

#: ../plugins/fn-string/functions.c:1444
msgid ""
"While in obsolete encodings ASC used to translate between 2-byte and 1-byte "
"characters, this is not the case in UTF-8."
msgstr ""
"In veralteten Kodierungen übersetzte ASC zwischen 2-Byte und 1-Byte-Zeichen. "
"Dies ist aber für UTF-8 nicht der Fall."

#: ../plugins/fn-string/functions.c:1566
msgid ""
"JIS:text with half-width katakana and ASCII characters converted to full-"
"width"
msgstr ""

#: ../plugins/fn-string/functions.c:1568
msgid ""
"JIS converts half-width katakana and ASCII characters to full-width "
"equivalent characters, copying all others. "
msgstr ""

#: ../plugins/fn-string/functions.c:1573
msgid ""
"While in obsolete encodings JIS used to translate between 1-byte and 2-byte "
"characters, this is not the case in UTF-8."
msgstr ""
"Während in veralteten Kodierungen JIS zur Übersetzung zwischen 1-Byte- und 2-"
"Byte-Zeichen verwendet wird, ist dies in UTF-8 nicht der Fall."

#: ../plugins/fn-tsa/functions.c:93
msgid ""
"Possible interpolation methods are:\n"
"0: linear;\n"
"1: linear with averaging;\n"
"2: staircase;\n"
"3: staircase with averaging;\n"
"4: natural cubic spline;\n"
"5: natural cubic spline with averaging."
msgstr ""
"Mögliche Interpolationsmethoden sind:\n"
"0: linear;\n"
"1: linear mit Mittelwert;\n"
"2: Treppenstufe;\n"
"3: Treppenstufe mit Mittelwert;\n"
"4: Natürliches kubisches Spline;\n"
"5: Natürliches kubisches Spline mit Mittelwert."

#: ../plugins/fn-tsa/functions.c:380
msgid ""
"INTERPOLATION:interpolated values corresponding to the given abscissa targets"
msgstr ""
"INTERPOLATION:Interpolierte Werte, entsprechend den gegebenen Abszissenzielen"

#: ../plugins/fn-tsa/functions.c:381
msgid "abscissae:abscissae of the given data points"
msgstr "abscissae:Die Abszissen der angegebenen Datenpunkte"

#: ../plugins/fn-tsa/functions.c:382
msgid "ordinates:ordinates of the given data points"
msgstr "ordinates:Die Ordinaten der angegebenen Datenpunkte"

#: ../plugins/fn-tsa/functions.c:383
msgid "targets:abscissae of the interpolated data"
msgstr "targets:Die Abszissen der interpolierten Daten"

#: ../plugins/fn-tsa/functions.c:384
msgid "interpolation:method of interpolation, defaults to 0 ('linear')"
msgstr ""
"interpolation:Die zu verwendende Interpolierungsmethode, Vorgabe ist 0 "
"(linear)"

#: ../plugins/fn-tsa/functions.c:385 ../plugins/fn-tsa/functions.c:574
msgid "The output consists always of one column of numbers."
msgstr "Die Ausgabe besteht immer aus einer Spalte mit Zahlen."

#: ../plugins/fn-tsa/functions.c:387
msgid ""
"The @{abscissae} should be given in increasing order. If the @{abscissae} is "
"not in increasing order the INTERPOLATION function is significantly slower."
msgstr ""

#: ../plugins/fn-tsa/functions.c:389
#, fuzzy
#| msgid ""
#| "If no logical values are provided, then the error #VALUE! is returned."
msgid "If any two @{abscissae} values are equal an error is returned."
msgstr ""
"Falls keine logischen Werte zurückgegeben werden, wird der Fehler #WERT! "
"zurückgegeben."

#: ../plugins/fn-tsa/functions.c:390
msgid ""
"If any of interpolation methods 1 ('linear with averaging'), 3 ('staircase "
"with averaging'), and 5 ('natural cubic spline with averaging') is used, the "
"number of returned values is one less than the number of targets and the "
"target values must be given in increasing order. The values returned are the "
"average heights of the interpolation function on the intervals determined by "
"consecutive target values."
msgstr ""
"Falls eine der Interpolationsmethoden »1« (linear mit Mittelwert), "
"»3« (Treppen mit Mittelwert) oder »5« (natürliches kubisches Spline mit "
"Mittelwert) angewendet wird, dann ist die Anzahl der zurückgegebenen Werte "
"um 1 kleiner als die Anzahl der Zielwerte. Die Zielwerte müssen in "
"aufsteigender Reihenfolge angegeben werden. Die zurückgegebenen Werte sind "
"die durchschnittliche Höhe der Interpolationsfunktion über den Intervallen, "
"die durch folgende Zielwerte festgelegt sind."

#: ../plugins/fn-tsa/functions.c:397 ../plugins/fn-tsa/functions.c:581
msgid "Strings and empty cells in @{abscissae} and @{ordinates} are ignored."
msgstr ""
"Zeichenketten und leere Zellen in @{abscissae} und @{ordinates} werden "
"ignoriert."

#: ../plugins/fn-tsa/functions.c:398 ../plugins/fn-tsa/functions.c:582
msgid ""
"If several target data are provided they must be in the same column in "
"consecutive cells."
msgstr ""
"Wenn mehrere Ziele angegeben werden, so müssen sich diese in der gleichen "
"Spalte in aufeinander folgenden Zellen befinden."

#: ../plugins/fn-tsa/functions.c:567
msgid "PERIODOGRAM:periodogram of the given data"
msgstr "PERIODOGRAM:Periodogramm der gegebenen Daten."

#: ../plugins/fn-tsa/functions.c:568
msgid "ordinates:ordinates of the given data"
msgstr "ordinates:Die Ordinaten der angegebenen Daten"

#: ../plugins/fn-tsa/functions.c:569
msgid "filter:windowing function to  be used, defaults to no filter"
msgstr "filter:Zu verwendende Fensterfunktion. Vorgabe ist kein Filter."

#: ../plugins/fn-tsa/functions.c:570
msgid ""
"abscissae:abscissae of the given data, defaults to regularly spaced abscissae"
msgstr ""
"abscissae:Abszissen der gelieferten Daten. Vorgabe ist Abszissen in "
"gleichmäßigem Abstand"

#: ../plugins/fn-tsa/functions.c:571
msgid "interpolation:method of interpolation, defaults to none"
msgstr ""
"interpolation:Die zu benutzende Interpolierungsmethode, Vorgabe ist keine "
"Interpolation"

#: ../plugins/fn-tsa/functions.c:572
msgid "number:number of interpolated data points"
msgstr "number:Anzahl der interpolierten Datenpunkte"

#: ../plugins/fn-tsa/functions.c:573
msgid ""
"If an interpolation method is used, the number of returned values is one "
"less than the number of targets and the targets values must be given in "
"increasing order."
msgstr ""
"Falls eine Interpolationsmethode angewendet wird, dann ist die Anzahl der "
"zurückgegebenen Werte um 1 kleiner als die Anzahl der Zielwerte. Die "
"Zielwerte müssen in aufsteigender Folge angegeben werden."

#: ../plugins/fn-tsa/functions.c:576
msgid ""
"Possible window functions are:\n"
"0: no filter (rectangular window)\n"
"1: Bartlett (triangular window)\n"
"2: Hahn (cosine window)\n"
"3: Welch (parabolic window)"
msgstr ""
"Mögliche Fensterfunktionen:\n"
"0: Kein Filter (rechteckiges Fenster)\n"
"1: Bartlett (dreieckiges Fenster)\n"
"2: Hahn (Kosinusfenster)\n"
"3: Welch (parabolisches Fenster)"

#: ../plugins/fn-tsa/functions.c:826
msgid "FOURIER:Fourier or inverse Fourier transform"
msgstr "FOURIER:Fourier- oder inverse Fourier-Transformation."

#: ../plugins/fn-tsa/functions.c:827 ../plugins/fn-tsa/functions.c:923
msgid "Sequence:the data sequence to be transformed"
msgstr "Sequence:Die umzuwandelnde Datensequenz"

#: ../plugins/fn-tsa/functions.c:828
msgid ""
"Inverse:if true, the inverse Fourier transform is calculated, defaults to "
"false"
msgstr ""
"Inverse:Falls wahr, wird die inverse Fourier-Transformation berechnet. "
"Vorgabe ist »falsch«."

#: ../plugins/fn-tsa/functions.c:829
msgid ""
"Separate:if true, the real and imaginary parts are given separately, "
"defaults to false"
msgstr ""
"Separate:Falls wahr, so werden der Real- und Imaginärteil separat angegeben. "
"Vorgabe lautet »falsch«"

#: ../plugins/fn-tsa/functions.c:830
msgid ""
"This array function returns the Fourier or inverse Fourier transform of the "
"given data sequence."
msgstr ""
"Diese Feldfunktion gibt die Fourier- oder inverse Fourier-Transformation der "
"gegebenen Datensequenz zurück."

#: ../plugins/fn-tsa/functions.c:831
msgid ""
"The output consists of one column of complex numbers if @{Separate} is false "
"and of two columns of real numbers if @{Separate} is true."
msgstr ""
"Die Ausgabe besteht aus einer Spalte komplexer Zahlen, falls @{Separate}  "
"falsch ist und aus zwei Spalten mit reellen Zahlen, falls @{Separate} wahr "
"ist."

#: ../plugins/fn-tsa/functions.c:832
msgid ""
"If @{Separate} is true the first output column contains the real parts and "
"the second column the imaginary parts."
msgstr ""
"Wenn @{Separate} wahr ist, so enthält die erste Ausgabespalte die "
"Realanteile und die zweite Spalte die Imaginärteile."

#: ../plugins/fn-tsa/functions.c:833 ../plugins/fn-tsa/functions.c:927
msgid ""
"If @{Sequence} is neither an n by 1 nor 1 by n array, this function returns "
"#VALUE!"
msgstr ""
"Wenn @{Sequence} weder ein n-mal-1, noch ein 1-mal-n Feld ist, so gibt diese "
"Funktion #WERT! zurück"

#: ../plugins/fn-tsa/functions.c:922
msgid "HPFILTER:Hodrick Prescott Filter"
msgstr "HPFILTER:Hodrick-Prescott-Filter"

#: ../plugins/fn-tsa/functions.c:924
msgid "λ:filter parameter λ, defaults to 1600"
msgstr "λ:Filterparameter λ, Vorgabe ist 1600"

#: ../plugins/fn-tsa/functions.c:925
msgid ""
"This array function returns the trend and cyclical components obtained by "
"applying the Hodrick Prescott Filter with parameter @{λ} to the given data "
"sequence."
msgstr ""
"Diese Feldfunktion gibt die Trend- und zyklischen Komponenten zurück, die "
"durch Anwendung des Hodrick-Prescott-Filters mit Parameter @{λ} auf die "
"gegebene Datensequenz erhalten werden."

#: ../plugins/fn-tsa/functions.c:926
msgid ""
"The output consists of two columns of numbers, the first containing the "
"trend component, the second the cyclical component."
msgstr ""
"Die Ausgabe besteht aus zwei Spalten mit Zahlen, wobei die erste die "
"Trendkomponente und die zweite die zyklische Komponente enthält."

#: ../plugins/fn-tsa/functions.c:928
msgid ""
"If @{Sequence} contians less than 6 numerical values, this function returns "
"#VALUE!"
msgstr ""
"Wenn @{Sequence} weniger als 6 numerische Werte enthält, so gibt diese "
"Funktion #WERT! zurück"

#: ../plugins/gda/plugin-gda.c:306
msgid "EXECSQL:result of executing @{sql} in the libgda data source @{dsn}"
msgstr ""
"EXECSQL:Ergebnis der Ausführung von @{sql} in der libgda-Datenquelle @{dsn}"

#: ../plugins/gda/plugin-gda.c:308 ../plugins/gda/plugin-gda.c:385
msgid "dsn:libgda data source"
msgstr "dsn:libgda-Datenquelle"

#: ../plugins/gda/plugin-gda.c:309 ../plugins/gda/plugin-gda.c:386
msgid "username:user name to access @{dsn}"
msgstr "username:Benutzername zum Zugriff auf @{dsn}"

#: ../plugins/gda/plugin-gda.c:310 ../plugins/gda/plugin-gda.c:387
msgid "password:password to access @{dsn} as @{username}"
msgstr "password:Passwort zum Zugriff auf @{dsn} als @{username}"

#: ../plugins/gda/plugin-gda.c:311
msgid "sql:SQL command"
msgstr "sql:SQL-Befehl"

#: ../plugins/gda/plugin-gda.c:312 ../plugins/gda/plugin-gda.c:389
msgid "Before using EXECSQL, you need to set up a libgda data source."
msgstr ""
"Bevor Sie EXECSQL verwenden können, müssen Sie eine libgda-Datenquelle "
"einrichten."

#: ../plugins/gda/plugin-gda.c:384
msgid "READDBTABLE:all rows of the table @{table} in @{dsn}"
msgstr "READDBTABLE:alle Zeilen der Tabelle @{table} in @{dsn}"

#: ../plugins/gda/plugin-gda.c:388
msgid "table:SQL table to retrieve"
msgstr "table:zu holende SQL-Tabelle"

#: ../plugins/sample_datasource/sample_datasource.c:274
msgid "ATL_LAST:sample real-time data source"
msgstr "ATL_LAST:Beispielhafte Echtzeit-Datenquelle"

#: ../plugins/sample_datasource/sample_datasource.c:275
#, fuzzy
msgid "tag:tag to watch"
msgstr "Zu überwachende Werte"

#: ../plugins/sample_datasource/sample_datasource.c:276
msgid ""
"ATL_LAST is a sample implementation of a real time data source.  It takes a "
"string tag and monitors the named pipe ~/atl for changes to the value of "
"that tag."
msgstr ""
"ATL.ZULETZT ist ein Implementierungsbeispiel für eine Echtzeitdatenquelle. "
"Es nimmt eine Kennungszeichenkette und überwacht die Named-Pipe »~/atl« auf "
"Änderungen am Wert dieser Kennung."

#: ../plugins/sample_datasource/sample_datasource.c:277
msgid "This is not intended to be generally enabled and is OFF by default."
msgstr ""
"Die allgemeine Aktivierung ist nicht beabsichtigt und ist daher per Vorgabe "
"ausgeschaltet."

#~ msgid "If @{p} < 0 or @{p} > 1 this functions returns a #NUM! error."
#~ msgstr ""
#~ "Wenn @{p} < 0 or @{p} > 1, dann gibt diese Funktion den Fehler #ZAHL! "
#~ "zurück."

#~ msgid "The @{abscissae} must be given in increasing order."
#~ msgstr ""
#~ "Die @{abscissae} müssen in aufsteigender Reihenfolge angegeben werden."

#~ msgid ""
#~ "SUMPRODUCTs arguments are arrays or ranges. Attempting to use A1:A5>0 "
#~ "will not work, implicit intersection will kick in. Instead use --(A1:A5>0)"
#~ msgstr ""
#~ "Die Argumente von SUMPRODUCT sind Felder oder Bereiche. Ein Versuch A1:"
#~ "A5>0 zu verwenden wird nicht funktionieren. Implizite Schnittmengen "
#~ "greifen statt dessen. Verwenden Sie stattdessen --(A1:A5>0)"

#~ msgid "a:amount of skew, defaults to 0"
#~ msgstr "a:Betrag der Verschiebung, Vorgabe ist 0"

#~ msgid "μ:mean of the underlying normal distribution, defaults to 0"
#~ msgstr ""
#~ "μ:Erwartungswert der zugrunde liegenden Normalverteilung, Vorgabe ist 0"

#~ msgid "α:order (any number)"
#~ msgstr "α:Ordnung (irgendeine Zahl)"

#~ msgid "secz = 1/cosz."
#~ msgstr "secz = 1/cosz."

#~ msgid "cscz = 1/sinz."
#~ msgstr "cscz = 1/sinz."

#~ msgid "cotz = cosz/sinz."
#~ msgstr "cotz = cosz/sinz."

#~ msgid "The output consists always of one column of complex numbers."
#~ msgstr "Die Ausgabe besteht immer aus einer Spalte mit komplexen Zahlen."

#~ msgid "DATE2UNIX:translate a date serial value to a Unix timestamp"
#~ msgstr ""
#~ "DATE2UNIX wandelt einen seriellen Datumswert in einen Unix-Zeitstempel um"

#~ msgid "d:date serial value"
#~ msgstr "d:serieller Datumswert"

#~ msgid ""
#~ "The DATE2UNIX function translates a date serial values into a Unix "
#~ "timestamp."
#~ msgstr ""
#~ "Die Funktion DATE2UNIX wandelt einen seriellen Datumswert in einen Unix-"
#~ "Zeitstempel um."

#~ msgid "ref_text:"
#~ msgstr "ref_text:"

#~ msgid "array:"
#~ msgstr "array:"

#~ msgid "x:"
#~ msgstr "x:"

#~ msgid "k:"
#~ msgstr "k:"

#~ msgid "This function is the OpenFormula function B"
#~ msgstr "Diese Funktion ist die OpenFormula-Funktion B"

#~ msgid "ACOTH:inverse hyperbolic cotangent of a value"
#~ msgstr "ACOTH:Der Kehrwert des hyperbolischen Kotangens eines Wertes"

#~ msgid "COS:Cosine function"
#~ msgstr "COS:Cosinus-Funktion"

#~ msgid "COSH:Hyperbolic cosine function"
#~ msgstr "COSH:Hyperbolische Kosinusfunktion"

#~ msgid "COT:cotangent of a value"
#~ msgstr "COT:Kotangens eines Wertes"

#~ msgid "COTH:hyperbolic cotangent of a value"
#~ msgstr "COTH:Hyperbolischer Kotangens eines Wertes"

#~ msgid "x:number."
#~ msgstr "x:Zahl."

#~ msgid "LOG:Logarithm"
#~ msgstr "LOG:Logarithmus"

#~ msgid "CSC:Cosecant"
#~ msgstr "CSC:Kosekans"

#~ msgid "CSCH:Hyperbolic cosecant"
#~ msgstr "CSCH:Hyperbolischer Kosekans"

#~ msgid "SECH:Hyperbolic secant"
#~ msgstr "SECH:Hyperbolischer Sekans"

#~ msgid "TAN:tangent"
#~ msgstr "TAN:Tangens"

#~ msgid "TANH:hyperbolic tangent"
#~ msgstr "TANH:hyperbolischer Tangens"

#~ msgid "b1:angle in radians"
#~ msgstr "b1:Winkel in Radiant"

#~ msgid "b2:angle in radians"
#~ msgstr "b2:Winkel in Radiant"

#~ msgid "This function is ODF compatible."
#~ msgstr "Diese Funktion ist ODF-kompatibel."

#~ msgid ""
#~ "@FUNCTION=PRICE\n"
#~ "@SYNTAX=PRICE(settle,mat,rate,yield,redemption_price,[frequency,basis])\n"
#~ "@DESCRIPTION=PRICE returns price per $100 face value of a security. This "
#~ "method can only be used if the security pays periodic interest.\n"
#~ "\n"
#~ "@frequency is the number of coupon payments per year. Allowed frequencies "
#~ "are: 1 = annual, 2 = semi, 4 = quarterly. @basis is the type of day "
#~ "counting system you want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @frequency is other than 1, 2, or 4, PRICE returns #NUM! error.\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis is not in between 0 and 4, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=ERTRAG\n"
#~ "@SYNTAX=ERTRAG(settle,mat,rate,price,redemption_price,Häufigkeit[,"
#~ "Basis])\n"
#~ "@DESCRIPTION=ERTRAG liefert den Ertrag auf eine Sicherheit, die einen "
#~ "periodischen Zins abwirft.\n"
#~ "\n"
#~ "@Häufigkeit ist die Anzahl der Kupon-Zahlungen pro Jahr. Zulässige Werte "
#~ "sind: 1 = jährlich, 2 = halbjährlich, 4 = vierteljährlich.\n"
#~ "@Basis ist der Typ des zur Tagesberechnung verwendeten Systems:\n"
#~ "\n"
#~ "  0  MSRB 30/360 (MSRB Regel G33 (e))\n"
#~ "  1  Tatsächliche Tage/Tatsächliche Tage\n"
#~ "  2  Tatsächliche Tage/360\n"
#~ "  3  Tatsächliche Tage/365\n"
#~ "  4  Europäisch 30/360\n"
#~ "  5  Europäisch + 30/360\n"
#~ "\n"
#~ "* Falls @Häufigkeit weder 1, noch 2, 4 oder ungültig ist, liefert ERTRAG "
#~ "einen #ZAHL!-Fehler.\n"
#~ "* Falls @Basis nicht übergeben wird, wird MSRB 30/360 angenommen.\n"
#~ "* Falls @Basis nicht zwischen 0 und 4 liegt, liefert ERTRAG einen #ZAHL!-"
#~ "Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=YIELD\n"
#~ "@SYNTAX=YIELD(settlement,maturity,rate,price,redemption_price,frequency[,"
#~ "basis])\n"
#~ "@DESCRIPTION=YIELD returns the yield on a security that pays periodic "
#~ "interest.\n"
#~ "\n"
#~ "@frequency is the number of coupon payments per year. Allowed frequencies "
#~ "are: 1 = annual, 2 = semi, 4 = quarterly. @basis is the type of day "
#~ "counting system you want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @frequency is other than 1, 2, or 4, YIELD returns #NUM! error.\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis is not in between 0 and 4, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=ERTRAG\n"
#~ "@SYNTAX=ERTRAG(settle,mat,rate,price,redemption_price,Häufigkeit[,"
#~ "Basis])\n"
#~ "@DESCRIPTION=ERTRAG liefert den Ertrag auf eine Sicherheit, die einen "
#~ "periodischen Zins abwirft.\n"
#~ "\n"
#~ "@Häufigkeit ist die Anzahl der Kupon-Zahlungen pro Jahr. Zulässige Werte "
#~ "sind: 1 = jährlich, 2 = halbjährlich, 4 = vierteljährlich.\n"
#~ "@Basis ist der Typ des zur Tagesberechnung verwendeten Systems:\n"
#~ "\n"
#~ "  0  MSRB 30/360 (MSRB Regel G33 (e))\n"
#~ "  1  Tatsächliche Tage/Tatsächliche Tage\n"
#~ "  2  Tatsächliche Tage/360\n"
#~ "  3  Tatsächliche Tage/365\n"
#~ "  4  Europäisch 30/360\n"
#~ "  5  Europäisch + 30/360\n"
#~ "\n"
#~ "* Falls @Häufigkeit weder 1, noch 2, 4 oder ungültig ist, liefert ERTRAG "
#~ "einen #ZAHL!-Fehler.\n"
#~ "* Falls @Basis nicht übergeben wird, wird MSRB 30/360 angenommen.\n"
#~ "* Falls @Basis nicht zwischen 0 und 4 liegt, liefert ERTRAG einen #ZAHL!-"
#~ "Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=YIELDDISC\n"
#~ "@SYNTAX=YIELDDISC(settlement,maturity,pr,redemption[,basis])\n"
#~ "@DESCRIPTION=YIELDDISC calculates the annual yield of a security that is "
#~ "discounted.\n"
#~ "\n"
#~ "@settlement is the settlement date of the security.  @maturity is the "
#~ "maturity date of the security. @pr is the price per $100 face value of "
#~ "the security. @redemption is the redemption value per $100 face value. "
#~ "@basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @frequency is other than 1, 2, or 4, YIELDDISC returns #NUM! error.\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis is not in between 0 and 4, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=ERTRAG\n"
#~ "@SYNTAX=ERTRAG(settle,mat,rate,price,redemption_price,Häufigkeit[,"
#~ "Basis])\n"
#~ "@DESCRIPTION=ERTRAG liefert den Ertrag auf eine Sicherheit, die einen "
#~ "periodischen Zins abwirft.\n"
#~ "\n"
#~ "@Häufigkeit ist die Anzahl der Kupon-Zahlungen pro Jahr. Zulässige Werte "
#~ "sind: 1 = jährlich, 2 = halbjährlich, 4 = vierteljährlich.\n"
#~ "@Basis ist der Typ des zur Tagesberechnung verwendeten Systems:\n"
#~ "\n"
#~ "  0  MSRB 30/360 (MSRB Regel G33 (e))\n"
#~ "  1  Tatsächliche Tage/Tatsächliche Tage\n"
#~ "  2  Tatsächliche Tage/360\n"
#~ "  3  Tatsächliche Tage/365\n"
#~ "  4  Europäisch 30/360\n"
#~ "  5  Europäisch + 30/360\n"
#~ "\n"
#~ "* Falls @Häufigkeit weder 1, noch 2, 4 oder ungültig ist, liefert ERTRAG "
#~ "einen #ZAHL!-Fehler.\n"
#~ "* Falls @Basis nicht übergeben wird, wird MSRB 30/360 angenommen.\n"
#~ "* Falls @Basis nicht zwischen 0 und 4 liegt, liefert ERTRAG einen #ZAHL!-"
#~ "Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=YIELDMAT\n"
#~ "@SYNTAX=YIELDMAT(settlement,maturity,issue,rate,pr[,basis])\n"
#~ "@DESCRIPTION=YIELDMAT calculates the annual yield of a security for which "
#~ "the interest is paid at maturity date.\n"
#~ "\n"
#~ "@settlement is the settlement date of the security. @maturity is the "
#~ "maturity date of the security. @issue is the issue date of the security. "
#~ "@rate is the interest rate set to the security. @pr is the price per $100 "
#~ "face value of the security. @basis is the type of day counting system you "
#~ "want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis is not in between 0 and 4, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=ERTRAG\n"
#~ "@SYNTAX=ERTRAG(settle,mat,rate,price,redemption_price,Häufigkeit[,"
#~ "Basis])\n"
#~ "@DESCRIPTION=ERTRAG liefert den Ertrag auf eine Sicherheit, die einen "
#~ "periodischen Zins abwirft.\n"
#~ "\n"
#~ "@Häufigkeit ist die Anzahl der Kupon-Zahlungen pro Jahr. Zulässige Werte "
#~ "sind: 1 = jährlich, 2 = halbjährlich, 4 = vierteljährlich.\n"
#~ "@Basis ist der Typ des zur Tagesberechnung verwendeten Systems:\n"
#~ "\n"
#~ "  0  MSRB 30/360 (MSRB Regel G33 (e))\n"
#~ "  1  Tatsächliche Tage/Tatsächliche Tage\n"
#~ "  2  Tatsächliche Tage/360\n"
#~ "  3  Tatsächliche Tage/365\n"
#~ "  4  Europäisch 30/360\n"
#~ "  5  Europäisch + 30/360\n"
#~ "\n"
#~ "* Falls @Häufigkeit weder 1, noch 2, 4 oder ungültig ist, liefert ERTRAG "
#~ "einen #ZAHL!-Fehler.\n"
#~ "* Falls @Basis nicht übergeben wird, wird MSRB 30/360 angenommen.\n"
#~ "* Falls @Basis nicht zwischen 0 und 4 liegt, liefert ERTRAG einen #ZAHL!-"
#~ "Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=ODDFPRICE\n"
#~ "@SYNTAX=ODDFPRICE(settlement,maturity,issue,first_coupon,rate,yld,"
#~ "redemption,frequency[,basis])\n"
#~ "@DESCRIPTION=ODDFPRICE returns the price per $100 face value of a "
#~ "security. The security should have an odd short or long first period.\n"
#~ "\n"
#~ "@settlement is the settlement date of the security. @maturity is the "
#~ "maturity date of the security. @issue is the issue date of the security. "
#~ "@frequency is the number of coupon payments per year. Allowed frequencies "
#~ "are: 1 = annual, 2 = semi, 4 = quarterly. @basis is the type of day "
#~ "counting system you want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @frequency is other than 1, 2, or 4, ODDFPRICE returns #NUM! error.\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis is not in between 0 and 4, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=ERTRAG\n"
#~ "@SYNTAX=ERTRAG(settle,mat,rate,price,redemption_price,Häufigkeit[,"
#~ "Basis])\n"
#~ "@DESCRIPTION=ERTRAG liefert den Ertrag auf eine Sicherheit, die einen "
#~ "periodischen Zins abwirft.\n"
#~ "\n"
#~ "@Häufigkeit ist die Anzahl der Kupon-Zahlungen pro Jahr. Zulässige Werte "
#~ "sind: 1 = jährlich, 2 = halbjährlich, 4 = vierteljährlich.\n"
#~ "@Basis ist der Typ des zur Tagesberechnung verwendeten Systems:\n"
#~ "\n"
#~ "  0  MSRB 30/360 (MSRB Regel G33 (e))\n"
#~ "  1  Tatsächliche Tage/Tatsächliche Tage\n"
#~ "  2  Tatsächliche Tage/360\n"
#~ "  3  Tatsächliche Tage/365\n"
#~ "  4  Europäisch 30/360\n"
#~ "  5  Europäisch + 30/360\n"
#~ "\n"
#~ "* Falls @Häufigkeit weder 1, noch 2, 4 oder ungültig ist, liefert ERTRAG "
#~ "einen #ZAHL!-Fehler.\n"
#~ "* Falls @Basis nicht übergeben wird, wird MSRB 30/360 angenommen.\n"
#~ "* Falls @Basis nicht zwischen 0 und 4 liegt, liefert ERTRAG einen #ZAHL!-"
#~ "Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=ODDFYIELD\n"
#~ "@SYNTAX=ODDFYIELD(settlement,maturity,issue,first_coupon,rate,pr,"
#~ "redemption,frequency[,basis])\n"
#~ "@DESCRIPTION=ODDFYIELD calculates the yield of a security having an odd "
#~ "first period.\n"
#~ "\n"
#~ "@settlement is the settlement date of the security. @maturity is the "
#~ "maturity date of the security. @frequency is the number of coupon "
#~ "payments per year. Allowed frequencies are: 1 = annual, 2 = semi, 4 = "
#~ "quarterly. @basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @frequency is other than 1, 2, or 4, ODDFYIELD returns #NUM! error.\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis is not in between 0 and 4, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=ERTRAG\n"
#~ "@SYNTAX=ERTRAG(settle,mat,rate,price,redemption_price,Häufigkeit[,"
#~ "Basis])\n"
#~ "@DESCRIPTION=ERTRAG liefert den Ertrag auf eine Sicherheit, die einen "
#~ "periodischen Zins abwirft.\n"
#~ "\n"
#~ "@Häufigkeit ist die Anzahl der Kupon-Zahlungen pro Jahr. Zulässige Werte "
#~ "sind: 1 = jährlich, 2 = halbjährlich, 4 = vierteljährlich.\n"
#~ "@Basis ist der Typ des zur Tagesberechnung verwendeten Systems:\n"
#~ "\n"
#~ "  0  MSRB 30/360 (MSRB Regel G33 (e))\n"
#~ "  1  Tatsächliche Tage/Tatsächliche Tage\n"
#~ "  2  Tatsächliche Tage/360\n"
#~ "  3  Tatsächliche Tage/365\n"
#~ "  4  Europäisch 30/360\n"
#~ "  5  Europäisch + 30/360\n"
#~ "\n"
#~ "* Falls @Häufigkeit weder 1, noch 2, 4 oder ungültig ist, liefert ERTRAG "
#~ "einen #ZAHL!-Fehler.\n"
#~ "* Falls @Basis nicht übergeben wird, wird MSRB 30/360 angenommen.\n"
#~ "* Falls @Basis nicht zwischen 0 und 4 liegt, liefert ERTRAG einen #ZAHL!-"
#~ "Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=ODDLPRICE\n"
#~ "@SYNTAX=ODDLPRICE(settlement,maturity,last_interest,rate,yld,redemption,"
#~ "frequency[,basis])\n"
#~ "@DESCRIPTION=ODDLPRICE calculates the price per $100 face value of a "
#~ "security that has an odd last coupon period.\n"
#~ "\n"
#~ "@settlement is the settlement date of the security. @maturity is the "
#~ "maturity date of the security. @frequency is the number of coupon "
#~ "payments per year. Allowed frequencies are: 1 = annual, 2 = semi, 4 = "
#~ "quarterly. @basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @frequency is other than 1, 2, or 4, ODDLPRICE returns #NUM! error.\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis is not in between 0 and 4, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=ERTRAG\n"
#~ "@SYNTAX=ERTRAG(settle,mat,rate,price,redemption_price,Häufigkeit[,"
#~ "Basis])\n"
#~ "@DESCRIPTION=ERTRAG liefert den Ertrag auf eine Sicherheit, die einen "
#~ "periodischen Zins abwirft.\n"
#~ "\n"
#~ "@Häufigkeit ist die Anzahl der Kupon-Zahlungen pro Jahr. Zulässige Werte "
#~ "sind: 1 = jährlich, 2 = halbjährlich, 4 = vierteljährlich.\n"
#~ "@Basis ist der Typ des zur Tagesberechnung verwendeten Systems:\n"
#~ "\n"
#~ "  0  MSRB 30/360 (MSRB Regel G33 (e))\n"
#~ "  1  Tatsächliche Tage/Tatsächliche Tage\n"
#~ "  2  Tatsächliche Tage/360\n"
#~ "  3  Tatsächliche Tage/365\n"
#~ "  4  Europäisch 30/360\n"
#~ "  5  Europäisch + 30/360\n"
#~ "\n"
#~ "* Falls @Häufigkeit weder 1, noch 2, 4 oder ungültig ist, liefert ERTRAG "
#~ "einen #ZAHL!-Fehler.\n"
#~ "* Falls @Basis nicht übergeben wird, wird MSRB 30/360 angenommen.\n"
#~ "* Falls @Basis nicht zwischen 0 und 4 liegt, liefert ERTRAG einen #ZAHL!-"
#~ "Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=ODDLYIELD\n"
#~ "@SYNTAX=ODDLYIELD(settlement,maturity,last_interest,rate,pr,redemption,"
#~ "frequency[,basis])\n"
#~ "@DESCRIPTION=ODDLYIELD calculates the yield of a security having an odd "
#~ "last period.\n"
#~ "\n"
#~ "@settlement is the settlement date of the security. @maturity is the "
#~ "maturity date of the security. @frequency is the number of coupon "
#~ "payments per year. Allowed frequencies are: 1 = annual, 2 = semi, 4 = "
#~ "quarterly. @basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @frequency is other than 1, 2, or 4, ODDLYIELD returns #NUM! error.\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis is not in between 0 and 4, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=ERTRAG\n"
#~ "@SYNTAX=ERTRAG(settle,mat,rate,price,redemption_price,Häufigkeit[,"
#~ "Basis])\n"
#~ "@DESCRIPTION=ERTRAG liefert den Ertrag auf eine Sicherheit, die einen "
#~ "periodischen Zins abwirft.\n"
#~ "\n"
#~ "@Häufigkeit ist die Anzahl der Kupon-Zahlungen pro Jahr. Zulässige Werte "
#~ "sind: 1 = jährlich, 2 = halbjährlich, 4 = vierteljährlich.\n"
#~ "@Basis ist der Typ des zur Tagesberechnung verwendeten Systems:\n"
#~ "\n"
#~ "  0  MSRB 30/360 (MSRB Regel G33 (e))\n"
#~ "  1  Tatsächliche Tage/Tatsächliche Tage\n"
#~ "  2  Tatsächliche Tage/360\n"
#~ "  3  Tatsächliche Tage/365\n"
#~ "  4  Europäisch 30/360\n"
#~ "  5  Europäisch + 30/360\n"
#~ "\n"
#~ "* Falls @Häufigkeit weder 1, noch 2, 4 oder ungültig ist, liefert ERTRAG "
#~ "einen #ZAHL!-Fehler.\n"
#~ "* Falls @Basis nicht übergeben wird, wird MSRB 30/360 angenommen.\n"
#~ "* Falls @Basis nicht zwischen 0 und 4 liegt, liefert ERTRAG einen #ZAHL!-"
#~ "Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=AMORDEGRC\n"
#~ "@SYNTAX=AMORDEGRC(cost,purchase_date,first_period,salvage,period,rate[,"
#~ "basis])\n"
#~ "@DESCRIPTION=AMORDEGRC: Calculates depreciation for each accounting "
#~ "period using French accounting conventions.   Assets purchased in the "
#~ "middle of a period take prorated depreciation into account.  This is "
#~ "similar to AMORLINC, except that a depreciation coefficient is applied in "
#~ "the calculation depending on the life of the assets.\n"
#~ "Named for AMORtissement DEGRessif Comptabilite\n"
#~ "\n"
#~ "@cost The value of the asset.\n"
#~ "@purchase_date The date the asset was purchased.\n"
#~ "@first_period The end of the first period.\n"
#~ "@salvage Asset value at maturity.\n"
#~ "@period The length of accounting periods.\n"
#~ "@rate rate of depreciation as a percentage.\n"
#~ "@basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis is not in between 0 and 4, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "AMORDEGRC(2400,DATE(1998,8,19),DATE(1998,12,30),300,1,0.14,1) = 733\n"
#~ "\n"
#~ "@SEEALSO=AMORLINC"
#~ msgstr ""
#~ "@FUNCTION=ERTRAG\n"
#~ "@SYNTAX=ERTRAG(settle,mat,rate,price,redemption_price,Häufigkeit[,"
#~ "Basis])\n"
#~ "@DESCRIPTION=ERTRAG liefert den Ertrag auf eine Sicherheit, die einen "
#~ "periodischen Zins abwirft.\n"
#~ "\n"
#~ "@Häufigkeit ist die Anzahl der Kupon-Zahlungen pro Jahr. Zulässige Werte "
#~ "sind: 1 = jährlich, 2 = halbjährlich, 4 = vierteljährlich.\n"
#~ "@Basis ist der Typ des zur Tagesberechnung verwendeten Systems:\n"
#~ "\n"
#~ "  0  MSRB 30/360 (MSRB Regel G33 (e))\n"
#~ "  1  Tatsächliche Tage/Tatsächliche Tage\n"
#~ "  2  Tatsächliche Tage/360\n"
#~ "  3  Tatsächliche Tage/365\n"
#~ "  4  Europäisch 30/360\n"
#~ "  5  Europäisch + 30/360\n"
#~ "\n"
#~ "* Falls @Häufigkeit weder 1, noch 2, 4 oder ungültig ist, liefert ERTRAG "
#~ "einen #ZAHL!-Fehler.\n"
#~ "* Falls @Basis nicht übergeben wird, wird MSRB 30/360 angenommen.\n"
#~ "* Falls @Basis nicht zwischen 0 und 4 liegt, liefert ERTRAG einen #ZAHL!-"
#~ "Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=AMORLINC\n"
#~ "@SYNTAX=AMORLINC(cost,purchase_date,first_period,salvage,period,rate[,"
#~ "basis])\n"
#~ "@DESCRIPTION=AMORLINC: Calculates depreciation for each accounting period "
#~ "using French accounting conventions.   Assets purchased in the middle of "
#~ "a period take prorated depreciation into account.\n"
#~ "Named for AMORtissement LINeaire Comptabilite.\n"
#~ "\n"
#~ "@cost The value of the asset.\n"
#~ "@purchase_date The date the asset was purchased.\n"
#~ "@first_period The end of the first period.\n"
#~ "@salvage Asset value at maturity.\n"
#~ "@period The length of accounting periods.\n"
#~ "@rate rate of depreciation as a percentage.\n"
#~ "@basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis is not in between 0 and 4, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "AMORLINC(2400,DATE(1998,8,19),DATE(1998,12,31),300,1,0.15,1) = 360\n"
#~ "\n"
#~ "@SEEALSO=AMORDEGRC"
#~ msgstr ""
#~ "@FUNCTION=ERTRAG\n"
#~ "@SYNTAX=ERTRAG(settle,mat,rate,price,redemption_price,Häufigkeit[,"
#~ "Basis])\n"
#~ "@DESCRIPTION=ERTRAG liefert den Ertrag auf eine Sicherheit, die einen "
#~ "periodischen Zins abwirft.\n"
#~ "\n"
#~ "@Häufigkeit ist die Anzahl der Kupon-Zahlungen pro Jahr. Zulässige Werte "
#~ "sind: 1 = jährlich, 2 = halbjährlich, 4 = vierteljährlich.\n"
#~ "@Basis ist der Typ des zur Tagesberechnung verwendeten Systems:\n"
#~ "\n"
#~ "  0  MSRB 30/360 (MSRB Regel G33 (e))\n"
#~ "  1  Tatsächliche Tage/Tatsächliche Tage\n"
#~ "  2  Tatsächliche Tage/360\n"
#~ "  3  Tatsächliche Tage/365\n"
#~ "  4  Europäisch 30/360\n"
#~ "  5  Europäisch + 30/360\n"
#~ "\n"
#~ "* Falls @Häufigkeit weder 1, noch 2, 4 oder ungültig ist, liefert ERTRAG "
#~ "einen #ZAHL!-Fehler.\n"
#~ "* Falls @Basis nicht übergeben wird, wird MSRB 30/360 angenommen.\n"
#~ "* Falls @Basis nicht zwischen 0 und 4 liegt, liefert ERTRAG einen #ZAHL!-"
#~ "Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=COUPDAYBS\n"
#~ "@SYNTAX=COUPDAYBS(settlement,maturity,frequency[,basis,eom])\n"
#~ "@DESCRIPTION=COUPDAYBS returns the number of days from the beginning of "
#~ "the coupon period to the settlement date.\n"
#~ "\n"
#~ "@settlement is the settlement date of the security.\n"
#~ "@maturity is the maturity date of the security.\n"
#~ "@frequency is the number of coupon payments per year.\n"
#~ "@eom = TRUE handles end of month maturity dates special.\n"
#~ "Allowed frequencies are: 1 = annual, 2 = semi, 4 = quarterly, 6 = "
#~ "bimonthly, 12 = monthly.\n"
#~ "@basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  MSRB 30/360 (MSRB Rule G33 (e))\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "  5  European+ 30/360\n"
#~ "\n"
#~ "(See the gnumeric manual for a detailed description of these bases).\n"
#~ "\n"
#~ "* If @frequency is invalid, COUPDAYBS returns #NUM! error.\n"
#~ "* If @basis is omitted, MSRB 30/360 is applied.\n"
#~ "* If @basis is invalid, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COUPDAYBS (DATE(2002,11,29),DATE(2004,2,29),4,0) = 89\n"
#~ "COUPDAYBS (DATE(2002,11,29),DATE(2004,2,29),4,0,FALSE) = 0\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=KUPTAGENK\n"
#~ "@SYNTAX=KUPTAGENK(Abrechnung,Fälligkeit,Häufigkeit[,Basis,EdM])\n"
#~ "@DESCRIPTION=KUPTAGENK liefert die Anzahl der Tage vom Abrechnungsdatum "
#~ "bis zum Datum des nächsten Kupons.\n"
#~ "\n"
#~ "@Abrechnung ist das Abrechnungsdatum der Sicherheit.\n"
#~ "@Fälligkeit ist das Fälligkeitsdatum der Sicherheit.\n"
#~ "@Häufigkeit ist die Anzahl der Kuponzahlungen pro Jahr.\n"
#~ "@EdM = WAHR führt zu einer speziellen Handhabung des Monatsendes.\n"
#~ "Zulässige Werte für @Häufigkeit: 1 = jährlich, 2 = halbjährlich, 4 = "
#~ "vierteljährlich. 6 = zweimonatlich, 12 = monatlich.\n"
#~ "@Basis ist der Typ des zur Tagesberechnung verwendeten Systems:\n"
#~ "\n"
#~ "  0  MSRB 30/360 (MSRB Regel G33 (e))\n"
#~ "  1  Tatsächliche Tage/Tatsächliche Tage\n"
#~ "  2  Tatsächliche Tage/360\n"
#~ "  3  Tatsächliche Tage/365\n"
#~ "  4  Europäisch 30/360\n"
#~ "  5  Europäisch + 30/360\n"
#~ "\n"
#~ "* Falls @Häufigkeit ungültig ist, liefert KUPTAGENK einen #ZAHL!-Fehler.\n"
#~ "* Falls @Basis nicht übergeben wird, wird MSRB 30/360 angenommen.\n"
#~ "* Falls @Basis ungültig ist, liefert KUPTAGENK einen #ZAHL!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COUPDAYSNC (DATE(2002,11,29),DATE(2004,2,29),4,0) = 1\n"
#~ "COUPDAYSNC (DATE(2002,11,29),DATE(2004,2,29),4,0,FALSE) = 89\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=COUPDAYS\n"
#~ "@SYNTAX=COUPDAYS(settlement,maturity,frequency[,basis,eom])\n"
#~ "@DESCRIPTION=COUPDAYS returns the number of days in the coupon period of "
#~ "the settlement date.\n"
#~ "\n"
#~ "@settlement is the settlement date of the security.\n"
#~ "@maturity is the maturity date of the security.\n"
#~ "@frequency is the number of coupon payments per year.\n"
#~ "@eom = TRUE handles end of month maturity dates special.\n"
#~ "Allowed frequencies are: 1 = annual, 2 = semi, 4 = quarterly, 6 = "
#~ "bimonthly, 12 = monthly.\n"
#~ "@basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  MSRB 30/360 (MSRB Rule G33 (e))\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "  5  European+ 30/360\n"
#~ "\n"
#~ "(See the gnumeric manual for a detailed description of these bases).\n"
#~ "\n"
#~ "* If @frequency is invalid, COUPDAYS returns #NUM! error.\n"
#~ "* If @basis is omitted, MSRB 30/360 is applied.\n"
#~ "* If @basis is invalid, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COUPDAYS (DATE(2002,11,29),DATE(2004,2,29),4,0) = 90\n"
#~ "COUPDAYS (DATE(2002,11,29),DATE(2004,2,29),4,0,FALSE) = 90\n"
#~ "COUPDAYS (DATE(2002,11,29),DATE(2004,2,29),4,1,FALSE) = 91\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=KUPTAGE\n"
#~ "@SYNTAX=KUPTAGE(Abrechnung,Fälligkeit,Häufigkeit[,Basis,EdM])\n"
#~ "@DESCRIPTION=KUPTAGE liefert die Anzahl der Tage in der Kuponperiode des "
#~ "Abrechnungsdatums.\n"
#~ "\n"
#~ "@Abrechnung ist das Abrechnungsdatum der Sicherheit.\n"
#~ "@Fälligkeit ist das Fälligkeitsdatum der Sicherheit.\n"
#~ "@Häufigkeit ist die Anzahl der Kuponzahlungen pro Jahr.\n"
#~ "@EdM = WAHR führt zu einer speziellen Handhabung des Monatsendes.\n"
#~ "Zulässige Werte für @Häufigkeit: 1 = jährlich, 2 = halbjährlich, 4 = "
#~ "vierteljährlich. 6 = zweimonatlich, 12 = monatlich.\n"
#~ "@Basis ist der Typ des zur Tagesberechnung verwendeten Systems:\n"
#~ "\n"
#~ "  0  MSRB 30/360 (MSRB Regel G33 (e))\n"
#~ "  1  Tatsächliche Tage/Tatsächliche Tage\n"
#~ "  2  Tatsächliche Tage/360\n"
#~ "  3  Tatsächliche Tage/365\n"
#~ "  4  Europäisch 30/360\n"
#~ "  5  Europäisch + 30/360\n"
#~ "\n"
#~ "* Falls @Häufigkeit ungültig ist, liefert KUPTAGE einen #ZAHL!-Fehler.\n"
#~ "* Falls @Basis nicht übergeben wird, wird MSRB 30/360 angenommen.\n"
#~ "* Falls @Basis ungültig ist, liefert KUPTAGE einen #ZAHL!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "KUPTAGE(DATUM(2002,11,29),DATUM(2004,2,29),4,0) liefert 90\n"
#~ "KUPTAGE(DATUM(2002,11,29),DATUM(2004,2,29),4,0,FALSCH) liefert 90\n"
#~ "KUPTAGE(DATUM(2002,11,29),DATUM(2004,2,29),4,1,FALSCH) liefert 91\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=COUPDAYSNC\n"
#~ "@SYNTAX=COUPDAYSNC(settlement,maturity,frequency[,basis,eom])\n"
#~ "@DESCRIPTION=COUPDAYSNC returns the number of days from the settlement "
#~ "date to the next coupon date.\n"
#~ "\n"
#~ "@settlement is the settlement date of the security.\n"
#~ "@maturity is the maturity date of the security.\n"
#~ "@frequency is the number of coupon payments per year.\n"
#~ "@eom = TRUE handles end of month maturity dates special.\n"
#~ "Allowed frequencies are: 1 = annual, 2 = semi, 4 = quarterly, 6 = "
#~ "bimonthly, 12 = monthly.\n"
#~ "@basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  MSRB 30/360 (MSRB Rule G33 (e))\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "  5  European+ 30/360\n"
#~ "\n"
#~ "(See the gnumeric manual for a detailed description of these bases).\n"
#~ "\n"
#~ "* If @frequency is invalid, COUPDAYSNC returns #NUM! error.\n"
#~ "* If @basis is omitted, MSRB 30/360 is applied.\n"
#~ "* If @basis is invalid, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COUPDAYSNC (DATE(2002,11,29),DATE(2004,2,29),4,0) = 1\n"
#~ "COUPDAYSNC (DATE(2002,11,29),DATE(2004,2,29),4,0,FALSE) = 89\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=KUPTAGENK\n"
#~ "@SYNTAX=KUPTAGENK(Abrechnung,Fälligkeit,Häufigkeit[,Basis,EdM])\n"
#~ "@DESCRIPTION=KUPTAGENK liefert die Anzahl der Tage vom Abrechnungsdatum "
#~ "bis zum Datum des nächsten Kupons.\n"
#~ "\n"
#~ "@Abrechnung ist das Abrechnungsdatum der Sicherheit.\n"
#~ "@Fälligkeit ist das Fälligkeitsdatum der Sicherheit.\n"
#~ "@Häufigkeit ist die Anzahl der Kuponzahlungen pro Jahr.\n"
#~ "@EdM = WAHR führt zu einer speziellen Handhabung des Monatsendes.\n"
#~ "Zulässige Werte für @Häufigkeit: 1 = jährlich, 2 = halbjährlich, 4 = "
#~ "vierteljährlich. 6 = zweimonatlich, 12 = monatlich.\n"
#~ "@Basis ist der Typ des zur Tagesberechnung verwendeten Systems:\n"
#~ "\n"
#~ "  0  MSRB 30/360 (MSRB Regel G33 (e))\n"
#~ "  1  Tatsächliche Tage/Tatsächliche Tage\n"
#~ "  2  Tatsächliche Tage/360\n"
#~ "  3  Tatsächliche Tage/365\n"
#~ "  4  Europäisch 30/360\n"
#~ "  5  Europäisch + 30/360\n"
#~ "\n"
#~ "* Falls @Häufigkeit ungültig ist, liefert KUPTAGENK einen #ZAHL!-Fehler.\n"
#~ "* Falls @Basis nicht übergeben wird, wird MSRB 30/360 angenommen.\n"
#~ "* Falls @Basis ungültig ist, liefert KUPTAGENK einen #ZAHL!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COUPDAYSNC (DATE(2002,11,29),DATE(2004,2,29),4,0) = 1\n"
#~ "COUPDAYSNC (DATE(2002,11,29),DATE(2004,2,29),4,0,FALSE) = 89\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=COUPNCD\n"
#~ "@SYNTAX=COUPNCD(settlement,maturity,frequency[,basis,eom])\n"
#~ "@DESCRIPTION=COUPNCD returns the coupon date following settlement.\n"
#~ "\n"
#~ "@settlement is the settlement date of the security.\n"
#~ "@maturity is the maturity date of the security.\n"
#~ "@frequency is the number of coupon payments per year.\n"
#~ "@eom = TRUE handles end of month maturity dates special.\n"
#~ "Allowed frequencies are: 1 = annual, 2 = semi, 4 = quarterly, 6 = "
#~ "bimonthly, 12 = monthly.\n"
#~ "@basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  MSRB 30/360 (MSRB Rule G33 (e))\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "  5  European+ 30/360\n"
#~ "\n"
#~ "(See the gnumeric manual for a detailed description of these bases).\n"
#~ "\n"
#~ "* If @frequency is invalid, COUPNCD returns #NUM! error.\n"
#~ "* If @basis is omitted, MSRB 30/360 is applied.\n"
#~ "* If @basis is invalid, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COUPNCD (DATE(2002,11,29),DATE(2004,2,29),4,0) = 30-Nov-2002\n"
#~ "COUPNCD (DATE(2002,11,29),DATE(2004,2,29),4,0,FALSE) = 28-Feb-2003\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=KUPTAGENK\n"
#~ "@SYNTAX=KUPTAGENK(Abrechnung,Fälligkeit,Häufigkeit[,Basis,EdM])\n"
#~ "@DESCRIPTION=KUPTAGENK liefert die Anzahl der Tage vom Abrechnungsdatum "
#~ "bis zum Datum des nächsten Kupons.\n"
#~ "\n"
#~ "@Abrechnung ist das Abrechnungsdatum der Sicherheit.\n"
#~ "@Fälligkeit ist das Fälligkeitsdatum der Sicherheit.\n"
#~ "@Häufigkeit ist die Anzahl der Kuponzahlungen pro Jahr.\n"
#~ "@EdM = WAHR führt zu einer speziellen Handhabung des Monatsendes.\n"
#~ "Zulässige Werte für @Häufigkeit: 1 = jährlich, 2 = halbjährlich, 4 = "
#~ "vierteljährlich. 6 = zweimonatlich, 12 = monatlich.\n"
#~ "@Basis ist der Typ des zur Tagesberechnung verwendeten Systems:\n"
#~ "\n"
#~ "  0  MSRB 30/360 (MSRB Regel G33 (e))\n"
#~ "  1  Tatsächliche Tage/Tatsächliche Tage\n"
#~ "  2  Tatsächliche Tage/360\n"
#~ "  3  Tatsächliche Tage/365\n"
#~ "  4  Europäisch 30/360\n"
#~ "  5  Europäisch + 30/360\n"
#~ "\n"
#~ "* Falls @Häufigkeit ungültig ist, liefert KUPTAGENK einen #ZAHL!-Fehler.\n"
#~ "* Falls @Basis nicht übergeben wird, wird MSRB 30/360 angenommen.\n"
#~ "* Falls @Basis ungültig ist, liefert KUPTAGENK einen #ZAHL!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COUPDAYSNC (DATE(2002,11,29),DATE(2004,2,29),4,0) = 1\n"
#~ "COUPDAYSNC (DATE(2002,11,29),DATE(2004,2,29),4,0,FALSE) = 89\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=COUPPCD\n"
#~ "@SYNTAX=COUPPCD(settlement,maturity,frequency[,basis,eom])\n"
#~ "@DESCRIPTION=COUPPCD returns the coupon date preceding settlement.\n"
#~ "\n"
#~ "@settlement is the settlement date of the security.\n"
#~ "@maturity is the maturity date of the security.\n"
#~ "@frequency is the number of coupon payments per year.\n"
#~ "@eom = TRUE handles end of month maturity dates special.\n"
#~ "Allowed frequencies are: 1 = annual, 2 = semi, 4 = quarterly, 6 = "
#~ "bimonthly, 12 = monthly.\n"
#~ "@basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  MSRB 30/360 (MSRB Rule G33 (e))\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "  5  European+ 30/360\n"
#~ "\n"
#~ "(See the gnumeric manual for a detailed description of these bases).\n"
#~ "\n"
#~ "* If @frequency is invalid, COUPPCD returns #NUM! error.\n"
#~ "* If @basis is omitted, MSRB 30/360 is applied.\n"
#~ "* If @basis is invalid, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COUPPCD (DATE(2002,11,29),DATE(2004,2,29),4,0) = 31-Aug-2002\n"
#~ "COUPPCD (DATE(2002,11,29),DATE(2004,2,29),4,0,FALSE) = 29-Nov-2002\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=KUPTAGENK\n"
#~ "@SYNTAX=KUPTAGENK(Abrechnung,Fälligkeit,Häufigkeit[,Basis,EdM])\n"
#~ "@DESCRIPTION=KUPTAGENK liefert die Anzahl der Tage vom Abrechnungsdatum "
#~ "bis zum Datum des nächsten Kupons.\n"
#~ "\n"
#~ "@Abrechnung ist das Abrechnungsdatum der Sicherheit.\n"
#~ "@Fälligkeit ist das Fälligkeitsdatum der Sicherheit.\n"
#~ "@Häufigkeit ist die Anzahl der Kuponzahlungen pro Jahr.\n"
#~ "@EdM = WAHR führt zu einer speziellen Handhabung des Monatsendes.\n"
#~ "Zulässige Werte für @Häufigkeit: 1 = jährlich, 2 = halbjährlich, 4 = "
#~ "vierteljährlich. 6 = zweimonatlich, 12 = monatlich.\n"
#~ "@Basis ist der Typ des zur Tagesberechnung verwendeten Systems:\n"
#~ "\n"
#~ "  0  MSRB 30/360 (MSRB Regel G33 (e))\n"
#~ "  1  Tatsächliche Tage/Tatsächliche Tage\n"
#~ "  2  Tatsächliche Tage/360\n"
#~ "  3  Tatsächliche Tage/365\n"
#~ "  4  Europäisch 30/360\n"
#~ "  5  Europäisch + 30/360\n"
#~ "\n"
#~ "* Falls @Häufigkeit ungültig ist, liefert KUPTAGENK einen #ZAHL!-Fehler.\n"
#~ "* Falls @Basis nicht übergeben wird, wird MSRB 30/360 angenommen.\n"
#~ "* Falls @Basis ungültig ist, liefert KUPTAGENK einen #ZAHL!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COUPDAYSNC (DATE(2002,11,29),DATE(2004,2,29),4,0) = 1\n"
#~ "COUPDAYSNC (DATE(2002,11,29),DATE(2004,2,29),4,0,FALSE) = 89\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=COUPNUM\n"
#~ "@SYNTAX=COUPNUM(settlement,maturity,frequency[,basis,eom])\n"
#~ "@DESCRIPTION=COUPNUM returns the numbers of coupons to be paid between "
#~ "the settlement and maturity dates, rounded up.\n"
#~ "\n"
#~ "@settlement is the settlement date of the security.\n"
#~ "@maturity is the maturity date of the security.\n"
#~ "@frequency is the number of coupon payments per year.\n"
#~ "@eom = TRUE handles end of month maturity dates special.\n"
#~ "Allowed frequencies are: 1 = annual, 2 = semi, 4 = quarterly. 6 = "
#~ "bimonthly, 12 = monthly.\n"
#~ "@basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  MSRB 30/360 (MSRB Rule G33 (e))\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "  5  European+ 30/360\n"
#~ "\n"
#~ "* If @frequency is other than 1, 2, 4, 6 or 12, COUPNUM returns #NUM! "
#~ "error.\n"
#~ "* If @basis is omitted, MSRB 30/360 is applied.\n"
#~ "* If @basis is not in between 0 and 5, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COUPNUM (DATE(2002,11,29),DATE(2004,2,29),4,0) = 6\n"
#~ "COUPNUM (DATE(2002,11,29),DATE(2004,2,29),4,0,FALSE) = 5\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=KUPANZAHL\n"
#~ "@SYNTAX=KUPANZAHL(Abrechnung,Fälligkeit,Häufigkeit[,Basis,EdM])\n"
#~ "@DESCRIPTION=KUPANZAHL liefert die zwischen den Abrechnungs- und dem "
#~ "Fälligkeitsdata zu zahlenden Kupons (aufgerundet).\n"
#~ "\n"
#~ "@Abrechnung ist das Abrechnungsdatum der Sicherheit.\n"
#~ "@Fälligkeit ist das Fälligkeitsdatum der Sicherheit.\n"
#~ "@Häufigkeit ist die Anzahl der Kuponzahlungen pro Jahr.\n"
#~ "@EdM = WAHR führt zu einer speziellen Handhabung des Monatsendes.\n"
#~ "Zulässige Werte für @Häufigkeit: 1 = jährlich, 2 = halbjährlich, 4 = "
#~ "vierteljährlich. 6 = zweimonatlich, 12 = monatlich.\n"
#~ "@Basis ist der Typ des zur Tagesberechnung verwendeten Systems:\n"
#~ "\n"
#~ "  0  MSRB 30/360 (MSRB Regel G33 (e))\n"
#~ "  1  Tatsächliche Tage/Tatsächliche Tage\n"
#~ "  2  Tatsächliche Tage/360\n"
#~ "  3  Tatsächliche Tage/365\n"
#~ "  4  Europäisch 30/360\n"
#~ "  5  Europäisch + 30/360\n"
#~ "\n"
#~ "* Falls @Häufigkeit weder 1, noch 2 oder 4 ist, liefert KUPANZAHL einen "
#~ "#ZAHL!-Fehler.\n"
#~ "* Falls @Basis nicht übergeben wird, wird MSRB 30/360 angenommen.\n"
#~ "* Falls @Basis nicht zwischen 0 und 4 liegt, liefert KUPANZAHL einen "
#~ "#ZAHL!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "KUPANZAHL(DATUM(2002,11,29),DATUM(2004,2,29),4,0) liefert 6\n"
#~ "KUPANZAHL(DATUM(2002,11,29),DATUM(2004,2,29),4,0,FALSCH) liefert 5\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=CUM_BIV_NORM_DIST\n"
#~ "@SYNTAX=CUM_BIV_NORM_DIST(a,b,rho)\n"
#~ "@DESCRIPTION=CUM_BIV_NORM_DIST calculates the cumulative bivariate normal "
#~ "distribution from parameters a, b & rho.\n"
#~ "The return value is the probability that two random variables with "
#~ "correlation @rho are respectively each less than @a and @b.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=NORMDIST,NORMSDIST,NORMSINV"
#~ msgstr ""
#~ "@FUNCTION=KUMBIVNORMVERT\n"
#~ "@SYNTAX=KUMBIVNORMVERT(a,b,Rho)\n"
#~ "@DESCRIPTION=KUMBIVNORMVERT berechnet die kumulative bivariate "
#~ "Normalverteilung aus den Parametern a, b und Rho. Der gelieferte Wert ist "
#~ "die Wahrscheinlichkeit, dass zwei Zufallsvariablen mit der Korrelation "
#~ "@Rho jeweils kleiner als @a und @b sind.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=NORMVERT,STANDNORMDIST,STANDNORMINV"

#~ msgid ""
#~ "@FUNCTION=OPT_BS\n"
#~ "@SYNTAX=OPT_BS(call_put_flag,spot,strike,time,rate,volatility [,"
#~ "cost_of_carry])\n"
#~ "@DESCRIPTION=OPT_BS uses the Black-Scholes model to calculate the price "
#~ "of a European option using call_put_flag, @call_put_flag, 'c' or 'p' "
#~ "struck at @strike on an asset with spot price @spot.\n"
#~ "@time is the time to maturity of the option expressed in years.\n"
#~ "@rate is the risk-free interest rate.\n"
#~ "@volatility is the annualized volatility, in percent, of the asset for "
#~ "the period through to the exercise date. \n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "* The returned value will be expressed in the same units as @strike and "
#~ "@spot.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_VEGA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_RGW\n"
#~ "@SYNTAX=OPT_RGW(Call_oder_Put,Kassapreis,Ausübungspreis,Laufzeit1,"
#~ "Laufzeit2,Kurs,d,Volatilität)\n"
#~ "@DESCRIPTION=OPT_RGW berechnet den theoretischen Preis einer Option nach "
#~ "der Roll-Geske-Whaley-Näherung.\n"
#~ "@Laufzeit1 ist die Zeit bis zur Auszahlung der Dividende\n"
#~ "@Laufzeit2 die Zeit bis zum Verfall der Option\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#~ msgid ""
#~ "@FUNCTION=OPT_BS_DELTA\n"
#~ "@SYNTAX=OPT_BS_DELTA(call_put_flag,spot,strike,time,rate,volatility[,"
#~ "cost_of_carry])\n"
#~ "@DESCRIPTION=OPT_BS_DELTA uses the Black-Scholes model to calculate the "
#~ "'delta' of a European option with call_put_flag, @call_put_flag, 'c' or "
#~ "'p' struck at @strike on an asset with spot price @spot.\n"
#~ "Where @time is the time to maturity of the option expressed in years.\n"
#~ "@rate is the risk-free interest rate.\n"
#~ "@volatility is the annualized volatility, in percent, of the asset for "
#~ "the period through to the exercise date. \n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "* The returned value will be expressed in the same units as @strike and "
#~ "@spot.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_VEGA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_RGW\n"
#~ "@SYNTAX=OPT_RGW(Call_oder_Put,Kassapreis,Ausübungspreis,Laufzeit1,"
#~ "Laufzeit2,Kurs,d,Volatilität)\n"
#~ "@DESCRIPTION=OPT_RGW berechnet den theoretischen Preis einer Option nach "
#~ "der Roll-Geske-Whaley-Näherung.\n"
#~ "@Laufzeit1 ist die Zeit bis zur Auszahlung der Dividende\n"
#~ "@Laufzeit2 die Zeit bis zum Verfall der Option\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#~ msgid ""
#~ "@FUNCTION=OPT_BS_GAMMA\n"
#~ "@SYNTAX=OPT_BS_GAMMA(spot,strike,time,rate,volatility[,cost_of_carry])\n"
#~ "@DESCRIPTION=OPT_BS_GAMMA uses the Black-Scholes model to calculate the "
#~ "'gamma' of a European option struck at @strike on an asset with spot "
#~ "price @spot.\n"
#~ "\n"
#~ "(The gamma of an option is the second derivative of its price with "
#~ "respect to the price of the underlying asset, and is the same for calls "
#~ "and puts.)\n"
#~ "\n"
#~ "@time is the time to maturity of the option expressed in years.\n"
#~ "@rate is the risk-free interest rate to the exercise date, in percent.\n"
#~ "@volatility is the annualized volatility, in percent, of the asset for "
#~ "the period through to the exercise date.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "* The returned value will be expressed as the rate of change of delta per "
#~ "unit change in @spot.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_VEGA"
#~ msgstr ""
#~ "@FUNCTION=OPT_RGW\n"
#~ "@SYNTAX=OPT_RGW(Call_oder_Put,Kassapreis,Ausübungspreis,Laufzeit1,"
#~ "Laufzeit2,Kurs,d,Volatilität)\n"
#~ "@DESCRIPTION=OPT_RGW berechnet den theoretischen Preis einer Option nach "
#~ "der Roll-Geske-Whaley-Näherung.\n"
#~ "@Laufzeit1 ist die Zeit bis zur Auszahlung der Dividende\n"
#~ "@Laufzeit2 die Zeit bis zum Verfall der Option\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#~ msgid ""
#~ "@FUNCTION=OPT_BS_THETA\n"
#~ "@SYNTAX=OPT_BS_THETA(call_put_flag,spot,strike,time,rate,volatility[,"
#~ "cost_of_carry])\n"
#~ "@DESCRIPTION=OPT_BS_THETA uses the Black-Scholes model to calculate the "
#~ "'theta' of a European option with call_put_flag, @call_put_flag struck at "
#~ "@strike on an asset with spot price @spot.\n"
#~ "\n"
#~ "(The theta of an option is the rate of change of its price with respect "
#~ "to time to expiry.)\n"
#~ "\n"
#~ "@time is the time to maturity of the option expressed in years\n"
#~ "and @rate is the risk-free interest rate to the exercise date, in "
#~ "percent.\n"
#~ "@volatility is the annualized volatility, in percent, of the asset for "
#~ "the period through to the exercise date.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "* The returned value will be expressed as minus the rate of change of "
#~ "option value, per 365.25 days.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_VEGA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_RGW\n"
#~ "@SYNTAX=OPT_RGW(Call_oder_Put,Kassapreis,Ausübungspreis,Laufzeit1,"
#~ "Laufzeit2,Kurs,d,Volatilität)\n"
#~ "@DESCRIPTION=OPT_RGW berechnet den theoretischen Preis einer Option nach "
#~ "der Roll-Geske-Whaley-Näherung.\n"
#~ "@Laufzeit1 ist die Zeit bis zur Auszahlung der Dividende\n"
#~ "@Laufzeit2 die Zeit bis zum Verfall der Option\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#~ msgid ""
#~ "@FUNCTION=OPT_BS_VEGA\n"
#~ "@SYNTAX=OPT_BS_VEGA(spot,strike,time,rate,volatility[,cost_of_carry])\n"
#~ "@DESCRIPTION=OPT_BS_VEGA uses the Black-Scholes model to calculate the "
#~ "'vega' of a European option struck at @strike on an asset with spot price "
#~ "@spot.\n"
#~ "(The vega of an option is the rate of change of its price with respect to "
#~ "volatility, and is the same for calls and puts.)\n"
#~ "@volatility is the annualized volatility, in percent, of the asset for "
#~ "the period through to the exercise date.\n"
#~ " @time is the time to maturity of the option expressed in years.\n"
#~ "@rate is the risk-free interest rate to the exercise date, in percent.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "\n"
#~ "* The returned value will be expressed as the rate of change of option "
#~ "value, per 100% volatility.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_RGW\n"
#~ "@SYNTAX=OPT_RGW(Call_oder_Put,Kassapreis,Ausübungspreis,Laufzeit1,"
#~ "Laufzeit2,Kurs,d,Volatilität)\n"
#~ "@DESCRIPTION=OPT_RGW berechnet den theoretischen Preis einer Option nach "
#~ "der Roll-Geske-Whaley-Näherung.\n"
#~ "@Laufzeit1 ist die Zeit bis zur Auszahlung der Dividende\n"
#~ "@Laufzeit2 die Zeit bis zum Verfall der Option\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#~ msgid ""
#~ "@FUNCTION=OPT_BS_RHO\n"
#~ "@SYNTAX=OPT_BS_RHO(call_put_flag,spot,strike,time,rate,volatility[,"
#~ "cost_of_carry])\n"
#~ "@DESCRIPTION=OPT_BS_RHO uses the Black-Scholes model to calculate the "
#~ "'rho' of a European option with call_put_flag, @call_put_flag struck at "
#~ "@strike on an asset with spot price @spot.\n"
#~ "@call_put_flag is 'c' or 'p' to indicate whether the option is a call or "
#~ "a put.\n"
#~ "\n"
#~ "(The rho of an option is the rate of change of its price with respect to "
#~ "the risk free interest rate.)\n"
#~ "@time is the time to maturity of the option expressed in years.\n"
#~ "@rate is the risk-free interest rate to the exercise date, in percent.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "* The returned value will be expressed as the rate of change of option "
#~ "value, per 100% change in @rate.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_THETA, OPT_BS_VEGA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_RGW\n"
#~ "@SYNTAX=OPT_RGW(Call_oder_Put,Kassapreis,Ausübungspreis,Laufzeit1,"
#~ "Laufzeit2,Kurs,d,Volatilität)\n"
#~ "@DESCRIPTION=OPT_RGW berechnet den theoretischen Preis einer Option nach "
#~ "der Roll-Geske-Whaley-Näherung.\n"
#~ "@Laufzeit1 ist die Zeit bis zur Auszahlung der Dividende\n"
#~ "@Laufzeit2 die Zeit bis zum Verfall der Option\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#~ msgid ""
#~ "@FUNCTION=OPT_BS_CARRYCOST\n"
#~ "@SYNTAX=OPT_BS_CARRYCOST(call_put_flag,spot,strike,time,rate,volatility[,"
#~ "cost_of_carry])\n"
#~ "@DESCRIPTION=OPT_BS_CARRYCOST uses the Black-Scholes model to calculate "
#~ "the 'elasticity' of a European option struck at @strike on an asset with "
#~ "spot price @spot.\n"
#~ "@call_put_flag is 'c' or 'p' to indicate whether the option is a call or "
#~ "a put.\n"
#~ "\n"
#~ "(The elasticity of an option is the rate of change of its price with "
#~ "respect to its cost of carry.)\n"
#~ "\n"
#~ "@volatility is the annualized volatility, in percent, of the asset for "
#~ "the period through to the exercise date.  @time is the time to maturity "
#~ "of the option expressed in years.\n"
#~ "@rate is the risk-free interest rate to the exercise date, in percent.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "\n"
#~ "* The returned value will be expressed as the rate of change of option "
#~ "value, per 100% volatility.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_RGW\n"
#~ "@SYNTAX=OPT_RGW(Call_oder_Put,Kassapreis,Ausübungspreis,Laufzeit1,"
#~ "Laufzeit2,Kurs,d,Volatilität)\n"
#~ "@DESCRIPTION=OPT_RGW berechnet den theoretischen Preis einer Option nach "
#~ "der Roll-Geske-Whaley-Näherung.\n"
#~ "@Laufzeit1 ist die Zeit bis zur Auszahlung der Dividende\n"
#~ "@Laufzeit2 die Zeit bis zum Verfall der Option\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#~ msgid ""
#~ "@FUNCTION=OPT_GARMAN_KOHLHAGEN\n"
#~ "@SYNTAX=OPT_GARMAN_KOHLHAGEN(call_put_flag,spot,strike,time,domestic_rate,"
#~ "foreign_rate,volatility[,cost_of_carry])\n"
#~ "@DESCRIPTION=OPT_GARMAN_KOHLHAGEN values the theoretical price of a "
#~ "European currency option struck at @strike on an asset with spot price "
#~ "@spot.\n"
#~ "@call_put_flag is 'c' or 'p' to indicate whether the option is a call or "
#~ "a put.\n"
#~ "@volatility is the annualized volatility, in percent, of the asset for "
#~ "the period through to the exercise date. \n"
#~ "@time the number of days to exercise.\n"
#~ "@domestic_rate is the domestic risk-free interest rate to the exercise "
#~ "date.\n"
#~ "@foreign_rate is the foreign risk-free interest rate to the exercise "
#~ "date, in percent.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "* The returned value will be expressed as the rate of change of option "
#~ "value, per 100% volatility.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_RGW\n"
#~ "@SYNTAX=OPT_RGW(Call_oder_Put,Kassapreis,Ausübungspreis,Laufzeit1,"
#~ "Laufzeit2,Kurs,d,Volatilität)\n"
#~ "@DESCRIPTION=OPT_RGW berechnet den theoretischen Preis einer Option nach "
#~ "der Roll-Geske-Whaley-Näherung.\n"
#~ "@Laufzeit1 ist die Zeit bis zur Auszahlung der Dividende\n"
#~ "@Laufzeit2 die Zeit bis zum Verfall der Option\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#~ msgid ""
#~ "@FUNCTION=OPT_FRENCH\n"
#~ "@SYNTAX=OPT_FRENCH(call_put_flag,spot,strike,time,t2,rate,volatility[,"
#~ "cost_of_carry])\n"
#~ "@DESCRIPTION=OPT_FRENCH values the theoretical price of a European option "
#~ "adjusted for trading day volatility, struck at @strike on an asset with "
#~ "spot price @spot.\n"
#~ "@call_put_flag is 'c' or 'p' to indicate whether the option is a call or "
#~ "a put.\n"
#~ "@volatility is the annualized volatility, in percent, of the asset for "
#~ "the period through to the exercise date.\n"
#~ " @time the number of calendar days to exercise divided by calendar days "
#~ "in the year.\n"
#~ "@t2 is the number of trading days to exercise divided by trading days in "
#~ "the year.\n"
#~ "@rate is the risk-free interest rate.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, to the "
#~ "exercise date, in percent.\n"
#~ "For common stocks, this would be the dividend yield.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_RGW\n"
#~ "@SYNTAX=OPT_RGW(Call_oder_Put,Kassapreis,Ausübungspreis,Laufzeit1,"
#~ "Laufzeit2,Kurs,d,Volatilität)\n"
#~ "@DESCRIPTION=OPT_RGW berechnet den theoretischen Preis einer Option nach "
#~ "der Roll-Geske-Whaley-Näherung.\n"
#~ "@Laufzeit1 ist die Zeit bis zur Auszahlung der Dividende\n"
#~ "@Laufzeit2 die Zeit bis zum Verfall der Option\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#~ msgid ""
#~ "@FUNCTION=OPT_JUMP_DIFF\n"
#~ "@SYNTAX=OPT_JUMP_DIFF(call_put_flag,spot,strike,time,rate,volatility,"
#~ "lambda,gamma)\n"
#~ "@DESCRIPTION=OPT_JUMP_DIFF models the theoretical price of an option "
#~ "according to the Jump Diffusion process (Merton).\n"
#~ "@call_put_flag is 'c' or 'p' to indicate whether the option is a call or "
#~ "a put.\n"
#~ "@spot is the spot price of the underlying asset.\n"
#~ "@strike is the strike price of the option.\n"
#~ "@time is the time to maturity of the option expressed in years.\n"
#~ "@rate is the annualized rate of interest.\n"
#~ "@volatility is the annualized volatility of the underlying asset.\n"
#~ "@lambda is expected number of 'jumps' per year.\n"
#~ "@gamma is proportion of volatility explained by the 'jumps.'\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_RGW\n"
#~ "@SYNTAX=OPT_RGW(Call_oder_Put,Kassapreis,Ausübungspreis,Laufzeit1,"
#~ "Laufzeit2,Kurs,d,Volatilität)\n"
#~ "@DESCRIPTION=OPT_RGW berechnet den theoretischen Preis einer Option nach "
#~ "der Roll-Geske-Whaley-Näherung.\n"
#~ "@Laufzeit1 ist die Zeit bis zur Auszahlung der Dividende\n"
#~ "@Laufzeit2 die Zeit bis zum Verfall der Option\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OPT_RGW\n"
#~ "@SYNTAX=OPT_RGW(spot,strike,t1,t2,rate,d,volatility)\n"
#~ "@DESCRIPTION=OPT_RGW models the theoretical price of an American option "
#~ "according to the Roll-Geske-Whaley approximation where: \n"
#~ "@spot is the spot price of the underlying asset.\n"
#~ "@strike is the strike price at which the option is struck.\n"
#~ "@t1 is the time to the dividend payout.\n"
#~ "@t2 is the time to option expiration.\n"
#~ "@rate is the annualized rate of interest.\n"
#~ "@d is the amount of the dividend to be paid expressed in currency.\n"
#~ "@volatility is the annualized rate of volatility of the underlying "
#~ "asset.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_RGW\n"
#~ "@SYNTAX=OPT_RGW(Call_oder_Put,Kassapreis,Ausübungspreis,Laufzeit1,"
#~ "Laufzeit2,Kurs,d,Volatilität)\n"
#~ "@DESCRIPTION=OPT_RGW berechnet den theoretischen Preis einer Option nach "
#~ "der Roll-Geske-Whaley-Näherung.\n"
#~ "@Laufzeit1 ist die Zeit bis zur Auszahlung der Dividende\n"
#~ "@Laufzeit2 die Zeit bis zum Verfall der Option\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OPT_BAW_AMER\n"
#~ "@SYNTAX=OPT_BAW_AMER(call_put_flag,spot,strike,time,rate,cost_of_carry,"
#~ "volatility)\n"
#~ "@DESCRIPTION=OPT_BAW_AMER models the theoretical price of an option "
#~ "according to the Barone Adesie & Whaley approximation. \n"
#~ "@call_put_flag is 'c' or 'p' to indicate whether the option is a call or "
#~ "a put.\n"
#~ "@spot is the spot price of the underlying asset.\n"
#~ "@strike is the strike price at which the option is struck.\n"
#~ "@time is the number of days to maturity of the option.\n"
#~ "@rate is the annualized risk-free rate of interest.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "@volatility is the annualized volatility in price of the underlying "
#~ "asset.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_RGW\n"
#~ "@SYNTAX=OPT_RGW(Call_oder_Put,Kassapreis,Ausübungspreis,Laufzeit1,"
#~ "Laufzeit2,Kurs,d,Volatilität)\n"
#~ "@DESCRIPTION=OPT_RGW berechnet den theoretischen Preis einer Option nach "
#~ "der Roll-Geske-Whaley-Näherung.\n"
#~ "@Laufzeit1 ist die Zeit bis zur Auszahlung der Dividende\n"
#~ "@Laufzeit2 die Zeit bis zum Verfall der Option\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OPT_BJER_STENS\n"
#~ "@SYNTAX=OPT_BJER_STENS(call_put_flag,spot,strike,time,rate,volatility[,"
#~ "cost_of_carry])\n"
#~ "@DESCRIPTION=OPT_BJER_STENS models the theoretical price of American "
#~ "options according to the Bjerksund & Stensland approximation technique.\n"
#~ "@call_put_flag is 'c' or 'p' to indicate whether the option is a call or "
#~ "a put.\n"
#~ "@spot is the spot price of the underlying asset.\n"
#~ "@strike is the strike price at which the option is struck.\n"
#~ "@time is the number of days to maturity of the option.\n"
#~ "@rate is the annualized risk-free rate of interest.\n"
#~ "@volatility is the annualized volatility in price of the underlying "
#~ "asset.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_RGW\n"
#~ "@SYNTAX=OPT_RGW(Call_oder_Put,Kassapreis,Ausübungspreis,Laufzeit1,"
#~ "Laufzeit2,Kurs,d,Volatilität)\n"
#~ "@DESCRIPTION=OPT_RGW berechnet den theoretischen Preis einer Option nach "
#~ "der Roll-Geske-Whaley-Näherung.\n"
#~ "@Laufzeit1 ist die Zeit bis zur Auszahlung der Dividende\n"
#~ "@Laufzeit2 die Zeit bis zum Verfall der Option\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OPT_EXEC\n"
#~ "@SYNTAX=OPT_EXEC(call_put_flag,spot,strike,time,rate,volatility,"
#~ "cost_of_carry,lambda)\n"
#~ "@DESCRIPTION=OPT_EXEC models the theoretical price of executive stock "
#~ "options @call_put_flag is 'c' or 'p' to indicate whether the option is a "
#~ "call or a put.\n"
#~ "One would expect this to always be a call option.\n"
#~ "@spot is the spot price of the underlying asset.\n"
#~ "@strike is the strike price at which the option is struck.\n"
#~ "@time is the number of days to maturity of the option.\n"
#~ "@rate is the annualized risk-free rate of interest.\n"
#~ "@volatility is the annualized volatility in price of the underlying "
#~ "asset.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "@lambda is the jump rate for executives. The model assumes executives "
#~ "forfeit their options if they leave the company.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_RGW\n"
#~ "@SYNTAX=OPT_RGW(Call_oder_Put,Kassapreis,Ausübungspreis,Laufzeit1,"
#~ "Laufzeit2,Kurs,d,Volatilität)\n"
#~ "@DESCRIPTION=OPT_RGW berechnet den theoretischen Preis einer Option nach "
#~ "der Roll-Geske-Whaley-Näherung.\n"
#~ "@Laufzeit1 ist die Zeit bis zur Auszahlung der Dividende\n"
#~ "@Laufzeit2 die Zeit bis zum Verfall der Option\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OPT_FORWARD_START\n"
#~ "@SYNTAX=OPT_FORWARD_START(call_put_flag,spot,alpha,time1,time,rate,"
#~ "volatility,cost_of_carry)\n"
#~ "@DESCRIPTION=OPT_FORWARD_START models the theoretical price of forward "
#~ "start options\n"
#~ " @call_put_flag is 'c' or 'p' to indicate whether the option is a call or "
#~ "a put.\n"
#~ "@spot is the spot price of the underlying asset.\n"
#~ "@alpha is a fraction that set the strike price the future date @time1.\n"
#~ "@time1 is the number of days until the option starts.\n"
#~ "@time is the number of days to maturity of the option.\n"
#~ "@rate is the annualized risk-free rate of interest.\n"
#~ "@volatility is the annualized volatility in price of the underlying "
#~ "asset.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_RGW\n"
#~ "@SYNTAX=OPT_RGW(Call_oder_Put,Kassapreis,Ausübungspreis,Laufzeit1,"
#~ "Laufzeit2,Kurs,d,Volatilität)\n"
#~ "@DESCRIPTION=OPT_RGW berechnet den theoretischen Preis einer Option nach "
#~ "der Roll-Geske-Whaley-Näherung.\n"
#~ "@Laufzeit1 ist die Zeit bis zur Auszahlung der Dividende\n"
#~ "@Laufzeit2 die Zeit bis zum Verfall der Option\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OPT_TIME_SWITCH\n"
#~ "@SYNTAX=OPT_TIME_SWITCH(call_put_flag,spot,strike,a,time,m,dt,rate,"
#~ "cost_of_carry,volatility)\n"
#~ "@DESCRIPTION=OPT_TIME_SWITCH models the theoretical price of time switch "
#~ "options. (Pechtl 1995)\n"
#~ "The holder receives @a * @dt for each period dt that the asset price was "
#~ "greater than the strike price (for a call) or below it (for a put). \n"
#~ "@call_put_flag is 'c' or 'p' to indicate whether the option is a call or "
#~ "a put.\n"
#~ "@spot is the spot price of the underlying asset.\n"
#~ "@strike is the strike price at which the option is struck.\n"
#~ "@a is the amount received for each time period as discussed above.\n"
#~ "@time is the maturity of the option in years.\n"
#~ "@m is the number of time units the option has already met the condition.\n"
#~ "@dt is the agreed upon discrete time period (often a day) expressed as a "
#~ "fraction of a year.\n"
#~ "@rate is the annualized risk-free rate of interest.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_RGW\n"
#~ "@SYNTAX=OPT_RGW(Call_oder_Put,Kassapreis,Ausübungspreis,Laufzeit1,"
#~ "Laufzeit2,Kurs,d,Volatilität)\n"
#~ "@DESCRIPTION=OPT_RGW berechnet den theoretischen Preis einer Option nach "
#~ "der Roll-Geske-Whaley-Näherung.\n"
#~ "@Laufzeit1 ist die Zeit bis zur Auszahlung der Dividende\n"
#~ "@Laufzeit2 die Zeit bis zum Verfall der Option\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OPT_SIMPLE_CHOOSER\n"
#~ "@SYNTAX=OPT_SIMPLE_CHOOSER(call_put_flag,spot,strike,time1,time2,rate,"
#~ "cost_of_carry,volatility)\n"
#~ "@DESCRIPTION=OPT_SIMPLE_CHOOSER models the theoretical price of simple "
#~ "chooser options.\n"
#~ "@call_put_flag is 'c' or 'p' to indicate whether the option is a call or "
#~ "a put.\n"
#~ "@spot is the spot price of the underlying asset.\n"
#~ "@strike is the strike price at which the option is struck.\n"
#~ "@time1 is the time in years until the holder chooses a put or a call "
#~ "option.\n"
#~ "@time2 is the time in years until the chosen option expires.\n"
#~ "@rate is the annualized risk-free rate of interest.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_RGW\n"
#~ "@SYNTAX=OPT_RGW(Call_oder_Put,Kassapreis,Ausübungspreis,Laufzeit1,"
#~ "Laufzeit2,Kurs,d,Volatilität)\n"
#~ "@DESCRIPTION=OPT_RGW berechnet den theoretischen Preis einer Option nach "
#~ "der Roll-Geske-Whaley-Näherung.\n"
#~ "@Laufzeit1 ist die Zeit bis zur Auszahlung der Dividende\n"
#~ "@Laufzeit2 die Zeit bis zum Verfall der Option\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OPT_COMPLEX_CHOOSER\n"
#~ "@SYNTAX=OPT_COMPLEX_CHOOSER(call_put_flag,spot,strike_call,strike_put,"
#~ "time,time_call,time_put,rate,cost_of_carry,volatility)\n"
#~ "@DESCRIPTION=OPT_COMPLEX_CHOOSER models the theoretical price of complex "
#~ "chooser options.\n"
#~ "@call_put_flag is 'c' or 'p' to indicate whether the option is a call or "
#~ "a put.\n"
#~ "@spot is the spot price of the underlying asset.\n"
#~ "@strike_call is the strike price at which the option is struck, "
#~ "applicable if exercised as a call option.\n"
#~ "@strike_put is the strike price at which the option is struck, applicable "
#~ "if exercised as a put option.\n"
#~ "@time is the time in years until the holder chooses a put or a call "
#~ "option. \n"
#~ "@time_call is the time in years to maturity of the call option if "
#~ "chosen.\n"
#~ "@time_put is the time in years  to maturity of the put option if chosen.\n"
#~ "@rate is the annualized risk-free rate of interest.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "@volatility is the annualized volatility in price of the underlying "
#~ "asset.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_RGW\n"
#~ "@SYNTAX=OPT_RGW(Call_oder_Put,Kassapreis,Ausübungspreis,Laufzeit1,"
#~ "Laufzeit2,Kurs,d,Volatilität)\n"
#~ "@DESCRIPTION=OPT_RGW berechnet den theoretischen Preis einer Option nach "
#~ "der Roll-Geske-Whaley-Näherung.\n"
#~ "@Laufzeit1 ist die Zeit bis zur Auszahlung der Dividende\n"
#~ "@Laufzeit2 die Zeit bis zum Verfall der Option\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OPT_ON_OPTIONS\n"
#~ "@SYNTAX=OPT_ON_OPTIONS(type_flag,spot,strike1,strike2,time1,time2,rate,"
#~ "cost_of_carry,volatility)\n"
#~ "@DESCRIPTION=OPT_ON_OPTIONS models the theoretical price of options on "
#~ "options.\n"
#~ "@type_flag is 'cc' for calls on calls, 'cp' for calls on puts, and so on "
#~ "for 'pc', and 'pp'.\n"
#~ "@spot is the spot price of the underlying asset.\n"
#~ "@strike1 is the strike price at which the option being valued is struck.\n"
#~ "@strike2 is the strike price at which the underlying option is struck.\n"
#~ "@time1 is the time in years to maturity of the option.\n"
#~ "@time2 is the time in years to the maturity of the underlying option.\n"
#~ "(@time2 >= @time1).\n"
#~ "@rate is the annualized risk-free rate of interest.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset of the "
#~ "underlying option.for common stocks, this would be the dividend yield.\n"
#~ "@volatility is the annualized volatility in price of the underlying asset "
#~ "of the underlying option.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_RGW\n"
#~ "@SYNTAX=OPT_RGW(Call_oder_Put,Kassapreis,Ausübungspreis,Laufzeit1,"
#~ "Laufzeit2,Kurs,d,Volatilität)\n"
#~ "@DESCRIPTION=OPT_RGW berechnet den theoretischen Preis einer Option nach "
#~ "der Roll-Geske-Whaley-Näherung.\n"
#~ "@Laufzeit1 ist die Zeit bis zur Auszahlung der Dividende\n"
#~ "@Laufzeit2 die Zeit bis zum Verfall der Option\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OPT_EXTENDIBLE_WRITER\n"
#~ "@SYNTAX=OPT_EXTENDIBLE_WRITER(call_put_flag,spot,strike1,strike2,time1,"
#~ "time2,rate,cost_of_carry,volatility)\n"
#~ "@DESCRIPTION=OPT_EXTENDIBLE_WRITER models the theoretical price of "
#~ "extendible writer options. These are options that can be exercised at an "
#~ "initial period, @time1, or their maturity extended to @time2 if the "
#~ "option is out of the money at @time1.\n"
#~ "@call_put_flag is 'c' or 'p' to indicate whether the option is a call or "
#~ "a put.\n"
#~ "@spot is the spot price of the underlying asset.\n"
#~ "@strike1 is the strike price at which the option is struck.\n"
#~ "@strike2 is the strike price at which the option is re-struck if out of "
#~ "the money at @time1.\n"
#~ "@time1 is the initial maturity of the option in years.\n"
#~ "@time2 is the is the extended maturity in years if chosen.\n"
#~ "@rate is the annualized risk-free rate of interest.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "@volatility is the annualized volatility in price of the underlying "
#~ "asset.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_RGW\n"
#~ "@SYNTAX=OPT_RGW(Call_oder_Put,Kassapreis,Ausübungspreis,Laufzeit1,"
#~ "Laufzeit2,Kurs,d,Volatilität)\n"
#~ "@DESCRIPTION=OPT_RGW berechnet den theoretischen Preis einer Option nach "
#~ "der Roll-Geske-Whaley-Näherung.\n"
#~ "@Laufzeit1 ist die Zeit bis zur Auszahlung der Dividende\n"
#~ "@Laufzeit2 die Zeit bis zum Verfall der Option\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OPT_2_ASSET_CORRELATION\n"
#~ "@SYNTAX=OPT_2_ASSET_CORRELATION(call_put_flag,spot1,spot2,strike1,strike2,"
#~ "time,cost_of_carry1,cost_of_carry2,rate,volatility1,volatility2,rho)\n"
#~ "@DESCRIPTION=OPT_2_ASSET_CORRELATION models the theoretical price of  "
#~ "options on 2 assets with correlation @rho.\n"
#~ "The payoff for a call is max(@spot2 - @strike2,0) if @spot1 > @strike1 or "
#~ "0 otherwise.\n"
#~ "The payoff for a put is max (@strike2 - @spot2, 0) if @spot1 < @strike1 "
#~ "or 0 otherwise.\n"
#~ "@call_put_flag is 'c' or 'p' to indicate whether the option is a call or "
#~ "a put.\n"
#~ "@spot1 & @spot2 are the spot prices of the underlying assets.\n"
#~ "@strike1 & @strike2 are the strike prices at which the option is struck.\n"
#~ "@time is the initial maturity of the option in years.\n"
#~ "@rate is the annualized risk-free rate of interest.\n"
#~ "@cost_of_carry1 & @cost_of_carry2 are the leakage in value of the "
#~ "underlying assets, for common stocks, this would be the dividend yield.\n"
#~ "@volatility1 & @volatility2 are the annualized volatility in price of the "
#~ "underlying assets.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_RGW\n"
#~ "@SYNTAX=OPT_RGW(Call_oder_Put,Kassapreis,Ausübungspreis,Laufzeit1,"
#~ "Laufzeit2,Kurs,d,Volatilität)\n"
#~ "@DESCRIPTION=OPT_RGW berechnet den theoretischen Preis einer Option nach "
#~ "der Roll-Geske-Whaley-Näherung.\n"
#~ "@Laufzeit1 ist die Zeit bis zur Auszahlung der Dividende\n"
#~ "@Laufzeit2 die Zeit bis zum Verfall der Option\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OPT_EURO_EXCHANGE\n"
#~ "@SYNTAX=OPT_EURO_EXCHANGE(spot1,spot2,qty1,qty2,time,rate,cost_of_carry1,"
#~ "cost_of_carry2,volatility1,volatility2,rho)\n"
#~ "@DESCRIPTION=OPT_EURO_EXCHANGE models the theoretical price of a European "
#~ "option to exchange one asset with quantity @qty2 and spot price @spot2 "
#~ "for another, with quantity @qty1 and spot price @spot1.\n"
#~ "@time is the initial maturity of the option in years.\n"
#~ "@rate is the annualized risk-free rate of interest.\n"
#~ "@cost_of_carry1 & @cost_of_carry2 are the leakage in value of the "
#~ "underlying assets, for common stocks, this would be the dividend yield.\n"
#~ "@volatility1 & @volatility2 are the annualized volatility in price of the "
#~ "underlying assets.\n"
#~ "@rho is the correlation between the two assets.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_AMER_EXCHANGE, OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, "
#~ "OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_RGW\n"
#~ "@SYNTAX=OPT_RGW(Call_oder_Put,Kassapreis,Ausübungspreis,Laufzeit1,"
#~ "Laufzeit2,Kurs,d,Volatilität)\n"
#~ "@DESCRIPTION=OPT_RGW berechnet den theoretischen Preis einer Option nach "
#~ "der Roll-Geske-Whaley-Näherung.\n"
#~ "@Laufzeit1 ist die Zeit bis zur Auszahlung der Dividende\n"
#~ "@Laufzeit2 die Zeit bis zum Verfall der Option\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OPT_AMER_EXCHANGE\n"
#~ "@SYNTAX=OPT_AMER_EXCHANGE(spot1,spot2,qty1,qty2,time,rate,cost_of_carry1,"
#~ "cost_of_carry2,volatility1, volatility2, rho)\n"
#~ "@DESCRIPTION=OPT_AMER_EXCHANGE models the theoretical price of an "
#~ "American option to exchange one asset with quantity @qty2 and spot price "
#~ "@spot2 for another, with quantity @qty1 and spot price @spot1.\n"
#~ "@time is the initial maturity of the option in years.\n"
#~ "@rate is the annualized risk-free rate of interest.\n"
#~ "@cost_of_carry1 & @cost_of_carry2 are the leakage in value of the "
#~ "underlying assets, for common stocks, this would be the dividend yield.\n"
#~ "@volatility1 & @volatility2 are the annualized volatility in price of the "
#~ "underlying assets.\n"
#~ "@rho is the correlation between the two assets.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_EURO_EXCHANGE, OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, "
#~ "OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_RGW\n"
#~ "@SYNTAX=OPT_RGW(Call_oder_Put,Kassapreis,Ausübungspreis,Laufzeit1,"
#~ "Laufzeit2,Kurs,d,Volatilität)\n"
#~ "@DESCRIPTION=OPT_RGW berechnet den theoretischen Preis einer Option nach "
#~ "der Roll-Geske-Whaley-Näherung.\n"
#~ "@Laufzeit1 ist die Zeit bis zur Auszahlung der Dividende\n"
#~ "@Laufzeit2 die Zeit bis zum Verfall der Option\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OPT_SPREAD_APPROX\n"
#~ "@SYNTAX=OPT_SPREAD_APPROX(call_put_flag,fut_price1,fut_price2,strike,"
#~ "time, rate,volatility1,volatility2,rho)\n"
#~ "@DESCRIPTION=OPT_SPREAD_APPROX models the theoretical price of a European "
#~ "option on the spread between two futures contracts.\n"
#~ "@call_put_flag is 'c' or 'p' to indicate whether the option is a call or "
#~ "a put.\n"
#~ "@fut_price1 & @fut_price2 are the prices of the two futures contracts.\n"
#~ "@strike is the strike price at which the option is struck \n"
#~ "@time is the initial maturity of the option in years.\n"
#~ "@rate is the annualized risk-free rate of interest.\n"
#~ "@volatility1 & @volatility2 are the annualized volatility in price of the "
#~ "underlying futures contracts.\n"
#~ "@rho is the correlation between the two futures contracts.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_RGW\n"
#~ "@SYNTAX=OPT_RGW(Call_oder_Put,Kassapreis,Ausübungspreis,Laufzeit1,"
#~ "Laufzeit2,Kurs,d,Volatilität)\n"
#~ "@DESCRIPTION=OPT_RGW berechnet den theoretischen Preis einer Option nach "
#~ "der Roll-Geske-Whaley-Näherung.\n"
#~ "@Laufzeit1 ist die Zeit bis zur Auszahlung der Dividende\n"
#~ "@Laufzeit2 die Zeit bis zum Verfall der Option\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OPT_FLOAT_STRK_LKBK\n"
#~ "@SYNTAX=OPT_FLOAT_STRK_LKBK(call_put_flag,spot,spot_min,spot_max,time,"
#~ "rate,cost_of_carry,volatility)\n"
#~ "@DESCRIPTION=OPT_FLOAT_STRK_LKBK models the theoretical price of an "
#~ "option where the holder of the option may exercise on expiry at the most "
#~ "favourable price observed during the options life of the underlying "
#~ "asset.\n"
#~ "@call_put_flag is 'c' or 'p' to indicate whether the option is a call or "
#~ "a put.\n"
#~ "@spot is the spot price of the underlying asset.\n"
#~ "@spot_min is the minimum spot price of the underlying asset so far "
#~ "observed.\n"
#~ "@spot_max is the maximum spot price of the underlying asset so far "
#~ "observed.\n"
#~ "@time is the initial maturity of the option in years.\n"
#~ "@rate is the annualized risk-free rate of interest.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "@volatility is the annualized volatility in price of the underlying "
#~ "asset.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_RGW\n"
#~ "@SYNTAX=OPT_RGW(Call_oder_Put,Kassapreis,Ausübungspreis,Laufzeit1,"
#~ "Laufzeit2,Kurs,d,Volatilität)\n"
#~ "@DESCRIPTION=OPT_RGW berechnet den theoretischen Preis einer Option nach "
#~ "der Roll-Geske-Whaley-Näherung.\n"
#~ "@Laufzeit1 ist die Zeit bis zur Auszahlung der Dividende\n"
#~ "@Laufzeit2 die Zeit bis zum Verfall der Option\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OPT_FIXED_STRK_LKBK\n"
#~ "@SYNTAX=OPT_FIXED_STRK_LKBK(call_put_flag,spot,spot_min,spot_max,strike,"
#~ "time,rate,cost_of_carry,volatility)\n"
#~ "@DESCRIPTION=OPT_FIXED_STRK_LKBK models the theoretical price of an "
#~ "option where the holder of the option may exercise on expiry at the most "
#~ "favourable price observed during the options life of the underlying "
#~ "asset.\n"
#~ "@call_put_flag is 'c' or 'p' to indicate whether the option is a call or "
#~ "a put.\n"
#~ "@spot is the spot price of the underlying asset.\n"
#~ "@spot_min is the minimum spot price of the underlying asset so far "
#~ "observed.\n"
#~ "@spot_max is the maximum spot price of the underlying asset so far "
#~ "observed.\n"
#~ "@strike is the strike prices at which the option is struck.\n"
#~ "@time is the initial maturity of the option in years.\n"
#~ "@rate is the annualized risk-free rate of interest.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset, for "
#~ "common stocks, this would be the dividend yield.\n"
#~ "@volatility is the annualized volatility in price of the underlying "
#~ "asset.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_RGW\n"
#~ "@SYNTAX=OPT_RGW(Call_oder_Put,Kassapreis,Ausübungspreis,Laufzeit1,"
#~ "Laufzeit2,Kurs,d,Volatilität)\n"
#~ "@DESCRIPTION=OPT_RGW berechnet den theoretischen Preis einer Option nach "
#~ "der Roll-Geske-Whaley-Näherung.\n"
#~ "@Laufzeit1 ist die Zeit bis zur Auszahlung der Dividende\n"
#~ "@Laufzeit2 die Zeit bis zum Verfall der Option\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OPT_BINOMIAL\n"
#~ "@SYNTAX=OPT_BINOMIAL(amer_euro_flag,call_put_flag,num_time_steps, spot, "
#~ "strike, time, rate, volatility, cost_of_carry)\n"
#~ "@DESCRIPTION=OPT_ models the theoretical price of either an American or "
#~ "European style option using a binomial tree.\n"
#~ "@amer_euro_flag is either 'a' or 'e' to indicate whether the option being "
#~ "valued is an American or European style option respectively.\n"
#~ "@call_put_flag is 'c' or 'p' to indicate whether the option is a call or "
#~ "a put.\n"
#~ "@num_time_steps is the number of time steps used in the valuation, a "
#~ "greater number of time steps yields greater accuracy however is slower to "
#~ "calculate.\n"
#~ "@spot is the spot price of the underlying asset.\n"
#~ "@strike is the strike price at which the option is struck.\n"
#~ "@time is the initial maturity of the option in years.\n"
#~ "@rate is the annualized risk-free rate of interest.\n"
#~ "@volatility is the annualized volatility in price of the underlying "
#~ "asset.\n"
#~ "@cost_of_carry is the leakage in value of the underlying asset.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
#~ msgstr ""
#~ "@FUNCTION=OPT_RGW\n"
#~ "@SYNTAX=OPT_RGW(Call_oder_Put,Kassapreis,Ausübungspreis,Laufzeit1,"
#~ "Laufzeit2,Kurs,d,Volatilität)\n"
#~ "@DESCRIPTION=OPT_RGW berechnet den theoretischen Preis einer Option nach "
#~ "der Roll-Geske-Whaley-Näherung.\n"
#~ "@Laufzeit1 ist die Zeit bis zur Auszahlung der Dividende\n"
#~ "@Laufzeit2 die Zeit bis zum Verfall der Option\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#~ msgid ""
#~ "@FUNCTION=COMPLEX\n"
#~ "@SYNTAX=COMPLEX(real,im[,suffix])\n"
#~ "@DESCRIPTION=COMPLEX returns a complex number of the form x + yi.\n"
#~ "\n"
#~ "@real is the real and @im is the imaginary part of the complex number.  "
#~ "@suffix is the suffix for the imaginary part.  If it is omitted, COMPLEX "
#~ "uses 'i' by default.\n"
#~ "\n"
#~ "* If @suffix is neither 'i' nor 'j', COMPLEX returns #VALUE! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COMPLEX(1,-1) equals 1-i.\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=KOMPLEX\n"
#~ "@SYNTAX=KOMPLEX(Reel,Imaginär[,Suffix])\n"
#~ "@DESCRIPTION=KOMPLEX liefert eine komplexe Zahl der Form x + yi.\n"
#~ "\n"
#~ "@Reel ist der reelle und @Imaginär der imaginäre Koeffizient der "
#~ "komplexen Zahl. @Suffix ist der Suffix des imaginären Koeffizienten.\n"
#~ "\n"
#~ "* Falls @Suffix weder 'i' noch 'j' ist, liefert KOMPLEX einen #WERT!-"
#~ "Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "KOMPLEX(1,-1) liefert 1-i.\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=IMAGINARY\n"
#~ "@SYNTAX=IMAGINARY(inumber)\n"
#~ "@DESCRIPTION=IMAGINARY returns the imaginary part of a complex number.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMAGINARY returns #VALUE! "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMAGINARY(\"132-j\") equals -1.\n"
#~ "\n"
#~ "@SEEALSO=IMREAL"
#~ msgstr ""
#~ "@FUNCTION=IMAGINÄR\n"
#~ "@SYNTAX=IMAGINÄR(iZahl)\n"
#~ "@DESCRIPTION=IMAGINÄR liefert den imaginären Teil einer komplexen Zahl "
#~ "@iZahl.\n"
#~ "\n"
#~ "* Falls @iZahl keine gültige komplexe Zahl ist, liefert IMAGINÄR einen "
#~ "#WERT!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMAGINÄR(\"132-j\") liefert -1.\n"
#~ "\n"
#~ "@SEEALSO=IMREEL"

#~ msgid ""
#~ "@FUNCTION=IMABS\n"
#~ "@SYNTAX=IMABS(inumber)\n"
#~ "@DESCRIPTION=IMABS returns the absolute value of a complex number.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMABS returns #VALUE! "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMABS(\"2-j\") equals 2.23606798.\n"
#~ "\n"
#~ "@SEEALSO=IMAGINARY,IMREAL"
#~ msgstr ""
#~ "@FUNCTION=IMABS\n"
#~ "@SYNTAX=IMABS(iZahl)\n"
#~ "@DESCRIPTION=IMABS liefert den absoluten Betrag einer komplexen Zahl "
#~ "@iZahl.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMABS(\"2-j\") liefert 2,23606798.\n"
#~ "\n"
#~ "@SEEALSO=IMAGINÄR, IMREEL"

#~ msgid ""
#~ "@FUNCTION=IMREAL\n"
#~ "@SYNTAX=IMREAL(inumber)\n"
#~ "@DESCRIPTION=IMREAL returns the real part of a complex number.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMREAL returns #VALUE! "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "imreal(\"132-j\") equals 132.\n"
#~ "\n"
#~ "@SEEALSO=IMAGINARY"
#~ msgstr ""
#~ "@FUNCTION=IMREEL\n"
#~ "@SYNTAX=IMREEL(iZahl)\n"
#~ "@DESCRIPTION=IMREEL liefert den reellen Teil einer komplexen Zahl "
#~ "@iZahl.\n"
#~ "\n"
#~ "* Falls @iZahl keine gültige komplexe Zahl ist, liefert IMREEL einen "
#~ "#WERT!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMREEL(\"132-j\") liefert 132.\n"
#~ "\n"
#~ "@SEEALSO=IMAGINÄR"

#~ msgid ""
#~ "@FUNCTION=IMCONJUGATE\n"
#~ "@SYNTAX=IMCONJUGATE(inumber)\n"
#~ "@DESCRIPTION=IMCONJUGATE returns the complex conjugate of a complex "
#~ "number.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMCONJUGATE returns #VALUE! "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMCONJUGATE(\"1-j\") equals 1+j.\n"
#~ "\n"
#~ "@SEEALSO=IMAGINARY,IMREAL"
#~ msgstr ""
#~ "@FUNCTION=IMKONJUGIERTE\n"
#~ "@SYNTAX=IMKONJUGIERTE(iZahl)\n"
#~ "@DESCRIPTION=IMKONJUGIERTE liefert das komplexe Konjugierte einer "
#~ "komplexen Zahl @iZahl.\n"
#~ "\n"
#~ "* Falls @iZahl keine gültige komplexe Zahl ist, liefert IMKONJUGIERTE "
#~ "einen #WERT!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMKONJUGIERTE(\"1-j\") liefert 1+j.\n"
#~ "\n"
#~ "@SEEALSO=IMAGINÄR, IMREEL"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=IMINV\n"
#~ "@SYNTAX=IMINV(inumber)\n"
#~ "@DESCRIPTION=IMINV returns the inverse, or reciprocal, of the complex "
#~ "number z (@inumber), where\n"
#~ "\n"
#~ "\t1/z = (x - i y)/(x^2 + y^2).\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMINV returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMINV(\"1-j\") equals 0.5+0.5j.\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=IMINV\n"
#~ "@SYNTAX=IMINV(iZahl)\n"
#~ "@DESCRIPTION=IMINV liefert die Inverse, oder Reziproke, einer komplexen "
#~ "Zahl z (@iZahl), wobei\n"
#~ "\n"
#~ "\t1/z = (x - i y)/(x^2 + y^2).\n"
#~ "\n"
#~ "* Falls @iZahl keine gültige komplexe Zahl ist, liefert IMINV einen "
#~ "#WERT!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMINV(\"1-j\") liefert 0.5+0.5j.\n"
#~ "\n"
#~ "@SEEALSO="

# FIXME: check for mathematical correctness
#~ msgid ""
#~ "@FUNCTION=IMNEG\n"
#~ "@SYNTAX=IMNEG(inumber)\n"
#~ "@DESCRIPTION=IMNEG returns the negative of the complex number z "
#~ "(@inumber), where\n"
#~ "\n"
#~ "\t-z = (-x) + i(-y).\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMNEG returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMNEG(\"1-j\") equals -1+j.\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=IMNEG\n"
#~ "@SYNTAX=IMNEG(iZahl)\n"
#~ "@DESCRIPTION=IMNEG liefert das negative einer komplexen Zahl z (@iZahl), "
#~ "wobei\n"
#~ "\n"
#~ "\t-z = (-x) + i(-y).\n"
#~ "\n"
#~ "* Falls @iZahl keine gültige komplexe Zahl ist, liefert IMNEG einen "
#~ "#WERT!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMNEG(\"1-j\") liefert -1+j.\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=IMCOS\n"
#~ "@SYNTAX=IMCOS(inumber)\n"
#~ "@DESCRIPTION=IMCOS returns the cosine of a complex number.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMCOS returns #VALUE! "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMCOS(\"1+j\") equals 0.833730-0.988898j.\n"
#~ "\n"
#~ "@SEEALSO=IMSIN,IMTAN"
#~ msgstr ""
#~ "@FUNCTION=IMCOS\n"
#~ "@SYNTAX=IMCOS(iZahl)\n"
#~ "@DESCRIPTION=IMCOS liefert den Cosinus einer komplexen Zahl @iZahl.\n"
#~ "\n"
#~ "* Falls @iZahl keine gültige komplexe Zahl ist, liefert IMCOS einen "
#~ "#WERT!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMCOS(\"1+j\") liefert 0.833730-0.988898j.\n"
#~ "\n"
#~ "@SEEALSO=IMSIN, IMTAN"

#~ msgid ""
#~ "@FUNCTION=IMTAN\n"
#~ "@SYNTAX=IMTAN(inumber)\n"
#~ "@DESCRIPTION=IMTAN returns the tangent of a complex number.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMTAN returns #VALUE! "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMTAN(\"2-j\") equals -0.2434582-1.1667363j.\n"
#~ "\n"
#~ "@SEEALSO=IMSIN,IMCOS"
#~ msgstr ""
#~ "@FUNCTION=IMTAN\n"
#~ "@SYNTAX=IMTAN(iZahl)\n"
#~ "@DESCRIPTION=IMTAN liefert den Cosinus einer komplexen Zahl @iZahl.\n"
#~ "\n"
#~ "* Falls @iZahl keine gültige komplexe Zahl ist, liefert IMTAN einen "
#~ "#WERT!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMTAN(\"1+j\") liefert -0.2434582-1.1667363j.\n"
#~ "\n"
#~ "@SEEALSO=IMSIN, IMCOS"

#~ msgid ""
#~ "@FUNCTION=IMSEC\n"
#~ "@SYNTAX=IMSEC(inumber)\n"
#~ "@DESCRIPTION=IMSEC returns the complex secant of the complex number z "
#~ "(@inumber), where\n"
#~ "\n"
#~ "\tsec(z) = 1/cos(z).\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMSEC returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMSEC(\"2-j\") equals -0.413149-0.687527j.\n"
#~ "\n"
#~ "@SEEALSO=IMCSC,IMCOT"
#~ msgstr ""
#~ "@FUNCTION=IMSEK\n"
#~ "@SYNTAX=IMSEK(iZahl)\n"
#~ "@DESCRIPTION=IMSEK liefert die komplexe Sekante einer komplexen Zahl z "
#~ "(@iZahl), wobei\n"
#~ "\n"
#~ "\tsec(z) = 1/cos(z).\n"
#~ "\n"
#~ "* Falls @iZahl keine gültige komplexe Zahl ist, liefert IMSEK einen "
#~ "#WERT!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMSEK(\"2-j\") liefert -0.413149-0.687527j.\n"
#~ "\n"
#~ "@SEEALSO=IMCOSEK,IMCOTAN"

#~ msgid ""
#~ "@FUNCTION=IMCSC\n"
#~ "@SYNTAX=IMCSC(inumber)\n"
#~ "@DESCRIPTION=IMCSC returns the complex cosecant of the complex number z "
#~ "(@inumber), where\n"
#~ "\n"
#~ "\tcsc(z) = 1/sin(z).\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMCSC returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMCSC(\"2-j\") equals 0.635494-0.221501j.\n"
#~ "\n"
#~ "@SEEALSO=IMSEC,IMCOT"
#~ msgstr ""
#~ "@FUNCTION=IMKOSEK\n"
#~ "@SYNTAX=IMKOSEK(iZahl)\n"
#~ "@DESCRIPTION=IMKOSEK liefert die komplexe Kosekante einer komplexen Zahl "
#~ "z (@iZahl), wobei\n"
#~ "\n"
#~ "\tcsc(z) = 1/sin(z).\n"
#~ "\n"
#~ "* Falls @iZahl keine gültige komplexe Zahl ist, liefert #IMKOSEK einen "
#~ "#WERT!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMCSC(\"2-j\") liefert 0.635494-0.221501j.\n"
#~ "\n"
#~ "@SEEALSO=IMSEK,IMCOT"

#~ msgid ""
#~ "@FUNCTION=IMCOT\n"
#~ "@SYNTAX=IMCOT(inumber)\n"
#~ "@DESCRIPTION=IMCOT returns the complex cotangent of the complex number z "
#~ "(@inumber), where\n"
#~ "\n"
#~ "\tcot(z) = 1/tan(z).\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMCOT returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMCOT(\"2-j\") equals -0.171384+0.821330j.\n"
#~ "\n"
#~ "@SEEALSO=IMSEC,IMCSC"
#~ msgstr ""
#~ "@FUNCTION=IMCOTAN\n"
#~ "@SYNTAX=IMCOTAN(iZahl)\n"
#~ "@DESCRIPTION=IMCOTAN liefert den komplexen Cotangens einer komplexen Zahl "
#~ "z (@iZahl), wobei\n"
#~ "\n"
#~ "\tcot(z) = 1/tan(z).\n"
#~ "\n"
#~ "* Falls @iZahl keine gültige komplexe Zahl ist, liefert IMCOTAN einen "
#~ "#WERT!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMCOTAN(\"2-j\") liefert -0.171384+0.821330j.\n"
#~ "\n"
#~ "@SEEALSO=IMSEK,IMCSEK"

# FIXME: check for mathematical correctness
#~ msgid ""
#~ "@FUNCTION=IMEXP\n"
#~ "@SYNTAX=IMEXP(inumber)\n"
#~ "@DESCRIPTION=IMEXP returns the exponential of a complex number.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMEXP returns #VALUE! "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMEXP(\"2-j\") equals 3.992324-6.217676j.\n"
#~ "\n"
#~ "@SEEALSO=IMLN"
#~ msgstr ""
#~ "@FUNCTION=IMEXP\n"
#~ "@SYNTAX=IMEXP(iZahl)\n"
#~ "@DESCRIPTION=IMEXP liefert das Exponential einer komplexen Zahl @iZahl.\n"
#~ "\n"
#~ "* Falls @iZahl keine gültige komplexe Zahl ist, liefert IMEXP einen "
#~ "#WERT!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMEXP(\"2-j\") liefert 3.992324-6.217676j.\n"
#~ "\n"
#~ "@SEEALSO=IMLN"

#~ msgid ""
#~ "@FUNCTION=IMARGUMENT\n"
#~ "@SYNTAX=IMARGUMENT(inumber)\n"
#~ "@DESCRIPTION=IMARGUMENT returns the argument theta of a complex number, i."
#~ "e. the angle in radians from the real axis to the representation of the "
#~ "number in polar coordinates.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMARGUMENT returns #VALUE! "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARGUMENT(\"2-j\") equals -0.463647609.\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=IMARGUMENT\n"
#~ "@SYNTAX=IMARGUMENT(iZahl)\n"
#~ "@DESCRIPTION=IMARGUMENT liefert das Argument Theta einer komplexen Zahl "
#~ "@iZahl, also den Winkel im Gradmaß zwischen der reellen Achse und der "
#~ "Darstellung der Zahl in Polarkoordinaten.\n"
#~ "\n"
#~ "* Falls @iZahl keine gültige komplexe Zahl ist, liefert IMARGUMENT einen "
#~ "#WERT!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARGUMENT(\"2-j\") liefert -0,463647609.\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=IMLN\n"
#~ "@SYNTAX=IMLN(inumber)\n"
#~ "@DESCRIPTION=IMLN returns the natural logarithm of a complex number.\n"
#~ "\n"
#~ "The result will have an imaginary part between -pi and +pi.  The natural "
#~ "logarithm is not uniquely defined on complex numbers. You may need to add "
#~ "or subtract an even multiple of pi to the imaginary part.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMLN returns #VALUE! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMLN(\"3-j\") equals 1.15129-0.32175j.\n"
#~ "\n"
#~ "@SEEALSO=IMEXP,IMLOG2,IMLOG10"
#~ msgstr ""
#~ "@FUNCTION=IMLN\n"
#~ "@SYNTAX=IMLN(iZahl)\n"
#~ "@DESCRIPTION=IMLN liefert den natürlichen Logarithmus einer komplexen "
#~ "Zahl @iZahl.\n"
#~ "Das Ergebnis hat einen imaginären Teil zwischen - und + PI. Der "
#~ "natürliche Logarithmus ist für komplexe Zahlen nicht eindeutig definiert. "
#~ "Möglicherweise müssen Sie eine gerade Vielfache von PI vom imaginären "
#~ "Teil abziehen.\n"
#~ "\n"
#~ "* Falls @iZahl keine gültige komplexe Zahl ist, liefert IMLN einen #WERT!-"
#~ "Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMLN(\"3-j\") liefert 1.15129-0.32175j.\n"
#~ "\n"
#~ "@SEEALSO=IMEXP, IMLOG2, IMLOG10"

#~ msgid ""
#~ "@FUNCTION=IMLOG2\n"
#~ "@SYNTAX=IMLOG2(inumber)\n"
#~ "@DESCRIPTION=IMLOG2 returns the logarithm of a complex number in base 2.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMLOG2 returns #VALUE! "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMLOG2(\"3-j\") equals 1.66096-0.46419j.\n"
#~ "\n"
#~ "@SEEALSO=IMLN,IMLOG10"
#~ msgstr ""
#~ "@FUNCTION=IMLOG2\n"
#~ "@SYNTAX=IMLOG2(iZahl)\n"
#~ "@DESCRIPTION=IMLOG2 liefert den Logarithmus einer komplexen Zahl @iZahl "
#~ "zur Basis 2.\n"
#~ "\n"
#~ "* Falls @iZahl keine gültige komplexe Zahl ist, liefert IMLOG2 einen "
#~ "#WERT!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMLOG2(\"3-j\") liefert 1.66096-0.46419j.\n"
#~ "\n"
#~ "@SEEALSO=IMLÄNGE, IMLOG2"

#~ msgid ""
#~ "@FUNCTION=IMLOG10\n"
#~ "@SYNTAX=IMLOG10(inumber)\n"
#~ "@DESCRIPTION=IMLOG10 returns the logarithm of a complex number in base "
#~ "10.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMLOG10 returns #VALUE! "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMLOG10(\"3-j\") equals 0.5-0.13973j.\n"
#~ "\n"
#~ "@SEEALSO=IMLN,IMLOG2"
#~ msgstr ""
#~ "@FUNCTION=IMLOG10\n"
#~ "@SYNTAX=IMLOG10(iZahl)\n"
#~ "@DESCRIPTION=IMLOG10 liefert den Logarithmus einer komplexen Zahl @iZahl "
#~ "zur Basis 10.\n"
#~ "\n"
#~ "* Falls @iZahl keine gültige komplexe Zahl ist, liefert IMLOG10 einen "
#~ "#WERT!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMLOG10(\"3-j\") liefert 0.5-0.13973.\n"
#~ "\n"
#~ "@SEEALSO=IMLÄNGE, IMLOG2"

#~ msgid ""
#~ "@FUNCTION=IMPOWER\n"
#~ "@SYNTAX=IMPOWER(inumber1,inumber2)\n"
#~ "@DESCRIPTION=IMPOWER returns a complex number raised to a power.  "
#~ "@inumber1 is the complex number to be raised to a power and @inumber2 is "
#~ "the power to which you want to raise it.\n"
#~ "\n"
#~ "* If @inumber1 or @inumber2 are not valid complex numbers, IMPOWER "
#~ "returns #VALUE! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMPOWER(\"4-j\",2) equals 15-8j.\n"
#~ "\n"
#~ "@SEEALSO=IMSQRT"
#~ msgstr ""
#~ "@FUNCTION=IMPOTENZ\n"
#~ "@SYNTAX=IMPOTENZ(iZahl1,iZahl2)\n"
#~ "@DESCRIPTION=IMPOTENZ liefert eine komplexe Zahl @iZahl1, potenziert mit "
#~ "einer anderen Zahl @iZahl2.\n"
#~ "@iZahl1 ist die komplexe, zu potenzierende Zahl und @iZahl2 ist die Zahl, "
#~ "mit der sie potenziert werden soll.\n"
#~ "\n"
#~ "* Falls @iZahl1 oder @iZahl2 keine gültige komplexe Zahl ist, liefert "
#~ "IMPOTENZ einen #WERT!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMPOTENZ(\"4-j\",2) liefert 15-8j.\n"
#~ "\n"
#~ "@SEEALSO=IMWURZEL"

#~ msgid ""
#~ "@FUNCTION=IMDIV\n"
#~ "@SYNTAX=IMDIV(inumber1,inumber2)\n"
#~ "@DESCRIPTION=IMDIV returns the quotient of two complex numbers.\n"
#~ "\n"
#~ "* If @inumber1 or @inumber2 are not valid complex numbers, IMDIV returns "
#~ "#VALUE! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMDIV(\"2-j\",\"2+j\") equals 0.6-0.8j.\n"
#~ "\n"
#~ "@SEEALSO=IMPRODUCT"
#~ msgstr ""
#~ "@FUNCTION=IMDIV\n"
#~ "@SYNTAX=IMDIV(iZahl1,iZahl2)\n"
#~ "@DESCRIPTION=IMDIV liefert den Quotienten zweier komplexer Zahlen @iZahl1 "
#~ "und @iZahl2.\n"
#~ "\n"
#~ "* Falls @iZahl1 oder @iZahl2 keine gültige komplexen Zahlen ist, liefert "
#~ "IMDIV einen #WERT!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMDIV(\"3-j\",\"2+j\") liefert 0.6-0.8j.\n"
#~ "\n"
#~ "@SEEALSO=IMPRODUKT"

#~ msgid ""
#~ "@FUNCTION=IMSIN\n"
#~ "@SYNTAX=IMSIN(inumber)\n"
#~ "@DESCRIPTION=IMSIN returns the sine of a complex number.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMSIN returns #VALUE! "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMSIN(\"1+j\") equals 1.29846+0.63496j.\n"
#~ "\n"
#~ "@SEEALSO=IMCOS,IMTAN"
#~ msgstr ""
#~ "@FUNCTION=IMSIN\n"
#~ "@SYNTAX=IMSIN(iZahl)\n"
#~ "@DESCRIPTION=IMSIN liefert den Sinus einer komplexen Zahl @iZahl.\n"
#~ "\n"
#~ "* Falls @iZahl keine gültige komplexe Zahl ist, liefert IMSIN einen "
#~ "#WERT!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMSIN(\"1+j\") liefert 1.29846+0.63496j.\n"
#~ "\n"
#~ "@SEEALSO=IMCOS, IMTAN"

#~ msgid ""
#~ "@FUNCTION=IMSINH\n"
#~ "@SYNTAX=IMSINH(inumber)\n"
#~ "@DESCRIPTION=IMSINH returns the complex hyperbolic sine of the complex "
#~ "number z (@inumber), where\n"
#~ "\n"
#~ "\tsinh(z) = (exp(z) - exp(-z))/2.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMSINH returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMSINH(\"1+j\") equals 0.63496+1.29846j.\n"
#~ "\n"
#~ "@SEEALSO=IMCOSH,IMTANH"
#~ msgstr ""
#~ "@FUNCTION=IMSINHYP\n"
#~ "@SYNTAX=IMSINHYP(iZahl)\n"
#~ "@DESCRIPTION=IMSINHYP liefert den komplexen hyperbolischen Sinus einer "
#~ "komplexen Zahl z (@iZahl), wobei\n"
#~ "\n"
#~ "\tsinh(z) = (exp(z) - exp(-z))/2.\n"
#~ "\n"
#~ "* Falls @iZahl keine gültige komplexe Zahl ist, liefert IMSINHYP einen "
#~ "#WERT!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMSINHYP(\"1+j\") liefert 0.63496+1.29846j.\n"
#~ "\n"
#~ "@SEEALSO=IMCOSHYP,IMTANHYP"

#~ msgid ""
#~ "@FUNCTION=IMCOSH\n"
#~ "@SYNTAX=IMCOSH(inumber)\n"
#~ "@DESCRIPTION=IMCOSH returns the complex hyperbolic cosine of the complex "
#~ "number z (@inumber), where\n"
#~ "\n"
#~ "\tcosh(z) = (exp(z) + exp(-z))/2.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMCOSH returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMCOSH(\"1+j\") equals 0.83373+0.988898j.\n"
#~ "\n"
#~ "@SEEALSO=IMSINH,IMTANH"
#~ msgstr ""
#~ "@FUNCTION=IMCOSHYP\n"
#~ "@SYNTAX=IMCOSHYP(iZahl)\n"
#~ "@DESCRIPTION=IMCOSHYP liefert den komplexen hyperbolischen Cosinus einer "
#~ "komplexen Zahl @iZahl, wobei\n"
#~ "\n"
#~ "\t(EXP(@iZahl) + EXP(-@iZahl)) / 2.\n"
#~ "\n"
#~ "* Falls @iZahl keine gültige komplexe Zahl ist, liefert IMCOSHYP einen "
#~ "#WERT!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMCOSHYP(\"1+j\") liefert 0.833733+0.88898j.\n"
#~ "\n"
#~ "@SEEALSO=IMSINHYP, IMTANHYP"

#~ msgid ""
#~ "@FUNCTION=IMTANH\n"
#~ "@SYNTAX=IMTANH(inumber)\n"
#~ "@DESCRIPTION=IMTANH returns the complex hyperbolic tangent of the complex "
#~ "number z (@inumber), where\n"
#~ "\n"
#~ "\ttanh(z) = sinh(z)/cosh(z).\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMTANH returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMTANH(\"1+j\") equals 1.083923+0.2717526j.\n"
#~ "\n"
#~ "@SEEALSO=IMSINH,IMCOSH"
#~ msgstr ""
#~ "@FUNCTION=IMTANHYP\n"
#~ "@SYNTAX=IMTANHYP(iZahl)\n"
#~ "@DESCRIPTION=IMTANHYP liefert den komplexen hyperbolischen Tangens einer "
#~ "komplexen Zahl @iZahl, wobei\n"
#~ "\n"
#~ "\tIMSINHYP(@iZahl) + IMCOSHYP(@iZahl).\n"
#~ "\n"
#~ "* Falls @iZahl keine gültige komplexe Zahl ist, liefert IMTANHYP einen "
#~ "#WERT!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMTANHYP(\"1+j\") liefert 1.083924+0.2717526j.\n"
#~ "\n"
#~ "@SEEALSO=IMSINHYP, IMCOSHYP"

#~ msgid ""
#~ "@FUNCTION=IMSECH\n"
#~ "@SYNTAX=IMSECH(inumber)\n"
#~ "@DESCRIPTION=IMSECH returns the complex hyperbolic secant of the complex "
#~ "number z (@inumber), where\n"
#~ "\n"
#~ "\tsech(z) = 1/cosh(z).\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMSECH returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMSECH(\"1+j\") equals 0.498337-0.5910838j.\n"
#~ "\n"
#~ "@SEEALSO=IMCSCH,IMCOTH"
#~ msgstr ""
#~ "@FUNCTION=IMSEKHYP\n"
#~ "@SYNTAX=IMSEKHYP(iZahl)\n"
#~ "@DESCRIPTION=IMSEKHYP liefert die komplexe hyperbolische Sekante einer "
#~ "komplexen Zahl z (@iZahl), wobei\n"
#~ "\n"
#~ "\tsech(z) = 1/cosh(z).\n"
#~ "\n"
#~ "* Falls @iZahl keine gültige komplexe Zahl ist, liefert IMSEKHYP einen "
#~ "#WERT-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMSEKHYP(\"1+j\") liefert 0.498337-0.5910838j.\n"
#~ "\n"
#~ "@SEEALSO=IMKOSEKHYP,IMCOTHYP"

#~ msgid ""
#~ "@FUNCTION=IMCSCH\n"
#~ "@SYNTAX=IMCSCH(inumber)\n"
#~ "@DESCRIPTION=IMCSCH returns the complex hyperbolic cosecant of the "
#~ "complex number z (@inumber), where\n"
#~ "\n"
#~ "\tcsch(z) = 1/sinh(z).\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMCSCH returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMCSCH(\"1+j\") equals 0.303931-0.621518j.\n"
#~ "\n"
#~ "@SEEALSO=IMSECH,IMCOTH"
#~ msgstr ""
#~ "@FUNCTION=IMKOSEKHYP\n"
#~ "@SYNTAX=IMKOSEKHYP(iZahl)\n"
#~ "@DESCRIPTION=IMKOSEKHYP liefert die komplexe hyperbolische Kosekante "
#~ "einer komplexen Zahl z (@iZahl), wobei\n"
#~ "\n"
#~ "\tcsch(z) = 1/sinh(z).\n"
#~ "\n"
#~ "* Falls @iZahl keine gültige komplexe Zahl ist, liefert IMKOSEKHYP einen "
#~ "#WERT!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMKOSEKHYP(\"1+j\") liefert 0.303931-0.621518j.\n"
#~ "\n"
#~ "@SEEALSO=IMSEKHYP,IMCOTHYP"

#~ msgid ""
#~ "@FUNCTION=IMCOTH\n"
#~ "@SYNTAX=IMCOTH(inumber)\n"
#~ "@DESCRIPTION=IMCOTH returns the complex hyperbolic cotangent of the "
#~ "complex number z (@inumber) where,\n"
#~ "\n"
#~ "\tcoth(z) = 1/tanh(z).\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMCOTH returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMCOTH(\"1+j\") equals 0.868014-0.217622j.\n"
#~ "\n"
#~ "@SEEALSO=IMSECH,IMCSCH"
#~ msgstr ""
#~ "@FUNCTION=IMCOTANHYP\n"
#~ "@SYNTAX=IMCOTANHYP(iZahl)\n"
#~ "@DESCRIPTION=IMCOTANHYP liefert den komplexen hyperbolischen Cotangens "
#~ "einer komplexen Zahl z (@iZahl), wobei\n"
#~ "\n"
#~ "\tcoth(z) = 1/tanh(z).\n"
#~ "\n"
#~ "* Falls @iZahl keine gültige komplexe Zahl ist, liefert IMCOTANHYP einen "
#~ "#WERT!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMCOTH(\"1+j\") liefert 0.868014-0.217622j.\n"
#~ "\n"
#~ "@SEEALSO=IMSEKHYP"

#~ msgid ""
#~ "@FUNCTION=IMARCSIN\n"
#~ "@SYNTAX=IMARCSIN(inumber)\n"
#~ "@DESCRIPTION=IMARCSIN returns the complex arcsine of the complex number "
#~ "@inumber. The branch cuts are on the real axis, less than -1 and greater "
#~ "than 1.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMARCSIN returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCSIN(\"1+j\") equals 0.6662394+1.061275j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCCOS,IMARCTAN"
#~ msgstr ""
#~ "@FUNCTION=IMARCSIN\n"
#~ "@SYNTAX=IMARCSIN(iZahl)\n"
#~ "@DESCRIPTION=IMARCSIN liefert den komplexen Arcus Sinus einer komplexen "
#~ "Zahl @iZahl. Die Branch-Cuts liegen auf der reellen Achse, unterhalb von "
#~ "-1 und oberhalb von 1.\n"
#~ "\n"
#~ "* Falls @iZahl keine gültige komplexe Zahl ist, liefert IMARCSIN einen "
#~ "#WERT!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCSIN(\"1+j\") liefert 0.6662394+1.061275j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCCOS,IMARCTAN"

#~ msgid ""
#~ "@FUNCTION=IMARCCOS\n"
#~ "@SYNTAX=IMARCCOS(inumber)\n"
#~ "@DESCRIPTION=IMARCCOS returns the complex arccosine of the complex number "
#~ "@inumber. The branch cuts are on the real axis, less than -1 and greater "
#~ "than 1.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMARCCOS returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCCOS(\"1+j\") equals 0.9045569-1.061275j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCSIN,IMARCTAN"
#~ msgstr ""
#~ "@FUNCTION=IMARCCOS\n"
#~ "@SYNTAX=IMARCCOS(iZahl)\n"
#~ "@DESCRIPTION=IMARCCOS liefert den komplexen Arcus Cosinus einer komplexen "
#~ "Zahl @iZahl. Die Branch-Cuts liegen auf der reellen Achse, unterhalb von "
#~ "-1 und oberhalb von 1.\n"
#~ "\n"
#~ "* Falls @iZahl keine gültige komplexe Zahl ist, liefert IMARCCOS einen "
#~ "#WERT!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCCOS(\"1+j\") liefert 0.6662394+1.061275j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCSIN,IMARCTAN"

#~ msgid ""
#~ "@FUNCTION=IMARCTAN\n"
#~ "@SYNTAX=IMARCTAN(inumber)\n"
#~ "@DESCRIPTION=IMARCTAN returns the complex arctangent of the complex "
#~ "number @inumber. The branch cuts are on the imaginary axis, below -i and "
#~ "above i.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMARCTAN returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCTAN(\"1+j\") equals 1.0172220+0.4023595j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCSIN,IMARCCOS"
#~ msgstr ""
#~ "@FUNCTION=IMARCTAN\n"
#~ "@SYNTAX=IMARCTAN(iZahl)\n"
#~ "@DESCRIPTION=IMARCTAN liefert den komplexen Arcus Tangens einer komplexen "
#~ "Zahl @iZahl. Die Branch-Cuts liegen auf der imaginären Achse, unterhalb "
#~ "von -i und oberhalb von i.\n"
#~ "\n"
#~ "* Falls @iZahl keine gültige komplexe Zahl ist, liefert IMARCTAN einen "
#~ "#WERT!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCTAN(\"1+j\") liefert 1.0172220+0.4023595j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCSIN,IMARCCOS"

#~ msgid ""
#~ "@FUNCTION=IMARCSEC\n"
#~ "@SYNTAX=IMARCSEC(inumber)\n"
#~ "@DESCRIPTION=IMARCSEC returns the complex arcsecant of the complex number "
#~ "z (@inumber), where\n"
#~ "\n"
#~ "\tarcsec(z) = arccos(1/z).\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMARCSEC returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCSEC(\"1+j\") equals 1.1185179+0.5306375j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCCSC,IMARCCOT"
#~ msgstr ""
#~ "@FUNCTION=IMARCSEK\n"
#~ "@SYNTAX=IMARCSEK(iZahl)\n"
#~ "@DESCRIPTION=IMARCSEK liefert die komplexe Arcus Sekante einer komplexen "
#~ "Zahl z (@iZahl), wobei\n"
#~ "\n"
#~ "\tarcsek(z) = arccos(1/z).\n"
#~ "\n"
#~ "* Falls @iZahl keine gültige komplexe Zahl ist, liefert IMARCSEK einen "
#~ "#WERT-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCSEK(\"1+j\") liefert 1.1185179+0.5306375j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCKOSEK,IMARCCOT"

#~ msgid ""
#~ "@FUNCTION=IMARCCSC\n"
#~ "@SYNTAX=IMARCCSC(inumber)\n"
#~ "@DESCRIPTION=IMARCCSC returns the complex arccosecant of the complex "
#~ "number z (@inumber), where\n"
#~ "\n"
#~ "\tarccsc(z) = arcsin(1/z).\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMARCCSC returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCCSC(\"1+j\") equals 0.45227845-0.5306375j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCSEC,IMARCCOT"
#~ msgstr ""
#~ "@FUNCTION=IMARCKOSEK\n"
#~ "@SYNTAX=IMARCKOSEK(iZahl)\n"
#~ "@DESCRIPTION=IMARCKOSEK liefert die komplexe Arcus Kosekante einer "
#~ "komplexen Zahl z (@iZahl), wobei\n"
#~ "\n"
#~ "\tarccsc(z) = arcsin(1/z).\n"
#~ "\n"
#~ "* Falls @iZahl keine gültige komplexe Zahl ist, liefert IMARCKOSEK einen "
#~ "#WERT!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCCSC(\"1+j\") liefert 0.45227845-0.5306375j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCSEK,IMARCCOT"

#~ msgid ""
#~ "@FUNCTION=IMARCCOT\n"
#~ "@SYNTAX=IMARCCOT(inumber)\n"
#~ "@DESCRIPTION=IMARCCOT returns the complex arccotangent of the complex "
#~ "number z (@inumber), where\n"
#~ "\n"
#~ "\tarccot(z) = arctan(1/z).\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMARCCOT returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCCOT(\"1+j\") equals 0.553574+0.4023595j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCSEC,IMARCCSC"
#~ msgstr ""
#~ "@FUNCTION=IMARCCOTAN\n"
#~ "@SYNTAX=IMARCCOTAN(iZahl)\n"
#~ "@DESCRIPTION=IMARCCOTAN liefert den komplexen Arcus Cotangens einer "
#~ "komplexen Zahl z (@iZahl), wobei\n"
#~ "\n"
#~ "\tarccot(z) = arctan(1/z).\n"
#~ "\n"
#~ "* Falls @iZahl keine gültige komplexe Zahl ist, liefert IMARCCOTAN einen "
#~ "#WERT!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCCOTAN(\"1+j\") liefert 0.553574+0.4023595j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCSEK,IMARCKOSEK"

#~ msgid ""
#~ "@FUNCTION=IMARCSINH\n"
#~ "@SYNTAX=IMARCSINH(inumber)\n"
#~ "@DESCRIPTION=IMARCSINH returns the complex hyperbolic arcsine of the "
#~ "complex number @inumber. The branch cuts are on the imaginary axis, below "
#~ "-i and above i.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMARCSINH returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCSINH(\"1+j\") equals 1.061275+0.6662394j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCCOSH,IMARCTANH"
#~ msgstr ""
#~ "@FUNCTION=IMARCSINHYP\n"
#~ "@SYNTAX=IMARCSINHYP(iZahl)\n"
#~ "@DESCRIPTION=IMARCSINHYP liefert den komplexen hyperbolischen Arcus Sinus "
#~ "einer komplexen Zahl @iZahl. Die Branch-Cuts liegen auf der imaginären "
#~ "Achse, unterhalb von -i und oberhalb von i.\n"
#~ "\n"
#~ "* Falls @iZahl keine gültige komplexe Zahl ist, liefert IMARCSINHYP einen "
#~ "#WERT!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCSINHYP(\"1+j\") liefert 1.061275+06662394j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCCOSINHYP,IMARCTANHYP"

#~ msgid ""
#~ "@FUNCTION=IMARCCOSH\n"
#~ "@SYNTAX=IMARCCOSH(inumber)\n"
#~ "@DESCRIPTION=IMARCCOSH returns the complex hyperbolic arccosine of the "
#~ "complex number @inumber. The branch cut is on the real axis, less than "
#~ "1.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMARCCOSH returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCCOSH(\"1+j\") equals 1.06127506+0.904557j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCSINH,IMARCTANH"
#~ msgstr ""
#~ "@FUNCTION=IMARCCOSINHYP\n"
#~ "@SYNTAX=IMARCCOSINHYP(iZahl)\n"
#~ "@DESCRIPTION=IMARCCOSINHYP liefert den komplexen hyperbolischen Arcus "
#~ "Cosinus einer komplexen Zahl @iZahl. Der Branch-Cut liegt auf der reellen "
#~ "Achse, kleiner 1.\n"
#~ "\n"
#~ "* Falls @iZahl keine gültige komplexe Zahl ist, liefert IMARCCOSINHYP "
#~ "einen #WERT!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCCOSINHYP(\"1+j\") liefert 1.06127506+0.904557j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCSINHYP,IMARCTANHYP"

#~ msgid ""
#~ "@FUNCTION=IMARCTANH\n"
#~ "@SYNTAX=IMARCTANH(inumber)\n"
#~ "@DESCRIPTION=IMARCTANH returns the complex hyperbolic arctangent of the "
#~ "complex number @inumber. The branch cuts are on the real axis, less than "
#~ "-1 and greater than 1.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMARCTANH returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCTANH(\"1+j\") equals 0.4023595+1.0172220j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCSINH,IMARCCOSH"
#~ msgstr ""
#~ "@FUNCTION=IMARCTANHYP\n"
#~ "@SYNTAX=IMARCTANHYP(iZahl)\n"
#~ "@DESCRIPTION=IMARCTANHYP liefert den hyperbolischen Arcus Tangens einer "
#~ "komplexen Zahl @iZahl. Die Branch-Cuts liegen auf der reellen Achse, "
#~ "unterhalb von -1 und oberhalb von 1.\n"
#~ "\n"
#~ "* Falls @iZahl keine gültige komplexe Zahl ist, liefert IMARCTANHYP einen "
#~ "#WERT!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCTANHYP(\"1+j\") liefert 0.4023595+1.0172220j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCSINHYP,IMARCCOSHYP"

#~ msgid ""
#~ "@FUNCTION=IMARCSECH\n"
#~ "@SYNTAX=IMARCSECH(inumber)\n"
#~ "@DESCRIPTION=IMARCSECH returns the complex hyperbolic arcsecant of the "
#~ "complex number z (@inumber), where\n"
#~ "\n"
#~ "\tarcsech(z) = arccosh(1/z).\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMARCSECH returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCSECH(\"1+j\") equals 0.5306375-1.118518j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCCSCH,IMARCCOTH"
#~ msgstr ""
#~ "@FUNCTION=IMARCSEKHYP\n"
#~ "@SYNTAX=IMARCSEKHYP(iZahl)\n"
#~ "@DESCRIPTION=IMARCSEKHYP liefert die komplexe hyperbolische Arcus Sekante "
#~ "einer komplexen Zahl z (@iZahl), wobei\n"
#~ "\n"
#~ "\tarcsech(z) = arccosh(1/z).\n"
#~ "\n"
#~ "* Falls @iZahl keine gültige komplexe Zahl ist, liefert IMARCSEKHYP einen "
#~ "#WERT!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCSEKHYP(\"1+j\") liefert 0.5306375-1.118518j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCKOSEKHYP,IMARCCOTHYP"

#~ msgid ""
#~ "@FUNCTION=IMARCCSCH\n"
#~ "@SYNTAX=IMARCCSCH(inumber)\n"
#~ "@DESCRIPTION=IMARCCSCH returns the complex hyperbolic arccosecant of the "
#~ "complex number z (@inumber), where\n"
#~ "\n"
#~ "\tarccsch(z) = arcsinh(1/z).\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMARCCSCH returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCCSCH(\"1+j\") equals 0.5306375-0.452278j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCSECH,IMARCCOTH"
#~ msgstr ""
#~ "@FUNCTION=IMARCKOSEKHYP\n"
#~ "@SYNTAX=IMARCKOSEKHYP(iZahl)\n"
#~ "@DESCRIPTION=IMARCKOSEKHYP liefert die komplexe hyperbolische Arcus "
#~ "Kosekante einer komplexen Zahl z (@iZahl), wobei\n"
#~ "\n"
#~ "\tarccsch(z) = arcsin(1/z).\n"
#~ "\n"
#~ "* Falls @iZahl keine gültige komplexe Zahl ist, liefert IMARCKOSEKHYP "
#~ "einen #WERT!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCKOSEKHYP(\"1+j\") liefert 0.5306375-0.452278j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCSEKHYP,IMARCCOTHYP"

#~ msgid ""
#~ "@FUNCTION=IMARCCOTH\n"
#~ "@SYNTAX=IMARCCOTH(inumber)\n"
#~ "@DESCRIPTION=IMARCCOTH returns the complex hyperbolic arccotangent of the "
#~ "complex number z (@inumber), where\n"
#~ "\n"
#~ "\tarccoth(z) = arctanh(1/z).\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMARCCOTH returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCCOTH(\"1+j\") equals 0.40235948-0.5535744j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCSECH,IMARCCSCH"
#~ msgstr ""
#~ "@FUNCTION=IMARCCOTHYP\n"
#~ "@SYNTAX=IMARCCOTHYP(iZahl)\n"
#~ "@DESCRIPTION=IMARCCOTHYP liefert den komplexen hyperbolischen Arcus "
#~ "Tangens der Zahl z (@iZahl), wobei\n"
#~ "\n"
#~ "\tarccoth(z) = arctanh(1/z).\n"
#~ "\n"
#~ "* Falls @iZahl keine gültige komplexe Zahl ist, liefert IMARCCOTHYP einen "
#~ "#WERT!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMARCCOTHYP(\"1+j\") liefert 0.40235948-0.5535744j.\n"
#~ "\n"
#~ "@SEEALSO=IMARCSEKHYP,IMARCKOSEKHYP"

#~ msgid ""
#~ "@FUNCTION=IMSQRT\n"
#~ "@SYNTAX=IMSQRT(inumber)\n"
#~ "@DESCRIPTION=IMSQRT returns the square root of a complex number.\n"
#~ "\n"
#~ "* If @inumber is not a valid complex number, IMSQRT returns #VALUE! "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMSQRT(\"1+j\") equals 1.09868+0.4550899j.\n"
#~ "\n"
#~ "@SEEALSO=IMPOWER"
#~ msgstr ""
#~ "@FUNCTION=IMWURZEL\n"
#~ "@SYNTAX=IMWURZEL(iZahl)\n"
#~ "@DESCRIPTION=IMWURZEL liefert die Quadratwurzel einer komplexen Zahl "
#~ "@iZahl.\n"
#~ "\n"
#~ "* Falls @iZahl keine gültige komplexe Zahl ist, liefert IMWURZEL einen "
#~ "#WERT!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMWURZEL(\"1+j\") liefert 1.09868+0.4550899j.\n"
#~ "\n"
#~ "@SEEALSO=IMPOTENZ"

#~ msgid ""
#~ "@FUNCTION=IMSUB\n"
#~ "@SYNTAX=IMSUB(inumber1,inumber2)\n"
#~ "@DESCRIPTION=IMSUB returns the difference of two complex numbers.\n"
#~ "\n"
#~ "* If @inumber1 or @inumber2 are not valid complex numbers, IMSUB returns "
#~ "#VALUE! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMSUB(\"3-j\",\"2+j\") equals 1-2j.\n"
#~ "\n"
#~ "@SEEALSO=IMSUM"
#~ msgstr ""
#~ "@FUNCTION=IMDIFFERENZ\n"
#~ "@SYNTAX=IMDIFFERENZ(iZahl1,iZahl2)\n"
#~ "@DESCRIPTION=IMDIFFERENZ liefert die Differenz zweier komplexer Zahlen "
#~ "@iZahl1 und @iZahl2.\n"
#~ "\n"
#~ "* Falls @iZahl1 oder @iZahl2 keine komplexe Zahl ist, liefert IMDIFFERENZ "
#~ "einen #WERT!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMDIFFERENZ(\"3-j\",\"2+j\") liefert 1-2j.\n"
#~ "\n"
#~ "@SEEALSO=IMSUMME"

#~ msgid ""
#~ "@FUNCTION=IMPRODUCT\n"
#~ "@SYNTAX=IMPRODUCT(inumber1[,inumber2,...])\n"
#~ "@DESCRIPTION=IMPRODUCT returns the product of given complex numbers.\n"
#~ "\n"
#~ "* If any of the @inumbers are not valid complex numbers, IMPRODUCT "
#~ "returns #VALUE! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMPRODUCT(\"2-j\",\"4-2j\") equals 6-8j.\n"
#~ "\n"
#~ "@SEEALSO=IMDIV"
#~ msgstr ""
#~ "@FUNCTION=IMPRODUKT\n"
#~ "@SYNTAX=IMPRODUKT(iZahl1[,iZahl2,...])\n"
#~ "@DESCRIPTION=IMPRODUKT liefert das Produkt der angegebenen komplexen "
#~ "Zahlen.\n"
#~ "\n"
#~ "* Falls eine @iZahl keine gültige komplexe Zahl ist, liefert IMPRODUKT "
#~ "einen #WERT!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMPRODUKT(\"2-j\",\"4-2j\") liefert 6-8j.\n"
#~ "\n"
#~ "@SEEALSO=IMDIV"

#~ msgid ""
#~ "@FUNCTION=IMSUM\n"
#~ "@SYNTAX=IMSUM(inumber1,inumber2)\n"
#~ "@DESCRIPTION=IMSUM returns the sum of two complex numbers.\n"
#~ "\n"
#~ "* If @inumber1 or @inumber2 are not valid complex numbers, IMSUM returns "
#~ "#VALUE! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMSUM(\"2-4j\",\"9-j\") equals 11-5j.\n"
#~ "\n"
#~ "@SEEALSO=IMSUB"
#~ msgstr ""
#~ "@FUNCTION=IMSUMME\n"
#~ "@SYNTAX=IMSUMME(iZahl1,iZahl2)\n"
#~ "@DESCRIPTION=IMSUMME liefert die Summe zweier komplexer Zahlen @iZahl1 "
#~ "und @iZahl2.\n"
#~ "\n"
#~ "* Falls @iZahl1 oder @iZahl2 keine komplexe Zahl ist, liefert IMSUMME "
#~ "einen #WERT!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IMSUMME(\"2-4j\",\"9-j\") liefert 11-5j.\n"
#~ "\n"
#~ "@SEEALSO=IMSUB"

#~ msgid ""
#~ "@FUNCTION=DAVERAGE\n"
#~ "@SYNTAX=DAVERAGE(database,field,criteria)\n"
#~ "@DESCRIPTION=DAVERAGE function returns the average of the values in a "
#~ "list or database that match conditions specified.\n"
#~ "\n"
#~ "@database is a range of cells in which rows of related information are "
#~ "records and columns of data are fields. The first row of a database "
#~ "contains labels for each column. \n"
#~ "\n"
#~ "@field specifies which column is used in the function.  If @field is an "
#~ "integer, for example 2, the second column is used. Field can also be the "
#~ "label of a column.  For example, ``Age'' refers to the column with the "
#~ "label ``Age'' in @database range. \n"
#~ "\n"
#~ "@criteria is the range of cells which contains the specified conditions.  "
#~ "The first row of a @criteria should contain the labels of the fields for "
#~ "which the criteria are for.  Cells below the labels specify conditions, "
#~ "for example, ``>3'' or ``<9''.  Equality condition can be given simply by "
#~ "specifying a value, e.g. ``3'' or ``John''. \n"
#~ "Each row in @criteria specifies a separate condition. If a row in "
#~ "@database matches a row in @criteria, then that row is counted. "
#~ "Technically speaking, this a boolean OR operation between the rows in "
#~ "@criteria.\n"
#~ "If @criteria specifies more than one column, then each of the conditions "
#~ "in the specified columns must be true for the row in @database to match. "
#~ "Technically speaking, this is a boolean AND operation between the columns "
#~ "in @criteria.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the range A1:C7 contain the following values:\n"
#~ "Name    Age     Salary\n"
#~ "John    34      54342\n"
#~ "Bill    35      22343\n"
#~ "Clark   29      34323\n"
#~ "Bob     43      47242\n"
#~ "Susan   37      42932\n"
#~ "Jill    45      45324\n"
#~ "\n"
#~ "In addition, the cells A9:B11 contain the following values:\n"
#~ "Age     Salary\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "DAVERAGE(A1:C7, \"Salary\", A9:A11) equals 42296.3333.\n"
#~ "DAVERAGE(A1:C7, \"Age\", A9:A11) equals 39.\n"
#~ "DAVERAGE(A1:C7, \"Salary\", A9:B11) equals 40782.5.\n"
#~ "DAVERAGE(A1:C7, \"Age\", A9:B11) equals 36.\n"
#~ "\n"
#~ "@SEEALSO=DCOUNT"
#~ msgstr ""
#~ "@FUNCTION=DBMITTELWERT\n"
#~ "@SYNTAX=DBMITTELWERT(Datenbank,Feld,Kriterien)\n"
#~ "@DESCRIPTION=DBMITTELWERT liefert den Mittelwert der Werte in einer Liste "
#~ "oder Datenbank, die den angegebenen Kriterien entsprechen.\n"
#~ "\n"
#~ "@Datenbank ist ein Zellbereich, in dem Zeilen Datensätze und Spalten "
#~ "Datenfelder sind. Die erste Zeile einer Datenbank enthält die "
#~ "Beschriftungen für die jeweiligen Spalten.\n"
#~ "\n"
#~ "@Feld legt fest, welche Spalte für die Funktion verwendet wird und darf "
#~ "eine Ganzzahl oder eine Zeichenkette sein. Falls n (@Feld) ganzzahlig "
#~ "ist, wird die n-te Spalte verwendet, falls @Feld jedoch als Zeichenkette "
#~ "übergeben wird, wird diese als Bezug zur Spalte mit der Beschriftung "
#~ "\"@Feld\" interpretiert.\n"
#~ "\n"
#~ "@Kriterien ist der Zellbereich, der die zu erfüllenden Bedingungen "
#~ "enthält. Die erste Zeile in @Kriterien sollte die Beschriftungen der "
#~ "Felder enthalten, für die die Kriterien gelten. Zellen unterhalb der "
#~ "Beschriftungen legen Bedingungen fest, zum Beispiel »>3« oder »<9«. Ist-"
#~ "gleich-Bedingungen können als Wert (z.B. »3« oder »Johann«) übergeben "
#~ "werden.\n"
#~ "Jede Zeile in @Kriterien gibt eine einzelne Bedingung an. Wenn also eine "
#~ "Zeile in @Datenbank mit einer der Zeilen in @Kriterien übereinstimmt, "
#~ "dann wird diese Zeile gezählt (technisch ausgedrückt ist dies ein "
#~ "Boolsches ODER zwischen den Zeilen in @Kriterien).\n"
#~ "Falls @Kriterien mehr als eine Spalte angibt, muss jede der Bedingungen "
#~ "in diesen Spalten wahr sein, damit sie auf @Datenbank zutrifft (also ein "
#~ "Boolsches UND zwischen den Spalten in jeder Zeile in @Kriterien).\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, der Zellbereich A1:C7 enthält folgende Werte:\n"
#~ "Name    Alter   Gehalt\n"
#~ "Johann  34      54342\n"
#~ "Fritz   35      22343\n"
#~ "Heinz   29      34323\n"
#~ "Kurt    43      47242\n"
#~ "Susanne 37      42932\n"
#~ "Robert  45      45324\n"
#~ "\n"
#~ "Zusätzlich enthält der Zellbereich A9:B1 folgende Werte:\n"
#~ "Alter   Gehalt\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "Dann gilt:\n"
#~ "DBMITTELWERT(A1:C7, \"Gehalt\", A9:A11) liefert 42296.3333.\n"
#~ "DBMITTELWERT(A1:C7, \"Alter\", A9:A11) liefert 39.\n"
#~ "DBMITTELWERT(A1:C7, \"Gehalt\", A9:B11) liefert 40782.5.\n"
#~ "DBMITTELWERT(A1:C7, \"Alter\", A9:B11) liefert 36.\n"
#~ "\n"
#~ "@SEEALSO=DBANZAHL"

#~ msgid ""
#~ "@FUNCTION=DCOUNT\n"
#~ "@SYNTAX=DCOUNT(database,field,criteria)\n"
#~ "@DESCRIPTION=DCOUNT function counts the cells that contain numbers in a "
#~ "database that match conditions specified.\n"
#~ "\n"
#~ "@database is a range of cells in which rows of related information are "
#~ "records and columns of data are fields. The first row of a database "
#~ "contains labels for each column. \n"
#~ "\n"
#~ "@field specifies which column is used in the function.  If @field is an "
#~ "integer, for example 2, the second column is used. Field can also be the "
#~ "label of a column.  For example, ``Age'' refers to the column with the "
#~ "label ``Age'' in @database range. \n"
#~ "\n"
#~ "@criteria is the range of cells which contains the specified conditions.  "
#~ "The first row of a @criteria should contain the labels of the fields for "
#~ "which the criteria are for.  Cells below the labels specify conditions, "
#~ "for example, ``>3'' or ``<9''.  Equality condition can be given simply by "
#~ "specifying a value, e.g. ``3'' or ``John''. \n"
#~ "Each row in @criteria specifies a separate condition. If a row in "
#~ "@database matches a row in @criteria, then that row is counted. "
#~ "Technically speaking, this a boolean OR operation between the rows in "
#~ "@criteria.\n"
#~ "If @criteria specifies more than one column, then each of the conditions "
#~ "in the specified columns must be true for the row in @database to match. "
#~ "Technically speaking, this is a boolean AND operation between the columns "
#~ "in @criteria.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the range A1:C7 contain the following values:\n"
#~ "Name    Age     Salary\n"
#~ "John    34      54342\n"
#~ "Bill    35      22343\n"
#~ "Clark   29      34323\n"
#~ "Bob     43      47242\n"
#~ "Susan   37      42932\n"
#~ "Jill    45      45324\n"
#~ "\n"
#~ "In addition, the cells A9:B11 contain the following values:\n"
#~ "Age     Salary\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "DCOUNT(A1:C7, \"Salary\", A9:A11) equals 3.\n"
#~ "DCOUNT(A1:C7, \"Salary\", A9:B11) equals 2.\n"
#~ "DCOUNT(A1:C7, \"Name\", A9:B11) equals 0.\n"
#~ "\n"
#~ "@SEEALSO=DAVERAGE"
#~ msgstr ""
#~ "@FUNCTION=DBANZAHL\n"
#~ "@SYNTAX=DBANZAHL(Datenbank,Feld,Kriterien)\n"
#~ "@DESCRIPTION=DBANZAHL zählt die Zellen in einer Datenbank, die Zahlen "
#~ "enthalten, die den angegebenen Kriterien entsprechen.\n"
#~ "\n"
#~ "@Datenbank ist ein Zellbereich, in dem Zeilen Datensätze und Spalten "
#~ "Datenfelder sind. Die erste Zeile einer Datenbank enthält die "
#~ "Beschriftungen für die jeweiligen Spalten.\n"
#~ "\n"
#~ "@Feld legt fest, welche Spalte für die Funktion verwendet wird und darf "
#~ "eine Ganzzahl oder eine Zeichenkette sein. Falls n (@Feld) ganzzahlig "
#~ "ist, wird die n-te Spalte verwendet, falls @Feld jedoch als Zeichenkette "
#~ "übergeben wird, wird diese als Bezug zur Spalte mit der Beschriftung "
#~ "\"@Feld\" interpretiert.\n"
#~ "\n"
#~ "@Kriterien ist der Zellbereich, der die zu erfüllenden Bedingungen "
#~ "enthält. Die erste Zeile in @Kriterien sollte die Beschriftungen der "
#~ "Felder enthalten, für die die Kriterien gelten. Zellen unterhalb der "
#~ "Beschriftungen legen Bedingungen fest, zum Beispiel »>3« oder »<9«. Ist-"
#~ "gleich-Bedingungen können als Wert (z.B. »3« oder »Johann«) übergeben "
#~ "werden.\n"
#~ "Jede Zeile in @Kriterien gibt eine einzelne Bedingung an. Wenn also eine "
#~ "Zeile in @Datenbank mit einer der Zeilen in @Kriterien übereinstimmt, "
#~ "dann wird diese Zeile gezählt (technisch ausgedrückt ist dies ein "
#~ "Boolsches ODER zwischen den Zeilen in @Kriterien).\n"
#~ "Falls @Kriterien mehr als eine Spalte angibt, muss jede der Bedingungen "
#~ "in diesen Spalten wahr sein, damit sie auf @Datenbank zutrifft (also ein "
#~ "Boolsches UND zwischen den Spalten in jeder Zeile in @Kriterien).\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, der Zellbereich A1:C7 enthält folgende Werte:\n"
#~ "Name    Alter   Gehalt\n"
#~ "Johann  34      54342\n"
#~ "Fritz   35      22343\n"
#~ "Heinz   29      34323\n"
#~ "Kurt    43      47242\n"
#~ "Susanne 37      42932\n"
#~ "Robert  45      45324\n"
#~ "\n"
#~ "Zusätzlich enthält der Zellbereich A9:B1 folgende Werte:\n"
#~ "Alter   Gehalt\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "Dann gilt:\n"
#~ "DBANZAHL(A1:C7, \"Gehalt\", A9:A11) liefert 3.\n"
#~ "DBANZAHL(A1:C7, \"Gehalt\", A9:B11) liefert 2.\n"
#~ "DBANZAHL(A1:C7, \"Name\", A9:B11) liefert 0.\n"
#~ "\n"
#~ "@SEEALSO=DBMITTELWERT"

#~ msgid ""
#~ "@FUNCTION=DCOUNTA\n"
#~ "@SYNTAX=DCOUNTA(database,field,criteria)\n"
#~ "@DESCRIPTION=DCOUNTA function counts the cells that contain data in a "
#~ "database that match conditions specified.\n"
#~ "\n"
#~ "@database is a range of cells in which rows of related information are "
#~ "records and columns of data are fields. The first row of a database "
#~ "contains labels for each column. \n"
#~ "\n"
#~ "@field specifies which column is used in the function.  If @field is an "
#~ "integer, for example 2, the second column is used. Field can also be the "
#~ "label of a column.  For example, ``Age'' refers to the column with the "
#~ "label ``Age'' in @database range. \n"
#~ "\n"
#~ "@criteria is the range of cells which contains the specified conditions.  "
#~ "The first row of a @criteria should contain the labels of the fields for "
#~ "which the criteria are for.  Cells below the labels specify conditions, "
#~ "for example, ``>3'' or ``<9''.  Equality condition can be given simply by "
#~ "specifying a value, e.g. ``3'' or ``John''. \n"
#~ "Each row in @criteria specifies a separate condition. If a row in "
#~ "@database matches a row in @criteria, then that row is counted. "
#~ "Technically speaking, this a boolean OR operation between the rows in "
#~ "@criteria.\n"
#~ "If @criteria specifies more than one column, then each of the conditions "
#~ "in the specified columns must be true for the row in @database to match. "
#~ "Technically speaking, this is a boolean AND operation between the columns "
#~ "in @criteria.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the range A1:C7 contain the following values:\n"
#~ "Name    Age     Salary\n"
#~ "John    34      54342\n"
#~ "Bill    35      22343\n"
#~ "Clark   29      34323\n"
#~ "Bob     43      47242\n"
#~ "Susan   37      42932\n"
#~ "Jill    45      45324\n"
#~ "\n"
#~ "In addition, the cells A9:B11 contain the following values:\n"
#~ "Age     Salary\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "DCOUNTA(A1:C7, \"Salary\", A9:A11) equals 3.\n"
#~ "DCOUNTA(A1:C7, \"Salary\", A9:B11) equals 2.\n"
#~ "DCOUNTA(A1:C7, \"Name\", A9:B11) equals 2.\n"
#~ "\n"
#~ "@SEEALSO=DCOUNT"
#~ msgstr ""
#~ "@FUNCTION=DBANZAHL2\n"
#~ "@SYNTAX=DBANZAHL2(Datenbank,Feld,Kriterien)\n"
#~ "@DESCRIPTION=DBANZAHL2 zählt die Zellen in einer Datenbank, die Daten "
#~ "enthalten, die den angegebenen Kriterien entsprechen.\n"
#~ "\n"
#~ "@Datenbank ist ein Zellbereich, in dem Zeilen Datensätze und Spalten "
#~ "Datenfelder sind. Die erste Zeile einer Datenbank enthält die "
#~ "Beschriftungen für die jeweiligen Spalten.\n"
#~ "\n"
#~ "@Feld legt fest, welche Spalte für die Funktion verwendet wird und darf "
#~ "eine Ganzzahl oder eine Zeichenkette sein. Falls n (@Feld) ganzzahlig "
#~ "ist, wird die n-te Spalte verwendet, falls @Feld jedoch als Zeichenkette "
#~ "übergeben wird, wird diese als Bezug zur Spalte mit der Beschriftung "
#~ "\"@Feld\" interpretiert.\n"
#~ "\n"
#~ "@Kriterien ist der Zellbereich, der die zu erfüllenden Bedingungen "
#~ "enthält. Die erste Zeile in @Kriterien sollte die Beschriftungen der "
#~ "Felder enthalten, für die die Kriterien gelten. Zellen unterhalb der "
#~ "Beschriftungen legen Bedingungen fest, zum Beispiel »>3« oder »<9«. Ist-"
#~ "gleich-Bedingungen können als Wert (z.B. »3« oder »Johann«) übergeben "
#~ "werden.\n"
#~ "Jede Zeile in @Kriterien gibt eine einzelne Bedingung an. Wenn also eine "
#~ "Zeile in @Datenbank mit einer der Zeilen in @Kriterien übereinstimmt, "
#~ "dann wird diese Zeile gezählt (technisch ausgedrückt ist dies ein "
#~ "Boolsches ODER zwischen den Zeilen in @Kriterien).\n"
#~ "Falls @Kriterien mehr als eine Spalte angibt, muss jede der Bedingungen "
#~ "in diesen Spalten wahr sein, damit sie auf @Datenbank zutrifft (also ein "
#~ "Boolsches UND zwischen den Spalten in jeder Zeile in @Kriterien).\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, der Zellbereich A1:C7 enthält folgende Werte:\n"
#~ "Name    Alter   Gehalt\n"
#~ "Johann  34      54342\n"
#~ "Fritz   35      22343\n"
#~ "Heinz   29      34323\n"
#~ "Kurt    43      47242\n"
#~ "Susanne 37      42932\n"
#~ "Robert  45      45324\n"
#~ "\n"
#~ "Zusätzlich enthält der Zellbereich A9:B1 folgende Werte:\n"
#~ "Alter   Gehalt\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "Dann gilt:\n"
#~ "DBANZAHL2(A1:C7, \"Gehalt\", A9:A11) liefert 3.\n"
#~ "DBANZAHL2(A1:C7, \"Gehalt\", A9:B11) liefert 2.\n"
#~ "DBANZAHL2(A1:C7, \"Name\", A9:B11) liefert 2.\n"
#~ "\n"
#~ "@SEEALSO=DBANZAHL"

#~ msgid ""
#~ "@FUNCTION=DGET\n"
#~ "@SYNTAX=DGET(database,field,criteria)\n"
#~ "@DESCRIPTION=DGET function returns a single value from a column that "
#~ "match conditions specified.\n"
#~ "\n"
#~ "@database is a range of cells in which rows of related information are "
#~ "records and columns of data are fields. The first row of a database "
#~ "contains labels for each column. \n"
#~ "\n"
#~ "@field specifies which column is used in the function.  If @field is an "
#~ "integer, for example 2, the second column is used. Field can also be the "
#~ "label of a column.  For example, ``Age'' refers to the column with the "
#~ "label ``Age'' in @database range. \n"
#~ "\n"
#~ "@criteria is the range of cells which contains the specified conditions.  "
#~ "The first row of a @criteria should contain the labels of the fields for "
#~ "which the criteria are for.  Cells below the labels specify conditions, "
#~ "for example, ``>3'' or ``<9''.  Equality condition can be given simply by "
#~ "specifying a value, e.g. ``3'' or ``John''. \n"
#~ "Each row in @criteria specifies a separate condition. If a row in "
#~ "@database matches a row in @criteria, then that row is counted. "
#~ "Technically speaking, this a boolean OR operation between the rows in "
#~ "@criteria.\n"
#~ "If @criteria specifies more than one column, then each of the conditions "
#~ "in the specified columns must be true for the row in @database to match. "
#~ "Technically speaking, this is a boolean AND operation between the columns "
#~ "in @criteria.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the range A1:C7 contain the following values:\n"
#~ "Name    Age     Salary\n"
#~ "John    34      54342\n"
#~ "Bill    35      22343\n"
#~ "Clark   29      34323\n"
#~ "Bob     43      47242\n"
#~ "Susan   37      42932\n"
#~ "Jill    45      45324\n"
#~ "\n"
#~ "In addition, the cells A9:B11 contain the following values:\n"
#~ "Age     Salary\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "* If none of the items match the conditions, DGET returns #VALUE! error.\n"
#~ "* If more than one items match the conditions, DGET returns #NUM! error.\n"
#~ "\n"
#~ "DGET(A1:C7, \"Salary\", A9:A10) equals 34323.\n"
#~ "DGET(A1:C7, \"Name\", A9:A10) equals \"Clark\".\n"
#~ "\n"
#~ "@SEEALSO=DCOUNT"
#~ msgstr ""
#~ "@FUNCTION=DBAUSZUG\n"
#~ "@SYNTAX=DBAUSZUG(Datenbank,Feld,Kriterien)\n"
#~ "@DESCRIPTION=DBAUSZUG liefert einen einzelnen Wert aus einer Spalte, der "
#~ "den angegebenen Kriterien entspricht.\n"
#~ "\n"
#~ "@Datenbank ist ein Zellbereich, in dem Zeilen Datensätze und Spalten "
#~ "Datenfelder sind. Die erste Zeile einer Datenbank enthält die "
#~ "Beschriftungen für die jeweiligen Spalten.\n"
#~ "\n"
#~ "@Feld legt fest, welche Spalte für die Funktion verwendet wird und darf "
#~ "eine Ganzzahl oder eine Zeichenkette sein. Falls n (@Feld) ganzzahlig "
#~ "ist, wird die n-te Spalte verwendet, falls @Feld jedoch als Zeichenkette "
#~ "übergeben wird, wird diese als Bezug zur Spalte mit der Beschriftung "
#~ "\"@Feld\" interpretiert.\n"
#~ "\n"
#~ "@Kriterien ist der Zellbereich, der die zu erfüllenden Bedingungen "
#~ "enthält. Die erste Zeile in @Kriterien sollte die Beschriftungen der "
#~ "Felder enthalten, für die die Kriterien gelten. Zellen unterhalb der "
#~ "Beschriftungen legen Bedingungen fest, zum Beispiel »>3« oder »<9«. Ist-"
#~ "gleich-Bedingungen können als Wert (z.B. »3« oder »Johann«) übergeben "
#~ "werden.\n"
#~ "Jede Zeile in @Kriterien gibt eine einzelne Bedingung an. Wenn also eine "
#~ "Zeile in @Datenbank mit einer der Zeilen in @Kriterien übereinstimmt, "
#~ "dann wird diese Zeile gezählt (technisch ausgedrückt ist dies ein "
#~ "Boolsches ODER zwischen den Zeilen in @Kriterien).\n"
#~ "Falls @Kriterien mehr als eine Spalte angibt, muss jede der Bedingungen "
#~ "in diesen Spalten wahr sein, damit sie auf @Datenbank zutrifft (also ein "
#~ "Boolsches UND zwischen den Spalten in jeder Zeile in @Kriterien).\n"
#~ "\n"
#~ "* Falls keiner der Posten die Bedingungen erfüllt, liefert DBAUSZUG einen "
#~ "#WERT!-Fehler.\n"
#~ "* Erfüllt mehr als ein Posten die Bedingungen, liefert DBAUSZUG einen "
#~ "#ZAHL!-Fehler\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, der Zellbereich A1:C7 enthält folgende Werte:\n"
#~ "Name    Alter   Gehalt\n"
#~ "Johann  34      54342\n"
#~ "Fritz   35      22343\n"
#~ "Heinz   29      34323\n"
#~ "Kurt    43      47242\n"
#~ "Susanne 37      42932\n"
#~ "Robert  45      45324\n"
#~ "\n"
#~ "Zusätzlich enthält der Zellbereich A9:B1 folgende Werte:\n"
#~ "Alter   Gehalt\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "Dann gilt:\n"
#~ "DBAUSZUG(A1:C7, \"Gehalt\", A9:A10) liefert 34323.\n"
#~ "DBAUSZUG(A1:C7, \"Name\", A9:A10) liefert \"Clark\".\n"
#~ "\n"
#~ "@SEEALSO=DBANZAHL"

#~ msgid ""
#~ "@FUNCTION=DMAX\n"
#~ "@SYNTAX=DMAX(database,field,criteria)\n"
#~ "@DESCRIPTION=DMAX function returns the largest number in a column that "
#~ "match conditions specified.\n"
#~ "\n"
#~ "@database is a range of cells in which rows of related information are "
#~ "records and columns of data are fields. The first row of a database "
#~ "contains labels for each column. \n"
#~ "\n"
#~ "@field specifies which column is used in the function.  If @field is an "
#~ "integer, for example 2, the second column is used. Field can also be the "
#~ "label of a column.  For example, ``Age'' refers to the column with the "
#~ "label ``Age'' in @database range. \n"
#~ "\n"
#~ "@criteria is the range of cells which contains the specified conditions.  "
#~ "The first row of a @criteria should contain the labels of the fields for "
#~ "which the criteria are for.  Cells below the labels specify conditions, "
#~ "for example, ``>3'' or ``<9''.  Equality condition can be given simply by "
#~ "specifying a value, e.g. ``3'' or ``John''. \n"
#~ "Each row in @criteria specifies a separate condition. If a row in "
#~ "@database matches a row in @criteria, then that row is counted. "
#~ "Technically speaking, this a boolean OR operation between the rows in "
#~ "@criteria.\n"
#~ "If @criteria specifies more than one column, then each of the conditions "
#~ "in the specified columns must be true for the row in @database to match. "
#~ "Technically speaking, this is a boolean AND operation between the columns "
#~ "in @criteria.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the range A1:C7 contain the following values:\n"
#~ "Name    Age     Salary\n"
#~ "John    34      54342\n"
#~ "Bill    35      22343\n"
#~ "Clark   29      34323\n"
#~ "Bob     43      47242\n"
#~ "Susan   37      42932\n"
#~ "Jill    45      45324\n"
#~ "\n"
#~ "In addition, the cells A9:B11 contain the following values:\n"
#~ "Age     Salary\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "DMAX(A1:C7, \"Salary\", A9:A11) equals 47242.\n"
#~ "DMAX(A1:C7, \"Age\", A9:A11) equals 45.\n"
#~ "DMAX(A1:C7, \"Age\", A9:B11) equals 43.\n"
#~ "\n"
#~ "@SEEALSO=DMIN"
#~ msgstr ""
#~ "@FUNCTION=DBMAX\n"
#~ "@SYNTAX=DBMAX(Datenbank,Feld,Kriterien)\n"
#~ "@DESCRIPTION=DBMAX liefert die größte Zahl in einer Spalte, die den "
#~ "angegebenen Kriterien entspricht.\n"
#~ "\n"
#~ "@Datenbank ist ein Zellbereich, in dem Zeilen Datensätze und Spalten "
#~ "Datenfelder sind. Die erste Zeile einer Datenbank enthält die "
#~ "Beschriftungen für die jeweiligen Spalten.\n"
#~ "\n"
#~ "@Feld legt fest, welche Spalte für die Funktion verwendet wird und darf "
#~ "eine Ganzzahl oder eine Zeichenkette sein. Falls n (@Feld) ganzzahlig "
#~ "ist, wird die n-te Spalte verwendet, falls @Feld jedoch als Zeichenkette "
#~ "übergeben wird, wird diese als Bezug zur Spalte mit der Beschriftung "
#~ "\"@Feld\" interpretiert.\n"
#~ "\n"
#~ "@Kriterien ist der Zellbereich, der die zu erfüllenden Bedingungen "
#~ "enthält. Die erste Zeile in @Kriterien sollte die Beschriftungen der "
#~ "Felder enthalten, für die die Kriterien gelten. Zellen unterhalb der "
#~ "Beschriftungen legen Bedingungen fest, zum Beispiel »>3« oder »<9«. Ist-"
#~ "gleich-Bedingungen können als Wert (z.B. »3« oder »Johann«) übergeben "
#~ "werden.\n"
#~ "Jede Zeile in @Kriterien gibt eine einzelne Bedingung an. Wenn also eine "
#~ "Zeile in @Datenbank mit einer der Zeilen in @Kriterien übereinstimmt, "
#~ "dann wird diese Zeile gezählt (technisch ausgedrückt ist dies ein "
#~ "Boolsches ODER zwischen den Zeilen in @Kriterien).\n"
#~ "Falls @Kriterien mehr als eine Spalte angibt, muss jede der Bedingungen "
#~ "in diesen Spalten wahr sein, damit sie auf @Datenbank zutrifft (also ein "
#~ "Boolsches UND zwischen den Spalten in jeder Zeile in @Kriterien).\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, der Zellbereich A1:C7 enthält folgende Werte:\n"
#~ "Name    Alter   Gehalt\n"
#~ "Johann  34      54342\n"
#~ "Fritz   35      22343\n"
#~ "Heinz   29      34323\n"
#~ "Kurt    43      47242\n"
#~ "Susanne 37      42932\n"
#~ "Robert  45      45324\n"
#~ "\n"
#~ "Zusätzlich enthält der Zellbereich A9:B1 folgende Werte:\n"
#~ "Alter   Gehalt\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "Dann gilt:\n"
#~ "DBMAX(A1:C7, \"Gehalt\", A9:A11) liefert 47242.\n"
#~ "DBMAX(A1:C7, \"Alter\", A9:A11) liefert 45.\n"
#~ "DBMAX(A1:C7, \"Alter\", A9:B11) liefert 43.\n"
#~ "\n"
#~ "@SEEALSO=DBMIN"

#~ msgid ""
#~ "@FUNCTION=DMIN\n"
#~ "@SYNTAX=DMIN(database,field,criteria)\n"
#~ "@DESCRIPTION=DMIN function returns the smallest number in a column that "
#~ "match conditions specified.\n"
#~ "\n"
#~ "@database is a range of cells in which rows of related information are "
#~ "records and columns of data are fields. The first row of a database "
#~ "contains labels for each column. \n"
#~ "\n"
#~ "@field specifies which column is used in the function.  If @field is an "
#~ "integer, for example 2, the second column is used. Field can also be the "
#~ "label of a column.  For example, ``Age'' refers to the column with the "
#~ "label ``Age'' in @database range. \n"
#~ "\n"
#~ "@criteria is the range of cells which contains the specified conditions.  "
#~ "The first row of a @criteria should contain the labels of the fields for "
#~ "which the criteria are for.  Cells below the labels specify conditions, "
#~ "for example, ``>3'' or ``<9''.  Equality condition can be given simply by "
#~ "specifying a value, e.g. ``3'' or ``John''. \n"
#~ "Each row in @criteria specifies a separate condition. If a row in "
#~ "@database matches a row in @criteria, then that row is counted. "
#~ "Technically speaking, this a boolean OR operation between the rows in "
#~ "@criteria.\n"
#~ "If @criteria specifies more than one column, then each of the conditions "
#~ "in the specified columns must be true for the row in @database to match. "
#~ "Technically speaking, this is a boolean AND operation between the columns "
#~ "in @criteria.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the range A1:C7 contain the following values:\n"
#~ "Name    Age     Salary\n"
#~ "John    34      54342\n"
#~ "Bill    35      22343\n"
#~ "Clark   29      34323\n"
#~ "Bob     43      47242\n"
#~ "Susan   37      42932\n"
#~ "Jill    45      45324\n"
#~ "\n"
#~ "In addition, the cells A9:B11 contain the following values:\n"
#~ "Age     Salary\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "DMIN(A1:C7, \"Salary\", A9:B11) equals 34323.\n"
#~ "DMIN(A1:C7, \"Age\", A9:B11) equals 29.\n"
#~ "\n"
#~ "@SEEALSO=DMAX"
#~ msgstr ""
#~ "@FUNCTION=DBMIN\n"
#~ "@SYNTAX=DBMIN(Datenbank,Feld,Kriterien)\n"
#~ "@DESCRIPTION=DBMIN liefert die kleinste Zahl in einer Spalte, die den "
#~ "angegebenen Kriterien entspricht.\n"
#~ "\n"
#~ "@Datenbank ist ein Zellbereich, in dem Zeilen Datensätze und Spalten "
#~ "Datenfelder sind. Die erste Zeile einer Datenbank enthält die "
#~ "Beschriftungen für die jeweiligen Spalten.\n"
#~ "\n"
#~ "@Feld legt fest, welche Spalte für die Funktion verwendet wird und darf "
#~ "eine Ganzzahl oder eine Zeichenkette sein. Falls n (@Feld) ganzzahlig "
#~ "ist, wird die n-te Spalte verwendet, falls @Feld jedoch als Zeichenkette "
#~ "übergeben wird, wird diese als Bezug zur Spalte mit der Beschriftung "
#~ "\"@Feld\" interpretiert.\n"
#~ "\n"
#~ "@Kriterien ist der Zellbereich, der die zu erfüllenden Bedingungen "
#~ "enthält. Die erste Zeile in @Kriterien sollte die Beschriftungen der "
#~ "Felder enthalten, für die die Kriterien gelten. Zellen unterhalb der "
#~ "Beschriftungen legen Bedingungen fest, zum Beispiel »>3« oder »<9«. Ist-"
#~ "gleich-Bedingungen können als Wert (z.B. »3« oder »Johann«) übergeben "
#~ "werden.\n"
#~ "Jede Zeile in @Kriterien gibt eine einzelne Bedingung an. Wenn also eine "
#~ "Zeile in @Datenbank mit einer der Zeilen in @Kriterien übereinstimmt, "
#~ "dann wird diese Zeile gezählt (technisch ausgedrückt ist dies ein "
#~ "Boolsches ODER zwischen den Zeilen in @Kriterien).\n"
#~ "Falls @Kriterien mehr als eine Spalte angibt, muss jede der Bedingungen "
#~ "in diesen Spalten wahr sein, damit sie auf @Datenbank zutrifft (also ein "
#~ "Boolsches UND zwischen den Spalten in jeder Zeile in @Kriterien).\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, der Zellbereich A1:C7 enthält folgende Werte:\n"
#~ "Name    Alter   Gehalt\n"
#~ "Johann  34      54342\n"
#~ "Fritz   35      22343\n"
#~ "Heinz   29      34323\n"
#~ "Kurt    43      47242\n"
#~ "Susanne 37      42932\n"
#~ "Robert  45      45324\n"
#~ "\n"
#~ "Zusätzlich enthält der Zellbereich A9:B1 folgende Werte:\n"
#~ "Alter   Gehalt\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "Dann gilt:\n"
#~ "DBMIN(A1:C7, \"Gehalt\", A9:B11) liefert 34323.\n"
#~ "DBMIN(A1:C7, \"Alter\", A9:B11) liefert 29.\n"
#~ "\n"
#~ "@SEEALSO=DBMAX"

#~ msgid ""
#~ "@FUNCTION=DPRODUCT\n"
#~ "@SYNTAX=DPRODUCT(database,field,criteria)\n"
#~ "@DESCRIPTION=DPRODUCT function returns the product of numbers in a column "
#~ "that match conditions specified.\n"
#~ "\n"
#~ "@database is a range of cells in which rows of related information are "
#~ "records and columns of data are fields. The first row of a database "
#~ "contains labels for each column. \n"
#~ "\n"
#~ "@field specifies which column is used in the function.  If @field is an "
#~ "integer, for example 2, the second column is used. Field can also be the "
#~ "label of a column.  For example, ``Age'' refers to the column with the "
#~ "label ``Age'' in @database range. \n"
#~ "\n"
#~ "@criteria is the range of cells which contains the specified conditions.  "
#~ "The first row of a @criteria should contain the labels of the fields for "
#~ "which the criteria are for.  Cells below the labels specify conditions, "
#~ "for example, ``>3'' or ``<9''.  Equality condition can be given simply by "
#~ "specifying a value, e.g. ``3'' or ``John''. \n"
#~ "Each row in @criteria specifies a separate condition. If a row in "
#~ "@database matches a row in @criteria, then that row is counted. "
#~ "Technically speaking, this a boolean OR operation between the rows in "
#~ "@criteria.\n"
#~ "If @criteria specifies more than one column, then each of the conditions "
#~ "in the specified columns must be true for the row in @database to match. "
#~ "Technically speaking, this is a boolean AND operation between the columns "
#~ "in @criteria.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the range A1:C7 contain the following values:\n"
#~ "Name    Age     Salary\n"
#~ "John    34      54342\n"
#~ "Bill    35      22343\n"
#~ "Clark   29      34323\n"
#~ "Bob     43      47242\n"
#~ "Susan   37      42932\n"
#~ "Jill    45      45324\n"
#~ "\n"
#~ "In addition, the cells A9:B11 contain the following values:\n"
#~ "Age     Salary\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "DPRODUCT(A1:C7, \"Age\", A9:B11) equals 1247.\n"
#~ "\n"
#~ "@SEEALSO=DSUM"
#~ msgstr ""
#~ "@FUNCTION=DBPRODUKT\n"
#~ "@SYNTAX=DBPRODUKT(Datenbank,Feld,Kriterien)\n"
#~ "@DESCRIPTION=DBPRODUKT liefert das Produkt in einer Spalte von Zahlen, "
#~ "die den angegebenen Kriterien entsprechen.\n"
#~ "\n"
#~ "@Datenbank ist ein Zellbereich, in dem Zeilen Datensätze und Spalten "
#~ "Datenfelder sind. Die erste Zeile einer Datenbank enthält die "
#~ "Beschriftungen für die jeweiligen Spalten.\n"
#~ "\n"
#~ "@Feld legt fest, welche Spalte für die Funktion verwendet wird und darf "
#~ "eine Ganzzahl oder eine Zeichenkette sein. Falls n (@Feld) ganzzahlig "
#~ "ist, wird die n-te Spalte verwendet, falls @Feld jedoch als Zeichenkette "
#~ "übergeben wird, wird diese als Bezug zur Spalte mit der Beschriftung "
#~ "\"@Feld\" interpretiert.\n"
#~ "\n"
#~ "@Kriterien ist der Zellbereich, der die zu erfüllenden Bedingungen "
#~ "enthält. Die erste Zeile in @Kriterien sollte die Beschriftungen der "
#~ "Felder enthalten, für die die Kriterien gelten. Zellen unterhalb der "
#~ "Beschriftungen legen Bedingungen fest, zum Beispiel »>3« oder »<9«. Ist-"
#~ "gleich-Bedingungen können als Wert (z.B. »3« oder »Johann«) übergeben "
#~ "werden.\n"
#~ "Jede Zeile in @Kriterien gibt eine einzelne Bedingung an. Wenn also eine "
#~ "Zeile in @Datenbank mit einer der Zeilen in @Kriterien übereinstimmt, "
#~ "dann wird diese Zeile gezählt (technisch ausgedrückt ist dies ein "
#~ "Boolsches ODER zwischen den Zeilen in @Kriterien).\n"
#~ "Falls @Kriterien mehr als eine Spalte angibt, muss jede der Bedingungen "
#~ "in diesen Spalten wahr sein, damit sie auf @Datenbank zutrifft (also ein "
#~ "Boolsches UND zwischen den Spalten in jeder Zeile in @Kriterien).\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, der Zellbereich A1:C7 enthält folgende Werte:\n"
#~ "Name    Alter   Gehalt\n"
#~ "Johann  34      54342\n"
#~ "Fritz   35      22343\n"
#~ "Heinz   29      34323\n"
#~ "Kurt    43      47242\n"
#~ "Susanne 37      42932\n"
#~ "Robert  45      45324\n"
#~ "\n"
#~ "Zusätzlich enthält der Zellbereich A9:B1 folgende Werte:\n"
#~ "Alter   Gehalt\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "Dann gilt:\n"
#~ "DBPRODUKT(A1:C7, \"Alter\", A9:B11) liefert 1247.\n"
#~ "\n"
#~ "@SEEALSO=DBSUMME"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=DSTDEV\n"
#~ "@SYNTAX=DSTDEV(database,field,criteria)\n"
#~ "@DESCRIPTION=DSTDEV function returns the estimate of the standard "
#~ "deviation of a population based on a sample. The population consists of "
#~ "numbers that match conditions specified.\n"
#~ "\n"
#~ "@database is a range of cells in which rows of related information are "
#~ "records and columns of data are fields. The first row of a database "
#~ "contains labels for each column. \n"
#~ "\n"
#~ "@field specifies which column is used in the function.  If @field is an "
#~ "integer, for example 2, the second column is used. Field can also be the "
#~ "label of a column.  For example, ``Age'' refers to the column with the "
#~ "label ``Age'' in @database range. \n"
#~ "\n"
#~ "@criteria is the range of cells which contains the specified conditions.  "
#~ "The first row of a @criteria should contain the labels of the fields for "
#~ "which the criteria are for.  Cells below the labels specify conditions, "
#~ "for example, ``>3'' or ``<9''.  Equality condition can be given simply by "
#~ "specifying a value, e.g. ``3'' or ``John''. \n"
#~ "Each row in @criteria specifies a separate condition. If a row in "
#~ "@database matches a row in @criteria, then that row is counted. "
#~ "Technically speaking, this a boolean OR operation between the rows in "
#~ "@criteria.\n"
#~ "If @criteria specifies more than one column, then each of the conditions "
#~ "in the specified columns must be true for the row in @database to match. "
#~ "Technically speaking, this is a boolean AND operation between the columns "
#~ "in @criteria.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the range A1:C7 contain the following values:\n"
#~ "Name    Age     Salary\n"
#~ "John    34      54342\n"
#~ "Bill    35      22343\n"
#~ "Clark   29      34323\n"
#~ "Bob     43      47242\n"
#~ "Susan   37      42932\n"
#~ "Jill    45      45324\n"
#~ "\n"
#~ "In addition, the cells A9:B11 contain the following values:\n"
#~ "Age     Salary\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "DSTDEV(A1:C7, \"Age\", A9:B11) equals 9.89949.\n"
#~ "DSTDEV(A1:C7, \"Salary\", A9:B11) equals 9135.112506.\n"
#~ "\n"
#~ "@SEEALSO=DSTDEVP"
#~ msgstr ""
#~ "@FUNCTION=DBSTDABW\n"
#~ "@SYNTAX=DBSTDABW(Datenbank,Feld,Kriterien)\n"
#~ "@DESCRIPTION=DBSTDABW liefert die geschätzte Standardabweichung einer auf "
#~ "einer Stichprobe basierenden Grundgesamtheit. Die Grundgesamtheiten "
#~ "bestehen aus Zahlen, die die angegebenen Kriterien erfüllen.\n"
#~ "\n"
#~ "@Datenbank ist ein Zellbereich, in dem Zeilen Datensätze und Spalten "
#~ "Datenfelder sind. Die erste Zeile einer Datenbank enthält die "
#~ "Beschriftungen für die jeweiligen Spalten.\n"
#~ "\n"
#~ "@Feld legt fest, welche Spalte für die Funktion verwendet wird und darf "
#~ "eine Ganzzahl oder eine Zeichenkette sein. Falls n (@Feld) ganzzahlig "
#~ "ist, wird die n-te Spalte verwendet, falls @Feld jedoch als Zeichenkette "
#~ "übergeben wird, wird diese als Bezug zur Spalte mit der Beschriftung "
#~ "\"@Feld\" interpretiert.\n"
#~ "\n"
#~ "@Kriterien ist der Zellbereich, der die zu erfüllenden Bedingungen "
#~ "enthält. Die erste Zeile in @Kriterien sollte die Beschriftungen der "
#~ "Felder enthalten, für die die Kriterien gelten. Zellen unterhalb der "
#~ "Beschriftungen legen Bedingungen fest, zum Beispiel »>3« oder »<9«. Ist-"
#~ "gleich-Bedingungen können als Wert (z.B. »3« oder »Johann«) übergeben "
#~ "werden.\n"
#~ "Jede Zeile in @Kriterien gibt eine einzelne Bedingung an. Wenn also eine "
#~ "Zeile in @Datenbank mit einer der Zeilen in @Kriterien übereinstimmt, "
#~ "dann wird diese Zeile gezählt (technisch ausgedrückt ist dies ein "
#~ "Boolsches ODER zwischen den Zeilen in @Kriterien).\n"
#~ "Falls @Kriterien mehr als eine Spalte angibt, muss jede der Bedingungen "
#~ "in diesen Spalten wahr sein, damit sie auf @Datenbank zutrifft (also ein "
#~ "Boolsches UND zwischen den Spalten in jeder Zeile in @Kriterien).\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, der Zellbereich A1:C7 enthält folgende Werte:\n"
#~ "Name    Alter   Gehalt\n"
#~ "Johann  34      54342\n"
#~ "Fritz   35      22343\n"
#~ "Heinz   29      34323\n"
#~ "Kurt    43      47242\n"
#~ "Susanne 37      42932\n"
#~ "Robert  45      45324\n"
#~ "\n"
#~ "Zusätzlich enthält der Zellbereich A9:B1 folgende Werte:\n"
#~ "Alter   Gehalt\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "Dann gilt:\n"
#~ "DBSTDABW(A1:C7, \"Alter\", A9:B11) liefert 9.89949.\n"
#~ "DBSTDABW(A1:C7, \"Gehalt\", A9:B11) liefert 9135.112506.\n"
#~ "\n"
#~ "@SEEALSO=DBSTDABWN"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=DSTDEVP\n"
#~ "@SYNTAX=DSTDEVP(database,field,criteria)\n"
#~ "@DESCRIPTION=DSTDEVP function returns the standard deviation of a "
#~ "population based on the entire population. The population consists of "
#~ "numbers that match conditions specified.\n"
#~ "\n"
#~ "@database is a range of cells in which rows of related information are "
#~ "records and columns of data are fields. The first row of a database "
#~ "contains labels for each column. \n"
#~ "\n"
#~ "@field specifies which column is used in the function.  If @field is an "
#~ "integer, for example 2, the second column is used. Field can also be the "
#~ "label of a column.  For example, ``Age'' refers to the column with the "
#~ "label ``Age'' in @database range. \n"
#~ "\n"
#~ "@criteria is the range of cells which contains the specified conditions.  "
#~ "The first row of a @criteria should contain the labels of the fields for "
#~ "which the criteria are for.  Cells below the labels specify conditions, "
#~ "for example, ``>3'' or ``<9''.  Equality condition can be given simply by "
#~ "specifying a value, e.g. ``3'' or ``John''. \n"
#~ "Each row in @criteria specifies a separate condition. If a row in "
#~ "@database matches a row in @criteria, then that row is counted. "
#~ "Technically speaking, this a boolean OR operation between the rows in "
#~ "@criteria.\n"
#~ "If @criteria specifies more than one column, then each of the conditions "
#~ "in the specified columns must be true for the row in @database to match. "
#~ "Technically speaking, this is a boolean AND operation between the columns "
#~ "in @criteria.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the range A1:C7 contain the following values:\n"
#~ "Name    Age     Salary\n"
#~ "John    34      54342\n"
#~ "Bill    35      22343\n"
#~ "Clark   29      34323\n"
#~ "Bob     43      47242\n"
#~ "Susan   37      42932\n"
#~ "Jill    45      45324\n"
#~ "\n"
#~ "In addition, the cells A9:B11 contain the following values:\n"
#~ "Age     Salary\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "DSTDEVP(A1:C7, \"Age\", A9:B11) equals 7.\n"
#~ "DSTDEVP(A1:C7, \"Salary\", A9:B11) equals 6459.5.\n"
#~ "\n"
#~ "@SEEALSO=DSTDEV"
#~ msgstr ""
#~ "@FUNCTION=DBSTDABWN\n"
#~ "@SYNTAX=DBSTDABWN(Datenbank,Feld,Kriterien)\n"
#~ "@DESCRIPTION=DBSTDABWN liefert die Standardabweichung einer auf den "
#~ "gesamten Grundgesamtheiten basierenden Grundgesamtheit. Die "
#~ "Grundgesamtheiten bestehen aus Zahlen, die die angegebenen Kriterien "
#~ "erfüllen.\n"
#~ "\n"
#~ "@Datenbank ist ein Zellbereich, in dem Zeilen Datensätze und Spalten "
#~ "Datenfelder sind. Die erste Zeile einer Datenbank enthält die "
#~ "Beschriftungen für die jeweiligen Spalten.\n"
#~ "\n"
#~ "@Feld legt fest, welche Spalte für die Funktion verwendet wird und darf "
#~ "eine Ganzzahl oder eine Zeichenkette sein. Falls n (@Feld) ganzzahlig "
#~ "ist, wird die n-te Spalte verwendet, falls @Feld jedoch als Zeichenkette "
#~ "übergeben wird, wird diese als Bezug zur Spalte mit der Beschriftung "
#~ "\"@Feld\" interpretiert.\n"
#~ "\n"
#~ "@Kriterien ist der Zellbereich, der die zu erfüllenden Bedingungen "
#~ "enthält. Die erste Zeile in @Kriterien sollte die Beschriftungen der "
#~ "Felder enthalten, für die die Kriterien gelten. Zellen unterhalb der "
#~ "Beschriftungen legen Bedingungen fest, zum Beispiel »>3« oder »<9«. Ist-"
#~ "gleich-Bedingungen können als Wert (z.B. »3« oder »Johann«) übergeben "
#~ "werden.\n"
#~ "Jede Zeile in @Kriterien gibt eine einzelne Bedingung an. Wenn also eine "
#~ "Zeile in @Datenbank mit einer der Zeilen in @Kriterien übereinstimmt, "
#~ "dann wird diese Zeile gezählt (technisch ausgedrückt ist dies ein "
#~ "Boolsches ODER zwischen den Zeilen in @Kriterien).\n"
#~ "Falls @Kriterien mehr als eine Spalte angibt, muss jede der Bedingungen "
#~ "in diesen Spalten wahr sein, damit sie auf @Datenbank zutrifft (also ein "
#~ "Boolsches UND zwischen den Spalten in jeder Zeile in @Kriterien).\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, der Zellbereich A1:C7 enthält folgende Werte:\n"
#~ "Name    Alter   Gehalt\n"
#~ "Johann  34      54342\n"
#~ "Fritz   35      22343\n"
#~ "Heinz   29      34323\n"
#~ "Kurt    43      47242\n"
#~ "Susanne 37      42932\n"
#~ "Robert  45      45324\n"
#~ "\n"
#~ "Zusätzlich enthält der Zellbereich A9:B1 folgende Werte:\n"
#~ "Alter   Gehalt\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "Dann gilt:\n"
#~ "DBSTDABWN(A1:C7, \"Alter\", A9:B11) liefert 7.\n"
#~ "DBSTDABWN(A1:C7, \"Gehalt\", A9:B11) liefert 6459.5.\n"
#~ "\n"
#~ "@SEEALSO=DBSTDABWN"

#~ msgid ""
#~ "@FUNCTION=DSUM\n"
#~ "@SYNTAX=DSUM(database,field,criteria)\n"
#~ "@DESCRIPTION=DSUM function returns the sum of numbers in a column that "
#~ "match conditions specified.\n"
#~ "\n"
#~ "@database is a range of cells in which rows of related information are "
#~ "records and columns of data are fields. The first row of a database "
#~ "contains labels for each column. \n"
#~ "\n"
#~ "@field specifies which column is used in the function.  If @field is an "
#~ "integer, for example 2, the second column is used. Field can also be the "
#~ "label of a column.  For example, ``Age'' refers to the column with the "
#~ "label ``Age'' in @database range. \n"
#~ "\n"
#~ "@criteria is the range of cells which contains the specified conditions.  "
#~ "The first row of a @criteria should contain the labels of the fields for "
#~ "which the criteria are for.  Cells below the labels specify conditions, "
#~ "for example, ``>3'' or ``<9''.  Equality condition can be given simply by "
#~ "specifying a value, e.g. ``3'' or ``John''. \n"
#~ "Each row in @criteria specifies a separate condition. If a row in "
#~ "@database matches a row in @criteria, then that row is counted. "
#~ "Technically speaking, this a boolean OR operation between the rows in "
#~ "@criteria.\n"
#~ "If @criteria specifies more than one column, then each of the conditions "
#~ "in the specified columns must be true for the row in @database to match. "
#~ "Technically speaking, this is a boolean AND operation between the columns "
#~ "in @criteria.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the range A1:C7 contain the following values:\n"
#~ "Name    Age     Salary\n"
#~ "John    34      54342\n"
#~ "Bill    35      22343\n"
#~ "Clark   29      34323\n"
#~ "Bob     43      47242\n"
#~ "Susan   37      42932\n"
#~ "Jill    45      45324\n"
#~ "\n"
#~ "In addition, the cells A9:B11 contain the following values:\n"
#~ "Age     Salary\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "DSUM(A1:C7, \"Age\", A9:B11) equals 72.\n"
#~ "DSUM(A1:C7, \"Salary\", A9:B11) equals 81565.\n"
#~ "\n"
#~ "@SEEALSO=DPRODUCT"
#~ msgstr ""
#~ "@FUNCTION=DBSUMME\n"
#~ "@SYNTAX=DBSUMME(Datenbank,Feld,Kriterien)\n"
#~ "@DESCRIPTION=DBSUMME liefert in einer Spalte die Summe der Zahlen, die "
#~ "den angegebenen Kriterien entsprechen.\n"
#~ "\n"
#~ "@Datenbank ist ein Zellbereich, in dem Zeilen Datensätze und Spalten "
#~ "Datenfelder sind. Die erste Zeile einer Datenbank enthält die "
#~ "Beschriftungen für die jeweiligen Spalten.\n"
#~ "\n"
#~ "@Feld legt fest, welche Spalte für die Funktion verwendet wird und darf "
#~ "eine Ganzzahl oder eine Zeichenkette sein. Falls n (@Feld) ganzzahlig "
#~ "ist, wird die n-te Spalte verwendet, falls @Feld jedoch als Zeichenkette "
#~ "übergeben wird, wird diese als Bezug zur Spalte mit der Beschriftung "
#~ "\"@Feld\" interpretiert.\n"
#~ "\n"
#~ "@Kriterien ist der Zellbereich, der die zu erfüllenden Bedingungen "
#~ "enthält. Die erste Zeile in @Kriterien sollte die Beschriftungen der "
#~ "Felder enthalten, für die die Kriterien gelten. Zellen unterhalb der "
#~ "Beschriftungen legen Bedingungen fest, zum Beispiel »>3« oder »<9«. Ist-"
#~ "gleich-Bedingungen können als Wert (z.B. »3« oder »Johann«) übergeben "
#~ "werden.\n"
#~ "Jede Zeile in @Kriterien gibt eine einzelne Bedingung an. Wenn also eine "
#~ "Zeile in @Datenbank mit einer der Zeilen in @Kriterien übereinstimmt, "
#~ "dann wird diese Zeile gezählt (technisch ausgedrückt ist dies ein "
#~ "Boolsches ODER zwischen den Zeilen in @Kriterien).\n"
#~ "Falls @Kriterien mehr als eine Spalte angibt, muss jede der Bedingungen "
#~ "in diesen Spalten wahr sein, damit sie auf @Datenbank zutrifft (also ein "
#~ "Boolsches UND zwischen den Spalten in jeder Zeile in @Kriterien).\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, der Zellbereich A1:C7 enthält folgende Werte:\n"
#~ "Name    Alter   Gehalt\n"
#~ "Johann  34      54342\n"
#~ "Fritz   35      22343\n"
#~ "Heinz   29      34323\n"
#~ "Kurt    43      47242\n"
#~ "Susanne 37      42932\n"
#~ "Robert  45      45324\n"
#~ "\n"
#~ "Zusätzlich enthält der Zellbereich A9:B1 folgende Werte:\n"
#~ "Alter   Gehalt\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "Dann gilt:\n"
#~ "DBSUMME(A1:C7, \"Alter\", A9:B11) liefert 72.\n"
#~ "DBSUMME(A1:C7, \"Gehalt\", A9:B11) liefert 81565.\n"
#~ "\n"
#~ "@SEEALSO=DBPRODUKT"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=DVAR\n"
#~ "@SYNTAX=DVAR(database,field,criteria)\n"
#~ "@DESCRIPTION=DVAR function returns the estimate of variance of a "
#~ "population based on a sample. The population consists of numbers that "
#~ "match conditions specified.\n"
#~ "\n"
#~ "@database is a range of cells in which rows of related information are "
#~ "records and columns of data are fields. The first row of a database "
#~ "contains labels for each column. \n"
#~ "\n"
#~ "@field specifies which column is used in the function.  If @field is an "
#~ "integer, for example 2, the second column is used. Field can also be the "
#~ "label of a column.  For example, ``Age'' refers to the column with the "
#~ "label ``Age'' in @database range. \n"
#~ "\n"
#~ "@criteria is the range of cells which contains the specified conditions.  "
#~ "The first row of a @criteria should contain the labels of the fields for "
#~ "which the criteria are for.  Cells below the labels specify conditions, "
#~ "for example, ``>3'' or ``<9''.  Equality condition can be given simply by "
#~ "specifying a value, e.g. ``3'' or ``John''. \n"
#~ "Each row in @criteria specifies a separate condition. If a row in "
#~ "@database matches a row in @criteria, then that row is counted. "
#~ "Technically speaking, this a boolean OR operation between the rows in "
#~ "@criteria.\n"
#~ "If @criteria specifies more than one column, then each of the conditions "
#~ "in the specified columns must be true for the row in @database to match. "
#~ "Technically speaking, this is a boolean AND operation between the columns "
#~ "in @criteria.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the range A1:C7 contain the following values:\n"
#~ "Name    Age     Salary\n"
#~ "John    34      54342\n"
#~ "Bill    35      22343\n"
#~ "Clark   29      34323\n"
#~ "Bob     43      47242\n"
#~ "Susan   37      42932\n"
#~ "Jill    45      45324\n"
#~ "\n"
#~ "In addition, the cells A9:B11 contain the following values:\n"
#~ "Age     Salary\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "DVAR(A1:C7, \"Age\", A9:B11) equals 98.\n"
#~ "DVAR(A1:C7, \"Salary\", A9:B11) equals 83450280.5.\n"
#~ "\n"
#~ "@SEEALSO=DVARP"
#~ msgstr ""
#~ "@FUNCTION=DBVARIANZ\n"
#~ "@SYNTAX=DBVARIANZ(Datenbank,Feld,Kriterien)\n"
#~ "@DESCRIPTION=DBVARIANZ liefert die geschätzte Varianz einer "
#~ "Grundgesamtheit, basierend auf einer Stichprobe. Die Grundgesamtheiten "
#~ "bestehen aus Zahlen, die den angegebenen Kriterien entsprechen.\n"
#~ "\n"
#~ "@Datenbank ist ein Zellbereich, in dem Zeilen Datensätze und Spalten "
#~ "Datenfelder sind. Die erste Zeile einer Datenbank enthält die "
#~ "Beschriftungen für die jeweiligen Spalten.\n"
#~ "\n"
#~ "@Feld legt fest, welche Spalte für die Funktion verwendet wird und darf "
#~ "eine Ganzzahl oder eine Zeichenkette sein. Falls n (@Feld) ganzzahlig "
#~ "ist, wird die n-te Spalte verwendet, falls @Feld jedoch als Zeichenkette "
#~ "übergeben wird, wird diese als Bezug zur Spalte mit der Beschriftung "
#~ "\"@Feld\" interpretiert.\n"
#~ "\n"
#~ "@Kriterien ist der Zellbereich, der die zu erfüllenden Bedingungen "
#~ "enthält. Die erste Zeile in @Kriterien sollte die Beschriftungen der "
#~ "Felder enthalten, für die die Kriterien gelten. Zellen unterhalb der "
#~ "Beschriftungen legen Bedingungen fest, zum Beispiel »>3« oder »<9«. Ist-"
#~ "gleich-Bedingungen können als Wert (z.B. »3« oder »Johann«) übergeben "
#~ "werden.\n"
#~ "Jede Zeile in @Kriterien gibt eine einzelne Bedingung an. Wenn also eine "
#~ "Zeile in @Datenbank mit einer der Zeilen in @Kriterien übereinstimmt, "
#~ "dann wird diese Zeile gezählt (technisch ausgedrückt ist dies ein "
#~ "Boolsches ODER zwischen den Zeilen in @Kriterien).\n"
#~ "Falls @Kriterien mehr als eine Spalte angibt, muss jede der Bedingungen "
#~ "in diesen Spalten wahr sein, damit sie auf @Datenbank zutrifft (also ein "
#~ "Boolsches UND zwischen den Spalten in jeder Zeile in @Kriterien).\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, der Zellbereich A1:C7 enthält folgende Werte:\n"
#~ "Name    Alter   Gehalt\n"
#~ "Johann  34      54342\n"
#~ "Fritz   35      22343\n"
#~ "Heinz   29      34323\n"
#~ "Kurt    43      47242\n"
#~ "Susanne 37      42932\n"
#~ "Robert  45      45324\n"
#~ "\n"
#~ "Zusätzlich enthält der Zellbereich A9:B1 folgende Werte:\n"
#~ "Alter   Gehalt\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "Dann gilt:\n"
#~ "DBVARIANZ(A1:C7, \"Alter\", A9:B11) liefert 98.\n"
#~ "DBVARIANZ(A1:C7, \"Gehalt\", A9:B11) liefert 83450280.5.\n"
#~ "\n"
#~ "@SEEALSO=DBVARIANZN"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=DVARP\n"
#~ "@SYNTAX=DVARP(database,field,criteria)\n"
#~ "@DESCRIPTION=DVARP function returns the variance of a population based on "
#~ "the entire population. The population consists of numbers that match "
#~ "conditions specified.\n"
#~ "\n"
#~ "@database is a range of cells in which rows of related information are "
#~ "records and columns of data are fields. The first row of a database "
#~ "contains labels for each column. \n"
#~ "\n"
#~ "@field specifies which column is used in the function.  If @field is an "
#~ "integer, for example 2, the second column is used. Field can also be the "
#~ "label of a column.  For example, ``Age'' refers to the column with the "
#~ "label ``Age'' in @database range. \n"
#~ "\n"
#~ "@criteria is the range of cells which contains the specified conditions.  "
#~ "The first row of a @criteria should contain the labels of the fields for "
#~ "which the criteria are for.  Cells below the labels specify conditions, "
#~ "for example, ``>3'' or ``<9''.  Equality condition can be given simply by "
#~ "specifying a value, e.g. ``3'' or ``John''. \n"
#~ "Each row in @criteria specifies a separate condition. If a row in "
#~ "@database matches a row in @criteria, then that row is counted. "
#~ "Technically speaking, this a boolean OR operation between the rows in "
#~ "@criteria.\n"
#~ "If @criteria specifies more than one column, then each of the conditions "
#~ "in the specified columns must be true for the row in @database to match. "
#~ "Technically speaking, this is a boolean AND operation between the columns "
#~ "in @criteria.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the range A1:C7 contain the following values:\n"
#~ "Name    Age     Salary\n"
#~ "John    34      54342\n"
#~ "Bill    35      22343\n"
#~ "Clark   29      34323\n"
#~ "Bob     43      47242\n"
#~ "Susan   37      42932\n"
#~ "Jill    45      45324\n"
#~ "\n"
#~ "In addition, the cells A9:B11 contain the following values:\n"
#~ "Age     Salary\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "DVARP(A1:C7, \"Age\", A9:B11) equals 49.\n"
#~ "DVARP(A1:C7, \"Salary\", A9:B11) equals 41725140.25.\n"
#~ "\n"
#~ "@SEEALSO=DVAR"
#~ msgstr ""
#~ "@FUNCTION=DBVARIANZN\n"
#~ "@SYNTAX=DBVARIANZN(Datenbank,Feld,Kriterien)\n"
#~ "@DESCRIPTION=DBVARIANZN liefert die Varianz einer Grundgesamtheit, "
#~ "basierend auf den gesamten Grundgesamtheiten. Die Grundgesamtheiten "
#~ "bestehen aus Zahlen, die den angegebenen Kriterien entsprechen.\n"
#~ "\n"
#~ "@Datenbank ist ein Zellbereich, in dem Zeilen Datensätze und Spalten "
#~ "Datenfelder sind. Die erste Zeile einer Datenbank enthält die "
#~ "Beschriftungen für die jeweiligen Spalten.\n"
#~ "\n"
#~ "@Feld legt fest, welche Spalte für die Funktion verwendet wird und darf "
#~ "eine Ganzzahl oder eine Zeichenkette sein. Falls n (@Feld) ganzzahlig "
#~ "ist, wird die n-te Spalte verwendet, falls @Feld jedoch als Zeichenkette "
#~ "übergeben wird, wird diese als Bezug zur Spalte mit der Beschriftung "
#~ "\"@Feld\" interpretiert.\n"
#~ "\n"
#~ "@Kriterien ist der Zellbereich, der die zu erfüllenden Bedingungen "
#~ "enthält. Die erste Zeile in @Kriterien sollte die Beschriftungen der "
#~ "Felder enthalten, für die die Kriterien gelten. Zellen unterhalb der "
#~ "Beschriftungen legen Bedingungen fest, zum Beispiel »>3« oder »<9«. Ist-"
#~ "gleich-Bedingungen können als Wert (z.B. »3« oder »Johann«) übergeben "
#~ "werden.\n"
#~ "Jede Zeile in @Kriterien gibt eine einzelne Bedingung an. Wenn also eine "
#~ "Zeile in @Datenbank mit einer der Zeilen in @Kriterien übereinstimmt, "
#~ "dann wird diese Zeile gezählt (technisch ausgedrückt ist dies ein "
#~ "Boolsches ODER zwischen den Zeilen in @Kriterien).\n"
#~ "Falls @Kriterien mehr als eine Spalte angibt, muss jede der Bedingungen "
#~ "in diesen Spalten wahr sein, damit sie auf @Datenbank zutrifft (also ein "
#~ "Boolsches UND zwischen den Spalten in jeder Zeile in @Kriterien).\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, der Zellbereich A1:C7 enthält folgende Werte:\n"
#~ "Name    Alter   Gehalt\n"
#~ "Johann  34      54342\n"
#~ "Fritz   35      22343\n"
#~ "Heinz   29      34323\n"
#~ "Kurt    43      47242\n"
#~ "Susanne 37      42932\n"
#~ "Robert  45      45324\n"
#~ "\n"
#~ "Zusätzlich enthält der Zellbereich A9:B1 folgende Werte:\n"
#~ "Alter   Gehalt\n"
#~ "<30\n"
#~ ">40     >46000\n"
#~ "\n"
#~ "Dann gilt:\n"
#~ "DBVARIANZN(A1:C7, \"Alter\", A9:B11) liefert 49.\n"
#~ "DBVARIANZN(A1:C7, \"Gehalt\", A9:B11) liefert 41725140.25.\n"
#~ "\n"
#~ "@SEEALSO=DBVARIANZ"

#~ msgid ""
#~ "@FUNCTION=GETPIVOTDATA\n"
#~ "@SYNTAX=GETPIVOTDATA(pivot_table,field_name)\n"
#~ "@DESCRIPTION=GETPIVOTDATA function fetches summary data from a pivot "
#~ "table. @pivot_table is a cell range containing the pivot table. "
#~ "@field_name is the name of the field of which you want the summary data.\n"
#~ "\n"
#~ "* If the summary data is unavailable, GETPIVOTDATA returns #REF! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=PIVOTDATEN.ZUORDNEN\n"
#~ "@SYNTAX=PIVOTDATEN.ZUORDNEN(Pivottabelle,Feldname)\n"
#~ "@DESCRIPTION=PIVOTDATEN.ZUORDNEN holt Summendaten aus einer Pivottabelle. "
#~ "@Pivottabelle ist ein Zellbereich, der die Pivottabelle enthält. "
#~ "@Feldname ist der Name des Feldes, von dem die Zusammenfassungsdaten "
#~ "berechnet werden sollen.\n"
#~ "\n"
#~ "* Falls keine Summendaten verfügbar sind, liefert PIVOTDATENZUORDNEN "
#~ "einen #BEZUG!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=DATE\n"
#~ "@SYNTAX=DATE (year,month,day)\n"
#~ "@DESCRIPTION=DATE returns the number of days since the 1st of January of "
#~ "1900(the date serial number) for the given year, month and day.\n"
#~ "\n"
#~ "* If @month < 1 or @month > 12, the year will be corrected.  A similar "
#~ "correction takes place for days.\n"
#~ "* The @years should be at least 1900.  If @years < 1900, it is assumed to "
#~ "be 1900 + @years.\n"
#~ "* If the given date is not valid, DATE returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DATE(2001, 3, 30) returns 'Mar 30, 2001'.\n"
#~ " \n"
#~ "@SEEALSO=TODAY, NOW"
#~ msgstr ""
#~ "@FUNCTION=DATUM\n"
#~ "@SYNTAX=DATUM (Jahr,Monat,Tag)\n"
#~ "@DESCRIPTION=DATUM berechnet die Tage seit dem 1. Januar 1900 (die "
#~ "Datumsseriennummer) für das angegebene Jahr, den angegebenen Monat und "
#~ "Tag.\n"
#~ "\n"
#~ "* Falls @Monat < 1 oder > 12 ist, wird das Jahr angepasst. Eine ähnliche "
#~ "Anpassung findet für Tage statt.\n"
#~ "* @Jahr sollte mindestens 1900 sein. Falls @Jahr < 1900 ist, wird 1900 + "
#~ "@Jahr angenommen.\n"
#~ "* Falls das angegebene Datum ungültig ist, liefert DATUM einen #ZAHL!-"
#~ "Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DATUM(2001, 3, 30) liefert »Mär 30, 2001«.\n"
#~ "\n"
#~ "@SEEALSO=HEUTE, JETZT"

#~ msgid ""
#~ "@FUNCTION=UNIX2DATE\n"
#~ "@SYNTAX=UNIX2DATE(unixtime)\n"
#~ "@DESCRIPTION=UNIX2DATE converts a unix time into a spreadsheet date and "
#~ "time.\n"
#~ "\n"
#~ "A unix time is the number of seconds since midnight January 1, 1970.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=NOW, DATE, DATE2UNIX"
#~ msgstr ""
#~ "@FUNCTION=UNIXINDATUM\n"
#~ "@SYNTAX=UNIXINDATUM(Unix_Zeit)\n"
#~ "@DESCRIPTION=UNIXINDATUM konvertiert eine Unix-Zeit in ein für die "
#~ "Tabellenkalkulation lesbares Datums- und Zeitformat.\n"
#~ "\n"
#~ "* Die Unix-Zeit ist die Anzahl der Sekunden seit Mitternacht des 1. "
#~ "Januars 1970.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=JETZT, DATUM, DATUMINUNIX"

#~ msgid ""
#~ "@FUNCTION=DATE2UNIX\n"
#~ "@SYNTAX=DATE2UNIX(serial)\n"
#~ "@DESCRIPTION=DATE2UNIX converts a spreadsheet date and time serial number "
#~ "into a unix time.\n"
#~ "\n"
#~ "A unix time is the number of seconds since midnight January 1, 1970.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DATE2UNIX(\"01/01/2000\") equals 946656000.\n"
#~ "\n"
#~ "@SEEALSO=NOW, DATE, UNIX2DATE"
#~ msgstr ""
#~ "@FUNCTION=DATUMINUNIX\n"
#~ "@SYNTAX=DATUMINUNIX(Seriennummer)\n"
#~ "@DESCRIPTION=DATUMINUNIX konvertiert eine für die Tabellenkalkulation "
#~ "lesbare Datums- und Zeit-Seriennummer in das Unix-Zeitformat.\n"
#~ "\n"
#~ "* Die Unix-Zeit ist die Anzahl der Sekunden seit Mitternacht des 1. "
#~ "Januars 1970.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=JETZT, DATUM, UNIXINDATUM"

#~ msgid ""
#~ "@FUNCTION=DATEVALUE\n"
#~ "@SYNTAX=DATEVALUE(date_str)\n"
#~ "@DESCRIPTION=DATEVALUE returns the serial number of the date.  @date_str "
#~ "is the string that contains the date. The value depends on the date "
#~ "convention.  The MS Excel 1900 convention dates things from Jan 1 1900 "
#~ "while the 1904 convention uses Jan 1 1904.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DATEVALUE(\"1/1/1999\") equals 36161 (in the 1900 convention).\n"
#~ "@SEEALSO=DATE"
#~ msgstr ""
#~ "@FUNCTION=DATWERT\n"
#~ "@SYNTAX=DATWERT(Datum_Zeichenkette)\n"
#~ "@DESCRIPTION=DATWERT liefert die Seriennummer des Datums. "
#~ "@Datum_Zeichenkette ist die Zeichenkette, die das Datum enthält. Der Wert "
#~ "hängt von der Datumskonvention ab. Die MS Excel 1900-Konvention zählt "
#~ "Daten vom 1. Januar 1900 an, wohingegen die 1904-Konvention den 1. Januar "
#~ "1904 verwendet.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DATEVALUE(\"1/1/1999\") liefert 36161 (in der 1900-Konvention).\n"
#~ "\n"
#~ "@SEEALSO=DATUM"

#~ msgid ""
#~ "@FUNCTION=DATEDIF\n"
#~ "@SYNTAX=DATEDIF(date1,date2,interval)\n"
#~ "@DESCRIPTION=DATEDIF returns the difference between two dates.  @interval "
#~ "is one of six possible values:  \"y\", \"m\", \"d\", \"ym\", \"md\", and "
#~ "\"yd\".\n"
#~ "\n"
#~ "The first three options will return the number of complete years, months, "
#~ "or days, respectively, between the two dates specified.\n"
#~ "\n"
#~ "  \"ym\" will return the number of full months between the two dates, not "
#~ "including the difference in years.\n"
#~ "  \"md\" will return the number of full days between the two dates, not "
#~ "including the difference in months.\n"
#~ "  \"yd\" will return the number of full days between the two dates, not "
#~ "including the difference in years.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DATEDIF(DATE(2000,4,30),DATE(2003,8,4),\"d\") equals 1191.\n"
#~ "DATEDIF(DATE(2000,4,30),DATE(2003,8,4),\"y\") equals 3.\n"
#~ "\n"
#~ "@SEEALSO=DATE"
#~ msgstr ""
#~ "@FUNCTION=DATEDIF\n"
#~ "@SYNTAX=DATEDIF(Datum1,Datum2,Intervall)\n"
#~ "@DESCRIPTION=DATEDIF liefert die Differenz zwischen zwei Daten. "
#~ "@Intervall ist einer der sechs folgenden möglichen Werte:\n"
#~ "\"y\", \"m\", \"d\", \"ym\", \"md\" und \"yd\".\n"
#~ "\n"
#~ "Die ersten drei Möglichkeiten liefern jeweils die Anzahl ganzer Jahre, "
#~ "Monate oder Tage zwischen den beiden angegebenen Daten.\n"
#~ "\n"
#~ "  \"ym\" liefert die Anzahl ganzer Monate zwischen den beiden Daten, ohne "
#~ "Berücksichtigung der Differenz in Jahren.\n"
#~ "  \"md\" liefert die Anzahl ganzer Tage zwischen den beiden Daten, ohne "
#~ "Berücksichtigung der Differenz in Monaten.\n"
#~ "  \"yd\" liefert die Anzahl ganzer Tage zwischen den beiden Daten, ohne "
#~ "Berücksichtigung der Differenz in Jahren.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DATEDIF(DATUM(2000,4,30),DATUM(2003,8,4),\"d\") liefert 1191.\n"
#~ "DATEDIF(DATUM(2000,4,30),DATUM(2003,8,4),\"y\") liefert 3.\n"
#~ "\n"
#~ "@SEEALSO=DATUM"

#~ msgid ""
#~ "@FUNCTION=EDATE\n"
#~ "@SYNTAX=EDATE(date,months)\n"
#~ "@DESCRIPTION=EDATE returns the serial number of the date that is the "
#~ "specified number of months before or after a given date.  @date is the "
#~ "serial number of the initial date and @months is the number of months "
#~ "before (negative number) or after (positive number) the initial date.\n"
#~ "\n"
#~ "* If @months is not an integer, it is truncated.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "EDATE(DATE(2001,12,30),2) returns 'Feb 28, 2002'.\n"
#~ "\n"
#~ "@SEEALSO=DATE"
#~ msgstr ""
#~ "@FUNCTION=EDATUM\n"
#~ "@SYNTAX=EDATUM(Datum, Monate)\n"
#~ "@DESCRIPTION=EDATUM liefert die Seriennummer des Datums, das die "
#~ "angegebene Anzahl von Monaten vor oder nach dem angegebenen Datum liegt. "
#~ "@Datum ist die Seriennummer des Ausgangsdatums und @Monate ist die Anzahl "
#~ "von Monaten vor (negative Zahl) oder nach (positive Zahl) dem "
#~ "Ausgangsdatum.\n"
#~ "\n"
#~ "* Falls @Monate keine Ganzzahl ist, werden die Nachkommastellen "
#~ "abgeschnitten.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "EDATUM(DATUM(2001,12,30),2) liefert »Feb 28, 2002«.\n"
#~ "\n"
#~ "@SEEALSO=DATUM"

#~ msgid ""
#~ "@FUNCTION=TODAY\n"
#~ "@SYNTAX=TODAY()\n"
#~ "@DESCRIPTION=TODAY returns the serial number for today (the number of "
#~ "days elapsed since the 1st of January of 1900).\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TODAY() returns 'Nov 6, 2001' on that particular day.\n"
#~ " \n"
#~ "@SEEALSO=NOW"
#~ msgstr ""
#~ "@FUNCTION=HEUTE\n"
#~ "@SYNTAX=HEUTE()\n"
#~ "@DESCRIPTION=HEUTE liefert die heutige Datumsseriennummer, also die "
#~ "Anzahl der Tage, die seit dem 1. Januar 1900 vergangen sind.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "HEUTE() liefert am entsprechenden Tag 'Nov 6, 2001'.\n"
#~ "\n"
#~ "@SEEALSO=JETZT"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=NOW\n"
#~ "@SYNTAX=NOW ()\n"
#~ "@DESCRIPTION=NOW returns the serial number for the date and time at the "
#~ "time it is evaluated.\n"
#~ "\n"
#~ "Serial Numbers in Gnumeric are represented as follows: The integral part "
#~ "is the number of days since the 1st of January of 1900.  The decimal part "
#~ "represent the fraction of the day and is mapped into hour, minutes and "
#~ "seconds.\n"
#~ "\n"
#~ "For example: .0 represents the beginning of the day, and 0.5 represents "
#~ "noon.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "NOW().\n"
#~ "\n"
#~ "@SEEALSO=TODAY"
#~ msgstr ""
#~ "@FUNCTION=JETZT\n"
#~ "@SYNTAX=JETZT()\n"
#~ "@DESCRIPTION=JETZT liefert die Datumsseriennummer für den Zeitpunkt, an "
#~ "diese Funktion ausgewertet wird.\n"
#~ "\n"
#~ "Datumsseriennummern in Gnumeric sind wie folgt aufgebaut:  Der "
#~ "ganzzahlige Bestandteil ist die Anzahl der Tage seit dem 1. Januar 1900. "
#~ "Der gebrochene Anteil repräsentiert den Bruchteil des Tages bestehend aus "
#~ "den Stunden-, Minuten- und Sekunden-Anteilen.\n"
#~ "\n"
#~ "* .0 steht für den Tagesbeginn und 0.5 den Mittag.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "JETZT().\n"
#~ "\n"
#~ "@SEEALSO=HEUTE, JETZT"

#~ msgid ""
#~ "@FUNCTION=TIME\n"
#~ "@SYNTAX=TIME (hours,minutes,seconds)\n"
#~ "@DESCRIPTION=TIME returns a fraction representing the time of day.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TIME(3, 5, 23) equals 3:05AM.\n"
#~ "\n"
#~ "@SEEALSO=HOUR"
#~ msgstr ""
#~ "@FUNCTION=ZEIT\n"
#~ "@SYNTAX=ZEIT(Stunden,Minuten,Sekunden)\n"
#~ "@DESCRIPTION=ZEIT liefert die Uhrzeit.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ZEIT(3, 5, 23) liefert 3:05 AM.\n"
#~ "\n"
#~ "@SEEALSO=STUNDE"

#~ msgid ""
#~ "@FUNCTION=TIMEVALUE\n"
#~ "@SYNTAX=TIMEVALUE (timetext)\n"
#~ "@DESCRIPTION=TIMEVALUE returns a fraction representing the time of day, a "
#~ "number between 0 and 1.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TIMEVALUE(\"3:05\") equals 0.128472.\n"
#~ "TIMEVALUE(\"2:24:53 PM\") equals 0.600613.\n"
#~ "\n"
#~ "@SEEALSO=HOUR,MINUTE"
#~ msgstr ""
#~ "@FUNCTION=ZEITWERT\n"
#~ "@SYNTAX=ZEITWERT(Zeittext)\n"
#~ "@DESCRIPTION=ZEITWERT liefert die Tageszeit als Dezimalzahl zwischen 0 "
#~ "und 1.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ZEITWERT(\"3:05\") liefert 0.128472.\n"
#~ "ZEITWERT(\"2:24:53 PM\") liefert 0.600613.\n"
#~ "\n"
#~ "@SEEALSO=STUNDE, MINUTE"

#~ msgid ""
#~ "@FUNCTION=HOUR\n"
#~ "@SYNTAX=HOUR (date)\n"
#~ "@DESCRIPTION=HOUR converts a serial number to an hour.  The hour is "
#~ "returned as an integer in the range 0 (12:00 A.M.) to 23 (11:00 P.M.).\n"
#~ "\n"
#~ "* Note that Gnumeric will perform regular string to serial number "
#~ "conversion for you, so you can enter a date as a string.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "HOUR(0.128472) equals 3.\n"
#~ "\n"
#~ "@SEEALSO=MINUTE, NOW, TIME, SECOND"
#~ msgstr ""
#~ "@FUNCTION=STUNDE\n"
#~ "@SYNTAX=STUNDE(Datum)\n"
#~ "@DESCRIPTION=STUNDE konvertiert eine Seriennummer in eine Stunde, wobei "
#~ "die Stunde als Ganzzahl im Bereich zwischen 0 und 23 definiert ist.\n"
#~ "\n"
#~ "* Beachten Sie, dass Gnumeric eine Zeichenkette automatisch in eine "
#~ "Seriennummer umwandelt, sodass das Datum als Zeichenkette übergeben "
#~ "werden kann.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "STUNDE(0.128472) liefert 3.\n"
#~ "\n"
#~ "@SEEALSO=MINUTE, JETZT, ZEIT, SEKUNDE"

#~ msgid ""
#~ "@FUNCTION=MINUTE\n"
#~ "@SYNTAX=MINUTE (date)\n"
#~ "@DESCRIPTION=MINUTE converts a serial number to a minute.  The minute is "
#~ "returned as an integer in the range 0 to 59.\n"
#~ "\n"
#~ "* Note that Gnumeric will perform regular string to serial number "
#~ "conversion for you, so you can enter a date as a string.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "MINUTE(0.128472) equals 5.\n"
#~ "\n"
#~ "@SEEALSO=HOUR, NOW, TIME, SECOND"
#~ msgstr ""
#~ "@FUNCTION=MINUTE\n"
#~ "@SYNTAX=MINUTE(Datum)\n"
#~ "@DESCRIPTION=MINUTE konvertiert eine Seriennummer in eine Minute, wobei "
#~ "die Minute wird als Ganzzahl im Bereich zwischen 0 und 59 definiert ist.\n"
#~ "\n"
#~ "* Beachten Sie, dass Gnumeric eine Zeichenkette automatisch in eine "
#~ "Seriennummer umwandelt, sodass das Datum als Zeichenkette übergeben "
#~ "werden kann.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "MINUTE(0.128472) liefert 5.\n"
#~ "\n"
#~ "@SEEALSO=STUNDE, JETZT, ZEIT, SEKUNDE"

#~ msgid ""
#~ "@FUNCTION=SECOND\n"
#~ "@SYNTAX=SECOND (date)\n"
#~ "@DESCRIPTION=SECOND converts a serial number to a second.  The second is "
#~ "returned as an integer in the range 0 to 59.\n"
#~ "\n"
#~ "* Note that Gnumeric will perform regular string to serial number "
#~ "conversion for you, so you can enter a date as a string.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "SECOND(0.600613) equals 53.\n"
#~ "\n"
#~ "@SEEALSO=HOUR, MINUTE, NOW, TIME"
#~ msgstr ""
#~ "@FUNCTION=SEKUNDE\n"
#~ "@SYNTAX=SEKUNDE(Datum)\n"
#~ "@DESCRIPTION=SEKUNDE konvertiert eine Seriennummer in eine Sekunde, wobei "
#~ "die Sekunde als Ganzzahl im Bereich zwischen 0 und 59 definiert ist.\n"
#~ "\n"
#~ "* Beachten Sie, dass Gnumeric eine Zeichenkette automatisch in eine "
#~ "Seriennummer umwandelt, sodass das Datum als Zeichenkette übergegeben "
#~ "werden kann.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "SEKUNDE(0.600613) liefert 53.\n"
#~ "\n"
#~ "@SEEALSO=STUNDE, MINUTE, JETZT, ZEIT"

#~ msgid ""
#~ "@FUNCTION=YEAR\n"
#~ "@SYNTAX=YEAR (date)\n"
#~ "@DESCRIPTION=YEAR converts a serial number to a year.\n"
#~ "\n"
#~ "* Note that Gnumeric will perform regular string to serial number "
#~ "conversion for you, so you can enter a date as a string.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "YEAR(DATE(2003, 4, 30)) equals 2003.\n"
#~ "\n"
#~ "@SEEALSO=DAY, MONTH, TIME, NOW"
#~ msgstr ""
#~ "@FUNCTION=JAHR\n"
#~ "@SYNTAX=JAHR(Datum)\n"
#~ "@DESCRIPTION=JAHR konvertiert eine Seriennummer in ein Jahr.\n"
#~ "\n"
#~ "* Beachten Sie, dass Gnumeric eine Zeichenkette automatisch in eine "
#~ "Seriennummer umwandelt, sodass das Datum als Zeichenkette übergeben "
#~ "werden kann.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "JAHR(DATUM(2003, 4, 30)) liefert 2003.\n"
#~ "\n"
#~ "@SEEALSO=TAG, MONAT, ZEIT, JETZT"

#~ msgid ""
#~ "@FUNCTION=MONTH\n"
#~ "@SYNTAX=MONTH (date)\n"
#~ "@DESCRIPTION=MONTH converts a serial number to a month.\n"
#~ "\n"
#~ "* Note that Gnumeric will perform regular string to serial number "
#~ "conversion for you, so you can enter a date as a string.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "MONTH(DATE(2003, 4, 30)) equals 4.\n"
#~ "\n"
#~ "@SEEALSO=DAY, TIME, NOW, YEAR"
#~ msgstr ""
#~ "@FUNCTION=MONAT\n"
#~ "@SYNTAX=MONAT(Datum)\n"
#~ "@DESCRIPTION=MONAT konvertiert eine Seriennummer in einen Monat.\n"
#~ "\n"
#~ "* Bitte beachten Sie, dass Gnumeric eine Zeichenkette automatisch in eine "
#~ "Seriennummer umwandelt, sodass das Datum als Zeichenkette übergeben "
#~ "werden kann.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "MONAT(DATUM(2003, 4, 30)) liefert 4.\n"
#~ "\n"
#~ "@SEEALSO=TAG, ZEIT, JETZT, JAHR"

#~ msgid ""
#~ "@FUNCTION=DAY\n"
#~ "@SYNTAX=DAY (date)\n"
#~ "@DESCRIPTION=DAY converts a serial number to a day of month.\n"
#~ "\n"
#~ "* Note that Gnumeric will perform regular string to serial number "
#~ "conversion for you, so you can enter a date as a string.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DAY(\"10/24/1968\") equals 24.\n"
#~ "\n"
#~ "@SEEALSO=MONTH, TIME, NOW, YEAR"
#~ msgstr ""
#~ "@FUNCTION=TAG\n"
#~ "@SYNTAX=TAG(Datum)\n"
#~ "@DESCRIPTION=TAG konvertiert eine Seriennummer in den Tag eines Monats.\n"
#~ "\n"
#~ "* Beachten Sie, dass Gnumeric eine Zeichenkette automatisch in eine "
#~ "Seriennummer umwandelt, sodass das Datum als Zeichenkette übergeben "
#~ "werden kann.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DAY(\"10/24/1968\") liefert 24.\n"
#~ "\n"
#~ "@SEEALSO=MONAT, ZEIT, JETZT, JAHR"

#~ msgid ""
#~ "@FUNCTION=WEEKDAY\n"
#~ "@SYNTAX=WEEKDAY (date[, method])\n"
#~ "@DESCRIPTION=WEEKDAY converts a serial number to a weekday.\n"
#~ "\n"
#~ "This function returns an integer indicating the day of week.\n"
#~ "@METHOD indicates the numbering system.  It defaults to 1.\n"
#~ "\n"
#~ "  For @METHOD=1: Sunday is 1, Monday is 2, etc.\n"
#~ "  For @METHOD=2: Monday is 1, Tuesday is 2, etc.\n"
#~ "  For @METHOD=3: Monday is 0, Tuesday is 1, etc.\n"
#~ "\n"
#~ "* Note that Gnumeric will perform regular string to serial number "
#~ "conversion for you, so you can enter a date as a string.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "WEEKDAY(\"10/24/1968\") equals 5 (Thursday).\n"
#~ "\n"
#~ "@SEEALSO=DAY, MONTH, TIME, NOW, YEAR"
#~ msgstr ""
#~ "@FUNCTION=WOCHENTAG\n"
#~ "@SYNTAX=WOCHENTAG(Datum[, Methode])\n"
#~ "@DESCRIPTION=WOCHENTAG konvertiert eine Seriennummer in einen Wochentag.\n"
#~ "\n"
#~ "Diese Funktion liefert eine Ganzzahl, die den Wochentag angibt.\n"
#~ "@Methode legt die Art des Zählens fest. Die Vorgabe ist 1.\n"
#~ "\n"
#~ "  Für @Methode=1: Sonntag ist 1, Montag ist 2, u.s.w.\n"
#~ "  Für @Methode=2: Montag ist 1, Dienstag ist 2, u.s.w.\n"
#~ "  Für @Methode=3: Montag ist 0, Dienstag ist 1, u.s.w.\n"
#~ "\n"
#~ "* Beachten Sie, dass Gnumeric eine Zeichenkette automatisch in eine "
#~ "Seriennummer umwandelt, sodass das Datum als Zeichenkette übergeben "
#~ "werden kann.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "WOCHENTAG(\"10/24/1968\") liefert 5 (Donnerstag).\n"
#~ "\n"
#~ "@SEEALSO=TAG, MONAT, ZEIT, JETZT, JAHR"

#~ msgid ""
#~ "@FUNCTION=DAYS360 \n"
#~ "@SYNTAX=DAYS360 (date1,date2,method)\n"
#~ "@DESCRIPTION=DAYS360 returns the number of days from @date1 to @date2 "
#~ "following a 360-day calendar in which all months are assumed to have 30 "
#~ "days.\n"
#~ "\n"
#~ "* If @method is 1, the European method will be used.  In this case, if "
#~ "the day of the month is 31 it will be considered as 30.\n"
#~ "* If @method is 0 or omitted, the MS Excel (tm) US method will be used.  "
#~ "This is a somewhat complicated industry standard method where the last "
#~ "day of February is considered to be the 30th day of the month, but only "
#~ "for the first date.\n"
#~ "* If @method is 2, a saner version of the US method is used in which both "
#~ "dates get the same February treatment.\n"
#~ "* Note that Gnumeric will perform regular string to serial number "
#~ "conversion for you, so you can enter a date as a string.\n"
#~ "* This function is mostly Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DAYS360(DATE(2003, 2, 3), DATE(2007, 4, 2)) equals 1499.\n"
#~ "\n"
#~ "@SEEALSO=MONTH, TIME, NOW, YEAR"
#~ msgstr ""
#~ "@FUNCTION=TAGE360\n"
#~ "@SYNTAX=TAGE360(Datum1,Datum2,Methode)\n"
#~ "@DESCRIPTION=TAGE360 liefert die die Anzahl der Tage von @Datum1 bis "
#~ "@Datum2, wobei ein 360-Tages-Kalender zu Grunde gelegt wird, in dem "
#~ "angenommen wird, dass alle Monate 30 Tage haben.\n"
#~ "\n"
#~ "* Falls @Methode 1 ist, wird die europäische Methode verwendet. In diesem "
#~ "Fall wird angenommen, dass ein Monat mit 31 Tagen 30 Tage hat.\n"
#~ "* Falls @Methode 0 ist oder nicht übergeben wird, wird die MS Excel (tm)-"
#~ "US-Methode verwendet. Diese ist ziemlich kompliziert und industriell "
#~ "genormt. Hierbei wird der letzte Tag des Februar als dreißigster Tag des "
#~ "Monats angesehen, jedoch nur beim ersten Datum.\n"
#~ "* Falls @Methode 2 ist, wird eine vernünftigere Version der US-Methode "
#~ "verwendet, bei der Februar bei beiden Daten gleich behandelt wird.\n"
#~ "* Beachten Sie, dass Gnumeric Zeichenketten in Seriennummern umwandelt, "
#~ "sodass Daten als Zeichenketten übergeben werden können.\n"
#~ "* Diese Funktion ist weitgehend Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TAGE360(DATUM(2003, 2, 3), DATUM(2007, 4, 2)) liefert 1499.\n"
#~ "\n"
#~ "@SEEALSO=MONAT, ZEIT, JETZT, JAHR"

#~ msgid ""
#~ "@FUNCTION=EOMONTH\n"
#~ "@SYNTAX=EOMONTH (start_date,months)\n"
#~ "@DESCRIPTION=EOMONTH returns the last day of the month which is @months "
#~ "from the @start_date.\n"
#~ "\n"
#~ "* EOMONTH returns #NUM! if @start_date or @months are invalid.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "If A1 contains 12/21/00 then EOMONTH(A1,0)=12/31/00, EOMONTH(A1,5)"
#~ "=5/31/01, and EOMONTH(A1,2)=2/28/01\n"
#~ "\n"
#~ "@SEEALSO=MONTH"
#~ msgstr ""
#~ "@FUNCTION=MONATSENDE\n"
#~ "@SYNTAX=MONATSENDE (Ausgangsdatum,Monate)\n"
#~ "@DESCRIPTION=MONATSENDE liefert den letzten Tag des Monats, der @Monate "
#~ "nach dem @Ausgangsdatum liegt.\n"
#~ "\n"
#~ "* Falls @Ausgangsdatum oder @Monate ungültig ist, liefert MONATSENDE "
#~ "einen #ZAHL!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Falls A1 12/21/00 enthält, dann liefert:\n"
#~ "MONATSENDE(A1,0) 12/31/00,\n"
#~ "MONATSENDE(A1,5) 5/31/01 und\n"
#~ "MONATSENDE(A1,2) 2/28/01\n"
#~ "\n"
#~ "@SEEALSO=MONAT"

#~ msgid ""
#~ "@FUNCTION=WORKDAY\n"
#~ "@SYNTAX=WORKDAY (start_date,days[,holidays])\n"
#~ "@DESCRIPTION=WORKDAY returns the date which is @days working days from "
#~ "the @start_date.  Weekends and holidays optionally supplied in @holidays "
#~ "are respected.\n"
#~ "\n"
#~ "* WORKDAY returns #NUM! if @start_date or @days are invalid.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DAY(WORKDAY(DATE(2001,1,5),30)) equals 16 and\n"
#~ "MONTH(WORKDAY(DATE(2001,1,5),30)) equals 2.\n"
#~ "\n"
#~ "@SEEALSO=NETWORKDAYS"
#~ msgstr ""
#~ "@FUNCTION=ARBEITSTAG\n"
#~ "@SYNTAX=ARBEITSTAG (Ausgangsdatum,Tage[,Freie_Tage])\n"
#~ "@DESCRIPTION=ARBEISTAG liefert das Datum des Tags, der @Tage Werktage vom "
#~ "@Ausgangsdatum entfernt ist. Feiertage, die zusätzlich als @Freie_Tage "
#~ "übergegeben werden, werden hierbei ebenfalls berücksichtigt.\n"
#~ "\n"
#~ "* Falls @Ausgangsdatum oder @Monate ungültig ist, liefert ARBEITSTAG "
#~ "einen #ZAHL!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TAG(ARBEITSTAG(DATUM(2001,1,5),30)) liefert 16.\n"
#~ "MONAT(ARBEITSTAG(DATUM(2001,1,5),30)) liefert 2.\n"
#~ "\n"
#~ "@SEEALSO=NETTOARBEITSTAGE"

#~ msgid ""
#~ "@FUNCTION=NETWORKDAYS\n"
#~ "@SYNTAX=NETWORKDAYS (start_date,end_date[,holidays])\n"
#~ "@DESCRIPTION=NETWORKDAYS returns the number of non-weekend non-holidays "
#~ "between @start_date and @end_date including these dates. Holidays are "
#~ "optionally supplied in @holidays.\n"
#~ "\n"
#~ "* NETWORKDAYS returns #NUM! if @start_date or @end_date are invalid.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "NETWORKDAYS(DATE(2001,1,2),DATE(2001,2,15)) equals 33.\n"
#~ "\n"
#~ "@SEEALSO=WORKDAY"
#~ msgstr ""
#~ "@FUNCTION=NETTOARBEITSTAGE\n"
#~ "@SYNTAX=NETTOARBEITSTAGE (Ausgangsdatum,Zieldatum[,Freie_Tage])\n"
#~ "@DESCRIPTION=NETTOARBEITSTAGE liefert die Anzahl der Werktage zwischen "
#~ "@Ausgangsdatum und @Zieldatum einschließlich diesen. Feiertage, die "
#~ "zusätzlich als @Freie_Tage übergegeben werden, werden hierbei ebenfalls "
#~ "berücksichtigt.\n"
#~ "\n"
#~ "* Falls @Ausgangsdatum oder @Zieldatum ungültig ist, liefert "
#~ "NETTOARBEITSTAGE einen #ZAHL!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "NETTOARBEITSTAGE(DATUM(2001,1,5),DATUM(2001,2,15)) liefert 33.\n"
#~ "\n"
#~ "@SEEALSO=ARBEITSTAGE"

#~ msgid ""
#~ "@FUNCTION=ISOWEEKNUM\n"
#~ "@SYNTAX=ISOWEEKNUM (date)\n"
#~ "@DESCRIPTION=ISOWEEKNUM returns the ISO 8601 week number of @date.\n"
#~ "\n"
#~ "An ISO 8601 week starts on Monday. Weeks are numbered from 1. A week "
#~ "including days from two different years is assigned to the year which "
#~ "includes the most days. This means that Dec 31 could be in week 1 of the "
#~ "following year, and Jan 1 could be in week 52 or 53 of the previous year. "
#~ "ISOWEEKNUM returns the week number.\n"
#~ "\n"
#~ "* ISOWEEKNUM returns #NUM! if date is invalid.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "If A1 contains 12/21/00 then ISOWEEKNUM(A1)=51\n"
#~ "@SEEALSO=WEEKNUM, ISOYEAR"
#~ msgstr ""
#~ "@FUNCTION=ISOWOCHENZAHL\n"
#~ "@SYNTAX=ISOWOCHENZAHL(Datum)\n"
#~ "@DESCRIPTION=ISOWOCHENZAHL liefert die ISO 8601-Wochenzahl von @Datum.\n"
#~ "\n"
#~ "Eine ISO 8601-Woche beginnt am Montag. Wochen werden von 1 an "
#~ "durchgezählt. Eine Woche, die sich über zwei Jahre erstreckt, wird dem "
#~ "Jahr zugewiesen, das die meisten Wochentage enthält. Das heißt, dass der "
#~ "31. Dezember in der ersten Woche des folgenden Jahres und der 1. Januar "
#~ "in der 52. oder 53. Woche des vorherigen Jahres sein kann. ISOWOCHENZAHL "
#~ "liefert die Wochenzahl, während ISOJAHR das Jahr, dem die Woche "
#~ "zugewiesen ist, liefert.\n"
#~ "* Falls @Datum ungültig ist, liefert ISOWOCHENZAHL einen #ZAHL-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Falls A1 12/21/00 enthält, liefert ISOWOCHENZAHL(A1) 51\n"
#~ "@SEEALSO=WOCHENZAHL, ISOJAHR"

#~ msgid ""
#~ "@FUNCTION=ISOYEAR\n"
#~ "@SYNTAX=ISOYEAR (date)\n"
#~ "@DESCRIPTION=ISOYEAR returns the year of the ISO 8601 week number of "
#~ "@date.\n"
#~ "\n"
#~ "An ISO 8601 week starts on Monday. Weeks are numbered from 1. A week "
#~ "including days from two different years is assigned to the year which "
#~ "includes the most days. This means that Dec 31 could be in week 1 of the "
#~ "following year, and Jan 1 could be in week 52 or 53 of the previous year. "
#~ "ISOYEAR returns the year the week is assigned to.\n"
#~ "\n"
#~ "* ISOYEAR returns #NUM! if date is invalid.\n"
#~ "@EXAMPLES=\n"
#~ "If A1 contains 12/31/2001 then ISOYEAR(A1)=2002\n"
#~ "@SEEALSO=ISOWEEKNUM"
#~ msgstr ""
#~ "@FUNCTION=ISOJAHR\n"
#~ "@SYNTAX=ISOJAHR(Datum)\n"
#~ "@DESCRIPTION=ISOJAHR liefert die ISO 8601-Wochenzahl von @Datum.\n"
#~ "\n"
#~ "Eine ISO 8601-Woche beginnt am Montag. Wochen werden von 1 an "
#~ "durchgezählt. Eine Woche, die sich über zwei Jahre erstreckt, wird dem "
#~ "Jahr zugewiesen, das die meisten Wochentage enthält. Das heißt, dass der "
#~ "31. Dezember in der ersten Woche des folgenden Jahres und der 1. Januar "
#~ "in der 52. oder 53. Woche des vorherigen Jahres sein kann. ISOJAHR "
#~ "liefert das Jahr, dem die Woche zugewiesen ist, während ISOWOCHENZAHL die "
#~ "Wochenzahl liefert.\n"
#~ "\n"
#~ "* Falls @Datum ungültig ist, liefert ISOJAHR einen #ZAHL-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Falls A1 12/31/2001 enthält, liefert ISOJAHR 2002\n"
#~ "@SEEALSO=ISOWOCHENZAHL"

#~ msgid ""
#~ "@FUNCTION=WEEKNUM\n"
#~ "@SYNTAX=WEEKNUM (date[,method])\n"
#~ "@DESCRIPTION=WEEKNUM returns the week number of @date according to the "
#~ "given @method.\n"
#~ "\n"
#~ "@method defaults to 1.\n"
#~ "\n"
#~ "  For @method=1, week starts on Sunday, and days before first Sunday are "
#~ "in week 0.\n"
#~ "  For @method=2, week starts on Monday, and days before first Monday are "
#~ "in week 0.\n"
#~ "  For @method=150, the ISO 8601 week number is returned.\n"
#~ "\n"
#~ "* WEEKNUM returns #NUM! if @date or @method is invalid.\n"
#~ "* This function is Excel compatible, except that Excel does not support "
#~ "ISO 8601 week numbers.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "If A1 contains 12/21/00 then WEEKNUM(A1,2)=51\n"
#~ "@SEEALSO=ISOWEEKNUM"
#~ msgstr ""
#~ "@FUNCTION=WOCHENZAHL\n"
#~ "@SYNTAX=WOCHENZAHL (Datum[,Methode])\n"
#~ "@DESCRIPTION=WOCHENZAHL liefert die Wochenzahl von @Datum, entsprechend "
#~ "der übergebenen Methode @Methode.\n"
#~ "\n"
#~ "Die Vorgabe für @Methode ist 1.\n"
#~ "\n"
#~ "  Falls @Methode 1 ist, beginnt die Woche am Sonntag und Tage vor dem "
#~ "ersten Sonntag sind in Woche 0.\n"
#~ "  Falls @Methode 2 ist, beginnt die Woche am Montag und Tage vor dem "
#~ "ersten Montag sind in Woche 0.\n"
#~ "  Falls @Methode 150 ist, liefert WOCHENZAHL die ISO 8601-Wochenzahl.\n"
#~ "* Falls @Datum oder @Methode ungültig ist, liefert WOCHENZAHL einen #ZAHL-"
#~ "Fehler.\n"
#~ "* Diese Funktion ist Excel kompatibel, bis auf die Tatsache, dass Excel "
#~ "keine ISO 8601-Wochenzahlen unterstützt.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Falls A1 12/21/00 enthält, liefert WOCHENZAHL(A1,2) 51\n"
#~ "@SEEALSO=ISOWOCHENZAHL"

#~ msgid ""
#~ "@FUNCTION=YEARFRAC\n"
#~ "@SYNTAX=YEARFRAC (start_date, end_date [,basis])\n"
#~ "@DESCRIPTION=YEARFRAC returns the number of full days between @start_date "
#~ "and @end_date according to the @basis.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=DATEDIF"
#~ msgstr ""
#~ "@FUNCTION=JAHRBRUCH\n"
#~ "@SYNTAX=JAHRBRUCH (Ausgangsdatum, Zieldatum [, Basis])\n"
#~ "@DESCRIPTION=JAHRBRUCH liefert die Anzahl ganzer Tage zwischen "
#~ "@Ausgangsdatum und @Zieldatum entsprechend der @Basis.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=DATEDIF"

#~ msgid ""
#~ "@FUNCTION=BASE\n"
#~ "@SYNTAX=BASE(number,base[,length])\n"
#~ "@DESCRIPTION=BASE function converts a number to a string representing "
#~ "that number in base @base.\n"
#~ "\n"
#~ "* @base must be an integer between 2 and 36.\n"
#~ "* This function is OpenOffice.Org compatible.\n"
#~ "* Optional argument @length specifies the minimum result length.  "
#~ "Leading  zeroes will be added to reach this length.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BASE(255,16,4) equals \"00FF\".\n"
#~ "\n"
#~ "@SEEALSO=DECIMAL"
#~ msgstr ""
#~ "@FUNCTION=OKTINDEZ\n"
#~ "@SYNTAX=OKTINDEZ(x)\n"
#~ "@DESCRIPTION=OKTINDEZ wandelt eine oktale Zahl in ihr dezimales "
#~ "Äquivalent um.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "OKTINDEZ(\"124\") liefert 84.\n"
#~ "\n"
#~ "@SEEALSO=DEZINOKT, OKTINBIN, OKTINHEX"

#~ msgid ""
#~ "@FUNCTION=BIN2DEC\n"
#~ "@SYNTAX=BIN2DEC(x)\n"
#~ "@DESCRIPTION=BIN2DEC function converts a binary number in string or "
#~ "number to its decimal equivalent.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BIN2DEC(101) equals 5.\n"
#~ "\n"
#~ "@SEEALSO=DEC2BIN, BIN2OCT, BIN2HEX"
#~ msgstr ""
#~ "@FUNCTION=BININDEZ\n"
#~ "@SYNTAX=BININDEZ(x)\n"
#~ "@DESCRIPTION=BININDEZ wandelt eine Binärzahl in ihr dezimales Äquivalent "
#~ "um.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BININDEZ(101) liefert 5.\n"
#~ "\n"
#~ "@SEEALSO=DEZINBIN, BININOKT, BININHEX"

#~ msgid ""
#~ "@FUNCTION=BIN2OCT\n"
#~ "@SYNTAX=BIN2OCT(number[,places])\n"
#~ "@DESCRIPTION=BIN2OCT function converts a binary number to an octal "
#~ "number. @places is an optional field, specifying to zero pad to that "
#~ "number of spaces.\n"
#~ "\n"
#~ "* If @places is too small or negative #NUM! error is returned.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BIN2OCT(110111) equals 67.\n"
#~ "\n"
#~ "@SEEALSO=OCT2BIN, BIN2DEC, BIN2HEX"
#~ msgstr ""
#~ "@FUNCTION=BININOKT\n"
#~ "@SYNTAX=BININOKT(Zahl[,Stellen])\n"
#~ "@DESCRIPTION=BININOKT wandelt eine Binärzahl in ihr oktales Äquivalent "
#~ "um. @Stellen ist ein optionales Argument, wodurch eventuelle leere "
#~ "Stellen mit Nullen aufgefüllt werden, bis die Zahl @Stellen lang ist.\n"
#~ "\n"
#~ "* Falls @Stellen zu klein oder negativ ist, liefert BININOKT einen #ZAHL!-"
#~ "Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BININOKT(110111) liefert 67.\n"
#~ "\n"
#~ "@SEEALSO=OKTINBIN, BININDEZ, BININHEX"

#~ msgid ""
#~ "@FUNCTION=BIN2HEX\n"
#~ "@SYNTAX=BIN2HEX(number[,places])\n"
#~ "@DESCRIPTION=BIN2HEX function converts a binary number to a hexadecimal "
#~ "number.  @places is an optional field, specifying to zero pad to that "
#~ "number of spaces.\n"
#~ "\n"
#~ "* If @places is too small or negative #NUM! error is returned.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BIN2HEX(100111) equals 27.\n"
#~ "\n"
#~ "@SEEALSO=HEX2BIN, BIN2OCT, BIN2DEC"
#~ msgstr ""
#~ "@FUNCTION=BININHEX\n"
#~ "@SYNTAX=BININHEX(Zahl[,Stellen])\n"
#~ "@DESCRIPTION=BININHEX wandelt eine Binärzahl ihr hexadezimale Äquivalent "
#~ "um. @Stellen ist ein optionales Argument, wodurch eventuelle leere "
#~ "Stellen mit Nullen aufgefüllt werden, bis die Zahl @Stellen lang ist.\n"
#~ "\n"
#~ "* Falls @Stellen zu klein oder negativ ist, liefert BININHEX einen #ZAHL!-"
#~ "Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BININHEX(100111) liefert 27.\n"
#~ "\n"
#~ "@SEEALSO=HEXINBIN, BININOKT, BININDEZ"

#~ msgid ""
#~ "@FUNCTION=DEC2BIN\n"
#~ "@SYNTAX=DEC2BIN(number[,places])\n"
#~ "@DESCRIPTION=DEC2BIN function converts a decimal number to a binary "
#~ "number. @places is an optional field, specifying to zero pad to that "
#~ "number of spaces.\n"
#~ "\n"
#~ "* If @places is too small or negative #NUM! error is returned.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DEC2BIN(42) equals 101010.\n"
#~ "\n"
#~ "@SEEALSO=BIN2DEC, DEC2OCT, DEC2HEX"
#~ msgstr ""
#~ "@FUNCTION=DEZINBIN\n"
#~ "@SYNTAX=DEZINBIN(Zahl[,Stellen])\n"
#~ "@DESCRIPTION=DEZINBIN wandelt eine Dezimalzahl ihr binäres Äquivalent um. "
#~ "@Stellen ist ein optionales Argument, wodurch eventuelle leere Stellen "
#~ "mit Nullen aufgefüllt werden, bis die Zahl @Stellen lang ist.\n"
#~ "\n"
#~ "* Falls @Stellen zu klein oder negativ ist, liefert DEZINBIN einen #ZAHL!-"
#~ "Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DEZINBIN(42) liefert 101010.\n"
#~ "\n"
#~ "@SEEALSO=BININDEZ, DEZINOKT, DEZINHEX"

#~ msgid ""
#~ "@FUNCTION=DEC2OCT\n"
#~ "@SYNTAX=DEC2OCT(number[,places])\n"
#~ "@DESCRIPTION=DEC2OCT function converts a decimal number to an octal "
#~ "number. @places is an optional field, specifying to zero pad to that "
#~ "number of spaces.\n"
#~ "\n"
#~ "* If @places is too small or negative #NUM! error is returned.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DEC2OCT(42) equals 52.\n"
#~ "\n"
#~ "@SEEALSO=OCT2DEC, DEC2BIN, DEC2HEX"
#~ msgstr ""
#~ "@FUNCTION=DEZINOKT\n"
#~ "@SYNTAX=DEZINOKT(Zahl[,Stellen])\n"
#~ "@DESCRIPTION=DEZINOKT wandelt eine Dezimalzahl in ihr dezimales "
#~ "Äquivalent um. @Stellen ist ein optionales Argument, wodurch eventuelle "
#~ "leere Stellen mit Nullen aufgefüllt werden, bis die Zahl @Stellen lang "
#~ "ist.\n"
#~ "\n"
#~ "* Falls @Stellen zu klein oder negativ ist, liefert DEZINOKT einen #ZAHL!-"
#~ "Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DEZINOKT(42) liefert 52.\n"
#~ "\n"
#~ "@SEEALSO=OKTINDEZ, DEZINBIN, DEZINHEX"

#~ msgid ""
#~ "@FUNCTION=DEC2HEX\n"
#~ "@SYNTAX=DEC2HEX(number[,places])\n"
#~ "@DESCRIPTION=DEC2HEX function converts a decimal number to a hexadecimal "
#~ "number. @places is an optional field, specifying to zero pad to that "
#~ "number of spaces.\n"
#~ "\n"
#~ "* If @places is too small or negative #NUM! error is returned.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DEC2HEX(42) equals 2A.\n"
#~ "\n"
#~ "@SEEALSO=HEX2DEC, DEC2BIN, DEC2OCT"
#~ msgstr ""
#~ "@FUNCTION=DEZINHEX\n"
#~ "@SYNTAX=DEZINHEX(x)\n"
#~ "@DESCRIPTION=DEZINHEX wandelt eine Dezimalzahl in ihr hexadezimales "
#~ "Äquivalent um. @Stellen ist ein optionales Argument, wodurch eventuelle "
#~ "leere Stellen mit Nullen aufgefüllt werden, bis die Zahl @Stellen lang "
#~ "ist.\n"
#~ "\n"
#~ "* Falls @Stellen zu klein oder negativ ist, liefert DEZINHEX einen #ZAHL!-"
#~ "Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DEZINHEX(42) liefert 2A.\n"
#~ "\n"
#~ "@SEEALSO=HEXINDEZ, DEZINBIN, DEZINOKT"

#~ msgid ""
#~ "@FUNCTION=DECIMAL\n"
#~ "@SYNTAX=DECIMAL(text,base)\n"
#~ "@DESCRIPTION=DECIMAL function converts a number in base @base to "
#~ "decimal.\n"
#~ "\n"
#~ "* @base must be an integer between 2 and 36.\n"
#~ "* This function is OpenOffice.Org compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DECIMAL(\"A1\",16) equals 161.\n"
#~ "\n"
#~ "@SEEALSO=BASE"
#~ msgstr ""
#~ "@FUNCTION=OKTINDEZ\n"
#~ "@SYNTAX=OKTINDEZ(x)\n"
#~ "@DESCRIPTION=OKTINDEZ wandelt eine oktale Zahl in ihr dezimales "
#~ "Äquivalent um.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "OKTINDEZ(\"124\") liefert 84.\n"
#~ "\n"
#~ "@SEEALSO=DEZINOKT, OKTINBIN, OKTINHEX"

#~ msgid ""
#~ "@FUNCTION=OCT2DEC\n"
#~ "@SYNTAX=OCT2DEC(x)\n"
#~ "@DESCRIPTION=OCT2DEC function converts an octal number in a string or "
#~ "number to its decimal equivalent.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "OCT2DEC(\"124\") equals 84.\n"
#~ "\n"
#~ "@SEEALSO=DEC2OCT, OCT2BIN, OCT2HEX"
#~ msgstr ""
#~ "@FUNCTION=OKTINDEZ\n"
#~ "@SYNTAX=OKTINDEZ(x)\n"
#~ "@DESCRIPTION=OKTINDEZ wandelt eine oktale Zahl in ihr dezimales "
#~ "Äquivalent um.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "OKTINDEZ(\"124\") liefert 84.\n"
#~ "\n"
#~ "@SEEALSO=DEZINOKT, OKTINBIN, OKTINHEX"

#~ msgid ""
#~ "@FUNCTION=OCT2BIN\n"
#~ "@SYNTAX=OCT2BIN(number[,places])\n"
#~ "@DESCRIPTION=OCT2BIN function converts an octal number to a binary "
#~ "number.  @places is an optional field, specifying to zero pad to that "
#~ "number of spaces.\n"
#~ "\n"
#~ "* If @places is too small or negative #NUM! error is returned.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "OCT2BIN(\"213\") equals 10001011.\n"
#~ "\n"
#~ "@SEEALSO=BIN2OCT, OCT2DEC, OCT2HEX"
#~ msgstr ""
#~ "@FUNCTION=OKTINBIN\n"
#~ "@SYNTAX=OKTINBIN(Zahl[,Stellen])\n"
#~ "@DESCRIPTION=OKTINBIN wandelt eine oktale Zahl in ihr binäres Äquivalent "
#~ "um. @Stellen ist ein optionales Argument, wodurch eventuelle leere "
#~ "Stellen mit Nullen aufgefüllt werden, bis die Zahl @Stellen lang ist. "
#~ "@Stellen ist ein optionales Argument, wodurch eventuelle leere Stellen "
#~ "mit Nullen aufgefüllt werden, bis die Zahl @Stellen lang ist.\n"
#~ "\n"
#~ "* Falls @Stellen zu klein oder negativ ist, liefert OKTINBIN einen #ZAHL!-"
#~ "Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "OKTINBIN(\"213\") liefert 10001011.\n"
#~ "\n"
#~ "@SEEALSO=BININOKT, OKTINDEZ, OCTINHEX"

#~ msgid ""
#~ "@FUNCTION=OCT2HEX\n"
#~ "@SYNTAX=OCT2HEX(number[,places])\n"
#~ "@DESCRIPTION=OCT2HEX function converts an octal number to a hexadecimal "
#~ "number.  @places is an optional field, specifying to zero pad to that "
#~ "number of spaces.\n"
#~ "\n"
#~ "* If @places is too small or negative #NUM! error is returned.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "OCT2HEX(132) equals 5A.\n"
#~ "\n"
#~ "@SEEALSO=HEX2OCT, OCT2BIN, OCT2DEC"
#~ msgstr ""
#~ "@FUNCTION=OKTINHEX\n"
#~ "@SYNTAX=OKTINHEX(Zahl[,Stellen])\n"
#~ "@DESCRIPTION=OKTINHEX wandelt eine oktale Zahl in ihr hexadezimales "
#~ "Äquivalent um. @Stellen ist ein optionales Argument, wodurch eventuelle "
#~ "leere Stellen mit Nullen aufgefüllt werden, bis die Zahl @Stellen lang "
#~ "ist.\n"
#~ "\n"
#~ "* Falls @Stellen zu klein oder negativ ist, liefert OKTINHEX einen #ZAHL!-"
#~ "Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "OKTINHEX(132) liefert 5A.\n"
#~ "\n"
#~ "@SEEALSO=HEXINOKT, OKTINBIN, OKTINDEZ"

#~ msgid ""
#~ "@FUNCTION=HEX2BIN\n"
#~ "@SYNTAX=HEX2BIN(number[,places])\n"
#~ "@DESCRIPTION=HEX2BIN function converts a hexadecimal number to a binary "
#~ "number.  @places is an optional field, specifying to zero pad to that "
#~ "number of spaces.\n"
#~ "\n"
#~ "* If @places is too small or negative #NUM! error is returned.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "HEX2BIN(\"2A\") equals 101010.\n"
#~ "\n"
#~ "@SEEALSO=BIN2HEX, HEX2OCT, HEX2DEC"
#~ msgstr ""
#~ "@FUNCTION=HEXINBIN\n"
#~ "@SYNTAX=HEXINBIN(Zahl[,Stellen])\n"
#~ "@DESCRIPTION=HEXINBIN wandelt eine hexadezimale Zahl ihr binäres "
#~ "Äquivalent um. @Stellen ist ein optionales Argument, wodurch eventuelle "
#~ "leere Stellen mit Nullen aufgefüllt werden, bis die Zahl @Stellen lang "
#~ "ist.\n"
#~ "\n"
#~ "* Falls @Stellen zu klein oder negativ ist, liefert HEXINBIN einen #ZAHL!-"
#~ "Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "HEXINBIN(101) liefert 5.\n"
#~ "\n"
#~ "@SEEALSO=BININHEX, HEXINOKT, HEXINDEZ"

#~ msgid ""
#~ "@FUNCTION=HEX2OCT\n"
#~ "@SYNTAX=HEX2OCT(number[,places])\n"
#~ "@DESCRIPTION=HEX2OCT function converts a hexadecimal number to an octal "
#~ "number.  @places is an optional field, specifying to zero pad to that "
#~ "number of spaces.\n"
#~ "\n"
#~ "* If @places is too small or negative #NUM! error is returned.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "HEX2OCT(\"2A\") equals 52.\n"
#~ "\n"
#~ "@SEEALSO=OCT2HEX, HEX2BIN, HEX2DEC"
#~ msgstr ""
#~ "@FUNCTION=HEXINOKT\n"
#~ "@SYNTAX=HEXINOKT(Zahl[,Stellen])\n"
#~ "@DESCRIPTION=HEXINOKT wandelt eine hexadezimale Zahl in ihr oktales "
#~ "Äquivalent um. @Stellen ist ein optionales Argument, wodurch eventuelle "
#~ "leere Stellen mit Nullen aufgefüllt werden, bis die Zahl @Stellen lang "
#~ "ist.\n"
#~ "\n"
#~ "* Falls @Stellen zu klein oder negativ ist, liefert HEXINOKT einen #ZAHL!-"
#~ "Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "HEXINOKT(\"2A\") liefert 52.\n"
#~ "\n"
#~ "@SEEALSO=OKTINHEX, HEXINBIN, HEXINDEZ"

#~ msgid ""
#~ "@FUNCTION=HEX2DEC\n"
#~ "@SYNTAX=HEX2DEC(x)\n"
#~ "@DESCRIPTION=HEX2DEC function converts a hexadecimal number to its "
#~ "decimal equivalent.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "HEX2DEC(\"2A\") equals 42.\n"
#~ "\n"
#~ "@SEEALSO=DEC2HEX, HEX2BIN, HEX2OCT"
#~ msgstr ""
#~ "@FUNCTION=HEXINDEZ\n"
#~ "@SYNTAX=HEXINDEZ(x)\n"
#~ "@DESCRIPTION=HEXINDEZ wandelt eine hexadezimale Zahl in ihr dezimales "
#~ "Äquivalent um.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "HEXINDEZ(\"2A\") liefert 42.\n"
#~ "\n"
#~ "@SEEALSO=DEZINHEX, HEXINBIN, HEXINOKT"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=BESSELI\n"
#~ "@SYNTAX=BESSELI(x,y)\n"
#~ "@DESCRIPTION=BESSELI function returns the Neumann, Weber or Bessel "
#~ "function.\n"
#~ "\n"
#~ "@x is where the function is evaluated. @y is the order of the Bessel "
#~ "function.\n"
#~ "\n"
#~ "* If @x or @y are not numeric a #VALUE! error is returned.\n"
#~ "* If @y < 0 a #NUM! error is returned.\n"
#~ "* This function extends the Excel function of the same name to non-"
#~ "integer orders.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BESSELI(0.7,3) equals 0.007367374.\n"
#~ "\n"
#~ "@SEEALSO=BESSELJ,BESSELK,BESSELY"
#~ msgstr ""
#~ "@FUNCTION=BESSELI\n"
#~ "@SYNTAX=BESSELI(x,y)\n"
#~ "@DESCRIPTION=BESSELI liefert die Neumann-, Weber- oder Bessel-Funktion.\n"
#~ "\n"
#~ "@x ist die Stelle, an der die Funktion ausgewertet wird und @y die "
#~ "Reihenfolge der Bessel-Funktion.\n"
#~ "\n"
#~ "* Falls @y keine Ganzzahl ist, werden die Nachkommastellen "
#~ "abgeschnitten.\n"
#~ "* Falls @x oder @y nicht-numerisch ist, liefert BESSELI einen #WERT!-"
#~ "Fehler.\n"
#~ "* Falls @y < 0 ist, liefert BESSELI einen #ZAHL!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BESSELI(0.7,3) liefert 0.007367374.\n"
#~ "\n"
#~ "@SEEALSO=BESSELJ,BESSELK,BESSELY"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=BESSELK\n"
#~ "@SYNTAX=BESSELK(x,y)\n"
#~ "@DESCRIPTION=BESSELK function returns the Neumann, Weber or Bessel "
#~ "function. @x is where the function is evaluated. @y is the order of the "
#~ "Bessel function.\n"
#~ "\n"
#~ "* If @x or @y are not numeric a #VALUE! error is returned.\n"
#~ "* If @y < 0 a #NUM! error is returned.\n"
#~ "* This function extends the Excel function of the same name to non-"
#~ "integer orders.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BESSELK(3,9) equals 397.95880.\n"
#~ "\n"
#~ "@SEEALSO=BESSELI,BESSELJ,BESSELY"
#~ msgstr ""
#~ "@FUNCTION=BESSELK\n"
#~ "@SYNTAX=BESSELK(x,y)\n"
#~ "@DESCRIPTION=BESSELK liefert die Neumann-, Weber- oder Bessel-Funktion.\n"
#~ "\n"
#~ "@x ist die Stelle, an der die Funktion ausgewertet wird und @y die "
#~ "Reihenfolge der Bessel-Funktion.\n"
#~ "\n"
#~ "* Falls @y keine Ganzzahl ist, werden die Nachkommastellen "
#~ "abgeschnitten.\n"
#~ "* Falls @x oder @y nicht-numerisch ist, liefert BESSELK einen #WERT!-"
#~ "Fehler.\n"
#~ "* Falls @y < 0 ist, liefert BESSELK einen #ZAHL!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BESSELK(3,9) liefert 397.95880.\n"
#~ "\n"
#~ "@SEEALSO=BESSELI,BESSELJ,BESSELY"

#~ msgid ""
#~ "@FUNCTION=BESSELJ\n"
#~ "@SYNTAX=BESSELJ(x,y)\n"
#~ "@DESCRIPTION=BESSELJ function returns the Bessel function with @x is "
#~ "where the function is evaluated. @y is the order of the Bessel function, "
#~ "if non-integer it is truncated.\n"
#~ "\n"
#~ "* If @x or @y are not numeric a #VALUE! error is returned.\n"
#~ "* If @y < 0 a #NUM! error is returned.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BESSELJ(0.89,3) equals 0.013974004.\n"
#~ "\n"
#~ "@SEEALSO=BESSELI,BESSELK,BESSELY"
#~ msgstr ""
#~ "@FUNCTION=BESSELJ\n"
#~ "@SYNTAX=BESSELJ(x,y)\n"
#~ "@DESCRIPTION=BESSELJ liefert die Bessel-Funktion.\n"
#~ "\n"
#~ "@x ist die Stelle, an der die Funktion ausgewertet wird und @y die "
#~ "Reihenfolge der Bessel-Funktion.\n"
#~ "\n"
#~ "* Falls @y keine Ganzzahl ist, werden die Nachkommastellen "
#~ "abgeschnitten.\n"
#~ "* Falls @x oder @y nicht-numerisch ist, liefert BESSELJ einen #WERT!-"
#~ "Fehler.\n"
#~ "* Falls @y < 0 ist, liefert BESSELJ einen #ZAHL!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BESSELJ(0.89,3) liefert 0.013974004.\n"
#~ "\n"
#~ "@SEEALSO=BESSELI,BESSELK,BESSELY"

#~ msgid ""
#~ "@FUNCTION=BESSELY\n"
#~ "@SYNTAX=BESSELY(x,y)\n"
#~ "@DESCRIPTION=BESSELY function returns the Neumann, Weber or Bessel "
#~ "function.\n"
#~ "\n"
#~ "@x is where the function is evaluated. @y is the order of the Bessel "
#~ "function, if non-integer it is truncated.\n"
#~ "\n"
#~ "* If @x or @y are not numeric a #VALUE! error is returned.\n"
#~ "* If @y < 0 a #NUM! error is returned.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BESSELY(4,2) equals 0.215903595.\n"
#~ "\n"
#~ "@SEEALSO=BESSELI,BESSELJ,BESSELK"
#~ msgstr ""
#~ "@FUNCTION=BESSELY\n"
#~ "@SYNTAX=BESSELY(x,y)\n"
#~ "@DESCRIPTION=BESSELY liefert die Neumann-, Weber- oder Bessel-Funktion.\n"
#~ "\n"
#~ "@x ist die Stelle, an der die Funktion ausgewertet wird und @y die "
#~ "Reihenfolge der Bessel-Funktion.\n"
#~ "\n"
#~ "* Falls @y keine Ganzzahl ist, werden die Nachkommastellen "
#~ "abgeschnitten.\n"
#~ "* Falls @x oder @y nicht-numerisch ist, liefert BESSELY einen #WERT!-"
#~ "Fehler.\n"
#~ "* Falls @y < 0 ist, liefert BESSELY einen #ZAHL!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BESSELY(4,2) liefert 0.215903595.\n"
#~ "\n"
#~ "@SEEALSO=BESSELI,BESSELJ,BESSELK"

#~ msgid ""
#~ "@FUNCTION=ERF\n"
#~ "@SYNTAX=ERF([lower limit,]upper_limit)\n"
#~ "@DESCRIPTION=ERF returns the error function.  With a single argument ERF "
#~ "returns the error function, defined as\n"
#~ "\n"
#~ "\terf(x) = 2/sqrt(pi)* integral from 0 to x of exp(-t*t) dt.\n"
#~ "\n"
#~ "If two arguments are supplied, they are the lower and upper limits of the "
#~ "integral.\n"
#~ "\n"
#~ "* If either @lower_limit or @upper_limit is not numeric a #VALUE! error "
#~ "is returned.\n"
#~ "* This function is upward-compatible with that in Excel. (If two "
#~ "arguments are supplied, Excel will not allow either to be negative.)\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ERF(0.4) equals 0.428392355.\n"
#~ "ERF(1.6448536269515/SQRT(2)) equals 0.90.\n"
#~ "\n"
#~ "The second example shows that a random variable with a normal "
#~ "distribution has a 90 percent chance of falling within approximately "
#~ "1.645 standard deviations of the mean.\n"
#~ "@SEEALSO=ERFC"
#~ msgstr ""
#~ "@FUNCTION=FEHLERF\n"
#~ "@SYNTAX=FEHLERF([limes_inferior,]limes_superior)\n"
#~ "@DESCRIPTION=FEHLERF liefert die Fehlerfunktion, die definiert ist als:\n"
#~ "\n"
#~ "\terf(x) = 2/sqrt(pi)* integral von 0 nach x von exp(-t*t) dt.\n"
#~ "\n"
#~ "Falls zwei Argumente übergegeben werden, werden sie als limes inferior "
#~ "und superior des Integrals verwendet.\n"
#~ "\n"
#~ "* Falls @limes_inferior oder @limes_superior nicht numerisch sind, "
#~ "liefert FEHLERF einen #WERT!-Fehler.\n"
#~ "* Diese Version ist abwärts-kompatibel zu Excel. (Falls zwei Argumente "
#~ "übergeben werden, darf bei Excel keines der beiden negativ sein.)\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ERF(0.4) liefert 0.428392355.\n"
#~ "ERF(1.6448536269515/SQRT(2)) liefert 0.90.\n"
#~ "\n"
#~ "Das zweite Beispiel zeigt, dass eine zufällige Variable mit einer "
#~ "Gauß'schen Verteilung eine Chance von 90% hat innerhalb einer geschätzten "
#~ "Standardabweichung von 1.645 um den Mittelwert zu sein.\n"
#~ "@SEEALSO=FEHLERFK"

#~ msgid ""
#~ "@FUNCTION=ERFC\n"
#~ "@SYNTAX=ERFC(x)\n"
#~ "@DESCRIPTION=ERFC function returns the complementary error function, "
#~ "defined as\n"
#~ "\n"
#~ "\t1 - erf(x).\n"
#~ "\n"
#~ "erfc(x) is calculated more accurately than 1 - erf(x) for arguments "
#~ "larger than about 0.5.\n"
#~ "\n"
#~ "* If @x is not numeric a #VALUE! error is returned.  \n"
#~ "@EXAMPLES=\n"
#~ "ERFC(6) equals 2.15197367e-17.\n"
#~ "\n"
#~ "@SEEALSO=ERF"
#~ msgstr ""
#~ "@FUNCTION=FEHLERFK\n"
#~ "@SYNTAX=FEHLERFK(x)\n"
#~ "@DESCRIPTION=FEHLERFK liefert die komplementäre Fehlerfunktion, die "
#~ "definiert ist als:\n"
#~ "\n"
#~ "\t1 - erf(x).\n"
#~ "\n"
#~ "erfc(x) wird für Argumente, die ungefähr größer als 0.5 sind, exakter als "
#~ "1 - erf(x) berechnet.\n"
#~ "\n"
#~ "* Falls @x nicht numerisch ist, liefert FEHLERFK einen #WERT!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ERFC(6) liefert 2.15197367e-17.\n"
#~ "\n"
#~ "@SEEALSO=FEHLERF"

#~ msgid ""
#~ "@FUNCTION=DELTA\n"
#~ "@SYNTAX=DELTA(x[,y])\n"
#~ "@DESCRIPTION=DELTA function tests for numerical equivalence of two "
#~ "arguments, returning 1 in case of equality.\n"
#~ "\n"
#~ "* @y is optional, and defaults to 0.\n"
#~ "* If either argument is non-numeric returns a #VALUE! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DELTA(42.99,43) equals 0.\n"
#~ "\n"
#~ "@SEEALSO=EXACT,GESTEP"
#~ msgstr ""
#~ "@FUNCTION=DELTA\n"
#~ "@SYNTAX=DELTA(x[,y])\n"
#~ "@DESCRIPTION=DELTA überprüft die beiden Argumente @x und @y auf "
#~ "numerische Äquivalenz, wobei im Falle der Gleichwertigkeit 1 geliefert "
#~ "wird.\n"
#~ "\n"
#~ "* @y ist optional, und die Vorgabe ist 0.\n"
#~ "* Falls eines der Argumente keine Zahl ist, liefert DELTA einen #WERT!-"
#~ "Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DELTA(42.99,43) liefert 0.\n"
#~ "\n"
#~ "@SEEALSO=IDENTISCH,GESTEP"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=GESTEP\n"
#~ "@SYNTAX=GESTEP(x[,y])\n"
#~ "@DESCRIPTION=GESTEP function tests if @x is >= @y, returning 1 if it is "
#~ "so, and 0 otherwise. @y is optional, and defaults to 0.\n"
#~ "\n"
#~ "* If either argument is non-numeric returns a #VALUE! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "@EXAMPLES=\n"
#~ "GESTEP(5,4) equals 1.\n"
#~ "\n"
#~ "@SEEALSO=DELTA"
#~ msgstr ""
#~ "@FUNCTION=GESTEP\n"
#~ "@SYNTAX=GESTEP(x[,y])\n"
#~ "@DESCRIPTION=GESTEP vergleicht @x und @y und liefert 1, falls @x >= @y, "
#~ "andernfalls 0. @y ist optional und die Vorgabe ist 0.\n"
#~ "\n"
#~ "* Falls eines der Argumente nicht numerisch ist, liefert GESTEP einen "
#~ "#WERT!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "@EXAMPLES=\n"
#~ "GESTEP(5,4) liefert 1.\n"
#~ "\n"
#~ "@SEEALSO=DELTA"

#~ msgid ""
#~ "@FUNCTION=ACCRINT\n"
#~ "@SYNTAX=ACCRINT(issue,first_interest,settlement,rate,par,frequency[,"
#~ "basis])\n"
#~ "@DESCRIPTION=ACCRINT calculates the accrued interest for a security that "
#~ "pays periodic interest.\n"
#~ "\n"
#~ "@issue is the issue date of the security.  @first_interest is the first "
#~ "interest date of the security.  @settlement is the settlement date of the "
#~ "security.  The settlement date is always after the issue date (the date "
#~ "when the security is bought). @rate is the annual rate of the security "
#~ "and @par is the par value of the security. @frequency is the number of "
#~ "coupon payments per year.\n"
#~ "\n"
#~ "Allowed frequencies are:\n"
#~ "  1 = annual,\n"
#~ "  2 = semi,\n"
#~ "  4 = quarterly.\n"
#~ "\n"
#~ "@basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @issue date, @first_interest date, or @settlement date is not valid, "
#~ "ACCRINT returns #NUM! error.\n"
#~ "* The dates must be @issue < @first_interest < @settlement, or ACCRINT "
#~ "returns #NUM! error.\n"
#~ "* If @rate <= 0 or @par <= 0 , ACCRINT returns #NUM! error.\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis < 0 or @basis > 4, ACCRINT returns #NUM! error.\n"
#~ "* If @issue date is after @settlement date or they are the same, ACCRINT "
#~ "returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=ACCRINTM"
#~ msgstr ""
#~ "@FUNCTION=ERTRAG\n"
#~ "@SYNTAX=ERTRAG(settle,mat,rate,price,redemption_price,Häufigkeit[,"
#~ "Basis])\n"
#~ "@DESCRIPTION=ERTRAG liefert den Ertrag auf eine Sicherheit, die einen "
#~ "periodischen Zins abwirft.\n"
#~ "\n"
#~ "@Häufigkeit ist die Anzahl der Kupon-Zahlungen pro Jahr. Zulässige Werte "
#~ "sind: 1 = jährlich, 2 = halbjährlich, 4 = vierteljährlich.\n"
#~ "@Basis ist der Typ des zur Tagesberechnung verwendeten Systems:\n"
#~ "\n"
#~ "  0  MSRB 30/360 (MSRB Regel G33 (e))\n"
#~ "  1  Tatsächliche Tage/Tatsächliche Tage\n"
#~ "  2  Tatsächliche Tage/360\n"
#~ "  3  Tatsächliche Tage/365\n"
#~ "  4  Europäisch 30/360\n"
#~ "  5  Europäisch + 30/360\n"
#~ "\n"
#~ "* Falls @Häufigkeit weder 1, noch 2, 4 oder ungültig ist, liefert ERTRAG "
#~ "einen #ZAHL!-Fehler.\n"
#~ "* Falls @Basis nicht übergeben wird, wird MSRB 30/360 angenommen.\n"
#~ "* Falls @Basis nicht zwischen 0 und 4 liegt, liefert ERTRAG einen #ZAHL!-"
#~ "Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=ACCRINTM\n"
#~ "@SYNTAX=ACCRINTM(issue,maturity,rate[,par,basis])\n"
#~ "@DESCRIPTION=ACCRINTM calculates and returns the accrued interest for a "
#~ "security from @issue to @maturity date.\n"
#~ "\n"
#~ "@issue is the issue date of the security.  @maturity is the maturity date "
#~ "of the security.  @rate is the annual rate of the security and @par is "
#~ "the par value of the security. If you omit @par, ACCRINTM applies $1,000 "
#~ "instead.  @basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @issue date or @maturity date is not valid, ACCRINTM returns #NUM! "
#~ "error.\n"
#~ "* If @rate <= 0 or @par <= 0, ACCRINTM returns #NUM! error.\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis < 0 or @basis > 4, ACCRINTM returns #NUM! error.\n"
#~ "* If @issue date is after @maturity date or they are the same, ACCRINTM "
#~ "returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=ACCRINT"
#~ msgstr ""
#~ "@FUNCTION=ERTRAG\n"
#~ "@SYNTAX=ERTRAG(settle,mat,rate,price,redemption_price,Häufigkeit[,"
#~ "Basis])\n"
#~ "@DESCRIPTION=ERTRAG liefert den Ertrag auf eine Sicherheit, die einen "
#~ "periodischen Zins abwirft.\n"
#~ "\n"
#~ "@Häufigkeit ist die Anzahl der Kupon-Zahlungen pro Jahr. Zulässige Werte "
#~ "sind: 1 = jährlich, 2 = halbjährlich, 4 = vierteljährlich.\n"
#~ "@Basis ist der Typ des zur Tagesberechnung verwendeten Systems:\n"
#~ "\n"
#~ "  0  MSRB 30/360 (MSRB Regel G33 (e))\n"
#~ "  1  Tatsächliche Tage/Tatsächliche Tage\n"
#~ "  2  Tatsächliche Tage/360\n"
#~ "  3  Tatsächliche Tage/365\n"
#~ "  4  Europäisch 30/360\n"
#~ "  5  Europäisch + 30/360\n"
#~ "\n"
#~ "* Falls @Häufigkeit weder 1, noch 2, 4 oder ungültig ist, liefert ERTRAG "
#~ "einen #ZAHL!-Fehler.\n"
#~ "* Falls @Basis nicht übergeben wird, wird MSRB 30/360 angenommen.\n"
#~ "* Falls @Basis nicht zwischen 0 und 4 liegt, liefert ERTRAG einen #ZAHL!-"
#~ "Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=INTRATE\n"
#~ "@SYNTAX=INTRATE(settlement,maturity,investment,redemption[,basis])\n"
#~ "@DESCRIPTION=INTRATE calculates and returns the interest rate of a fully "
#~ "vested security.\n"
#~ "\n"
#~ "@settlement is the settlement date of the security.  @maturity is the "
#~ "maturity date of the security. @investment is the price of the security "
#~ "paid at @settlement date and @redemption is the amount to be received at "
#~ "@maturity date.\n"
#~ "\n"
#~ "@basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @settlement date or @maturity date is not valid, INTRATE returns "
#~ "#NUM! error.\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis < 0 or @basis > 4, INTRATE returns #NUM! error.\n"
#~ "* If @settlement date is after @maturity date or they are the same, "
#~ "INTRATE returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "If you had a bond with a settlement date of April 15, 2000, maturity date "
#~ "September 30, 2000, investment of $100,000, redemption value $103,525, "
#~ "using the actual/actual basis, the bond discount rate is:\n"
#~ "=INTRATE(36631, 36799, 100000, 103525, 1) which equals 0.0648 or 6.48%\n"
#~ "@SEEALSO=RECEIVED, DATE"
#~ msgstr ""
#~ "@FUNCTION=ZINSSATZ\n"
#~ "@SYNTAX=ZINSSATZ(Abrechnungsdatum,Fälligkeitsdatum,Investition,Auszahlung"
#~ "[,Basis])\n"
#~ "@DESCRIPTION=ZINSSATZ berechnet den Zinssatz eines vollständig erworbenen "
#~ "Wertpapiers.\n"
#~ "\n"
#~ "@Abrechnungsdatum ist das Abrechnungsdatum und @Fälligkeitsdatum das "
#~ "Fälligkeitsdatum des Wertpapiers. @Investition ist der am "
#~ "@Abrechnungsdatum für das Wertpapier gezahlte Preis und @Auszahlung das "
#~ "voraussichtliche am @Fälligkeitsdatum Kapital.\n"
#~ "\n"
#~ "@Basis ist der Typ des zur Tagesberechnung verwendeten Systems:\n"
#~ "\n"
#~ "  0  MSRB 30/360 (MSRB Regel G33 (e))\n"
#~ "  1  Tatsächliche Tage/Tatsächliche Tage\n"
#~ "  2  Tatsächliche Tage/360\n"
#~ "  3  Tatsächliche Tage/365\n"
#~ "  4  Europäisch 30/360\n"
#~ "  5  Europäisch + 30/360\n"
#~ "\n"
#~ "* Falls @Abrechnungsdatum oder @Fälligkeitsdatum nicht gültig ist, "
#~ "liefert ZINSSATZ einen #ZAHL!-Fehler.\n"
#~ "* Falls @Abrechnungsdatum nach @Fälligkeitsdatum liegt oder beide den "
#~ "selben Wert haben, liefert ZINSSATZ einen #ZAHL!-Fehler.\n"
#~ "* Falls @Basis nicht übergeben wird, wird MSRB 30/360 angenommen.\n"
#~ "* Falls @Basis < 0 oder > 4 ist, liefert KUPTAGE einen #ZAHL!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "If you had a bond with a settlement date of April 15, 2000, maturity date "
#~ "September 30, 2000, investment of $100,000, redemption value $103,525, "
#~ "using the actual/actual basis, the bond discount rate is:\n"
#~ "=ZINSSATZ(36631, 36799, 100000, 103525, 1) which equals 0.0648 or 6.48%\n"
#~ "@SEEALSO=RECEIVED, DATE"

#~ msgid ""
#~ "@FUNCTION=RECEIVED\n"
#~ "@SYNTAX=RECEIVED(settlement,maturity,investment,rate[,basis])\n"
#~ "@DESCRIPTION=RECEIVED calculates and returns the amount to be received at "
#~ "maturity date for a security bond.\n"
#~ "\n"
#~ "@settlement is the settlement date of the security.  @maturity is the "
#~ "maturity date of the security.  The amount of investment is specified in "
#~ "@investment.  @rate is the security's discount rate.\n"
#~ "\n"
#~ "@basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @settlement date or @maturity date is not valid, RECEIVED returns "
#~ "#NUM! error.\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis < 0 or @basis > 4, RECEIVED returns #NUM! error.\n"
#~ "* If @settlement date is after @maturity date or they are the same, "
#~ "RECEIVED returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=INTRATE"
#~ msgstr ""
#~ "@FUNCTION=ERTRAG\n"
#~ "@SYNTAX=ERTRAG(settle,mat,rate,price,redemption_price,Häufigkeit[,"
#~ "Basis])\n"
#~ "@DESCRIPTION=ERTRAG liefert den Ertrag auf eine Sicherheit, die einen "
#~ "periodischen Zins abwirft.\n"
#~ "\n"
#~ "@Häufigkeit ist die Anzahl der Kupon-Zahlungen pro Jahr. Zulässige Werte "
#~ "sind: 1 = jährlich, 2 = halbjährlich, 4 = vierteljährlich.\n"
#~ "@Basis ist der Typ des zur Tagesberechnung verwendeten Systems:\n"
#~ "\n"
#~ "  0  MSRB 30/360 (MSRB Regel G33 (e))\n"
#~ "  1  Tatsächliche Tage/Tatsächliche Tage\n"
#~ "  2  Tatsächliche Tage/360\n"
#~ "  3  Tatsächliche Tage/365\n"
#~ "  4  Europäisch 30/360\n"
#~ "  5  Europäisch + 30/360\n"
#~ "\n"
#~ "* Falls @Häufigkeit weder 1, noch 2, 4 oder ungültig ist, liefert ERTRAG "
#~ "einen #ZAHL!-Fehler.\n"
#~ "* Falls @Basis nicht übergeben wird, wird MSRB 30/360 angenommen.\n"
#~ "* Falls @Basis nicht zwischen 0 und 4 liegt, liefert ERTRAG einen #ZAHL!-"
#~ "Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=PRICEDISC\n"
#~ "@SYNTAX=PRICEDISC(settlement,maturity,discount,redemption[,basis])\n"
#~ "@DESCRIPTION=PRICEDISC calculates and returns the price per $100 face "
#~ "value of a security bond.  The security does not pay interest at "
#~ "maturity.\n"
#~ "\n"
#~ "@settlement is the settlement date of the security. @maturity is the "
#~ "maturity date of the security.  @discount is the rate for which the "
#~ "security is discounted.  @redemption is the amount to be received on "
#~ "@maturity date.\n"
#~ "\n"
#~ "@basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @settlement date or @maturity date is not valid, PRICEDISC returns "
#~ "#NUM! error.\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis < 0 or @basis > 4, PRICEDISC returns #NUM! error.\n"
#~ "* If @settlement date is after @maturity date or they are the same, "
#~ "PRICEDISC returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=PRICEMAT"
#~ msgstr ""
#~ "@FUNCTION=ERTRAG\n"
#~ "@SYNTAX=ERTRAG(settle,mat,rate,price,redemption_price,Häufigkeit[,"
#~ "Basis])\n"
#~ "@DESCRIPTION=ERTRAG liefert den Ertrag auf eine Sicherheit, die einen "
#~ "periodischen Zins abwirft.\n"
#~ "\n"
#~ "@Häufigkeit ist die Anzahl der Kupon-Zahlungen pro Jahr. Zulässige Werte "
#~ "sind: 1 = jährlich, 2 = halbjährlich, 4 = vierteljährlich.\n"
#~ "@Basis ist der Typ des zur Tagesberechnung verwendeten Systems:\n"
#~ "\n"
#~ "  0  MSRB 30/360 (MSRB Regel G33 (e))\n"
#~ "  1  Tatsächliche Tage/Tatsächliche Tage\n"
#~ "  2  Tatsächliche Tage/360\n"
#~ "  3  Tatsächliche Tage/365\n"
#~ "  4  Europäisch 30/360\n"
#~ "  5  Europäisch + 30/360\n"
#~ "\n"
#~ "* Falls @Häufigkeit weder 1, noch 2, 4 oder ungültig ist, liefert ERTRAG "
#~ "einen #ZAHL!-Fehler.\n"
#~ "* Falls @Basis nicht übergeben wird, wird MSRB 30/360 angenommen.\n"
#~ "* Falls @Basis nicht zwischen 0 und 4 liegt, liefert ERTRAG einen #ZAHL!-"
#~ "Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=PRICEMAT\n"
#~ "@SYNTAX=PRICEMAT(settlement,maturity,issue,rate,yield[,basis])\n"
#~ "@DESCRIPTION=PRICEMAT calculates and returns the price per $100 face "
#~ "value of a security.  The security pays interest at maturity.\n"
#~ "\n"
#~ "@settlement is the settlement date of the security.  @maturity is the "
#~ "maturity date of the security.  @issue is the issue date of the "
#~ "security.  @rate is the discount rate of the security. @yield is the "
#~ "annual yield of the security. @basis is the type of day counting system "
#~ "you want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @settlement date or @maturity date is not valid, PRICEMAT returns "
#~ "#NUM! error.\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis < 0 or @basis > 4, PRICEMAT returns #NUM! error.\n"
#~ "* If @settlement date is after @maturity date or they are the same, "
#~ "PRICEMAT returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=PRICEDISC"
#~ msgstr ""
#~ "@FUNCTION=ERTRAG\n"
#~ "@SYNTAX=ERTRAG(settle,mat,rate,price,redemption_price,Häufigkeit[,"
#~ "Basis])\n"
#~ "@DESCRIPTION=ERTRAG liefert den Ertrag auf eine Sicherheit, die einen "
#~ "periodischen Zins abwirft.\n"
#~ "\n"
#~ "@Häufigkeit ist die Anzahl der Kupon-Zahlungen pro Jahr. Zulässige Werte "
#~ "sind: 1 = jährlich, 2 = halbjährlich, 4 = vierteljährlich.\n"
#~ "@Basis ist der Typ des zur Tagesberechnung verwendeten Systems:\n"
#~ "\n"
#~ "  0  MSRB 30/360 (MSRB Regel G33 (e))\n"
#~ "  1  Tatsächliche Tage/Tatsächliche Tage\n"
#~ "  2  Tatsächliche Tage/360\n"
#~ "  3  Tatsächliche Tage/365\n"
#~ "  4  Europäisch 30/360\n"
#~ "  5  Europäisch + 30/360\n"
#~ "\n"
#~ "* Falls @Häufigkeit weder 1, noch 2, 4 oder ungültig ist, liefert ERTRAG "
#~ "einen #ZAHL!-Fehler.\n"
#~ "* Falls @Basis nicht übergeben wird, wird MSRB 30/360 angenommen.\n"
#~ "* Falls @Basis nicht zwischen 0 und 4 liegt, liefert ERTRAG einen #ZAHL!-"
#~ "Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=DISC\n"
#~ "@SYNTAX=DISC(settlement,maturity,par,redemption[,basis])\n"
#~ "@DESCRIPTION=DISC calculates and returns the discount rate for a "
#~ "security. @settlement is the settlement date of the security.\n"
#~ "\n"
#~ "@maturity is the maturity date of the security.  @par is the price per "
#~ "$100 face value of the security.  @redemption is the redemption value per "
#~ "$100 face value of the security.\n"
#~ "\n"
#~ "@basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @settlement date or @maturity date is not valid, DISC returns #NUM! "
#~ "error.\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis < 0 or @basis > 4, DISC returns #NUM! error.\n"
#~ "* If @settlement date is after @maturity date or they are the same, DISC "
#~ "returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=ERTRAG\n"
#~ "@SYNTAX=ERTRAG(settle,mat,rate,price,redemption_price,Häufigkeit[,"
#~ "Basis])\n"
#~ "@DESCRIPTION=ERTRAG liefert den Ertrag auf eine Sicherheit, die einen "
#~ "periodischen Zins abwirft.\n"
#~ "\n"
#~ "@Häufigkeit ist die Anzahl der Kupon-Zahlungen pro Jahr. Zulässige Werte "
#~ "sind: 1 = jährlich, 2 = halbjährlich, 4 = vierteljährlich.\n"
#~ "@Basis ist der Typ des zur Tagesberechnung verwendeten Systems:\n"
#~ "\n"
#~ "  0  MSRB 30/360 (MSRB Regel G33 (e))\n"
#~ "  1  Tatsächliche Tage/Tatsächliche Tage\n"
#~ "  2  Tatsächliche Tage/360\n"
#~ "  3  Tatsächliche Tage/365\n"
#~ "  4  Europäisch 30/360\n"
#~ "  5  Europäisch + 30/360\n"
#~ "\n"
#~ "* Falls @Häufigkeit weder 1, noch 2, 4 oder ungültig ist, liefert ERTRAG "
#~ "einen #ZAHL!-Fehler.\n"
#~ "* Falls @Basis nicht übergeben wird, wird MSRB 30/360 angenommen.\n"
#~ "* Falls @Basis nicht zwischen 0 und 4 liegt, liefert ERTRAG einen #ZAHL!-"
#~ "Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=EFFECT\n"
#~ "@SYNTAX=EFFECT(r,nper)\n"
#~ "@DESCRIPTION=EFFECT calculates the effective interest rate from a given "
#~ "nominal rate.\n"
#~ "\n"
#~ "Effective interest rate is calculated using this formula:\n"
#~ "\n"
#~ "    (1 + @r / @nper) ^ @nper - 1\n"
#~ "\n"
#~ "where:\n"
#~ "\n"
#~ "@r = nominal interest rate (stated in yearly terms)\n"
#~ "@nper = number of periods used for compounding\n"
#~ "\n"
#~ "* If @rate < 0, EFFECT returns #NUM! error.\n"
#~ "* If @nper <= 0, EFFECT returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "For example credit cards will list an APR (annual percentage rate) which "
#~ "is a nominal interest rate.\n"
#~ "For example if you wanted to find out how much you are actually paying "
#~ "interest on your credit card that states an APR of 19% that is compounded "
#~ "monthly you would type in:\n"
#~ "=EFFECT(.19,12) and you would get .2075 or 20.75%. That is the effective "
#~ "percentage you will pay on your loan.\n"
#~ "@SEEALSO=NOMINAL"
#~ msgstr ""
#~ "@FUNCTION=EFFEKTIV\n"
#~ "@SYNTAX=EFFEKTIV(Zinssatz,Periodenanzahl)\n"
#~ "@DESCRIPTION=EFFEKTIV liefert den Effektivzinssatz eines angegebenen "
#~ "nominalen Zinssatzes.\n"
#~ "\n"
#~ "Der Effektivzinssatz mit folgender Formel berechnet:\n"
#~ "\n"
#~ "    (1 + @Zinssatz / @Periodenanzahl) ^ @Periodenanzahl - 1\n"
#~ "\n"
#~ "wobei:\n"
#~ "\n"
#~ "@r = nominal interest rate (stated in yearly terms)\n"
#~ "@Periodenanzahl = number of periods used for compounding\n"
#~ "\n"
#~ "* Falls @Zinssatz < 0 ist, liefert EFFEKTIV einen #ZAHL!-Fehler.\n"
#~ "* Falls @Periodenanzahl <= 0 ist, liefert EFFEKTIV einen #ZAHL!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Kreditkarten verzeichnen eine jährliche Gesamtbelastung, die ein "
#~ "nominaler Zinssatz ist.\n"
#~ "Wollen Sie beispielsweise herausfinden, wie viele Zinsen Sie für Ihre "
#~ "Kreditkarte mit einer jährlichen Gesamtbelastung von 19%, die monatlich "
#~ "verzinst wird, zahlen, so müssen Sie folgendes eingeben:\n"
#~ "=EFFEKTIV(.19,12)\n"
#~ "liefert .2075 oder 20.75%. Dies ist der effektive Anteil, den Sie auf "
#~ "Ihre Anleihe Zahlen müssen.\n"
#~ "@SEEALSO=NOMINAL"

#~ msgid ""
#~ "@FUNCTION=NOMINAL\n"
#~ "@SYNTAX=NOMINAL(r,nper)\n"
#~ "@DESCRIPTION=NOMINAL calculates the nominal interest rate from a given "
#~ "effective rate.\n"
#~ "\n"
#~ "Nominal interest rate is given by a formula:\n"
#~ "\n"
#~ "@nper * (( 1 + @r ) ^ (1 / @nper) - 1 )\n"
#~ "where:\n"
#~ "\n"
#~ "@r = effective interest rate\n"
#~ "@nper = number of periods used for compounding\n"
#~ "\n"
#~ "* If @rate < 0, NOMINAL returns #NUM! error.\n"
#~ "* If @nper <= 0, NOMINAL returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=EFFECT"
#~ msgstr ""
#~ "@FUNCTION=NOMINAL\n"
#~ "@SYNTAX=NOMINAL(Zinssatz,Periodenanzahl)\n"
#~ "@DESCRIPTION=NOMINAL liefert den nominalen Zinssatz einer angegebenen "
#~ "Effektivverzinsung.\n"
#~ "\n"
#~ "Der nominale Zinssatz wird mit folgender Formel berechnet:\n"
#~ "\n"
#~ "@Periodenanzahl * (( 1 + @Zinssatz ) ^ (1 / @Periodenanzahl) - 1 )\n"
#~ "\n"
#~ "wobei:\n"
#~ "\n"
#~ "@Zinssatz = Effektivverzinsung\n"
#~ "@Periodenanzahl = number of periods used for compounding\n"
#~ "\n"
#~ "* Falls @Zinssatz < 0 ist, liefert NOMINAL einen #ZAHL!-Fehler.\n"
#~ "* Falls @Periodenanzahl <= 0 ist, liefert NOMINAL einen #ZAHL!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=EFFEKTIV"

#~ msgid ""
#~ "@FUNCTION=ISPMT\n"
#~ "@SYNTAX=ISPMT(rate,per,nper,pv)\n"
#~ "@DESCRIPTION=ISPMT function returns the interest paid on a given period.\n"
#~ "\n"
#~ "* If @per < 1 or @per > @nper, ISPMT returns #NUM! error. \n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=PV"
#~ msgstr ""
#~ "@FUNCTION=ZINSZAHLUNG\n"
#~ "@SYNTAX=ZINSZAHLUNG(Zins,Per,Periodenanzahl,BW)\n"
#~ "@DESCRIPTION=ZINSZAHLUNG liefert den in einer bestimmten Periode "
#~ "gezahlten Zins.\n"
#~ "\n"
#~ "* Falls @Per < 1 oder @Per > @Periodenanzahl, liefert ZINSZAHLUNG einen "
#~ "#ZAHL!-Fehler.\n"
#~ "@EXAMPLES=\n"
#~ "PV\n"
#~ "@SEEALSO=BW"

#~ msgid ""
#~ "@FUNCTION=DOLLARDE\n"
#~ "@SYNTAX=DOLLARDE(fractional_dollar,fraction)\n"
#~ "@DESCRIPTION=DOLLARDE converts a dollar price expressed as a fraction "
#~ "into a dollar price expressed as a decimal number.\n"
#~ "\n"
#~ "@fractional_dollar is the fractional number to be converted. @fraction is "
#~ "the denominator of the fraction.\n"
#~ "\n"
#~ "* If @fraction is non-integer it is truncated.\n"
#~ "* If @fraction <= 0, DOLLARDE returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=DOLLARFR"
#~ msgstr ""
#~ "@FUNCTION=DOLLARDEZ\n"
#~ "@SYNTAX=DOLLARDEZ(Dollar_gebrochen,Bruch)\n"
#~ "@DESCRIPTION=DOLLARDEZ konvertiert einen als Bruch in einen als "
#~ "Dezimalzahl ausgedrückten Dollarpreis.\n"
#~ "\n"
#~ "@Dollar_gebrochen ist die zu konvertierende Bruchzahl, @Bruch der Nenner "
#~ "des Bruches.\n"
#~ "\n"
#~ "* Falls @Bruch keine Ganzzahl ist, werden die Nachkommastellen "
#~ "abgeschnitten.\n"
#~ "* Falls @Bruch <= 0 ist, liefert DOLLARDEZ einen #ZAHL!-Fehler.\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=DOLLARBRUCH"

#~ msgid ""
#~ "@FUNCTION=DOLLARFR\n"
#~ "@SYNTAX=DOLLARFR(decimal_dollar,fraction)\n"
#~ "@DESCRIPTION=DOLLARFR converts a decimal dollar price into a dollar price "
#~ "expressed as a fraction.\n"
#~ "\n"
#~ "* If @fraction is non-integer it is truncated.\n"
#~ "* If @fraction <= 0, DOLLARFR returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=DOLLARDE"
#~ msgstr ""
#~ "@FUNCTION=DOLLARBRUCH\n"
#~ "@SYNTAX=DOLLARBRUCH(Dollar_dezimal,Bruch)\n"
#~ "@DESCRIPTION=DOLLARBRUCH konvertiert einen als Bruch in einen als "
#~ "Dezimalzahl ausgedrückten Dollarpreis.\n"
#~ "\n"
#~ "* Falls @Bruch keine Ganzzahl ist, werden die Nachkommastellen "
#~ "abgeschnitten.\n"
#~ "* Falls @Bruch <= 0 ist, liefert DOLLARBRUCH einen #ZAHL!-Fehler.\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=DOLLARDEZ"

#~ msgid ""
#~ "@FUNCTION=MIRR\n"
#~ "@SYNTAX=MIRR(values,finance_rate,reinvest_rate)\n"
#~ "@DESCRIPTION=MIRR function returns the modified internal rate of return "
#~ "for a given periodic cash flow. \n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=NPV"
#~ msgstr ""
#~ "@FUNCTION=MIZS\n"
#~ "@SYNTAX=MIZS(Werte,Zins,Reinvestitionszins)\n"
#~ "@DESCRIPTION=MIZS liefert den modifizierten internen Zinssatz für einen "
#~ "angegebenen periodischen Zinsfluss.\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=NPV"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=RATE\n"
#~ "@SYNTAX=RATE(nper,pmt,pv[,fv,type,guess])\n"
#~ "@DESCRIPTION=RATE calculates the rate of an investment.\n"
#~ "\n"
#~ "* If @pmt is omitted it defaults to 0\n"
#~ "* If @nper <= 0, RATE returns #NUM! error.\n"
#~ "* If @type != 0 and @type != 1, RATE returns #VALUE! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=PV,FV"
#~ msgstr ""
#~ "@FUNCTION=ZINS\n"
#~ "@SYNTAX=ZINS(Periodenanzahl,pmt,pv[,fv,Type,guess])\n"
#~ "@DESCRIPTION=ZINS liefert den Zinssatz einer Investition.\n"
#~ "\n"
#~ "* Falls @Periodenanzahl <= 0 ist, liefert ZINS einen #ZAHL!-Fehler.\n"
#~ "* Falls @Typ != 0 und @type != 1 ist, liefert ZINS einen #WERT!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=PV,FV"

#~ msgid ""
#~ "@FUNCTION=PV\n"
#~ "@SYNTAX=PV(rate,nper,pmt[,fv,type])\n"
#~ "@DESCRIPTION=PV calculates the present value of an investment. @rate is "
#~ "the periodic interest rate, @nper is the number of periods used for "
#~ "compounding. @pmt is the payment made each period, @fv is the future "
#~ "value and @type is when the payment is made.\n"
#~ "\n"
#~ "* If @type = 1 then the payment is made at the beginning of the period.\n"
#~ "* If @type = 0 (or omitted) it is made at the end of each period.\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=FV"
#~ msgstr ""
#~ "@FUNCTION=AW\n"
#~ "@SYNTAX=AW(Zinssatz,Anzahl_Perioden,Zahlung[,ZW,type])\n"
#~ "@DESCRIPTION=AW liefert den aktuellen Wert einer Investition. @Zinssatz "
#~ "ist der periodische Zinssatz, @Anzahl_Perioden die zur Berechnung "
#~ "verwendete Anzahl der Perioden. @Zahlung ist die in jeder Periode "
#~ "geleistete Zahlung, @ZW der zukünftige Wert und @Typ gibt an, wann die "
#~ "Zahlung zu leisten ist.\n"
#~ "\n"
#~ "* Falls @Typ 1 ist, ist die Zahlung am Anfang jeder Periode zu leisten.\n"
#~ "* Falls @Typ 1 ist (oder nicht übergeben wird), ist die Zahlung am Ende "
#~ "jeder Periode zu leisten.\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=ZW"

#~ msgid ""
#~ "@FUNCTION=NPV\n"
#~ "@SYNTAX=NPV(rate,v1,v2,...)\n"
#~ "@DESCRIPTION=NPV calculates the net present value of an investment "
#~ "generating periodic payments.  @rate is the periodic interest rate and "
#~ "@v1, @v2, ... are the periodic payments.  If the schedule of the cash "
#~ "flows are not periodic use the XNPV function. \n"
#~ "@EXAMPLES=\n"
#~ "NPV(0.17,-10000,3340,2941,2493,3233,1732,2932) equals 186.30673.\n"
#~ "\n"
#~ "@SEEALSO=PV,XNPV"
#~ msgstr ""
#~ "@FUNCTION=AKTW\n"
#~ "@SYNTAX=AKTW(Zinssatz,v1,v2,...)\n"
#~ "@DESCRIPTION=AKTW berechnet den aktualisierten Wert einer Investition, "
#~ "die periodische Zahlungen generiert. @Zinssatz ist der periodische "
#~ "Zinssatz und @v1, @v2, ... die periodischen Zahlungen. Falls der "
#~ "Kapitalfluss nicht periodisch ist, müssen Sie die XNPV-Funktion "
#~ "verwenden.\n"
#~ "@EXAMPLES=\n"
#~ "AKTW(0.17,-10000,3340,2941,2493,3233,1732,2932) liefert 186.30673.\n"
#~ "\n"
#~ "@SEEALSO=AW,XAKTW"

#~ msgid ""
#~ "@FUNCTION=XNPV\n"
#~ "@SYNTAX=XNPV(rate,values,dates)\n"
#~ "@DESCRIPTION=XNPV calculates the net present value of an investment.  The "
#~ "schedule of the cash flows is given in @dates array.  The first date "
#~ "indicates the beginning of the payment schedule.  @rate is the interest "
#~ "rate and @values are the payments.\n"
#~ "\n"
#~ "* If @values and @dates contain unequal number of values, XNPV returns "
#~ "the #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=NPV,PV"
#~ msgstr ""
#~ "@FUNCTION=XAKTW\n"
#~ "@SYNTAX=XAKTW(Zinssatz,Werte,Data)\n"
#~ "@DESCRIPTION=XAKTW berechnet den aktualisierten Wert einer Investition. "
#~ "Das Feld @Data gibt die jeweiligen Daten des Geldflusses an, @Zinssatz "
#~ "ist der Zinssatz und @Werte sind die Zahlungen.\n"
#~ "\n"
#~ "* Falls @Werte und @Data eine unterschiedliche Werteanzahl enthalten, "
#~ "liefert XAKTW einen #ZAHL!-Fehler.\n"
#~ "\n"
#~ " @EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=AKTW,AW"

#~ msgid ""
#~ "@FUNCTION=FV\n"
#~ "@SYNTAX=FV(rate,nper,pmt[,pv,type])\n"
#~ "@DESCRIPTION=FV computes the future value of an investment. This is based "
#~ "on periodic, constant payments and a constant interest rate. The interest "
#~ "rate per period is @rate, @nper is the number of periods in an annuity, "
#~ "@pmt is the payment made each period, @pv is the present value and @type "
#~ "is when the payment is made.\n"
#~ "\n"
#~ "* If @type = 1 then the payment is made at the beginning of the period.\n"
#~ "* If @type = 0 it is made at the end of each period.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=PV,PMT,PPMT"
#~ msgstr ""
#~ "@FUNCTION=ZW\n"
#~ "@SYNTAX=ZW(rate,term,pmt,pv,type)\n"
#~ "@DESCRIPTION=ZW berechnet den zukünftigen Wert einer Investition auf "
#~ "Basis von periodisch konstanten Zahlungen und einem konstanten Zinssatz. "
#~ "@Zins ist der Zinssatz pro Periode, @Tern die Anzahl der Perioden in "
#~ "einer Annuität, @Zahlung die jede Periode geleistete Zahlung, @AW der "
#~ "aktuelle Wert und @Typ legt fest, wann die Zahlung zu leisten ist.\n"
#~ "\n"
#~ "* Falls @Typ 1 ist, ist die Zahlung am Anfang jeder Periode zu leisten.\n"
#~ "* Falls @Typ 1 ist (oder nicht übergeben wird), ist die Zahlung am Ende "
#~ "jeder Periode zu leisten.\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=AW,ZAHLUNG,PPMT"

#~ msgid ""
#~ "@FUNCTION=PMT\n"
#~ "@SYNTAX=PMT(rate,nper,pv[,fv,type])\n"
#~ "@DESCRIPTION=PMT returns the amount of payment for a loan based on a "
#~ "constant interest rate and constant payments (each payment is equal "
#~ "amount).\n"
#~ "\n"
#~ "@rate is the constant interest rate.\n"
#~ "@nper is the overall number of payments.\n"
#~ "@pv is the present value.\n"
#~ "@fv is the future value.\n"
#~ "@type is the type of the payment: 0 means at the end of the period and 1 "
#~ "means at the beginning of the period.\n"
#~ "\n"
#~ "* If @fv is omitted, Gnumeric assumes it to be zero.\n"
#~ "* If @type is omitted, Gnumeric assumes it to be zero.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=PPMT,PV,FV"
#~ msgstr ""
#~ "@FUNCTION=AW\n"
#~ "@SYNTAX=AW(Zinssatz,Anzahl_Perioden,Zahlung[,ZW,type])\n"
#~ "@DESCRIPTION=AW liefert den aktuellen Wert einer Investition. @Zinssatz "
#~ "ist der periodische Zinssatz, @Anzahl_Perioden die zur Berechnung "
#~ "verwendete Anzahl der Perioden. @Zahlung ist die in jeder Periode "
#~ "geleistete Zahlung, @ZW der zukünftige Wert und @Typ gibt an, wann die "
#~ "Zahlung zu leisten ist.\n"
#~ "\n"
#~ "* Falls @Typ 1 ist, ist die Zahlung am Anfang jeder Periode zu leisten.\n"
#~ "* Falls @Typ 1 ist (oder nicht übergeben wird), ist die Zahlung am Ende "
#~ "jeder Periode zu leisten.\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=ZW"

#~ msgid ""
#~ "@FUNCTION=DURATION\n"
#~ "@SYNTAX=DURATION(settlement,maturity,coup,yield,frequency[,basis])\n"
#~ "@DESCRIPTION=DURATION calculates the duration of a security.\n"
#~ "\n"
#~ "@settlement is the settlement date of the security.\n"
#~ "@maturity is the maturity date of the security.\n"
#~ "@coup The annual coupon rate as a percentage.\n"
#~ "@yield The annualized yield of the security as a percentage.\n"
#~ "@frequency is the number of coupon payments per year. Allowed frequencies "
#~ "are: 1 = annual, 2 = semi, 4 = quarterly. @basis is the type of day "
#~ "counting system you want to use:\n"
#~ "\n"
#~ "  0  US 30/360\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "\n"
#~ "* If @frequency is other than 1, 2, or 4, DURATION returns #NUM! error.\n"
#~ "* If @basis is omitted, US 30/360 is applied.\n"
#~ "* If @basis is not in between 0 and 4, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=G_DURATION,MDURATION"
#~ msgstr ""
#~ "@FUNCTION=ERTRAG\n"
#~ "@SYNTAX=ERTRAG(settle,mat,rate,price,redemption_price,Häufigkeit[,"
#~ "Basis])\n"
#~ "@DESCRIPTION=ERTRAG liefert den Ertrag auf eine Sicherheit, die einen "
#~ "periodischen Zins abwirft.\n"
#~ "\n"
#~ "@Häufigkeit ist die Anzahl der Kupon-Zahlungen pro Jahr. Zulässige Werte "
#~ "sind: 1 = jährlich, 2 = halbjährlich, 4 = vierteljährlich.\n"
#~ "@Basis ist der Typ des zur Tagesberechnung verwendeten Systems:\n"
#~ "\n"
#~ "  0  MSRB 30/360 (MSRB Regel G33 (e))\n"
#~ "  1  Tatsächliche Tage/Tatsächliche Tage\n"
#~ "  2  Tatsächliche Tage/360\n"
#~ "  3  Tatsächliche Tage/365\n"
#~ "  4  Europäisch 30/360\n"
#~ "  5  Europäisch + 30/360\n"
#~ "\n"
#~ "* Falls @Häufigkeit weder 1, noch 2, 4 oder ungültig ist, liefert ERTRAG "
#~ "einen #ZAHL!-Fehler.\n"
#~ "* Falls @Basis nicht übergeben wird, wird MSRB 30/360 angenommen.\n"
#~ "* Falls @Basis nicht zwischen 0 und 4 liegt, liefert ERTRAG einen #ZAHL!-"
#~ "Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=FVSCHEDULE\n"
#~ "@SYNTAX=FVSCHEDULE(principal,schedule)\n"
#~ "@DESCRIPTION=FVSCHEDULE returns the future value of given initial value "
#~ "after applying a series of compound periodic interest rates. The argument "
#~ "@principal is the present value; @schedule is an array of interest rates "
#~ "to apply. The @schedule argument must be a range of cells.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain interest rates 0.11, "
#~ "0.13, 0.09, 0.17, and 0.03.  Then\n"
#~ "FVSCHEDULE(3000,A1:A5) equals 4942.7911611.\n"
#~ "@SEEALSO=PV,FV"
#~ msgstr ""
#~ "@FUNCTION=MITTELWERT\n"
#~ "@SYNTAX=MITTELWERT(Wert1,Wert2[,...])\n"
#~ "@DESCRIPTION=MITTELWERT berechnet den Mittelwert aller übergebenen Werte "
#~ "und Zellen. Dieser wird durch das Teilen der Gesamtsumme der Argumente "
#~ "durch die Anzahl selbiger berechnet.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, die Zellen A1, A2, ..., A5 enthalten die Zahlen 11.4, 17.3, "
#~ "21.3, 25.9 und 40.1. Dann liefert\n"
#~ "MITTELWERT(A1:A5) 23.2.\n"
#~ "\n"
#~ "@SEEALSO=SUMME, ANZAHL"

#~ msgid ""
#~ "@FUNCTION=EURO\n"
#~ "@SYNTAX=EURO(currency)\n"
#~ "@DESCRIPTION=EURO converts one Euro to a given national currency in the "
#~ "European monetary union.\n"
#~ "\n"
#~ "@currency is one of the following:\n"
#~ "\n"
#~ "    ATS\t(Austria)\n"
#~ "    BEF\t(Belgium)\n"
#~ "    DEM\t(Germany)\n"
#~ "    ESP\t(Spain)\n"
#~ "    EUR\t(Euro)\n"
#~ "    FIM\t(Finland)\n"
#~ "    FRF\t(France)\n"
#~ "    GRD\t(Greek)\n"
#~ "    IEP\t(Ireland)\n"
#~ "    ITL\t(Italy)\n"
#~ "    LUF\t(Luxembourg)\n"
#~ "    NLG\t(Netherlands)\n"
#~ "    PTE\t(Portugal)\n"
#~ "\n"
#~ "* If the given @currency is other than one of the above, EURO returns "
#~ "#NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "EURO(\"DEM\") returns 1.95583.\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=EURO\n"
#~ "@SYNTAX=EURO(Währung)\n"
#~ "@DESCRIPTION=EURO konvertiert einen Euro in die angegebene nationale "
#~ "Währung der europäischen Währungsunion.\n"
#~ "\n"
#~ "@Währung muss eine der Folgenden sein:\n"
#~ "\n"
#~ "    ATS\t(Österreich)\n"
#~ "    BEF\t(Belgien)\n"
#~ "    DEM\t(Deutschland)\n"
#~ "    ESP\t(Spanien)\n"
#~ "    EUR\t(Euro)\n"
#~ "    FIM\t(Finnland)\n"
#~ "    FRF\t(Frankreich)\n"
#~ "    GRD\t(Griechenland)\n"
#~ "    IEP\t(Irland)\n"
#~ "    ITL\t(Italien)\n"
#~ "    LUF\t(Luxemburg)\n"
#~ "    NLG\t(Niederlande)\n"
#~ "    PTE\t(Portugal)\n"
#~ "\n"
#~ "* Falls @Währung keine der oben aufgeführten ist, liefert EURO einen "
#~ "#ZAHL!-Fehler.\n"
#~ "@EXAMPLES=\n"
#~ "EURO(\"DEM\") liefert 1.95583.\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=EUROCONVERT\n"
#~ "@SYNTAX=EUROCONVERT(n,source,target)\n"
#~ "@DESCRIPTION=EUROCONVERT converts the currency value @n of @source "
#~ "currency to a target currency @target. Both currencies are given as three-"
#~ "letter strings using the ISO code system names.  The following currencies "
#~ "are available:\n"
#~ "\n"
#~ "    ATS\t(Austria)\n"
#~ "    BEF\t(Belgium)\n"
#~ "    DEM\t(Germany)\n"
#~ "    ESP\t(Spain)\n"
#~ "    EUR\t(Euro)\n"
#~ "    FIM\t(Finland)\n"
#~ "    FRF\t(France)\n"
#~ "    GRD\t(Greek)\n"
#~ "    IEP\t(Ireland)\n"
#~ "    ITL\t(Italy)\n"
#~ "    LUF\t(Luxembourg)\n"
#~ "    NLG\t(Netherlands)\n"
#~ "    PTE\t(Portugal)\n"
#~ "\n"
#~ "* If the given @source or @target is other than one of the above, "
#~ "EUROCONVERT returns #VALUE! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "EUROCONVERT(2.1,\"DEM\",\"EUR\") returns 1.07.\n"
#~ "@SEEALSO=EURO"
#~ msgstr ""
#~ "@FUNCTION=EUROKONVERTIEREN\n"
#~ "@SYNTAX=EUROKONVERTIEREN(n,Quelle,Ziel)\n"
#~ "@DESCRIPTION=EUROKONVERTIEREN konvertiert den Währungswert @n der Währung "
#~ "@Quelle in die Währung @Ziel. Beide Währungen müssen als Zeichenkette im "
#~ "aus drei Buchstaben bestehenden ISO-Ländercode übergeben werden.\n"
#~ "\n"
#~ "Folgende Währungen sind verfügbar:\n"
#~ "\n"
#~ "    ATS\t(Österreich)\n"
#~ "    BEF\t(Belgien)\n"
#~ "    DEM\t(Deutschland)\n"
#~ "    ESP\t(Spanien)\n"
#~ "    EUR\t(Euro)\n"
#~ "    FIM\t(Finnland)\n"
#~ "    FRF\t(Frankreich)\n"
#~ "    GRD\t(Griechenland)\n"
#~ "    IEP\t(Irland)\n"
#~ "    ITL\t(Italien)\n"
#~ "    LUF\t(Luxemburg)\n"
#~ "    NLG\t(Niederlande)\n"
#~ "    PTE\t(Portugal)\n"
#~ "\n"
#~ "* Falls @Quelle oder @Ziel keine der oben aufgeführten ist, liefert EURO "
#~ "einen #ZAHL!-Fehler.\n"
#~ "@EXAMPLES=\n"
#~ "EURO(2.1,\"DEM\",\"EUR\") liefert 1.07.\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=CUMIPMT\n"
#~ "@SYNTAX=CUMIPMT(rate,nper,pv,start_period,end_period,type)\n"
#~ "@DESCRIPTION=CUMIPMT returns the cumulative interest paid on a loan "
#~ "between @start_period and @end_period.\n"
#~ "\n"
#~ "* If @rate <= 0, CUMIPMT returns #NUM! error.\n"
#~ "* If @nper <= 0, CUMIPMT returns #NUM! error.\n"
#~ "* If @pv <= 0, CUMIPMT returns #NUM! error.\n"
#~ "* If @start_period < 1, CUMIPMT returns #NUM! error.\n"
#~ "* If @end_period < @start_period, CUMIPMT returns #NUM! error.\n"
#~ "* If @end_period > @nper, CUMIPMT returns #NUM! error.\n"
#~ "* If @type <> 0 and @type <> 1, CUMIPMT returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=GESZINSZ\n"
#~ "@SYNTAX=GESZINSZ(Zinssatz,Periodenanzahl,pv,Periodenbeginn,Periodenende,"
#~ "Typ)\n"
#~ "@DESCRIPTION=GESZINSZ liefert die Zinsaufwendung für ein Darlehen "
#~ "zwischen @Periodenbeginn und @Periodenende.\n"
#~ "\n"
#~ "* Falls @Zinssatz <= 0 ist, liefert GESZINSZ einen #ZAHL!-Fehler.\n"
#~ "* Falls @Periodenanzahl <= 0 ist, liefert GESZINSZ einen #ZAHL!-Fehler.\n"
#~ "* Falls @pv <= 0 ist, liefert GESZINSZ einen #ZAHL!-Fehler.\n"
#~ "* Falls @Periodenbeginn < 1 ist, liefert GESZINSZ einen #ZAHL!-Fehler.\n"
#~ "* Falls @Periodenende < @Periodenbeginn ist, liefert GESZINSZ einen "
#~ "#ZAHL!-Fehler.\n"
#~ "* Falls @Periodenende > @Periodenanzahl ist, liefert GESZINSZ einen "
#~ "#ZAHL!-Fehler.\n"
#~ "* Falls @Typ <> 0 und @Typ <> 1 ist, liefert GESZINSZ einen #ZAHL!-"
#~ "Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=CUMPRINC\n"
#~ "@SYNTAX=CUMPRINC(rate,nper,pv,start_period,end_period,type)\n"
#~ "@DESCRIPTION=CUMPRINC returns the cumulative principal paid on a loan "
#~ "between @start_period and @end_period.\n"
#~ "\n"
#~ "* If @rate <= 0, CUMPRINC returns #NUM! error.\n"
#~ "* If @nper <= 0, CUMPRINC returns #NUM! error.\n"
#~ "* If @pv <= 0, CUMPRINC returns #NUM! error.\n"
#~ "* If @start_period < 1, CUMPRINC returns #NUM! error.\n"
#~ "* If @end_period < @start_period, CUMPRINC returns #NUM! error.\n"
#~ "* If @end_period > @nper, CUMPRINC returns #NUM! error.\n"
#~ "* If @type <> 0 and @type <> 1, CUMPRINC returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=GESZINSK\n"
#~ "@SYNTAX=GESZINSK(Zinssatz,Periodenanzahl,pv,Periodenbeginn,Periodenende,"
#~ "Typ)\n"
#~ "@DESCRIPTION=GESZINSK liefert die Kapitalaufwendung für ein Darlehen "
#~ "zwischen @Periodenbeginn und @Periodenende.\n"
#~ "\n"
#~ "* Falls @Zinssatz <= 0 ist, liefert GESZINSK einen #ZAHL!-Fehler.\n"
#~ "* Falls @Periodenanzahl <= 0 ist, liefert GESZINSK einen #ZAHL!-Fehler.\n"
#~ "* Falls @pv <= 0 ist, liefert GESZINSK einen #ZAHL!-Fehler.\n"
#~ "* Falls @Periodenbeginn < 1 ist, liefert GESZINSK einen #ZAHL!-Fehler.\n"
#~ "* Falls @Periodenende < @Periodenbeginn ist, liefert GESZINSK einen "
#~ "#ZAHL!-Fehler.\n"
#~ "* Falls @Periodenende > @Periodenanzahl ist, liefert GESZINSK einen "
#~ "#ZAHL!-Fehler.\n"
#~ "* Falls @Typ <> 0 und @Typ <> 1 ist, liefert GESZINSK einen #ZAHL!-"
#~ "Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=MDURATION\n"
#~ "@SYNTAX=MDURATION(settlement,maturity,coupon,yield,frequency[,basis])\n"
#~ "@DESCRIPTION=MDURATION returns the Macauley duration for a security with "
#~ "par value 100.\n"
#~ "\n"
#~ "@basis is the type of day counting system you want to use:\n"
#~ "\n"
#~ "  0  MSRB 30/360 (MSRB Rule G33 (e))\n"
#~ "  1  actual days/actual days\n"
#~ "  2  actual days/360\n"
#~ "  3  actual days/365\n"
#~ "  4  European 30/360\n"
#~ "  5  European+ 30/360\n"
#~ "\n"
#~ "* If @settlement or @maturity are not valid dates, MDURATION returns "
#~ "#NUM! error.\n"
#~ "* If @frequency is other than 1, 2, or 4, MDURATION returns #NUM! error.\n"
#~ "* If @basis is omitted, MSRB 30/360 is applied.\n"
#~ "* If @basis is invalid, #NUM! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=DURATION,G_DURATION"
#~ msgstr ""
#~ "@FUNCTION=ERTRAG\n"
#~ "@SYNTAX=ERTRAG(settle,mat,rate,price,redemption_price,Häufigkeit[,"
#~ "Basis])\n"
#~ "@DESCRIPTION=ERTRAG liefert den Ertrag auf eine Sicherheit, die einen "
#~ "periodischen Zins abwirft.\n"
#~ "\n"
#~ "@Basis ist der Typ des zur Tagesberechnung verwendeten Systems:\n"
#~ "\n"
#~ "  0  MSRB 30/360 (MSRB Regel G33 (e))\n"
#~ "  1  Tatsächliche Tage/Tatsächliche Tage\n"
#~ "  2  Tatsächliche Tage/360\n"
#~ "  3  Tatsächliche Tage/365\n"
#~ "  4  Europäisch 30/360\n"
#~ "  5  Europäisch + 30/360\n"
#~ "\n"
#~ "* Falls @Häufigkeit weder 1, noch 2, 4 oder ungültig ist, liefert ERTRAG "
#~ "einen #ZAHL!-Fehler.\n"
#~ "* Falls @Basis nicht übergeben wird, wird MSRB 30/360 angenommen.\n"
#~ "* Falls @Basis nicht zwischen 0 und 4 liegt, liefert ERTRAG einen #ZAHL!-"
#~ "Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=VDB\n"
#~ "@SYNTAX=VDB(cost,salvage,life,start_period,end_period[,factor,switch])\n"
#~ "@DESCRIPTION=VDB calculates the depreciation of an asset for a given "
#~ "period or partial period using the double-declining balance method.\n"
#~ "\n"
#~ "* If @start_period < 0, VDB returns #NUM! error.\n"
#~ "* If @start_period > @end_period, VDB returns #NUM! error.\n"
#~ "* If @end_period > @life, VDB returns #NUM! error.\n"
#~ "* If @cost < 0, VDB returns #NUM! error.\n"
#~ "* If @salvage > @cost, VDB returns #NUM! error.\n"
#~ "* If @factor <= 0, VDB returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=DB"
#~ msgstr ""
#~ "@FUNCTION=GESZINSZ\n"
#~ "@SYNTAX=GESZINSZ(Zinssatz,Periodenanzahl,pv,Periodenbeginn,Periodenende,"
#~ "Typ)\n"
#~ "@DESCRIPTION=GESZINSZ liefert die Zinsaufwendung für ein Darlehen "
#~ "zwischen @Periodenbeginn und @Periodenende.\n"
#~ "\n"
#~ "* Falls @Zinssatz <= 0 ist, liefert GESZINSZ einen #ZAHL!-Fehler.\n"
#~ "* Falls @Periodenanzahl <= 0 ist, liefert GESZINSZ einen #ZAHL!-Fehler.\n"
#~ "* Falls @pv <= 0 ist, liefert GESZINSZ einen #ZAHL!-Fehler.\n"
#~ "* Falls @Periodenbeginn < 1 ist, liefert GESZINSZ einen #ZAHL!-Fehler.\n"
#~ "* Falls @Periodenende < @Periodenbeginn ist, liefert GESZINSZ einen "
#~ "#ZAHL!-Fehler.\n"
#~ "* Falls @Periodenende > @Periodenanzahl ist, liefert GESZINSZ einen "
#~ "#ZAHL!-Fehler.\n"
#~ "* Falls @Typ <> 0 und @Typ <> 1 ist, liefert GESZINSZ einen #ZAHL!-"
#~ "Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=CELL\n"
#~ "@SYNTAX=CELL(type,ref)\n"
#~ "@DESCRIPTION=CELL returns information about the formatting, location, or "
#~ "contents of a cell.\n"
#~ "\n"
#~ "@type specifies the type of information you want to obtain:\n"
#~ "\n"
#~ "  address    \tReturns the given cell reference as text.\n"
#~ "  col        \t\tReturns the number of the column in @ref.\n"
#~ "  contents   \tReturns the contents of the cell in @ref.\n"
#~ "  format     \t\tReturns the code of the format of the cell.\n"
#~ "  parentheses\tReturns 1 if @ref contains a negative value\n"
#~ "             \t\tand its format displays it with parentheses.\n"
#~ "  row        \t\tReturns the number of the row in @ref.\n"
#~ "  width      \t\tReturns the column width.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Cell(\"format\",A1) returns the code of the format of the cell A1.\n"
#~ "\n"
#~ "@SEEALSO=INDIRECT"
#~ msgstr ""
#~ "@FUNCTION=ZELLE\n"
#~ "@SYNTAX=ZELLE(Typ,Bezug)\n"
#~ "@DESCRIPTION=ZELLE liefert Informationen zu Formatierung, Ort und Inhalt "
#~ "einer Zelle.\n"
#~ "\n"
#~ "@Typ gibt den abzurufenden Informationstyp an:\n"
#~ "\n"
#~ "  address    \tliefert den übergebenen Zellbezug als Text.\n"
#~ "  col        \t\tliefert die Anzahl der Spalten in @Bezug.\n"
#~ "  contents   \tliefert den Inhalt der Zelle in @Bezug.\n"
#~ "  format     \t\tliefert die Formatierungskennung der Zelle.\n"
#~ "  parentheses\tliefert 1, falls @Bezug einen negativen Wert enthält\n"
#~ "             \t\tund ihn dessen Formatierung eingeklammert anzeigt.\n"
#~ "  row        \t\tliefert die Anzahl der Zeilen in @Bezug.\n"
#~ "  width      \t\tliefert die Spaltenbreite.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ZELLE(\"format\",A1) liefert die Formatierungskennung der Zelle A1.\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=EXPRESSION\n"
#~ "@SYNTAX=EXPRESSION(cell)\n"
#~ "@DESCRIPTION=EXPRESSION returns expression in @cell as a string, or empty "
#~ "if the cell is not an expression.\n"
#~ "@EXAMPLES=\n"
#~ "entering '=EXPRESSION(A3)' in A2 = empty (assuming there is nothing in "
#~ "A3).\n"
#~ "entering '=EXPRESSION(A2)' in A1 = 'EXPRESSION(A3)'.\n"
#~ "\n"
#~ "@SEEALSO=TEXT"
#~ msgstr ""
#~ "@FUNCTION=AUSDRUCK\n"
#~ "@SYNTAX=AUSDRUCK(Zelle)\n"
#~ "@DESCRIPTION=AUSDRUCK liefert den Ausdruck in @Zelle als Zeichenkette, "
#~ "oder nichts, falls die Zelle kein Ausdruck ist.\n"
#~ "@EXAMPLES=\n"
#~ "In A2 liefert AUSDRUCK(A3) nichts (angenommen, dass A3 leer ist).\n"
#~ "In A1 liefert AUSDRUCK(A3) \"AUSDRUCK(A3)\".\n"
#~ "\n"
#~ "@SEEALSO=TEXT"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=GET.FORMULA\n"
#~ "@SYNTAX=GET.FORMULA(cell)\n"
#~ "@DESCRIPTION=EXPRESSION returns expression in @cell as a string, or empty "
#~ "if the cell is not an expression.\n"
#~ "@EXAMPLES=\n"
#~ "entering '=GET.FORMULA(A3)' in A2 = empty (assuming there is nothing in "
#~ "A3).\n"
#~ "entering '=GET.FORMULA(A2)' in A1 = '=GET.FORMULA(A3)'.\n"
#~ "\n"
#~ "@SEEALSO=EXPRESSION"
#~ msgstr ""
#~ "@FUNCTION=AUSDRUCK\n"
#~ "@SYNTAX=AUSDRUCK(Zelle)\n"
#~ "@DESCRIPTION=AUSDRUCK liefert den Ausdruck in @Zelle als Zeichenkette, "
#~ "oder nichts, falls die Zelle kein Ausdruck ist.\n"
#~ "@EXAMPLES=\n"
#~ "In A2 liefert AUSDRUCK(A3) nichts (angenommen, dass A3 leer ist).\n"
#~ "In A1 liefert AUSDRUCK(A3) \"AUSDRUCK(A3)\".\n"
#~ "\n"
#~ "@SEEALSO=TEXT"

#~ msgid ""
#~ "@FUNCTION=COUNTBLANK\n"
#~ "@SYNTAX=COUNTBLANK(range)\n"
#~ "@DESCRIPTION=COUNTBLANK returns the number of blank cells in a @range.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COUNTBLANK(A1:A20) returns the number of blank cell in A1:A20.\n"
#~ "\n"
#~ "@SEEALSO=COUNT"
#~ msgstr ""
#~ "@FUNCTION=ANZAHLLEEREZELLEN\n"
#~ "@SYNTAX=ANZAHLLEEREZELLEN(Bereich)\n"
#~ "@DESCRIPTION=ANZAHLLEEREZELLEN liefert die Anzahl leerer Zellen in "
#~ "@Bereich.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ANZAHLLEEREZELLEN(A1:A20) liefert die Anzahl leerer Zellen in A1:A20.\n"
#~ "\n"
#~ "@SEEALSO=ANZAHL"

#~ msgid ""
#~ "@FUNCTION=ISERROR\n"
#~ "@SYNTAX=ISERROR(value)\n"
#~ "@DESCRIPTION=ISERROR returns a TRUE value if the expression has an "
#~ "error.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISERROR(NA()) equals TRUE.\n"
#~ "\n"
#~ "@SEEALSO=ERROR"
#~ msgstr ""
#~ "@FUNCTION=ISTFEHLER\n"
#~ "@SYNTAX=ISTFEHLER(Wert)\n"
#~ "@DESCRIPTION=ISTFEHLER liefert WAHR, falls der Ausdruck einen Fehler "
#~ "enthält.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISTFEHLER(NA()) liefert WAHR.\n"
#~ "@SEEALSO=FEHLER"

#~ msgid ""
#~ "@FUNCTION=ISNA\n"
#~ "@SYNTAX=ISNA(value)\n"
#~ "@DESCRIPTION=ISNA returns TRUE if the value is the #N/A error value.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISNA(NA()) equals TRUE.\n"
#~ "\n"
#~ "@SEEALSO=NA"
#~ msgstr ""
#~ "@FUNCTION=ISTNV\n"
#~ "@SYNTAX=ISTNV(Wert)\n"
#~ "@DESCRIPTION=ISTNV liefert WAHR, falls der Wert der #NV-Fehlerwert ist.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISTNV(NV()) liefert WAHR.\n"
#~ "\n"
#~ "@SEEALSO=NV"

#~ msgid ""
#~ "@FUNCTION=ISERR\n"
#~ "@SYNTAX=ISERR(value)\n"
#~ "@DESCRIPTION=ISERR returns TRUE if the value is any error value except #N/"
#~ "A.\n"
#~ "\n"
#~ "* This function is Excel compatible. \n"
#~ "@EXAMPLES=\n"
#~ "ISERR(NA()) return FALSE.\n"
#~ "\n"
#~ "@SEEALSO=ISERROR"
#~ msgstr ""
#~ "@FUNCTION=ISTFEHL\n"
#~ "@SYNTAX=ISTFEHL(Wert)\n"
#~ "@DESCRIPTION=ISTFEHL liefert WAHR, falls der Wert irgendein Fehler außer "
#~ "#NV ist.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISTFEHL(NV()) liefert FALSCH.\n"
#~ "\n"
#~ "@SEEALSO=ISTFEHLER"

#~ msgid ""
#~ "@FUNCTION=NA\n"
#~ "@SYNTAX=NA()\n"
#~ "@DESCRIPTION=NA returns the error value #N/A.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "NA() equals #N/A error.\n"
#~ "\n"
#~ "@SEEALSO=ISNA"
#~ msgstr ""
#~ "@FUNCTION=NV\n"
#~ "@SYNTAX=NV()\n"
#~ "@DESCRIPTION=NV liefert den Fehlerwert #NV.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "NA() liefert den Fehler #NV.\n"
#~ "\n"
#~ "@SEEALSO=ISTNV"

#~ msgid ""
#~ "@FUNCTION=ERROR\n"
#~ "@SYNTAX=ERROR(text)\n"
#~ "@DESCRIPTION=ERROR return the specified error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ERROR(\"#OWN ERROR\").\n"
#~ "\n"
#~ "@SEEALSO=ISERROR"
#~ msgstr ""
#~ "@FUNCTION=FEHLER\n"
#~ "@SYNTAX=FEHLER(Text)\n"
#~ "@DESCRIPTION=FEHLER liefert den angegebenen Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FEHLER(\"#MEIN FEHLER\").\n"
#~ "\n"
#~ "@SEEALSO=ISTFEHLER"

#~ msgid ""
#~ "@FUNCTION=ISBLANK\n"
#~ "@SYNTAX=ISBLANK(value)\n"
#~ "@DESCRIPTION=ISBLANK returns TRUE if the value is blank.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISBLANK(A1).\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=ISTLEER\n"
#~ "@SYNTAX=ISTLEER(Wert)\n"
#~ "@DESCRIPTION=ISTLEER liefert WAHR, falls @Wert leer ist.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISTLEER(A1).\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=ISEVEN\n"
#~ "@SYNTAX=ISEVEN(value)\n"
#~ "@DESCRIPTION=ISEVEN returns TRUE if the number is even.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISEVEN(4) equals TRUE.\n"
#~ "\n"
#~ "@SEEALSO=ISODD"
#~ msgstr ""
#~ "@FUNCTION=ISTGERADE\n"
#~ "@SYNTAX=ISTGERADE(Zahl)\n"
#~ "@DESCRIPTION=ISTGERADE liefert WAHR, falls @Zahl gerade ist.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISTGERADE(4) liefert WAHR.\n"
#~ "@SEEALSO=ISTUNGERADE"

#~ msgid ""
#~ "@FUNCTION=ISLOGICAL\n"
#~ "@SYNTAX=ISLOGICAL(value)\n"
#~ "@DESCRIPTION=ISLOGICAL returns TRUE if the value is a logical value.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISLOGICAL(A1).\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=ISTLOG\n"
#~ "@SYNTAX=ISTLOG(Wert)\n"
#~ "@DESCRIPTION=ISTLOG liefert WAHR, falls @Wert ein logischer Wert ist.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISTLOG(A1).\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=ISNONTEXT\n"
#~ "@SYNTAX=ISNONTEXT(value)\n"
#~ "@DESCRIPTION=ISNONTEXT Returns TRUE if the value is not text.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISNONTEXT(\"text\") equals FALSE.\n"
#~ "\n"
#~ "@SEEALSO=ISTEXT"
#~ msgstr ""
#~ "@FUNCTION=ISTKTEXT\n"
#~ "@SYNTAX=ISTKTEXT(Wert)\n"
#~ "@DESCRIPTION=ISTKTEXT liefert WAHR, falls @Wert kein Text ist.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISTKTEXT(\"Text\") liefert FALSCH.\n"
#~ "\n"
#~ "@SEEALSO=ISTTEXT"

#~ msgid ""
#~ "@FUNCTION=ISNUMBER\n"
#~ "@SYNTAX=ISNUMBER(value)\n"
#~ "@DESCRIPTION=ISNUMBER returns TRUE if the value is a number.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISNUMBER(\"text\") equals FALSE.\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=ISTZAHL\n"
#~ "@SYNTAX=ISTZAHL(Wert)\n"
#~ "@DESCRIPTION=ISTZAHL liefert WAHR, falls @Wert eine Zahl ist.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISTZAHL(\"Text\") liefert FALSCH.\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=ISODD\n"
#~ "@SYNTAX=ISODD(value)\n"
#~ "@DESCRIPTION=ISODD returns TRUE if the number is odd.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISODD(3) equals TRUE.\n"
#~ "\n"
#~ "@SEEALSO=ISEVEN"
#~ msgstr ""
#~ "@FUNCTION=ISTUNGERADE\n"
#~ "@SYNTAX=ISTUNGERADE(Zahl)\n"
#~ "@DESCRIPTION=ISTUNGERADE liefert WAHR, falls @Zahl ungerade ist.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISTUNGERADE(3) liefert WAHR.\n"
#~ "@SEEALSO=ISTGERADE"

#~ msgid ""
#~ "@FUNCTION=ISREF\n"
#~ "@SYNTAX=ISREF(value)\n"
#~ "@DESCRIPTION=ISREF returns TRUE if the value is a reference.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISREF(A1) equals TRUE.\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=ISTBEZUG\n"
#~ "@SYNTAX=ISTBEZUG(Wert)\n"
#~ "@DESCRIPTION=ISTBEZUG liefert WAHR, falls der Wert ein Bezug ist.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISTBEZUG(A1) liefert WAHR.\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=ISTEXT\n"
#~ "@SYNTAX=ISTEXT(value)\n"
#~ "@DESCRIPTION=ISTEXT returns TRUE if the value is text.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISTEXT(\"text\") equals TRUE.\n"
#~ "\n"
#~ "@SEEALSO=ISNONTEXT"
#~ msgstr ""
#~ "@FUNCTION=ISTTEXT\n"
#~ "@SYNTAX=ISTTEXT(Wert)\n"
#~ "@DESCRIPTION=ISTTEXT liefert WAHR, falls der Wert ein Text ist.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ISTTEXT(\"Text\") liefert WAHR.\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=N\n"
#~ "@SYNTAX=N(value)\n"
#~ "@DESCRIPTION=N returns a value converted to a number.  Strings containing "
#~ "text are converted to the zero value.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "N(\"42\") equals 42.\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=N\n"
#~ "@SYNTAX=N(Wert)\n"
#~ "@DESCRIPTION=N wandelt @Wert in eine Zahl um. Zeichenketten, die Text "
#~ "enthalten, werden in den Wert Null umgewandelt.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "N(\"42\") liefert 42.\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=TYPE\n"
#~ "@SYNTAX=TYPE(value)\n"
#~ "@DESCRIPTION=TYPE returns a number indicating the data type of a value.\n"
#~ "\n"
#~ "1  == number\n"
#~ "2  == text\n"
#~ "4  == boolean\n"
#~ "16 == error\n"
#~ "64 == array\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TYPE(3) equals 1.\n"
#~ "TYPE(\"text\") equals 2.\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=TYP\n"
#~ "@SYNTAX=TYP(Wert)\n"
#~ "@DESCRIPTION=TYP liefert eine Zahl, die den Datentyp von @Wert anzeigt.\n"
#~ "\n"
#~ "1 == Zahl\n"
#~ "2 == Text\n"
#~ "3 == Bool\n"
#~ "16 == Fehler\n"
#~ "64 == Feld\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TYP(3) liefert 1.\n"
#~ "TYPE(\"Text\") liefert 2.\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=GETENV\n"
#~ "@SYNTAX=GETENV(string)\n"
#~ "@DESCRIPTION=GETENV retrieves a value from the execution environment.\n"
#~ "\n"
#~ "* If the variable specified by @string does not exist, #N/A! will be "
#~ "returned.  Note, that variable names are case sensitive.\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=UMGEBUNG.ZUORDNEN\n"
#~ "@SYNTAX=UMGEBUNG.ZUORDNEN(Zeichenkette)\n"
#~ "@DESCRIPTION=UMGEBUNG.ZUORDNEN ermittelt den Wert einer der beim "
#~ "Ausführen verwendeten Umgebungsvariable.\n"
#~ "\n"
#~ "* Falls die von der Zeichenkette @Zeichenkette angegebene Variable nicht "
#~ "existiert, liefert UMGEBUNG.ZUORDNEN einen #NV!-Fehler.\n"
#~ "* Beachten Sie, dass bei Variablennamen zwischen Groß- und "
#~ "Kleinschreibung unterschieden wird.\n"
#~ "\n"
#~ " @EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=AND\n"
#~ "@SYNTAX=AND(b1, b2, ...)\n"
#~ "@DESCRIPTION=AND implements the logical AND function: the result is TRUE "
#~ "if all of the expressions evaluate to TRUE, otherwise it returns FALSE.\n"
#~ "\n"
#~ "@b1 through @bN are expressions that should evaluate to TRUE or FALSE.  "
#~ "If an integer or floating point value is provided, zero is considered "
#~ "FALSE and anything else is TRUE.\n"
#~ "\n"
#~ "* If the values contain strings or empty cells those values are ignored.\n"
#~ "* If no logical values are provided, then the error #VALUE! is returned.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "AND(TRUE,TRUE) equals TRUE.\n"
#~ "AND(TRUE,FALSE) equals FALSE.\n"
#~ "\n"
#~ "Let us assume that A1 holds number five and A2 number one.  Then\n"
#~ "AND(A1>3,A2<2) equals TRUE.\n"
#~ "\n"
#~ "@SEEALSO=OR, NOT"
#~ msgstr ""
#~ "@FUNCTION=UND\n"
#~ "@SYNTAX=UND(b1, b2, ...)\n"
#~ "@DESCRIPTION=UND stellt die logische UND-Verknüpfung bereit: Das Ergebnis "
#~ "ist WAHR, falls alle Ausdrücke WAHR sind, andernfalls FALSCH.\n"
#~ "\n"
#~ "@b1 bis @bN sind die auszuwertenden Ausdrücke. Falls ein ganzzahliger "
#~ "oder Fließpunkt-Wert übergeben wird, wird für den Wert Null FALSCH, für "
#~ "alle Anderen WAHR angenommen.\n"
#~ "\n"
#~ "* Falls die Werte Zeichenketten oder leere Zellen enthalten, werden diese "
#~ "Werte ignoriert.\n"
#~ "* Falls keine logischen Werte übergeben werden, liefert UND einen #WERT!-"
#~ "Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "UND(WAHR,WAHR) liefert WAHRF.\n"
#~ "AND(WAHR,FALSCH) equals FALSCH.\n"
#~ "\n"
#~ "Angenommen, die Zelle A1 enthält 5 und A2 1. Dann liefert\n"
#~ "UND(A1>3,A2<2) WAHR.\n"
#~ "\n"
#~ "@SEEALSO=ODER, NICHT"

#~ msgid ""
#~ "@FUNCTION=NOT\n"
#~ "@SYNTAX=NOT(number)\n"
#~ "@DESCRIPTION=NOT implements the logical NOT function: the result is TRUE "
#~ "if the @number is zero;  otherwise the result is FALSE.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "NOT(0) equals TRUE.\n"
#~ "NOT(TRUE) equals FALSE.\n"
#~ "\n"
#~ "@SEEALSO=AND, OR"
#~ msgstr ""
#~ "@FUNCTION=NICHT\n"
#~ "@SYNTAX=NICHT(Zahl)\n"
#~ "@DESCRIPTION=NICHT stellt die logische NICHT-Verknüpfung bereit: Das "
#~ "Ergebnis ist WAHR, falls der Wert von @Zahl Null ist, andernfalls "
#~ "FALSCH.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "NICHT(0) liefert WAHR.\n"
#~ "NICHT(WAHR) liefert FALSCH.\n"
#~ "\n"
#~ "@SEEALSO=UND, ODER"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=OR\n"
#~ "@SYNTAX=OR(b1, b2, ...)\n"
#~ "@DESCRIPTION=OR implements the logical OR function: the result is TRUE if "
#~ "any of the values evaluated to TRUE.\n"
#~ "\n"
#~ "@b1 through @bN are expressions that should evaluate to TRUE or FALSE. If "
#~ "an integer or floating point value is provided, zero is considered FALSE "
#~ "and anything else is TRUE.\n"
#~ "\n"
#~ "* If the values contain strings or empty cells those values are ignored.\n"
#~ "* If no logical values are provided, then the error #VALUE! is returned.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "OR(TRUE,FALSE) equals TRUE.\n"
#~ "OR(3>4,4<3) equals FALSE.\n"
#~ "\n"
#~ "@SEEALSO=AND, NOT"
#~ msgstr ""
#~ "@FUNCTION=ODER\n"
#~ "@SYNTAX=ODER(b1, b2, ...)\n"
#~ "@DESCRIPTION=ODER stellt die logische ODER-Verknüpfung bereit: Das "
#~ "Ergebnis ist WAHR, falls einer der übergebenen Werte WAHR ist.\n"
#~ "\n"
#~ "@b1 bis @bN sind die auszuwertenden Ausdrücke. Falls ein ganzzahliger "
#~ "oder Fließpunkt-Wert übergeben wird, wird für den Wert Null FALSCH, für "
#~ "alle Anderen WAHR angenommen.\n"
#~ "\n"
#~ "* Falls die Werte Zeichenketten oder leere Zellen enthalten, werden diese "
#~ "Werte ignoriert.\n"
#~ "* Falls keine logischen Werte übergeben werden, liefert ODER einen #WERT!-"
#~ "Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ODER(WAHR,FALSCH) liefert WAHR.\n"
#~ "ODER(3>4,4<3) liefert FALSCH.\n"
#~ "\n"
#~ "@SEEALSO=UND, NICHT"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=XOR\n"
#~ "@SYNTAX=XOR(b1, b2, ...)\n"
#~ "@DESCRIPTION=XOR implements the logical exclusive OR function: the result "
#~ "is TRUE if an odd number of the values evaluated to TRUE.\n"
#~ "\n"
#~ "@b1 through @bN are expressions that should evaluate to TRUE or FALSE. If "
#~ "an integer or floating point value is provided, zero is considered FALSE "
#~ "and anything else is TRUE.\n"
#~ "\n"
#~ "* If the values contain strings or empty cells those values are ignored.\n"
#~ "* If no logical values are provided, then the error #VALUE! is returned.\n"
#~ "@EXAMPLES=\n"
#~ "XOR(TRUE,FALSE) equals TRUE.\n"
#~ "XOR(3>4,4<3) equals FALSE.\n"
#~ "\n"
#~ "@SEEALSO=OR, AND, NOT"
#~ msgstr ""
#~ "@FUNCTION=XODER\n"
#~ "@SYNTAX=XODER(b1, b2, ...)\n"
#~ "@DESCRIPTION=XODER stellt die exklusive ODER-Verknüpfung bereit: Das "
#~ "Ergebnis ist WAHR, falls eine ungerade Anzahl der Werte WAHR ist.\n"
#~ "\n"
#~ "@b1 bis @bN sind die auszuwertenden Ausdrücke. Falls ein ganzzahliger "
#~ "oder Fließpunkt-Wert übergeben wird, wird für den Wert Null FALSCH, für "
#~ "alle Anderen WAHR angenommen.\n"
#~ "\n"
#~ "* Falls die Werte Zeichenketten oder leere Zellen enthalten, werden diese "
#~ "Werte ignoriert.\n"
#~ "* Falls keine logischen Werte übergeben werden, liefert XODER einen "
#~ "#WERT!-Fehler.\n"
#~ "\n"
#~ "XODER(WAHR,FALSCH) liefert WAHR.\n"
#~ "XODER(3>4,4<3) liefert FALSCH.\n"
#~ "\n"
#~ "@SEEALSO=ODER, UND, NICHT"

#~ msgid ""
#~ "@FUNCTION=IF\n"
#~ "@SYNTAX=IF(condition[,if-true,if-false])\n"
#~ "@DESCRIPTION=IF function can be used to evaluate conditionally other "
#~ "expressions. IF evaluates @condition.  If @condition returns a non-zero "
#~ "value the result of the IF expression is the @if-true expression, "
#~ "otherwise IF evaluates to the value of @if-false.\n"
#~ "\n"
#~ "* If omitted @if-true defaults to TRUE and @if-false to FALSE.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IF(FALSE,TRUE,FALSE) equals FALSE.\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=WENN\n"
#~ "@SYNTAX=WENN(Bedingung[,wenn-wahr,wenn-falsch])\n"
#~ "@DESCRIPTION=WENN kann zur fallweisen Auswertung anderer Ausdrücke "
#~ "verwendet werden und wertet die Bedingung @Bedingung aus. Falls diese "
#~ "einen Wert != Null liefert, ist das Ergebnis des WENN-Ausdrucks @wenn-"
#~ "wahr, andernfalls @wenn-falsch.\n"
#~ "\n"
#~ "* Falls @wenn-wahr und @wenn-falsch nicht übergeben werden, wird WAHR für "
#~ "@wenn-wahr bzw. FALSCH für @wenn-falsch angenommen.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "WENN(FALSCH,WAHR,FALSCH) liefert FALSCH.\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=TRUE\n"
#~ "@SYNTAX=TRUE()\n"
#~ "@DESCRIPTION=TRUE returns boolean value true.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TRUE() equals TRUE.\n"
#~ "\n"
#~ "@SEEALSO=FALSE"
#~ msgstr ""
#~ "@FUNCTION=WAHR\n"
#~ "@SYNTAX=WAHR()\n"
#~ "@DESCRIPTION=WAHR liefert den Boole'schen Wert WAHR.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=WAHR() liefert WAHR.\n"
#~ "\n"
#~ "@SEEALSO=FALSCH"

#~ msgid ""
#~ "@FUNCTION=FALSE\n"
#~ "@SYNTAX=FALSE()\n"
#~ "@DESCRIPTION=FALSE returns boolean value false.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FALSE() equals FALSE.\n"
#~ "\n"
#~ "@SEEALSO=TRUE"
#~ msgstr ""
#~ "@FUNCTION=FALSCH\n"
#~ "@SYNTAX=FALSCH()\n"
#~ "@DESCRIPTION=FALSCH liefert den Boole'schen Wert FALSCH.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=FALSCH() liefert FALSCH.\n"
#~ "\n"
#~ "@SEEALSO=WAHR"

#~ msgid ""
#~ "@FUNCTION=ADDRESS\n"
#~ "@SYNTAX=ADDRESS(row_num,col_num[,abs_num,a1,text])\n"
#~ "@DESCRIPTION=ADDRESS returns a cell address as text for specified row and "
#~ "column numbers.\n"
#~ "\n"
#~ "@a1 is a logical value that specifies the reference style.  If @a1 is "
#~ "TRUE or omitted, ADDRESS returns an A1-style reference, i.e. $D$4.  "
#~ "Otherwise ADDRESS returns an R1C1-style reference, i.e. R4C4.\n"
#~ "\n"
#~ "@text specifies the name of the worksheet to be used as the external "
#~ "reference.\n"
#~ "\n"
#~ "* If @abs_num is 1 or omitted, ADDRESS returns absolute reference.\n"
#~ "* If @abs_num is 2 ADDRESS returns absolute row and relative column.\n"
#~ "* If @abs_num is 3 ADDRESS returns relative row and absolute column.\n"
#~ "* If @abs_num is 4 ADDRESS returns relative reference.\n"
#~ "* If @abs_num is greater than 4 ADDRESS returns #VALUE! error.\n"
#~ "* If @row_num or @col_num is less than one, ADDRESS returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ADDRESS(5,4) equals \"$D$5\".\n"
#~ "ADDRESS(5,4,4) equals \"D5\".\n"
#~ "ADDRESS(5,4,3,FALSE) equals \"R[5]C4\".\n"
#~ "\n"
#~ "@SEEALSO=COLUMNNUMBER"
#~ msgstr ""
#~ "@FUNCTION=ADRESSE\n"
#~ "@SYNTAX=ADRESSE(Zeilennummer,Spaltennummer[,Absolut,A1_Bezug,Text])\n"
#~ "@DESCRIPTION=ADRESSE liefert die Adresse der Zelle mit der angegebenen "
#~ "Zeilen- und Spaltennummer als Text.\n"
#~ "\n"
#~ "@A1 ist ein logischer Wert, der die Bezugsformatierung angibt. Falls "
#~ "dieser WAHR ist oder nicht übergeben wird, liefert ADRESSE einen A1-"
#~ "formatierten Zellbezug, also z.B. $D$4, andernfalls einen Zellbezug im "
#~ "R1C1-Format, also z.B. R4C4.\n"
#~ "\n"
#~ "@Text gibt den Namen des als externer Bezug zu verwendenden Arbeitsbuchs "
#~ "an.\n"
#~ "\n"
#~ "* Falls @Absolut 1 ist oder nicht übergeben wird, liefert ADRESSE den "
#~ "absoluten Bezug.\n"
#~ "* Falls @Absolut 2 ist, liefert ADRESSE die absolute Zeilen- und die "
#~ "relative Spaltennummer.\n"
#~ "* Falls @Absulut 3 ist, liefert ADRESSE die relative Zeilen- und die "
#~ "absolute Spaltennummer.\n"
#~ "* Falls @Absolut 4 ist, liefert ADRESSE den relativen Bezug.\n"
#~ "* Falls @Absolut größer als 4 ist, liefert ADDRESSE einen #WERT!-Fehler.\n"
#~ "* Falls @Zeilennummer oder @Spaltennummer kleiner als 1 ist, liefert "
#~ "ADRESSE einen #WERT!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ADRESSE(5,4) liefert \"$D$5\",\n"
#~ "ADRESSE(5,4,4) \"D5\" und\n"
#~ "ADRESSE(5,4,3,FALSCH) \"R[5]C4\".\n"
#~ "\n"
#~ "@SEEALSO=SPALTENNUMMER"

#~ msgid ""
#~ "@FUNCTION=AREAS\n"
#~ "@SYNTAX=AREAS(reference)\n"
#~ "@DESCRIPTION=AREAS returns the number of areas in @reference. \n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "AREAS((A1,B2,C3)) equals 3.\n"
#~ "\n"
#~ "@SEEALSO=ADDRESS,INDEX,INDIRECT,OFFSET"
#~ msgstr ""
#~ "@FUNCTION=BEREICHE\n"
#~ "@SYNTAX=BEREICHE(@Bezug)\n"
#~ "@DESCRIPTION=BEREICHE liefert die Anzahl der Bereiche in @Bezug.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BEREICHE((A1,B2,C3)) liefert 3.\n"
#~ "\n"
#~ "@SEEALSO=ADRESSE, INDEX, INDIREKT, BEREICH.VERSCHIEBEN"

#~ msgid ""
#~ "@FUNCTION=CHOOSE\n"
#~ "@SYNTAX=CHOOSE(index[,value1][,value2]...)\n"
#~ "@DESCRIPTION=CHOOSE returns the value of index @index. @index is rounded "
#~ "to an integer if it is not.\n"
#~ "\n"
#~ "* If @index < 1 or @index > number of values, CHOOSE returns #VALUE! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CHOOSE(3,\"Apple\",\"Orange\",\"Grape\",\"Perry\") equals \"Grape\".\n"
#~ "\n"
#~ "@SEEALSO=IF"
#~ msgstr ""
#~ "@FUNCTION=WAHL\n"
#~ "@SYNTAX=WAHL(Index[,Wert1][,Wert2]...)\n"
#~ "@DESCRIPTION=WAHL liefert den Wert des @Index-ten Index. Falls @Index "
#~ "keine Ganzzahl ist, wird auf die nächste aufgerundet.\n"
#~ "\n"
#~ "* Falls @Index < 1 oder @Index > Anzahl der Werte, liefert WAHL einen "
#~ "#WERT!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "WAHL(3,\"Apfel\",\"Birnen\",\"Orangen\",\"Wein\") liefert \"Orangen\".\n"
#~ "\n"
#~ "@SEEALSO=FALLS"

#~ msgid ""
#~ "@FUNCTION=LOOKUP\n"
#~ "@SYNTAX=LOOKUP(value,vector1[,vector2])\n"
#~ "@DESCRIPTION=LOOKUP function finds the row index of @value in @vector1 "
#~ "and returns the contents of @vector2 at that row index. Alternatively a "
#~ "single array can be used for @vector1. If the area is longer than it is "
#~ "wide then the sense of the search is rotated. \n"
#~ "\n"
#~ "* If LOOKUP can't find @value it uses the largest value less than "
#~ "@value.\n"
#~ "* The data must be sorted.\n"
#~ "* If @value is smaller than the first value it returns #N/A.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=VLOOKUP,HLOOKUP"
#~ msgstr ""
#~ "@FUNCTION=VERWEIS\n"
#~ "@SYNTAX=VERWEIS(Wert,Vektor1[,Vektor2])\n"
#~ "@DESCRIPTION=VERWEIS sucht den Zeilenindex von @Wert in @Vektor1 und "
#~ "liefert den Inhalt von @Vektor2 bei diesem Zeilenindex. Alternativ kann "
#~ "ein einzelnes Datenfeld für @Vektor2 verwendet werden. Falls der Bereich "
#~ "länger als dessen Breite ist, wird die Suche umgekehrt.\n"
#~ "\n"
#~ "* Falls @Wert nicht gefunden werden kann, wird ein niedrigerer, am "
#~ "nächsten an @Wert gelegener Wert verwendet.\n"
#~ "* Die Daten müssen sortiert werden.\n"
#~ "* Falls @Wert kleiner als der erste Wert ist, liefert VERWEIS #NV.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=SVERWEIS,WVERWEIS"

#~ msgid ""
#~ "@FUNCTION=MATCH\n"
#~ "@SYNTAX=MATCH(seek,vector[,type])\n"
#~ "@DESCRIPTION=MATCH function finds the row index of @seek in @vector and "
#~ "returns it.\n"
#~ "\n"
#~ "If the area is longer than it is wide then the sense of the search is "
#~ "rotated. Alternatively a single array can be used.\n"
#~ "\n"
#~ "* The @type parameter, which defaults to +1, controls the search:\n"
#~ "* If @type = 1, MATCH finds largest value <= @seek.\n"
#~ "* If @type = 0, MATCH finds first value == @seek.\n"
#~ "* If @type = -1, MATCH finds smallest value >= @seek.\n"
#~ "* For @type = 0, the data can be in any order.  * For @type = -1 and "
#~ "@type = +1, the data must be sorted.  (And in these cases, MATCH uses a "
#~ "binary search to locate the index.)\n"
#~ "* If @seek could not be found, #N/A is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=LOOKUP"
#~ msgstr ""
#~ "@FUNCTION=VERGLEICH\n"
#~ "@SYNTAX=VERGLEICH(Begriff,Vektor[,Typ])\n"
#~ "@DESCRIPTION=VERGLEICH liefert den Zeilenindex von @Begriff in @Vektor.\n"
#~ "\n"
#~ "Falls der Bereich länger als dessen Breite ist, wird die Suche umgekehrt. "
#~ "Alternativ kann ein einzelnes Datenfeld verwendet werden.\n"
#~ "\n"
#~ "* Der Parameter @Typ, dessen Vorgabe +1 ist, steuert die Suche:\n"
#~ "* Falls @Typ 1 ist, liefert VERGLEICH den größten Wert <= @Begriff.\n"
#~ "* Falls @Typ 0 ist, liefert VERGLEICH den ersten Wert == @Begriff.\n"
#~ "* Falls @Typ -1 ist, liefert VERGLEICH den kleinsten Wert >= @Begriff.\n"
#~ "* Falls @Typ 0 ist, können die Daten in beliebiger Reihenfolge "
#~ "vorliegen.\n"
#~ "* Falls @Typ 1 oder -1 ist, müssen die Daten sortiert werden (In diesem "
#~ "Fall führt VERGLEICH zum Lokalisieren des Indexes eine Binärsuche "
#~ "durch).\n"
#~ "* Falls @Begriff nicht gefunden werden kann, liefert VERGLEICH #NV.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=VERWEIS"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=INDIRECT\n"
#~ "@SYNTAX=INDIRECT(ref_text[,format])\n"
#~ "@DESCRIPTION=INDIRECT function returns the contents of the cell pointed "
#~ "to by the @ref_text string. The string specifies a single cell reference "
#~ "the format of which is either A1 or R1C1 style. The boolean @format "
#~ "controls how @ref_text is to be interpreted: TRUE (the default) for A1 "
#~ "style and FALSE for R1C1 style.\n"
#~ "\n"
#~ "* If @ref_text is not a valid reference in the style controlled by "
#~ "@format, returns #REF! \n"
#~ "@EXAMPLES=\n"
#~ "If A1 contains 3.14 and A2 contains \"A1\", then\n"
#~ "INDIRECT(A2) equals 3.14.\n"
#~ "\n"
#~ "If B1 contains 23 and A1 contains \"R1C2\", then\n"
#~ "INDIRECT(A1,FALSE) equals 23.\n"
#~ "@SEEALSO=AREAS,INDEX,CELL"
#~ msgstr ""
#~ "@FUNCTION=INDIREKT\n"
#~ "@SYNTAX=INDIREKT(Bez_Text[,Format])\n"
#~ "@DESCRIPTION=INDIREKT liefert den Inhalt der in der Zeichenkette "
#~ "@Bez_Text angegebenen Zelle. @Bez_Text ist ein einzelliger Bezug, der "
#~ "entweder A1- oder R1C1-formatiert ist. Das vorliegende Format wird durch "
#~ "den Boole'schen Parameter @Format bestimmt, dessen Vorgabe A1 ist.\n"
#~ "\n"
#~ "* Falls @Bez_Text kein gültiger Bezug ist, liefert INDIREKT einen #BEZUG!-"
#~ "Fehler\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, A1 enthält 3.14 und A2 A1, dann liefert\n"
#~ "INDIREKT(A2) 3.14.\n"
#~ "\n"
#~ "@SEEALSO=BEREICHE,INDEX,"

#~ msgid ""
#~ "@FUNCTION=INDEX\n"
#~ "@SYNTAX=INDEX(array[,row, col, area])\n"
#~ "@DESCRIPTION=INDEX gives a reference to a cell in the given @array.The "
#~ "cell is pointed out by @row and @col, which count the rows and columns in "
#~ "the array.\n"
#~ "\n"
#~ "* If @row and @col are omitted the are assumed to be 1.\n"
#~ "* If the reference falls outside the range of the @array, INDEX returns a "
#~ "#REF! error.\n"
#~ "\n"
#~ "@EXAMPLES=Let us assume that the cells A1, A2, ..., A5 contain numbers "
#~ "11.4, 17.3, 21.3, 25.9, and 40.1. Then INDEX(A1:A5,4,1,1) equals 25.9\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=INDEX\n"
#~ "@SYNTAX=INDEX(Feld[, Zeile, Spalte, Bereich])\n"
#~ "@DESCRIPTION=INDEX liefert einen Zellbezug im angegebenen Feld @Feld. Die "
#~ "Zelle wird mittels @Zeile und @Spalte angegeben, die die Zeilen und "
#~ "Spalten im Feld zählen.\n"
#~ "\n"
#~ "* Falls @Zeile und @Spalte nicht übergeben werden, wird angenommen, dass "
#~ "sie 1 sind.\n"
#~ "* Falls der Bezug außerhalb des Feldes @Feld liegt, liefert INDEX einen "
#~ "#BEZUG!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=Angenommen, die Zellen A1, A2, ..., A5 enthalten die Zahlen "
#~ "11.4, 17.3, 21.3, 25.9 und 40.1. Dann liefert INDEX(A1:A5,4,1,1) 25.9\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=COLUMNNUMBER\n"
#~ "@SYNTAX=COLUMNNUMBER(name)\n"
#~ "@DESCRIPTION=COLUMNNUMBER function returns an integer corresponding to "
#~ "the column name supplied as a string.\n"
#~ "\n"
#~ "* If @name is invalid, COLUMNNUMBER returns the #VALUE! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COLUMNNUMBER(\"E\") equals 5.\n"
#~ "\n"
#~ "@SEEALSO=ADDRESS"
#~ msgstr ""
#~ "@FUNCTION=SPALTENNUMMER\n"
#~ "@SYNTAX=SPALTENNUMMER(Name)\n"
#~ "@DESCRIPTION=SPALTENNUMMER liefert eine Ganzzahl, die dem als "
#~ "Zeichenkette übergebenen Spaltennamen entspricht.\n"
#~ "\n"
#~ "* Falls @Name ungültig ist, liefert SPALTEN einen #WERT!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "SPALTENANZAHL(\"E\") liefert 5.\n"
#~ "\n"
#~ "@SEEALSO=ADRESSE"

#~ msgid ""
#~ "@FUNCTION=COLUMNS\n"
#~ "@SYNTAX=COLUMNS(reference)\n"
#~ "@DESCRIPTION=COLUMNS function returns the number of columns in area or "
#~ "array reference.\n"
#~ "\n"
#~ "* If @reference is neither an array nor a reference nor a range, COLUMNS "
#~ "returns #VALUE! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COLUMNS(H2:J3) equals 3.\n"
#~ "\n"
#~ "@SEEALSO=COLUMN,ROW,ROWS"
#~ msgstr ""
#~ "@FUNCTION=SPALTEN\n"
#~ "@SYNTAX=SPALTEN(Bezug)\n"
#~ "@DESCRIPTION=SPALTEN liefert die Anzahl der Spalten im Bereich oder dem "
#~ "Feldbezug.\n"
#~ "\n"
#~ "* Falls @Bezug weder ein Feld, noch ein Bezug oder Bereich ist, liefert "
#~ "SPALTEN einen #WERT!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "SPALTEN(H2:J3) liefert 3.\n"
#~ "\n"
#~ "@SEEALSO=SPALTE, ZEILE, ZEILEN"

#~ msgid ""
#~ "@FUNCTION=OFFSET\n"
#~ "@SYNTAX=OFFSET(range,row,col[,height[,width]])\n"
#~ "@DESCRIPTION=OFFSET function returns a cell range. The cell range starts "
#~ "at offset (@row,@col) from @range, and is of height @height and width "
#~ "@width.\n"
#~ "\n"
#~ "* If @range is neither a reference nor a range, OFFSET returns #VALUE!.\n"
#~ "* If either @height or @width is omitted, the height or width of the "
#~ "reference is used.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=COLUMN,COLUMNS,ROWS,INDEX,INDIRECT,ADDRESS"
#~ msgstr ""
#~ "@FUNCTION=BEREICH.VERSCHIEBEN\n"
#~ "@SYNTAX=BEREICH.VERSCHIEBEN(Bereich,Zeilen,Spalten,Höhe,Breite)\n"
#~ "@DESCRIPTION=BEREICH.VERSCHIEBEN liefert einen Zellbereich. Der "
#~ "Zellbereich beginnt bei der Position (@Zeilen,@Spalten) von @Bereich, und "
#~ "ist @Höhe hoch und @Breite breit.\n"
#~ "\n"
#~ "* Falls @Bereich weder eine Referenz noch ein Bereich ist, liefert "
#~ "BEREICH.VERSCHIEBEN einen #WERT!-Fehler.\n"
#~ "* Falls Höhe oder Breite nicht übergeben werden, wird die Höhe bzw. "
#~ "Breite der Referenz verwendet.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=SPALTE, SPALTEN, ZEILE, ZEILEN, INDEX, INDIREKT, ADRESSE"

#~ msgid ""
#~ "@FUNCTION=ROWS\n"
#~ "@SYNTAX=ROWS(reference)\n"
#~ "@DESCRIPTION=ROWS function returns the number of rows in area or array "
#~ "reference.\n"
#~ "\n"
#~ "* If @reference is neither an array nor a reference nor a range, ROWS "
#~ "returns #VALUE! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ROWS(H7:I13) equals 7.\n"
#~ "\n"
#~ "@SEEALSO=COLUMN,COLUMNS,ROW"
#~ msgstr ""
#~ "@FUNCTION=ZEILEN\n"
#~ "@SYNTAX=ZEILEN([Bezug])\n"
#~ "@DESCRIPTION=ZEILEN liefert ein Feld mit der Anzahl der Zellen im "
#~ "Bereichs- oder Feldbezug.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ZEILEN(H7:I13) liefert 7.\n"
#~ "\n"
#~ "@SEEALSO=SPALTE,SPALTEN,ZEILE"

#~ msgid ""
#~ "@FUNCTION=HYPERLINK\n"
#~ "@SYNTAX=HYPERLINK(link_location[,optional_label])\n"
#~ "@DESCRIPTION=HYPERLINK function currently returns its 2nd argument, or if "
#~ "that is omitted the 1st argument.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "HYPERLINK(\"www.gnome.org\",\"GNOME\").\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=VERKNÜPFUNG\n"
#~ "@SYNTAX=VERKNÜPFUNG(Ort[,Beschriftung])\n"
#~ "@DESCRIPTION=VERKNÜPFUNG liefert im Augenblick das zweite, oder, falls "
#~ "dieses nicht übergeben wurde, das erste Argument.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "VERKNÜPFUNG(\"www.gnome.de\",\"GNOME Deutschland\").\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=TRANSPOSE\n"
#~ "@SYNTAX=TRANSPOSE(matrix)\n"
#~ "@DESCRIPTION=TRANSPOSE function returns the transpose of the input "
#~ "@matrix.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=MMULT"
#~ msgstr ""
#~ "@FUNCTION=MTRANS\n"
#~ "@SYNTAX=MTRANS(Matrix)\n"
#~ "@DESCRIPTION=MTRANS liefert die Transponierte der Eingabematrix @Matrix.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=MMULT"

#~ msgid ""
#~ "@FUNCTION=GCD\n"
#~ "@SYNTAX=GCD(number1,number2,...)\n"
#~ "@DESCRIPTION=GCD returns the greatest common divisor of given numbers.\n"
#~ "\n"
#~ "* If any of the arguments is less than one, GCD returns #NUM! error.\n"
#~ "* If any of the arguments is non-integer, it is truncated.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "GCD(470,770) equals 10.\n"
#~ "GCD(470,770,1495) equals 5.\n"
#~ "\n"
#~ "@SEEALSO=LCM"
#~ msgstr ""
#~ "@FUNCTION=GGT\n"
#~ "@SYNTAX=GGT(Zahl1,Zahl2,...)\n"
#~ "@DESCRIPTION=GGT liefert den größten gemeinsamen Teiler der übergebenen "
#~ "Zahlen.\n"
#~ "\n"
#~ "* Falls eines der Argumente negativ ist, liefert GGT einen #ZAHL!-"
#~ "Fehler.\n"
#~ "* Falls eines der Argumente nicht ganzzahlig ist, werden die "
#~ "Nachkommastellen abgeschnitten.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "GGT(470,770) liefert 10.\n"
#~ "GGT(470,770,1495) liefert 5.\n"
#~ "\n"
#~ "@SEEALSO=KGV"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=LCM\n"
#~ "@SYNTAX=LCM(number1,number2,...)\n"
#~ "@DESCRIPTION=LCM returns the least common multiple of integers.  The "
#~ "least common multiple is the smallest positive number that is a multiple "
#~ "of all integer arguments given.\n"
#~ "\n"
#~ "* If any of the arguments is less than one, LCM returns #NUM!.\n"
#~ "* If any of the arguments is non-integer, it is truncated.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LCM(2,13) equals 26.\n"
#~ "LCM(4,7,5) equals 140.\n"
#~ "\n"
#~ "@SEEALSO=GCD"
#~ msgstr ""
#~ "@FUNCTION=KGV\n"
#~ "@SYNTAX=KGV(Zahl1,Zahl2,...)\n"
#~ "@DESCRIPTION=KGV liefert das kleinste gemeinsame Vielfache von "
#~ "Ganzzahlen. Das kleinste gemeinsame Vielfache ist die kleinste positive "
#~ "Zahl, die Vielfache aller übergebenen ganzzahligen Argumente ist.\n"
#~ "\n"
#~ "* Falls eines der Argumente negativ ist, liefert KGV einen #ZAHL!-"
#~ "Fehler.\n"
#~ "* Falls eines der Argumente keine Ganzzahl ist, werden deren "
#~ "Nachkommastellen abgeschnitten.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "KGV(2,13) liefert 26.\n"
#~ "KGV(4,7,5) liefert 140.\n"
#~ "\n"
#~ "@SEEALSO=GGT"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=HYPOT\n"
#~ "@SYNTAX=HYPOT(number1,number2,...)\n"
#~ "@DESCRIPTION=HYPOT returns the square root of the sum of the squares of "
#~ "the arguments.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "HYPOT(3,4) equals 5.\n"
#~ "\n"
#~ "@SEEALSO=MIN,MAX"
#~ msgstr ""
#~ "@FUNCTION=UNGERADE\n"
#~ "@SYNTAX=UNGERADE(Zahl)\n"
#~ "@DESCRIPTION=UNGERADE liefert @Zahl auf die nächste ungerade Ganzzahl "
#~ "gerundet.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "UNGERADE(4.4) liefert 5.\n"
#~ "\n"
#~ "@SEEALSO=GERADE"

#~ msgid ""
#~ "@FUNCTION=ABS\n"
#~ "@SYNTAX=ABS(b1)\n"
#~ "@DESCRIPTION=ABS implements the Absolute Value function:  the result is "
#~ "to drop the negative sign (if present).  This can be done for integers "
#~ "and floating point numbers.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ABS(7) equals 7.\n"
#~ "ABS(-3.14) equals 3.14.\n"
#~ "\n"
#~ "@SEEALSO=CEIL, CEILING, FLOOR, INT, MOD"
#~ msgstr ""
#~ "@FUNCTION=ABS\n"
#~ "@SYNTAX=ABS(b1)\n"
#~ "@DESCRIPTION=ABS liefert den Absoluten Wert von b1: Das Ergebnis verliert "
#~ "das negative Vorzeichen (falls vorhanden). Dies funktioniert mit "
#~ "Ganzzahlen und Fließkomma-Zahlen.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ABS(7) liefert 7.\n"
#~ "ABS(-3.14) liefert 3.14.\n"
#~ "\n"
#~ "@SEEALSO=OBERGRENZE, UNTERGRENZE"

#~ msgid ""
#~ "@FUNCTION=ACOS\n"
#~ "@SYNTAX=ACOS(x)\n"
#~ "@DESCRIPTION=ACOS function calculates the arc cosine of @x; that is the "
#~ "value whose cosine is @x.\n"
#~ "\n"
#~ "* The value it returns is in radians.\n"
#~ "* If @x falls outside the range -1 to 1, ACOS returns the #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ACOS(0.1) equals 1.470629.\n"
#~ "ACOS(-0.1) equals 1.670964.\n"
#~ "\n"
#~ "@SEEALSO=COS, SIN, DEGREES, RADIANS"
#~ msgstr ""
#~ "@FUNCTION=ARCCOS\n"
#~ "@SYNTAX=ARCCOS(x)\n"
#~ "@DESCRIPTION=ARCCOS liefert den Arcus Cosinus von @x; Das ist der Wert, "
#~ "dessen Cosinus @x ist.\n"
#~ "\n"
#~ "* Der gelieferte Wert ist ein Bogenmaß.\n"
#~ "* Falls @x außerhalb von -1 bis 1 liegt, liefert ARCCOS einen #ZAHL!-"
#~ "Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ARCCOS(0.1) liefert 1.470629.\n"
#~ "ARCCOS(-0.1) liefert 1.670964.\n"
#~ "\n"
#~ "@SEEALSO=COS, SIN, GRAD, BOGENMASS"

#~ msgid ""
#~ "@FUNCTION=ACOSH\n"
#~ "@SYNTAX=ACOSH(x)\n"
#~ "@DESCRIPTION=ACOSH  function  calculates  the inverse hyperbolic cosine "
#~ "of @x; that is the value whose hyperbolic cosine is @x.\n"
#~ "\n"
#~ "* If @x is less than 1.0, ACOSH() returns the #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ " \n"
#~ "@EXAMPLES=\n"
#~ "ACOSH(2) equals 1.31696.\n"
#~ "ACOSH(5.3) equals 2.35183.\n"
#~ "\n"
#~ "@SEEALSO=ACOS, ASINH, DEGREES, RADIANS "
#~ msgstr ""
#~ "@FUNCTION=ARCCOSHYP\n"
#~ "@SYNTAX=ARCCOSHYP(x)\n"
#~ "@DESCRIPTION=ARCCOSHYP liefert den hyperbolischen Arcus Sinus von @x; das "
#~ "ist der Wert, dessen hyperbolischer Cosinus @x ist.\n"
#~ "\n"
#~ "* Falls @x kleiner als 1.0 ist, liefert ACOSHYP einen #ZAHL!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ARCSINHYP(0.5) liefert 1.31696.\n"
#~ "ARCSINHYP(0.8) liefert 2.35183.\n"
#~ "\n"
#~ "@SEEALSO=ARCCOS, ARCSINHYP, GRAD, BOGENMASS"

#~ msgid ""
#~ "@FUNCTION=ASIN\n"
#~ "@SYNTAX=ASIN(x)\n"
#~ "@DESCRIPTION=ASIN function calculates the arc sine of @x; that is the "
#~ "value whose sine is @x.\n"
#~ "\n"
#~ "* If @x falls outside the range -1 to 1, ASIN returns the #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ASIN(0.5) equals 0.523599.\n"
#~ "ASIN(1) equals 1.570797.\n"
#~ "\n"
#~ "@SEEALSO=SIN, COS, ASINH, DEGREES, RADIANS"
#~ msgstr ""
#~ "@FUNCTION=ARCSIN\n"
#~ "@SYNTAX=ARCSIN(x)\n"
#~ "@DESCRIPTION=ARCSIN liefert den Arcus Sinus von @x; Das ist der Wert, "
#~ "dessen Sinus @x ist.\n"
#~ "\n"
#~ "* Falls @x außerhalb von -1 bis 1 liegt, liefert ARCSIN einen #ZAHL!-"
#~ "Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ARCSIN(0.5) liefert 0.523599.\n"
#~ "ARCSIN(1) liefert 1.570797.\n"
#~ "@SEEALSO=SIN, COS, ARCSINHYP, GRAD, BOGENMASS"

#~ msgid ""
#~ "@FUNCTION=ASINH\n"
#~ "@SYNTAX=ASINH(x)\n"
#~ "@DESCRIPTION=ASINH function calculates the inverse hyperbolic sine of @x; "
#~ "that is the value whose hyperbolic sine is @x.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ASINH(0.5) equals 0.481212.\n"
#~ "ASINH(1.0) equals 0.881374.\n"
#~ "\n"
#~ "@SEEALSO=ASIN, ACOSH, SIN, COS, DEGREES, RADIANS"
#~ msgstr ""
#~ "@FUNCTION=ARCSINHYP\n"
#~ "@SYNTAX=ARCSINHYP(x)\n"
#~ "@DESCRIPTION=ARCSINHYP liefert den hyperbolischen Arcus Sinus von @x; das "
#~ "ist der Wert, dessen hyperbolischer Sinus @x ist.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ARCSINHYP(0.5) liefert 0.481212.\n"
#~ "ARCSINHYP(0.8) liefert 0.881374.\n"
#~ "\n"
#~ "@SEEALSO=ARCSIN, ARCCOSHYP, SIN, COS, GRAD, BOGENMASS"

#~ msgid ""
#~ "@FUNCTION=ATAN\n"
#~ "@SYNTAX=ATAN(x)\n"
#~ "@DESCRIPTION=ATAN function calculates the arc tangent of @x; that is the "
#~ "value whose tangent is @x.\n"
#~ "\n"
#~ "* Return value is in radians.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ATAN(0.5) equals 0,463648.\n"
#~ "ATAN(1) equals 0,785398.\n"
#~ "\n"
#~ "@SEEALSO=TAN, COS, SIN, DEGREES, RADIANS"
#~ msgstr ""
#~ "@FUNCTION=ARCTAN\n"
#~ "@SYNTAX=ARCTAN(x)\n"
#~ "@DESCRIPTION=ARCTAN liefert den Arcus Tangens von @x; das ist der Wert, "
#~ "dessen Tangens @x ist.\n"
#~ "\n"
#~ "* Rückgabewert ist im Bogenmaß.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ARCTAN(0.5) liefert 0.463648.\n"
#~ "ARCTAN(1) liefert 0.785398.\n"
#~ "\n"
#~ "@SEEALSO=TAN, COS, SIN, GRAD, BOGENMASS"

#~ msgid ""
#~ "@FUNCTION=ATANH\n"
#~ "@SYNTAX=ATANH(x)\n"
#~ "@DESCRIPTION=ATANH function calculates the inverse hyperbolic tangent of "
#~ "@x; that is the value whose hyperbolic tangent is @x.\n"
#~ "\n"
#~ "* If the absolute value of @x is greater than 1.0, ATANH returns #NUM! "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ATANH(0.5) equals 0.549306.\n"
#~ "ATANH(0.8) equals 1.098612.\n"
#~ "\n"
#~ "@SEEALSO=ATAN, TAN, SIN, COS, DEGREES, RADIANS"
#~ msgstr ""
#~ "@FUNCTION=ARCTANHYP\n"
#~ "@SYNTAX=ARCTANHYP(x)\n"
#~ "@DESCRIPTION=ARCTANHYP liefert den hyperbolischen Arcus Tangens von @x; "
#~ "das ist der Wert, dessen hyperbolischer Tangens @x ist.\n"
#~ "\n"
#~ "* Falls der absolute Wert von @x größer als 1.0 ist, liefert ARCTANHYP "
#~ "einen #ZAHL!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ARCTANHYP(0.5) liefert 0.549306.\n"
#~ "ARCTANHYP(0.8) liefert 1.098612.\n"
#~ "\n"
#~ "@SEEALSO=ARCTAN, TAN, SIN, COS, GRAD, BOGENMASS"

#~ msgid ""
#~ "@FUNCTION=ATAN2\n"
#~ "@SYNTAX=ATAN2(b1,b2)\n"
#~ "@DESCRIPTION=ATAN2 function calculates the arc tangent of the two "
#~ "variables @b1 and @b2.  It is similar to calculating the arc tangent of "
#~ "@b2 / @b1, except that the signs of both arguments are used to determine "
#~ "the quadrant of the result.\n"
#~ "\n"
#~ "* The result is in radians.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ATAN2(0.5,1.0) equals 1.107149.\n"
#~ "ATAN2(-0.5,2.0) equals 1.815775.\n"
#~ "\n"
#~ "@SEEALSO=ATAN, ATANH, COS, SIN, DEGREES, RADIANS"
#~ msgstr ""
#~ "@FUNCTION=ARCTAN2\n"
#~ "@SYNTAX=ARCTAN2(b1,b2)\n"
#~ "@DESCRIPTION=ATAN2 liefert den Arcus Tangens der beiden Variablen @b1 und "
#~ "@b2. Es ist dem Berechnen des Arcus Tangens von @b2 / @b1 ähnlich, außer, "
#~ "dass es die Vorzeichen beide Argumente verwendet, um den "
#~ "Lösungsquadranten zu ermitteln.\n"
#~ "\n"
#~ "* Das Ergebnis wird im Gradmaß geliefert.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ARCTAN2(0.5,1.0) liefert 1.107149.\n"
#~ "ARCTAN2(-0.5,2.0) liefert 1.815775.\n"
#~ "\n"
#~ "@SEEALSO=ARCTAN, ARCTANHYP, COS, SIN, GRAD, BOGENMASS"

#~ msgid ""
#~ "@FUNCTION=CEIL\n"
#~ "@SYNTAX=CEIL(x)\n"
#~ "@DESCRIPTION=CEIL function rounds @x up to the next nearest integer.\n"
#~ "\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CEIL(0.4) equals 1.\n"
#~ "CEIL(-1.1) equals -1.\n"
#~ "CEIL(-2.9) equals -2.\n"
#~ "\n"
#~ "@SEEALSO=CEILING, FLOOR, ABS, INT, MOD"
#~ msgstr ""
#~ "@FUNCTION=AUFRUNDEN\n"
#~ "@SYNTAX=AUFRUNDEN(x)\n"
#~ "@DESCRIPTION=AUFRUNDEN rundet @x auf die nächste Ganzzahl auf.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "AUFRUNDEN(0.4) liefert 1.\n"
#~ "AUFRUNDEN(-1.1) liefert -1.\n"
#~ "AUFRUNDEN(-2.9) liefert -2.\n"
#~ "\n"
#~ "@SEEALSO=ABS, ABRUNDEN, GANZZAHL"

#~ msgid ""
#~ "@FUNCTION=COUNTIF\n"
#~ "@SYNTAX=COUNTIF(range,criteria)\n"
#~ "@DESCRIPTION=COUNTIF function counts the number of cells in the given "
#~ "@range that meet the given @criteria.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 23, 27, 28, "
#~ "33, and 39.  Then\n"
#~ "COUNTIF(A1:A5,\"<=28\") equals 3.\n"
#~ "COUNTIF(A1:A5,\"<28\") equals 2.\n"
#~ "COUNTIF(A1:A5,\"28\") equals 1.\n"
#~ "COUNTIF(A1:A5,\">28\") equals 2.\n"
#~ "\n"
#~ "@SEEALSO=COUNT,SUMIF"
#~ msgstr ""
#~ "@FUNCTION=ZÄHLENWENN\n"
#~ "@SYNTAX=ZÄHLENWENN(Bereich,Kriterium)\n"
#~ "@DESCRIPTION=ZÄHLENWENN zählt die Anzahl der Zellen im angegebenen "
#~ "Bereich @Bereich, die dem angegebenen Kriterium @Kriterium entsprechen.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, die Zellen A1, A2, ..., A5 enthalten die Zahlen 23, 27, 28, "
#~ "33 und 39. Dann liefert\n"
#~ "ZÄHLENWENN(A1:A5,\"<=28\") 3,\n"
#~ "ZÄHLENWENN(A1:A5,\"<28\") 2,\n"
#~ "ZÄHLENWENN(A1:A5,\"28\") 1 und\n"
#~ "ZÄHLENWENN(A1:A5,\">28\") 2.\n"
#~ "\n"
#~ "@SEEALSO=ZÄHLEN, SUMMEWENN"

#~ msgid ""
#~ "@FUNCTION=SUMIF\n"
#~ "@SYNTAX=SUMIF(range,criteria[,actual_range])\n"
#~ "@DESCRIPTION=SUMIF function sums the values in the given @range that meet "
#~ "the given @criteria.  If @actual_range is given, SUMIF sums the values in "
#~ "the @actual_range whose corresponding components in @range meet the given "
#~ "@criteria.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 23, 27, 28, "
#~ "33, and 39.  Then\n"
#~ "SUMIF(A1:A5,\"<=28\") equals 78.\n"
#~ "SUMIF(A1:A5,\"<28\") equals 50.\n"
#~ "In addition, if the cells B1, B2, ..., B5 hold numbers 5, 3, 2, 6, and 7 "
#~ "then:\n"
#~ "SUMIF(A1:A5,\"<=27\",B1:B5) equals 8.\n"
#~ "\n"
#~ "@SEEALSO=COUNTIF, SUM"
#~ msgstr ""
#~ "@FUNCTION=SUMMEWENN\n"
#~ "@SYNTAX=SUMMEWENN(Bereich,Kriterium[,Tatsächlicher_Bereich)\n"
#~ "@DESCRIPTION=SUMMEWENN liefert die Summe der Werte im angegebenen Bereich "
#~ "@Bereich, die dem angegebenen Kriterium @Kriterium entsprechen. Falls "
#~ "@Tatsächlicher_Bereich übergeben ist, addiert SUMMEWENN die Werte in "
#~ "@Tatsächlicher_Bereich, deren entsprechende Komponenten in @Bereich dem "
#~ "angegebenen @Kriterium entsprechen.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, die Zellen A1, A2, ..., A5 enthalten die Zahlen 23, 27, 28, "
#~ "33 und 39. Dann liefert\n"
#~ "SUMMEWENN(A1:A5,\"<=28\") 78 und\n"
#~ "SUMMEWENN(A1:A5,\"<28\") 50.\n"
#~ "Falls zusätzlich die Zellen B1, B2, ..., B5 die Zahlen 5, 3, 2, 6 und 7 "
#~ "enthalten, liefert:\n"
#~ "SUMMEWENN(A1:A5,\"<=27\",B1:B5) 8.\n"
#~ "\n"
#~ "@SEEALSO=ZÄHLENWENN, SUMME"

#~ msgid ""
#~ "@FUNCTION=CEILING\n"
#~ "@SYNTAX=CEILING(x[,significance])\n"
#~ "@DESCRIPTION=CEILING function rounds @x up to the nearest multiple of "
#~ "@significance.\n"
#~ "\n"
#~ "* If @x or @significance is non-numeric CEILING returns #VALUE! error.\n"
#~ "* If @x and @significance have different signs CEILING returns #NUM! "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CEILING(2.43,1) equals 3.\n"
#~ "CEILING(123.123,3) equals 126.\n"
#~ "\n"
#~ "@SEEALSO=CEIL, FLOOR, ABS, INT, MOD"
#~ msgstr ""
#~ "@FUNCTION=OBERGRENZE\n"
#~ "@SYNTAX=OBERGRENZE(x,Signifikanz)\n"
#~ "@DESCRIPTION=OBERGRENZE rundet @x auf die nächste Vielfache von "
#~ "@Signifikanz auf.\n"
#~ "\n"
#~ "* Falls @x oder @Signifikanz keine Zahl ist, liefert OBERGRENZE einen "
#~ "#WERT!-Fehler.\n"
#~ "* Falls @x und @Signifikanz unterschiedliche Vorzeichen haben, liefert "
#~ "OBERGRENZE einen #ZAHL!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "OBERGRENZE(2.43,1) liefert 3.\n"
#~ "OBERGRENZE(123.123,3) liefert 126\n"
#~ "\n"
#~ "@SEEALSO=AUFRUNDEN"

#~ msgid ""
#~ "@FUNCTION=COS\n"
#~ "@SYNTAX=COS(x)\n"
#~ "@DESCRIPTION=COS function returns the cosine of @x, where @x is given in "
#~ "radians.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COS(0.5) equals 0.877583.\n"
#~ "COS(1) equals 0.540302.\n"
#~ "\n"
#~ "@SEEALSO=COSH, SIN, SINH, TAN, TANH, RADIANS, DEGREES"
#~ msgstr ""
#~ "@FUNCTION=COS\n"
#~ "@SYNTAX=COS(x)\n"
#~ "@DESCRIPTION=COS liefert den Cosinus von @x, wobei @x im Bogenmaß "
#~ "angegeben wird.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COS(0.5) liefert 0.877583.\n"
#~ "COS(1) liefert 0.540302.\n"
#~ "\n"
#~ "@SEEALSO=COSHYP, SIN, SINHYP, TAN, TANHYP, BOGENMASS, GRAD"

#~ msgid ""
#~ "@FUNCTION=COSH\n"
#~ "@SYNTAX=COSH(x)\n"
#~ "@DESCRIPTION=COSH function returns the hyperbolic cosine of @x, which is "
#~ "defined mathematically as\n"
#~ "\n"
#~ "\t(exp(@x) + exp(-@x)) / 2.\n"
#~ "\n"
#~ "* @x is in radians.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COSH(0.5) equals 1.127626.\n"
#~ "COSH(1) equals 1.543081.\n"
#~ "\n"
#~ "@SEEALSO=COS, SIN, SINH, TAN, TANH, RADIANS, DEGREES, EXP"
#~ msgstr ""
#~ "@FUNCTION=COSHYP\n"
#~ "@SYNTAX=COSHYP(x)\n"
#~ "@DESCRIPTION=COSHYP liefert den hyperbolischen Cosinus von @x, der "
#~ "mathematisch definiert ist als\n"
#~ "\n"
#~ "\t(EXP(@x) + EXP(-@x)) / 2.\n"
#~ "\n"
#~ "definiert ist.\n"
#~ "* @x muss im Gradmaß übergeben werden.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COSHYP(0.5) liefert 1.127626.\n"
#~ "COSHYP(1) liefert 1.543081.\n"
#~ "\n"
#~ "@SEEALSO=COS, SIN, SINHYP, TAN, TANHYP, GRAD, BOGENMASS, EXP"

#~ msgid ""
#~ "@FUNCTION=DEGREES\n"
#~ "@SYNTAX=DEGREES(x)\n"
#~ "@DESCRIPTION=DEGREES computes the number of degrees equivalent to @x "
#~ "radians.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DEGREES(2.5) equals 143.2394.\n"
#~ "\n"
#~ "@SEEALSO=RADIANS, PI"
#~ msgstr ""
#~ "@FUNCTION=GRAD\n"
#~ "@SYNTAX=GRAD(x)\n"
#~ "@DESCRIPTION=GRAD liefert die zum Radius @x äquivalente Gradanzahl.\n"
#~ "\n"
#~ "Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "GRAD(2.5) liefert 143.2394.\n"
#~ "\n"
#~ "@SEEALSO=BOGENMASS, PI"

# FIXME: check for mathematical correctness
#~ msgid ""
#~ "@FUNCTION=EXP\n"
#~ "@SYNTAX=EXP(x)\n"
#~ "@DESCRIPTION=EXP computes the value of e (the base of natural logarithms) "
#~ "raised to the power of @x.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "EXP(2) equals 7.389056.\n"
#~ "\n"
#~ "@SEEALSO=LOG, LOG2, LOG10"
#~ msgstr ""
#~ "@FUNCTION=EXP\n"
#~ "@SYNTAX=EXP(x)\n"
#~ "@DESCRIPTION=EXP berechnet den Wert von e (der Basis des natürlichen "
#~ "Logarithmus) potenziert mit @x.\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "EXP(2) liefert 7.389056.\n"
#~ "\n"
#~ "@SEEALSO=LOG, LOG2, LOG10"

# FIXME: check for mathematical correctness
#~ msgid ""
#~ "@FUNCTION=EXPM1\n"
#~ "@SYNTAX=EXPM1(x)\n"
#~ "@DESCRIPTION=EXPM1 computes EXP(@x)-1 with higher resulting precision "
#~ "than the direct formula.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "EXPM1(0.01) equals 0.01005.\n"
#~ "\n"
#~ "@SEEALSO=EXP, LN1P"
#~ msgstr ""
#~ "@FUNCTION=EXP\n"
#~ "@SYNTAX=EXP(x)\n"
#~ "@DESCRIPTION=EXP berechnet den Wert von e (der Basis des natürlichen "
#~ "Logarithmus) potenziert mit @x.\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "EXP(2) liefert 7.389056.\n"
#~ "\n"
#~ "@SEEALSO=LOG, LOG2, LOG10"

#~ msgid ""
#~ "@FUNCTION=FACT\n"
#~ "@SYNTAX=FACT(x)\n"
#~ "@DESCRIPTION=FACT computes the factorial of @x. ie, @x!\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FACT(3) equals 6.\n"
#~ "FACT(9) equals 362880.\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=FAKTULTÄT\n"
#~ "@SYNTAX=FAKULTÄT(x)\n"
#~ "@DESCRIPTION=FAKULTÄT liefert die Fakultät von @x, also @x!\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FAKULTÄT(3) liefert 6.\n"
#~ "FAKULTÄT(9) liefert 362880.\n"
#~ "\n"
#~ "@SEEALSO="

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=BETA\n"
#~ "@SYNTAX=BETA(a,b)\n"
#~ "@DESCRIPTION=BETA function returns the value of the mathematical beta "
#~ "function extended to all real numbers except 0 and negative integers.\n"
#~ "\n"
#~ "* If @a, @b, or (@a + @b) are non-positive integers, BETA returns #NUM! "
#~ "error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BETA(2,3) equals 0.083333.\n"
#~ "BETA(-0.5,0.5) equals #NUM!.\n"
#~ "\n"
#~ "@SEEALSO=BETALN,GAMMALN"
#~ msgstr ""
#~ "@FUNCTION=BETA\n"
#~ "@SYNTAX=BETA(a,b)\n"
#~ "@DESCRIPTION=BETA liefert den Wert der mathematischen Beta-Funktion, "
#~ "wobei diese auf alle rellen Zahlen außer 0 und nicht negative Ganzzahlen "
#~ "ausgeweitet wird.\n"
#~ "\n"
#~ "* Falls @a, @b oder (@a + @b) keine negative Ganzzahl ist, liefert BETA "
#~ "einen #ZAHL!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=BETALN,GAMMALN"

#~ msgid ""
#~ "@FUNCTION=BETALN\n"
#~ "@SYNTAX=BETALN(a,b)\n"
#~ "@DESCRIPTION=BETALN function returns the natural logarithm of the "
#~ "absolute value of the beta function.\n"
#~ "\n"
#~ "* If @a, @b, or (@a + @b) are non-positive integers, BETALN returns "
#~ "#NUM! \n"
#~ "@EXAMPLES=\n"
#~ "BETALN(2,3) equals -2.48.\n"
#~ "BETALN(-0.5,0.5) equals #NUM!.\n"
#~ "\n"
#~ "@SEEALSO=BETA,GAMMALN"
#~ msgstr ""
#~ "@FUNCTION=BETALN\n"
#~ "@SYNTAX=BETALN(a,b)\n"
#~ "@DESCRIPTION=BETALN liefert den natürlichen Logarithmus des absoluten "
#~ "Werts der Beta-Funktion.\n"
#~ "\n"
#~ "* Falls @a, @b oder (@a + @b) keine positive Ganzzahl ist, liefert BETALN "
#~ "einen #ZAHL!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=BETA,GAMMALN"

#~ msgid ""
#~ "@FUNCTION=COMBIN\n"
#~ "@SYNTAX=COMBIN(n,k)\n"
#~ "@DESCRIPTION=COMBIN computes the number of combinations.\n"
#~ "\n"
#~ "* Performing this function on a non-integer or a negative number returns "
#~ "#NUM! error.\n"
#~ "* If @n is less than @k COMBIN returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COMBIN(8,6) equals 28.\n"
#~ "COMBIN(6,2) equals 15.\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=KOMBINATIONEN\n"
#~ "@SYNTAX=KOMBINATIONEN(n, k)\n"
#~ "@DESCRIPTION=KOMBINATIONEN berechnet die Anzahl der "
#~ "Kombinationsmöglichkeiten zwischen @n und @k.\n"
#~ "\n"
#~ "* Falls @n oder @k < 0 ist, liefert KOMBINATIONEN einen #ZAHL!-Fehler.\n"
#~ "* Falls @n < @k, liefert KOMBINATIONEN einen #ZAHL!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "@EXAMPLES=\n"
#~ "KOMBINATIONEN(8,6) liefert 28.\n"
#~ "KOMBINATIONEN(6,2) liefert 15.\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=INT\n"
#~ "@SYNTAX=INT(a)\n"
#~ "@DESCRIPTION=INT function returns the largest integer that is not bigger "
#~ "than its argument.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "INT(7.2) equals 7.\n"
#~ "INT(-5.5) equals -6.\n"
#~ "\n"
#~ "@SEEALSO=CEIL, CEILING, FLOOR, ABS, MOD"
#~ msgstr ""
#~ "@FUNCTION=GANZZAHL\n"
#~ "@SYNTAX=GANZZAHL(a)\n"
#~ "@DESCRIPTION=GANZZAHL liefert die größte Ganzzahl, die nicht größer als "
#~ "das Argument ist.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "GANZZAHL(7.2) liefert 7.\n"
#~ "GANZZAHL(-5.5) liefert -6.\n"
#~ "\n"
#~ "@SEEALSO=UNTERGRENZE, OBERGRENZE, ABS"

#~ msgid ""
#~ "@FUNCTION=LOG\n"
#~ "@SYNTAX=LOG(x[,base])\n"
#~ "@DESCRIPTION=LOG computes the logarithm of @x in the given base @base.  "
#~ "If no @base is given LOG returns the logarithm in base 10. @base must be "
#~ "> 0. and cannot equal 1.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LOG(2) equals 0.30103.\n"
#~ "LOG(8192,2) equals 13.\n"
#~ "\n"
#~ "@SEEALSO=LN, LOG2, LOG10"
#~ msgstr ""
#~ "@FUNCTION=LOG\n"
#~ "@SYNTAX=LOG(x[, Basis])\n"
#~ "@DESCRIPTION=LOG berechnet den Logarithmus von @x zur angegebenen Basis "
#~ "@Basis. Falls @Basis nicht übergeben wird, liefert LOG den Logarithmus "
#~ "zur Basis 10.\n"
#~ "\n"
#~ "* @Basis muss > 0 und darf nicht 1 sein.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LOG(2) liefert 0.30103.\n"
#~ "LOG(8192,2) liefert 13.\n"
#~ "\n"
#~ "@SEEALSO=LN, LOG2, LOG10"

#~ msgid ""
#~ "@FUNCTION=LN\n"
#~ "@SYNTAX=LN(x)\n"
#~ "@DESCRIPTION=LN returns the natural logarithm of @x.\n"
#~ "\n"
#~ "* If @x <= 0, LN returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LN(7) equals 1.94591.\n"
#~ "\n"
#~ "@SEEALSO=EXP, LOG2, LOG10"
#~ msgstr ""
#~ "@FUNCTION=LN\n"
#~ "@SYNTAX=LN(x)\n"
#~ "@DESCRIPTION=LN liefert den natürlichen Logarithmus von @x.\n"
#~ "\n"
#~ "* Falls @x <= 0 ist, liefert LN einen #ZAHL!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LN(7) liefert 1.94591.\n"
#~ "\n"
#~ "@SEEALSO=EXP, LOG2, LOG10"

#~ msgid ""
#~ "@FUNCTION=LN1P\n"
#~ "@SYNTAX=LN1P(x)\n"
#~ "@DESCRIPTION=LN1P computes LN(1+@x) with higher resulting precision than "
#~ "the direct formula.\n"
#~ "\n"
#~ "* If @x <= -1, LN1P returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LN1P(0.01) equals 0.00995.\n"
#~ "\n"
#~ "@SEEALSO=LN, EXPM1"
#~ msgstr ""
#~ "@FUNCTION=LOG2\n"
#~ "@SYNTAX=LOG2(x)\n"
#~ "@DESCRIPTION=LOG2 berechnet den Logarithmus von @x zur Basis 2.\n"
#~ "\n"
#~ "* Falls @x <=, liefert LOG10 einen #ZAHL!-Fehler.\n"
#~ "@EXAMPLES=\n"
#~ "LOG2(1024) liefert 10.\n"
#~ "\n"
#~ "@SEEALSO=EXP, LOG, LOG10"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=POWER\n"
#~ "@SYNTAX=POWER(x,y)\n"
#~ "@DESCRIPTION=POWER returns the value of @x raised to the power @y.\n"
#~ "\n"
#~ "\n"
#~ "* If both @x and @y equal 0, POWER returns #NUM! error.\n"
#~ "* If @x = 0 and @y < 0, POWER returns #DIV/0! error.\n"
#~ "* If @x < 0 and @y is non-integer, POWER returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "POWER(2,7) equals 128.\n"
#~ "POWER(3,3.141) equals 31.523749.\n"
#~ "\n"
#~ "@SEEALSO=EXP"
#~ msgstr ""
#~ "@FUNCTION=POTENZ\n"
#~ "@SYNTAX=POTENZ(x,y)\n"
#~ "@DESCRIPTION=POTENZ liefert den Wert von @x potenziert mit @y.\n"
#~ "\n"
#~ "* Falls sowohl @x als auch @y 0 sind, liefert POTENZ einen #ZAHL!-"
#~ "Fehler.\n"
#~ "* Falls @x = 0 und @y < 0 ist, liefert POTENZ einen #DIV/0-Fehler.\n"
#~ "* Falls @x < 0 und @y keine Ganzzahl ist, liefert POTENZ einen #ZAHL-"
#~ "Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "POTENZ(2,7) liefert 128.\n"
#~ "POTENZ(3,3141) liefert 31.523749.\n"
#~ "\n"
#~ "@SEEALSO=EXP"

#~ msgid ""
#~ "@FUNCTION=LOG2\n"
#~ "@SYNTAX=LOG2(x)\n"
#~ "@DESCRIPTION=LOG2 computes the base-2 logarithm of @x.\n"
#~ "\n"
#~ "* If @x <= 0, LOG2 returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LOG2(1024) equals 10.\n"
#~ "\n"
#~ "@SEEALSO=EXP, LOG10, LOG"
#~ msgstr ""
#~ "@FUNCTION=LOG2\n"
#~ "@SYNTAX=LOG2(x)\n"
#~ "@DESCRIPTION=LOG2 berechnet den Logarithmus von @x zur Basis 2.\n"
#~ "\n"
#~ "* Falls @x <=, liefert LOG10 einen #ZAHL!-Fehler.\n"
#~ "@EXAMPLES=\n"
#~ "LOG2(1024) liefert 10.\n"
#~ "\n"
#~ "@SEEALSO=EXP, LOG, LOG10"

#~ msgid ""
#~ "@FUNCTION=LOG10\n"
#~ "@SYNTAX=LOG10(x)\n"
#~ "@DESCRIPTION=LOG10 computes the base-10 logarithm of @x.\n"
#~ "\n"
#~ "* If @x <= 0, LOG10 returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ " \n"
#~ "@EXAMPLES=\n"
#~ "LOG10(7) equals 0.845098.\n"
#~ "\n"
#~ "@SEEALSO=EXP, LOG2, LOG"
#~ msgstr ""
#~ "@FUNCTION=LOG10\n"
#~ "@SYNTAX=LOG10(x)\n"
#~ "@DESCRIPTION=LOG10 berechnet den Logarithmus von @x zur Basis 10.\n"
#~ "\n"
#~ "* Falls @x <= 0 ist, liefert LOG10 einen #ZAHL!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LOG10(7) liefert 0.845098.\n"
#~ "\n"
#~ "@SEEALSO=EXP, LOG, LOG2"

#~ msgid ""
#~ "@FUNCTION=MOD\n"
#~ "@SYNTAX=MOD(number,divisor)\n"
#~ "@DESCRIPTION=MOD function returns the remainder when @divisor is divided "
#~ "into @number.\n"
#~ "\n"
#~ "* MOD returns #DIV/0! if @divisor is zero.\n"
#~ "* This function is Excel compatible.\n"
#~ " \n"
#~ "@EXAMPLES=\n"
#~ "MOD(23,7) equals 2.\n"
#~ "\n"
#~ "@SEEALSO=CEIL, CEILING, FLOOR, ABS, INT, ABS"
#~ msgstr ""
#~ "@FUNCTION=REST\n"
#~ "@SYNTAX=REST(Zahl,Divisor)\n"
#~ "@DESCRIPTION=REST liefert den Rest beim Teilen der Zahl @Zahl durch den "
#~ "Divisor @Divisor.\n"
#~ "* Falls @Divisor = 0 ist, liefert REST einen #DIV/0!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "REST(23,7) liefert 2.\n"
#~ "\n"
#~ "@SEEALSO=GANZZAHL, UNTERGRENZE, OBERGRENZE"

#~ msgid ""
#~ "@FUNCTION=RADIANS\n"
#~ "@SYNTAX=RADIANS(x)\n"
#~ "@DESCRIPTION=RADIANS computes the number of radians equivalent to @x "
#~ "degrees.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RADIANS(180) equals 3.14159.\n"
#~ "\n"
#~ "@SEEALSO=PI,DEGREES"
#~ msgstr ""
#~ "@FUNCTION=BOGENMASS\n"
#~ "@SYNTAX=BOGENMASS(x)\n"
#~ "@DESCRIPTION=BOGENMASS berechnet das Bogenmaß-Äquivalent aus @x Grad.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BOGENMASS(180) liefert 3.14159.\n"
#~ "\n"
#~ "@SEEALSO=PI, GRAD"

#~ msgid ""
#~ "@FUNCTION=SIN\n"
#~ "@SYNTAX=SIN(x)\n"
#~ "@DESCRIPTION=SIN function returns the sine of @x, where @x is given in "
#~ "radians.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "SIN(0.5) equals 0.479426.\n"
#~ "\n"
#~ "@SEEALSO=COS, COSH, SINH, TAN, TANH, RADIANS, DEGREES"
#~ msgstr ""
#~ "@FUNCTION=SIN\n"
#~ "@SYNTAX=SIN(x)\n"
#~ "@DESCRIPTION=SIN liefert den Sinus von @x, wobei @x im Gradmaß angegeben "
#~ "wird.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "SIN(0.5) liefert 0.479426.\n"
#~ "\n"
#~ "@SEEALSO=COS, COSHYP, SINHYP, TAN, TANHYP, BOGENMASS, GRAD"

#~ msgid ""
#~ "@FUNCTION=SINH\n"
#~ "@SYNTAX=SINH(x)\n"
#~ "@DESCRIPTION=SINH function returns the hyperbolic sine of @x, which is "
#~ "defined mathematically as\n"
#~ "\n"
#~ "\t(exp(@x) - exp(-@x)) / 2.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "SINH(0.5) equals 0.521095.\n"
#~ "\n"
#~ "@SEEALSO=SIN, COS, COSH, TAN, TANH, DEGREES, RADIANS, EXP"
#~ msgstr ""
#~ "@FUNCTION=SINHYP\n"
#~ "@SYNTAX=SINHYP(x)\n"
#~ "@DESCRIPTION=SINHYP liefert den hyperbolischen Sinus von @x, der "
#~ "mathematisch definiert ist als\n"
#~ "\n"
#~ "\t(EXP(@x) - EXP(-@x)) /2.\n"
#~ "\n"
#~ "definiert ist.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "SINHYP(0.5) liefert 0.521095.\n"
#~ "\n"
#~ "@SEEALSO=SIN, COS, COSHYP, TAN, TANHYP, BOGENMASS, GRAD, EXP"

#~ msgid ""
#~ "@FUNCTION=SQRT\n"
#~ "@SYNTAX=SQRT(x)\n"
#~ "@DESCRIPTION=SQRT function returns the square root of @x.\n"
#~ "\n"
#~ "* If @x is negative, SQRT returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "SQRT(2) equals 1.4142136.\n"
#~ "\n"
#~ "@SEEALSO=POWER"
#~ msgstr ""
#~ "@FUNCTION=WURZEL\n"
#~ "@SYNTAX=WURZEL(x)\n"
#~ "@DESCRIPTION=WURZEL liefert die Quadratwurzel von @x.\n"
#~ "\n"
#~ "* Falls @x negativ ist, liefert WURZEL einen #ZAHL!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "WURZEL(2) liefert 1.4142136.\n"
#~ "\n"
#~ "@SEEALSO=POTENZ"

#~ msgid ""
#~ "@FUNCTION=SUMSQ\n"
#~ "@SYNTAX=SUMSQ(value1, value2, ...)\n"
#~ "@DESCRIPTION=SUMSQ returns the sum of the squares of all the values and "
#~ "cells referenced in the argument list.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ " \n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11, 15, 17, "
#~ "21, and 43.  Then\n"
#~ "SUMSQ(A1:A5) equals 2925.\n"
#~ "\n"
#~ "@SEEALSO=SUM, COUNT"
#~ msgstr ""
#~ "@FUNCTION=QUADRATESUMME\n"
#~ "@SYNTAX=QUADRATESUMME(Wert1,Wert2, ...)\n"
#~ "@DESCRIPTION=QUADRATESUMME liefert der Summe der Quadrate aller "
#~ "übergebenen Werte und Zellen.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, die Zellen A1, A2, ..., A5 enthalten die Zahlen 11, 15, 17, "
#~ "21 und 43. Dann liefert\n"
#~ "SUMSQ(A1:A5) 2925.\n"
#~ "\n"
#~ "@SEEALSO=SUMME, ANZAHL"

#~ msgid ""
#~ "@FUNCTION=MULTINOMIAL\n"
#~ "@SYNTAX=MULTINOMIAL(value1, value2, ...)\n"
#~ "@DESCRIPTION=MULTINOMIAL returns the ratio of the factorial of a sum of "
#~ "values to the product of factorials.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ " \n"
#~ "@EXAMPLES=\n"
#~ "MULTINOMIAL(2,3,4) equals 1260.\n"
#~ "\n"
#~ "@SEEALSO=SUM"
#~ msgstr ""
#~ "@FUNCTION=MULTINOMIAL\n"
#~ "@SYNTAX=MULTINOMIAL(Wert1,Wert2,...)\n"
#~ "@DESCRIPTION=MULTINOMIAL liefert das Verhältnis der Fakultät einer Summe "
#~ "von Werten zum Produkt der Fakultäten.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "MULTINOMIAL(2,3,4) liefert 1260.\n"
#~ "\n"
#~ "@SEEALSO=SUMME"

#~ msgid ""
#~ "@FUNCTION=G_PRODUCT\n"
#~ "@SYNTAX=G_PRODUCT(value1, value2, ...)\n"
#~ "@DESCRIPTION=G_PRODUCT returns the product of all the values and cells "
#~ "referenced in the argument list.\n"
#~ "\n"
#~ "* Empty cells are ignored and the empty product is 1.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "G_PRODUCT(2,5,9) equals 90.\n"
#~ "\n"
#~ "@SEEALSO=SUM, COUNT"
#~ msgstr ""
#~ "@FUNCTION=G_PRODUKT\n"
#~ "@SYNTAX=G_PRODUKT(Wert1,Wert2[ ,...])\n"
#~ "@DESCRIPTION=G_PRODUCT liefert das Produkt aller übergebenen Werte und "
#~ "Zellen.\n"
#~ "\n"
#~ "* Leere Zellen werden ignoriert und das leere Produkt ist 1.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "G_PRODUKT(2,5,9) liefert 90.\n"
#~ "\n"
#~ "@SEEALSO=SUMME, ANZAHL"

#~ msgid ""
#~ "@FUNCTION=TAN\n"
#~ "@SYNTAX=TAN(x)\n"
#~ "@DESCRIPTION=TAN function returns the tangent of @x, where @x is given in "
#~ "radians.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TAN(3) equals -0.1425465.\n"
#~ "\n"
#~ "@SEEALSO=TANH, COS, COSH, SIN, SINH, DEGREES, RADIANS"
#~ msgstr ""
#~ "@FUNCTION=TAN\n"
#~ "@SYNTAX=TAN(x)\n"
#~ "@DESCRIPTION=TAN liefert den Tangens von @x, wobei @x im Bogenmaß "
#~ "angegeben wird.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TAN(3) liefert -0.1425465.\n"
#~ "\n"
#~ "@SEEALSO=TANHYP, COS, COSHYP, SIN, SINHYP, GRAD, BOGENMASS"

#~ msgid ""
#~ "@FUNCTION=TANH\n"
#~ "@SYNTAX=TANH(x)\n"
#~ "@DESCRIPTION=TANH function returns the hyperbolic tangent of @x, which is "
#~ "defined mathematically as \n"
#~ "\n"
#~ "\tsinh(@x) / cosh(@x).\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TANH(2) equals 0.96402758.\n"
#~ "\n"
#~ "@SEEALSO=TAN, SIN, SINH, COS, COSH, DEGREES, RADIANS"
#~ msgstr ""
#~ "@FUNCTION=TANHYP\n"
#~ "@SYNTAX=TANHYP(x)\n"
#~ "@DESCRIPTION=TANHYP liefert den hyperbolischen Tangens von @x, der "
#~ "mathematisch als\n"
#~ "\n"
#~ "\t(SINHYP(@x) / COSHYP(@x).\n"
#~ "\n"
#~ "definiert ist.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TANHYP(2) liefert 0.96402758.\n"
#~ "\n"
#~ "@SEEALSO=TAN, SIN, SINHYP, COS, COSHYP, GRAD, BOGENMASS"

#~ msgid ""
#~ "@FUNCTION=PI\n"
#~ "@SYNTAX=PI()\n"
#~ "@DESCRIPTION=PI functions returns the value of pi.\n"
#~ "\n"
#~ "* This function is called with no arguments.\n"
#~ "* This function is Excel compatible, except that it returns pi with a "
#~ "better precision.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "PI() equals about 3.141593.\n"
#~ "\n"
#~ "@SEEALSO=SQRTPI"
#~ msgstr ""
#~ "@FUNCTION=PI\n"
#~ "@SYNTAX=PI()\n"
#~ "@DESCRIPTION=PI liefert den Wert von Pi.\n"
#~ "\n"
#~ "* Diese Funktion wird ohne Argumente aufgerufen.\n"
#~ "* Diese Funktion ist Excel-kompatibel, außer der Tatsache, dass sie Pi "
#~ "präziser liefert.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "PI() liefert ungefähr 3.141593.\n"
#~ "\n"
#~ "@SEEALSO=WURZELPI"

#~ msgid ""
#~ "@FUNCTION=TRUNC\n"
#~ "@SYNTAX=TRUNC(number[,digits])\n"
#~ "@DESCRIPTION=TRUNC function returns the value of @number truncated to the "
#~ "number of digits specified.\n"
#~ "\n"
#~ "* If @digits is omitted or negative then @digits defaults to zero.\n"
#~ "* If @digits is not an integer, it is truncated.\n"
#~ "* This function is Excel compatible.\n"
#~ " \n"
#~ "@EXAMPLES=\n"
#~ "TRUNC(3.12) equals 3.\n"
#~ "TRUNC(4.15,1) equals 4.1.\n"
#~ "\n"
#~ "@SEEALSO=INT"
#~ msgstr ""
#~ "@FUNCTION=KÜRZEN\n"
#~ "@SYNTAX=KÜRZEN(Zahl[,Stellen])\n"
#~ "@DESCRIPTION=KÜRZEN liefert den Wert der Zahl @Zahl, wobei diese auf die "
#~ "führenden @Stellen Stellen verkürzt wird.\n"
#~ "\n"
#~ "* Falls @Stellen nicht übergegeben wird, wird die Vorgabe Null "
#~ "angenommen.\n"
#~ "* Falls @Stellen keine Ganzzahl ist, werden die Nachkommastellen "
#~ "abgeschnitten.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "KÜRZEN(3.12) liefert 3.\n"
#~ "KÜRZEN(4.15,1) liefert 4.1.\n"
#~ "\n"
#~ "@SEEALSO=GANZZAHL"

#~ msgid ""
#~ "@FUNCTION=EVEN\n"
#~ "@SYNTAX=EVEN(number)\n"
#~ "@DESCRIPTION=EVEN function returns the number rounded up to the nearest "
#~ "even integer.  Negative numbers are rounded down.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ " \n"
#~ "@EXAMPLES=\n"
#~ "EVEN(5.4) equals 6.\n"
#~ "EVEN(-5.4) equals -6.\n"
#~ "\n"
#~ "@SEEALSO=ODD"
#~ msgstr ""
#~ "@FUNCTION=GERADE\n"
#~ "@SYNTAX=GERADE(Zahl)\n"
#~ "@DESCRIPTION=GERADE liefert @Zahl auf die nächste gerade Ganzzahl "
#~ "gerundet.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "GERADE(5.4) liefert 6.\n"
#~ "\n"
#~ "@SEEALSO=UNGERADE"

#~ msgid ""
#~ "@FUNCTION=ODD\n"
#~ "@SYNTAX=ODD(number)\n"
#~ "@DESCRIPTION=ODD function returns the @number rounded up to the nearest "
#~ "odd integer.  Negative numbers are rounded down.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ " \n"
#~ "@EXAMPLES=\n"
#~ "ODD(4.4) equals 5.\n"
#~ "ODD(-4.4) equals -5.\n"
#~ "\n"
#~ "@SEEALSO=EVEN"
#~ msgstr ""
#~ "@FUNCTION=UNGERADE\n"
#~ "@SYNTAX=UNGERADE(Zahl)\n"
#~ "@DESCRIPTION=UNGERADE liefert @Zahl auf die nächste ungerade Ganzzahl "
#~ "gerundet.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "UNGERADE(4.4) liefert 5.\n"
#~ "\n"
#~ "@SEEALSO=GERADE"

#~ msgid ""
#~ "@FUNCTION=FACTDOUBLE\n"
#~ "@SYNTAX=FACTDOUBLE(number)\n"
#~ "@DESCRIPTION=FACTDOUBLE function returns the double factorial of a "
#~ "@number, i.e., x!!.\n"
#~ "\n"
#~ "* If @number is not an integer, it is truncated.\n"
#~ "* If @number is negative FACTDOUBLE returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ " \n"
#~ "@EXAMPLES=\n"
#~ "FACTDOUBLE(5) equals 15.\n"
#~ "\n"
#~ "@SEEALSO=FACT"
#~ msgstr ""
#~ "@FUNCTION=DOPPELFAKULTÄT\n"
#~ "@SYNTAX=DOPPELFAKULTÄT(Zahl)\n"
#~ "@DESCRIPTION=DOPPELFAKULTÄT liefert die Doppelfakultät einer Zahl @Zahl, "
#~ "also x!!.\n"
#~ "\n"
#~ "* Falls @Zahl keine Ganzzahl ist, werden die Nachkommastellen "
#~ "abgeschnitten.\n"
#~ "* Falls @Zahl negativ ist, liefert DOPPELFAKULTÄT einen #ZAHL!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DOPPELFAKULTÄT(5) liefert 15.\n"
#~ "\n"
#~ "@SEEALSO=FAKULTÄT"

# FIXME: check for mathematical correctness
#~ msgid ""
#~ "@FUNCTION=FIB\n"
#~ "@SYNTAX=FIB(number)\n"
#~ "@DESCRIPTION=FIB function computes Fibonacci numbers.\n"
#~ "\n"
#~ "* If @number is not an integer, it is truncated.\n"
#~ "* If @number is negative or zero FIB returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FIB(12) equals 144.\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=FIB\n"
#~ "@SYNTAX=FIB(Zahl)\n"
#~ "@DESCRIPTION=FIB berechnet Fibonacci-Zahlen.\n"
#~ "\n"
#~ "* Falls @Zahl keine Ganzzahl ist, werden die Nachkommastellen "
#~ "abgeschnitten.\n"
#~ "* Falls @Zahl negativ oder Null ist, liefert FIB einen #ZAHL!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FIB(12) liefert 144.\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=QUOTIENT\n"
#~ "@SYNTAX=QUOTIENT(numerator,denominator)\n"
#~ "@DESCRIPTION=QUOTIENT function returns the integer portion of a "
#~ "division.  @numerator is the divided number and @denominator is the "
#~ "divisor.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ " \n"
#~ "@EXAMPLES=\n"
#~ "QUOTIENT(23,5) equals 4.\n"
#~ "\n"
#~ "@SEEALSO=MOD"
#~ msgstr ""
#~ "@FUNCTION=QUOTIENT\n"
#~ "@SYNTAX=QUOTIENT(Zähler,Nenner)\n"
#~ "@DESCRIPTION=QUOTIENT liefert das den ganzzahligen Anteil einer Division. "
#~ "@Zähler ist der Divident und @Nenner der Divisor.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "QUOTIENT(23,5) liefert 4.\n"
#~ "\n"
#~ "@SEEALSO=REST"

#~ msgid ""
#~ "@FUNCTION=SIGN\n"
#~ "@SYNTAX=SIGN(number)\n"
#~ "@DESCRIPTION=SIGN function returns 1 if the @number is positive, zero if "
#~ "the @number is 0, and -1 if the @number is negative.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ " \n"
#~ "@EXAMPLES=\n"
#~ "SIGN(3) equals 1.\n"
#~ "SIGN(-3) equals -1.\n"
#~ "SIGN(0) equals 0.\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=VORZEICHEN\n"
#~ "@SYNTAX=VORZEICHEN(Zahl)\n"
#~ "@DESCRIPTION=VORZEICHEN liefert 1, falls @Zahl positiv ist, Null, falls "
#~ "@Zahl 0 ist und -1, falls @Zahl negativ ist.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "VORZEICHEN(3) liefert 1.\n"
#~ "VORZEICHEN(-3) liefert -1.\n"
#~ "VORZEICHEN(0) liefert 0.\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=SQRTPI\n"
#~ "@SYNTAX=SQRTPI(number)\n"
#~ "@DESCRIPTION=SQRTPI function returns the square root of a @number "
#~ "multiplied by pi.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "SQRTPI(2) equals 2.506628275.\n"
#~ "\n"
#~ "@SEEALSO=PI"
#~ msgstr ""
#~ "@FUNCTION=WURZELPI\n"
#~ "@SYNTAX=WURZELPI(Zahl)\n"
#~ "@DESCRIPTION=WURZELPI liefert die Quadratwurzel von @Zahl multipliziert "
#~ "mit Pi.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "WURZELPI(2) liefert 2.506628275.\n"
#~ "\n"
#~ "@SEEALSO=PI"

#~ msgid ""
#~ "@FUNCTION=ROUNDDOWN\n"
#~ "@SYNTAX=ROUNDDOWN(number[,digits])\n"
#~ "@DESCRIPTION=ROUNDDOWN function rounds a given @number towards 0.\n"
#~ "\n"
#~ "@number is the number you want rounded toward 0 and @digits is the number "
#~ "of digits to which you want to round that number.\n"
#~ "\n"
#~ "* If @digits is greater than zero, @number is rounded toward 0 to the "
#~ "given number of digits.\n"
#~ "* If @digits is zero or omitted, @number is rounded toward 0 to the next "
#~ "integer.\n"
#~ "* If @digits is less than zero, @number is rounded toward 0 to the left "
#~ "of the decimal point.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ROUNDDOWN(5.5) equals 5.\n"
#~ "ROUNDDOWN(-3.3) equals -3.\n"
#~ "ROUNDDOWN(1501.15,1) equals 1501.1.\n"
#~ "ROUNDDOWN(1501.15,-2) equals 1500.0.\n"
#~ "\n"
#~ "@SEEALSO=ROUND,ROUNDUP"
#~ msgstr ""
#~ "@FUNCTION=ABRUNDEN\n"
#~ "@SYNTAX=ABRUNDEN(Zahl[,Stellen])\n"
#~ "@DESCRIPTION=ABRUNDEN rundet die angegebene Zahl ab.\n"
#~ "\n"
#~ "@Zahl ist die abzurundende Zahl und @Stellen die Anzahl der Stellen, auf "
#~ "die diese Zahl gerundet werden soll.\n"
#~ "\n"
#~ "* Falls @Stellen positiv ist, wird @Zahl auf die angegebene Anzahl der "
#~ "Stellen abgerundet.\n"
#~ "* Falls @Stellen Null ist, wird @Zahl auf die nächste Ganzzahl "
#~ "abgerundet.\n"
#~ "* Falls @Stellen negativ ist, wird @Zahl auf die Zahl links der "
#~ "Dezimalstelle abgerundet.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ABRUNDEN(5.5) liefert 5.\n"
#~ "ABRUNDEN(-3.3) liefert -4.\n"
#~ "ABRUNDEN(1501.15,1) liefert 1501.1.\n"
#~ "ABRUNDEN(1501.15,-2) liefert 1500.0.\n"
#~ "\n"
#~ "@SEEALSO=RUNDEN, AUFRUNDEN"

#~ msgid ""
#~ "@FUNCTION=ROUND\n"
#~ "@SYNTAX=ROUND(number[,digits])\n"
#~ "@DESCRIPTION=ROUND function rounds a given number.\n"
#~ "\n"
#~ "@number is the number you want rounded and @digits is the number of "
#~ "digits to which you want to round that number.\n"
#~ "\n"
#~ "* If @digits is greater than zero, @number is rounded to the given number "
#~ "of digits.\n"
#~ "* If @digits is zero or omitted, @number is rounded to the nearest "
#~ "integer.\n"
#~ "* If @digits is less than zero, @number is rounded to the left of the "
#~ "decimal point.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ROUND(5.5) equals 6.\n"
#~ "ROUND(-3.3) equals -3.\n"
#~ "ROUND(1501.15,1) equals 1501.2.\n"
#~ "ROUND(1501.15,-2) equals 1500.0.\n"
#~ "\n"
#~ "@SEEALSO=ROUNDDOWN,ROUNDUP"
#~ msgstr ""
#~ "@FUNCTION=RUNDEN\n"
#~ "@SYNTAX=RUNDEN(Zahl[,Stellen])\n"
#~ "@DESCRIPTION=RUNDEN rundet die angegebene Zahl.\n"
#~ "\n"
#~ "@Zahl ist die zu rundende Zahl und @Stellen die Anzahl der Stellen, auf "
#~ "die diese Zahl gerundet werden soll.\n"
#~ "\n"
#~ "* Falls @Stellen positiv ist, wird @Zahl auf die angegebene Anzahl der "
#~ "Stellen gerundet.\n"
#~ "* Falls @Stellen Null ist, wird @Zahl auf die nächste Ganzzahl gerundet.\n"
#~ "* Falls @Stellen negativ ist, wird @Zahl auf die Zahl links der "
#~ "Dezimalstelle gerundet.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RUNDEN(5.5) liefert 6.\n"
#~ "RUNDEN(-3.3) liefert -3.\n"
#~ "RUNDEN(1501.15,1) liefert 1501.2.\n"
#~ "RUNDEN(1501.15,-2) liefert 1500.0.\n"
#~ "\n"
#~ "@SEEALSO=ABRUNDEN, AUFRUNDEN"

#~ msgid ""
#~ "@FUNCTION=ROUNDUP\n"
#~ "@SYNTAX=ROUNDUP(number[,digits])\n"
#~ "@DESCRIPTION=ROUNDUP function rounds a given number away from 0.\n"
#~ "\n"
#~ "@number is the number you want rounded away from 0 and @digits is the "
#~ "number of digits to which you want to round that number.\n"
#~ "\n"
#~ "* If @digits is greater than zero, @number is rounded away from 0 to the "
#~ "given number of digits.\n"
#~ "* If @digits is zero or omitted, @number is rounded away from 0 to the "
#~ "next integer.\n"
#~ "* If @digits is less than zero, @number is rounded away from 0 to the "
#~ "left of the decimal point.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ROUNDUP(5.5) equals 6.\n"
#~ "ROUNDUP(-3.3) equals -4.\n"
#~ "ROUNDUP(1501.15,1) equals 1501.2.\n"
#~ "ROUNDUP(1501.15,-2) equals 1600.0.\n"
#~ "\n"
#~ "@SEEALSO=ROUND,ROUNDDOWN"
#~ msgstr ""
#~ "@FUNCTION=AUFRUNDEN\n"
#~ "@SYNTAX=AUFRUNDEN(Zahl[,Stellen])\n"
#~ "@DESCRIPTION=AUFRUNDEN rundet die angegebene Zahl auf.\n"
#~ "\n"
#~ "@Zahl ist die aufzurundende Zahl und @Stellen die Anzahl der Stellen, auf "
#~ "die diese Zahl gerundet werden soll.\n"
#~ "\n"
#~ "* Falls @Stellen positiv ist, wird @Zahl auf die angegebene Anzahl der "
#~ "Stellen aufgerundet.\n"
#~ "* Falls @Stellen Null ist, wird @Zahl auf die nächste Ganzzahl "
#~ "aufgerundet.\n"
#~ "* Falls @Stellen negativ ist, wird @Zahl auf die Zahl links der "
#~ "Dezimalstelle aufgerundet.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "AUFRUNDEN(5.5) liefert 6.\n"
#~ "AUFRUNDEN(-3.3) liefert -3.\n"
#~ "AUFRUNDEN(1501.15,1) liefert 1501.2.\n"
#~ "AUFRUNDEN(1501.15,-2) liefert 1600.0.\n"
#~ "\n"
#~ "@SEEALSO=RUNDEN, ABRUNDEN"

#~ msgid ""
#~ "@FUNCTION=MROUND\n"
#~ "@SYNTAX=MROUND(number,multiple)\n"
#~ "@DESCRIPTION=MROUND function rounds a given number to the desired "
#~ "multiple.\n"
#~ "\n"
#~ "@number is the number you want rounded and @multiple is the the multiple "
#~ "to which you want to round the number.\n"
#~ "\n"
#~ "* If @number and @multiple have different sign, MROUND returns #NUM! "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "MROUND(1.7,0.2) equals 1.8.\n"
#~ "MROUND(321.123,0.12) equals 321.12.\n"
#~ "\n"
#~ "@SEEALSO=ROUNDDOWN,ROUND,ROUNDUP"
#~ msgstr ""
#~ "@FUNCTION=VRUNDEN\n"
#~ "@SYNTAX=VRUNDEN(Zahl,Vielfache)\n"
#~ "@DESCRIPTION=VRUNDEN rundet die angegebene Zahl auf die gewünschte "
#~ "Vielfache.\n"
#~ "\n"
#~ "@Zahl ist zu rundende Zahl und @Vielfache die Vielfache, auf die die Zahl "
#~ "gerundet werden soll.\n"
#~ "\n"
#~ "* Falls @Zahl und @Vielfache ein anderes Vorzeichen haben, liefert "
#~ "VRUNDEN einen #ZAHL!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "MROUND(1.7,0.2) liefert 1.8.\n"
#~ "MROUND(321.123,0.12) liefert 321.12.\n"
#~ "\n"
#~ "@SEEALSO=RUNDEN, ABRUNDEN, AUFRUNDEN"

#~ msgid ""
#~ "@FUNCTION=ROMAN\n"
#~ "@SYNTAX=ROMAN(number[,type])\n"
#~ "@DESCRIPTION=ROMAN function returns an arabic number in the roman numeral "
#~ "style, as text. @number is the number you want to convert and @type is "
#~ "the type of roman numeral you want.\n"
#~ "\n"
#~ "* If @type is 0 or it is omitted, ROMAN returns classic roman numbers.\n"
#~ "* Type 1 is more concise than classic type, type 2 is more concise than "
#~ "type 1, and type 3 is more concise than type 2.  Type 4 is simplified "
#~ "type.\n"
#~ "* If @number is negative or greater than 3999, ROMAN returns #VALUE! "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ROMAN(999) equals CMXCIX.\n"
#~ "ROMAN(999,1) equals LMVLIV.\n"
#~ "ROMAN(999,2) equals XMIX.\n"
#~ "ROMAN(999,3) equals VMIV.\n"
#~ "ROMAN(999,4) equals IM.\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=RÖMISCH\n"
#~ "@SYNTAX=RÖMISCH(Zahl[,Typ])\n"
#~ "@DESCRIPTION=RÖMISCH wandelt eine arabische Zahl in die römische "
#~ "Schreibweise um. @Zahl ist die zu konvertierende Zahl und @Typ der Typ "
#~ "der gewünschte römischen Darstellung.\n"
#~ "\n"
#~ "* Falls @Typ Null ist oder nicht übergeben wird, liefert RÖMISCH "
#~ "klassische römische Zahlen.\n"
#~ "* Typ 1 ist übersichtlicher als der klassische Typ, Typ 2 übersichtlicher "
#~ "als Typ 1 und Typ 3 ist übersichtlicher als Typ 2. Typ 4 ist der "
#~ "vereinfachte Typ.\n"
#~ "* Falls @Zahl negativ oder größer als 3999 ist, liefert RÖMISCH einen "
#~ "#WERT!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RÖMISCH(999) liefert CMXCIX.\n"
#~ "RÖMISCH(999,1) liefert LMVLIV.\n"
#~ "RÖMISCH(999,2) liefert XMIX.\n"
#~ "RÖMISCH(999,3) liefert VMIV.\n"
#~ "RÖMISCH(999,4) liefert IM.\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=SUMX2MY2\n"
#~ "@SYNTAX=SUMX2MY2(array1,array2)\n"
#~ "@DESCRIPTION=SUMX2MY2 function returns the sum of the difference of "
#~ "squares of corresponding values in two arrays. @array1 is the first array "
#~ "or range of data points and @array2 is the second array or range of data "
#~ "points. The equation of SUMX2MY2 is SUM (x^2-y^2).\n"
#~ "\n"
#~ "* Strings and empty cells are simply ignored.\n"
#~ "* If @array1 and @array2 have different number of data points, SUMX2MY2 "
#~ "returns #N/A error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11, 15, 17, "
#~ "21, and 43 and the cells B1, B2, ..., B5 hold numbers 13, 22, 31, 33, and "
#~ "39.  Then\n"
#~ "SUMX2MY2(A1:A5,B1:B5) equals -1299.\n"
#~ "\n"
#~ "@SEEALSO=SUMSQ,SUMX2PY2"
#~ msgstr ""
#~ "@FUNCTION=SUMMENPRODUKT\n"
#~ "@SYNTAX=SUMMENPRODUKT(Bereich1,Bereich2,...)\n"
#~ "@DESCRIPTION=SUMMENPRODUKT multipliziert die entsprechenden Dateneinträge "
#~ "in den angegebenen Feldern oder Bereichen und liefert dann die Summe "
#~ "dieser Produkte. Falls ein Feldeintrag nicht numerisch ist, wird "
#~ "stattdessen der Wert Null verwendet.\n"
#~ "\n"
#~ "* Falls Felder- oder Bereichsargumente unterschiedliche Dimensionen "
#~ "haben, liefert SUMMENPRODUKT einen #WERT!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, die Zellen A1, A2, ..., A5 enthalten die Zahlen 11, 15, 17, "
#~ "21 und 43 und die Zellen B1, B2, ..., B5 13, 22, 31, 33 sowie 39. Dann "
#~ "liefert\n"
#~ "SUMMENPRODUKT(A1:A5,B1:B5) 3370.\n"
#~ "\n"
#~ "@SEEALSO=SUMME, PRODUKT"

#~ msgid ""
#~ "@FUNCTION=SUMX2PY2\n"
#~ "@SYNTAX=SUMX2PY2(array1,array2)\n"
#~ "@DESCRIPTION=SUMX2PY2 function returns the sum of the sum of squares of "
#~ "corresponding values in two arrays. @array1 is the first array or range "
#~ "of data points and @array2 is the second array or range of data points. "
#~ "The equation of SUMX2PY2 is SUM (x^2+y^2).\n"
#~ "\n"
#~ "* Strings and empty cells are simply ignored.\n"
#~ "* If @array1 and @array2 have different number of data points, SUMX2PY2 "
#~ "returns #N/A error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11, 15, 17, "
#~ "21, and 43 and the cells B1, B2, ..., B5 hold numbers 13, 22, 31, 33, and "
#~ "39.  Then\n"
#~ "SUMX2PY2(A1:A5,B1:B5) equals 7149.\n"
#~ "\n"
#~ "@SEEALSO=SUMSQ,SUMX2MY2"
#~ msgstr ""
#~ "@FUNCTION=SUMMENPRODUKT\n"
#~ "@SYNTAX=SUMMENPRODUKT(Bereich1,Bereich2,...)\n"
#~ "@DESCRIPTION=SUMMENPRODUKT multipliziert die entsprechenden Dateneinträge "
#~ "in den angegebenen Feldern oder Bereichen und liefert dann die Summe "
#~ "dieser Produkte. Falls ein Feldeintrag nicht numerisch ist, wird "
#~ "stattdessen der Wert Null verwendet.\n"
#~ "\n"
#~ "* Falls Felder- oder Bereichsargumente unterschiedliche Dimensionen "
#~ "haben, liefert SUMMENPRODUKT einen #WERT!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, die Zellen A1, A2, ..., A5 enthalten die Zahlen 11, 15, 17, "
#~ "21 und 43 und die Zellen B1, B2, ..., B5 13, 22, 31, 33 sowie 39. Dann "
#~ "liefert\n"
#~ "SUMMENPRODUKT(A1:A5,B1:B5) 3370.\n"
#~ "\n"
#~ "@SEEALSO=SUMME, PRODUKT"

#~ msgid ""
#~ "@FUNCTION=SUMXMY2\n"
#~ "@SYNTAX=SUMXMY2(array1,array2)\n"
#~ "@DESCRIPTION=SUMXMY2 function returns the sum of squares of differences "
#~ "of corresponding values in two arrays. @array1 is the first array or "
#~ "range of data points and @array2 is the second array or range of data "
#~ "points. The equation of SUMXMY2 is SUM (x-y)^2.\n"
#~ "\n"
#~ "* Strings and empty cells are simply ignored.\n"
#~ "* If @array1 and @array2 have different number of data points, SUMXMY2 "
#~ "returns #N/A error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11, 15, 17, "
#~ "21, and 43 and the cells B1, B2, ..., B5 hold numbers 13, 22, 31, 33, and "
#~ "39.  Then\n"
#~ "SUMXMY2(A1:A5,B1:B5) equals 409.\n"
#~ "\n"
#~ "@SEEALSO=SUMSQ,SUMX2MY2,SUMX2PY2"
#~ msgstr ""
#~ "@FUNCTION=SUMMENPRODUKT\n"
#~ "@SYNTAX=SUMMENPRODUKT(Bereich1,Bereich2,...)\n"
#~ "@DESCRIPTION=SUMMENPRODUKT multipliziert die entsprechenden Dateneinträge "
#~ "in den angegebenen Feldern oder Bereichen und liefert dann die Summe "
#~ "dieser Produkte. Falls ein Feldeintrag nicht numerisch ist, wird "
#~ "stattdessen der Wert Null verwendet.\n"
#~ "\n"
#~ "* Falls Felder- oder Bereichsargumente unterschiedliche Dimensionen "
#~ "haben, liefert SUMMENPRODUKT einen #WERT!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, die Zellen A1, A2, ..., A5 enthalten die Zahlen 11, 15, 17, "
#~ "21 und 43 und die Zellen B1, B2, ..., B5 13, 22, 31, 33 sowie 39. Dann "
#~ "liefert\n"
#~ "SUMMENPRODUKT(A1:A5,B1:B5) 3370.\n"
#~ "\n"
#~ "@SEEALSO=SUMME, PRODUKT"

#~ msgid ""
#~ "@FUNCTION=SERIESSUM\n"
#~ "@SYNTAX=SERIESSUM(x,n,m,coefficients)\n"
#~ "@DESCRIPTION=SERIESSUM function returns the sum of a power series.  @x is "
#~ "the base of the power series, @n is the initial power to raise @x, @m is "
#~ "the increment to the power for each term in the series, and @coefficients "
#~ "are the coefficients by which each successive power of @x is multiplied.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 1.23, 2.32, "
#~ "2.98, 3.42, and 4.33.  Then\n"
#~ "SERIESSUM(3,1,2.23,A1:A5) equals 251416.43018.\n"
#~ "\n"
#~ "@SEEALSO=COUNT,SUM"
#~ msgstr ""
#~ "@FUNCTION=REIHENSUMME\n"
#~ "@SYNTAX=REIHENSUMME(x,n,m,Koeffizienten)\n"
#~ "@DESCRIPTION=REIHENSUMME liefert die Summe einer Potenzreihe. @x ist die "
#~ "Basis der Potenzreihe, @n der erste Exponent, mit dem @x potenziert "
#~ "werden soll. @m ist die Schrittweite des Exponenten für jeden Term in der "
#~ "Reihe und @Koeffizienten sind die Koeffizienten, mit denen jede folgende "
#~ "Potenz von @x multipliziert werden soll.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, die Zellen A1, A2, ..., A5 enthalten die Zahlen 1.23, 2.32, "
#~ "2.98, 3.42 und 4.33. Dann liefert\n"
#~ "REIHENSUMME(3,1,2.23,A1:A5) 251416.43018.\n"
#~ "\n"
#~ "@SEEALSO=ANZAHL,SUMME"

#~ msgid ""
#~ "@FUNCTION=MINVERSE\n"
#~ "@SYNTAX=MINVERSE(matrix)\n"
#~ "@DESCRIPTION=MINVERSE function returns the inverse matrix of @matrix.\n"
#~ "\n"
#~ "* If @matrix cannot be inverted, MINVERSE returns #NUM! error.\n"
#~ "* If @matrix does not contain equal number of columns and rows, MINVERSE "
#~ "returns #VALUE! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=MMULT, MDETERM"
#~ msgstr ""
#~ "@FUNCTION=MINVERS\n"
#~ "@SYNTAX=MINVERS(Matrix)\n"
#~ "@DESCRIPTION=MINVERS liefert die inverse Matrix der Matrix @Matrix.\n"
#~ "\n"
#~ "* Falls @Matrix nicht invertiert werden kann, liefert MINVERS einen "
#~ "#ZAHL!-Fehler.\n"
#~ "* Falls @Matrix nicht die gleiche Anzahl Spalten und Zeilen enthält, "
#~ "liefert MINVERS einen #WERT!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=MMULT, MDETERM"

#~ msgid ""
#~ "@FUNCTION=MMULT\n"
#~ "@SYNTAX=MMULT(array1,array2)\n"
#~ "@DESCRIPTION=MMULT function returns the matrix product of two arrays. The "
#~ "result is an array with the same number of rows as @array1 and the same "
#~ "number of columns as @array2.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=TRANSPOSE,MINVERSE"
#~ msgstr ""
#~ "@FUNCTION=MMULT\n"
#~ "@SYNTAX=MMULT(Datenfeld1,Datenfeld2)\n"
#~ "@DESCRIPTION=MMULT liefert das Matrizenprodukt zweier Felder. Das "
#~ "Ergebnis ist ein Feld mit der gleichen Zeilenanzahl wie @Datenfeld1 und "
#~ "der gleichen Spaltenanzahl wie @Datenfeld2.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=TRANSPOSE,MTRANS"

#~ msgid ""
#~ "@FUNCTION=MDETERM\n"
#~ "@SYNTAX=MDETERM(matrix)\n"
#~ "@DESCRIPTION=MDETERM function returns the determinant of a given matrix.\n"
#~ "\n"
#~ "* If the @matrix does not contain equal number of columns and rows, "
#~ "MDETERM returns #VALUE! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that A1, ..., A4 contain numbers 2, 3, 7, and 3, B1, ..., "
#~ "B4 4, 2, 4, and 1, C1, ..., C4 9, 4, 3, and 2, and D1, ..., D4 7, 3, 6, "
#~ "and 5. Then\n"
#~ "MDETERM(A1:D4) equals 148.\n"
#~ "\n"
#~ "@SEEALSO=MMULT, MINVERSE"
#~ msgstr ""
#~ "@FUNCTION=MDETERM\n"
#~ "@SYNTAX=MDETERM(Matrix)\n"
#~ "@DESCRIPTION=MDETERM liefert die Determinante einer angegebenen Matrix "
#~ "@Matrix.\n"
#~ "\n"
#~ "* Falls @matrix nicht gleich viele Zeilen und Spalten enthält, liefert "
#~ "MDETERM einen #WERT!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, die Zellen A1, ..., A4 enthalten die Zahlen 2, 3, 7 und 3, "
#~ "B1, ..., B4 4, 2, 4 und 1, C1, ..., C4 9, 4, 3 und 2 sowie D1, ..., D4 7, "
#~ "3, 6 und 5. Dann liefert\n"
#~ "MDETERM(A1:D4) 148.\n"
#~ "\n"
#~ "@SEEALSO=MMULT, MINVERSE"

#~ msgid ""
#~ "@FUNCTION=RAND\n"
#~ "@SYNTAX=RAND()\n"
#~ "@DESCRIPTION=RAND returns a random number between zero and one.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RAND() returns a random number greater than zero but less than one.\n"
#~ "\n"
#~ "@SEEALSO=RANDBETWEEN"
#~ msgstr ""
#~ "@FUNCTION=ZUFALLSZAHL\n"
#~ "@SYNTAX=ZUFALLSZAHL()\n"
#~ "@DESCRIPTION=ZUFALLSZAHL liefert eine Zufallszahl zwischen Null und "
#~ "Eins.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ZUFALLSZAHL() liefert eine Zufallszahl, die größer als Null aber kleiner "
#~ "als Eins ist.\n"
#~ "\n"
#~ "@SEEALSO=ZUFALLSZAHL.ZWISCHEN"

#~ msgid ""
#~ "@FUNCTION=RANDUNIFORM\n"
#~ "@SYNTAX=RANDUNIFORM(a,b)\n"
#~ "@DESCRIPTION=RANDUNIFORM returns a random variate from the uniform (flat) "
#~ "distribution from a to b. The distribution is,\n"
#~ "\n"
#~ "\tp(x) dx = {1 over (b-a)} dx : for a <= x < b.\n"
#~ "p(x) dx = 0 : for x < a or b <= x.\n"
#~ "* If @a > @b RANDUNIFORM returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDUNIFORM(1.4,4.2) returns a random number greater than or equal to 1.4 "
#~ "but less than 4.2.\n"
#~ "\n"
#~ "@SEEALSO=RANDBETWEEN,RAND"
#~ msgstr ""
#~ "@FUNCTION=ZUFALLSZAHL.RECHTECK\n"
#~ "@SYNTAX=ZUFALLSZAHL.RECHTECK(a,b)\n"
#~ "@DESCRIPTION=ZUFALLSZAHL.RECHTECK liefert eine zufällige Variable der "
#~ "(flachen) Rechteckverteilung zwischen a und b, wobei die Verteilung\n"
#~ "\n"
#~ "\tp(x) dx = {1 / (b-a)} dx für a <= x < b bzw.\n"
#~ "\tp(x) dx = 0 für x < a oder b <= x ist.\n"
#~ "\n"
#~ "* Falls @a > @b, liefert ZUFALLSZAHL.RECHTECK einen #ZAHL!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ZUFALLSZAHL.RECHTECK(1.4,4.2) liefert eine Zufallszahl, die größer/gleich "
#~ "1.4, aber kleiner als 4.2 ist.\n"
#~ "\n"
#~ "@SEEALSO=ZUFALLSZAHL.ZWISCHEN,ZUFALLSZAHL"

#~ msgid ""
#~ "@FUNCTION=RANDDISCRETE\n"
#~ "@SYNTAX=RANDDISCRETE(val_range[,prob_range])\n"
#~ "@DESCRIPTION=RANDDISCRETE returns one of the values in the @val_range. "
#~ "The probabilities for each value are given in the @prob_range.\n"
#~ "\n"
#~ "* If @prob_range is omitted, the uniform discrete distribution is "
#~ "assumed.\n"
#~ "* If the sum of all values in @prob_range is other than one, RANDDISCRETE "
#~ "returns #NUM! error.\n"
#~ "* If @val_range and @prob_range are not the same size, RANDDISCRETE "
#~ "returns #NUM! error.\n"
#~ "* If @val_range or @prob_range is not a range, RANDDISCRETE returns "
#~ "#VALUE! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDDISCRETE(A1:A6) returns one of the values in the range A1:A6.\n"
#~ "\n"
#~ "@SEEALSO=RANDBETWEEN,RAND"
#~ msgstr ""
#~ "@FUNCTION=ZUFALLSZAHL.DISKRET\n"
#~ "@SYNTAX=ZUFALLSZAHL.DISKRET(Wertebereich[,Wahrscheinlichkeitsbereich])\n"
#~ "@DESCRIPTION=ZUFALLSZAHL.DISKRET liefert einen der Werte im Bereich "
#~ "@Wertebereich. Die Wahrscheinlichkeiten für jeden Wert werden in "
#~ "@Wahrscheinlichkeitsbereich übergeben.\n"
#~ "\n"
#~ "* Falls @Wahrscheinlichkeitsbereich nicht übergeben wird, wird eine "
#~ "diskrete Normalverteilung angenommen.\n"
#~ "* Falls die Summe aller Werte im Bereich @Wahrscheinlichkeitsbereich "
#~ "ungleich eins ist, liefert ZUFALLSZAHL.DISKRET einen #ZAHL!-Fehler.\n"
#~ "* Falls @Wertebereich und @Wahrscheinlichkeitsbereich nicht gleich groß "
#~ "sind, liefert ZUFALLSZAHL.DISKRET einen #ZAHL!-Fehler.\n"
#~ "* Falls @Wertebereich oder @Wahrscheinlichkeitsbereich keine Bereiche "
#~ "ist, liefert ZUFALLSZAHL.DISKRET einen #ZAHL!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ZUFALLSZAHL.DISKRET(A1:A6) liefert einen der Werte im Bereich A1:A6.\n"
#~ "\n"
#~ "@SEEALSO=ZUFALLSZAHL.ZWISCHEN, ZUFALLSZAHL"

#~ msgid ""
#~ "@FUNCTION=RANDEXP\n"
#~ "@SYNTAX=RANDEXP(b)\n"
#~ "@DESCRIPTION=RANDEXP returns a exponentially-distributed random number.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDEXP(0.5).\n"
#~ "\n"
#~ "@SEEALSO=RAND,RANDBETWEEN"
#~ msgstr ""
#~ "@FUNCTION=ZUFALLSZAHL.EXP\n"
#~ "@SYNTAX=ZUFALLSZAHL.EXP(b)\n"
#~ "@DESCRIPTION=ZUFALLSZAHL.EXP liefert eine exponenziell verteilte "
#~ "Zufallszahl.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ZUFALLSZAHL.EXP(0.5).\n"
#~ "\n"
#~ "@SEEALSO=ZUFALLSZAHL, ZUFALLSZAHL.ZWISCHEN"

#~ msgid ""
#~ "@FUNCTION=RANDPOISSON\n"
#~ "@SYNTAX=RANDPOISSON(lambda)\n"
#~ "@DESCRIPTION=RANDPOISSON returns a Poisson-distributed random number.\n"
#~ "\n"
#~ "* If @lambda < 0 RANDPOISSON returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDPOISSON(3).\n"
#~ "\n"
#~ "@SEEALSO=RAND,RANDBETWEEN"
#~ msgstr ""
#~ "@FUNCTION=ZUFALLSZAHL.POISSON\n"
#~ "@SYNTAX=ZUFALLSZAHL.POISSON(Lambda)\n"
#~ "@DESCRIPTION=ZUFALLSZAHL.POISSON liefert eine Poisson-verteilte "
#~ "Zufallszahl.\n"
#~ "\n"
#~ "* Falls @Lambda < 0 ist, liefert ZUFALLSZAHL.POISSON einen #ZAHL!-"
#~ "Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ZUFALLSZAHL.POISSON(3).\n"
#~ "\n"
#~ "@SEEALSO=ZUFALLSZAHL, ZUFALLSZAHL.ZWISCHEN"

#~ msgid ""
#~ "@FUNCTION=RANDBINOM\n"
#~ "@SYNTAX=RANDBINOM(p,trials)\n"
#~ "@DESCRIPTION=RANDBINOM returns a binomially-distributed random number.\n"
#~ "\n"
#~ "* If @p < 0 or @p > 1 RANDBINOM returns #NUM! error.\n"
#~ "* If @trials < 0 RANDBINOM returns #NUM! error. \n"
#~ "@EXAMPLES=\n"
#~ "RANDBINOM(0.5,2).\n"
#~ "\n"
#~ "@SEEALSO=RAND,RANDBETWEEN"
#~ msgstr ""
#~ "@FUNCTION=ZUFALLSZAHL.BINOM\n"
#~ "@SYNTAX=ZUFALLSZAHL.BINOM(Wahrscheinlichkeit,Versuche)\n"
#~ "@DESCRIPTION=ZUFALLSZAHL.BINOM liefert eine binomial verteilte "
#~ "Zufallszahl.\n"
#~ "\n"
#~ "* Falls @Wahrscheinlichkeit < 0 oder > 1 ist, liefert ZUFALLSZAHL.BINOM "
#~ "einen #ZAHL!-Fehler.\n"
#~ "* Falls @Fehlschläge < 0 ist, liefert ZUFALLSZAHL.BINOM einen #ZAHL!-"
#~ "Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ZUFALLSZAHL.BINOM(0.5,2).\n"
#~ "\n"
#~ "@SEEALSO=ZUFALLSZAHL,ZUFALLSZAHL.NEGBINOM"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=RANDBETWEEN\n"
#~ "@SYNTAX=RANDBETWEEN(bottom,top)\n"
#~ "@DESCRIPTION=RANDBETWEEN function returns a random integer number between "
#~ "and including @bottom and @top.\n"
#~ "\n"
#~ "* If @bottom is non-integer, it is rounded up.\n"
#~ "* If @top is non-integer, it is rounded down.\n"
#~ "* If @bottom > @top, RANDBETWEEN returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDBETWEEN(3,7).\n"
#~ "\n"
#~ "@SEEALSO=RAND,RANDUNIFORM"
#~ msgstr ""
#~ "@FUNCTION=ZUFALLSZAHL.ZWISCHEN\n"
#~ "@SYNTAX=ZUFALLSZAHL.ZWISCHEN(unten,oben)\n"
#~ "@DESCRIPTION=ZUFALLSZAHL.ZWISCHEN liefert eine zufällige Ganzzahl "
#~ "zwischen und einschließlich der Unter- und Obergrenze @unten bzw. @oben.\n"
#~ "\n"
#~ "* Falls @unten oder @oben keine Ganzzahl ist, werden die Nachkommastellen "
#~ "abgeschnitten.\n"
#~ "* Falls @unten > @oben, liefert ZUFALLSZAHL.ZWISCHEN einen #ZAHL!-"
#~ "Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ZUFALLSZAHL.ZWISCHEN(3,7).\n"
#~ "\n"
#~ "@SEEALSO=ZUFALLSZAHL,ZUFALLSZAHL.RECHTECK"

#~ msgid ""
#~ "@FUNCTION=RANDNEGBINOM\n"
#~ "@SYNTAX=RANDNEGBINOM(p,failures)\n"
#~ "@DESCRIPTION=RANDNEGBINOM returns a negative binomially-distributed "
#~ "random number.\n"
#~ "\n"
#~ "* If @p < 0 or @p > 1, RANDNEGBINOM returns #NUM! error.\n"
#~ "* If @failures < 1, RANDNEGBINOM returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDNEGBINOM(0.5,2).\n"
#~ "\n"
#~ "@SEEALSO=RAND,RANDBETWEEN"
#~ msgstr ""
#~ "@FUNCTION=ZUFALLSZAHL.NEGBINOM\n"
#~ "@SYNTAX=ZUFALLSZAHL.NEGBINOM(Wahrscheinlichkeit,Fehlschläge)\n"
#~ "@DESCRIPTION=ZUFALLSZAHL.NEGBINOM liefert eine negative, binomial "
#~ "verteilte Zufallszahl.\n"
#~ "\n"
#~ "* Falls @Wahrscheinlichkeit < 0 oder > 1 ist, liefert ZUFALLSZAHL."
#~ "NEGBINOM einen #ZAHL!-Fehler.\n"
#~ "* Falls @Fehlschläge < 1 ist, liefert ZUFALLSZAHL.NEGBINOM einen #ZAHL!-"
#~ "Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ZUFALLSZAHL.NEGBINOM(0.5,2).\n"
#~ "\n"
#~ "@SEEALSO=ZUFALLSZAHL,ZUFALLSZAHL.BINOM"

#~ msgid ""
#~ "@FUNCTION=RANDBERNOULLI\n"
#~ "@SYNTAX=RANDBERNOULLI(p)\n"
#~ "@DESCRIPTION=RANDBERNOULLI returns a Bernoulli-distributed random "
#~ "number.\n"
#~ "\n"
#~ "* If @p < 0 or @p > 1 RANDBERNOULLI returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDBERNOULLI(0.5).\n"
#~ "\n"
#~ "@SEEALSO=RAND,RANDBETWEEN"
#~ msgstr ""
#~ "@FUNCTION=ZUFALLSZAHL.BERNOULLI\n"
#~ "@SYNTAX=ZUFALLSZAHL.BERNOULLI(Wahrscheinlichkeit)\n"
#~ "@DESCRIPTION=ZUFALLSZAHL.BERNOULLI liefert eine Bernoulli-verteilte "
#~ "Zufallszahl.\n"
#~ "\n"
#~ "* Falls @Wahrscheinlichkeit < 0 oder @Wahrscheinlichkeit > 1 ist, liefert "
#~ "ZUFALLSZAHL.BERNOULLI einen #WERT!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ZUFALLSZAHL.BERNOULLI(0.5).\n"
#~ "\n"
#~ "@SEEALSO=ZUFALLSZAHL, ZUFALLSZAHL.ZWISCHEN"

#~ msgid ""
#~ "@FUNCTION=RANDNORM\n"
#~ "@SYNTAX=RANDNORM(mean,stdev)\n"
#~ "@DESCRIPTION=RANDNORM returns a normal-distributed random number.\n"
#~ "\n"
#~ "* If @stdev < 0 RANDNORM returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDNORM(0,1).\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=ZUFALLSZAHL.NORM\n"
#~ "@SYNTAX=ZUFALLSZAHL.NORM(Mittelwert,Stdabw)\n"
#~ "@DESCRIPTION=ZUFALLSZAHL.NORM liefert eine normalverteilte Zufallszahl.\n"
#~ "\n"
#~ "* Falls @Stdabw < 0 ist, liefert ZUFALLSZAHL.NORM einen #ZAHL!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ZUFALLSZAHL.NORM(0,1).\n"
#~ "\n"
#~ "@SEEALSO=ZUFALLSZAHL"

#~ msgid ""
#~ "@FUNCTION=RANDCAUCHY\n"
#~ "@SYNTAX=RANDCAUCHY(a)\n"
#~ "@DESCRIPTION=RANDCAUCHY returns a Cauchy-distributed random number with "
#~ "scale parameter a. The Cauchy distribution is also known as the Lorentz "
#~ "distribution.\n"
#~ "\n"
#~ "* If @a < 0 RANDCAUCHY returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDCAUCHY(1).\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=ZUFALLSZAHL.CAUCHY\n"
#~ "@SYNTAX=ZUFALLSZAHL.CAUCHY(a)\n"
#~ "@DESCRIPTION=ZUFALLSZAHL.CAUCHY liefert eine Cauchy-verteilte Zufallszahl "
#~ "mit Skalenparameter a. Die Cauchy-Verteilung ist auch als Lorentz-"
#~ "Verteilung bekannt.\n"
#~ "\n"
#~ "* Falls @a < 0 ist, liefert ZUFALLSZAHL.CAUCHY einen #ZAHL!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ZUFALLSZAHL.CAUCHY(1).\n"
#~ "\n"
#~ "@SEEALSO=ZUFALLSZAHL"

#~ msgid ""
#~ "@FUNCTION=RANDLOGNORM\n"
#~ "@SYNTAX=RANDLOGNORM(zeta,sigma)\n"
#~ "@DESCRIPTION=RANDLOGNORM returns a lognormal-distributed random number.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDLOGNORM(1,2).\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=ZUFALLSZAHL.LOGNORMAL\n"
#~ "@SYNTAX=ZUFALLSZAHL.LOGNORMAL(Zeta,Sigma)\n"
#~ "@DESCRIPTION=ZUFALLSZAHL.LOGNORMAL liefert eine lognormal-verteilte "
#~ "Zufallszahl.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ZUFALLSZAHL.LOGNORMAL(1,2).\n"
#~ "\n"
#~ "@SEEALSO=ZUFALLSZAHL"

#~ msgid ""
#~ "@FUNCTION=RANDWEIBULL\n"
#~ "@SYNTAX=RANDWEIBULL(a,b)\n"
#~ "@DESCRIPTION=RANDWEIBULL returns a Weibull-distributed random number.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDWEIBULL(1,2).\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=ZUFALLSZAHL.WEIBULL\n"
#~ "@SYNTAX=ZUFALLSZAHL.WEIBULL(a,b)\n"
#~ "@DESCRIPTION=ZUFALLSZAHL.WEIBULL liefert eine Weibull-verteilte "
#~ "Zufallszahl.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ZUFALLSZAHL.WEIBULL(1,2).\n"
#~ "\n"
#~ "@SEEALSO=ZUFALLSZAHL"

#~ msgid ""
#~ "@FUNCTION=RANDLAPLACE\n"
#~ "@SYNTAX=RANDLAPLACE(a)\n"
#~ "@DESCRIPTION=RANDLAPLACE returns a Laplace-distributed random number. "
#~ "Laplace distribution is also known as two-sided exponential probability "
#~ "distribution.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDLAPLACE(1).\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=ZUFALLSZAHL.LAPLACE\n"
#~ "@SYNTAX=ZUFALLSZAHL.LAPLACE(a)\n"
#~ "@DESCRIPTION=ZUFALLSZAHL.LAPLACE liefert eine Laplace-verteilte "
#~ "Zufallszahl. Laplace-Verteilungen sind auch als zweiseitige exponenzielle "
#~ "Wahrscheinlichkeitsverteilungen bekannt.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ZUFALLSZAHL.LAPLACE(1).\n"
#~ "\n"
#~ "@SEEALSO=ZUFALLSZAHL"

#~ msgid ""
#~ "@FUNCTION=RANDRAYLEIGH\n"
#~ "@SYNTAX=RANDRAYLEIGH(sigma)\n"
#~ "@DESCRIPTION=RANDRAYLEIGH returns a Rayleigh-distributed random number.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDRAYLEIGH(1).\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=ZUFALLSZAHL.RAYLEIGH\n"
#~ "@SYNTAX=ZUFALLSZAHL.RAYLEIGH(Sigma)\n"
#~ "@DESCRIPTION=ZUFALLSZAHL.RAYLEIGH liefert eine Rayleigh-verteilte "
#~ "Zufallszahl.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ZUFALLSZAHL.RAYLEIGH(1).\n"
#~ "\n"
#~ "@SEEALSO=ZUFALLSZAHL"

#~ msgid ""
#~ "@FUNCTION=RANDRAYLEIGHTAIL\n"
#~ "@SYNTAX=RANDRAYLEIGHTAIL(a,sigma)\n"
#~ "@DESCRIPTION=RANDRAYLEIGHTAIL returns  a random variate from the tail of "
#~ "the Rayleigh distribution with scale parameter sigma and a lower limit of "
#~ "a. The distribution is,\n"
#~ "\n"
#~ "\tp(x) dx = {x over sigma^2} exp ((a^2 - x^2) /(2 sigma^2)) dx,\n"
#~ "\n"
#~ "for x > a.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDRAYLEIGHTAIL(0.3,1).\n"
#~ "\n"
#~ "@SEEALSO=RAND,RANDRAYLEIGH"
#~ msgstr ""
#~ "@FUNCTION=ZUFALLSZAHL.RAYLEIGHTAIL\n"
#~ "@SYNTAX=ZUFALLSZAHL.RAYLEIGHTAIL(a,Sigma)\n"
#~ "@DESCRIPTION=ZUFALLSZAHL.RAYLEIGHTAIL liefert eine Zufallsvariable aus "
#~ "dem Tail der Rayleigh-Verteilung mit dem Skalierungsparameter @Sigma und "
#~ "limes inferior @a. Die Verteilung ist\n"
#~ "\n"
#~ "\tp(x) dx = {x / sigma^2} exp ((a^2 - x^2) /(2 sigma^2)) dx,\n"
#~ "\n"
#~ "for x > a.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ZUFALLSZAHL.RAYLEIGHTAIL(0.3,1).\n"
#~ "\n"
#~ "@SEEALSO=ZUFALLSZAHL,ZUFALLSZAHLEN.RAYLEIGH"

#~ msgid ""
#~ "@FUNCTION=RANDGAMMA\n"
#~ "@SYNTAX=RANDGAMMA(a,b)\n"
#~ "@DESCRIPTION=RANDGAMMA returns a Gamma-distributed random number.\n"
#~ "\n"
#~ "* If @a <= 0 RANDGAMMA returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDGAMMA(1,2).\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=ZUFALLSZAHL.GAMMA\n"
#~ "@SYNTAX=ZUFALLSZAHL.GAMMA(a,b)\n"
#~ "@DESCRIPTION=ZUFALLSZAHL.GAMMA liefert eine Gamma-verteilte Zufallszahl.\n"
#~ "\n"
#~ "* Falls @a <= 0 ist, liefert ZUFALLSZAHL.GAMMA einen #ZAHL!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ZUFALLSZAHL.GAMMA(1,2).\n"
#~ "\n"
#~ "@SEEALSO=ZUFALLSZAHL"

#~ msgid ""
#~ "@FUNCTION=RANDPARETO\n"
#~ "@SYNTAX=RANDPARETO(a,b)\n"
#~ "@DESCRIPTION=RANDPARETO returns a Pareto-distributed random number.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDPARETO(1,2).\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=ZUFALLSZAHL.PARETO\n"
#~ "@SYNTAX=ZUFALLSZAHL.PARETO(a,b)\n"
#~ "@DESCRIPTION=ZUFALLSZAHL.PARETO liefert eine Pareto-verteilte "
#~ "Zufallszahl.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ZUFALLSZAHL.PARETO(1,2).\n"
#~ "\n"
#~ "@SEEALSO=ZUFALLSZAHL.PARETO"

#~ msgid ""
#~ "@FUNCTION=RANDFDIST\n"
#~ "@SYNTAX=RANDFDIST(nu1,nu2)\n"
#~ "@DESCRIPTION=RANDFDIST returns a F-distributed random number.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDFDIST(1,2).\n"
#~ "\n"
#~ "@SEEALSO=RAND,RANDGAMMA"
#~ msgstr ""
#~ "@FUNCTION=ZUFALLSZAHL.FVERT\n"
#~ "@SYNTAX=ZUFALLSZAHL.FVERT(Zahl1,Zahl2)\n"
#~ "@DESCRIPTION=ZUFALLSZAHL.FVERT liefert eine F-verteilte Zufallszahl.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ZUFALLSZAHL.FVERT(1,2).\n"
#~ "\n"
#~ "@SEEALSO=ZUFALLSZAHL, ZUFALLSZAHL.GAMMA"

#~ msgid ""
#~ "@FUNCTION=RANDBETA\n"
#~ "@SYNTAX=RANDBETA(a,b)\n"
#~ "@DESCRIPTION=RANDBETA returns a Beta-distributed random number.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDBETA(1,2).\n"
#~ "\n"
#~ "@SEEALSO=RAND,RANDGAMMA"
#~ msgstr ""
#~ "@FUNCTION=ZUFALLSZAHL.BETA\n"
#~ "@SYNTAX=ZUFALLSZAHL.BETA(a,b)\n"
#~ "@DESCRIPTION=ZUFALLSZAHL.BETA liefert eine Beta-verteile Zufallszahl.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ZUFALLSZAHL.BETA(1,2).\n"
#~ "\n"
#~ "@SEEALSO=ZUFALLSZAHL, ZUFALLSZAHL.GAMMA"

#~ msgid ""
#~ "@FUNCTION=RANDLOGISTIC\n"
#~ "@SYNTAX=RANDLOGISTIC(a)\n"
#~ "@DESCRIPTION=RANDLOGISTIC returns a logistic-distributed random number.  "
#~ "The distribution function is,\n"
#~ "\n"
#~ "\tp(x) dx = { exp(-x/a) over a (1 + exp(-x/a))^2 } dx for -infty < x < "
#~ "+infty.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDLOGISTIC(1).\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=ZUFALLSZAHL.LOGISTISCH\n"
#~ "@SYNTAX=ZUFALLSZAHL.LOGISTISCH(a)\n"
#~ "@DESCRIPTION=ZUFALLSZAHL.LOGISTISCH liefert eine logistisch verteilte "
#~ "Zufallszahl, wobei\n"
#~ "\n"
#~ "\tp(x) dx = { exp(-x/a) / a (1 + exp(-x/a))^2 } dx für -infty < x < "
#~ "+infty.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ZUFALLSZAHL.LOGISTISCH(1).\n"
#~ "\n"
#~ "@SEEALSO=ZUFALLSZAHL"

#~ msgid ""
#~ "@FUNCTION=RANDGEOM\n"
#~ "@SYNTAX=RANDGEOM(p)\n"
#~ "@DESCRIPTION=RANDGEOM returns a geometric-distributed random number. The "
#~ "number of independent trials with probability @p until the first success. "
#~ "The probability distribution for geometric variates is, \n"
#~ "\n"
#~ "\tp(k) =  p (1-p)^(k-1), for k >= 1.\n"
#~ "\n"
#~ "* If @p < 0 or @p > 1 RANDGEOM returns #NUM! error. \n"
#~ "@EXAMPLES=\n"
#~ "RANDGEOM(0.4).\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=ZUFALLSZAHL.GEOM\n"
#~ "@SYNTAX=ZUFALLSZAHL.GEOM(Wahrscheinlichkeit)\n"
#~ "@DESCRIPTION=ZUFALLSZAHL.GEOM liefert eine geometrisch verteilte "
#~ "Zufallszahl. DIes ist die Anzahl unabhängiger Versuche mit der "
#~ "Wahrscheinlichkeit @Wahrscheinlichkeit bis zum ersten Erfolg. Die "
#~ "Wahrscheinlichkeitsverteilung für geometrische Zufallsvariablen ist\n"
#~ "\n"
#~ "\tp(k) =  p (1-p)^(k-1), für k >= 1.\n"
#~ "\n"
#~ "* Falls @Wahrscheinlichkeit < 0 oder @Wahrscheinlichkeit > 1 ist, liefert "
#~ "ZUFALLSZAHL.GEOM einen #ZAHL!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ZUFALLSZAHL.GEOM(0.4).\n"
#~ "\n"
#~ "@SEEALSO=ZUFALLSZAHL"

#~ msgid ""
#~ "@FUNCTION=RANDHYPERG\n"
#~ "@SYNTAX=RANDHYPERG(n1,n2,t)\n"
#~ "@DESCRIPTION=RANDHYPERG returns a hypergeometric-distributed random "
#~ "number. The probability distribution for hypergeometric random variates "
#~ "is,\n"
#~ "\n"
#~ "\tp(k) =  C(n_1,k) C(n_2, t-k) / C(n_1 + n_2,k), \n"
#~ "\n"
#~ "where C(a,b) = a!/(b!(a-b)!). \n"
#~ "\n"
#~ "The domain of k is max(0,t-n_2), ..., max(t,n_1).\n"
#~ "@EXAMPLES=\n"
#~ "RANDHYPERG(21,1,9).\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=ZUFALLSZAHL.HYPERGEOM\n"
#~ "@SYNTAX=ZUFALLSZAHL.HYPERGEOM(n1,n2,t)\n"
#~ "@DESCRIPTION=ZUFALLSZAHL.HYPERGEOM liefert eine hypergeometrisch "
#~ "verteilte Zufallszahl. Die Wahrscheinlichkeitsverteilung für "
#~ "hyperheometrische Zufallsvariablen ist\n"
#~ "\n"
#~ "\tp(k) =  C(n_1,k) C(n_2, t-k) / C(n_1 + n_2,k), wobei\n"
#~ "\n"
#~ "C(a,b) = a!/(b!(a-b)!).\n"
#~ "\n"
#~ "Die Domäne von k ist max(0,t-n_2), ..., max(t,n_1).\n"
#~ "@EXAMPLES=\n"
#~ "ZUFALLSZAHL.HYPERGEOM(21,1,9).\n"
#~ "\n"
#~ "@SEEALSO=ZUFALLSZAHL"

#~ msgid ""
#~ "@FUNCTION=RANDLOG\n"
#~ "@SYNTAX=RANDLOG(p)\n"
#~ "@DESCRIPTION=RANDLOG returns a logarithmic-distributed random number.\n"
#~ "\n"
#~ "* If @p < 0 or @p > 1 RANDLOG returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDLOG(0.72).\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=ZUFALLSZAHL.LOG\n"
#~ "@SYNTAX=ZUFALLSZAHL.LOG(Wahrscheinlichkeit)\n"
#~ "@DESCRIPTION=ZUFALLSZAHL.LOG liefert eine logarithmisch verteilte "
#~ "Zufallszahl.\n"
#~ "\n"
#~ "* Falls @Wahrscheinlichkeit < 0 oder > 1 ist, liefert ZUFALLSZAHL.LOG "
#~ "einen #ZAHL!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ZUFALLSZAHL.LOG(0.72).\n"
#~ "\n"
#~ "@SEEALSO=ZUFALLSZAHL"

#~ msgid ""
#~ "@FUNCTION=RANDCHISQ\n"
#~ "@SYNTAX=RANDCHISQ(nu)\n"
#~ "@DESCRIPTION=RANDCHISQ returns a Chi-Square-distributed random number.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDCHISQ(0.5).\n"
#~ "\n"
#~ "@SEEALSO=RAND,RANDGAMMA"
#~ msgstr ""
#~ "@FUNCTION=ZUFALLSZAHL.CHI2\n"
#~ "@SYNTAX=ZUFALLSZAHL.CHI2(Zahl)\n"
#~ "@DESCRIPTION=ZUFALLSZAHL.CHI2 liefert eine Chi²-verteilte Zufallszahl.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ZUFALLSZAHL.CHI2(0.5).\n"
#~ "\n"
#~ "@SEEALSO=ZUFALLSZAHL,ZUFALLSZAHL.GAMMA"

#~ msgid ""
#~ "@FUNCTION=RANDTDIST\n"
#~ "@SYNTAX=RANDTDIST(nu)\n"
#~ "@DESCRIPTION=RANDTDIST returns a T-distributed random number.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDTDIST(0.5).\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=ZUFALLSZAHL.TVERT\n"
#~ "@SYNTAX=ZUFALLSZAHL.TVERT(Zahl)\n"
#~ "@DESCRIPTION=ZUFALLSZAHL.TVERT liefert eine T-verteilte Zufallszahl.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ZUFALLSZAHL.TVERT(0.5).\n"
#~ "\n"
#~ "@SEEALSO=ZUFALLSZAHL"

#~ msgid ""
#~ "@FUNCTION=RANDGUMBEL\n"
#~ "@SYNTAX=RANDGUMBEL(a,b[,type])\n"
#~ "@DESCRIPTION=RANDGUMBEL returns a Type I or Type II Gumbel-distributed "
#~ "random number. @type is either 1 or 2 and specifies the type of the "
#~ "distribution (Type I or Type II).\n"
#~ "\n"
#~ "* If @type is neither 1 nor 2, RANDGUMBEL returns #NUM! error.\n"
#~ "* If @type is omitted, Type I is assumed.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDGUMBEL(0.5,1,2).\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=ZUFALLSZAHL.GUMBEL\n"
#~ "@SYNTAX=ZUFALLSZAHL.GUMBEL(a,b[,Typ])\n"
#~ "@DESCRIPTION=ZUFALLSZAHL.GUMBEL liefert eine Gumbel Typ I oder Typ II-"
#~ "verteilte Zufallszahl. @Typ ist entweder 1 oder 2 und legt den Typ der "
#~ "Verteilung fest (Typ I or Typ II).\n"
#~ "\n"
#~ "* Falls @Typ weder 1 noch 2 ist, liefert ZUFALLSZAHL.GUMBEL einen #ZAHL!-"
#~ "Fehler.\n"
#~ "* Falls @Typ nicht übergeben wird, wird Typ I angenommen.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ZUFALLSZAHL.GUMBEL(0.5,1,2).\n"
#~ "\n"
#~ "@SEEALSO=ZUFALLSZAHL"

#~ msgid ""
#~ "@FUNCTION=RANDLEVY\n"
#~ "@SYNTAX=RANDLEVY(c,alpha[,beta])\n"
#~ "@DESCRIPTION=RANDLEVY returns a Levy-distributed random number. If @beta "
#~ "is omitted, it is assumed to be 0.\n"
#~ "\n"
#~ "* For @alpha = 1, @beta=0, we get the Lorentz distribution.\n"
#~ "* For @alpha = 2, @beta=0, we get the normal distribution.\n"
#~ "\n"
#~ "* If @alpha <= 0 or @alpha > 2, RANDLEVY returns #NUM! error.\n"
#~ "* If @beta < -1 or @beta > 1, RANDLEVY returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDLEVY(0.5,0.1,1).\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=ZUFALLSZAHL.LEVY\n"
#~ "@SYNTAX=ZUFALLSZAHL.LEVY(c,Alpha[,Beta])\n"
#~ "@DESCRIPTION=ZUFALLSZAHL.LEVY liefert eine Lévy-verteilte Zufallszahl.\n"
#~ "\n"
#~ "* Für Alpha = 1 und Beta = 0 wird die Lorentz-Verteilung verwendet.\n"
#~ "* Für Alpha = 2 und Beta = 0 wird die Gauß'sche Verteilung verwendet.\n"
#~ "\n"
#~ "* Falls @Beta nicht übergeben wird, wird @Beta = 0 angenommen.\n"
#~ "* Falls @Alpha <= 0 oder > 2 ist, liefert ZUFALLSZAHL.LEVY einen #ZAHL!-"
#~ "Fehler.\n"
#~ "* Falls @Beta < -1 oder > 1 ist, liefert ZUFALLSZAHL.LEVY einen #ZAHL!-"
#~ "Fehler .\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ZUFALLSZAHL.LEVY(0.5,0.1,1).\n"
#~ "\n"
#~ "@SEEALSO=ZUFALLSZAHL"

#~ msgid ""
#~ "@FUNCTION=RANDEXPPOW\n"
#~ "@SYNTAX=RANDEXPPOW(a,b)\n"
#~ "@DESCRIPTION=RANDEXPPOW returns a random variate from the exponential "
#~ "power distribution with scale parameter @a and exponent @b. The "
#~ "distribution is,\n"
#~ "\n"
#~ "\tp(x) dx = {1 over 2 a Gamma(1+1/b)} exp(-|x/a|^b) dx, for x >= 0.\n"
#~ "\n"
#~ "* For @b = 1 this reduces to the Laplace distribution.\n"
#~ "* For @b = 2 it has the same form as a normal distribution with sigma = a/"
#~ "sqrt(2).\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDEXPPOW(0.5,0.1).\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=ZUFALLSZAHL.EXPPOW\n"
#~ "@SYNTAX=ZUFALLSZAHL.EXPPOW(a,b)\n"
#~ "@DESCRIPTIONZUFALLSZAHL.EXPPOW liefert eine Zufallsvariable der "
#~ "»exponential power distribution« mit Skalierungsparameter @a und Exponent "
#~ "@b. Die Verteilung ist\n"
#~ "\n"
#~ "\tp(x) dx = {1 durch 2 a Gamma(1+1/b)} exp(-|x/a|^b) dx, für x >= 0.\n"
#~ "\n"
#~ "* Falls b = 1 ist, wird dies auf die Laplace-Verteilung beschränkt.\n"
#~ "* Falls b = 2 ist, entspricht die Form derer der Gauß'schen Verteilung, "
#~ "jedoch mit a = sqrt{2} Sigma.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ZUFALLSZAHL.EXPPOW(0.5,0.1).\n"
#~ "\n"
#~ "@SEEALSO=ZUFALLSZAHL"

#~ msgid ""
#~ "@FUNCTION=RANDLANDAU\n"
#~ "@SYNTAX=RANDLANDAU()\n"
#~ "@DESCRIPTION=RANDLANDAU returns a random variate from the Landau "
#~ "distribution. The probability distribution for Landau random variates is "
#~ "defined analytically by the complex integral,\n"
#~ "\n"
#~ "\tp(x) = (1/(2 pi i)) int_{c-i infty}^{c+i infty} ds exp(s log(s) + x "
#~ "s).\n"
#~ "\n"
#~ "For numerical purposes it is more convenient to use the following "
#~ "equivalent form of the integral,\n"
#~ "\n"
#~ "\tp(x) = (1/pi) int_0^ infty dt exp(-t log(t) - x t) sin(pi t).\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDLANDAU().\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=ZUFALLSZAHL.LANDAU\n"
#~ "@SYNTAX=ZUFALLSZAHL.LANDAU()\n"
#~ "@DESCRIPTION=ZUFALLSZAHL.LANDAU liefert eine Zufallsvariable der "
#~ "Landauverteilung. Die Wahrscheinlichkeitsverteilung für Landau-"
#~ "Zufallsvariablen ist analytisch vom komplexen Integral definiert: \n"
#~ "\n"
#~ "\tp(x) = (1/(2 pi i)) int_{c-i infty}^{c+i infty} ds exp(s log(s) + x "
#~ "s).\n"
#~ "\n"
#~ "Aus mathematischer Sicht ist folgende äquivalente Schreibweise wesentlich "
#~ "zweckmäßiger:\n"
#~ "\n"
#~ "\tp(x) = (1/pi) int_0^ infty dt exp(-t log(t) - x t) sin(pi t).\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ZUFALLSZAHL.LANDAU().\n"
#~ "\n"
#~ "@SEEALSO=RAND"

#~ msgid ""
#~ "@FUNCTION=RANDNORMTAIL\n"
#~ "@SYNTAX=RANDNORMTAIL(a,sigma)\n"
#~ "@DESCRIPTION=RANDNORMTAIL returns a random variates from the upper tail "
#~ "of a normal distribution with standard deviation @sigma. The values "
#~ "returned are larger than the lower limit @a, which must be positive. The "
#~ "method is based on Marsaglia's famous rectangle-wedge-tail algorithm (Ann "
#~ "Math Stat 32, 894-899 (1961)), with this aspect explained in Knuth, v2, "
#~ "3rd ed, p139, 586 (exercise 11).\n"
#~ "\n"
#~ "The probability distribution for normal tail random variates is,\n"
#~ "\n"
#~ "\tp(x) dx = {1 over N(a;sigma)} exp (- x^2/(2 sigma^2)) dx,\n"
#~ "\n"
#~ "for x > a where N(a;sigma) is the normalization constant, N(a;sigma) = "
#~ "(1/2) erfc(a / sqrt(2 sigma^2)).\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RANDNORMTAIL(0.5,0.1).\n"
#~ "\n"
#~ "@SEEALSO=RAND"
#~ msgstr ""
#~ "@FUNCTION=ZUFALLSZAHL.GAUSSSCHERTAIL\n"
#~ "@SYNTAX=ZUFALLSZAHL.GAUSSSCHERTAIL(a,Sigma)\n"
#~ "@DESCRIPTION=ZUFALLSZAHL.GAUSSSCHERTAIL liefert eine Zufallsvariable aus "
#~ "dem oberen Tail einer Gauß'schen Verteilung mit Standardabweichung "
#~ "@Sigma. Die gelieferten Werte sind größer als der limes inferior a, "
#~ "welcher Positiv sein muss. Die Methode basiert auf Marsaglias bekanntem "
#~ "Rechtecks-Wedge-Tail-Algorithmus (Ann Math Stat 32, 894-899 (1961)), "
#~ "wobei dieser Aspekt in Knuth, v2, dritte Ausgabe, S. 139, 586 (Übung 11) "
#~ "erklärt wird.\n"
#~ "\n"
#~ "Die Wahrscheinlichkeitsverteilung für Zufallsvariablen im Gauß'schen Tail "
#~ "ist\n"
#~ "\n"
#~ "\tp(x) dx = {1 durch N(a;sigma)} exp (- x^2/(2 sigma^2)) dx,\n"
#~ "\n"
#~ "für x > a, wobei N(a;sigma) die Normalisierungskonstante ist, N(a;sigma) "
#~ "= (1/2) erfc(a / sqrt(2 sigma^2)).\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ZUFALLSZAHL.GAUSSSCHERTAIL(0.5,0.1).\n"
#~ "\n"
#~ "@SEEALSO=ZUFALLSZAHL"

#~ msgid ""
#~ "@FUNCTION=VARP\n"
#~ "@SYNTAX=VARP(b1, b2, ...)\n"
#~ "@DESCRIPTION=VARP calculates the variance of an entire population.\n"
#~ "VARP is also known as the N-variance.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "VARP(A1:A5) equals 94.112.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,DVAR,DVARP,STDEV,VAR"
#~ msgstr ""
#~ "@FUNCTION=VARIANZN\n"
#~ "@SYNTAX=VARIANZN(b1, b2, ...)\n"
#~ "@DESCRIPTION=VARIANZN berechnet die Varianz eines Zahlensatzes, wobei "
#~ "jede Zahl Mitglied einer Grundgesamtheit ist und der Datensatz die "
#~ "gesamte Grundgesamtheit.\n"
#~ "\n"
#~ "* VARIANZN ist auch als N-Varianz bekannt.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, die Zellen A1, A2, ..., A5 enthalten die Zahlen 11.4, 17.3, "
#~ "21.3, 25.9 und 40.1. Dann liefert\n"
#~ "VARIANZN(A1:A5) 94.112.\n"
#~ "\n"
#~ "@SEEALSO=MITTELWERT,DBVARIANZ,DBVARIANZN,STDABW,VARIANZ"

#~ msgid ""
#~ "@FUNCTION=VAR\n"
#~ "@SYNTAX=VAR(b1, b2, ...)\n"
#~ "@DESCRIPTION=VAR calculates sample variance of the given sample. To get "
#~ "the true variance of a complete population use VARP.\n"
#~ "VAR is also known as the N-1-variance. Under reasonable conditions, it is "
#~ "the maximum-likelihood estimator for the true variance.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "VAR(A1:A5) equals 117.64.\n"
#~ "\n"
#~ "@SEEALSO=VARP,STDEV"
#~ msgstr ""
#~ "@FUNCTION=VARIANZ\n"
#~ "@SYNTAX=VARIANZ(b1, b2, ...)\n"
#~ "@DESCRIPTION=VARIANZ liefert die geschätzte Abweichung einer Stichprobe "
#~ "von einer Grundgesamtheit. Zur Bestimmung der tatsächlichen Varianz einer "
#~ "gesamten Grundgesamtheit müssen Sie die Funktion @VARIANZN verwenden.\n"
#~ "\n"
#~ "* VARIANZ ist auch als N-1-Varianz bekannt. Unter reellen Bedingungen ist "
#~ "dies der wahrscheinlichste Schätzwert für die wahre Varianz.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, die Zellen A1, A2, ..., A5 enthalten die Zahlen 11.4, 17.3, "
#~ "21.3, 25.9 und 40.1. Dann liefert\n"
#~ "VARIANZ(A1:A5) 117.64.\n"
#~ "\n"
#~ "@SEEALSO=VARIANZN,STDABW"

#~ msgid ""
#~ "@FUNCTION=STDEV\n"
#~ "@SYNTAX=STDEV(b1, b2, ...)\n"
#~ "@DESCRIPTION=STDEV returns the sample standard deviation of the given "
#~ "sample.\n"
#~ "To obtain the population standard deviation of a whole population use "
#~ "STDEVP.\n"
#~ "STDEV is also known as the N-1-standard deviation.\n"
#~ "Under reasonable conditions, it is the maximum-likelihood estimator for "
#~ "the true population standard deviation.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "STDEV(A1:A5) equals 10.84619749.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,DSTDEV,DSTDEVP,STDEVA,STDEVPA,VAR"
#~ msgstr ""
#~ "@FUNCTION=VARIANZ\n"
#~ "@SYNTAX=VARIANZ(b1, b2, ...)\n"
#~ "@DESCRIPTION=VARIANZ liefert die geschätzte Abweichung einer Stichprobe "
#~ "von einer Grundgesamtheit. Zur Bestimmung der tatsächlichen Varianz einer "
#~ "gesamten Grundgesamtheit müssen Sie die Funktion @VARIANZN verwenden.\n"
#~ "\n"
#~ "* VARIANZ ist auch als N-1-Varianz bekannt. Unter reellen Bedingungen ist "
#~ "dies der wahrscheinlichste Schätzwert für die wahre Varianz.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, die Zellen A1, A2, ..., A5 enthalten die Zahlen 11.4, 17.3, "
#~ "21.3, 25.9 und 40.1. Dann liefert\n"
#~ "VARIANZ(A1:A5) 117.64.\n"
#~ "\n"
#~ "@SEEALSO=VARIANZN,STDABW"

#~ msgid ""
#~ "@FUNCTION=STDEVP\n"
#~ "@SYNTAX=STDEVP(b1, b2, ...)\n"
#~ "@DESCRIPTION=STDEVP returns the population standard deviation of the "
#~ "given population. \n"
#~ "This is also known as the N-standard deviation\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "STDEVP(A1:A5) equals 9.701133954.\n"
#~ "\n"
#~ "@SEEALSO=STDEV,STDEVA,STDEVPA"
#~ msgstr ""
#~ "@FUNCTION=STDABWN\n"
#~ "@SYNTAX=STDABWN(b1, b2, ...)\n"
#~ "@DESCRIPTION=STDABWN liefert die Standardabweichung eines Zahlensatzes, "
#~ "wobei diese Zahlen als Mitglieder einer gesamten Grundgesamtheit "
#~ "angesehen werden.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, die Zellen A1, A2, ..., A5 enthalten die Zahlen 11.4, 17.3, "
#~ "21.3, 25.9 und 40.1. Dann liefert\n"
#~ "STDABWN(A1:A5) 9.701133954.\n"
#~ "\n"
#~ "@SEEALSO=STDABW,STDABW2,STDABWN2"

#~ msgid ""
#~ "@FUNCTION=RANK\n"
#~ "@SYNTAX=RANK(x,ref[,order])\n"
#~ "@DESCRIPTION=RANK returns the rank of a number in a list of numbers.  @x "
#~ "is the number whose rank you want to find, @ref is the list of numbers, "
#~ "and @order specifies how to rank numbers.  If @order is 0, numbers are "
#~ "ranked in descending order, otherwise numbers are ranked in ascending "
#~ "order.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "RANK(17.3,A1:A5) equals 4.\n"
#~ "\n"
#~ "@SEEALSO=PERCENTRANK"
#~ msgstr ""
#~ "@FUNCTION=RANG\n"
#~ "@SYNTAX=RANG(x,Bezug[,Reihenfolge])\n"
#~ "@DESCRIPTION=RANG liefert den Rang einer Zahl in einer Liste mit Zahlen. "
#~ "@x ist die Zahl, nach deren Rang gesucht werden soll, @Bezug die Liste "
#~ "mit den Zahlen und @Reihenfolge gibt an, wie in welcher Reihenfolge die "
#~ "Zahlen aufgereiht werden. Falls @Reihenfolge 0 ist, werden die Zahlen in "
#~ "absteigender, andernfalls in aufsteigender Reihenfolge verarbeitet.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, die Zellen A1, A2, ..., A5 enthalten die Zahlen 11.4, 17.3, "
#~ "21.3, 25.9 und 40.1. Dann liefert\n"
#~ "RANG(17.3,A1:A5) 4.\n"
#~ "\n"
#~ "@SEEALSO=PROZENTRANG"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=TRIMMEAN\n"
#~ "@SYNTAX=TRIMMEAN(ref,fraction)\n"
#~ "@DESCRIPTION=TRIMMEAN returns the mean of the interior of a data set. "
#~ "@ref is the list of numbers whose mean you want to calculate and "
#~ "@fraction is the fraction of the data set excluded from the mean. For "
#~ "example, if @fraction=0.2 and the data set contains 40 numbers, 8 numbers "
#~ "are trimmed from the data set (40 x 0.2): the 4 largest and the 4 "
#~ "smallest.  To avoid a bias, the number of points to be excluded is always "
#~ "rounded down to the nearest even number.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "TRIMMEAN(A1:A5,0.2) equals 23.2.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,GEOMEAN,HARMEAN,MEDIAN,MODE"
#~ msgstr ""
#~ "@FUNCTION=RANG\n"
#~ "@SYNTAX=RANG(x,Bezug[,Reihenfolge])\n"
#~ "@DESCRIPTION=RANG liefert den Rang einer Zahl in einer Liste mit Zahlen. "
#~ "@x ist die Zahl, nach deren Rang gesucht werden soll, @Bezug die Liste "
#~ "mit den Zahlen und @Reihenfolge gibt an, wie in welcher Reihenfolge die "
#~ "Zahlen aufgereiht werden. Falls @Reihenfolge 0 ist, werden die Zahlen in "
#~ "absteigender, andernfalls in aufsteigender Reihenfolge verarbeitet.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, die Zellen A1, A2, ..., A5 enthalten die Zahlen 11.4, 17.3, "
#~ "21.3, 25.9 und 40.1. Dann liefert\n"
#~ "RANG(17.3,A1:A5) 4.\n"
#~ "\n"
#~ "@SEEALSO=PROZENTRANG"

#~ msgid ""
#~ "@FUNCTION=COVAR\n"
#~ "@SYNTAX=COVAR(array1,array2)\n"
#~ "@DESCRIPTION=COVAR returns the covariance of two data sets.\n"
#~ "\n"
#~ "* Strings and empty cells are simply ignored.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1, and the cells B1, B2, ... B5 23.2, 25.8, 29.9, "
#~ "33.5, and 42.7.  Then\n"
#~ "COVAR(A1:A5,B1:B5) equals 65.858.\n"
#~ "\n"
#~ "@SEEALSO=CORREL,FISHER,FISHERINV"
#~ msgstr ""
#~ "@FUNCTION=KOVAR\n"
#~ "@SYNTAX=KOVAR(Datenfeld1,Datenfeld2)\n"
#~ "@DESCRIPTION=KOVAR liefert die Kovarianz zweier Datensätze.\n"
#~ "\n"
#~ "* Zeichenketten und leere Zellen werden ignoriert.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, die Zellen A1, A2, ..., A5 enthalten die Zahlen 11.4, 17.3, "
#~ "21.3, 25.9 und 40.1 und die Zellen B1, B2, ... B5 23.2, 25.8, 29.9, 33.5 "
#~ "und 42.7. Dann liefert\n"
#~ "COVAR(A1:A5,B1:B5) 65.858.\n"
#~ "\n"
#~ "@SEEALSO=KORREL,FISHER,FISHERINV"

#~ msgid ""
#~ "@FUNCTION=CORREL\n"
#~ "@SYNTAX=CORREL(array1,array2)\n"
#~ "@DESCRIPTION=CORREL returns the correlation coefficient of two data "
#~ "sets.\n"
#~ "\n"
#~ "* Strings and empty cells are simply ignored.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1, and the cells B1, B2, ... B5 23.2, 25.8, 29.9, "
#~ "33.5, and 42.7.  Then\n"
#~ "CORREL(A1:A5,B1:B5) equals 0.996124788.\n"
#~ "\n"
#~ "@SEEALSO=COVAR,FISHER,FISHERINV"
#~ msgstr ""
#~ "@FUNCTION=KORREL\n"
#~ "@SYNTAX=KORREL(Datenfeld1,Datenfeld2)\n"
#~ "@DESCRIPTION=KORREL liefert den Korrelationskoeffizienten zweier "
#~ "Datensätze.\n"
#~ "\n"
#~ "* Zeichenketten und leere Zellen werden ignoriert.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, die Zellen A1, A2, ..., A5 enthalten die Zahlen 11.4, 17.3, "
#~ "21.3, 25.9 und 40.1, und die Zellen B1, B2, ... B5 23.2, 25.8, 29.9, 33.5 "
#~ "und 42.7. Dann liefert\n"
#~ "KORREL(A1:A5,B1:B5) 0.996124788.\n"
#~ "\n"
#~ "@SEEALSO=KOVAR,FISHER,FISHERINV"

#~ msgid ""
#~ "@FUNCTION=NEGBINOMDIST\n"
#~ "@SYNTAX=NEGBINOMDIST(f,t,p)\n"
#~ "@DESCRIPTION=NEGBINOMDIST function returns the negative binomial "
#~ "distribution. @f is the number of failures, @t is the threshold number of "
#~ "successes, and @p is the probability of a success.\n"
#~ "\n"
#~ "* If @f or @t is a non-integer it is truncated.\n"
#~ "* If (@f + @t -1) <= 0 NEGBINOMDIST returns #NUM! error.\n"
#~ "* If @p < 0 or @p > 1 NEGBINOMDIST returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "NEGBINOMDIST(2,5,0.55) equals 0.152872629.\n"
#~ "\n"
#~ "@SEEALSO=BINOMDIST,COMBIN,FACT,HYPGEOMDIST,PERMUT"
#~ msgstr ""
#~ "@FUNCTION=NEGBINOMVERT\n"
#~ "@SYNTAX=NEGBINOMVERT(Fehlschläge,Versuche,Wahrscheinlichkeit)\n"
#~ "@DESCRIPTION=NEGBINOMVERT liefert die negative Binominalverteilung. @f "
#~ "ist die Anzahl der Fehlschläge, @Versuche der Schwellwert der Anzahl "
#~ "erfolgreicher Versuche und @Wahrscheinlichkeit die Wahrscheinlichkeit, "
#~ "dass ein Versuch erfolgreich ist.\n"
#~ "\n"
#~ "* Falls @Fehlschläge oder @Versuche keine Ganzzahl ist, werden die "
#~ "Nachkommastellen abgeschnitten.\n"
#~ "* Falls (@Fehlschläge + @Versuche -1) <= 0 ist, liefert NEGBINOMVERT "
#~ "einen #ZAHL!-Fehler.\n"
#~ "* Falls @Wahrscheinlichkeit < 0 oder > 1 ist, liefert NEGBINOMVERT einen "
#~ "#ZAHL!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "NEGBINOMVERT(2,5,0.55) liefert 0.152872629.\n"
#~ "\n"
#~ "@SEEALSO=BINOMVERT,KOMBINATIONEN,FAKULTÄT,HYPGEOMVERT,PERMUT"

#~ msgid ""
#~ "@FUNCTION=NORMSDIST\n"
#~ "@SYNTAX=NORMSDIST(x)\n"
#~ "@DESCRIPTION=NORMSDIST function returns the standard normal cumulative "
#~ "distribution. @x is the value for which you want the distribution.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "NORMSDIST(2) equals 0.977249868.\n"
#~ "\n"
#~ "@SEEALSO=NORMDIST"
#~ msgstr ""
#~ "@FUNCTION=STANDNORMVERT\n"
#~ "@SYNTAX=STANDNORMVERT(x)\n"
#~ "@DESCRIPTION=STANDNORMVERT liefert die kumulative Standard-"
#~ "Normalverteilung. @x ist der Wert, für den die Verteilung erzeugt werden "
#~ "soll.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "STANDNORMVERT(2) liefert 0.977249868.\n"
#~ "\n"
#~ "@SEEALSO=NORMVERT"

#~ msgid ""
#~ "@FUNCTION=NORMSINV\n"
#~ "@SYNTAX=NORMSINV(p)\n"
#~ "@DESCRIPTION=NORMSINV function returns the inverse of the standard normal "
#~ "cumulative distribution. @p is the given probability corresponding to the "
#~ "normal distribution.\n"
#~ "\n"
#~ "* If @p < 0 or @p > 1 NORMSINV returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "NORMSINV(0.2) equals -0.841621234.\n"
#~ "\n"
#~ "@SEEALSO=NORMDIST,NORMINV,NORMSDIST,STANDARDIZE,ZTEST"
#~ msgstr ""
#~ "@FUNCTION=STANDNORMINV\n"
#~ "@SYNTAX=STANDNORMINV(Wahrscheinlichkeit)\n"
#~ "@DESCRIPTION=STANDNORMINV liefert die inverse kumulative Standard-"
#~ "Normalverteilung. @Wahrscheinlichkeit ist die angegebene, der "
#~ "Normalverteilung entsprechende Wahrscheinlichkeit.\n"
#~ "\n"
#~ "* Falls @Wahrscheinlichkeit < 0 oder @Wahrscheinlichkeit > 1 ist, liefert "
#~ "STANDNORMINV einen #ZAHL!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "STANDNORMINV(0.2) liefert -0.841621234.\n"
#~ "\n"
#~ "@SEEALSO=NORMVERT,NORMINV,STANDNORMVERT,NORMIEREN,ZTEST"

#~ msgid ""
#~ "@FUNCTION=LOGNORMDIST\n"
#~ "@SYNTAX=LOGNORMDIST(x,mean,stddev)\n"
#~ "@DESCRIPTION=LOGNORMDIST function returns the lognormal distribution. @x "
#~ "is the value for which you want the distribution, @mean is the mean of "
#~ "the distribution, and @stddev is the standard deviation of the "
#~ "distribution.\n"
#~ "\n"
#~ "* If @stddev = 0 LOGNORMDIST returns #DIV/0! error.\n"
#~ "* If @x <= 0, @mean < 0 or @stddev < 0 LOGNORMDIST returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LOGNORMDIST(3,1,2) equals 0.519662338.\n"
#~ "\n"
#~ "@SEEALSO=NORMDIST"
#~ msgstr ""
#~ "@FUNCTION=LOGNORMVERT\n"
#~ "@SYNTAX=LOGNORMVERT(x,Mittelwert,Stdabw)\n"
#~ "@DESCRIPTION=LOGNORMVERT liefert die Lognormal-Verteilung. @x ist der "
#~ "Wert, für den die Verteilung berechnet werden soll, @Mittelwert der "
#~ "Mittelwert der Verteilung und @Stdabw die Standardabweichung von der "
#~ "Verteilung.\n"
#~ "\n"
#~ "* Falls @Stdabw = 0 ist, liefert LOGNORMVERT einen #DIV/0!-Fehler.\n"
#~ "* Falls @x <= 0, @Mittelwert < 0 oder @Stdabw < 0 ist, liefert "
#~ "LOGNORMVERT einen #ZAHL!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LOGNORMVERT(3,1,2) liefert 0.519662338.\n"
#~ "\n"
#~ "@SEEALSO=NORMVERT"

#~ msgid ""
#~ "@FUNCTION=LOGINV\n"
#~ "@SYNTAX=LOGINV(p,mean,stddev)\n"
#~ "@DESCRIPTION=LOGINV function returns the inverse of the lognormal "
#~ "cumulative distribution. @p is the given probability corresponding to the "
#~ "normal distribution, @mean is the arithmetic mean of the distribution, "
#~ "and @stddev is the standard deviation of the distribution.\n"
#~ "\n"
#~ "* If @p < 0 or @p > 1 or @stddev <= 0 LOGINV returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LOGINV(0.5,2,3) equals 7.389056099.\n"
#~ "\n"
#~ "@SEEALSO=EXP,LN,LOG,LOG10,LOGNORMDIST"
#~ msgstr ""
#~ "@FUNCTION=LOGINV\n"
#~ "@SYNTAX=LOGINV(Wahrscheinlichkeit,Mittelwert,Stdabw)\n"
#~ "@DESCRIPTION=LOGINV liefert die inverse Lognormal-Verteilung. "
#~ "@Wahrscheinlichkeit ist die der Normalverteilung entsprechende "
#~ "Wahrscheinlichkeit, @Mittelwert der arithmetische Mittelwert der "
#~ "Verteilung und @Stdabw ist die Standardabweichung von der Funktion.\n"
#~ "\n"
#~ "* Falls @Wahrscheinlichkeit < 0 oder > 1 oder @Stdabw <= 0 ist, liefert "
#~ "LOGINV einen #ZAHL!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LOGINV(0.5,2,3) liefert 7.389056099.\n"
#~ "\n"
#~ "@SEEALSO=EXP,LN,LOG,LOG10,LOGNORMVERT"

#~ msgid ""
#~ "@FUNCTION=FISHERINV\n"
#~ "@SYNTAX=FISHERINV(x)\n"
#~ "@DESCRIPTION=FISHERINV function returns the inverse of the Fisher "
#~ "transformation at @x.\n"
#~ "\n"
#~ "* If @x is non-number FISHERINV returns #VALUE! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FISHERINV(2) equals 0.96402758.\n"
#~ "\n"
#~ "@SEEALSO=FISHER"
#~ msgstr ""
#~ "@FUNCTION=FISHERINV\n"
#~ "@SYNTAX=FISHERINV(x)\n"
#~ "@DESCRIPTION=FISHERINV liefert die inverse Fisher-Transformation bei @x.\n"
#~ "\n"
#~ "* Falls @x keine Zahl ist, liefert FISHERINV einen #WERT!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FISHERINV(2) liefert 0.96402758.\n"
#~ "\n"
#~ "@SEEALSO=FISHER"

#~ msgid ""
#~ "@FUNCTION=MODE\n"
#~ "@SYNTAX=MODE(n1, n2, ...)\n"
#~ "@DESCRIPTION=MODE returns the most common number of the data set. If the "
#~ "data set has many most common numbers MODE returns the first one of "
#~ "them.\n"
#~ "\n"
#~ "* Strings and empty cells are simply ignored.\n"
#~ "* If the data set does not contain any duplicates MODE returns #N/A "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "11.4, 25.9, and 40.1.  Then\n"
#~ "MODE(A1:A5) equals 11.4.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,MEDIAN"
#~ msgstr ""
#~ "@FUNCTION=MODALWERT\n"
#~ "@SYNTAX=MODALWERT(n1, n2, ...)\n"
#~ "@DESCRIPTION=MODALWERT liefert die am Häufigsten in den Datensätzen "
#~ "auftauchende Zahl. Falls mehrere Zahlen am Häufigsten auftauchen, liefert "
#~ "MODALWERT die erste von diesen.\n"
#~ "\n"
#~ "* Zeichenketten und leere Zellen werden ignoriert.\n"
#~ "* Falls keine Zahl mehrmals in den Datensätzen vorkommt, liefert "
#~ "MODALWERT einen #-/-!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, die Zellen A1, A2, ..., A5 enthalten die Zahlen 11.4, 17.3, "
#~ "11.4, 25.9 und 40.1. Dann liefert\n"
#~ "MODALWERT(A1:A5) 11.4.\n"
#~ "\n"
#~ "@SEEALSO= :: LATER"

#~ msgid ""
#~ "@FUNCTION=HARMEAN\n"
#~ "@SYNTAX=HARMEAN(b1, b2, ...)\n"
#~ "@DESCRIPTION=HARMEAN returns the harmonic mean of the N data points (that "
#~ "is, N divided by the sum of the inverses of the data points).\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "HARMEAN(A1:A5) equals 19.529814427.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,GEOMEAN,MEDIAN,MODE,TRIMMEAN"
#~ msgstr ""
#~ "@FUNCTION=HARMITTEL\n"
#~ "@SYNTAX=HARMITTEL(b1, b2, ...)\n"
#~ "@DESCRIPTION=HARMITTEL liefert den harmonischen Mittelwert von N "
#~ "Datenpunkten (also N geteilt durch Summe der Inversen der Datenpunkte).\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, die Zellen A1, A2, ..., A5 enthalten die Zahlen 11.4, 17.3, "
#~ "21.3, 25.9 und 40.1. Dann liefert\n"
#~ "HARMITTEL(A1:A5) 19.529814427.\n"
#~ "\n"
#~ "@SEEALSO= :: LATER"

#~ msgid ""
#~ "@FUNCTION=GEOMEAN\n"
#~ "@SYNTAX=GEOMEAN(b1, b2, ...)\n"
#~ "@DESCRIPTION=GEOMEAN returns the geometric mean of the given arguments. "
#~ "This is equal to the Nth root of the product of the terms.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "GEOMEAN(A1:A5) equals 21.279182482.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,HARMEAN,MEDIAN,MODE,TRIMMEAN"
#~ msgstr ""
#~ "@FUNCTION=GEOMITTEL\n"
#~ "@SYNTAX=GEOMITTEL(b1,b2[,...])\n"
#~ "@DESCRIPTION=GEOMITTEL liefert den geometrischen Mittelwert der "
#~ "angegebenen Argumente. Dies entspricht der n-ten Wurzel dieser Terme.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, die Zellen A1, A2, ..., A5 enthalten die Zahlen 11.4, 17.3, "
#~ "21.3, 25.9 und 40.1. Dann liefert\n"
#~ "GEOMITTEL(A1:A5) 21.279182482.\n"
#~ "\n"
#~ "@SEEALSO=MITTEL,HARMEAN,MEDIAN,MODE,TRIMMEAN"

#~ msgid ""
#~ "@FUNCTION=COUNT\n"
#~ "@SYNTAX=COUNT(b1, b2, ...)\n"
#~ "@DESCRIPTION=COUNT returns the total number of integer or floating point "
#~ "arguments passed.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "COUNT(A1:A5) equals 5.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE"
#~ msgstr ""
#~ "@FUNCTION=ANZAHL\n"
#~ "@SYNTAX=ANZAHL(b1,b2,...)\n"
#~ "@DESCRIPTION=ANZAHL liefert die Gesamtanzahl übergebener ganzzahliger und "
#~ "Fließkomma-Argumente.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=MITTELWERT"

#~ msgid ""
#~ "@FUNCTION=COUNTA\n"
#~ "@SYNTAX=COUNTA(b1, b2, ...)\n"
#~ "@DESCRIPTION=COUNTA returns the number of arguments passed not including "
#~ "empty cells.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers and strings "
#~ "11.4, \"missing\", \"missing\", 25.9, and 40.1.  Then\n"
#~ "COUNTA(A1:A5) equals 5.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,COUNT,DCOUNT,DCOUNTA,PRODUCT,SUM"
#~ msgstr ""
#~ "@FUNCTION=ANZAHL2\n"
#~ "@SYNTAX=ANZAHL2(b1, b2, ...)\n"
#~ "@DESCRIPTION=ANZAHL2 liefert die Anzahl der übergebenen Argumente, wobei "
#~ "leere Zellen nicht gezählt werden.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, die Zellen A1, A2, ..., A5 enthalten die Zahlen und "
#~ "Zeichenketten 11.4, \"fehlt\", \"fehlt\", 25.9, and 40.1. Dann liefert\n"
#~ "ANZAHL2(A1:A5) 5.\n"
#~ "\n"
#~ "@SEEALSO= :: LATER"

#~ msgid ""
#~ "@FUNCTION=AVERAGE\n"
#~ "@SYNTAX=AVERAGE(value1, value2,...)\n"
#~ "@DESCRIPTION=AVERAGE computes the average of all the values and cells "
#~ "referenced in the argument list.  This is equivalent to the sum of the "
#~ "arguments divided by the count of the arguments.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "AVERAGE(A1:A5) equals 23.2.\n"
#~ "\n"
#~ "@SEEALSO=SUM, COUNT"
#~ msgstr ""
#~ "@FUNCTION=MITTELWERT\n"
#~ "@SYNTAX=MITTELWERT(Wert1,Wert2[,...])\n"
#~ "@DESCRIPTION=MITTELWERT berechnet den Mittelwert aller übergebenen Werte "
#~ "und Zellen. Dieser wird durch das Teilen der Gesamtsumme der Argumente "
#~ "durch die Anzahl selbiger berechnet.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, die Zellen A1, A2, ..., A5 enthalten die Zahlen 11.4, 17.3, "
#~ "21.3, 25.9 und 40.1. Dann liefert\n"
#~ "MITTELWERT(A1:A5) 23.2.\n"
#~ "\n"
#~ "@SEEALSO=SUMME, ANZAHL"

#~ msgid ""
#~ "@FUNCTION=MIN\n"
#~ "@SYNTAX=MIN(b1, b2, ...)\n"
#~ "@DESCRIPTION=MIN returns the value of the element of the values passed "
#~ "that has the smallest value, with negative numbers considered smaller "
#~ "than positive numbers.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "MIN(A1:A5) equals 11.4.\n"
#~ "\n"
#~ "@SEEALSO=MAX,ABS"
#~ msgstr ""
#~ "@FUNCTION=MIN\n"
#~ "@SYNTAX=MIN(b1, b2, ...)\n"
#~ "@DESCRIPTION=MIN liefert den Wert des übergebenen Elements mit dem "
#~ "kleinsten Wert. Hierbei wird angenommen, dass der Wert von negativen "
#~ "kleiner als der von positiven Zahlen ist.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, die Zellen A1, A2, ..., A5 enthalten die Zahlen 11.4, 17.3, "
#~ "21.3, 25.9 und 40.1. Dann liefert\n"
#~ "MIN(A1:A5) 11.4.\n"
#~ "\n"
#~ "@SEEALSO=MAX, ABS"

#~ msgid ""
#~ "@FUNCTION=MAX\n"
#~ "@SYNTAX=MAX(b1, b2, ...)\n"
#~ "@DESCRIPTION=MAX returns the value of the element of the values passed "
#~ "that has the largest value, with negative numbers considered smaller than "
#~ "positive numbers.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "MAX(A1:A5) equals 40.1.\n"
#~ "\n"
#~ "@SEEALSO=MIN,ABS"
#~ msgstr ""
#~ "@FUNCTION=MAX\n"
#~ "@SYNTAX=MAX(b1, b2, ...)\n"
#~ "@DESCRIPTION=MAX liefert den Wert des übergebenen Elements mit dem "
#~ "größten Wert. Hierbei wird angenommen, dass der Wert von negativen "
#~ "kleiner als der von positiven Zahlen ist.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, die Zellen A1, A2, ..., A5 enthalten die Zahlen 11.4, 17.3, "
#~ "21.3, 25.9 und 40.1. Dann liefert\n"
#~ "MAX(A1:A5) 40.1.\n"
#~ "\n"
#~ "@SEEALSO=MIN, ABS"

#~ msgid ""
#~ "@FUNCTION=SKEW\n"
#~ "@SYNTAX=SKEW(n1, n2, ...)\n"
#~ "@DESCRIPTION=SKEW returns an unbiased estimate for skewness of a "
#~ "distribution.\n"
#~ "\n"
#~ "Note, that this is only meaningful if the underlying distribution really "
#~ "has a third moment.  The skewness of a symmetric (e.g., normal) "
#~ "distribution is zero.\n"
#~ "\n"
#~ "* Strings and empty cells are simply ignored.\n"
#~ "* If less than three numbers are given, SKEW returns #DIV/0! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "SKEW(A1:A5) equals 0.976798268.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,VAR,SKEWP,KURT"
#~ msgstr ""
#~ "@FUNCTION=SCHIEFE\n"
#~ "@SYNTAX=SCHIEFE(n1, n2, ...)\n"
#~ "@DESCRIPTION=SCHIEFE liefert einen Schätzwert für die Schiefe einer "
#~ "Verteilung.\n"
#~ "\n"
#~ "Beachten Sie, dass das Ergebnis lediglich aussagekräftig ist, falls die "
#~ "zu Grunde liegende Verteilung ein drittes Moment hat. Die Schiefe einer "
#~ "symmetrischen (also normalen) Verteilung ist null.\n"
#~ "\n"
#~ "* Zeichenketten und leere Zellen werden nicht berücksichtigt.\n"
#~ "* Falls weniger als drei Argumente übergeben werden, liefert SCHIEFE "
#~ "einen #DIV/0!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, die Zellen A1, A2, ..., A5 enthalten die Zahlen 11.4, 17.3, "
#~ "21.3, 25.9 und 40.1. Dann liefert\n"
#~ "SCHIEFE(A1:A5) 0.976798268.\n"
#~ "\n"
#~ "@SEEALSO=MITTELWERT,VARIANZ,SCHIEFEN,KURT"

#~ msgid ""
#~ "@FUNCTION=SKEWP\n"
#~ "@SYNTAX=SKEWP(n1, n2, ...)\n"
#~ "@DESCRIPTION=SKEWP returns the population skewness of a data set.\n"
#~ "\n"
#~ "* Strings and empty cells are simply ignored.\n"
#~ "* If less than two numbers are given, SKEWP returns #DIV/0! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "SKEWP(A1:A5) equals 0.655256198.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,VARP,SKEW,KURTP"
#~ msgstr ""
#~ "@FUNCTION=SCHIEFEN\n"
#~ "@SYNTAX=SCHIEFEN(n1, n2, ...)\n"
#~ "@DESCRIPTION=SCHIEFEN liefert die Schiefe der Grundgesamtheit eines "
#~ "Datensatzes.\n"
#~ "\n"
#~ "* Zeichenketten und leere Zellen werden nicht berücksichtigt.\n"
#~ "* Falls weniger als zwei Argumente übergeben werden, liefert SCHIEFEN "
#~ "einen #DIV/0!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, die Zellen A1, A2, ..., A5 enthalten die Zahlen 11.4, 17.3, "
#~ "21.3, 25.9 und 40.1. Dann liefert\n"
#~ "SCHIEFEN(A1:A5) 0.655256198.\n"
#~ "\n"
#~ "@SEEALSO=MITTELWERT,VARIANZN,SCHIEFE,KURT"

#~ msgid ""
#~ "@FUNCTION=EXPONDIST\n"
#~ "@SYNTAX=EXPONDIST(x,y,cumulative)\n"
#~ "@DESCRIPTION=EXPONDIST function returns the exponential distribution. If "
#~ "the @cumulative boolean is false it will return:\n"
#~ "\n"
#~ "\t@y * exp (-@y*@x),\n"
#~ "\n"
#~ "otherwise it will return\n"
#~ "\n"
#~ "\t1 - exp (-@y*@x).\n"
#~ "\n"
#~ "* If @x < 0 or @y <= 0 this will return an error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "EXPONDIST(2,4,0) equals 0.001341851.\n"
#~ "\n"
#~ "@SEEALSO=POISSON"
#~ msgstr ""
#~ "@FUNCTION=EXPONVERT\n"
#~ "@SYNTAX=EXPONVERT(x,y,kumulativ)\n"
#~ "@DESCRIPTION=EXPONVERT liefert die Exponentialverteilung. Falls das "
#~ "logische Argument @kumulativ falsch ist, liefert sie\n"
#~ "\n"
#~ "\t@y * exp (-@y*@x),\n"
#~ "\n"
#~ "andernfalls\n"
#~ "\n"
#~ "\t1 - exp (-@y*@x).\n"
#~ "\n"
#~ "* Falls @x < 0 oder @y <= 0 ist, liefert EXPONDIST einen Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "EXPONVERT(2,4,0) liefert 0.001341851.\n"
#~ "\n"
#~ "@SEEALSO=POISSON"

#~ msgid ""
#~ "@FUNCTION=BERNOULLI\n"
#~ "@SYNTAX=BERNOULLI(k,p)\n"
#~ "@DESCRIPTION=BERNOULLI returns the probability p(k) of obtaining @k from "
#~ "a Bernoulli distribution with probability parameter @p.\n"
#~ "\n"
#~ "* If @k != 0 and @k != 1 BERNOULLI returns #NUM! error.\n"
#~ "* If @p < 0 or @p > 1 BERNOULLI returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BERNOULLI(0,0.5).\n"
#~ "\n"
#~ "@SEEALSO=RANDBERNOULLI"
#~ msgstr ""
#~ "@FUNCTION=BERNOULLI\n"
#~ "@SYNTAX=BERNOULLI(k,Wahrscheinlichkeit)\n"
#~ "@DESCRIPTION=BERNOULLI liefert die Wahrscheinlichkeit p(k), dass eine "
#~ "Bernoulli-Verteilung mit Wahrscheinlichkeitsparameter @p @k liefert.\n"
#~ "\n"
#~ "* Falls @k != 0 und @k != 1 ist, liefert BERNOULLI einen #ZAHL!-Fehler.\n"
#~ "* Falls @Wahrscheinlichkeit < 0 oder > 1 ist, liefert BERNOULLI einen "
#~ "#ZAHL!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BERNOULLI(0,0.5).\n"
#~ "\n"
#~ "@SEEALSO=ZUFALL.BERNOULLI"

#~ msgid ""
#~ "@FUNCTION=GAMMALN\n"
#~ "@SYNTAX=GAMMALN(x)\n"
#~ "@DESCRIPTION=GAMMALN function returns the natural logarithm of the gamma "
#~ "function.\n"
#~ "\n"
#~ "* If @x is non-number then GAMMALN returns #VALUE! error.\n"
#~ "* If @x <= 0 then GAMMALN returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "GAMMALN(23) equals 48.471181352.\n"
#~ "\n"
#~ "@SEEALSO=POISSON"
#~ msgstr ""
#~ "@FUNCTION=GAMMALN\n"
#~ "@SYNTAX=GAMMALN(x)\n"
#~ "@DESCRIPTION=GAMMALN liefert den natürlichen Logarithmus der Gamma-"
#~ "Funktion.\n"
#~ "\n"
#~ "* Falls @x keine Zahl ist, liefert GAMMALN einen #WERT!-Fehler.\n"
#~ "* Falls @x <= 0 ist, liefert GAMMALN einen #ZAHL!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "GAMMALN(23) liefert 48.471181352.\n"
#~ "\n"
#~ "@SEEALSO=POISSON"

#~ msgid ""
#~ "@FUNCTION=GAMMADIST\n"
#~ "@SYNTAX=GAMMADIST(x,alpha,beta,cum)\n"
#~ "@DESCRIPTION=GAMMADIST function returns the gamma distribution. If @cum "
#~ "is TRUE, GAMMADIST returns the incomplete gamma function, otherwise it "
#~ "returns the probability mass function.\n"
#~ "\n"
#~ "* If @x < 0 GAMMADIST returns #NUM! error.\n"
#~ "* If @alpha <= 0 or @beta <= 0, GAMMADIST returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "GAMMADIST(1,2,3,0) equals 0.07961459.\n"
#~ "\n"
#~ "@SEEALSO=GAMMAINV"
#~ msgstr ""
#~ "@FUNCTION=GAMMAVERT\n"
#~ "@SYNTAX=GAMMAVERT(x,Alpha,Beta,kumulativ)\n"
#~ "@DESCRIPTION=GAMMAVERT liefert die Gammaverteilung. Falls @kumulativ WAHR "
#~ "ist, liefert GAMMAVERT die unvollständige Gammafunktion, andernfalls die "
#~ "Wahrscheinlichkeitsdichte-Funktion.\n"
#~ "\n"
#~ "* Falls @x < 0 ist, liefert GAMMAVERT einen #ZAHL!-Fehler.\n"
#~ "* Falls @Alpha oder @Beta <= 0 ist, liefert GAMMAVERT einen #ZAHL!-"
#~ "Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "GAMMAVERT(1,2,3,0) liefert 0.07961459.\n"
#~ "\n"
#~ "@SEEALSO=GAMMAINV"

#~ msgid ""
#~ "@FUNCTION=GAMMAINV\n"
#~ "@SYNTAX=GAMMAINV(p,alpha,beta)\n"
#~ "@DESCRIPTION=GAMMAINV function returns the inverse of the cumulative "
#~ "gamma distribution.\n"
#~ "\n"
#~ "* If @p < 0 or @p > 1 GAMMAINV returns #NUM! error.\n"
#~ "* If @alpha <= 0 or @beta <= 0 GAMMAINV returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "GAMMAINV(0.34,2,4) equals 4.829093908.\n"
#~ "\n"
#~ "@SEEALSO=GAMMADIST"
#~ msgstr ""
#~ "@FUNCTION=GAMMAINV\n"
#~ "@SYNTAX=GAMMAINV(Wahrscheinlichkeit,Alpha,Beta)\n"
#~ "@DESCRIPTION=GAMMAINV liefert die inverse kumulative Gammaverteilung.\n"
#~ "\n"
#~ "* Falls @Wahrscheinlichkeit < 0 oder > 1 ist, liefert GAMMAINV einen "
#~ "#ZAHL!-Fehler.\n"
#~ "* Falls @Alpha oder @Beta <= 0 ist, liefert GAMMAINV einen #ZAHL!-"
#~ "Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "GAMMAINV(0.34,2,4) liefert 4.829093908.\n"
#~ "\n"
#~ "@SEEALSO=GAMMAVERT"

#~ msgid ""
#~ "@FUNCTION=CHIDIST\n"
#~ "@SYNTAX=CHIDIST(x,dof)\n"
#~ "@DESCRIPTION=CHIDIST function returns the one-tailed probability of the "
#~ "chi-squared distribution. @dof is the number of degrees of freedom.\n"
#~ "\n"
#~ "* If @dof is non-integer it is truncated.\n"
#~ "* If @dof < 1 CHIDIST returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CHIDIST(5.3,2) equals 0.070651213.\n"
#~ "\n"
#~ "@SEEALSO=CHIINV,CHITEST"
#~ msgstr ""
#~ "@FUNCTION=CHIVERT\n"
#~ "@SYNTAX=CHIVERT(x,Freiheitsgrad)\n"
#~ "@DESCRIPTION=CHIVERT liefert die einseitige Wahrscheinlichkeit Chi²-"
#~ "Verteilung. @Freiheitsgrad ist die Zahl der Freiheitsgrade.\n"
#~ "\n"
#~ "* Falls @Freiheitsgrad keine Ganzzahl ist, werden die Nachkommastellen "
#~ "abgeschnitten.\n"
#~ "* Falls @Freiheitsgrad < 1 ist, liefert CHIVERT einen #ZAHL!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CHIVERT(5.3,2) liefert 0.070651213.\n"
#~ "\n"
#~ "@SEEALSO=CHIINV,CHITEST"

#~ msgid ""
#~ "@FUNCTION=CHIINV\n"
#~ "@SYNTAX=CHIINV(p,dof)\n"
#~ "@DESCRIPTION=CHIINV function returns the inverse of the one-tailed "
#~ "probability of the chi-squared distribution.\n"
#~ "\n"
#~ "* If @p < 0 or @p > 1 or @dof < 1 CHIINV returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CHIINV(0.98,7) equals 1.564293004.\n"
#~ "\n"
#~ "@SEEALSO=CHIDIST,CHITEST"
#~ msgstr ""
#~ "@FUNCTION=CHIINV\n"
#~ "@SYNTAX=CHIINV(Wahrscheinlichkeit,Freiheitsgrad)\n"
#~ "@DESCRIPTION=CHIINV liefert die einseitige Wahrscheinlichkeit der "
#~ "inversen Chi²-Verteilung.\n"
#~ "\n"
#~ "* Falls @Wahrscheinlichkeit < 0 oder > 1 oder @Freiheitsgrad < 1 ist, "
#~ "liefert CHIINV einen #ZAHL!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CHIINV(0.98,7) liefert 1.564293004.\n"
#~ "\n"
#~ "@SEEALSO=CHIVERT,CHITEST"

#~ msgid ""
#~ "@FUNCTION=CHITEST\n"
#~ "@SYNTAX=CHITEST(actual_range,theoretical_range)\n"
#~ "@DESCRIPTION=CHITEST function returns the test for independence of chi-"
#~ "squared distribution.\n"
#~ "\n"
#~ "@actual_range is a range that contains the observed data points. "
#~ "@theoretical_range is a range that contains the expected values of the "
#~ "data points.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=CHIDIST,CHIINV"
#~ msgstr ""
#~ "@FUNCTION=CHITEST\n"
#~ "@SYNTAX=CHITEST(Beobachteter_Bereich,Erwarteter_Bereich)\n"
#~ "@DESCRIPTION=CHITEST stellt den Test auf Unabgägigkeit von der Chi²-"
#~ "Verteilung bereit.\n"
#~ "\n"
#~ "@Beobachteter_Bereich ist der Bereich, der die zu beobachtenden "
#~ "Messpunkte enthält. @Erwarteter_Bereich ist der Bereich, der die "
#~ "erwarteten Werte für die Messpunkte enthält.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=CHIVERT,CHIINV"

#~ msgid ""
#~ "@FUNCTION=BETADIST\n"
#~ "@SYNTAX=BETADIST(x,alpha,beta[,a,b])\n"
#~ "@DESCRIPTION=BETADIST function returns the cumulative beta distribution. "
#~ "@a is the optional lower bound of @x and @b is the optional upper bound "
#~ "of @x.\n"
#~ "* If @a is not given, BETADIST uses 0.\n"
#~ "* If @b is not given, BETADIST uses 1.\n"
#~ "* If @x < @a or @x > @b BETADIST returns #NUM! error.\n"
#~ "* If @alpha <= 0 or @beta <= 0, BETADIST returns #NUM! error.\n"
#~ "* If @a >= @b BETADIST returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BETADIST(0.12,2,3) equals 0.07319808.\n"
#~ "\n"
#~ "@SEEALSO=BETAINV"
#~ msgstr ""
#~ "@FUNCTION=BETAVERT\n"
#~ "@SYNTAX=BETAVERT(x,Alpha,Beta[,a,b])\n"
#~ "@DESCRIPTION=BETAVERT liefert die kumulative Beta-Verteilung. @a ist die "
#~ "optionale untere und @b die optionale obere Schranke von @x. \n"
#~ "* Falls @a nicht übergeben wird, wird 0 verwendet.\n"
#~ "* Falls @b nicht übergeben wird, wird 1 verwendet.\n"
#~ "* Falls @x < @a oder > @b ist, liefert BETAVERT einen #ZAHL!-Fehler.\n"
#~ "* Falls @Alpha <= 0 oder @Beta <= 0 ist, liefert BETAVERT einen #ZAHL!-"
#~ "Fehler.\n"
#~ "* Falls @a >= @b ist, liefert BETAVERT einen #ZAHL!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BETAVERT(0.12,2,3) liefert 0.07319808.\n"
#~ "\n"
#~ "@SEEALSO=BETAINV"

#~ msgid ""
#~ "@FUNCTION=BETAINV\n"
#~ "@SYNTAX=BETAINV(p,alpha,beta[,a,b])\n"
#~ "@DESCRIPTION=BETAINV function returns the inverse of cumulative beta "
#~ "distribution.  @a is the optional lower bound of @x and @b is the "
#~ "optional upper bound of @x.\n"
#~ "\n"
#~ "* If @a is not given, BETAINV uses 0.\n"
#~ "* If @b is not given, BETAINV uses 1.\n"
#~ "* If @p < 0 or @p > 1 BETAINV returns #NUM! error.\n"
#~ "* If @alpha <= 0 or @beta <= 0, BETAINV returns #NUM! error.\n"
#~ "* If @a >= @b BETAINV returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BETAINV(0.45,1.6,1) equals 0.607096629.\n"
#~ "\n"
#~ "@SEEALSO=BETADIST"
#~ msgstr ""
#~ "@FUNCTION=BETAINV\n"
#~ "@SYNTAX=BETAINV(Wahrscheinlichkeit,Alpha,Beta[,a,b])\n"
#~ "@DESCRIPTION=BETAINV liefert die inverse kumulative Beta-Verteilung. @a "
#~ "ist die optionale untere und @b die optionale obere Schranke von @x.\n"
#~ "* Falls @a nicht übergeben wird, wird 0 verwendet.\n"
#~ "* Falls @b nicht übergeben wird, wird 1 verwendet.\n"
#~ "* Falls @Wahrscheinlichkeit < 0 oder > 1 ist, liefert BETAINV einen "
#~ "#ZAHL!-Fehler.\n"
#~ "* Falls @Alpha oder @Beta <= 0 ist, liefert BETAINV einen #ZAHL!-Fehler.\n"
#~ "* Falls @a >= @b ist, liefert BETAINV einen #ZAHL!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BETAINV(0.45,1.6,1) liefert 0.607096629.\n"
#~ "\n"
#~ "@SEEALSO=BETAVERT"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=TDIST\n"
#~ "@SYNTAX=TDIST(x,dof,tails)\n"
#~ "@DESCRIPTION=TDIST function returns the Student's t-distribution. @dof is "
#~ "the degree of freedom and @tails is 1 or 2 depending on whether you want "
#~ "one-tailed or two-tailed distribution.\n"
#~ "@tails = 1 returns the size of the right tail.\n"
#~ "\n"
#~ "* If @dof < 1 TDIST returns #NUM! error.\n"
#~ "* If @tails is neither 1 or 2 TDIST returns #NUM! error.\n"
#~ "* This function is Excel compatible for non-negative @x.\n"
#~ "\n"
#~ "Warning: the parameterization of this function is different from what is "
#~ "used for, e.g., NORMSDIST.  This is a common source of mistakes, but "
#~ "necessary for compatibility.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TDIST(2,5,1) equals 0.050969739.\n"
#~ "TDIST(-2,5,1) equals 0.949030261.\n"
#~ "TDIST(0,5,2) equals 1.\n"
#~ "\n"
#~ "@SEEALSO=TINV,TTEST"
#~ msgstr ""
#~ "@FUNCTION=TVERT\n"
#~ "@SYNTAX=TVERT(x,Freiheitsgrad,Seiten)\n"
#~ "@DESCRIPTION=TVERT liefert die Student's-t-Verteilung. @Freiheitsgrad ist "
#~ "der Freiheitsgrad und @Seiten legt fest an, ob die ein- oder zweiseitige "
#~ "Funktion verwendet werden soll (Mögliche Werte sind dementsprechend 1 und "
#~ "2).\n"
#~ "\n"
#~ "* Falls @Freiheitsgrad < 1 ist, liefert TVERT einen #ZAHL!-Fehler.\n"
#~ "* Falls @Seiten weder 1 noch 2 ist, liefert TVERT einen #ZAHL-Fehler.\n"
#~ "* Diese funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TVERT(2,5,1) liefert 0.050969739.\n"
#~ "\n"
#~ "@SEEALSO=TINV,TTEST"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=TINV\n"
#~ "@SYNTAX=TINV(p,dof)\n"
#~ "@DESCRIPTION=TINV function returns the inverse of the two-tailed "
#~ "Student's t-distribution.\n"
#~ "\n"
#~ "* If @p < 0 or @p > 1 or @dof < 1 TINV returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "Warning: the parameterization of this function is different from what is "
#~ "used for, e.g., NORMSINV.  This is a common source of mistakes, but "
#~ "necessary for compatibility.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TINV(0.4,32) equals 0.852998454.\n"
#~ "\n"
#~ "@SEEALSO=TDIST,TTEST"
#~ msgstr ""
#~ "@FUNCTION=TINV\n"
#~ "@SYNTAX=TINV(Wahrscheinlichkeit,Freiheitsgrad)\n"
#~ "@DESCRIPTION=TINV liefert die inverse zweiseitige Student-t-Verteilung.\n"
#~ "\n"
#~ "* Falls @Wahrscheinlichkeit < 0 oder > 1 oder @Freiheitsgrad < 1 ist, "
#~ "liefert TINV einen #ZAHL!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TINV(0.4,32) liefert 0.852998454.\n"
#~ "\n"
#~ "@SEEALSO=TVERT,TTEST"

#~ msgid ""
#~ "@FUNCTION=FDIST\n"
#~ "@SYNTAX=FDIST(x,dof1,dof2)\n"
#~ "@DESCRIPTION=FDIST function returns the F probability distribution. @dof1 "
#~ "is the numerator degrees of freedom and @dof2 is the denominator degrees "
#~ "of freedom.\n"
#~ "\n"
#~ "* If @x < 0 FDIST returns #NUM! error.\n"
#~ "* If @dof1 < 1 or @dof2 < 1, FDIST returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FDIST(2,5,5) equals 0.232511319.\n"
#~ "\n"
#~ "@SEEALSO=FINV"
#~ msgstr ""
#~ "@FUNCTION=FVERT\n"
#~ "@SYNTAX=FVERT(x,Freiheitsgrad1,Freiheitsgrad2)\n"
#~ "@DESCRIPTION=FVERT liefert die F-Wahrscheinlichkeitsverteilung. "
#~ "@Freiheitsgrad1 ist der Freiheitsgrad des Zählers und @Freiheitsgrad2 der "
#~ "des Nenners.\n"
#~ "\n"
#~ "* Falls @x < 0 ist, liefert FVERT einen #ZAHL!-Fehler.\n"
#~ "* Falls @Freiheitsgrad1 < 1 oder @Freiheitsgrad2 < 1 ist, liefert FVERT "
#~ "einen #ZAHL!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FVERT(2,5,5) liefert 0.232511319.\n"
#~ "\n"
#~ "@SEEALSO=FINV"

#~ msgid ""
#~ "@FUNCTION=LANDAU\n"
#~ "@SYNTAX=LANDAU(x)\n"
#~ "@DESCRIPTION=LANDAU returns the probability density p(x) at @x for the "
#~ "Landau distribution using an approximation method. \n"
#~ "@EXAMPLES=\n"
#~ "LANDAU(0.34).\n"
#~ "\n"
#~ "@SEEALSO=RANDLANDAU"
#~ msgstr ""
#~ "@FUNCTION=LANDAU\n"
#~ "@SYNTAX=LANDAU(x)\n"
#~ "@DESCRIPTION=LANDAU liefert unter Anwendung einer Annäherungsmethode die "
#~ "Wahrscheinlichkeitsdichte p(x) bei @x für die Landau-Verteilung\n"
#~ "@EXAMPLES=\n"
#~ "LANDAU(0.34).\n"
#~ "\n"
#~ "@SEEALSO=ZUFALLLANDAU"

#~ msgid ""
#~ "@FUNCTION=FINV\n"
#~ "@SYNTAX=FINV(p,dof1,dof2)\n"
#~ "@DESCRIPTION=FINV function returns the inverse of the F probability "
#~ "distribution.\n"
#~ "\n"
#~ "* If @p < 0 or @p > 1 FINV returns #NUM! error.\n"
#~ "* If @dof1 < 1 or @dof2 < 1 FINV returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FINV(0.2,2,4) equals 2.472135955.\n"
#~ "\n"
#~ "@SEEALSO=FDIST"
#~ msgstr ""
#~ "@FUNCTION=FINV\n"
#~ "@SYNTAX=FINV(Wahrscheinlichkeit,Freiheitsgrad1,Freiheitsgrad2)\n"
#~ "@DESCRIPTION=FINV liefert die inverse F-Wahrscheinlichkeitsverteilung.\n"
#~ "\n"
#~ "* Falls @Wahrscheinlichkeit < 0 oder > 1 ist, liefert FINV einen #ZAHL!-"
#~ "Fehler.\n"
#~ "* Falls @Freiheitsgrad1 oder @Freiheitsgrad2 < 1 ist, liefert FINV einen "
#~ "#ZAHL!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FINV(0.2,2,4) liefert 2.472135955.\n"
#~ "\n"
#~ "@SEEALSO=FVERT"

#~ msgid ""
#~ "@FUNCTION=BINOMDIST\n"
#~ "@SYNTAX=BINOMDIST(n,trials,p,cumulative)\n"
#~ "@DESCRIPTION=BINOMDIST function returns the binomial distribution. @n is "
#~ "the number of successes, @trials is the total number of independent "
#~ "trials, @p is the probability of success in trials, and @cumulative "
#~ "describes whether to return the sum of the binomial function from 0 to "
#~ "@n.\n"
#~ "\n"
#~ "* If @n or @trials are non-integer they are truncated.\n"
#~ "* If @n < 0 or @trials < 0 BINOMDIST returns #NUM! error.\n"
#~ "* If @n > @trials BINOMDIST returns #NUM! error.\n"
#~ "* If @p < 0 or @p > 1 BINOMDIST returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BINOMDIST(3,5,0.8,0) equals 0.2048.\n"
#~ "\n"
#~ "@SEEALSO=POISSON"
#~ msgstr ""
#~ "@FUNCTION=BINOMVERT\n"
#~ "@SYNTAX=BINOMVERT(n,Versuche,Wahrscheinlichkeit,kumulativ)\n"
#~ "@DESCRIPTION=BINOMVERT liefert die Binomialverteilung. @n ist die Anzahl "
#~ "der Treffer, @Versuche die Gesamtanzahl unabhängiger Versuche, "
#~ "@Wahrscheinlichkeit die Wahrscheinlichkeit, dass ein Versuch erfolgreich "
#~ "ist und @kumulativ legt fest, ob BINOMVERT die Summe der "
#~ "Binomialverteilung von 0 bis @n liefert.\n"
#~ "\n"
#~ "* Falls @n oder @Versuche keine Ganzzahl ist, werden die Nachkommastellen "
#~ "abgeschnitten.\n"
#~ "* Falls @n < 0 oder @Versuche < 0 ist, liefert BINOMDIST einen #ZAHL!-"
#~ "Fehler.\n"
#~ "* Falls @n > Versuche ist, liefert BINOMVERT einen #ZAHL!-Fehler.\n"
#~ "* Falls @Wahrscheinlichkeit < 0 oder > 1 ist, liefert BINOMVERT einen "
#~ "#ZAHL!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BINOMVERT(3,5,0.8,0) liefert 0.2048.\n"
#~ "\n"
#~ "@SEEALSO=POISSON"

#~ msgid ""
#~ "@FUNCTION=CAUCHY\n"
#~ "@SYNTAX=CAUCHY(x,a,cum)\n"
#~ "@DESCRIPTION=CAUCHY returns the Cauchy distribution with scale parameter "
#~ "@a. If @cum is TRUE, CAUCHY returns the cumulative distribution.\n"
#~ "\n"
#~ "* If @a < 0 CAUCHY returns #NUM! error.\n"
#~ "* If @cum != TRUE and @cum != FALSE CAUCHY returns #VALUE! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CAUCHY(0.43,1,TRUE) returns 0.370735.\n"
#~ "\n"
#~ "@SEEALSO=RANDCAUCHY"
#~ msgstr ""
#~ "@FUNCTION=CAUCHY\n"
#~ "@SYNTAX=CAUCHY(x,a,Kum)\n"
#~ "@DESCRIPTION=CAUCHY liefert die Cauchy-Verteilung mit "
#~ "Skalierungsparameter @a. Falls @Kum WAHR ist, liefert CAUCHY die "
#~ "kumulative Verteilung.\n"
#~ "\n"
#~ "* Falls @a < 0 ist, liefert CAUCHY einen #ZAHL!-Fehler.\n"
#~ "* Falls @Kum != WAHR und @Kum != FALSCH, liefert einen #WERT!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CAUCHY(0.43,1,WAHR) liefert 0.370735.\n"
#~ "\n"
#~ "@SEEALSO=ZUFALL.CAUCHY"

#~ msgid ""
#~ "@FUNCTION=CRITBINOM\n"
#~ "@SYNTAX=CRITBINOM(trials,p,alpha)\n"
#~ "@DESCRIPTION=CRITBINOM function returns the smallest value for which the "
#~ "cumulative is greater than or equal to a given value. @n is the number of "
#~ "trials, @p is the probability of success in trials, and @alpha is the "
#~ "criterion value.\n"
#~ "\n"
#~ "* If @trials is a non-integer it is truncated.\n"
#~ "* If @trials < 0 CRITBINOM returns #NUM! error.\n"
#~ "* If @p < 0 or @p > 1 CRITBINOM returns #NUM! error.\n"
#~ "* If @alpha < 0 or @alpha > 1 CRITBINOM returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CRITBINOM(10,0.5,0.75) equals 6.\n"
#~ "\n"
#~ "@SEEALSO=BINOMDIST"
#~ msgstr ""
#~ "@FUNCTION=BINOMVERT\n"
#~ "@SYNTAX=BINOMVERT(n,Versuche,Wahrscheinlichkeit,kumulativ)\n"
#~ "@DESCRIPTION=BINOMVERT liefert die Binomialverteilung. @n ist die Anzahl "
#~ "der Treffer, @Versuche die Gesamtanzahl unabhängiger Versuche, "
#~ "@Wahrscheinlichkeit die Wahrscheinlichkeit, dass ein Versuch erfolgreich "
#~ "ist und @kumulativ legt fest, ob BINOMVERT die Summe der "
#~ "Binomialverteilung von 0 bis @n liefert.\n"
#~ "\n"
#~ "* Falls @n oder @Versuche keine Ganzzahl ist, werden die Nachkommastellen "
#~ "abgeschnitten.\n"
#~ "* Falls @n < 0 oder @Versuche < 0 ist, liefert BINOMDIST einen #ZAHL!-"
#~ "Fehler.\n"
#~ "* Falls @n > Versuche ist, liefert BINOMVERT einen #ZAHL!-Fehler.\n"
#~ "* Falls @Wahrscheinlichkeit < 0 oder > 1 ist, liefert BINOMVERT einen "
#~ "#ZAHL!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "BINOMVERT(3,5,0.8,0) liefert 0.2048.\n"
#~ "\n"
#~ "@SEEALSO=POISSON"

#~ msgid ""
#~ "@FUNCTION=PERMUT\n"
#~ "@SYNTAX=PERMUT(n,k)\n"
#~ "@DESCRIPTION=PERMUT function returns the number of permutations. @n is "
#~ "the number of objects, @k is the number of objects in each permutation.\n"
#~ "\n"
#~ "* If @n = 0 PERMUT returns #NUM! error.\n"
#~ "* If @n < @k PERMUT returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "PERMUT(7,3) equals 210.\n"
#~ "\n"
#~ "@SEEALSO=COMBIN"
#~ msgstr ""
#~ "@FUNCTION=VARIATIONEN\n"
#~ "@SYNTAX=VARIATIONEN(n,k)\n"
#~ "@DESCRIPTION=VARIATIONEN liefert die Anzahl der Permutationen. @n ist die "
#~ "Objektanzahl, @k die Objektanzahl in jeder Permutation.\n"
#~ "\n"
#~ "* Falls @n = 0 ist, liefert VARIATIONEN einen #ZAHL!-Fehler.\n"
#~ "* Falls @n < @k, liefert VARIATIONEN einen #ZAHL!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@BEISPIELE=\n"
#~ "VARIATIONEN(7,3) liefert 210.\n"
#~ "\n"
#~ "@SEEALSO=KOMBINATIONEN"

#~ msgid ""
#~ "@FUNCTION=HYPGEOMDIST\n"
#~ "@SYNTAX=HYPGEOMDIST(x,n,M,N[,cumulative])\n"
#~ "@DESCRIPTION=HYPGEOMDIST function returns the hypergeometric "
#~ "distribution. @x is the number of successes in the sample, @n is the "
#~ "number of trials, @M is the number of successes overall, and @N is the "
#~ "population size.\n"
#~ "\n"
#~ "If the optional argument @cumulative is TRUE, the cumulative left tail "
#~ "will be returned.\n"
#~ "\n"
#~ "* If @x,@n,@M or @N is a non-integer it is truncated.\n"
#~ "* If @x,@n,@M or @N < 0 HYPGEOMDIST returns #NUM! error.\n"
#~ "* If @x > @M or @n > @N HYPGEOMDIST returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "HYPGEOMDIST(1,2,3,10) equals 0.4666667.\n"
#~ "\n"
#~ "@SEEALSO=BINOMDIST,POISSON"
#~ msgstr ""
#~ "@FUNCTION=HYPGEOMVERT\n"
#~ "@SYNTAX=HYPGEOMVERT(x,n,M,N)\n"
#~ "@DESCRIPTION=HYPGEOMVERT liefert die hypergeometrische Verteilung. @x ist "
#~ "die Anzahl der Treffer in der Stichprobe, @n die Anzahl der Versuche, @M "
#~ "die Gesamtanzahl der Treffer und @N die Größe der Grundgesamtheit.\n"
#~ "\n"
#~ "* Falls @x, @n, @M oder @N keine Ganzzahl ist, werden die "
#~ "Nachkommastellen abgeschnitten.\n"
#~ "* Falls @x, @n, @M oder @N < 0 ist, liefert HYPERGEOMVERT einen #ZAHL!-"
#~ "Fehler.\n"
#~ "* Falls @x > @M oder @n > @N, liefert HYPERGEOMVERT einen #ZAHL!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "HYPERGEOMVERT(1,2,3,10) liefert 0.4666667.\n"
#~ "\n"
#~ "@SEEALSO=BINOMVERT,POISSON"

#~ msgid ""
#~ "@FUNCTION=CONFIDENCE\n"
#~ "@SYNTAX=CONFIDENCE(x,stddev,size)\n"
#~ "@DESCRIPTION=CONFIDENCE function returns the confidence interval for a "
#~ "mean. @x is the significance level, @stddev is the population standard "
#~ "deviation, and @size is the size of the sample.\n"
#~ "\n"
#~ "* If @size is non-integer it is truncated.\n"
#~ "* If @size < 0 CONFIDENCE returns #NUM! error.\n"
#~ "* If @size is 0 CONFIDENCE returns #DIV/0! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CONFIDENCE(0.05,1,33) equals 0.341185936.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE"
#~ msgstr ""
#~ "@FUNCTION=KONFIDENZ\n"
#~ "@SYNTAX=KONFIDENZ(x,Stdabw,Größe)\n"
#~ "@DESCRIPTION=KONFIDENZ liefert das Konfidenzintervall für einen "
#~ "Mittelwert. @x ist das Signifikanzniveau, @Stdabw die Standardabweichung "
#~ "der Grundgesamtheit und @Größe die Größe der Stichprobe.\n"
#~ "\n"
#~ "* Falls @Größe keine Ganzzahl ist, werden die Nachkommastellen "
#~ "abgeschnitten.\n"
#~ "* Falls @Größe < 0 ist, liefert KONFIDENZ einen #ZAHL!-Fehler.\n"
#~ "* Falls @Größe 0 ist, liefert KONFIDENZ einen #DIV/0!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CONFIDENCE(0.05,1,33) liefert 0.341185936.\n"
#~ "\n"
#~ "@SEEALSO=MITTELWERT"

#~ msgid ""
#~ "@FUNCTION=STANDARDIZE\n"
#~ "@SYNTAX=STANDARDIZE(x,mean,stddev)\n"
#~ "@DESCRIPTION=STANDARDIZE function returns a normalized value. @x is the "
#~ "number to be normalized, @mean is the mean of the distribution, @stddev "
#~ "is the standard deviation of the distribution.\n"
#~ "\n"
#~ "* If @stddev is 0 STANDARDIZE returns #DIV/0! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "STANDARDIZE(3,2,4) equals 0.25.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE"
#~ msgstr ""
#~ "@FUNCTION=NORMIEREN\n"
#~ "@SYNTAX=NORMIEREN(x,Mittelwert,Stdabw)\n"
#~ "@DESCRIPTION=NORMIEREN liefert einen normierten Wert. @x ist die zu "
#~ "normierende Zahl, @Mittelwert der Mittelwert der Verteilung und @Stdabw "
#~ "die Standardabweichung der Verteilung.\n"
#~ "\n"
#~ "* Falls @Stdabw 0 ist, liefert NORMIEREN einen #DIV/0!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "NORMIEREN(3,2,4) liefert 0.25.\n"
#~ "\n"
#~ "@SEEALSO=MITTELWERT"

#~ msgid ""
#~ "@FUNCTION=WEIBULL\n"
#~ "@SYNTAX=WEIBULL(x,alpha,beta,cumulative)\n"
#~ "@DESCRIPTION=WEIBULL function returns the Weibull distribution. If the "
#~ "@cumulative boolean is true it will return:\n"
#~ "\n"
#~ "\t1 - exp (-(@x/@beta)^@alpha),\n"
#~ "\n"
#~ "otherwise it will return\n"
#~ "\n"
#~ "\t(@alpha/@beta^@alpha) * @x^(@alpha-1) * exp(-(@x/@beta^@alpha)).\n"
#~ "\n"
#~ "* If @x < 0 WEIBULL returns #NUM! error.\n"
#~ "* If @alpha <= 0 or @beta <= 0 WEIBULL returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "WEIBULL(3,2,4,0) equals 0.213668559.\n"
#~ "\n"
#~ "@SEEALSO=POISSON"
#~ msgstr ""
#~ "@FUNCTION=WEIBULL\n"
#~ "@SYNTAX=WEIBULL(x,Alpha,Beta,kumulativ)\n"
#~ "@DESCRIPTION=WEIBULL liefert die Weibull-Verteilung. Falls der Boolsche "
#~ "Wert @kumulativ WAHR ist, lautet die Funktion:\n"
#~ "\n"
#~ "\t1 - exp (-(@x/@beta)^@alpha),\n"
#~ "\n"
#~ "andernfalls liefert sie:\n"
#~ "\n"
#~ "\t(@alpha/@beta^@alpha) * @x^(@alpha-1) * exp(-(@x/@beta^@alpha)).\n"
#~ "\n"
#~ "* Falls @x < 0 ist, liefert WEIBULL einen #ZAHL!-Fehler.\n"
#~ "* Falls @Alpha <= 0 oder @Beta <= 0 ist, liefert WEIBULL einen #ZAHL!-"
#~ "Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "WEIBULL(3,2,4,0) liefert 0.213668559.\n"
#~ "\n"
#~ "@SEEALSO=POISSON"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=NORMDIST\n"
#~ "@SYNTAX=NORMDIST(x,mean,stddev,cumulative)\n"
#~ "@DESCRIPTION=The NORMDIST function returns the value of the probability "
#~ "density function or the cumulative distribution function for the normal "
#~ "distribution with the mean given by @mean, and the standard deviation "
#~ "given by @stddev. If @cumulative is FALSE, NORMDIST returns the value of "
#~ "the probability density function at the value @x. If @cumulative is TRUE, "
#~ "NORMDIST returns the value of the cumulative distribution function at "
#~ "@x.\n"
#~ "\n"
#~ "* If @stddev is 0 NORMDIST returns #DIV/0! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "NORMDIST(2,1,2,0) equals 0.176032663.\n"
#~ "\n"
#~ "@SEEALSO=POISSON"
#~ msgstr ""
#~ "@FUNCTION=NORMVERT\n"
#~ "@SYNTAX=NORMVERT(x,Mittelwert,Stdabw,kumulativ)\n"
#~ "@DESCRIPTION=NORMVERT liefert die kumulative Normalverteilung. @x ist der "
#~ "Wert, für den die Verteilung erzeugt werden soll, @Mittelwert der "
#~ "Mittelwert der Verteilung und @Stdabw die Standardabweichung.\n"
#~ "\n"
#~ "* Falls @Stdabw 0 ist, liefert NORMVERT einen #DIV/0!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "NORMDIST(2,1,2,0) liefert 0.176032663.\n"
#~ "\n"
#~ "@SEEALSO=POISSON"

#~ msgid ""
#~ "@FUNCTION=NORMINV\n"
#~ "@SYNTAX=NORMINV(p,mean,stddev)\n"
#~ "@DESCRIPTION=NORMINV function returns the inverse of the normal "
#~ "cumulative distribution. @p is the given probability corresponding to the "
#~ "normal distribution, @mean is the arithmetic mean of the distribution, "
#~ "and @stddev is the standard deviation of the distribution.\n"
#~ "\n"
#~ "* If @p < 0 or @p > 1 or @stddev <= 0 NORMINV returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "NORMINV(0.76,2,3) equals 4.118907689.\n"
#~ "\n"
#~ "@SEEALSO=NORMDIST,NORMSDIST,NORMSINV,STANDARDIZE,ZTEST"
#~ msgstr ""
#~ "@FUNCTION=NORMINV\n"
#~ "@SYNTAX=NORMINV(Wahrscheinlichkeit,Mittelwert,Stdabw)\n"
#~ "@DESCRIPTION=NORMINV liefert die inverse Normalverteilung. "
#~ "@Wahrscheinlichkeit ist die der Normalverteilung entsprechende "
#~ "Wahrscheinlichkeit, @Mittelwert der arithmetische Mittelwert der "
#~ "Verteilung und @Stdabw die Standardabweichung der Verteilung.\n"
#~ "\n"
#~ "* Falls @Wahrscheinlichkeit < 0 oder > 1 oder @Stdabw <= 0 ist, liefert "
#~ "NORMINV einen #ZAHL!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "NORMINV(0.76,2,3) liefert 4.118907689.\n"
#~ "\n"
#~ "@SEEALSO=NORMVERT,STANDNORMVERT,STANDNORMINV,NORMIEREN,ZTEST"

#~ msgid ""
#~ "@FUNCTION=KURT\n"
#~ "@SYNTAX=KURT(n1, n2, ...)\n"
#~ "@DESCRIPTION=KURT returns an unbiased estimate of the kurtosis of a data "
#~ "set.\n"
#~ "Note, that this is only meaningful if the underlying distribution really "
#~ "has a fourth moment.  The kurtosis is offset by three such that a normal "
#~ "distribution will have zero kurtosis.\n"
#~ "\n"
#~ "* Strings and empty cells are simply ignored.\n"
#~ "* If fewer than four numbers are given or all of them are equal KURT "
#~ "returns #DIV/0! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "KURT(A1:A5) equals 1.234546305.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,VAR,SKEW,KURTP"
#~ msgstr ""
#~ "@FUNCTION=KURT\n"
#~ "@SYNTAX=KURT(n1, n2, ...)\n"
#~ "@DESCRIPTION=KURT liefert einen Schätzwert für die Kurtosis eines "
#~ "Datensatzes.\n"
#~ "\n"
#~ "Beachten Sie, dass das Ergebnis lediglich aussagekräftig ist, falls die "
#~ "zu Grunde liegende Verteilung ein viertes Moment hat. Die Kurtosis einer "
#~ "symmetrischen (also normalen) Verteilung ist null.\n"
#~ "\n"
#~ "* Zeichenketten und leere Zellen werden nicht berücksichtigt.\n"
#~ "* Falls weniger als vier Argumente übergeben werden oder sie alle gleich "
#~ "sind, liefert KURT einen #DIV/0!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, die Zellen A1, A2, ..., A5 enthalten die Zahlen 11.4, 17.3, "
#~ "21.3, 25.9 und 40.1. Dann liefert\n"
#~ "KURT(A1:A5) 1.234546305.\n"
#~ "\n"
#~ "@SEEALSO=MITTELWERT,VARIANZ,SCHIEFE,KURTN"

#~ msgid ""
#~ "@FUNCTION=KURTP\n"
#~ "@SYNTAX=KURTP(n1, n2, ...)\n"
#~ "@DESCRIPTION=KURTP returns the population kurtosis of a data set.\n"
#~ "\n"
#~ "* Strings and empty cells are simply ignored.\n"
#~ "* If fewer than two numbers are given or all of them are equal KURTP "
#~ "returns #DIV/0! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "KURTP(A1:A5) equals -0.691363424.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,VARP,SKEWP,KURT"
#~ msgstr ""
#~ "@FUNCTION=SCHIEFEN\n"
#~ "@SYNTAX=SCHIEFEN(n1, n2, ...)\n"
#~ "@DESCRIPTION=SCHIEFEN liefert die Schiefe der Grundgesamtheit eines "
#~ "Datensatzes.\n"
#~ "\n"
#~ "* Zeichenketten und leere Zellen werden nicht berücksichtigt.\n"
#~ "* Falls weniger als zwei Argumente übergeben werden, liefert SCHIEFEN "
#~ "einen #DIV/0!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, die Zellen A1, A2, ..., A5 enthalten die Zahlen 11.4, 17.3, "
#~ "21.3, 25.9 und 40.1. Dann liefert\n"
#~ "SCHIEFEN(A1:A5) 0.655256198.\n"
#~ "\n"
#~ "@SEEALSO=MITTELWERT,VARIANZN,SCHIEFE,KURT"

#~ msgid ""
#~ "@FUNCTION=AVEDEV\n"
#~ "@SYNTAX=AVEDEV(n1, n2, ...)\n"
#~ "@DESCRIPTION=AVEDEV returns the average of the absolute deviations of a "
#~ "data set from their mean.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "AVEDEV(A1:A5) equals 7.84.\n"
#~ "\n"
#~ "@SEEALSO=STDEV"
#~ msgstr ""
#~ "@FUNCTION=MITTELABW\n"
#~ "@SYNTAX=MITTELABW(n1, n2, ...)\n"
#~ "@DESCRIPTION=MITTELABW liefert den Mittelwert der absoluten Abweichungen "
#~ "eines Datensatzes vom Mittelwert.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, die Zellen A1, A2, ..., A5 enthalten die Zahlen 11.4, 17.3, "
#~ "21.3, 25.9 und 40.1. Dann liefert\n"
#~ "AVEDEV(A1:A5) 7.84.\n"
#~ "\n"
#~ "@SEEALSO=STABW"

#~ msgid ""
#~ "@FUNCTION=DEVSQ\n"
#~ "@SYNTAX=DEVSQ(n1, n2, ...)\n"
#~ "@DESCRIPTION=DEVSQ returns the sum of squares of deviations of a data set "
#~ "from the sample mean.\n"
#~ "\n"
#~ "* Strings and empty cells are simply ignored.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "DEVSQ(A1:A5) equals 470.56.\n"
#~ "\n"
#~ "@SEEALSO=STDEV"
#~ msgstr ""
#~ "@FUNCTION=SUMQUADABW\n"
#~ "@SYNTAX=SUMQUADABW(n1, n2, ...)\n"
#~ "@DESCRIPTION=SUMQUADABW liefert die Quadratsumme der Abweichungen eines "
#~ "Datensatzes vom ermittelten Mittelwert.\n"
#~ "\n"
#~ "* Zeichenketten und leere Zellen werden ignoriert.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, die Zellen A1, A2, ..., A5 enthalten die Zahlen 11.4, 17.3, "
#~ "21.3, 25.9 und 40.1. Dann liefert\n"
#~ "SUMQUADABW(A1:A5) 470.56.\n"
#~ "\n"
#~ "@SEEALSO=STDABW"

#~ msgid ""
#~ "@FUNCTION=FISHER\n"
#~ "@SYNTAX=FISHER(x)\n"
#~ "@DESCRIPTION=FISHER function returns the Fisher transformation at @x.\n"
#~ "\n"
#~ "* If @x is not a number, FISHER returns #VALUE! error.\n"
#~ "* If @x <= -1 or @x >= 1, FISHER returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FISHER(0.332) equals 0.345074339.\n"
#~ "\n"
#~ "@SEEALSO=SKEW"
#~ msgstr ""
#~ "@FUNCTION=FISHER\n"
#~ "@SYNTAX=FISHER(x)\n"
#~ "@DESCRIPTION=FISHER liefert die Fisher-Transformation bei @x.\n"
#~ "\n"
#~ "* Falls @x keine Zahl ist, liefert FISHER einen #WERT!-Fehler.\n"
#~ "* Falls @x <= -1 oder >= 1 ist, liefert FISHER einen #ZAHL!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FISHER(0.332) liefert 0.345074339.\n"
#~ "\n"
#~ "@SEEALSO=SCHIEFE"

#~ msgid ""
#~ "@FUNCTION=POISSON\n"
#~ "@SYNTAX=POISSON(x,mean,cumulative)\n"
#~ "@DESCRIPTION=POISSON function returns the Poisson distribution. @x is the "
#~ "number of events, @mean is the expected numeric value @cumulative "
#~ "describes whether to return the sum of the Poisson function from 0 to "
#~ "@x.\n"
#~ "\n"
#~ "* If @x is a non-integer it is truncated.\n"
#~ "* If @x < 0 POISSON returns #NUM! error.\n"
#~ "* If @mean <= 0 POISSON returns the #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "POISSON(3,6,0) equals 0.089235078.\n"
#~ "\n"
#~ "@SEEALSO=NORMDIST, WEIBULL"
#~ msgstr ""
#~ "@FUNCTION=POISSON\n"
#~ "@SYNTAX=POISSON(x,Mittelwert,kumulativ)\n"
#~ "@DESCRIPTION=POISSON liefert die Poisson-Verteilung. @x ist die "
#~ "Ereignisanzahl, @Mittelwert der erwartete numerische Wert und @kumulativ "
#~ "gibt an, ob die Summe der Poisson-Funktion von 0 bis @x geliefert werden "
#~ "soll.\n"
#~ "\n"
#~ "* Falls @x keine Ganzzahl ist, werden die Nachkommastellen "
#~ "abgeschnitten.\n"
#~ "* Falls @x < 0 ist, liefert POISSON einen #ZAHL!-Fehler.\n"
#~ "* Falls @Mittelwert <= 0 ist, liefert POISSON einen #ZAHL!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "POISSON(3,6,0) liefert 0.089235078.\n"
#~ "\n"
#~ "@SEEALSO=NORMVERT, WEIBULL"

#~ msgid ""
#~ "@FUNCTION=PEARSON\n"
#~ "@SYNTAX=PEARSON(array1,array2)\n"
#~ "@DESCRIPTION=PEARSON returns the Pearson correlation coefficient of two "
#~ "data sets.\n"
#~ "\n"
#~ "* Strings and empty cells are simply ignored.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=INTERCEPT,LINEST,RSQ,SLOPE,STEYX"
#~ msgstr ""
#~ "@FUNCTION=PEARSON\n"
#~ "@SYNTAX=PEARSON(Datenfeld1,Datenfeld2)\n"
#~ "@DESCRIPTION=PEARSON liefert die Pearsonschen Korrelationskoeffizienten "
#~ "zweier Datensätze.\n"
#~ "\n"
#~ "* Zeichenketten und leere Zellen werden ignoriert.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=RSQ\n"
#~ "@SYNTAX=RSQ(array1,array2)\n"
#~ "@DESCRIPTION=RSQ returns the square of the Pearson correlation "
#~ "coefficient of two data sets.\n"
#~ "\n"
#~ "* Strings and empty cells are simply ignored.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=CORREL,COVAR,INTERCEPT,LINEST,LOGEST,PEARSON,SLOPE,STEYX,TREND"
#~ msgstr ""
#~ "@FUNCTION=BESTIMMTHEITSMASS\n"
#~ "@SYNTAX=BESTIMMTHEITSMASS(Datenfeld1,Datenfeld2)\n"
#~ "@DESCRIPTION=BESTIMMTHEITSMASS liefert das Quadrat zweier Pearsonscher "
#~ "Korrelationskoeffizienten zweier Datensätze.\n"
#~ "\n"
#~ "* Zeichenketten und leere Zellen werden ignoriert.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=MEDIAN\n"
#~ "@SYNTAX=MEDIAN(n1, n2, ...)\n"
#~ "@DESCRIPTION=MEDIAN returns the median of the given data set.\n"
#~ "\n"
#~ "* Strings and empty cells are simply ignored.\n"
#~ "* If even numbers are given MEDIAN returns the average of the two numbers "
#~ "in the middle.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "MEDIAN(A1:A5) equals 21.3.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE,COUNT,COUNTA,DAVERAGE,MODE,SSMEDIAN,SUM"
#~ msgstr ""
#~ "@FUNCTION=MEDIAN\n"
#~ "@SYNTAX=MEDIAN(n1, n2, ...)\n"
#~ "@DESCRIPTION=MEDIAN liefert den Median des übergebenen Datensatzes.\n"
#~ "\n"
#~ "* Zeichenketten und leere Zellen werden ignoriert.\n"
#~ "* Falls gerade Zahlen übergeben werden, liefert MEDIAN den Mittelwert der "
#~ "beiden mittleren Zahlen.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, die Zellen A1, A2, ..., A5 enthalten die Zahlen 11.4, 17.3, "
#~ "21.3, 25.9 und 40.1. Dann liefert\n"
#~ "MEDIAN(A1:A5) 21.3.\n"
#~ "\n"
#~ "@SEEALSO= LATER"

#~ msgid ""
#~ "@FUNCTION=SSMEDIAN\n"
#~ "@SYNTAX=SSMEDIAN(array[,interval)]\n"
#~ "@DESCRIPTION=The SSMEDIAN function returns the median for grouped data as "
#~ "commonly determined in the social sciences. The data points given in "
#~ "@array are assumed to be the result of grouping data into intervals of "
#~ "length @interval\n"
#~ "\n"
#~ "* If @interval is not given, SSMEDIAN uses 1.\n"
#~ "* If @array is empty, SSMEDIAN returns #NUM! error.\n"
#~ "* If @interval <= 0, SSMEDIAN returns #NUM! error.\n"
#~ "* SSMEDIAN does not check whether the data points are at least @interval "
#~ "apart.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, A3 contain numbers 7, 8, 8.  Then\n"
#~ "SSMEDIAN(A1:A3, 1) equals 7.75.\n"
#~ "\n"
#~ "@SEEALSO=MEDIAN"
#~ msgstr ""
#~ "@FUNCTION=PERZENTILE\n"
#~ "@SYNTAX=PERZENTILE(Datenfeld,k)\n"
#~ "@DESCRIPTION=PERZENTILE liefert die 100*@kte Perzentile der übergebenen "
#~ "Datenpunkte (also eine Zahl x, bei der der @k-te Teil der Datenpunkte "
#~ "kleiner als x ist).\n"
#~ "\n"
#~ "* Falls @Datenfeld leer ist, liefert PERZENTILE einen #ZAHL!-Fehler.\n"
#~ "* Falls @k < 0 oder > 1 ist, liefert PERZENTILE einen #ZAHL!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, die Zellen A1, A2, ..., A5 enthalten die Zahlen 11.4, 17.3, "
#~ "21.3, 25.9 und 40.1. Dann liefert\n"
#~ "PERZENTILE(A1:A5,0.42) 20.02.\n"
#~ "\n"
#~ "@SEEALSO=QUARTILE"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=LARGE\n"
#~ "@SYNTAX=LARGE(n, k)\n"
#~ "@DESCRIPTION=LARGE returns the k-th largest value in a data set.\n"
#~ "\n"
#~ "* If data set is empty LARGE returns #NUM! error.\n"
#~ "* If @k <= 0 or @k is greater than the number of data items given LARGE "
#~ "returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "LARGE(A1:A5,2) equals 25.9.\n"
#~ "LARGE(A1:A5,4) equals 17.3.\n"
#~ "\n"
#~ "@SEEALSO=PERCENTILE,PERCENTRANK,QUARTILE,SMALL"
#~ msgstr ""
#~ "@FUNCTION=KGRÖSSTE\n"
#~ "@SYNTAX=KGRÖSSTE(n1, n2, ..., k)\n"
#~ "@DESCRIPTION=KGRÖSSTE liefert den @k-t größten Wert in einem Datensatz.\n"
#~ "\n"
#~ "* Falls kein Datensatz übergeben wird, liefert KGRÖSSTE einen #ZAHL!-"
#~ "Fehler.\n"
#~ "* Falls @k <= 0 oder @k größer ist als die Anzahl der übergebenen "
#~ "Datenobjekte, liefert KGRÖSSTE einen #ZAHL!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, die Zellen A1, A2, ..., A5 enthalten die Zahlen 11.4, 17.3, "
#~ "21.3, 25.9 und 40.1. Dann liefert \n"
#~ "KGRÖSSTE(A1:A5,2) 25.9 und\n"
#~ "KGRÖSSTE(A1:A5,4) 17.3.\n"
#~ "\n"
#~ "@SEEALSO=PERZENTILE,QUANTILSRANG,QUARTILE,KKLEINSTE"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=SMALL\n"
#~ "@SYNTAX=SMALL(n, k)\n"
#~ "@DESCRIPTION=SMALL returns the k-th smallest value in a data set.\n"
#~ "\n"
#~ "* If data set is empty SMALL returns #NUM! error.\n"
#~ "* If @k <= 0 or @k is greater than the number of data items given SMALL "
#~ "returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "SMALL(A1:A5,2) equals 17.3.\n"
#~ "SMALL(A1:A5,4) equals 25.9.\n"
#~ "\n"
#~ "@SEEALSO=PERCENTILE,PERCENTRANK,QUARTILE,LARGE"
#~ msgstr ""
#~ "@FUNCTION=KKLEINSTE\n"
#~ "@SYNTAX=KKLEINSTE(n1, n2, ..., k)\n"
#~ "@DESCRIPTION=KKLEINSTE liefert den @k-t kleinsten Wert in einem "
#~ "Datensatz.\n"
#~ "\n"
#~ "* Falls kein Datensatz übergeben wird, liefert KKLEINSTE einen #ZAHL!-"
#~ "Fehler.\n"
#~ "* Falls @k <= 0 oder @k größer ist als die Anzahl der übergebenen "
#~ "Datenobjekte, liefert KKLEINSTE einen #ZAHL!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, die Zellen A1, A2, ..., A5 enthalten die Zahlen 11.4, 17.3, "
#~ "21.3, 25.9 und 40.1. Dann liefert \n"
#~ "KKLEINSTE(A1:A5,2) 17.3 und\n"
#~ "KKLEINSTE(A1:A5,4) 25.9.\n"
#~ "\n"
#~ "@SEEALSO=PERZENTILE,QUANTILSRANG,QUARTILE,KKGRÖSSTE"

#~ msgid ""
#~ "@FUNCTION=PROB\n"
#~ "@SYNTAX=PROB(x_range,prob_range,lower_limit[,upper_limit])\n"
#~ "@DESCRIPTION=PROB function returns the probability that values in a range "
#~ "or an array are between two limits. If @upper_limit is not given, PROB "
#~ "returns the probability that values in @x_range are equal to "
#~ "@lower_limit.\n"
#~ "\n"
#~ "* If the sum of the probabilities in @prob_range is not equal to 1 PROB "
#~ "returns #NUM! error.\n"
#~ "* If any value in @prob_range is <=0 or > 1, PROB returns #NUM! error.\n"
#~ "* If @x_range and @prob_range contain a different number of data entries, "
#~ "PROB returns #N/A error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=BINOMDIST,CRITBINOM"
#~ msgstr ""
#~ "@FUNCTION=WAHRSCHBEREICH\n"
#~ "@SYNTAX=WAHRSCHBEREICH(X_Bereich,Wahrscheinlichkeitsbereich,limes_inferior"
#~ "[,limes_superior])\n"
#~ "@DESCRIPTION=WAHRSCHBEREICH liefert die Wahrscheinlichkeit, dass Werte in "
#~ "einem Bereich oder einer Zeichenkette innerhalb zweier Grenzwerte "
#~ "liegen.\n"
#~ "\n"
#~ "* Falls @limes_superior nicht übergeben wird, liefert WAHRSCHBEREICH die "
#~ "Wahrscheinlichkeit, dass Werte in @X_Bereich gleich @limes_inferior "
#~ "sind.\n"
#~ "* Falls die Summe der Wahrscheinlichkeiten in @Wahrscheinlichkeitsbereich "
#~ "ungleich 1 ist, liefert WAHRSCHBEREICH einen #ZAHL!-Fehler.\n"
#~ "* Falls ein Wert in @Wahrscheinlichkeitsbereich <=0 oder > 1 ist, liefert "
#~ "WAHRSCHBEREICH einen #ZAHL!-Fehler.\n"
#~ "* Falls @X_Bereich und @Wahrscheinlichkeitsbereich eine unterschiedliche "
#~ "Anzahl an Dateneinträgen haben, liefert WAHRSCHBEREICH einen #NV!-"
#~ "Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO=BINOMVERT,KRITBINOM"

#~ msgid ""
#~ "@FUNCTION=STEYX\n"
#~ "@SYNTAX=STEYX(known_y's,known_x's)\n"
#~ "@DESCRIPTION=STEYX function returns the standard error of the predicted y-"
#~ "value for each x in the regression.\n"
#~ "\n"
#~ "* If @known_y's and @known_x's are empty or have a different number of "
#~ "arguments then STEYX returns #N/A error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1, and the cells B1, B2, ... B5 23.2, 25.8, 29.9, "
#~ "33.5, and 42.7.  Then\n"
#~ "STEYX(A1:A5,B1:B5) equals 1.101509979.\n"
#~ "\n"
#~ "@SEEALSO=PEARSON,RSQ,SLOPE"
#~ msgstr ""
#~ "@FUNCTION=STFEHLERYX\n"
#~ "@SYNTAX=STFEHLERYX(Y_Werte,X_Werte)\n"
#~ "@DESCRIPTION=STFEHLERYX liefert den Standardfehler des vorhergesagten y-"
#~ "Wertes zu jedem x in der Regression.\n"
#~ "\n"
#~ "* Falls @X_Werte und @X_Werte leer sind oder eine unterschiedliche "
#~ "Argumentanzahl haben, liefert STFEHLERYX einen #NV-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, die Zellen A1, A2, ..., A5 enthalten die Zahlen 11.4, 17.3, "
#~ "21.3, 25.9 und 40.1 und die Zellen B1, B2, ... B5 23.2, 25.8, 29.9, 33.5 "
#~ "und 42.7. Dann liefert\n"
#~ "STFEHLERYX(A1:A5,B1:B5) 1.101509979.\n"
#~ "\n"
#~ "@SEEALSO= LATER"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=ZTEST\n"
#~ "@SYNTAX=ZTEST(ref,x[,stddev])\n"
#~ "@DESCRIPTION=ZTEST returns the two-tailed probability of a z-test.\n"
#~ "\n"
#~ "@ref is the data set and @x is the value to be tested.\n"
#~ "@stddev is optionally an assumed standard deviation.\n"
#~ "\n"
#~ "* If @ref contains less than two data items ZTEST returns #DIV/0! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "ZTEST(A1:A5,20) equals 0.254717826.\n"
#~ "\n"
#~ "@SEEALSO=CONFIDENCE,NORMDIST,NORMINV,NORMSDIST,NORMSINV,STANDARDIZE"
#~ msgstr ""
#~ "@FUNCTION=ZTEST\n"
#~ "@SYNTAX=ZTEST(Bezug,x)\n"
#~ "@DESCRIPTION=ZTEST liefert die zweiseitige Wahrscheinlichkeit eines Z-"
#~ "Tests.\n"
#~ "\n"
#~ "@Bezug ist der Datensatz und @x der zu prüfende Wert.\n"
#~ "\n"
#~ "* Falls @Bezug weniger als zwei Datenobjekte enthält, liefert ZTEST einen "
#~ "#DIV/0!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, die Zellen A1, A2, ..., A5 enthalten die Zahlen 11.4, 17.3, "
#~ "21.3, 25.9 und 40.1. Dann liefert\n"
#~ "ZTEST(A1:A5,20) 0.254717826.\n"
#~ "\n"
#~ "@SEEALSO=LATER"

#~ msgid ""
#~ "@FUNCTION=AVERAGEA\n"
#~ "@SYNTAX=AVERAGEA(number1,number2,...)\n"
#~ "@DESCRIPTION=AVERAGEA returns the average of the given arguments.  "
#~ "Numbers, text and logical values are included in the calculation too. If "
#~ "the cell contains text or the argument evaluates to FALSE, it is counted "
#~ "as value zero (0).  If the argument evaluates to TRUE, it is counted as "
#~ "one (1).  Note that empty cells are not counted.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers and strings "
#~ "11.4, 17.3, \"missing\", 25.9, and 40.1.  Then\n"
#~ "AVERAGEA(A1:A5) equals 18.94.\n"
#~ "\n"
#~ "@SEEALSO=AVERAGE"
#~ msgstr ""
#~ "@FUNCTION=MITTELWERT2\n"
#~ "@SYNTAX=MITTELWERT2(Argument1,Argument2[,...])\n"
#~ "@DESCRIPTION=MITTELWERT2 berechnet den Mittelwert der übergebenen "
#~ "Argumente. Zahlen, Text und logische Werte werden ebenfalls in die "
#~ "Berechnung einbezogen. Falls die Zelle Text enthält oder das Argument "
#~ "FALSCH ist, wird sie bzw. es als Wert null (0) gewertet, falls es WAHR "
#~ "ist als eins (1). Beachten Sie, dass leere Zellen bei der Berechnung "
#~ "nicht berücksichtigt werden.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, die Zellen A1, A2, ..., A5 enthalten die Zahlen 11.4, 17.3, "
#~ "\"fehlt\", 25.9 und 40.1. Dann liefert\n"
#~ "MITTELWERT2(A1:A5) 18.94.\n"
#~ "\n"
#~ "@SEEALSO=MITTELWERT"

#~ msgid ""
#~ "@FUNCTION=MAXA\n"
#~ "@SYNTAX=MAXA(number1,number2,...)\n"
#~ "@DESCRIPTION=MAXA returns the largest value of the given arguments.  "
#~ "Numbers, text and logical values are included in the calculation too. If "
#~ "the cell contains text or the argument evaluates to FALSE, it is counted "
#~ "as value zero (0).  If the argument evaluates to TRUE, it is counted as "
#~ "one (1).  Note that empty cells are not counted.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers and strings "
#~ "11.4, 17.3, \"missing\", 25.9, and 40.1.  Then\n"
#~ "MAXA(A1:A5) equals 40.1.\n"
#~ "\n"
#~ "@SEEALSO=MAX,MINA"
#~ msgstr ""
#~ "@FUNCTION=MAX2\n"
#~ "@SYNTAX=MAX2(Argument1,Argument2[,...])\n"
#~ "@DESCRIPTION=MAX2 liefert den Wert des größten übergeben Arguments. "
#~ "Zahlen, Text und logische Werte werden ebenfalls in die Berechnung "
#~ "einbezogen. Falls die Zelle Text enthält oder das Argument FALSCH ist, "
#~ "wird sie bzw. es als Wert null (0) gewertet, falls es WAHR ist als eins "
#~ "(1). Beachten Sie, dass leere Zellen bei der Berechnung nicht "
#~ "berücksichtigt werden.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, die Zellen A1, A2, ..., A5 enthalten die Zahlen 11.4, 17.3, "
#~ "\"fehlt\", 25.9 und 40.1. Dann liefert\n"
#~ "MAX2(A1:A5) 40.1.\n"
#~ "\n"
#~ "@SEEALSO=MAX,MIN2"

#~ msgid ""
#~ "@FUNCTION=MINA\n"
#~ "@SYNTAX=MINA(number1,number2,...)\n"
#~ "@DESCRIPTION=MINA returns the smallest value of the given arguments.  "
#~ "Numbers, text and logical values are included in the calculation too. If "
#~ "the cell contains text or the argument evaluates to FALSE, it is counted "
#~ "as value zero (0).  If the argument evaluates to TRUE, it is counted as "
#~ "one (1).  Note that empty cells are not counted.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers and strings "
#~ "11.4, 17.3, \"missing\", 25.9, and 40.1.  Then\n"
#~ "MINA(A1:A5) equals 0.\n"
#~ "\n"
#~ "@SEEALSO=MIN,MAXA"
#~ msgstr ""
#~ "@FUNCTION=MIN2\n"
#~ "@SYNTAX=MIN2(Argument1,Argument2[,...])\n"
#~ "@DESCRIPTION=MIN2 liefert den Wert des kleinsten übergeben Arguments. "
#~ "Zahlen, Text und logische Werte werden ebenfalls in die Berechnung "
#~ "einbezogen. Falls die Zelle Text enthält oder das Argument FALSCH ist, "
#~ "wird sie bzw. es als Wert null (0) gewertet, falls es WAHR ist als eins "
#~ "(1). Beachten Sie, dass leere Zellen bei der Berechnung nicht "
#~ "berücksichtigt werden.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, die Zellen A1, A2, ..., A5 enthalten die Zahlen 11.4, 17.3, "
#~ "\"fehlt\", 25.9 und 40.1. Dann liefert\n"
#~ "MAX2(A1:A5) 11.4.\n"
#~ "\n"
#~ "@SEEALSO=MIN,MAX2"

#~ msgid ""
#~ "@FUNCTION=VARA\n"
#~ "@SYNTAX=VARA(number1,number2,...)\n"
#~ "@DESCRIPTION=VARA calculates sample variance of the given sample.\n"
#~ "To get the true variance of a complete population use VARPA.\n"
#~ "VARA is also known as the N-1-variance.\n"
#~ "Under reasonable conditions, it is the maximum-likelihood estimator for "
#~ "the true variance.\n"
#~ "Numbers, text and logical values are included in the calculation too. If "
#~ "the cell contains text or the argument evaluates to FALSE, it is counted "
#~ "as value zero (0).  If the argument evaluates to TRUE, it is counted as "
#~ "one (1).  Note that empty cells are not counted.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers and strings "
#~ "11.4, 17.3, \"missing\", 25.9, and 40.1.  Then\n"
#~ "VARA(A1:A5) equals 228.613.\n"
#~ "\n"
#~ "@SEEALSO=VAR,VARPA"
#~ msgstr ""
#~ "@FUNCTION=VARIANZ2\n"
#~ "@SYNTAX=VARIANZ2(Zahl1,Zahl2,...)\n"
#~ "@DESCRIPTION=VARIANZ2 liefert die Varianz auf Basis einer Stichprobe. In "
#~ "die Berechnung werden Zahlen, Text und logische Werte einbezogen. Falls "
#~ "die Zelle Text enthält oder das Argument FALSCH ist, wird es als Wert "
#~ "null (0) angesehen. Falls das Argument WAHR ist, als eins (1). Beachten "
#~ "Sie, dass leere Zellen ignoriert werden.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, die Zellen A1, A2, ..., A5 enthalten die Zahlen bzw. "
#~ "Zeichenketten 11.4, 17.3, \"fehlt\", 25.9 und 40.1. Dann liefert\n"
#~ "VARIANZ2(A1:A5) 228.613.\n"
#~ "\n"
#~ "@SEEALSO=VARIANZ,VARIANZN2"

#~ msgid ""
#~ "@FUNCTION=VARPA\n"
#~ "@SYNTAX=VARPA(number1,number2,...)\n"
#~ "@DESCRIPTION=VARPA calculates the variance of an entire population.\n"
#~ "VARPA is also known as the N-variance.\n"
#~ "Numbers, text and logical values are included in the calculation too.  If "
#~ "the cell contains text or the argument evaluates to FALSE, it is counted "
#~ "as value zero (0).  If the argument evaluates to TRUE, it is counted as "
#~ "one (1).  Note that empty cells are not counted.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers and strings "
#~ "11.4, 17.3, \"missing\", 25.9, and 40.1.  Then\n"
#~ "VARPA(A1:A5) equals 182.8904.\n"
#~ "\n"
#~ "@SEEALSO=VARA,VARP"
#~ msgstr ""
#~ "@FUNCTION=VARIANZN2\n"
#~ "@SYNTAX=VARIANZN2(Zahl1,Zahl2,...)\n"
#~ "@DESCRIPTION=VARIANZN2 liefert die Varianz auf Basis einer Stichprobe. In "
#~ "die Berechnung werden Zahlen, Text und logische Werte einbezogen. Falls "
#~ "die Zelle Text enthält oder das Argument FALSCH ist, wird es als Wert "
#~ "null (0) angesehen. Falls das Argument WAHR ist, als eins (1). Beachten "
#~ "Sie, dass leere Zellen ignoriert werden.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, die Zellen A1, A2, ..., A5 enthalten die Zahlen bzw. "
#~ "Zeichenketten 11.4, 17.3, \"fehlt\", 25.9 und 40.1. Dann liefert\n"
#~ "VARIANZ2(A1:A5) 228.613.\n"
#~ "\n"
#~ "@SEEALSO=VARIANZ,VARIANZN2"

#~ msgid ""
#~ "@FUNCTION=STDEVA\n"
#~ "@SYNTAX=STDEVA(number1,number2,...)\n"
#~ "@DESCRIPTION=STDEVA returns the sample standard deviation of the given "
#~ "sample.\n"
#~ "To obtain the population standard deviation of a whole population use "
#~ "STDEVPA.\n"
#~ "STDEVA is also known as the N-1-standard deviation.\n"
#~ "Under reasonable conditions, it is the maximum-likelihood estimator for "
#~ "the true population standard deviation.\n"
#~ "Numbers, text and logical values are included in the calculation too.  If "
#~ "the cell contains text or the argument evaluates to FALSE, it is counted "
#~ "as value zero (0).  If the argument evaluates to TRUE, it is counted as "
#~ "one (1).  Note that empty cells are not counted.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers and strings "
#~ "11.4, 17.3, \"missing\", 25.9, and 40.1.  Then\n"
#~ "STDEVA(A1:A5) equals 15.119953704.\n"
#~ "\n"
#~ "@SEEALSO=STDEV,STDEVPA"
#~ msgstr ""
#~ "@FUNCTION=VARIANZN2\n"
#~ "@SYNTAX=VARIANZN2(Zahl1,Zahl2,...)\n"
#~ "@DESCRIPTION=VARIANZN2 liefert die Varianz auf Basis einer Stichprobe. In "
#~ "die Berechnung werden Zahlen, Text und logische Werte einbezogen. Falls "
#~ "die Zelle Text enthält oder das Argument FALSCH ist, wird es als Wert "
#~ "null (0) angesehen. Falls das Argument WAHR ist, als eins (1). Beachten "
#~ "Sie, dass leere Zellen ignoriert werden.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, die Zellen A1, A2, ..., A5 enthalten die Zahlen bzw. "
#~ "Zeichenketten 11.4, 17.3, \"fehlt\", 25.9 und 40.1. Dann liefert\n"
#~ "VARIANZ2(A1:A5) 228.613.\n"
#~ "\n"
#~ "@SEEALSO=VARIANZ,VARIANZN2"

#~ msgid ""
#~ "@FUNCTION=STDEVPA\n"
#~ "@SYNTAX=STDEVPA(number1,number2,...)\n"
#~ "@DESCRIPTION=STDEVPA returns the population standard deviation of an "
#~ "entire population.\n"
#~ "This is also known as the N-standard deviation\n"
#~ "Numbers, text and logical values are included in the calculation too.  If "
#~ "the cell contains text or the argument evaluates to FALSE, it is counted "
#~ "as value zero (0).  If the argument evaluates to TRUE, it is counted as "
#~ "one (1).  Note that empty cells are not counted.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers and strings "
#~ "11.4, 17.3, \"missing\", 25.9, and 40.1.  Then\n"
#~ "STDEVPA(A1:A5) equals 13.523697719.\n"
#~ "\n"
#~ "@SEEALSO=STDEVA,STDEVP"
#~ msgstr ""
#~ "@FUNCTION=VARIANZN2\n"
#~ "@SYNTAX=VARIANZN2(Zahl1,Zahl2,...)\n"
#~ "@DESCRIPTION=VARIANZN2 liefert die Varianz auf Basis einer Stichprobe. In "
#~ "die Berechnung werden Zahlen, Text und logische Werte einbezogen. Falls "
#~ "die Zelle Text enthält oder das Argument FALSCH ist, wird es als Wert "
#~ "null (0) angesehen. Falls das Argument WAHR ist, als eins (1). Beachten "
#~ "Sie, dass leere Zellen ignoriert werden.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, die Zellen A1, A2, ..., A5 enthalten die Zahlen bzw. "
#~ "Zeichenketten 11.4, 17.3, \"fehlt\", 25.9 und 40.1. Dann liefert\n"
#~ "VARIANZ2(A1:A5) 228.613.\n"
#~ "\n"
#~ "@SEEALSO=VARIANZ,VARIANZN2"

#~ msgid ""
#~ "@FUNCTION=PERCENTILE\n"
#~ "@SYNTAX=PERCENTILE(array,k)\n"
#~ "@DESCRIPTION=PERCENTILE function returns the 100*@k-th percentile of the "
#~ "given data points (that is, a number x such that a fraction @k of the "
#~ "data points are less than x).\n"
#~ "\n"
#~ "* If @array is empty, PERCENTILE returns #NUM! error.\n"
#~ "* If @k < 0 or @k > 1, PERCENTILE returns #NUM! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "PERCENTILE(A1:A5,0.42) equals 20.02.\n"
#~ "\n"
#~ "@SEEALSO=QUARTILE"
#~ msgstr ""
#~ "@FUNCTION=PERZENTILE\n"
#~ "@SYNTAX=PERZENTILE(Datenfeld,k)\n"
#~ "@DESCRIPTION=PERZENTILE liefert die 100*@kte Perzentile der übergebenen "
#~ "Datenpunkte (also eine Zahl x, bei der der @k-te Teil der Datenpunkte "
#~ "kleiner als x ist).\n"
#~ "\n"
#~ "* Falls @Datenfeld leer ist, liefert PERZENTILE einen #ZAHL!-Fehler.\n"
#~ "* Falls @k < 0 oder > 1 ist, liefert PERZENTILE einen #ZAHL!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, die Zellen A1, A2, ..., A5 enthalten die Zahlen 11.4, 17.3, "
#~ "21.3, 25.9 und 40.1. Dann liefert\n"
#~ "PERZENTILE(A1:A5,0.42) 20.02.\n"
#~ "\n"
#~ "@SEEALSO=QUARTILE"

#~ msgid ""
#~ "@FUNCTION=QUARTILE\n"
#~ "@SYNTAX=QUARTILE(array,quart)\n"
#~ "@DESCRIPTION=QUARTILE function returns the quartile of the given data "
#~ "points.\n"
#~ "\n"
#~ "If @quart is equal to: QUARTILE returns:\n"
#~ "0                      the smallest value of @array.\n"
#~ "1                      the first quartile\n"
#~ "2                      the second quartile\n"
#~ "3                      the third quartile\n"
#~ "4                      the largest value of @array.\n"
#~ "\n"
#~ "* If @array is empty, QUARTILE returns #NUM! error.\n"
#~ "* If @quart < 0 or @quart > 4, QUARTILE returns #NUM! error.\n"
#~ "* If @quart is not an integer, it is truncated.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1.  Then\n"
#~ "QUARTILE(A1:A5,1) equals 17.3.\n"
#~ "\n"
#~ "@SEEALSO=LARGE,MAX,MEDIAN,MIN,PERCENTILE,SMALL"
#~ msgstr ""
#~ "@FUNCTION=QUARTILE\n"
#~ "@SYNTAX=QUARTILE(Feld,Quart)\n"
#~ "@DESCRIPTION=QUARTILE liefert die Quartile der angegebenen Datenpunkte.\n"
#~ "\n"
#~ "Falls @Quart gleich: liefert QUARTILE:\n"
#~ "0                      den kleinsten Wert von @Feld.\n"
#~ "1                      die erste Quartile\n"
#~ "2                      die zweite Quartile\n"
#~ "3                      die dritte Quartile\n"
#~ "4                      den größten Wert von @Feld.\n"
#~ "\n"
#~ "* Falls @Feld leer ist, liefert QUARTILE einen #ZAHL!-Fehler.\n"
#~ "* Falls @Quart < 1 oder > 4 ist, liefert QUARTILE einen #ZAHL!-Fehler.\n"
#~ "* Falls @Quart keine Ganzzahl ist, werden die Nachkommastellen "
#~ "abgeschnitten.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, die Zellen A1, A2, ..., A5 enthalten die Zahlen 11.4, 17.3, "
#~ "21.3, 25.9 und 40.1. Dann liefert\n"
#~ "QUARTILE(A1:A5,1) 17.3.\n"
#~ "\n"
#~ "@SEEALSO= :: LATER"

#~ msgid ""
#~ "@FUNCTION=FTEST\n"
#~ "@SYNTAX=FTEST(array1,array2)\n"
#~ "@DESCRIPTION=FTEST function returns the two-tailed probability that the "
#~ "variances in the given two data sets are not significantly different.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1, and the cells B1, B2, ... B5 23.2, 25.8, 29.9, "
#~ "33.5, and 42.7.  Then\n"
#~ "FTEST(A1:A5,B1:B5) equals 0.510815017.\n"
#~ "\n"
#~ "@SEEALSO=FDIST,FINV"
#~ msgstr ""
#~ "@FUNCTION=FTEST\n"
#~ "@SYNTAX=FTEST(Datenfeld1,Datenfeld2)\n"
#~ "@DESCRIPTION=FTEST liefert die zweiseitige Wahrscheinlichkeit, dass die "
#~ "Varianzen in den zwei übergebenen Datensätzen nicht signifikant "
#~ "verschieden sind.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, die Zellen A1, A2, ..., A5 enthalten die Zahlen 11.4, 17.3, "
#~ "21.3, 25.9 und 40.1, und die Zellen B1, B2, ... B5 23.2, 25.8, 29.9, 33.5 "
#~ "und 42.7. Dann liefert\n"
#~ "FTEST(A1:A5,B1:B5) 0.510815017.\n"
#~ "\n"
#~ "@SEEALSO=FVERT,FINV"

#~ msgid ""
#~ "@FUNCTION=TTEST\n"
#~ "@SYNTAX=TTEST(array1,array2,tails,type)\n"
#~ "@DESCRIPTION=TTEST function returns the probability of a Student's t-"
#~ "Test. \n"
#~ "@array1 is the first data set and @array2 is the second data set.  If "
#~ "@tails is one, TTEST uses the one-tailed distribution and if @tails is "
#~ "two, TTEST uses the two-tailed distribution.  @type determines the kind "
#~ "of the test:\n"
#~ "\n"
#~ "\t1  Paired test\n"
#~ "\t2  Two-sample equal variance\n"
#~ "\t3  Two-sample unequal variance\n"
#~ "\n"
#~ "* If the data sets contain a different number of data points and the test "
#~ "is paired (@type one), TTEST returns the #N/A error.\n"
#~ "* @tails and @type are truncated to integers.\n"
#~ "* If @tails is not one or two, TTEST returns #NUM! error.\n"
#~ "* If @type is any other than one, two, or three, TTEST returns #NUM! "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1, and the cells B1, B2, ... B5 23.2, 25.8, 29.9, "
#~ "33.5, and 42.7.  Then\n"
#~ "TTEST(A1:A5,B1:B5,1,1) equals 0.003127619.\n"
#~ "TTEST(A1:A5,B1:B5,2,1) equals 0.006255239.\n"
#~ "TTEST(A1:A5,B1:B5,1,2) equals 0.111804322.\n"
#~ "TTEST(A1:A5,B1:B5,1,3) equals 0.113821797.\n"
#~ "\n"
#~ "@SEEALSO=FDIST,FINV"
#~ msgstr ""
#~ "@FUNCTION=TTEST\n"
#~ "@SYNTAX=TTEST(Datenfeld1,Datenfeld2,Tails,Typ)\n"
#~ "@DESCRIPTION=TTEST liefert die Wahrscheinlichkeit eines Student's-T-"
#~ "Tests. \n"
#~ "@Datenfeld1 ist der erste und @Datenfeld2 der zweite Datensatz. Falls "
#~ "@Tails 1 ist, verwendet TTEST die one-tailed und falls @Tails 2 ist, die "
#~ "two-tailed Verteilung. @Typ legt den Typ des Tests fest:\n"
#~ "\n"
#~ "\t1 Gepaarter Test\n"
#~ "\t2 Zwei Stichproben, gleiche Varianz\n"
#~ "\t3  Zwei Stichproben, unterschiedliche Varianz\n"
#~ "\n"
#~ "* Falls die Datensätze eine unterschiedliche Anzahl an Datenpunkten "
#~ "enthalten und der Test gepaart ist (@Typ 1), liefert TTEST einen #NV!-"
#~ "Fehler.\n"
#~ "* @tails and @type are truncated to integers.\n"
#~ "* Falls @Tails weder 1 noch 2 ist, liefert TTEST einen #ZAHL!-Fehler.\n"
#~ "* Falls @Typ weder 1, noch 2 oder 3 ist, liefert TTEST einen #ZAHL!-"
#~ "Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, die Zellen A1, A2, ..., A5 enthalten die Zahlen 11.4, 17.3, "
#~ "21.3, 25.9 und 40.1 und die Zellen B1, B2, ... B5 23.2, 25.8, 29.9, 33.5 "
#~ "sowie 42.7. Dann liefert\n"
#~ "TTEST(A1:A5,B1:B5,1,1) 0.003127619,\n"
#~ "TTEST(A1:A5,B1:B5,2,1) 0.006255239,\n"
#~ "TTEST(A1:A5,B1:B5,1,2) 0.111804322 und\n"
#~ "TTEST(A1:A5,B1:B5,1,3) 0.113821797.\n"
#~ "\n"
#~ "@SEEALSO=FVERT,FINV"

#~ msgid ""
#~ "@FUNCTION=FREQUENCY\n"
#~ "@SYNTAX=FREQUENCY(data_array,bins_array)\n"
#~ "@DESCRIPTION=FREQUENCY function counts how often given values occur "
#~ "within a range of values.  The results are given as an array.\n"
#~ "\n"
#~ "@data_array is a data array for which you want to count the frequencies.  "
#~ "@bin_array is an array containing the intervals into which you want to "
#~ "group the values in data_array.  If the @bin_array is empty, FREQUENCY "
#~ "returns the number of data points in @data_array.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=HÄUFIGKEIT\n"
#~ "@SYNTAX=HÄUFIGKEIT(Datenfeld,Klassenfeld)\n"
#~ "@DESCRIPTION=HÄUFIGKEIT zählt, wie oft die übergebenen Werte innerhalb "
#~ "eines Wertebereichs. Das Ergebnis wird als Datenfeld übergeben.\n"
#~ "\n"
#~ "@Datenfeld ist das Datenfeld, in dem die Häufigkeit berechnet werden "
#~ "soll. @Klassen_Datenfeld ist das Datenfeld, das die Intervalle enthält, "
#~ "in denen die Werte in @Datenfeld gruppiert werden sollen. Falls "
#~ "@Klassen_Datenfeld leer ist, liefert HÄUFIGKEIT die Anzahl der "
#~ "Datenpunkte in @Datenfeld.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=TREND\n"
#~ "@SYNTAX=TREND(known_y's[,known_x's[,new_x's[,const]]])\n"
#~ "@DESCRIPTION=TREND function estimates future values of a given data set "
#~ "using the ``least squares'' line that best fit to your data. @known_y's "
#~ "is the y-values where y=mx+b and @known_x's contains the corresponding x-"
#~ "values.  @new_x's contains the x-values for which you want to estimate "
#~ "the y-values. If @const is FALSE, the line will be forced to go through "
#~ "the origin, i.e., b will be zero.\n"
#~ "\n"
#~ "* If @known_x's is omitted, an array {1, 2, 3, ...} is used.\n"
#~ "* If @new_x's is omitted, it is assumed to be the same as @known_x's.\n"
#~ "* If @const is omitted, it is assumed to be TRUE.\n"
#~ "* If @known_y's and @known_x's have unequal number of data points, TREND "
#~ "returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1, and the cells B1, B2, ... B5 23.2, 25.8, 29.9, "
#~ "33.5, and 42.7.  Then\n"
#~ "TREND(A1:A5,B1:B5) equals {12.1, 15.7, 21.6, 26.7, 39.7}.\n"
#~ "\n"
#~ "@SEEALSO=LINEST"
#~ msgstr ""
#~ "@FUNCTION=TREND\n"
#~ "@SYNTAX=TREND(Y_Werte[,X_Werte],Neue_X_Werte[,konstant]])\n"
#~ "@DESCRIPTION=TREND schätzt die zukünftigen Werte des übergebenen "
#~ "Datensatzes ab, wobei die Näherungsgerade verwendet wird, die am besten "
#~ "zu den Daten passt. @Y_Werte sind die Y-Werte, wobei y=mx+b gilt und "
#~ "@X_Werte enthält die entsprechenden X-Werte. @Neue_X_Werte enthält die X-"
#~ "Werte, für die Sie die Y-Werte abschätzen lassen wollen.\n"
#~ "\n"
#~ "* Falls @X_Werte nicht übergeben wird, wird ein Datenfeld der Form {1, 2, "
#~ "3, ...} verwendet.\n"
#~ "* Falls @Neue_X_Werte nicht übergeben wird, wird dieses gleich @X_Werte "
#~ "angenommen.\n"
#~ "* Falls @Y_Werte und X_Werte nicht die gleiche Anzahl an Datenpunkten "
#~ "enthalten, liefert TREND einen #ZAHL!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, die Zellen A1, A2, ..., A5 enthalten die Zahlen 11.4, 17.3, "
#~ "21.3, 25.9 und 40.1 und die Zellen B1, B2, ... B5 23.2, 25.8, 29.9, 33.5 "
#~ "und 42.7. Dann liefert\n"
#~ "TREND(A1:A5,B1:B5) = {12.1, 15.7, 21.6, 26.7, 39.7}.\n"
#~ "\n"
#~ "@SEEALSO=RGP"

#~ msgid ""
#~ "@FUNCTION=FORECAST\n"
#~ "@SYNTAX=FORECAST(x,known_y's,known_x's)\n"
#~ "@DESCRIPTION=FORECAST function estimates a future value according to "
#~ "existing values using simple linear regression.  The estimated future "
#~ "value is a y-value for a given x-value (@x).\n"
#~ "\n"
#~ "* If @known_x or @known_y contains no data entries or different number of "
#~ "data entries, FORECAST returns #N/A error.\n"
#~ "* If the variance of the @known_x is zero, FORECAST returns #DIV/0 "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1, and the cells B1, B2, ... B5 23.2, 25.8, 29.9, "
#~ "33.5, and 42.7.  Then\n"
#~ "FORECAST(7,A1:A5,B1:B5) equals -10.859397661.\n"
#~ "\n"
#~ "@SEEALSO=INTERCEPT,TREND"
#~ msgstr ""
#~ "@FUNCTION=SCHÄTZER\n"
#~ "@SYNTAX=SCHÄTZER(x,Y_Werte,X_Werte)\n"
#~ "@DESCRIPTION=SCHÄTZER schätzt einen zukünftigen Wert anhand der bekannten "
#~ "Werte unter Verwendung der einfachen linearen Regression ab. Der "
#~ "Schätzwert ist der zum übergebenen X-Wert @x gehörige Y-Wert.\n"
#~ "\n"
#~ "* Falls @Y_Werte oder @X_Werte null ist, keinen Dateneintrag LATER, "
#~ "liefert SCHÄTZER einen #NV-Fehler.\n"
#~ "* Falls die Varianz oder @X_Werte null ist, liefert SCHÄTZER einen #DIV/0-"
#~ "Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, die Zellen A1, A2, ..., A5 enthalten die Zahlen 11.4, 17.3, "
#~ "21.3, 25.9 und 40.1 und die Zellen B1, B2, ... B5 23.2, 25.8, 29.9, 33.5 "
#~ "sowie 42.7. Dann liefert\n"
#~ "SCHÄTZER(7,A1:A5,B1:B5) -10.859397661.\n"
#~ "\n"
#~ "@SEEALSO=ACHSENABSCHNITT,TREND"

#~ msgid ""
#~ "@FUNCTION=INTERCEPT\n"
#~ "@SYNTAX=INTERCEPT(known_y's,known_x's)\n"
#~ "@DESCRIPTION=INTERCEPT function calculates the point where the linear "
#~ "regression line intersects the y-axis.\n"
#~ "\n"
#~ "* If @known_x or @known_y contains no data entries or different number of "
#~ "data entries, INTERCEPT returns #N/A error.\n"
#~ "* If the variance of the @known_x is zero, INTERCEPT returns #DIV/0 "
#~ "error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1, and the cells B1, B2, ... B5 23.2, 25.8, 29.9, "
#~ "33.5, and 42.7.  Then\n"
#~ "INTERCEPT(A1:A5,B1:B5) equals -20.785117212.\n"
#~ "\n"
#~ "@SEEALSO=FORECAST,TREND"
#~ msgstr ""
#~ "@FUNCTION=ACHSENABSCHNITT\n"
#~ "@SYNTAX=ACHSENABSCHNITT(Y_Werte,X_Werte)\n"
#~ "@DESCRIPTION=ACHSENABSCHNITT berechnet den Punkt, an dem die lineare "
#~ "Regressionsgerade die Y-Achse schneidet.\n"
#~ "\n"
#~ "* Falls @X_Werte oder @Y_Werte keine Dateneinträge oder eine "
#~ "unterschiedliche Anzahl selbiger enthält, liefert ACHSENABSCHNITT einen "
#~ "#NV-Fehler.\n"
#~ "* Falls die Varianz der @X_Werte null ist, liefert ACHSENABSCHNITT EINEN "
#~ "#DIV/0-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, die Zellen A1, A2, ..., A5 enthalten die Zahlen 11.4, 17.3, "
#~ "21.3, 25.9 und 40.1 und die Zellen B1, B2, ... B5 23.2, 25.8, 29.9, 33.5 "
#~ "und 42.7. Dann liefert\n"
#~ "ACHSENABSCHNITT(A1:A5,B1:B5) -20.785117212.\n"
#~ "\n"
#~ "@SEEALSO=SCHÄTZER,TREND"

#~ msgid ""
#~ "@FUNCTION=SLOPE\n"
#~ "@SYNTAX=SLOPE(known_y's,known_x's)\n"
#~ "@DESCRIPTION=SLOPE returns the slope of the linear regression line.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
#~ "21.3, 25.9, and 40.1, and the cells B1, B2, ... B5 23.2, 25.8, 29.9, "
#~ "33.5, and 42.7.  Then\n"
#~ "SLOPE(A1:A5,B1:B5) equals 1.417959936.\n"
#~ "\n"
#~ "@SEEALSO=STDEV,STDEVPA"
#~ msgstr ""
#~ "@FUNCTION=STEIGUNG\n"
#~ "@SYNTAX=STEIGUNG(Y_Werte,X_Werte)\n"
#~ "@DESCRIPTION=STEIGUNG liefert die Steigung der Regressionsgeraden.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, die Zellen A1, A2, ..., A5 enthalten die Zahlen 11.4, 17.3, "
#~ "21.3, 25.9 und 40.1 und die Zellen B1, B2, ... B5 23.2, 25.8, 29.9, 33.5 "
#~ "und 42.7. Dann liefert\n"
#~ "STEIGUNG(A1:A5,B1:B5) 1.417959936.\n"
#~ "\n"
#~ "@SEEALSO=STDABW, LATER"

#~ msgid ""
#~ "@FUNCTION=SUBTOTAL\n"
#~ "@SYNTAX=SUBTOTAL(function_nbr,ref1,ref2,...)\n"
#~ "@DESCRIPTION=SUBTOTAL function returns a subtotal of given list of "
#~ "arguments. @function_nbr is the number that specifies which function to "
#~ "use in calculating the subtotal.\n"
#~ "\n"
#~ "The following functions are available:\n"
#~ "\n"
#~ "\t1   AVERAGE\n"
#~ "\t2   COUNT\n"
#~ "\t3   COUNTA\n"
#~ "\t4   MAX\n"
#~ "\t5   MIN\n"
#~ "\t6   PRODUCT\n"
#~ "\t7   STDEV\n"
#~ "\t8   STDEVP\n"
#~ "\t9   SUM\n"
#~ "\t10   VAR\n"
#~ "\t11   VARP\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 23, 27, 28, "
#~ "33, and 39.  Then\n"
#~ "SUBTOTAL(1,A1:A5) equals 30.\n"
#~ "SUBTOTAL(6,A1:A5) equals 22378356.\n"
#~ "SUBTOTAL(7,A1:A5) equals 6.164414003.\n"
#~ "SUBTOTAL(9,A1:A5) equals 150.\n"
#~ "SUBTOTAL(11,A1:A5) equals 30.4.\n"
#~ "\n"
#~ "@SEEALSO=COUNT,SUM"
#~ msgstr ""
#~ "@FUNCTION=TEILERGEBNIS\n"
#~ "@SYNTAX=TEILERGEBNIS(Funktionsnummer,Bezug1,Bezug2,...)\n"
#~ "@DESCRIPTION=TEILERGEBNIS liefert ein Teilergebnis der übergebenen "
#~ "Argumentliste. @Funktionsnummer ist die Zahl, die festlegt, welche "
#~ "Funktion zur Berechnung des Teilergebnisses verwendet werden soll.\n"
#~ "\n"
#~ "Folgende Funktionen sind verfügbar:\n"
#~ "\n"
#~ "\t1   MITTELWERT\n"
#~ "\t2   ANZAHL\n"
#~ "\t3   ANZAHL2\n"
#~ "\t4   MAX\n"
#~ "\t5   MIN\n"
#~ "\t6   PRODUKT\n"
#~ "\t7   STDABW\n"
#~ "\t8   STDABWN\n"
#~ "\t9   SUMME\n"
#~ "\t10   VAR\n"
#~ "\t11   VAR2\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, die Zellen A1, A2, ..., A5 enthalten die Zahlen 23, 27, 28, "
#~ "33 und 39. Dann liefert\n"
#~ "TEILERGEBNIS(1,A1:A5) 30.\n"
#~ "TEILERGEBNIS(6,A1:A5) 22378356.\n"
#~ "TEILERGEBNIS(7,A1:A5) 6.164414003.\n"
#~ "TEILERGEBNIS(9,A1:A5) 150.\n"
#~ "TEILERGEBNIS(11,A1:A5) 30.4.\n"
#~ "\n"
#~ "@SEEALSO=ANZAHL, SUMME"

#~ msgid ""
#~ "@FUNCTION=CRONBACH\n"
#~ "@SYNTAX=CRONBACH(ref1,ref2,...)\n"
#~ "@DESCRIPTION=CRONBACH returns Cronbach's alpha for the given cases.\n"
#~ "@ref1 is a data set, @ref2 the second data set, etc..\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=CRONBACH\n"
#~ "@SYNTAX=CRONBACH(Bezug1,Bezug2,...)\n"
#~ "@DESCRIPTION=CRONBACH liefert das Cronbach'sche Alpha für die angegebenen "
#~ "Fälle.\n"
#~ "@Bezug1 ist der erste, @Bezug2 der zweite Datensatz u.s.w..\n"
#~ "@EXAMPLES=\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=GEOMDIST\n"
#~ "@SYNTAX=GEOMDIST(k,p,cum)\n"
#~ "@DESCRIPTION=GEOMDIST returns the probability p(k) of obtaining @k from a "
#~ "geometric distribution with probability parameter @p.\n"
#~ "\n"
#~ "* If @k < 0 GEOMDIST returns #NUM! error.\n"
#~ "* If @p < 0 or @p > 1 GEOMDIST returns #NUM! error.\n"
#~ "* If @cum != TRUE and @cum != FALSE GEOMDIST returns #NUM! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "GEOMDIST(2,10.4,TRUE).\n"
#~ "\n"
#~ "@SEEALSO=RANDGEOM"
#~ msgstr ""
#~ "@FUNCTION=GEOMVERT\n"
#~ "@SYNTAX=GEOMVERT(k,Wahrscheinlichkeit,Kum)\n"
#~ "@DESCRIPTION=GEOMVERT liefert die Wahrscheinlichkeit @Wahrscheinlichkeit"
#~ "(k), dass eine geometrische Verteilung mit Wahrscheinlichkeitsparameter "
#~ "@Wahrscheinlichkeit @k liefert.\n"
#~ "\n"
#~ "* Falls @k < 0 ist, liefert GEOMVERT einen #ZAHL!-Fehler.\n"
#~ "* Falls @Wahrscheinlichkeit < 0 oder > 1 ist, liefert GEOMVERT einen "
#~ "#ZAHL!-Fehler.\n"
#~ "* Falls @Kum != WAHR und @Kum != FALSCH, liefert GEOMVERT einen #ZAHL!-"
#~ "Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "GEOMVERT(2,10.4,WAHR).\n"
#~ "\n"
#~ "@SEEALSO=ZUFALLSZAHL.GEOM"

#~ msgid ""
#~ "@FUNCTION=LOGISTIC\n"
#~ "@SYNTAX=LOGISTIC(x,a)\n"
#~ "@DESCRIPTION=LOGISTIC returns the probability density p(x) at @x for a "
#~ "logistic distribution with scale parameter @a.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LOGISTIC(0.4,1).\n"
#~ "\n"
#~ "@SEEALSO=RANDLOGISTIC"
#~ msgstr ""
#~ "@FUNCTION=LOGISTISCH\n"
#~ "@SYNTAX=LOGISTISCH(x,a)\n"
#~ "@DESCRIPTION=LOGISTISCH liefert die Wahrscheinlichkeitsdichte p(x) bei @x "
#~ "für eine logistische Verteilung Skalierungsparameter @a.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LOGISTISCH(0.4,1).\n"
#~ "\n"
#~ "@SEEALSO=ZUFALLSZAHL.LOGISTISCH"

#~ msgid ""
#~ "@FUNCTION=PARETO\n"
#~ "@SYNTAX=PARETO(x,a,b)\n"
#~ "@DESCRIPTION=PARETO returns the probability density p(x) at @x for a "
#~ "Pareto distribution with exponent @a and scale @b.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "PARETO(0.6,1,2).\n"
#~ "\n"
#~ "@SEEALSO=RANDPARETO"
#~ msgstr ""
#~ "@FUNCTION=PARETO\n"
#~ "@SYNTAX=PARETO(x,a,b)\n"
#~ "@DESCRIPTION=PARETO liefert die Wahrscheinlichkeitsdichte p(x) bei @x für "
#~ "eine Pareto-Verteilung mit Exponent @a Skalierung @b.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "PARETO(0.6,1,2).\n"
#~ "\n"
#~ "@SEEALSO=ZUFALLSZAHL.PARETO"

#~ msgid ""
#~ "@FUNCTION=RAYLEIGH\n"
#~ "@SYNTAX=RAYLEIGH(x,sigma)\n"
#~ "@DESCRIPTION=RAYLEIGH returns the probability density p(x) at @x for a "
#~ "Rayleigh distribution with scale parameter @sigma.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RAYLEIGH(0.4,1).\n"
#~ "\n"
#~ "@SEEALSO=RANDRAYLEIGH"
#~ msgstr ""
#~ "@FUNCTION=RAYLEIGH\n"
#~ "@SYNTAX=RAYLEIGH(x,Sigma)\n"
#~ "@DESCRIPTION=RAYLEIGH liefert die Wahrscheinlichkeitsdichte p(x) bei @x "
#~ "für eine Rayleigh-Verteilung mit Skalierungsparameter @Sigma.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RAYLEIGH(0.4,1).\n"
#~ "\n"
#~ "@SEEALSO=ZUFALLSZAHL.RAYLEIGH"

#~ msgid ""
#~ "@FUNCTION=RAYLEIGHTAIL\n"
#~ "@SYNTAX=RAYLEIGHTAIL(x,a,sigma)\n"
#~ "@DESCRIPTION=RAYLEIGHTAIL returns the probability density p(x) at @x for "
#~ "a Rayleigh tail distribution with scale parameter @sigma and lower limit "
#~ "@a.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RAYLEIGHTAIL(0.6,0.3,1).\n"
#~ "\n"
#~ "@SEEALSO=RANDRAYLEIGHTAIL"
#~ msgstr ""
#~ "@FUNCTION=RAYLEIGHTAIL\n"
#~ "@SYNTAX=RAYLEIGHTAIL(x,a,Sigma)\n"
#~ "@DESCRIPTION=RAYLEIGHTAIL liefert die Wahrscheinlichkeitsdichte p(x) bei "
#~ "@x für eine Rayleigh-Tail-Verteilung mit Skalierungsparameter @Sigma und "
#~ "Untergrenze @a.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RAYLEIGHTAIL(0.6,0.3,1).\n"
#~ "\n"
#~ "@SEEALSO=ZUFALLSZAHL.RAYLEIGHTAIL"

#~ msgid ""
#~ "@FUNCTION=LAPLACE\n"
#~ "@SYNTAX=LAPLACE(x,a)\n"
#~ "@DESCRIPTION=LAPLACE returns the probability density p(x) at @x for "
#~ "Laplace distribution with mean @a. \n"
#~ "@EXAMPLES=\n"
#~ "LAPLACE(0.4,1).\n"
#~ "\n"
#~ "@SEEALSO=RANDLAPLACE"
#~ msgstr ""
#~ "@FUNCTION=LAPLACE\n"
#~ "@SYNTAX=LAPLACE(x,a)\n"
#~ "@DESCRIPTION=LAPLACE liefert die mögliche Dichte p(x) bei @x für eine "
#~ "Laplace-Verteilung mit Mittelwert @a.\n"
#~ "@EXAMPLES=\n"
#~ "LAPLACE(0.4,1).\n"
#~ "\n"
#~ "@SEEALSO=ZUFALLSZAHL.LAPLACE"

#~ msgid ""
#~ "@FUNCTION=CHAR\n"
#~ "@SYNTAX=CHAR(x)\n"
#~ "@DESCRIPTION=CHAR returns the ASCII character represented by the number "
#~ "@x.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CHAR(65) equals A.\n"
#~ "\n"
#~ "@SEEALSO=CODE"
#~ msgstr ""
#~ "@FUNCTION=ZEICHEN\n"
#~ "@SYNTAX=ZEICHEN(x)\n"
#~ "@DESCRIPTION=ZEICHEN liefert das durch die Zahl @x repräsentierte ASCII-"
#~ "Zeichen.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CHAR(65) liefert A.\n"
#~ "\n"
#~ "@SEEALSO=CODE"

#~ msgid ""
#~ "@FUNCTION=UNICHAR\n"
#~ "@SYNTAX=UNICHAR(x)\n"
#~ "@DESCRIPTION=UNICHAR returns the Unicode character represented by the "
#~ "number @x.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "UNICHAR(65) equals A.\n"
#~ "UNICHAR(960) equals a small Greek pi.\n"
#~ "\n"
#~ "@SEEALSO=CHAR,UNICODE,CODE"
#~ msgstr ""
#~ "@FUNCTION=UNIZEICHEN\n"
#~ "@SYNTAX=UNIZEICHEN(x)\n"
#~ "@DESCRIPTION=UNIZEICHEN liefert das durch die Zahl @x repräsentierte "
#~ "Unicode-Zeichen.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CHAR(65) liefert A.\n"
#~ "UNICHAR(960) liefert ein kleines griechisches Pi.\n"
#~ "\n"
#~ "@SEEALSO=ZEICHEN,UNICODE,CODE"

#~ msgid ""
#~ "@FUNCTION=CODE\n"
#~ "@SYNTAX=CODE(char)\n"
#~ "@DESCRIPTION=CODE returns the ASCII number for the character @char.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CODE(\"A\") equals 65.\n"
#~ "\n"
#~ "@SEEALSO=CHAR"
#~ msgstr ""
#~ "@FUNCTION=CODE\n"
#~ "@SYNTAX=CODE(Zeichen)\n"
#~ "@DESCRIPTION=CODE liefert die ASCII-Zahl für das Zeichen @Zeichen.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CODE(\"A\") liefert 65.\n"
#~ "\n"
#~ "@SEEALSO=ZEICHEN"

#~ msgid ""
#~ "@FUNCTION=UNICODE\n"
#~ "@SYNTAX=UNICODE(char)\n"
#~ "@DESCRIPTION=UNICODE returns the Unicode number for the character @char.\n"
#~ "\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "UNICODE(\"A\") equals 65.\n"
#~ "\n"
#~ "@SEEALSO=UNICHAR,CODE,CHAR"
#~ msgstr ""
#~ "@FUNCTION=UNICODE\n"
#~ "@SYNTAX=UNICODE(Zeichen)\n"
#~ "@DESCRIPTION=UNICODE liefert die Unicode-Zahl für das Zeichen @Zeichen.\n"
#~ "\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CODE(\"A\") liefert 65.\n"
#~ "\n"
#~ "@SEEALSO=UNIZEICHEN,CODE,ZEICHEN"

#~ msgid ""
#~ "@FUNCTION=EXACT\n"
#~ "@SYNTAX=EXACT(string1, string2)\n"
#~ "@DESCRIPTION=EXACT returns true if @string1 is exactly equal to @string2 "
#~ "(this routine is case sensitive).\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "EXACT(\"key\",\"key\") equals TRUE.\n"
#~ "EXACT(\"key\",\"Key\") equals FALSE.\n"
#~ "\n"
#~ "@SEEALSO=LEN, SEARCH, DELTA"
#~ msgstr ""
#~ "@FUNCTION=IDENTISCH\n"
#~ "@SYNTAX=IDENTISCH(Zeichenkette1, Zeichenkette2)\n"
#~ "@DESCRIPTION=IDENTISCH liefert WAHR, falls @Zeichenkette1 identisch mit "
#~ "@Zeichenkette2 ist (Hierbei wird zwischen Groß- und Kleinschreibung "
#~ "unterschieden).\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "IDENTISCH(\"Schlüssel\",\"Schlüssel\") liefert WAHR.\n"
#~ "IDENTISCH(\"Schlüssel\",\"SChlüssel\") liefert FALSCH.\n"
#~ "\n"
#~ "@SEEALSO=LÄNGE, SUCHEN, DELTA"

#~ msgid ""
#~ "@FUNCTION=LEN\n"
#~ "@SYNTAX=LEN(string)\n"
#~ "@DESCRIPTION=LEN returns the length in characters of the string @string.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LEN(\"Helsinki\") equals 8.\n"
#~ "\n"
#~ "@SEEALSO=CHAR, CODE, LENB"
#~ msgstr ""
#~ "@FUNCTION=LÄNGE\n"
#~ "@SYNTAX=LÄNGE(Zeichenkette)\n"
#~ "@DESCRIPTION=LÄNGE liefert die Länge der Zeichen in der Zeichenkette "
#~ "@Zeichenkette.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LÄNGE(\"Helsinki\") liefert 8.\n"
#~ "\n"
#~ "@SEEALSO=CHAR, CODE, LENB"

#~ msgid ""
#~ "@FUNCTION=LENB\n"
#~ "@SYNTAX=LENB(string)\n"
#~ "@DESCRIPTION=LENB returns the length in bytes of the string @string.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LENB(\"Helsinki\") equals 8.\n"
#~ "\n"
#~ "@SEEALSO=CHAR, CODE, LEN"
#~ msgstr ""
#~ "@FUNCTION=LÄNGE\n"
#~ "@SYNTAX=LÄNGE(Zeichenkette)\n"
#~ "@DESCRIPTION=LÄNGE liefert die Länge der Zeichen in der Zeichenkette "
#~ "@Zeichenkette.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LÄNGE(\"Helsinki\") liefert 8.\n"
#~ "\n"
#~ "@SEEALSO=CHAR, CODE, LEN"

#~ msgid ""
#~ "@FUNCTION=LEFT\n"
#~ "@SYNTAX=LEFT(text[,num_chars])\n"
#~ "@DESCRIPTION=LEFT returns the leftmost @num_chars characters or the left "
#~ "character if @num_chars is not specified.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LEFT(\"Directory\",3) equals \"Dir\".\n"
#~ "\n"
#~ "@SEEALSO=MID, RIGHT"
#~ msgstr ""
#~ "@FUNCTION=LINKS\n"
#~ "@SYNTAX=LINKS(Text[,Anzahl_Zeichen])\n"
#~ "@DESCRIPTION=LINKS liefert die ersten @Anzahl_Zeichen Zeichen oder das "
#~ "erste Zeichen, falls @Anzahl_Zeichen nicht angegeben ist.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LINKS(\"Verzeichnis\",3) liefert \"Ver\".\n"
#~ "\n"
#~ "@SEEALSO=TEIL, RECHTS"

#~ msgid ""
#~ "@FUNCTION=LOWER\n"
#~ "@SYNTAX=LOWER(text)\n"
#~ "@DESCRIPTION=LOWER returns a lower-case version of the string in @text.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "LOWER(\"J. F. Kennedy\") equals \"j. f. kennedy\".\n"
#~ "\n"
#~ "@SEEALSO=UPPER"
#~ msgstr ""
#~ "@FUNCTION=KLEIN\n"
#~ "@SYNTAX=KLEIN(Text)\n"
#~ "@DESCRIPTION=KLEIN liefert die Zeichenkette @Text in Kleinschreibung.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "KLEIN(\"J. F. Kennedy\") liefert \"j. f. kennedy\".\n"
#~ "\n"
#~ "@SEEALSO=GROSS"

#~ msgid ""
#~ "@FUNCTION=MID\n"
#~ "@SYNTAX=MID(string, position, length)\n"
#~ "@DESCRIPTION=MID returns a substring from @string starting at @position "
#~ "for @length characters.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "MID(\"testing\",2,3) equals \"est\".\n"
#~ "\n"
#~ "@SEEALSO=LEFT, RIGHT"
#~ msgstr ""
#~ "@FUNCTION=TEIL\n"
#~ "@SYNTAX=TEIL(Zeichenkette, Position, Länge)\n"
#~ "@DESCRIPTION=TEIL liefert einen @Länge langen Teil der Zeichenkette "
#~ "@Zeichenkette, beginnend bei @Position.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TEIL(\"mal testen\",2,3) liefert \"al \".\n"
#~ "\n"
#~ "@SEEALSO=LINKS, RECHTS"

#~ msgid ""
#~ "@FUNCTION=RIGHT\n"
#~ "@SYNTAX=RIGHT(text[,num_chars])\n"
#~ "@DESCRIPTION=RIGHT returns the rightmost @num_chars characters or the "
#~ "right character if @num_chars is not specified.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RIGHT(\"end\") equals \"d\".\n"
#~ "RIGHT(\"end\",2) equals \"nd\".\n"
#~ "\n"
#~ "@SEEALSO=MID, LEFT"
#~ msgstr ""
#~ "@FUNCTION=RECHTS\n"
#~ "@SYNTAX=RECHTS(Text[,Anzahl_Zeichen])\n"
#~ "@DESCRIPTION=RECHTS liefert die letzten @Anzahl_Zeichen Zeichen oder das "
#~ "letzte Zeichen, falls @Anzahl_Zeichen nicht angegeben ist.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "RECHTS(\"Ende\") liefert \"e\".\n"
#~ "RECHTS(\"Ende\") liefert \"e\".\n"
#~ "\n"
#~ "@SEEALSO=TEIL, LINKS"

#~ msgid ""
#~ "@FUNCTION=UPPER\n"
#~ "@SYNTAX=UPPER(text)\n"
#~ "@DESCRIPTION=UPPER returns a upper-case version of the string in @text.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "UPPER(\"cancelled\") equals \"CANCELLED\".\n"
#~ "\n"
#~ "@SEEALSO=LOWER"
#~ msgstr ""
#~ "@FUNCTION=GROSS\n"
#~ "@SYNTAX=GROSS(Text)\n"
#~ "@DESCRIPTION=GROSS liefert die Zeichenkette @Text in Großschreibung.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "GROSS(\"abgebrochen\") liefert \"ABGEBROCHEN\".\n"
#~ "\n"
#~ "@SEEALSO=KLEIN"

#~ msgid ""
#~ "@FUNCTION=CONCATENATE\n"
#~ "@SYNTAX=CONCATENATE(string1[,string2...])\n"
#~ "@DESCRIPTION=CONCATENATE returns the string obtained by concatenation of "
#~ "the given strings.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CONCATENATE(\"aa\",\"bb\") equals \"aabb\".\n"
#~ "\n"
#~ "@SEEALSO=LEFT, MID, RIGHT"
#~ msgstr ""
#~ "@FUNCTION=VERKETTEN\n"
#~ "@SYNTAX=VERKETTEN(Zeichenkette1[,Zeichenkette 2...])\n"
#~ "@DESCRIPTION=VERKETTEN verkettet Zeichenketten und liefert die daraus "
#~ "entstehende Zeichenkette.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "VERKETTEN(\"aa\",\"bb\") liefert \"aabb\".\n"
#~ "\n"
#~ "@SEEALSO=LINKS, TEIL, RECHTS"

# FIXME: check for mathematical correctness
#~ msgid ""
#~ "@FUNCTION=REPT\n"
#~ "@SYNTAX=REPT(string,num)\n"
#~ "@DESCRIPTION=REPT returns @num repetitions of @string.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ " \n"
#~ "@EXAMPLES=\n"
#~ "REPT(\".\",3) equals \"...\".\n"
#~ "\n"
#~ "@SEEALSO=CONCATENATE"
#~ msgstr ""
#~ "@FUNCTION=WIEDERHOLEN\n"
#~ "@SYNTAX=WIEDERHOLEN(Zeichenkette,Anzahl)\n"
#~ "@DESCRIPTION=WIEDERHOLEN liefert @Zeichenkette @Zahl mal.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "WIEDERHOLEN(\".\",3) liefert \"...\".\n"
#~ "\n"
#~ "@SEEALSO=IMLÄNGE"

#~ msgid ""
#~ "@FUNCTION=CLEAN\n"
#~ "@SYNTAX=CLEAN(string)\n"
#~ "@DESCRIPTION=CLEAN removes any non-printable characters from @string.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "CLEAN(\"one\"\\&char(7)) equals \"one\".\n"
#~ "\n"
#~ "@SEEALSO="
#~ msgstr ""
#~ "@FUNCTION=SÄUBERN\n"
#~ "@SYNTAX=SÄUBERN(Zeichenkette)\n"
#~ "@DESCRIPTION=SÄUBERN entfernt alle nicht druckbaren Zeichen aus der "
#~ "Zeichenkette @Zeichenkette.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "SÄUBERN(\"Eins\"\\&char(7)) liefert \"Eins\".\n"
#~ "\n"
#~ "@SEEALSO="

#~ msgid ""
#~ "@FUNCTION=FIND\n"
#~ "@SYNTAX=FIND(string1,string2[,start])\n"
#~ "@DESCRIPTION=FIND returns position of @string1 in @string2 (case-"
#~ "sensitive), searching only from character @start onwards (assuming 1 if "
#~ "omitted).\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FIND(\"ac\",\"Jack\") equals 2.\n"
#~ "\n"
#~ "@SEEALSO=EXACT, LEN, MID, SEARCH"
#~ msgstr ""
#~ "@FUNCTION=FINDEN\n"
#~ "@SYNTAX=FINDEN(Zeichenkette1, Zeichenkette2[, Beginn])\n"
#~ "@DESCRIPTION=FINDEN liefert die Position von @Zeichenkette1 in "
#~ "@Zeichenkette2 unter Berüchsichtigung der Groß-/Kleinschreibung, wobei "
#~ "lediglich ab dem Zeichen @Beginn gesucht wird.\n"
#~ "\n"
#~ "* Falls @Beginn nicht übergeben wird, wird @Beginn = 1 angenommen.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@BEISPIELE?\n"
#~ "FINDEN(\"it\",\"Fritz\") liefert 3.\n"
#~ "\n"
#~ "@SEEALSO=IDENTISCH, LÄNGE, TEIL, SUCHEN"

# FIXME: check for mathematical correctness
#~ msgid ""
#~ "@FUNCTION=FIXED\n"
#~ "@SYNTAX=FIXED(num,[decimals, no_commas])\n"
#~ "@DESCRIPTION=FIXED returns @num as a formatted string with @decimals "
#~ "numbers after the decimal point, omitting commas if requested by "
#~ "@no_commas.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FIXED(1234.567,2) equals \"1,234.57\".\n"
#~ "\n"
#~ "@SEEALSO=TEXT, VALUE, DOLLAR"
#~ msgstr ""
#~ "@FUNCTION=FEST\n"
#~ "@SYNTAX=FEST(Zahl[, Dezimalen, keine_Kommata])\n"
#~ "@DESCRIPTION=FEST liefert @Zahl als formatierte Zeichenkette mit "
#~ "@Dezimalen Zahlen hinter dem Dezimalpunkt, wobei Kommata übergangen "
#~ "werden, falls @Keine_Kommata übergeben wurde.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FEST(1234.567,2) liefert \"1,234.57\".\n"
#~ "\n"
#~ "@SEEALSO="

# FIXME: check for mathematical correctness
#~ msgid ""
#~ "@FUNCTION=PROPER\n"
#~ "@SYNTAX=PROPER(string)\n"
#~ "@DESCRIPTION=PROPER returns @string with initial of each word "
#~ "capitalised.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "PROPER(\"j. f. kennedy\") equals \"J. F. Kennedy\".\n"
#~ "\n"
#~ "@SEEALSO=LOWER, UPPER"
#~ msgstr ""
#~ "@FUNCTION=GROSS2\n"
#~ "@SYNTAX=GROSS2(Zeichenkette)\n"
#~ "@DESCRIPTION=GROSS2 liefert @Zeichenkette, wobei der erste Buchstebe "
#~ "jedes Worts groß geschrieben wird.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "GROSS2(\"j. f. kennedy\") liefert \"J. F. Kennedy\".\n"
#~ "\n"
#~ "@SEEALSO=KLEIN, GROSS"

#~ msgid ""
#~ "@FUNCTION=REPLACE\n"
#~ "@SYNTAX=REPLACE(old,start,num,new)\n"
#~ "@DESCRIPTION=REPLACE returns @old with @new replacing @num characters "
#~ "from @start.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "REPLACE(\"testing\",2,3,\"*****\") equals \"t*****ing\".\n"
#~ "\n"
#~ "@SEEALSO=MID, SEARCH, SUBSTITUTE, TRIM"
#~ msgstr ""
#~ "@FUNCTION=ERSETZEN\n"
#~ "@SYNTAX=ERSETZEN(alt,Beginn,Zahl,neu)\n"
#~ "@DESCRIPTION=ERSETZEN liefert @alt, wobei @Zahl Zeichen vom @Beginn an "
#~ "durch @neu ersetzt werden.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ERSETZEN(\"testing\",2,3,\"*****\") liefert \"t*****ing\".\n"
#~ "\n"
#~ "@SEEALSO= :: LATER"

#~ msgid ""
#~ "@FUNCTION=T\n"
#~ "@SYNTAX=T(value)\n"
#~ "@DESCRIPTION=T returns @value if and only if it is text, otherwise a "
#~ "blank string.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "T(\"text\") equals \"text\".\n"
#~ "T(64) returns an empty cell.\n"
#~ "\n"
#~ "@SEEALSO=CELL, N, VALUE"
#~ msgstr ""
#~ "@FUNCTION=T\n"
#~ "@SYNTAX=T(Wert)\n"
#~ "@DESCRIPTION=T liefert @Wert, falls und nur falls dieser Text ist, sonst "
#~ "eine leere Zeichenkette.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "T(\"Text\") liefert \"Text\".\n"
#~ "T(64) liefert eine leere Zelle.\n"
#~ "\n"
#~ "@SEEALSO=ZELLE, N, WERT"

#~ msgid ""
#~ "@FUNCTION=TEXT\n"
#~ "@SYNTAX=TEXT(value,format_text)\n"
#~ "@DESCRIPTION=TEXT returns @value as a string with the specified format.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TEXT(3.223,\"$0.00\") equals \"$3.22\".\n"
#~ "TEXT(date(1999,4,15),\"mmmm, dd, yy\") equals \"April, 15, 99\".\n"
#~ "\n"
#~ "@SEEALSO=DOLLAR, FIXED, VALUE"
#~ msgstr ""
#~ "@FUNCTION=TEXT\n"
#~ "@SYNTAX=TEXT(Wert,Text_Formatierung)\n"
#~ "@DESCRIPTION=TEXT liefert @Wert als Zeichenkette im angegebenen Format.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TEXT(3.223,\"$0.00\") liefert \"$3.22\".\n"
#~ "TEXT(DATUM(1999,4,15),\"mmmm, dd, yy\") lierfert \"April, 15, 99\".\n"
#~ "\n"
#~ "@SEEALSO=EURO"

#~ msgid ""
#~ "@FUNCTION=TRIM\n"
#~ "@SYNTAX=TRIM(text)\n"
#~ "@DESCRIPTION=TRIM returns @text with only single spaces between words.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "TRIM(\"  a bbb  cc\") equals \"a bbb cc\".\n"
#~ "\n"
#~ "@SEEALSO=CLEAN, MID, REPLACE, SUBSTITUTE"
#~ msgstr ""
#~ "@FUNCTION=GLÄTTEN\n"
#~ "@SYNTAX=GLÄTTEN(Text)\n"
#~ "@DESCRIPTION=GLÄTTEN liefert den Text mit einem Leerzeichen zwischen den "
#~ "Worten.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "GLÄTTEN(\"  a bbb  c\") liefert \"a bbb cc\".\n"
#~ "\n"
#~ "@SEEALSO=SÄUBERN, TEIL, ERSETZEN, WECHSELN"

# $ durch Euro ersetzen!
#~ msgid ""
#~ "@FUNCTION=VALUE\n"
#~ "@SYNTAX=VALUE(text)\n"
#~ "@DESCRIPTION=VALUE returns numeric value of @text.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "VALUE(\"$1,000\") equals 1000.\n"
#~ "\n"
#~ "@SEEALSO=DOLLAR, FIXED, TEXT"
#~ msgstr ""
#~ "@FUNCTION=WERT\n"
#~ "@SYNTAX=WERT(Text)\n"
#~ "@DESCRIPTION=WERT liefert den numerischen Wert von @Text.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "WERT(\"$1,000\") liefert 1000.\n"
#~ "\n"
#~ "@SEEALSO=EURO, FEST, TEXT"

#~ msgid ""
#~ "@FUNCTION=SUBSTITUTE\n"
#~ "@SYNTAX=SUBSTITUTE(text, old, new [,num])\n"
#~ "@DESCRIPTION=SUBSTITUTE replaces @old with @new in @text.  Substitutions "
#~ "are only applied to instance @num of @old in @text, otherwise every one "
#~ "is changed.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "SUBSTITUTE(\"testing\",\"test\",\"wait\") equals \"waiting\".\n"
#~ "\n"
#~ "@SEEALSO=REPLACE, TRIM"
#~ msgstr ""
#~ "@FUNCTION=WECHSELN\n"
#~ "@SYNTAX=WECHSELN(Text,Alt,Neu[,Zahl])\n"
#~ "@DESCRIPTION=WECHSELN ersetzt @Alt in @Text durch @Neu. Ersetzungen "
#~ "werden nur auf Instanz @Zahl von @Alt in @Text angewandt, andernfalls "
#~ "werden alle verändert.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "WECHSELN(\"\testen\",\"test\",\"wart\") liefert \"warten\".\n"
#~ "\n"
#~ "@SEEALSO=ERSETZEN, GLÄTTEN"

#~ msgid ""
#~ "@FUNCTION=DOLLAR\n"
#~ "@SYNTAX=DOLLAR(num[,decimals])\n"
#~ "@DESCRIPTION=DOLLAR returns @num formatted as currency.\n"
#~ "\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DOLLAR(12345) equals \"$12,345.00\".\n"
#~ "\n"
#~ "@SEEALSO=FIXED, TEXT, VALUE"
#~ msgstr ""
#~ "@FUNCTION=DOLLAR\n"
#~ "@SYNTAX=DOLLAR(Zahl[,Dezimalen])\n"
#~ "@DESCRIPTION=DOLLAR liefert @Zahl als Währung formatiert.\n"
#~ "\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "DOLLAR(12345) liefert \"$12,345.00\".\n"
#~ "\n"
#~ "@SEEALSO=FEST, TEXT, WERT"

#~ msgid ""
#~ "@FUNCTION=SEARCH\n"
#~ "@SYNTAX=SEARCH(search_string,text[,start_num])\n"
#~ "@DESCRIPTION=SEARCH returns the location of the @search_ string within "
#~ "@text. The search starts  with the @start_num character of text @text.  "
#~ "If @start_num is omitted, it is assumed to be one.  The search is not "
#~ "case sensitive.\n"
#~ "\n"
#~ "@search_string can contain wildcard characters (*) and question marks "
#~ "(?). A question mark matches any character and a wildcard matches any "
#~ "string including the empty string.  If you want the actual wildcard or "
#~ "question mark to be found, use tilde (~) before the character.\n"
#~ "\n"
#~ "* If @search_string is not found, SEARCH returns #VALUE! error.\n"
#~ "* If @start_num is less than one or it is greater than the length of "
#~ "@text, SEARCH returns #VALUE! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "SEARCH(\"c\",\"Cancel\") equals 1.\n"
#~ "SEARCH(\"c\",\"Cancel\",2) equals 4.\n"
#~ "\n"
#~ "@SEEALSO=FIND"
#~ msgstr ""
#~ "@FUNCTION=SUCHEN\n"
#~ "@SYNTAX=SUCHEN(Text,innerhalb[,Ausgangszahl])\n"
#~ "@DESCRIPTION=SUCHEN liefert die Position eines Zeichens oder Texts @Text "
#~ "innerhalb einer anderen Zeichenkette @innerhalb, wobei die Suche bei "
#~ "@Ausgangszahl Zeichen des Texts @Text beginnt. \n"
#~ "@Text kann Joker- (*) und Fragezeichen (?) enthalten, um die Suche zu "
#~ "beeinflussen.\n"
#~ "Für ein Fragezeichen kann ein beliebiges Zeichen und ein Joker-Zeichen "
#~ "eine beliebige Zeichenkette stehen. Falls nach einem Joker- oder "
#~ "Fragezeichen gesucht werden soll, muss eine Tilde (~) vor dem Zeichen "
#~ "übergeben werden.\n"
#~ "\n"
#~ "* Beim Suchen wird nicht zwischen Groß- und Kleinschreibung "
#~ "unterschieden.\n"
#~ "* Falls der Suchtext @Text nicht gefunden wird, liefert SUCHEN einen "
#~ "#WERT!-Fehler.\n"
#~ "* Falls @Ausgangszahl nicht übergegeben wird, wird dafür eins "
#~ "angenommen.\n"
#~ "* Falls @Ausganzgszahl < 1 oder > Länge von @innerhalb ist, liefert "
#~ "SUCHEN einen #WERT-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "SUCHEN(\"b\",\"Abbrechen\") liefert 2.\n"
#~ "SUCHEN(\"b\",\"Abbrechen\",3) liefert 3.\n"
#~ "\n"
#~ "@SEEALSO=FINDEN"

#~ msgid ""
#~ "@FUNCTION=EXECSQL\n"
#~ "@SYNTAX=EXECSQL(dsn,username,password,sql)\n"
#~ "@DESCRIPTION=The EXECSQL function lets you execute a command in a "
#~ "database server, and show the results returned in current sheet. It uses "
#~ "libgda as the means for accessing the databases.\n"
#~ "For using it, you need first to set up a libgda data source.\n"
#~ "@EXAMPLES=\n"
#~ "To get all the data from the table \"Customers\" present in the "
#~ "\"mydatasource\" GDA data source, you would use:\n"
#~ "EXECSQL(\"mydatasource\",\"username\",\"password\",\"SELECT * FROM "
#~ "customers\")\n"
#~ "@SEEALSO=READDBTABLE"
#~ msgstr ""
#~ "@FUNCTION=AUSFSQL\n"
#~ "@SYNTAX=AUSFSQL(DSN,Benutzername,Passwort,SQL)\n"
#~ "@DESCRIPTION=AUSFSQL ermöglicht es Ihnen, eine Abfrage an einen\n"
#~ "Datenbank-Server durchzuführen und das Ergebnis im momentan angezeigten "
#~ "Blatt\n"
#~ "anzuzeigen. Als Bindeglied für den Datenbankzugriff wird libgda "
#~ "verwendet.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Um alle Daten aus der Tabelle »Kunden« in der GDA-Datenquelle "
#~ "»MeineDatenquelle« abzurufen, müssen Sie verwenden:\n"
#~ "AUSFSQL(\"MeineDatenQuelle\",\"Benutzername\",\"Passwort\",\"SELECT * "
#~ "FROM Kunden\"\n"
#~ "@SEEALSO=DBTABELLELESEN"

#, fuzzy
#~ msgid ""
#~ "@FUNCTION=READDBTABLE\n"
#~ "@SYNTAX=READDBTABLE(dsn,username,password,table)\n"
#~ "@DESCRIPTION=The READDBTABLE function lets you get the contents of a "
#~ "table, as stored in a database. For using it, you need first to set up a "
#~ "libgda data source.\n"
#~ "Note that this function returns all the rows in the given table. If you "
#~ "want to get data from more than one table or want a more precise "
#~ "selection (conditions), use the EXECSQL function.\n"
#~ "@EXAMPLES=\n"
#~ "To get all the data from the table \"Customers\" present in the "
#~ "\"mydatasource\" GDA data source, you would use:\n"
#~ "READDBTABLE(\"mydatasource\",\"username\",\"password\",\"customers\")\n"
#~ "@SEEALSO=EXECSQL"
#~ msgstr ""
#~ "@FUNCTION=AUSFSQL\n"
#~ "@SYNTAX=AUSFSQL(DSN,Benutzername,Passwort,SQL)\n"
#~ "@DESCRIPTION=AUSFSQL ermöglicht es Ihnen, eine Abfrage an einen\n"
#~ "Datenbank-Server durchzuführen und das Ergebnis im momentan angezeigten "
#~ "Blatt\n"
#~ "anzuzeigen. Als Bindeglied für den Datenbankzugriff wird libgda "
#~ "verwendet.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Um alle Daten aus der Tabelle »Kunden« in der GDA-Datenquelle "
#~ "»MeineDatenquelle« abzurufen, müssen Sie verwenden:\n"
#~ "AUSFSQL(\"MeineDatenQuelle\",\"Benutzername\",\"Passwort\",\"SELECT * "
#~ "FROM Kunden\"\n"
#~ "@SEEALSO=DBTABELLELESEN"

#~ msgid ""
#~ "@FUNCTION=NT_PHI\n"
#~ "@SYNTAX=NT_PHI(n)\n"
#~ "@DESCRIPTION=NT_PHI function calculates the number of integers less than "
#~ "or equal to @n that are relatively prime to @n.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=NT_D, ITHPRIME, NT_SIGMA"
#~ msgstr ""
#~ "@FUNCTION=NT_PHI\n"
#~ "@SYNTAX=NT_PHI(n)\n"
#~ "@DESCRIPTION=NT_PHI liefert die Anzahl der Ganzzahlen kleiner oder gleich "
#~ "@n, die zugleich Primteiler von @n sind.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=NT_D, ITHPRIME, NT_SIGMA"

#~ msgid ""
#~ "@FUNCTION=NT_D\n"
#~ "@SYNTAX=NT_D(n)\n"
#~ "@DESCRIPTION=NT_D function calculates the number of divisors of @n.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=ITHPRIME, NT_PHI, NT_SIGMA"
#~ msgstr ""
#~ "@FUNCTION=NT_D\n"
#~ "@SYNTAX=NT_D(n)\n"
#~ "@DESCRIPTION=NT_D liefert die Anzahl der Teiler von @n.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=ITERPRIM, NT_PHI, NT_SIGMA"

#~ msgid ""
#~ "@FUNCTION=NT_SIGMA\n"
#~ "@SYNTAX=NT_SIGMA(n)\n"
#~ "@DESCRIPTION=NT_SIGMA function calculates the sum of the divisors of @n.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=NT_D, ITHPRIME, NT_PHI"
#~ msgstr ""
#~ "@FUNCTION=NT_SIGMA\n"
#~ "@SYNTAX=NT_SIGMA(n)\n"
#~ "@DESCRIPTION=NT_SIGMA liefert die Summe der Teiler von @n.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=ITERPRIM, NT_D, NT_PHI"

#~ msgid ""
#~ "@FUNCTION=ITHPRIME\n"
#~ "@SYNTAX=ITHPRIME(i)\n"
#~ "@DESCRIPTION=ITHPRIME function returns the @ith prime.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=NT_D, NT_SIGMA"
#~ msgstr ""
#~ "@FUNCTION=ITERPRIM\n"
#~ "@SYNTAX=ITERPRIM(i)\n"
#~ "@DESCRIPTION=ITERPRIM liefert den @i-ten Primteiler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=NT_D, NT_SIGMA"

#~ msgid ""
#~ "@FUNCTION=ISPRIME\n"
#~ "@SYNTAX=ISPRIME(i)\n"
#~ "@DESCRIPTION=ISPRIME function returns TRUE if @i is prime and FALSE "
#~ "otherwise.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=ITHPRIME, NT_D, NT_SIGMA"
#~ msgstr ""
#~ "@FUNCTION=ISTPRIM\n"
#~ "@SYNTAX=ISTPRIM(i)\n"
#~ "@DESCRIPTION=ISTPRIM liefert WAHR, falls @i prim ist, sonst FALSCH.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=ITERPRIM, NT_D, NT_SIGMA"

#~ msgid ""
#~ "@FUNCTION=PFACTOR\n"
#~ "@SYNTAX=PFACTOR(n)\n"
#~ "@DESCRIPTION=PFACTOR function returns the smallest prime factor of its "
#~ "argument.\n"
#~ "\n"
#~ "The argument must be at least 2, or else a #VALUE! error is returned.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=ITHPRIME"
#~ msgstr ""
#~ "@FUNCTION=PFAKTOR\n"
#~ "@SYNTAX=PFAKTOR(n)\n"
#~ "@DESCRIPTION=PFAKTOR liefert den kleinsten Primfaktor des übergebenen "
#~ "Arguments.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=ITERPRIM"

#~ msgid ""
#~ "@FUNCTION=NT_PI\n"
#~ "@SYNTAX=NT_PI(n)\n"
#~ "@DESCRIPTION=NT_PI function returns the number of primes less than or "
#~ "equal to @n.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=ITHPRIME, NT_PHI, NT_D, NT_SIGMA"
#~ msgstr ""
#~ "@FUNCTION=NT_PI\n"
#~ "@SYNTAX=NT_PI(n)\n"
#~ "@DESCRIPTION=NT_PI liefert die Anzahl der Primzahlen, die kleiner als @n "
#~ "sind.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=ITERPRIM, NT_PHI, NT_D, NT_SIGMA"

#~ msgid ""
#~ "@FUNCTION=BITOR\n"
#~ "@SYNTAX=BITOR(a,b)\n"
#~ "@DESCRIPTION=BITOR function returns bitwise or-ing of its arguments.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=BITXOR,BITAND"
#~ msgstr ""
#~ "@FUNCTION=BITODER\n"
#~ "@SYNTAX=BITODER(a,b)\n"
#~ "@DESCRIPTION=BITODER liefert das Ergebnis der bitweisen ODER-Verknüpfung "
#~ "der übergebenen Argumente.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=BITXODER,BITUND"

#~ msgid ""
#~ "@FUNCTION=BITXOR\n"
#~ "@SYNTAX=BITXOR(a,b)\n"
#~ "@DESCRIPTION=BITXOR function returns bitwise exclusive or-ing of its "
#~ "arguments.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=BITOR,BITAND"
#~ msgstr ""
#~ "@FUNCTION=BITXODER\n"
#~ "@SYNTAX=BITXODER(a,b)\n"
#~ "@DESCRIPTION=BITXODER liefert das Ergebnis der bitweisen exklusiven ODER-"
#~ "Verknüpfung der übergebenen Argumente.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=BITODER,BITUND"

#~ msgid ""
#~ "@FUNCTION=BITAND\n"
#~ "@SYNTAX=BITAND(a,b)\n"
#~ "@DESCRIPTION=BITAND function returns bitwise and-ing of its arguments.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=BITOR,BITXOR"
#~ msgstr ""
#~ "@FUNCTION=BITUND\n"
#~ "@SYNTAX=BITUND(a,b)\n"
#~ "@DESCRIPTION=BITUND liefert das Ergebnis der bitweisen UND-Verknüpfung "
#~ "der übergebenen Argumente.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=BITODER,BITXODER"

#~ msgid ""
#~ "@FUNCTION=BITLSHIFT\n"
#~ "@SYNTAX=BITLSHIFT(x,n)\n"
#~ "@DESCRIPTION=BITLSHIFT function returns @x bit-shifted left by @n bits.\n"
#~ "\n"
#~ "* If @n is negative, a right shift will in effect be performed.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=BITRSHIFT"
#~ msgstr ""
#~ "@FUNCTION=BITSCHIEBEL\n"
#~ "@SYNTAX=BITSCHIEBEL(x,n)\n"
#~ "@DESCRIPTION=Die BITSCHIEBEL Funktion liefert das Ergebnis der Bitschiebe-"
#~ "Operation auf @x um @n Bits nach links.\n"
#~ "\n"
#~ "* Falls @n negativ ist, wird eine Bitschiebe-Operation nach rechts "
#~ "durchgeführt.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=BITSCHIEBER"

#~ msgid ""
#~ "@FUNCTION=BITRSHIFT\n"
#~ "@SYNTAX=BITRSHIFT(x,n)\n"
#~ "@DESCRIPTION=BITRSHIFT function returns @x bit-shifted right by @n bits.\n"
#~ "\n"
#~ "* If @n is negative, a left shift will in effect be performed.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=BITLSHIFT"
#~ msgstr ""
#~ "@FUNCTION=BITSCHIEBER\n"
#~ "@SYNTAX=BITSCHIEBER(x,n)\n"
#~ "@DESCRIPTION=Die BITSCHIEBER Funktion liefert das Ergebnis der Bitschiebe-"
#~ "Operation auf @x um @n Bits nach rechts.\n"
#~ "\n"
#~ "* Falls @n negativ ist, wird eine Bitschiebe-Operation nach links "
#~ "durchgeführt.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "@SEEALSO=BITSCHIEBEL"

#~ msgid ""
#~ "@FUNCTION=COLUMN\n"
#~ "@SYNTAX=COLUMN([reference])\n"
#~ "@DESCRIPTION=COLUMN function returns the column number of the current "
#~ "cell unless @reference is given. In that case, it returns an array of the "
#~ "column numbers of all cells in @reference. \n"
#~ "* If @reference is neither an array nor a reference nor a range, COLUMN "
#~ "returns #VALUE! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "COLUMN() in E1 equals 5.\n"
#~ "\n"
#~ "@SEEALSO=COLUMNS,ROW,ROWS"
#~ msgstr ""
#~ "@FUNCTION=SPALTE\n"
#~ "@SYNTAX=SPALTE([Bezug])\n"
#~ "@DESCRIPTION=SPALTE liefert die Spaltennummer der momentan gewählten "
#~ "Zelle, falls @Bezug nicht übergeben wird. Andernfalls liefert es ein "
#~ "Datenfeld mit den Spaltennummern aller Zellen in @Bezug.\n"
#~ "\n"
#~ "* Falls @Bezug weder ein Feld, noch ein Bezug oder Bereich ist, liefert "
#~ "SPALTE einen #WERT!-Fehler.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "SPALTE() in E1 liefert 5.\n"
#~ "\n"
#~ "@SEEALSO=SPALTEN, ZEILE, ZEILEN"

#~ msgid ""
#~ "@FUNCTION=ROW\n"
#~ "@SYNTAX=ROW([reference])\n"
#~ "@DESCRIPTION=ROW function returns an array of the row numbers taking a "
#~ "default argument of the containing cell position.\n"
#~ "\n"
#~ "* If @reference is neither an array nor a reference nor a range, ROW "
#~ "returns #VALUE! error.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ROW() in G13 equals 13.\n"
#~ "\n"
#~ "@SEEALSO=COLUMN,COLUMNS,ROWS"
#~ msgstr ""
#~ "@FUNCTION=ZEILE\n"
#~ "@SYNTAX=ZEILE([Bezug])\n"
#~ "@DESCRIPTION=ZEILE liefert ein Feld mit den Zeilennummern, wobei als "
#~ "Vorgabeargument die Position der enthaltenden Zelle verwendet wird.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "ZEILE() in G13 liefert 13.\n"
#~ "\n"
#~ "@SEEALSO=SPALTE,SPALTEN,ZEILEN"

#~ msgid ""
#~ "@FUNCTION=FLOOR\n"
#~ "@SYNTAX=FLOOR(x[,significance])\n"
#~ "@DESCRIPTION=FLOOR function rounds @x down to the next nearest multiple "
#~ "of @significance.\n"
#~ "\n"
#~ "* @significance defaults to 1.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "FLOOR(0.5) equals 0.\n"
#~ "FLOOR(5,2) equals 4.\n"
#~ "FLOOR(-5,-2) equals -4.\n"
#~ "FLOOR(-5,2) equals #NUM!.\n"
#~ "\n"
#~ "@SEEALSO=CEIL, CEILING, ABS, INT, MOD"
#~ msgstr ""
#~ "@FUNCTION=UNTERGRENZE\n"
#~ "@SYNTAX=UNTERGRENZE(x[,Signifikanz])\n"
#~ "@DESCRIPTION=UNTERGRENZE rundet @x auf das nächste Vielfache von "
#~ "@Signifikanz ab.\n"
#~ "\n"
#~ "* Die Vorgabe für @Signifikanz ist 1.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "UNTERGRENZE(0.5) liefert 0.\n"
#~ "UNTERGRENZE(5,2) liefert 4.\n"
#~ "UNTERGRENZE(-5,-2) liefert -4.\n"
#~ "UNTERGRENZE(-5,2) liefert #ZAHL!.\n"
#~ "\n"
#~ "@SEEALSO=OBERGRENZE, ABS, GANZZAHL"

#~ msgid ""
#~ "@FUNCTION=SUMPRODUCT\n"
#~ "@SYNTAX=SUMPRODUCT(range1,range2,...)\n"
#~ "@DESCRIPTION=SUMPRODUCT function multiplies corresponding data entries in "
#~ "the given arrays or ranges, and then returns the sum of those products.  "
#~ "If an array entry is not numeric, the value zero is used instead.\n"
#~ "\n"
#~ "* If arrays or range arguments do not have the same dimensions, "
#~ "SUMPRODUCT returns #VALUE! error.\n"
#~ "* This function is Excel compatible.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Let us assume that the cells A1, A2, ..., A5 contain numbers 11, 15, 17, "
#~ "21, and 43 and the cells B1, B2, ..., B5 hold numbers 13, 22, 31, 33, and "
#~ "39.  Then\n"
#~ "SUMPRODUCT(A1:A5,B1:B5) equals 3370.\n"
#~ "\n"
#~ "@SEEALSO=SUM,PRODUCT"
#~ msgstr ""
#~ "@FUNCTION=SUMMENPRODUKT\n"
#~ "@SYNTAX=SUMMENPRODUKT(Bereich1,Bereich2,...)\n"
#~ "@DESCRIPTION=SUMMENPRODUKT multipliziert die entsprechenden Dateneinträge "
#~ "in den angegebenen Feldern oder Bereichen und liefert dann die Summe "
#~ "dieser Produkte. Falls ein Feldeintrag nicht numerisch ist, wird "
#~ "stattdessen der Wert Null verwendet.\n"
#~ "\n"
#~ "* Falls Felder- oder Bereichsargumente unterschiedliche Dimensionen "
#~ "haben, liefert SUMMENPRODUKT einen #WERT!-Fehler.\n"
#~ "* Diese Funktion ist Excel-kompatibel.\n"
#~ "\n"
#~ "@EXAMPLES=\n"
#~ "Angenommen, die Zellen A1, A2, ..., A5 enthalten die Zahlen 11, 15, 17, "
#~ "21 und 43 und die Zellen B1, B2, ..., B5 13, 22, 31, 33 sowie 39. Dann "
#~ "liefert\n"
#~ "SUMMENPRODUKT(A1:A5,B1:B5) 3370.\n"
#~ "\n"
#~ "@SEEALSO=SUMME, PRODUKT"
