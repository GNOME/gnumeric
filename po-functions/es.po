# translation of gnumeric-functions.HEAD.po to Español
# Spanish translation of gnumeric
# Copyright © 1998,2003, 2006, 2007, 2008 Free Software Foundation, Inc.
# This file is distributed under the same license as the gnumeric package.
#
# Alfonso  Pedereño García-LaPuya, 2002.
# Federico Mena Quintero,Pregonero <federico@casiopea.quartic.org>, 1998.
# Pablo Saratxaga <pablo@mandrakesoft.com>, 1999-2000.
# Germán Poo Caamaño <gpoo@ubiobio.cl>, 2001.
# Juan Manuel García Molina <juanma_gm@wanadoo.es>, 2002.
# Francisco Javier F. Serrador <serrador@tecknolabs.com>, 2006.
# Jorge González <jorgegonz@svn.gnome.org>, 2007, 2008.
msgid ""
msgstr ""
"Project-Id-Version: gnumeric-functions.HEAD\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2008-08-29 15:13+0000\n"
"PO-Revision-Date: 2008-08-31 16:07+0200\n"
"Last-Translator: Jorge González <jorgegonz@svn.gnome.org>\n"
"Language-Team: Español <gnome-es-list@gnome.org>\n"
"MIME-Version: 1.0\n"
"Content-Type:  text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: KBabel 1.11.4\n"
"Plural-Forms:  nplurals=2; plural=(n != 1);\n"

#: ../plugins/derivatives/options.c:174
#, no-c-format
msgid ""
"@FUNCTION=CUM_BIV_NORM_DIST\n"
"@SYNTAX=CUM_BIV_NORM_DIST(a,b,rho)\n"
"@DESCRIPTION=CUM_BIV_NORM_DIST calculates the cumulative bivariate normal "
"distribution from parameters a, b & rho.\n"
"The return value is the probability that two random variables with "
"correlation @rho are respectively each less than @a and @b.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=NORMDIST,NORMSDIST,NORMSINV"
msgstr ""
"@FUNCTION=CUM_BIV_NORM_DIST\n"
"@SYNTAX=CUM_BIV_NORM_DIST(a,b,ro)\n"
"@DESCRIPTION=CUM_BIV_NORM_DIST calcula la distribución acumulada bivariada "
"normal con los parámetros a, b y ro.\n"
"El valor devuelto es la probabilidad de que dos variables aleatorias con "
"correlación @ro sean respectivamente cada una menor que @a y @b\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=NORMDIST,NORMSDIST,NORMSINV"

#: ../plugins/derivatives/options.c:234
msgid ""
"@FUNCTION=OPT_BS\n"
"@SYNTAX=OPT_BS(call_put_flag,spot,strike,time,rate,volatility [,"
"cost_of_carry])\n"
"@DESCRIPTION=OPT_BS uses the Black-Scholes model to calculate the price of a "
"European option using call_put_flag, @call_put_flag, 'c' or 'p' struck at "
"@strike on an asset with spot price @spot.\n"
"@time is the time to maturity of the option expressed in years.\n"
"@rate is the risk-free interest rate.\n"
"@volatility is the annualized volatility, in percent, of the asset for the "
"period through to the exercise date. \n"
"@cost_of_carry is the leakage in value of the underlying asset, for common "
"stocks, this would be the dividend yield.\n"
"* The returned value will be expressed in the same units as @strike and "
"@spot.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_VEGA, OPT_BS_GAMMA"
msgstr ""
"@FUNCTION=OPT_BS\n"
"@SYNTAX=OPT_BS(indicador_call_put,spot,strike,tiempo,tasa,volatilidad [,"
"devaluación])\n"
"@DESCRIPTION=OPT_BS usa el modelo Black-Scholes para calcular el precio de "
"una opción Europea usando call/put fijada un precio @strike en un activo con "
"precio @spot.\n"
"\n"
"@indicador_call_put es «c» o «p» dependiendo de si la opción es «call» o «put»\n"
" @tiempo es el tiempo para el vencimiento de la opción expresado en años\n"
"@tasa es la tasa de interés libre de riesgo.\n"
"@volatilidad es la volatilidad anualizada, en porcentaje, del activo o el "
"periodo hasta la fecha del ejercicio.\n"
"@devaluación es la pérdida de valor del activo subyacente,para stock "
"comunes, esto debería ser el margen (yield) del dividendo\n"
"* El valor devuelto será expresado en las mismas unidades que @strike y "
"@spot.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_VEGA, OPT_BS_GAMMA"

#: ../plugins/derivatives/options.c:303
msgid ""
"@FUNCTION=OPT_BS_DELTA\n"
"@SYNTAX=OPT_BS_DELTA(call_put_flag,spot,strike,time,rate,volatility[,"
"cost_of_carry])\n"
"@DESCRIPTION=OPT_BS_DELTA uses the Black-Scholes model to calculate the "
"'delta' of a European option with call_put_flag, @call_put_flag, 'c' or 'p' "
"struck at @strike on an asset with spot price @spot.\n"
"Where @time is the time to maturity of the option expressed in years.\n"
"@rate is the risk-free interest rate.\n"
"@volatility is the annualized volatility, in percent, of the asset for the "
"period through to the exercise date. \n"
"@cost_of_carry is the leakage in value of the underlying asset, for common "
"stocks, this would be the dividend yield.\n"
"* The returned value will be expressed in the same units as @strike and "
"@spot.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_BS, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_VEGA, OPT_BS_GAMMA"
msgstr ""
"@FUNCTION=OPT_BS_DELTA\n"
"@SYNTAX=OPT_BS_DELTA(indicador_call_put,spot,strike,tiempo,tasa,volatilidad[,"
"devaluación])\n"
"@DESCRIPTION=OPT_BS_DELTA usa el modelo Black-Scholes para calcular la "
"«delta» de una opción europea con call/put fijada un precio @strike en un "
"activo con precio @spot.\n"
"\n"
"(La «delta» de una opción es la tasa de cambio de su precio respecto al "
"precio spot del activo subyacente.)\n"
"\n"
"@indicador_call_put es «c» o «p» dependiendo de si la opción es «call» o «put»\n"
"@tiempo es el tiempo para el vencimiento de la opción expresado en años\n"
"@tasa es la tasa de interés libre de riesgo.\n"
"@volatilidad es la volatilidad anualizada, en porcentaje, del activo o el "
"periodo hasta la fecha del ejercicio.\n"
"@devaluación es la pérdida de valor del activo subyacente,para stock "
"comunes, esto debería ser el margen (yield) del dividendo\n"
"* El valor devuelto será expresado en las mismas unidades que @strike y "
"@spot.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_BS, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_VEGA, OPT_BS_GAMMA"

#: ../plugins/derivatives/options.c:358
msgid ""
"@FUNCTION=OPT_BS_GAMMA\n"
"@SYNTAX=OPT_BS_GAMMA(spot,strike,time,rate,volatility[,cost_of_carry])\n"
"@DESCRIPTION=OPT_BS_GAMMA uses the Black-Scholes model to calculate the "
"'gamma' of a European option struck at @strike on an asset with spot price "
"@spot.\n"
"\n"
"(The gamma of an option is the second derivative of its price with respect "
"to the price of the underlying asset, and is the same for calls and puts.)\n"
"\n"
"@time is the time to maturity of the option expressed in years.\n"
"@rate is the risk-free interest rate to the exercise date, in percent.\n"
"@volatility is the annualized volatility, in percent, of the asset for the "
"period through to the exercise date.\n"
"@cost_of_carry is the leakage in value of the underlying asset, for common "
"stocks, this would be the dividend yield.\n"
"* The returned value will be expressed as the rate of change of delta per "
"unit change in @spot.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_VEGA"
msgstr ""
"@FUNCTION=OPT_BS_GAMMA\n"
"@SYNTAX=OPT_BS_GAMMA(spot,strike,tiempo,tasa,volatilidad[,devaluación])\n"
"@DESCRIPTION=OPT_BS_GAMMA usa el modelo Black-Scholes para calcular la "
"«gamma» de una opción europea fijada a @strike en un activo con precio "
"@spot.\n"
"\n"
"(La «gamma» de una opción es la derivada segunda de su precio respecto al "
"precio del activo subyacente, y es el mismo para calls y puts.)\n"
"\n"
"@tiempo es el tiempo para el vencimiento de la opción expresado en años\n"
"@tasa es la tasa de interés libre de riesgo a fecha del ejercicio, en tanto "
"por ciento.\n"
"@volatilidad es la volatilidad anualizada, en porcentaje, del activo o el "
"periodo hasta la fecha del ejercicio.\n"
"@devaluación es la pérdida de valor del activo subyacente,para stock "
"comunes, esto debería ser el margen (yield) del dividendo\n"
"* El valor devuelto será expresado en las mismas unidades que @strike y "
"@spot.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_VEGA"

# Easy fix
#: ../plugins/derivatives/options.c:428
msgid ""
"@FUNCTION=OPT_BS_THETA\n"
"@SYNTAX=OPT_BS_THETA(call_put_flag,spot,strike,time,rate,volatility[,"
"cost_of_carry])\n"
"@DESCRIPTION=OPT_BS_THETA uses the Black-Scholes model to calculate the "
"'theta' of a European option with call_put_flag, @call_put_flag struck at "
"@strike on an asset with spot price @spot.\n"
"\n"
"(The theta of an option is the rate of change of its price with respect to "
"time to expiry.)\n"
"\n"
"@time is the time to maturity of the option expressed in years\n"
"and @rate is the risk-free interest rate to the exercise date, in percent.\n"
"@volatility is the annualized volatility, in percent, of the asset for the "
"period through to the exercise date.\n"
"@cost_of_carry is the leakage in value of the underlying asset, for common "
"stocks, this would be the dividend yield.\n"
"* The returned value will be expressed as minus the rate of change of option "
"value, per 365.25 days.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_VEGA, OPT_BS_GAMMA"
msgstr ""
"@FUNCTION=OPT_BS_THETA\n"
"@SYNTAX=OPT_BS_THETA(indicador_call_put,spot,strike,tiempo,tasa,volatilidad[,"
"devaluación])\n"
"@DESCRIPTION=OPT_BS_THETA usa el modelo Black-Scholes para calcular la «teta» "
"de una opción europea con call/put fijada a precio @strike en un activo con "
"precio @spot.\n"
"\n"
"(La «teta» de una opción es la tasa de cambio de su precio respecto al la "
"fecha de expiración.)\n"
"\n"
"@indicador_call_put es «c» o «p» dependiendo de si la opción es «call» o «put»\n"
"@tiempo es el tiempo para el vencimiento de la opción expresado en años\n"
"@tasa es la tasa de interés libre de riesgo a fecha del ejercicio, en tanto "
"por ciento.\n"
"@volatilidad es la volatilidad anualizada, en porcentaje, del activo o el "
"periodo hasta la fecha del ejercicio.\n"
"@devaluación es la pérdida de valor del activo subyacente,para «stocks» "
"comunes, esto debería ser el margen (yield) del dividendo\n"
"\n"
"* El valor devuelto será expresado como menos la tasa de cambio del valor de "
"la opción, por 365,25 días.\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_VEGA, OPT_BS_GAMMA"

#: ../plugins/derivatives/options.c:485
#, no-c-format
msgid ""
"@FUNCTION=OPT_BS_VEGA\n"
"@SYNTAX=OPT_BS_VEGA(spot,strike,time,rate,volatility[,cost_of_carry])\n"
"@DESCRIPTION=OPT_BS_VEGA uses the Black-Scholes model to calculate the "
"'vega' of a European option struck at @strike on an asset with spot price "
"@spot.\n"
"(The vega of an option is the rate of change of its price with respect to "
"volatility, and is the same for calls and puts.)\n"
"@volatility is the annualized volatility, in percent, of the asset for the "
"period through to the exercise date.\n"
" @time is the time to maturity of the option expressed in years.\n"
"@rate is the risk-free interest rate to the exercise date, in percent.\n"
"@cost_of_carry is the leakage in value of the underlying asset, for common "
"stocks, this would be the dividend yield.\n"
"\n"
"* The returned value will be expressed as the rate of change of option "
"value, per 100% volatility.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
msgstr ""
"@FUNCTION=OPT_BS_VEGA\n"
"@SYNTAX=OPT_BS_VEGA(spot,strike,tiempo,tasa,volatilidad[,devaluación])\n"
"@DESCRIPTION=OPT_BS_VEGA usa el modelo Black-Scholes para calcular la «vega» "
"de una opción europea fijada a @strike en un activo con precio @spot.\n"
"\n"
"(La «vega» de una opción es la tasa de cambio de su precio respecto a la "
"volatilidad, y es la misma para calls (compras) y puts. (ventas))\n"
"\n"
"@tiempo es el tiempo para el vencimiento de la opción expresado en años\n"
"@tasa es la tasa de interés libre de riesgo.\n"
"@volatilidad es la volatilidad anualizada, en porcentaje, del activo o el "
"periodo hasta la fecha del ejercicio. \n"
"@devaluación es la pérdida de valor del activo subyacente,para stock "
"comunes, esto debería ser el margen (yield) del dividendo\n"
"\n"
"* El valor devuelto será expresado como la tasa de cambio del valor de la "
"opción, por 100% de volatilidad.\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#: ../plugins/derivatives/options.c:560
#, no-c-format
msgid ""
"@FUNCTION=OPT_BS_RHO\n"
"@SYNTAX=OPT_BS_RHO(call_put_flag,spot,strike,time,rate,volatility[,"
"cost_of_carry])\n"
"@DESCRIPTION=OPT_BS_RHO uses the Black-Scholes model to calculate the 'rho' "
"of a European option with call_put_flag, @call_put_flag struck at @strike on "
"an asset with spot price @spot.\n"
"@call_put_flag is 'c' or 'p' to indicate whether the option is a call or a "
"put.\n"
"\n"
"(The rho of an option is the rate of change of its price with respect to the "
"risk free interest rate.)\n"
"@time is the time to maturity of the option expressed in years.\n"
"@rate is the risk-free interest rate to the exercise date, in percent.\n"
"@cost_of_carry is the leakage in value of the underlying asset, for common "
"stocks, this would be the dividend yield.\n"
"* The returned value will be expressed as the rate of change of option "
"value, per 100% change in @rate.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_THETA, OPT_BS_VEGA, OPT_BS_GAMMA"
msgstr ""
"@FUNCTION=OPT_BS_RHO\n"
"@SYNTAX=OPT_BS_RHO(indicador_call_put,spot,strike,tiempo,tasa,volatilidad[,"
"devaluación])\n"
"@DESCRIPTION=OPT_BS_RHO usa el modelo Black-Scholes para calcular la «ro» de "
"una opción europea con marca call / put, @indicador_call_put fijada a un "
"precio @strike en un activo con precio @spot.\n"
"@indicador_call_put es «c» o «p» dependiendo de si la opción es «call» o «put»\n"
"\n"
"(La «ro» de una opción es la tasa de cambio de su precio respecto a la tasa "
"de interés libre de riesgo.)\n"
"\n"
"@tiempo es el tiempo para el vencimiento de la opción expresado en años\n"
"@tasa es la tasa de interés libre de riesgo a la fecha del ejercicio, en "
"tanto por ciento.\n"
"@volatilidad es la volatilidad anualizada, en porcentaje, del activo o el "
"periodo hasta la fecha del ejercicio. \n"
"@devaluación es la pérdida de valor del activo subyacente,para stocks "
"comunes, esto debería ser el margen (yield) del dividendo\n"
"\n"
"* El valor devuelto será expresado como la tasa de cambio del valor de la "
"opción, por el 100% de cambio en @tasa.\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_THETA, OPT_BS_VEGA, OPT_BS_GAMMA"

#: ../plugins/derivatives/options.c:628
#, no-c-format
msgid ""
"@FUNCTION=OPT_BS_CARRYCOST\n"
"@SYNTAX=OPT_BS_CARRYCOST(call_put_flag,spot,strike,time,rate,volatility[,"
"cost_of_carry])\n"
"@DESCRIPTION=OPT_BS_CARRYCOST uses the Black-Scholes model to calculate the "
"'elasticity' of a European option struck at @strike on an asset with spot "
"price @spot.\n"
"@call_put_flag is 'c' or 'p' to indicate whether the option is a call or a "
"put.\n"
"\n"
"(The elasticity of an option is the rate of change of its price with respect "
"to its cost of carry.)\n"
"\n"
"@volatility is the annualized volatility, in percent, of the asset for the "
"period through to the exercise date.  @time is the time to maturity of the "
"option expressed in years.\n"
"@rate is the risk-free interest rate to the exercise date, in percent.\n"
"@cost_of_carry is the leakage in value of the underlying asset, for common "
"stocks, this would be the dividend yield.\n"
"\n"
"* The returned value will be expressed as the rate of change of option "
"value, per 100% volatility.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
msgstr ""
"@FUNCTION=OPT_BS_CARRYCOST\n"
"@SYNTAX=OPT_BS_CARRYCOST(indicador_call_put,spot,strike,tiempo,tasa,"
"volatilidad[,devaluación])\n"
"@DESCRIPTION=OPT_BS_CARRYCOST usa el modelo Black-Scholes para calcular "
"la«elasticidad» de una opción europea fijada a @strike en un activo con "
"precio @spot.\n"
"\n"
"(La elasticidad de una opción es la tasa de cambio de su precio respecto a "
"su coste de ejecución.)\n"
"\n"
"@indicador_call_put es «c» o «p» dependiendo de si la opción es «call» o «put»\n"
"@tiempo es el tiempo para el vencimiento de la opción expresado en años\n"
"@tasa es la tasa de interés libre de riesgo a la fecha del ejercicio, en "
"tanto por ciento.\n"
"@volatilidad es la volatilidad anualizada, en porcentaje, del activo o el "
"periodo hasta la fecha del ejercicio. \n"
"@devaluación es la pérdida de valor del activo subyacente,para stock "
"comunes, esto debería ser el margen (yield) del dividendo\n"
"\n"
"* El valor devuelto será expresado como la tasa de cambio del valor de la "
"opción, por 100% de volatilidad.\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#: ../plugins/derivatives/options.c:700
#, no-c-format
msgid ""
"@FUNCTION=OPT_GARMAN_KOHLHAGEN\n"
"@SYNTAX=OPT_GARMAN_KOHLHAGEN(call_put_flag,spot,strike,time,domestic_rate,"
"foreign_rate,volatility[,cost_of_carry])\n"
"@DESCRIPTION=OPT_GARMAN_KOHLHAGEN values the theoretical price of a European "
"currency option struck at @strike on an asset with spot price @spot.\n"
"@call_put_flag is 'c' or 'p' to indicate whether the option is a call or a "
"put.\n"
"@volatility is the annualized volatility, in percent, of the asset for the "
"period through to the exercise date. \n"
"@time the number of days to exercise.\n"
"@domestic_rate is the domestic risk-free interest rate to the exercise "
"date.\n"
"@foreign_rate is the foreign risk-free interest rate to the exercise date, "
"in percent.\n"
"@cost_of_carry is the leakage in value of the underlying asset, for common "
"stocks, this would be the dividend yield.\n"
"* The returned value will be expressed as the rate of change of option "
"value, per 100% volatility.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
msgstr ""
"@FUNCTION=OPT_GARMAN_KOHLHAGEN\n"
"@SYNTAX=OPT_GARMAN_KOHLHAGEN(indicador_call_put,spot,strike,tiempo,"
"tasa_nacional,tasa_extranjera,volatilidad[,devaluación])\n"
"@DESCRIPTION=OPT_GARMAN_KOHLHAGEN valora el precio teórico de una opción "
"sobre divisas europeas fijada a @strike en un activo con precio @spot.\n"
"\n"
"@indicador_call_put es «c» o «p» dependiendo de si la opción es «call» o «put»\n"
"@tiempo es el tiempo para el vencimiento de la opción expresado en años\n"
"@volatilidad es la volatilidad anualizada, en porcentaje, del activo o el "
"período hasta la fecha del ejercicio. \n"
"@tasa_nacional es la tasa de interés nacional libre de riesgo a fecha del "
"ejercicio \n"
"@tasa_extranjera es la tasa de interés extranjera libre de riesgo a fecha "
"del ejercicio\n"
"@devaluación es la pérdida de valor del activo subyacente,para stock "
"comunes, esto debería ser el margen (yield) del dividendo\n"
"\n"
"* El valor devuelto estará expresado como tasa de cambio del valor de la "
"opción, por 100% de volatilidad.\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#: ../plugins/derivatives/options.c:771
#, no-c-format
msgid ""
"@FUNCTION=OPT_FRENCH\n"
"@SYNTAX=OPT_FRENCH(call_put_flag,spot,strike,time,t2,rate,volatility[,"
"cost_of_carry])\n"
"@DESCRIPTION=OPT_FRENCH values the theoretical price of a European option "
"adjusted for trading day volatility, struck at @strike on an asset with spot "
"price @spot.\n"
"@call_put_flag is 'c' or 'p' to indicate whether the option is a call or a "
"put.\n"
"@volatility is the annualized volatility, in percent, of the asset for the "
"period through to the exercise date.\n"
" @time the number of calendar days to exercise divided by calendar days in "
"the year.\n"
"@t2 is the number of trading days to exercise divided by trading days in the "
"year.\n"
"@rate is the risk-free interest rate.\n"
"@cost_of_carry is the leakage in value of the underlying asset, to the "
"exercise date, in percent.\n"
"For common stocks, this would be the dividend yield.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
msgstr ""
"@FUNCTION=OPT_FRENCH\n"
"@SYNTAX=OPT_FRENCH(indicador_call_put,spot,strike,tiempo,t2,tasa,volatilidad"
"[,devaluación])\n"
"@DESCRIPTION=OPT_FRENCH valora el precio teórico de una opción europea "
"ajustada a la volatilidad del día de la transacción, fijada a @strike en un "
"activo con precio @spot.\n"
"\n"
"@indicador_call_put es «c» o «p» dependiendo de si la opción es «call» o «put»\n"
"@volatilidad es la volatilidad anualizada, en porcentaje, del activo o el "
"periodo hasta la fecha del ejercicio. \n"
"@tiempo es el número de días de calendario para el ejercicio dividido entre "
"el número de días de calendario del año.\n"
"@t2 es el número de días comerciales para el ejercicio divididos entre el "
"número de días comerciales en el año\n"
"@tasa es la tasa de interés libre de riesgo a la fecha del ejercicio, en "
"tanto por ciento.\n"
"@devaluación es la pérdida de valor del activo subyacente,para stock "
"comunes, esto debería ser el margen (yield) del dividendo a fecha del "
"ejercicio, en tanto por ciento\n"
"Para stocks comunes, esto debería ser el margen de dividendo.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#: ../plugins/derivatives/options.c:835
#, no-c-format
msgid ""
"@FUNCTION=OPT_JUMP_DIFF\n"
"@SYNTAX=OPT_JUMP_DIFF(call_put_flag,spot,strike,time,rate,volatility,lambda,"
"gamma)\n"
"@DESCRIPTION=OPT_JUMP_DIFF models the theoretical price of an option "
"according to the Jump Diffusion process (Merton).\n"
"@call_put_flag is 'c' or 'p' to indicate whether the option is a call or a "
"put.\n"
"@spot is the spot price of the underlying asset.\n"
"@strike is the strike price of the option.\n"
"@time is the time to maturity of the option expressed in years.\n"
"@rate is the annualized rate of interest.\n"
"@volatility is the annualized volatility of the underlying asset.\n"
"@lambda is expected number of 'jumps' per year.\n"
"@gamma is proportion of volatility explained by the 'jumps.'\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
msgstr ""
"@FUNCTION=OPT_JUMP_DIFF\n"
"@SYNTAX=OPT_JUMP_DIFF(indicador_call_put,spot,strike,tiempo,tasa,volatilidad,"
"lambda,gamma)\n"
"@DESCRIPTION=OPT_JUMP_DIFF modeliza el precio teórico de una opción de "
"acuerdo con el proceso de Difusión de Saltos (Merton).\n"
"\n"
"@indicador_call_put es «c» o «p» dependiendo de si la opción es «call» o «put»\n"
"@spot es el precio spot del activo\n"
"@strike es el precio strike (fijado) de la opción\n"
"@tiempo es el tiempo para el vencimiento de la opción expresado en años\n"
"@tasa es la tasa de interés libre de riesgo a la fecha del ejercicio, en "
"tanto por ciento.\n"
"@volatilidad es la volatilidad anualizada, en porcentaje, del activo hasta "
"la fecha del ejercicio. \n"
"@lambda es el número de «saltos» esperados por año\n"
"@gamma es la proporción de volatilidad explicada por los «saltos»'\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#: ../plugins/derivatives/options.c:934
#, no-c-format
msgid ""
"@FUNCTION=OPT_MILTERSEN_SCHWARTZ\n"
"@SYNTAX=OPT_MILTERSEN_SCHWARTZ(call_put_flag,p_t,f_t,x,t1,t2,v_s,v_e,v_f,"
"rho_se,rho_sf,rho_ef,kappa_e,kappa_f)\n"
"@DESCRIPTION=OPT_MILTERSEN_SCHWARTZ models the theoretical price of options "
"on commodities futures according to Miltersen & Schwartz. \n"
"@call_put_flag is 'c' or 'p' to indicate whether the option is a call or a "
"put.\n"
"@p_t is a zero coupon bond with expiry at option maturity.\n"
"@f_t is the futures price.\n"
"@x is the strike price.\n"
"@t1 is the time to maturity of the option.\n"
"@t2 is the time to maturity of the underlying commodity futures contract.\n"
"@v_s is the volatility of the spot commodity price.\n"
"@v_e is the volatility of the future convenience yield.\n"
"@v_f is the volatility of the forward rate of interest.\n"
"@rho_se is correlation between the spot commodity price and the convenience "
"yield.\n"
"@rho_sf is correlation between the spot commodity price and the forward "
"interest rate.\n"
"@rho_ef is correlation between the forward interest rate and the convenience "
"yield.\n"
"@kappa_e is the speed of mean reversion of the convenience yield.\n"
"@kappa_f is the speed of mean reversion of the forward interest rate.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
msgstr ""
"@FUNCTION=OPT_MILTERSEN_SCHWARTZ\n"
"@SYNTAX=OPT_MILTERSEN_SCHWARTZ(indicador_call_put,p_t,f_t,x,t1,t2,v_s,v_e,"
"v_f,ro_se,ro_sf,ro_ef,kappa_e,kappa_f)\n"
"@DESCRIPTION=OPT_MILTERSEN_SCHWARTZ modela el precio teórico de opciones en "
"futuros en mercancías de acuerdo con Miltersen & Schwartz. \n"
"@indicador_call_put es «c» o «p» dependiendo de si la opción es «call» o «put»\n"
"@p_t en un bono de cupón cero con expiración al vencimiento de la opción\n"
"@f_t es el precio del futuro.\n"
"@x es el precio fijado (strike).\n"
"@t1 es el tiempo para el vencimiento de la opción.\n"
"@t2 es el tiempo para el vencimiento del contrato de los futuros de "
"mercancías subyacentes.\n"
"@v_s es la volatilidad del precio spot de la mercancía.\n"
"@v_e es la volatilidad del margen del futuro convenido.\n"
"@v_f es la volatilidad de la tasa de interés adelantada.\n"
"@ro_se es la correlación entre el precio spot de la mercancía y el margen de "
"conveniencia.\n"
"@rho_sf es la correlación entre el precio spot de la mercancía y la tasa de "
"interés adelantada.\n"
"@rho_ef es la correlación entre la tasa de interés adelantada y el margen de "
"conveniencia.\n"
"@kappa_e es la velocidad de la reversión media del margen de conveniencia.\n"
"@kappa_f es la velocidad de la reversión media de la tasa de interés "
"adelantada.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#: ../plugins/derivatives/options.c:1050
#, no-c-format
msgid ""
"@FUNCTION=OPT_RGW\n"
"@SYNTAX=OPT_RGW(spot,strike,t1,t2,rate,d,volatility)\n"
"@DESCRIPTION=OPT_RGW models the theoretical price of an american option "
"according to the Roll-Geske-Whaley approximation where: \n"
"@spot is the spot price of the underlying asset.\n"
"@strike is the strike price at which the option is struck.\n"
"@t1 is the time to the dividend payout.\n"
"@t2 is the time to option expiration.\n"
"@rate is the annualized rate of interest.\n"
"@d is the amount of the dividend to be paid expressed in currency.\n"
"@volatility is the annualized rate of volatility of the underlying asset.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
msgstr ""
"@FUNCTION=OPT_RGW\n"
"@SYNTAX=OPT_RGW(spot,strike,t1,t2,tasa,d,volatilidad)\n"
"@DESCRIPTION=OPT_RGW modela el precio teórico de una opción americana de "
"acuerdo con la aproximación Roll-Geske-Whaley donde:\n"
"\n"
"@spot es el precio spot del activo\n"
"@strike es el precio strike (fijado) de la opción\n"
"@t1 es el tiempo para el pago de dividendo\n"
"@t2 es el tiempo para el vencimiento de la opción\n"
"@tasa es la tasa de interés anualizada\n"
"@d es la cantidad del dividendo a ser pagada\n"
"@volatilidad es la volatilidad anualizada, en porcentaje, del activo hasta "
"la fecha del ejercicio.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#: ../plugins/derivatives/options.c:1106
#, no-c-format
msgid ""
"@FUNCTION=OPT_BAW_AMER\n"
"@SYNTAX=OPT_BAW_AMER(call_put_flag,spot,strike,time,rate,cost_of_carry,"
"volatility)\n"
"@DESCRIPTION=OPT_BAW_AMER models the theoretical price of an option "
"according to the Barone Adesie & Whaley approximation. \n"
"@call_put_flag is 'c' or 'p' to indicate whether the option is a call or a "
"put.\n"
"@spot is the spot price of the underlying asset.\n"
"@strike is the strike price at which the option is struck.\n"
"@time is the number of days to maturity of the option.\n"
"@rate is the annualized risk-free rate of interest.\n"
"@cost_of_carry is the leakage in value of the underlying asset, for common "
"stocks, this would be the dividend yield.\n"
"@volatility is the annualized volatility in price of the underlying asset.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
msgstr ""
"@FUNCTION=OPT_BAW_AMER\n"
"@SYNTAX=OPT_BAW_AMER(indicador_call_put,spot,strike,tiempo,tasa,devaluación,"
"volatilidad)\n"
"@DESCRIPTION=OPT_BAW_AMER modela el precio teórico de una opción de acuerdo "
"con la aproximación de Barone Adesie & Whaley. \n"
"\n"
"@indicador_call_put es «c» o «p» para indicar si la opción es un «call» o "
"«put».\n"
"@spot es el precio «spot» del activo subyacente.\n"
"@strike es el precio al que se fija la opción.\n"
"@tiempo es el número de días hasta el vencimiento de la opción.\n"
"@tasa es la tasa de interés libre de riesgo anualizada.\n"
"@devaluación es la pérdida de valor del activo subyacente, para «stocks» "
"comunes, esto debería ser el margen (yield) del dividendo.\n"
"@volatilidad es la volatilidad anualizada en precio del activo subyacente.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#: ../plugins/derivatives/options.c:1292
#, no-c-format
msgid ""
"@FUNCTION=OPT_BJER_STENS\n"
"@SYNTAX=OPT_BJER_STENS(call_put_flag,spot,strike,time,rate,volatility[,"
"cost_of_carry])\n"
"@DESCRIPTION=OPT_BJER_STENS models the theoretical price of american options "
"according to the Bjerksund & Stensland approximation technique.\n"
"@call_put_flag is 'c' or 'p' to indicate whether the option is a call or a "
"put.\n"
"@spot is the spot price of the underlying asset.\n"
"@strike is the strike price at which the option is struck.\n"
"@time is the number of days to maturity of the option.\n"
"@rate is the annualized risk-free rate of interest.\n"
"@volatility is the annualized volatility in price of the underlying asset.\n"
"@cost_of_carry is the leakage in value of the underlying asset, for common "
"stocks, this would be the dividend yield.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
msgstr ""
"@FUNCTION=OPT_BJER_STENS\n"
"@SYNTAX=OPT_BJER_STENS(indicador_call_put,spot,strike,tiempo,tasa,volatilidad"
"[,devaluación])\n"
"@DESCRIPTION=OPT_BJER_STENS modela el precio teórico de opciones americanas "
"de acuerdo con la técnica de aproximación de Bjerksund & Stensland.\n"
"\n"
"@indicador_call_put es «c» o «p» para indicar si la opción es «call» o «put».\n"
"@spot es el precio «spot» del activo subyacente.\n"
"@strike es el precio al que se fija la opción.\n"
"@tiempo es el número de días para el vencimiento de la opción.\n"
"@tasa es la tasa de interés libre de riesgo anualizada.\n"
"@volatilidad es la volatilidad anualizada en precio del activo subyacente.\n"
"@devaluación es la pérdida de valor del activo subyacente, para «stocks» "
"comunes, esto debería ser el margen (yield) del dividendo\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#: ../plugins/derivatives/options.c:1379
#, no-c-format
msgid ""
"@FUNCTION=OPT_EXEC\n"
"@SYNTAX=OPT_EXEC(call_put_flag,spot,strike,time,rate,volatility,"
"cost_of_carry,lambda)\n"
"@DESCRIPTION=OPT_EXEC models the theoretical price of executive stock "
"options @call_put_flag is 'c' or 'p' to indicate whether the option is a "
"call or a put.\n"
"One would expect this to always be a call option.\n"
"@spot is the spot price of the underlying asset.\n"
"@strike is the strike price at which the option is struck.\n"
"@time is the number of days to maturity of the option.\n"
"@rate is the annualized risk-free rate of interest.\n"
"@volatility is the annualized volatility in price of the underlying asset.\n"
"@cost_of_carry is the leakage in value of the underlying asset, for common "
"stocks, this would be the dividend yield.\n"
"@lambda is the jump rate for executives. The model assumes executives "
"forfeit their options if they leave the company.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
msgstr ""
"@FUNCTION=OPT_EXEC\n"
"@SYNTAX=OPT_EXEC(indicador_call_put,spot,strike,tiempo,tasa,volatilidad,"
"devaluación,lambda)\n"
"@DESCRIPTION=OPT_EXEC modela el precio teórico de opciones de stock para "
"ejecutivos (executive stock options).\n"
"\n"
"@indicador_call_put es «c» o «p» para indicar si la opción es «call» o «put» . "
"Uno podría esperar que esto sea siempre una opción call.\n"
"@spot es el precio «spot» del activo subyacente.\n"
"@strike es el precio al que se fija la opción.\n"
"@tiempo es el número de días para el vencimiento de la opción.\n"
"@tasa es la tasa de interés libre de riesgo anualizada.\n"
"@volatilidad es la volatilidad anualizada en precio del activo subyacente.\n"
"@devaluación es la pérdida de valor del activo subyacente, para «stocks» "
"comunes, esto debería ser el margen (yield) del dividendo.\n"
"@lambda es la tasa de salto para ejecutivas. El modelo asume que los "
"ejecutivos pierden los derechos a sus opciones si dejan la compañía.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#: ../plugins/derivatives/options.c:1430
#, no-c-format
msgid ""
"@FUNCTION=OPT_FORWARD_START\n"
"@SYNTAX=OPT_FORWARD_START(call_put_flag,spot,alpha,time1,time,rate,"
"volatility,cost_of_carry)\n"
"@DESCRIPTION=OPT_FORWARD_START models the theoretical price of forward start "
"options\n"
" @call_put_flag is 'c' or 'p' to indicate whether the option is a call or a "
"put.\n"
"@spot is the spot price of the underlying asset.\n"
"@alpha is a fraction that set the strike price the future date @time1.\n"
"@time1 is the number of days until the option starts.\n"
"@time is the number of days to maturity of the option.\n"
"@rate is the annualized risk-free rate of interest.\n"
"@volatility is the annualized volatility in price of the underlying asset.\n"
"@cost_of_carry is the leakage in value of the underlying asset, for common "
"stocks, this would be the dividend yield.\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
msgstr ""
"@FUNCTION=OPT_FORWARD_START\n"
"@SYNTAX=OPT_FORWARD_START(indicador_call_put,spot,alfa,tiempo1,tiempo,tasa,"
"volatilidad,devaluación)\n"
"@DESCRIPTION=OPT_FORWARD_START modela el precio teórico de opciones «forward "
"start» \n"
"\n"
"@indicador_call_put es «c» o «p» para indicar si la opción es un «call» o «put»\n"
"@spot es el precio «spot» del activo subyacente\n"
"@alfa es una fracción que establece el precio «strike» en la fecha futura "
"@tiempo1\n"
"@tiempo1 es el número de días hasta que la opción comienza.\n"
"@tiempo es el número de días hasta el vencimiento de la opción.\n"
"@tasa es la tasa de interés libre de riesgo anualizada.\n"
"@volatilidad es la volatilidad anualizada en precio del activo subyacente.\n"
"@devaluación es la pérdida de valor del activo subyacente, para «stocks» "
"comunes, esto debería ser el margen (yield) del dividendo\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#: ../plugins/derivatives/options.c:1496
#, no-c-format
msgid ""
"@FUNCTION=OPT_TIME_SWITCH\n"
"@SYNTAX=OPT_TIME_SWITCH(call_put_flag,spot,strike,a,time,m,dt,rate,"
"cost_of_carry,volatility)\n"
"@DESCRIPTION=OPT_TIME_SWITCH models the theoretical price of time switch "
"options. (Pechtl 1995)\n"
"The holder receives @a * @dt for each period dt that the asset price was "
"greater than the strike price (for a call) or below it (for a put). \n"
"@call_put_flag is 'c' or 'p' to indicate whether the option is a call or a "
"put.\n"
"@spot is the spot price of the underlying asset.\n"
"@strike is the strike price at which the option is struck.\n"
"@a is the amount received for each time period as discussed above.\n"
"@time is the maturity of the option in years.\n"
"@m is the number of time units the option has already met the condition.\n"
"@dt is the agreed upon discrete time period (often a day) expressed as a "
"fraction of a year.\n"
"@rate is the annualized risk-free rate of interest.\n"
"@cost_of_carry is the leakage in value of the underlying asset, for common "
"stocks, this would be the dividend yield.\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
msgstr ""
"@FUNCTION=OPT_TIME_SWITCH\n"
"@SYNTAX=OPT_TIME_SWITCH(indicador_call_put,spot,strike,a,tiempo,m,dt,tasa,"
"devaluación,volatilidad)\n"
"@DESCRIPTION=OPT_TIME_SWITCH modela el precio teórico de opciones de cambio "
"de tiempo. (Pechtl 1995)\n"
"\n"
"El poseedor recibe @a * @dt para cada periodo dt que el precio de la acción "
"sea mayor que el precio fijado (para una call) o por debajo de él (para una "
"put) \n"
"\n"
"@indicador_call_put es «c» o «p» para indicar si la opción es un «call» o «put»\n"
"@spot es el precio «spot» del activo subyacente\n"
"@strike es el precio al que la opción se ha fijado\n"
"@a es la cantidad recibida para cada periodo de tiempo como se explicó "
"arriba\n"
"@tiempo es el vencimiento de la opción en años\n"
"@m es el número de unidades de tiempo en que la opción ha encontrado la "
"condición \n"
"@dt es el acuerdo entre periodos de tiempo discretos (a menudo un día) "
"expresados como una fracción de un año \n"
"@tasa es el tasa de interés libre de riesgo anualizada \n"
"@devaluación es la pérdida de valor del activo subyacente, para «stocks» "
"comunes, esto debería ser el margen (yield) del dividendo\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#: ../plugins/derivatives/options.c:1550
#, no-c-format
msgid ""
"@FUNCTION=OPT_SIMPLE_CHOOSER\n"
"@SYNTAX=OPT_SIMPLE_CHOOSER(call_put_flag,spot,strike,time1,time2,rate,"
"cost_of_carry,volatility)\n"
"@DESCRIPTION=OPT_SIMPLE_CHOOSER models the theoretical price of simple "
"chooser options.\n"
"@call_put_flag is 'c' or 'p' to indicate whether the option is a call or a "
"put.\n"
"@spot is the spot price of the underlying asset.\n"
"@strike is the strike price at which the option is struck.\n"
"@time1 is the time in years until the holder chooses a put or a call "
"option.\n"
"@time2 is the time in years until the chosen option expires.\n"
"@rate is the annualized risk-free rate of interest.\n"
"@cost_of_carry is the leakage in value of the underlying asset, for common "
"stocks, this would be the dividend yield.\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
msgstr ""
"@FUNCTION=OPT_SIMPLE_CHOOSER\n"
"@SYNTAX=OPT_SIMPLE_CHOOSER(indicador_call_put,spot,strike,tiempo1,tiempo2,"
"tasa,devaluación,volatilidad)\n"
"@DESCRIPTION=OPT_SIMPLE_CHOOSER modela el precio teórico de opciones de "
"elección simple.\n"
"\n"
"@indicador_call_put es «c» o «p» dependiendo de si la opción es «call» o «put».\n"
"@spot es el precio spot del activo.\n"
"@strike es el precio strike (fijado) de la opción.\n"
"@tiempo1 es el tiempo en años hasta que el titular elige una opción call o "
"put.\n"
"@tiempo2 es el tiempo en años hasta que la opción elegida vence\n"
"@tasa es la tasa de interés libre de riesgo a la fecha del ejercicio, en "
"tanto por ciento.\n"
"@devaluación es la pérdida de valor del activo subyacente, para «stocks» "
"comunes, esto debería ser el margen (yield) del dividendo\n"
"@volatilidad es la volatilidad anualizada en precio del activo subyacente\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#: ../plugins/derivatives/options.c:1613
#, no-c-format
msgid ""
"@FUNCTION=OPT_COMPLEX_CHOOSER\n"
"@SYNTAX=OPT_COMPLEX_CHOOSER(call_put_flag,spot,strike_call,strike_put,time,"
"time_call,time_put,rate,cost_of_carry,volatility)\n"
"@DESCRIPTION=OPT_COMPLEX_CHOOSER models the theoretical price of complex "
"chooser options.\n"
"@call_put_flag is 'c' or 'p' to indicate whether the option is a call or a "
"put.\n"
"@spot is the spot price of the underlying asset.\n"
"@strike_call is the strike price at which the option is struck, applicable "
"if exercised as a call option.\n"
"@strike_put is the strike price at which the option is struck, applicable if "
"exercised as a put option.\n"
"@time is the time in years until the holder chooses a put or a call "
"option. \n"
"@time_call is the time in years to maturity of the call option if chosen.\n"
"@time_put is the time in years  to maturity of the put option if chosen.\n"
"@rate is the annualized risk-free rate of interest.\n"
"@cost_of_carry is the leakage in value of the underlying asset, for common "
"stocks, this would be the dividend yield.\n"
"@volatility is the annualized volatility in price of the underlying asset.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
msgstr ""
"@FUNCTION=OPT_COMPLEX_CHOOSER\n"
"@SYNTAX=OPT_COMPLEX_CHOOSER(indicador_call_put,spot,strike_call,strike_put,"
"tiempo,tiempo_call,tiempo_put,tasa,devaluación,volatilidad)\n"
"@DESCRIPTION=OPT_COMPLEX_CHOOSER modela el precio teórico de opciones de "
"elección complejas.\n"
"\n"
"@indicador_call_put es «c» o «p» dependiendo de si la opción es «call» o «put»\n"
"@spot es el precio spot del activo.\n"
"@strike_call es el precio al que se ha fijado la opción.\n"
"@strike_put es el precio al que se ha fijado la opción.\n"
"@tiempo es es tiempo en años hasta que el titular elija una opción put o "
"call.\n"
"@tiempo_call es el tiempo de vencimiento en años de la opción call si es "
"elegida.\n"
"@tiempo_put es el tiempo de vencimiento en años de la opción put si es "
"elegida.\n"
"@tasa es la tasa de interés libre de riesgo anualizada.\n"
"@devaluación es la pérdida de valor del activo subyacente, para «stocks» "
"comunes, esto debería ser el margen (yield) del dividendo.\n"
"@volatilidad es la volatilidad anualizada en precio del activo subyacente\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#: ../plugins/derivatives/options.c:1730
#, no-c-format
msgid ""
"@FUNCTION=OPT_ON_OPTIONS\n"
"@SYNTAX=OPT_ON_OPTIONS(type_flag,spot,strike1,strike2,time1,time2,rate,"
"cost_of_carry,volatility)\n"
"@DESCRIPTION=OPT_ON_OPTIONS models the theoretical price of options on "
"options.\n"
"@type_flag is 'cc' for calls on calls, 'cp' for calls on puts, and so on for "
"'pc', and 'pp'.\n"
"@spot is the spot price of the underlying asset.\n"
"@strike1 is the strike price at which the option being valued is struck.\n"
"@strike2 is the strike price at which the underlying option is struck.\n"
"@time1 is the time in years to maturity of the option.\n"
"@time2 is the time in years to the maturity of the underlying option.\n"
"(@time2 >= @time1).\n"
"@rate is the annualized risk-free rate of interest.\n"
"@cost_of_carry is the leakage in value of the underlying asset of the "
"underlying option.for common stocks, this would be the dividend yield.\n"
"@volatility is the annualized volatility in price of the underlying asset of "
"the underlying option.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
msgstr ""
"@FUNCTION=OPT_ON_OPTIONS\n"
"@SYNTAX=OPT_ON_OPTIONS(marca_tipo,spot,strike1,strike2,tiempo1,tiempo2,tasa,"
"devaluación,volatilidad)\n"
"@DESCRIPTION=OPT_ON_OPTIONS modela el precio teórico de opciones sobre "
"opciones.\n"
"\n"
"@marca_tipo es «cc» para calls sobre calls, «cp» para calls sobre puts, y lo "
"mismo para «pc» y «pp».\n"
"@spot es el precio spot del activo subyacente.\n"
"@strike1 es el precio strike al que la opción que está siendo evaluada se ha "
"fijado.\n"
"@strike2 es el precio strike al que la opción subyacente está fijada.\n"
"@tiempo1 es es tiempo en años hasta el vencimiento de la opción.\n"
"@tiempo2 es el tiempo en años hasta el vencimiento de la opción subyacente.\n"
"(@tiempo2 >= @tiempo1)\n"
"@tasa es la tasa de interés libre de riesgo anualizada.\n"
"@devaluación es la pérdida de valor del activo subyacente, para «stocks» "
"comunes, esto debería ser el margen (yield) del dividendo.\n"
"@volatilidad es la volatilidad anualizada en precio del activo subyacente\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#: ../plugins/derivatives/options.c:1818
#, no-c-format
msgid ""
"@FUNCTION=OPT_EXTENDIBLE_WRITER\n"
"@SYNTAX=OPT_EXTENDIBLE_WRITER(call_put_flag,spot,strike1,strike2,time1,time2,"
"rate,cost_of_carry,volatility)\n"
"@DESCRIPTION=OPT_EXTENDIBLE_WRITER models the theoretical price of "
"extendible writer options. These are options that can be exercised at an "
"initial period, @time1, or their maturity extended to @time2 if the option "
"is out of the money at @time1.\n"
"@call_put_flag is 'c' or 'p' to indicate whether the option is a call or a "
"put.\n"
"@spot is the spot price of the underlying asset.\n"
"@strike1 is the strike price at which the option is struck.\n"
"@strike2 is the strike price at which the option is re-struck if out of the "
"money at @time1.\n"
"@time1 is the initial maturity of the option in years.\n"
"@time2 is the is the extended maturity in years if chosen.\n"
"@rate is the annualized risk-free rate of interest.\n"
"@cost_of_carry is the leakage in value of the underlying asset, for common "
"stocks, this would be the dividend yield.\n"
"@volatility is the annualized volatility in price of the underlying asset.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
msgstr ""
"@FUNCTION=OPT_EXTENDIBLE_WRITER\n"
"@SYNTAX=OPT_EXTENDIBLE_WRITER(indicador_call_put,spot,strike1,strike2,"
"tiempo1,tiempo2,tasa,costo_de_ejecución,volatilidad)\n"
"@DESCRIPTION=OPT_EXTENDIBLE_WRITER modela el precio teórico de las opciones "
"de escritura extensible. Estas son opciones que pueden ser ejercitadas en un "
"periodo inicial, @tiempo1, o su vencimiento extendido hasta @tiempo2 si la "
"opción agotó el dinero en el @tiempo1 \n"
"\n"
"@indicador_call_put es «c» o «p» dependiendo de si la opción es «call» o «put»\n"
"@spot es el precio spot del activo\n"
"@strike1 es el precio al que se ha fijado la opción\n"
"@strike2 es el precio al que se ha fijado la opción\n"
"@tiempo1 es el tiempo de vencimiento inicial en años\n"
"@tiempo2 es el tiempo de vencimiento extendido si es elegido \n"
"@tasa es la tasa de interés libre de riesgo anualizada.\n"
"@devaluación es la pérdida de valor del activo subyacente, para «stocks» "
"comunes, esto debería ser el margen (yield) del dividendo.\n"
"@volatilidad es la volatilidad anualizada en precio del activo subyacente\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#: ../plugins/derivatives/options.c:1882
#, no-c-format
msgid ""
"@FUNCTION=OPT_2_ASSET_CORRELATION\n"
"@SYNTAX=OPT_2_ASSET_CORRELATION(call_put_flag,spot1,spot2,strike1,strike2,"
"time,cost_of_carry1,cost_of_carry2,rate,volatility1,volatility2,rho)\n"
"@DESCRIPTION=OPT_2_ASSET_CORRELATION models the theoretical price of  "
"options on 2 assets with correlation @rho.\n"
"The payoff for a call is max(@spot2 - @strike2,0) if @spot1 > @strike1 or 0 "
"otherwise.\n"
"The payoff for a put is max (@strike2 - @spot2, 0) if @spot1 < @strike1 or 0 "
"otherwise.\n"
"@call_put_flag is 'c' or 'p' to indicate whether the option is a call or a "
"put.\n"
"@spot1 & @spot2 are the spot prices of the underlying assets.\n"
"@strike1 & @strike2 are the strike prices at which the option is struck.\n"
"@time is the initial maturity of the option in years.\n"
"@rate is the annualized risk-free rate of interest.\n"
"@cost_of_carry1 & @cost_of_carry2 are the leakage in value of the underlying "
"assets, for common stocks, this would be the dividend yield.\n"
"@volatility1 & @volatility2 are the annualized volatility in price of the "
"underlying assets.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
msgstr ""
"@FUNCTION=OPT_2_ASSET_CORRELATION\n"
"@SYNTAX=OPT_2_ASSET_CORRELATION(indicador_call_put,spot1,spot2,strike1,"
"strike2, tiempo,devaluación1,devaluación2,tasa,volatilidad1,volatilidad2,"
"rho)\n"
"@DESCRIPTION=OPT_2_ASSET_CORRELATION modela el precio teórico de opciones en "
"2 activos con correlación @rho.\n"
"\n"
"El @indicador_call_put es «c» o «p» para indicar si la opción es un «call» o "
"«put»\n"
"@spot es el precio «spot» del activo subyacente\n"
"@strike es el precio al que se fija la opción\n"
"@tiempo es el número de días hasta el vencimiento de la opción \n"
"@tasa es la tasa de interés libre de riesgo anualizada \n"
"@devaluación es la pérdida de valor del activo subyacente, para «stocks» "
"comunes, esto debería ser el margen (yield) del dividendo\n"
"@volatilidad es la volatilidad anualizada en precio del activo subyacente \n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#: ../plugins/derivatives/options.c:1939
#, no-c-format
msgid ""
"@FUNCTION=OPT_EURO_EXCHANGE\n"
"@SYNTAX=OPT_EURO_EXCHANGE(spot1,spot2,qty1,qty2,time,rate,cost_of_carry1,"
"cost_of_carry2,volatility1,volatility2,rho)\n"
"@DESCRIPTION=OPT_EURO_EXCHANGE models the theoretical price of a European "
"option to exchange one asset with quantity @qty2 and spot price @spot2 for "
"another, with quantity @qty1 and spot price @spot1.\n"
"@time is the initial maturity of the option in years.\n"
"@rate is the annualized risk-free rate of interest.\n"
"@cost_of_carry1 & @cost_of_carry2 are the leakage in value of the underlying "
"assets, for common stocks, this would be the dividend yield.\n"
"@volatility1 & @volatility2 are the annualized volatility in price of the "
"underlying assets.\n"
"@rho is the correlation between the two assets.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_AMER_EXCHANGE, OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, "
"OPT_BS_GAMMA"
msgstr ""
"@FUNCTION=OPT_EURO_EXCHANGE\n"
"@SYNTAX=OPT_EURO_EXCHANGE(spot1,spot2,cantidad1,cantidad2,tiempo,tasa,"
"devaluación1,coste_ejecución2,volatilidad1,volatilidad2,rho)\n"
"@DESCRIPTION=OPT_EURO_EXCHANGE modela el precio teórico de una opción "
"europea para cambiar una inversión con cantidad @cantidad2 y precio spot "
"@spot2 por otro, con cantidad @cantidad1 y precio spot @spot1. \n"
"\n"
"@tiempo es el número de días hasta el vencimiento de la opción \n"
"@tasa es la tasa de interés libre de riesgo anualizada \n"
"@devaluación1 y @coste_ejecución2 es la pérdida de valor de los activos "
"subyacentes, para «stocks» comunes, esto debería ser el margen (yield) del "
"dividendo\n"
"@volatilidad1 y @volatilidad2 es la volatilidad anualizada en precio del "
"activo subyacente \n"
"@rho es la correlación entre los dos activos.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_AMER_EXCHANGE, OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, "
"OPT_BS_GAMMA"

#: ../plugins/derivatives/options.c:1986
#, no-c-format
msgid ""
"@FUNCTION=OPT_AMER_EXCHANGE\n"
"@SYNTAX=OPT_AMER_EXCHANGE(spot1,spot2,qty1,qty2,time,rate,cost_of_carry1,"
"cost_of_carry2,volatility1, volatility2, rho)\n"
"@DESCRIPTION=OPT_AMER_EXCHANGE models the theoretical price of an American "
"option to exchange one asset with quantity @qty2 and spot price @spot2 for "
"another, with quantity @qty1 and spot price @spot1.\n"
"@time is the initial maturity of the option in years.\n"
"@rate is the annualized risk-free rate of interest.\n"
"@cost_of_carry1 & @cost_of_carry2 are the leakage in value of the underlying "
"assets, for common stocks, this would be the dividend yield.\n"
"@volatility1 & @volatility2 are the annualized volatility in price of the "
"underlying assets.\n"
"@rho is the correlation between the two assets.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_EURO_EXCHANGE, OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, "
"OPT_BS_GAMMA"
msgstr ""
"@FUNCTION=OPT_AMER_EXCHANGE\n"
"@SYNTAX=OPT_AMER_EXCHANGE(spot1,spot2,cant1,cant2,tiempo,tasa,devaluación1,"
"coste_ejecución2,volatilidad,rho)\n"
"@DESCRIPTION=OPT_AMER_EXCHANGE modela el precio teórico de una opción "
"americana para intercambio de un activo con cantidad @cant2 y precio spot "
"@spot2 por otro con cantidad @cant1 y precio spot @spot1\n"
"\n"
"@tiempo es el vencimiento inicial de la opción en años.\n"
"@tasa es la tasa de interés libre de riesgo anualizada \n"
"@devaluación1 y @devaluación2 es la pérdida de valor de los activos "
"subyacentes, para «stocks» comunes, esto debería ser el margen (yield) del "
"dividendo\n"
"@volatilidad1 y @volatilidad2 son la volatilidad anualizada en precio de los "
"activos subyacente \n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_EURO_EXCHANGE, OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, "
"OPT_BS_GAMMA"

#: ../plugins/derivatives/options.c:2031
#, no-c-format
msgid ""
"@FUNCTION=OPT_SPREAD_APPROX\n"
"@SYNTAX=OPT_SPREAD_APPROX(call_put_flag,fut_price1,fut_price2,strike,time, "
"rate,volatility1,volatility2,rho)\n"
"@DESCRIPTION=OPT_SPREAD_APPROX models the theoretical price of a European "
"option on the spread between two futures contracts.\n"
"@call_put_flag is 'c' or 'p' to indicate whether the option is a call or a "
"put.\n"
"@fut_price1 & @fut_price2 are the prices of the two futures contracts.\n"
"@strike is the strike price at which the option is struck \n"
"@time is the initial maturity of the option in years.\n"
"@rate is the annualized risk-free rate of interest.\n"
"@volatility1 & @volatility2 are the annualized volatility in price of the "
"underlying futures contracts.\n"
"@rho is the correlation between the two futures contracts.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
msgstr ""
"@FUNCTION=OPT_SPREAD_APPROX\n"
"@SYNTAX=OPT_SPREAD_APPROX(indicador_call_put,fut_price1,fut_price2,strike,"
"tiempo, tasa,volatilidad1,volatilidad2,rho)\n"
"@DESCRIPTION=OPT_SPREAD_APPROX modela el precio teórico de una opción "
"europea en la difusión entre dos contratos futuros.\n"
"\n"
"@indicador_call_put es «c» o «p» para indicar si la opción es «call» o «put» \n"
"@fut_price1 y 2fut_price2 son los frecios de los dos futuros.\n"
"@strike es el precio al que se fija la opción\n"
"@tiempo es el número de días para el vencimiento de la opción\n"
"@tasa es la tasa de interés libre de riesgo anualizada \n"
"@volatilidad1 y @volatilidad2 es la volatilidad anualizada en precio del los "
"futuros subyacentes \n"
"@rho es la correlación entre los dos futuros\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#: ../plugins/derivatives/options.c:2093
#, no-c-format
msgid ""
"@FUNCTION=OPT_FLOAT_STRK_LKBK\n"
"@SYNTAX=OPT_FLOAT_STRK_LKBK(call_put_flag,spot,spot_min,spot_max,time,rate,"
"cost_of_carry,volatility)\n"
"@DESCRIPTION=OPT_FLOAT_STRK_LKBK models the theoretical price of an option "
"where the holder of the option may exercise on expiry at the most favourable "
"price observed during the options life of the underlying asset.\n"
"@call_put_flag is 'c' or 'p' to indicate whether the option is a call or a "
"put.\n"
"@spot is the spot price of the underlying asset.\n"
"@spot_min is the minimum spot price of the underlying asset so far "
"observed.\n"
"@spot_max is the maximum spot price of the underlying asset so far "
"observed.\n"
"@time is the initial maturity of the option in years.\n"
"@rate is the annualized risk-free rate of interest.\n"
"@cost_of_carry is the leakage in value of the underlying asset, for common "
"stocks, this would be the dividend yield.\n"
"@volatility is the annualized volatility in price of the underlying asset.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
msgstr ""
"@FUNCTION=OPT_FLOAT_STRK_LKBK\n"
"@SYNTAX=OPT_FLOAT_STRK_LKBK(indicador_call_put,spot,spot_min,spot_max,tiempo,"
"tasa,devaluación,volatilidad)\n"
"@DESCRIPTION=OPT_FLOAT_STRK_LKBK modela el precio teórico de una opción "
"donde el propietario de la opción puede ejercitar al expirar al precio más "
"favorable observado durante la vida de la opción del activo subyacente.\n"
"\n"
"@indicador_call_put es «c» o «p» para indicar si la opción es un «call» o «put»\n"
"@spot_min es el mínimo precio «spot» del activo subyacente observado a lo "
"largo del tiempo.\n"
"@spot_max es el máximo precio «spot» del activo subyacente observado a lo "
"largo del tiempo.\n"
"@strike es el precio al que se fija la opción\n"
"@tiempo es número de años hasta el vencimiento de la opción.\n"
"@tasa es la tasa de interés libre de riesgo anualizada. \n"
"@devaluación es la pérdida de valor del activo subyacente, para «stocks» "
"comunes, esto debería ser el margen (yield) del dividendo\n"
"@volatilidad es la volatilidad anualizada en precio del activo subyacente \n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#: ../plugins/derivatives/options.c:2163
#, no-c-format
msgid ""
"@FUNCTION=OPT_FIXED_STRK_LKBK\n"
"@SYNTAX=OPT_FIXED_STRK_LKBK(call_put_flag,spot,spot_min,spot_max,strike,time,"
"rate,cost_of_carry,volatility)\n"
"@DESCRIPTION=OPT_FIXED_STRK_LKBK models the theoretical price of an option "
"where the holder of the option may exercise on expiry at the most favourable "
"price observed during the options life of the underlying asset.\n"
"@call_put_flag is 'c' or 'p' to indicate whether the option is a call or a "
"put.\n"
"@spot is the spot price of the underlying asset.\n"
"@spot_min is the minimum spot price of the underlying asset so far "
"observed.\n"
"@spot_max is the maximum spot price of the underlying asset so far "
"observed.\n"
"@strike is the strike prices at which the option is struck.\n"
"@time is the initial maturity of the option in years.\n"
"@rate is the annualized risk-free rate of interest.\n"
"@cost_of_carry is the leakage in value of the underlying asset, for common "
"stocks, this would be the dividend yield.\n"
"@volatility is the annualized volatility in price of the underlying asset.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
msgstr ""
"@FUNCTION=OPT_FIXED_STRK_LKBK\n"
"@SYNTAX=OPT_FIXED_STRK_LKBK(indicador_call_put,spot,spot_min,spot_max,strike,"
"tiempo,tasa,devaluación,volatilidad)\n"
"@DESCRIPTION=OPT_FIXED_STRK_LKBK modela el precio teórico de una opción "
"donde el propietario de la opción puede ejercitar al expirar al precio más "
"favorable observado durante la vida de la opción del activo subyacente. \n"
"\n"
"@indicador_call_put es «c» o «p» para indicar si la opción es un «call» o «put»\n"
"@spot_min es el mínimo precio «spot» del activo subyacente observado a lo "
"largo del tiempo.\n"
"@spot_max es el máximo precio «spot» del activo subyacente observado a lo "
"largo del tiempo.\n"
"@strike es el precio al que se fija la opción\n"
"@tiempo es número de años hasta el vencimiento de la opción.\n"
"@tasa es la tasa de interés libre de riesgo anualizada. \n"
"@devaluación es la pérdida de valor del activo subyacente, para «stocks» "
"comunes, esto debería ser el margen (yield) del dividendo\n"
"@volatilidad es la volatilidad anualizada en precio del activo subyacente \n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#: ../plugins/derivatives/options.c:2253
#, no-c-format
msgid ""
"@FUNCTION=OPT_BINOMIAL\n"
"@SYNTAX=OPT_BINOMIAL(amer_euro_flag,call_put_flag,num_time_steps, spot, "
"strike, time, rate, volatility, cost_of_carry)\n"
"@DESCRIPTION=OPT_ models the theoretical price of either an American or "
"European style option using a binomial tree.\n"
"@amer_euro_flag is either 'a' or 'e' to indicate whether the option being "
"valued is an American or European style option respectively.\n"
"@call_put_flag is 'c' or 'p' to indicate whether the option is a call or a "
"put.\n"
"@num_time_steps is the number of time steps used in the valuation, a greater "
"number of time steps yields greater accuracy however is slower to "
"calculate.\n"
"@spot is the spot price of the underlying asset.\n"
"@strike is the strike price at which the option is struck.\n"
"@time is the initial maturity of the option in years.\n"
"@rate is the annualized risk-free rate of interest.\n"
"@volatility is the annualized volatility in price of the underlying asset.\n"
"@cost_of_carry is the leakage in value of the underlying asset.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"
msgstr ""
"@FUNCTION=OPT_BINOMIAL\n"
"@SYNTAX=OPT_BINOMIAL(indicador_amer_euro,indicador_call_put,"
"num_tiempo_steps, spot, strike, tiempo, tasa, volatilidad, devaluación)\n"
"@DESCRIPTION=OPT_BINOMIAL modela el precio teórico de opciones al estilo "
"americano o europeo usando un árbol binomial.\n"
"\n"
"@indicador_amer_euro es o «a» o «e» para indicar si la opción se va a evaluar "
"como una opción de estilo americano o europeo respectivamente\n"
"@indicador_call_put es «c» o «p» para indicar si la opción es «call» o «put» \n"
"@spot es el precio «spot» del activo subyacente\n"
"@strike es el precio al que se fija la opción\n"
"@tiempo es el número de días para el vencimiento de la opción\n"
"@tasa es la tasa de interés libre de riesgo anualizada \n"
"@volatilidad es la volatilidad anualizada en precio del activo subyacente \n"
"@devaluación es la pérdida de valor del activo subyacente, para «stocks» "
"comunes, esto debería ser el margen (yield) del dividendo\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=OPT_BS, OPT_BS_DELTA, OPT_BS_RHO, OPT_BS_THETA, OPT_BS_GAMMA"

#: ../plugins/fn-complex/functions.c:80
msgid ""
"@FUNCTION=COMPLEX\n"
"@SYNTAX=COMPLEX(real,im[,suffix])\n"
"@DESCRIPTION=COMPLEX returns a complex number of the form x + yi.\n"
"\n"
"@real is the real and @im is the imaginary part of the complex number.  "
"@suffix is the suffix for the imaginary part.  If it is omitted, COMPLEX "
"uses 'i' by default.\n"
"\n"
"* If @suffix is neither 'i' nor 'j', COMPLEX returns #VALUE! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"COMPLEX(1,-1) equals 1-i.\n"
"\n"
"@SEEALSO="
msgstr ""
"@FUNCTION=COMPLEX\n"
"@SYNTAX=COMPLEX(real,im[,sufijo])\n"
"@DESCRIPTION=COMPLEX devuelve el número complejo de la forma x + yi.\n"
"\n"
"@real es la parte real e @im es la parte imaginaria del número complejo. "
"@sufijo es el sufijo para la parte imaginaria, si es omitido, COMPLEX emplea "
"'i'.\n"
"\n"
"* Si @sufijo no es 'i' ni 'j', entonces COMPLEX devuelve el error #VALOR!.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"COMPLEX(1,-1) es igual a 1-i.\n"
"\n"
"@SEEALSO="

#: ../plugins/fn-complex/functions.c:122
msgid ""
"@FUNCTION=IMAGINARY\n"
"@SYNTAX=IMAGINARY(inumber)\n"
"@DESCRIPTION=IMAGINARY returns the imaginary part of a complex number.\n"
"\n"
"* If @inumber is not a valid complex number, IMAGINARY returns #VALUE! "
"error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"IMAGINARY(\"132-j\") equals -1.\n"
"\n"
"@SEEALSO=IMREAL"
msgstr ""
"@FUNCTION=IMAGINARY\n"
"@SYNTAX=IMAGINARY(inum)\n"
"@DESCRIPTION=IMAGINARY devuelve la parte imaginaria de un número complejo.\n"
"\n"
"* Si @inum no es un número complejo válido, IMAGINARY devuelve el error "
"#VALOR!.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"IMAGINARY(\"132-j\") es igual a -1.\n"
"\n"
"@SEEALSO=IMREAL"

#: ../plugins/fn-complex/functions.c:158
msgid ""
"@FUNCTION=IMABS\n"
"@SYNTAX=IMABS(inumber)\n"
"@DESCRIPTION=IMABS returns the absolute value of a complex number.\n"
"\n"
"* If @inumber is not a valid complex number, IMABS returns #VALUE! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"IMABS(\"2-j\") equals 2.23606798.\n"
"\n"
"@SEEALSO=IMAGINARY,IMREAL"
msgstr ""
"@FUNCTION=IMABS\n"
"@SYNTAX=IMABS(inum)\n"
"@DESCRIPTION=Devuelve el valor absoluto de un número complejo.\n"
"\n"
"* Si @inum no es un número complejo válido, IMABS devuelve el error "
"#VALOR!.\n"
"* Esta función es compatible con Excel. \n"
"@EXAMPLES=\n"
"IMABS(\"2-j\") es igual a 2,23606798.\n"
"\n"
"@SEEALSO=IMAGINARY,IMREAL"

#: ../plugins/fn-complex/functions.c:191
msgid ""
"@FUNCTION=IMREAL\n"
"@SYNTAX=IMREAL(inumber)\n"
"@DESCRIPTION=IMREAL returns the real part of a complex number.\n"
"\n"
"* If @inumber is not a valid complex number, IMREAL returns #VALUE! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"imreal(\"132-j\") equals 132.\n"
"\n"
"@SEEALSO=IMAGINARY"
msgstr ""
"@FUNCTION=IMREAL\n"
"@SYNTAX=IMREAL(inum)\n"
"@DESCRIPTION=IMREAL devuelve la parte real de un número complejo.\n"
"\n"
"* Si @inum no es un número complejo válido, IMREAL devuelve el error "
"#VALOR!.\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"IMREAL(\"132-j\") es igual a 132.\n"
"\n"
"@SEEALSO=IMAGINARY"

#: ../plugins/fn-complex/functions.c:227
msgid ""
"@FUNCTION=IMCONJUGATE\n"
"@SYNTAX=IMCONJUGATE(inumber)\n"
"@DESCRIPTION=IMCONJUGATE returns the complex conjugate of a complex number.\n"
"\n"
"* If @inumber is not a valid complex number, IMCONJUGATE returns #VALUE! "
"error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"IMCONJUGATE(\"1-j\") equals 1+j.\n"
"\n"
"@SEEALSO=IMAGINARY,IMREAL"
msgstr ""
"@FUNCTION=IMCONJUGATE\n"
"@SYNTAX=IMCONJUGATE(inum)\n"
"@DESCRIPTION=Devuelve el conjugado de un número complejo.\n"
"\n"
"* Si @inum no es un número complejo válido, IMCONJUGATE devuelve el error "
"#VALOR!.\n"
"* Esta función es compatible con Excel. \n"
"@EXAMPLES=\n"
"IMCONJUGATE(\"1-j\") es igual a 1+i.\n"
"\n"
"@SEEALSO=IMAGINARY,IMREAL"

#: ../plugins/fn-complex/functions.c:261
msgid ""
"@FUNCTION=IMINV\n"
"@SYNTAX=IMINV(inumber)\n"
"@DESCRIPTION=IMINV returns the inverse, or reciprocal, of the complex number "
"z (@inumber), where\n"
"\n"
"\t1/z = (x - i y)/(x^2 + y^2).\n"
"\n"
"* If @inumber is not a valid complex number, IMINV returns #VALUE! error.\n"
"\n"
"@EXAMPLES=\n"
"IMINV(\"1-j\") equals 0.5+0.5j.\n"
"\n"
"@SEEALSO="
msgstr ""
"@FUNCTION=IMINV\n"
"@SYNTAX=IMINV(ncomplejo)\n"
"@DESCRIPTION=IMINV devuelve el inverso o recíproco, del número complejo z "
"(@ncomplejo), donde\n"
"\n"
"\t1/z = (x - i y)/(x^2 + y^2).\n"
"\n"
"* Si @ncomplejo no es un número complejo válido, IMINV devuelve el error "
"#VALOR!.\n"
"\n"
"@EXAMPLES=\n"
"IMINV(\"1-j\") es igual a 0.5+0.5j.\n"
"\n"
"@SEEALSO="

#: ../plugins/fn-complex/functions.c:295
msgid ""
"@FUNCTION=IMNEG\n"
"@SYNTAX=IMNEG(inumber)\n"
"@DESCRIPTION=IMNEG returns the negative of the complex number z (@inumber), "
"where\n"
"\n"
"\t-z = (-x) + i(-y).\n"
"\n"
"* If @inumber is not a valid complex number, IMNEG returns #VALUE! error.\n"
"\n"
"@EXAMPLES=\n"
"IMNEG(\"1-j\") equals -1+j.\n"
"\n"
"@SEEALSO="
msgstr ""
"@FUNCTION=IMNEG\n"
"@SYNTAX=IMNEG(ncomplejo)\n"
"@DESCRIPTION=IMNEG devuelve el negativo del número complejo z (@ncomplejo), "
"donde\n"
"\n"
"\t-z = (-x) + i(-y).\n"
"\n"
"* Si @complejo no es un número complejo válido, IMNEG devuelve el error "
"#VALOR!.\n"
"\n"
"@EXAMPLES=\n"
"IMNEG(\"1-j\") es igual a -1+j.\n"
"\n"
"@SEEALSO="

#: ../plugins/fn-complex/functions.c:329
msgid ""
"@FUNCTION=IMCOS\n"
"@SYNTAX=IMCOS(inumber)\n"
"@DESCRIPTION=IMCOS returns the cosine of a complex number.\n"
"\n"
"* If @inumber is not a valid complex number, IMCOS returns #VALUE! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"IMCOS(\"1+j\") equals 0.833730-0.988898j.\n"
"\n"
"@SEEALSO=IMSIN,IMTAN"
msgstr ""
"@FUNCTION=IMCOS\n"
"@SYNTAX=IMCOS(complejo)\n"
"@DESCRIPTION=Devuelve el coseno de un número complejo.\n"
"\n"
"* Si @complejo no es un número complejo válido, IMCOS devuelve el error "
"#VALOR!.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"IMCOS(\"1+i\") es igual a 0,833730-0,988898i.\n"
"\n"
"@SEEALSO=IMSIN,IMTAN"

#: ../plugins/fn-complex/functions.c:363
msgid ""
"@FUNCTION=IMTAN\n"
"@SYNTAX=IMTAN(inumber)\n"
"@DESCRIPTION=IMTAN returns the tangent of a complex number.\n"
"\n"
"* If @inumber is not a valid complex number, IMTAN returns #VALUE! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"IMTAN(\"2-j\") equals -0.2434582-1.1667363j.\n"
"\n"
"@SEEALSO=IMSIN,IMCOS"
msgstr ""
"@FUNCTION=IMTAN\n"
"@SYNTAX=IMTAN(complejo)\n"
"@DESCRIPTION=Devuelve la tangente de un número complejo.\n"
"\n"
"* Si @complejo no es un número complejo válido, IMTAN devuelve el error "
"#VALOR!.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=IMSIN,IMCOS"

#: ../plugins/fn-complex/functions.c:397
msgid ""
"@FUNCTION=IMSEC\n"
"@SYNTAX=IMSEC(inumber)\n"
"@DESCRIPTION=IMSEC returns the complex secant of the complex number z "
"(@inumber), where\n"
"\n"
"\tsec(z) = 1/cos(z).\n"
"\n"
"* If @inumber is not a valid complex number, IMSEC returns #VALUE! error.\n"
"\n"
"@EXAMPLES=\n"
"IMSEC(\"2-j\") equals -0.413149-0.687527j.\n"
"\n"
"@SEEALSO=IMCSC,IMCOT"
msgstr ""
"@FUNCTION=IMSEC\n"
"@SYNTAX=IMSEC(complejo)\n"
"@DESCRIPTION=IMSEC devuelve la secante compleja del número complejo z "
"(@complejo), donde\n"
"\n"
"\tsec(z) = 1/cos(z).\n"
"\n"
"* Si @complejo no es un número complejo válido, IMSEC devuelve el error "
"#VALOR!.\n"
"\n"
"@EXAMPLES=\n"
"IMSEC(\"2-j\") es igual a -0.413149-0.687527j.\n"
"\n"
"@SEEALSO=IMCSC,IMCOT"

#: ../plugins/fn-complex/functions.c:433
msgid ""
"@FUNCTION=IMCSC\n"
"@SYNTAX=IMCSC(inumber)\n"
"@DESCRIPTION=IMCSC returns the complex cosecant of the complex number z "
"(@inumber), where\n"
"\n"
"\tcsc(z) = 1/sin(z).\n"
"\n"
"* If @inumber is not a valid complex number, IMCSC returns #VALUE! error.\n"
"\n"
"@EXAMPLES=\n"
"IMCSC(\"2-j\") equals 0.635494-0.221501j.\n"
"\n"
"@SEEALSO=IMSEC,IMCOT"
msgstr ""
"@FUNCTION=IMCSC\n"
"@SYNTAX=IMCSC(complejo)\n"
"@DESCRIPTION=IMCSC devuelve la cosecante compleja del número complejo z "
"(@complejo), donde\n"
"\n"
"\tcsc(z) = 1/sin(z).\n"
"\n"
"* Si @complejo no es un número complejo válido, IMCSC devuelve el error "
"#VALOR!.\n"
"\n"
"@EXAMPLES=\n"
"IMCSC(\"2-j\") es igual a 0.635494-0.221501j.\n"
"\n"
"@SEEALSO=IMSEC,IMCOT"

#: ../plugins/fn-complex/functions.c:469
msgid ""
"@FUNCTION=IMCOT\n"
"@SYNTAX=IMCOT(inumber)\n"
"@DESCRIPTION=IMCOT returns the complex cotangent of the complex number z "
"(@inumber), where\n"
"\n"
"\tcot(z) = 1/tan(z).\n"
"\n"
"* If @inumber is not a valid complex number, IMCOT returns #VALUE! error.\n"
"\n"
"@EXAMPLES=\n"
"IMCOT(\"2-j\") equals -0.171384+0.821330j.\n"
"\n"
"@SEEALSO=IMSEC,IMCSC"
msgstr ""
"@FUNCTION=IMCOT\n"
"@SYNTAX=IMCOT(complejo)\n"
"@DESCRIPTION=IMCOT devuelve la cotangente compleja del número complejo z "
"(@complejo), donde\n"
"\n"
"\tcot(z) = 1/tan(z).\n"
"\n"
"* Si @complejo no es un número complejo válido, IMCOT devuelve el error "
"#VALOR!.\n"
"\n"
"@EXAMPLES=\n"
"IMCOT(\"2-j\") es igual a -0.171384+0.821330j.\n"
"\n"
"@SEEALSO=IMSEC,IMCSC"

#: ../plugins/fn-complex/functions.c:505
msgid ""
"@FUNCTION=IMEXP\n"
"@SYNTAX=IMEXP(inumber)\n"
"@DESCRIPTION=IMEXP returns the exponential of a complex number.\n"
"\n"
"* If @inumber is not a valid complex number, IMEXP returns #VALUE! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"IMEXP(\"2-j\") equals 3.992324-6.217676j.\n"
"\n"
"@SEEALSO=IMLN"
msgstr ""
"@FUNCTION=IMEXP\n"
"@SYNTAX=IMEXP(complejo)\n"
"@DESCRIPTION=IMEXP devuelve el exponencial de un número complejo.\n"
"\n"
"* Si @complejo no es un número complejo válido, IMEXP devuelve el error "
"#VALOR!.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"IMEXP(\"2-j\") es igual a 3.992324-6.217676j.\n"
"\n"
"@SEEALSO=IMLN"

#: ../plugins/fn-complex/functions.c:539
msgid ""
"@FUNCTION=IMARGUMENT\n"
"@SYNTAX=IMARGUMENT(inumber)\n"
"@DESCRIPTION=IMARGUMENT returns the argument theta of a complex number, i.e. "
"the angle in radians from the real axis to the representation of the number "
"in polar coordinates.\n"
"\n"
"* If @inumber is not a valid complex number, IMARGUMENT returns #VALUE! "
"error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"IMARGUMENT(\"2-j\") equals -0.463647609.\n"
"\n"
"@SEEALSO="
msgstr ""
"@FUNCTION=IMARGUMENT\n"
"@SYNTAX=IMARGUMENT(inum)\n"
"@DESCRIPTION=Devuelve el argumento teta de un número complejo, esto es el "
"ángulo (en radianes) que forma la representación del número complejo (en "
"coordenadas polares) con el eje real.\n"
"\n"
"* Si @inum no es un número complejo válido, IMARGUMENT devuelve el error "
"#VALOR!.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"IMARGUMENT(\"2-i\") es igual a -0,463647609.\n"
"\n"
"@SEEALSO="

#: ../plugins/fn-complex/functions.c:574
msgid ""
"@FUNCTION=IMLN\n"
"@SYNTAX=IMLN(inumber)\n"
"@DESCRIPTION=IMLN returns the natural logarithm of a complex number.\n"
"\n"
"The result will have an imaginary part between -pi and +pi.  The natural "
"logarithm is not uniquely defined on complex numbers. You may need to add or "
"subtract an even multiple of pi to the imaginary part.\n"
"\n"
"* If @inumber is not a valid complex number, IMLN returns #VALUE! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"IMLN(\"3-j\") equals 1.15129-0.32175j.\n"
"\n"
"@SEEALSO=IMEXP,IMLOG2,IMLOG10"
msgstr ""
"@FUNCTION=IMLN\n"
"@SYNTAX=IMLN(inum)\n"
"@DESCRIPTION=Devuelve el logaritmo natural de un número complejo.\n"
"\n"
"El resultado tendrá una parte imaginaria entre -pi y +pi. El logaritmo "
"natural no está definido de manera única con números complejos; puede que "
"necesite añadir o sustraer un múltiplo par de pi a la parte imaginaria..\n"
"\n"
"* Si @inum no es un número complejo válido, IMLN devuelve el error #VALOR!.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"Esta función es compatible con Excel.\n"
"@EXAMPLES=\n"
"IMLN(\"3-j\") es igual a 1,15129-0,32175j.\n"
"\n"
"@SEEALSO=IMEXP,IMLOG2,IMLOG10"

#: ../plugins/fn-complex/functions.c:613
msgid ""
"@FUNCTION=IMLOG2\n"
"@SYNTAX=IMLOG2(inumber)\n"
"@DESCRIPTION=IMLOG2 returns the logarithm of a complex number in base 2.\n"
"\n"
"* If @inumber is not a valid complex number, IMLOG2 returns #VALUE! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"IMLOG2(\"3-j\") equals 1.66096-0.46419j.\n"
"\n"
"@SEEALSO=IMLN,IMLOG10"
msgstr ""
"@FUNCTION=IMLOG2\n"
"@SYNTAX=IMLOG2(complejo)\n"
"@DESCRIPTION=IMLOG2 devuelve el logaritmo de base 2 un número complejo.\n"
"\n"
"* Si @complejo no es un número complejo válido, IMLOG2 devuelve el error "
"#VALOR!.\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"IMLOG2(\"3-j\") es igual a 1,66096-0,46419j.\n"
"\n"
"@SEEALSO=IMLN,IMLOG10"

#: ../plugins/fn-complex/functions.c:648
msgid ""
"@FUNCTION=IMLOG10\n"
"@SYNTAX=IMLOG10(inumber)\n"
"@DESCRIPTION=IMLOG10 returns the logarithm of a complex number in base 10.\n"
"\n"
"* If @inumber is not a valid complex number, IMLOG10 returns #VALUE! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"IMLOG10(\"3-j\") equals 0.5-0.13973j.\n"
"\n"
"@SEEALSO=IMLN,IMLOG2"
msgstr ""
"@FUNCTION=IMLOG10\n"
"@SYNTAX=IMLOG10(complejo)\n"
"@DESCRIPTION=IMLOG10 devuelve el logaritmo en base 10 de un número "
"complejo.\n"
"\n"
"* Si @complejo no es un número complejo válido, IMLOG10 devuelve el error "
"#VALOR!.\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"IMLOG10(\"3-j\") devuelve 0,5-0,13973j.\n"
"\n"
"@SEEALSO=IMLN,IMLOG2"

#: ../plugins/fn-complex/functions.c:683
msgid ""
"@FUNCTION=IMPOWER\n"
"@SYNTAX=IMPOWER(inumber1,inumber2)\n"
"@DESCRIPTION=IMPOWER returns a complex number raised to a power.  @inumber1 "
"is the complex number to be raised to a power and @inumber2 is the power to "
"which you want to raise it.\n"
"\n"
"* If @inumber1 or @inumber2 are not valid complex numbers, IMPOWER returns "
"#VALUE! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"IMPOWER(\"4-j\",2) equals 15-8j.\n"
"\n"
"@SEEALSO=IMSQRT"
msgstr ""
"@FUNCTION=IMPOWER\n"
"@SYNTAX=IMPOWER(ncomplejo1;ncomplejo2)\n"
"@DESCRIPTION=Devuelve un número complejo elevado a una potencia. @ncomplejo1 "
"es el número complejo y @ncomplejo2 es la potencia con la cual se desea "
"elevar el número complejo.\n"
"\n"
"* Si @ncomplejo1 o @ncomplejo2 no son números complejos válidos, IMPOWER "
"devuelve un error #VALOR!\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"IMPOWER(\"4-i\";2) es igual a 15-8i.\n"
"\n"
"@SEEALSO=IMSQRT"

#: ../plugins/fn-complex/functions.c:725
msgid ""
"@FUNCTION=IMDIV\n"
"@SYNTAX=IMDIV(inumber1,inumber2)\n"
"@DESCRIPTION=IMDIV returns the quotient of two complex numbers.\n"
"\n"
"* If @inumber1 or @inumber2 are not valid complex numbers, IMDIV returns "
"#VALUE! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"IMDIV(\"2-j\",\"2+j\") equals 0.6-0.8j.\n"
"\n"
"@SEEALSO=IMPRODUCT"
msgstr ""
"@FUNCTION=IMDIV\n"
"@SYNTAX=IMDIV(inum1,inum2)\n"
"@DESCRIPTION=Devuelve el cociente de dos números complejos.\n"
"\n"
"* Si @inum1 o @inum2 no es un número complejo válido, IMDIV devuelve el "
"error #VALOR!.\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"IMDIV(\"2-i\";\"2+i\") devuelve 0,6-0,8i.\n"
"\n"
"@SEEALSO=IMPRODUCT"

#: ../plugins/fn-complex/functions.c:765
msgid ""
"@FUNCTION=IMSIN\n"
"@SYNTAX=IMSIN(inumber)\n"
"@DESCRIPTION=IMSIN returns the sine of a complex number.\n"
"\n"
"* If @inumber is not a valid complex number, IMSIN returns #VALUE! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"IMSIN(\"1+j\") equals 1.29846+0.63496j.\n"
"\n"
"@SEEALSO=IMCOS,IMTAN"
msgstr ""
"@FUNCTION=IMSIN\n"
"@SYNTAX=IMSIN(inum)\n"
"@DESCRIPTION=Devuelve el seno de un número complejo.\n"
"\n"
"* Si @inum no es un número complejo válido, IMSIN devuelve un error "
"#VALOR!.\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"IMSIN(\"1+i\") es igual a 1,29846+0,63496i.\n"
"\n"
"@SEEALSO=IMCOS,IMTAN"

#: ../plugins/fn-complex/functions.c:798
msgid ""
"@FUNCTION=IMSINH\n"
"@SYNTAX=IMSINH(inumber)\n"
"@DESCRIPTION=IMSINH returns the complex hyperbolic sine of the complex "
"number z (@inumber), where\n"
"\n"
"\tsinh(z) = (exp(z) - exp(-z))/2.\n"
"\n"
"* If @inumber is not a valid complex number, IMSINH returns #VALUE! error.\n"
"\n"
"@EXAMPLES=\n"
"IMSINH(\"1+j\") equals 0.63496+1.29846j.\n"
"\n"
"@SEEALSO=IMCOSH,IMTANH"
msgstr ""
"@FUNCTION=IMSINH\n"
"@SYNTAX=IMSINH(inum)\n"
"@DESCRIPTION=IMSINH devuelve el seno hiperbólico complejo del número "
"complejo z (@inum), donde:\n"
"\n"
"\tsinh(z) = (exp(z) - exp(-z))/2.\n"
"\n"
"* Si @inum no es un número complejo válido, IMSINH devuelve un error "
"#VALOR!.\n"
"\n"
"@EXAMPLES=\n"
"IMSINH(\"1+j\") igual a 0.63496+1.29846j.\n"
"\n"
"@SEEALSO=IMCOSH,IMTANH"

#: ../plugins/fn-complex/functions.c:833
msgid ""
"@FUNCTION=IMCOSH\n"
"@SYNTAX=IMCOSH(inumber)\n"
"@DESCRIPTION=IMCOSH returns the complex hyperbolic cosine of the complex "
"number z (@inumber), where\n"
"\n"
"\tcosh(z) = (exp(z) + exp(-z))/2.\n"
"\n"
"* If @inumber is not a valid complex number, IMCOSH returns #VALUE! error.\n"
"\n"
"@EXAMPLES=\n"
"IMCOSH(\"1+j\") equals 0.83373+0.988898j.\n"
"\n"
"@SEEALSO=IMSINH,IMTANH"
msgstr ""
"@FUNCTION=IMCOSH\n"
"@SYNTAX=IMCOSH(inum)\n"
"@DESCRIPTION=IMCOSH devuelve el coseno hiperbólico complejo del número "
"complejo z (@inum), donde\n"
"\n"
"\tcosh(z) = (exp(z) + exp(-z))/2.\n"
"\n"
"* Si @inum no es un número complejo válido, IMCOSH devuelve el error "
"#VALOR!.\n"
"\n"
"@EXAMPLES=\n"
"IMCOSH(\"1+j\") igual a 0.83373+0.988898j.\n"
"\n"
"@SEEALSO=IMSINH,IMTANH"

#: ../plugins/fn-complex/functions.c:867
msgid ""
"@FUNCTION=IMTANH\n"
"@SYNTAX=IMTANH(inumber)\n"
"@DESCRIPTION=IMTANH returns the complex hyperbolic tangent of the complex "
"number z (@inumber), where\n"
"\n"
"\ttanh(z) = sinh(z)/cosh(z).\n"
"\n"
"* If @inumber is not a valid complex number, IMTANH returns #VALUE! error.\n"
"\n"
"@EXAMPLES=\n"
"IMTANH(\"1+j\") equals 1.083923+0.2717526j.\n"
"\n"
"@SEEALSO=IMSINH,IMCOSH"
msgstr ""
"@FUNCTION=IMTANH\n"
"@SYNTAX=IMTANH(inum)\n"
"@DESCRIPTION=IMTANH devuelve la tangente hiperbólica compleja del número "
"complejo z (@inum), donde\n"
"\n"
"\ttanh(z) = sinh(z)/cosh(z).\n"
"\n"
"* Si @inum no es un número complejo válido, IMTANH devuelve el error "
"#VALOR!.\n"
"\n"
"@EXAMPLES=\n"
"IMTANH(\"1+j\") igual a 1.083923+0.2717526j.\n"
"\n"
"@SEEALSO=IMSINH,IMCOSH"

#: ../plugins/fn-complex/functions.c:901
msgid ""
"@FUNCTION=IMSECH\n"
"@SYNTAX=IMSECH(inumber)\n"
"@DESCRIPTION=IMSECH returns the complex hyperbolic secant of the complex "
"number z (@inumber), where\n"
"\n"
"\tsech(z) = 1/cosh(z).\n"
"\n"
"* If @inumber is not a valid complex number, IMSECH returns #VALUE! error.\n"
"\n"
"@EXAMPLES=\n"
"IMSECH(\"1+j\") equals 0.498337-0.5910838j.\n"
"\n"
"@SEEALSO=IMCSCH,IMCOTH"
msgstr ""
"@FUNCTION=IMSECH\n"
"@SYNTAX=IMSECH(inum)\n"
"@DESCRIPTION=IMSECH devuelve la secante hiperbólica compleja del número "
"complejo z (@ncomplejo), donde\n"
"\n"
"\tsech(z) = 1/cosh(z).\n"
"\n"
"* Si @inum no es un número complejo válido, IMSECH devuelve el error "
"#VALOR!.\n"
"\n"
"@EXAMPLES=\n"
"IMSECH(\"1+j\") igual a 0.498337-0.5910838j.\n"
"\n"
"@SEEALSO=IMCSCH,IMCOTH"

#: ../plugins/fn-complex/functions.c:935
msgid ""
"@FUNCTION=IMCSCH\n"
"@SYNTAX=IMCSCH(inumber)\n"
"@DESCRIPTION=IMCSCH returns the complex hyperbolic cosecant of the complex "
"number z (@inumber), where\n"
"\n"
"\tcsch(z) = 1/sinh(z).\n"
"\n"
"* If @inumber is not a valid complex number, IMCSCH returns #VALUE! error.\n"
"\n"
"@EXAMPLES=\n"
"IMCSCH(\"1+j\") equals 0.303931-0.621518j.\n"
"\n"
"@SEEALSO=IMSECH,IMCOTH"
msgstr ""
"@FUNCTION=IMCSCH\n"
"@SYNTAX=IMCSCH(inum)\n"
"@DESCRIPTION=IMCSCH devuelve la cosecante hiperbólica compleja del número "
"complejo z (@inum), donde:\n"
"\n"
"\tcsch(z) = 1/sinh(z).\n"
"\n"
"* Si @inum no es un número complejo válido, IMCSCH devuelve el error "
"#VALOR!.\n"
"\n"
"@EXAMPLES=\n"
"IMCSCH(\"1+j\") igual a 0.303931-0.621518j.\n"
"\n"
"@SEEALSO=IMSECH,IMCOTH"

#: ../plugins/fn-complex/functions.c:969
msgid ""
"@FUNCTION=IMCOTH\n"
"@SYNTAX=IMCOTH(inumber)\n"
"@DESCRIPTION=IMCOTH returns the complex hyperbolic cotangent of the complex "
"number z (@inumber) where,\n"
"\n"
"\tcoth(z) = 1/tanh(z).\n"
"\n"
"* If @inumber is not a valid complex number, IMCOTH returns #VALUE! error.\n"
"\n"
"@EXAMPLES=\n"
"IMCOTH(\"1+j\") equals 0.868014-0.217622j.\n"
"\n"
"@SEEALSO=IMSECH,IMCSCH"
msgstr ""
"@FUNCTION=IMCOTH\n"
"@SYNTAX=IMCOTH(inum)\n"
"@DESCRIPTION=IMCOTH devuelve la cotangente hiperbólica compleja del número "
"complejo z (@inum) donde:\n"
"\n"
"\tcoth(z) = 1/tanh(z).\n"
"\n"
"* Si @inum no es un número complejo válido, IMCOTH devuelve el error "
"#VALOR!.\n"
"\n"
"@EXAMPLES=\n"
"IMCOTH(\"1+j\") igual 0.868014-0.217622j.\n"
"\n"
"@SEEALSO=IMSECH,IMCSCH"

#: ../plugins/fn-complex/functions.c:1003
msgid ""
"@FUNCTION=IMARCSIN\n"
"@SYNTAX=IMARCSIN(inumber)\n"
"@DESCRIPTION=IMARCSIN returns the complex arcsine of the complex number "
"@inumber. The branch cuts are on the real axis, less than -1 and greater "
"than 1.\n"
"\n"
"* If @inumber is not a valid complex number, IMARCSIN returns #VALUE! "
"error.\n"
"\n"
"@EXAMPLES=\n"
"IMARCSIN(\"1+j\") equals 0.6662394+1.061275j.\n"
"\n"
"@SEEALSO=IMARCCOS,IMARCTAN"
msgstr ""
"@FUNCTION=IMARCSIN\n"
"@SYNTAX=IMARCSIN(inum)\n"
"@DESCRIPTION=IMARCSIN devuelve el arco seno complejo del número complejo "
"@inum. Los cortes están en el eje real, menor que -1 y mayor que 1.\n"
"\n"
"* Si @inum no es un número complejo válido, IMARCSIN devuelve un error "
"#VALOR!.\n"
"\n"
"@EXAMPLES=\n"
"IMARCSIN(\"1+j\") igual a 0.6662394+1.061275j.\n"
"\n"
"@SEEALSO=IMARCCOS,IMARCTAN"

#: ../plugins/fn-complex/functions.c:1038
msgid ""
"@FUNCTION=IMARCCOS\n"
"@SYNTAX=IMARCCOS(inumber)\n"
"@DESCRIPTION=IMARCCOS returns the complex arccosine of the complex number "
"@inumber. The branch cuts are on the real axis, less than -1 and greater "
"than 1.\n"
"\n"
"* If @inumber is not a valid complex number, IMARCCOS returns #VALUE! "
"error.\n"
"\n"
"@EXAMPLES=\n"
"IMARCCOS(\"1+j\") equals 0.9045569-1.061275j.\n"
"\n"
"@SEEALSO=IMARCSIN,IMARCTAN"
msgstr ""
"@FUNCTION=IMARCCOS\n"
"@SYNTAX=IMARCCOS(complejo)\n"
"@DESCRIPTION=Devuelve arco coseno complejo del número complejo @complejo. "
"Los cortes de los brazos están en el eje real, menores que -1 y mayores que "
"1.\n"
"\n"
"* Si @complejo no es un número complejo válido, IMARCCOS devuelve un error "
"#VALOR!.\n"
"\n"
"@EXAMPLES=\n"
"IMARCCOS(\"1+i\") devuelve 0.9045569-1.061275i.\n"
"\n"
"@SEEALSO=IMARCSIN,IMARCTAN"

#: ../plugins/fn-complex/functions.c:1073
msgid ""
"@FUNCTION=IMARCTAN\n"
"@SYNTAX=IMARCTAN(inumber)\n"
"@DESCRIPTION=IMARCTAN returns the complex arctangent of the complex number "
"@inumber. The branch cuts are on the imaginary axis, below -i and above i.\n"
"\n"
"* If @inumber is not a valid complex number, IMARCTAN returns #VALUE! "
"error.\n"
"\n"
"@EXAMPLES=\n"
"IMARCTAN(\"1+j\") equals 1.0172220+0.4023595j.\n"
"\n"
"@SEEALSO=IMARCSIN,IMARCCOS"
msgstr ""
"@FUNCTION=IMARCTAN\n"
"@SYNTAX=IMARCTAN(inum)\n"
"@DESCRIPTION=IMARCTAN devuelve el arco tangente complejo del número complejo "
"@inum. Los cortes están sobre el eje imaginario, por debajo de -i y por "
"encima de i.\n"
"\n"
"* Si @inum no es un número complejo válido, IMARCTAN devuelve el error "
"#VALOR!.\n"
"\n"
"@EXAMPLES=\n"
"IMARCTAN(\"1+j\") igual a 1.0172220+0.4023595j.\n"
"\n"
"@SEEALSO=IMARCSIN,IMARCCOS"

#: ../plugins/fn-complex/functions.c:1108
msgid ""
"@FUNCTION=IMARCSEC\n"
"@SYNTAX=IMARCSEC(inumber)\n"
"@DESCRIPTION=IMARCSEC returns the complex arcsecant of the complex number z "
"(@inumber), where\n"
"\n"
"\tarcsec(z) = arccos(1/z).\n"
"\n"
"* If @inumber is not a valid complex number, IMARCSEC returns #VALUE! "
"error.\n"
"\n"
"@EXAMPLES=\n"
"IMARCSEC(\"1+j\") equals 1.1185179+0.5306375j.\n"
"\n"
"@SEEALSO=IMARCCSC,IMARCCOT"
msgstr ""
"@FUNCTION=IMARCSEC\n"
"@SYNTAX=IMARCSEC(inum)\n"
"@DESCRIPTION=IMARCSEC devuelve el arco secante complejo del número z "
"(@inum), donde\n"
"\n"
"\tarcsec(z) = arccos(1/z).\n"
"\n"
"* Si @inum no es un número complejo válido, IMARCSEC devuelve un error "
"#VALOR!.\n"
"\n"
"@EXAMPLES=\n"
"IMARCSEC(\"1+j\") igual a 1.1185179+0.5306375j.\n"
"\n"
"@SEEALSO=IMARCCSC,IMARCCOT"

#: ../plugins/fn-complex/functions.c:1142
msgid ""
"@FUNCTION=IMARCCSC\n"
"@SYNTAX=IMARCCSC(inumber)\n"
"@DESCRIPTION=IMARCCSC returns the complex arccosecant of the complex number "
"z (@inumber), where\n"
"\n"
"\tarccsc(z) = arcsin(1/z).\n"
"\n"
"* If @inumber is not a valid complex number, IMARCCSC returns #VALUE! "
"error.\n"
"\n"
"@EXAMPLES=\n"
"IMARCCSC(\"1+j\") equals 0.45227845-0.5306375j.\n"
"\n"
"@SEEALSO=IMARCSEC,IMARCCOT"
msgstr ""
"@FUNCTION=IMARCCSC\n"
"@SYNTAX=IMARCCSC(inum)\n"
"@DESCRIPTION=IMARCCSC devuelve el arco secante complejo del número complejo "
"z (@inum), donde\n"
"\n"
"\tarccsc(z) = arcsin(1/z).\n"
"\n"
"* Si @inum no es un número complejo válido, IMARCCSC devuelve un error "
"#VALOR!.\n"
"\n"
"@EXAMPLES=\n"
"IMARCCSC(\"1+j\") igual a 0.45227845-0.5306375j.\n"
"\n"
"@SEEALSO=IMARCSEC,IMARCCOT"

#: ../plugins/fn-complex/functions.c:1176
msgid ""
"@FUNCTION=IMARCCOT\n"
"@SYNTAX=IMARCCOT(inumber)\n"
"@DESCRIPTION=IMARCCOT returns the complex arccotangent of the complex number "
"z (@inumber), where\n"
"\n"
"\tarccot(z) = arctan(1/z).\n"
"\n"
"* If @inumber is not a valid complex number, IMARCCOT returns #VALUE! "
"error.\n"
"\n"
"@EXAMPLES=\n"
"IMARCCOT(\"1+j\") equals 0.553574+0.4023595j.\n"
"\n"
"@SEEALSO=IMARCSEC,IMARCCSC"
msgstr ""
"@FUNCTION=IMARCCOT\n"
"@SYNTAX=IMARCCOT(inum)\n"
"@DESCRIPTION=IMARCCOT devuelve el arco cotangente complejo del número "
"complejo z (@inum), donde\n"
"\n"
"\tarccot(z) = arctan(1/z).\n"
"\n"
"* Si @inum no es un número complejo válido, IMARCCOT devuelve el error "
"#VALOR!!.\n"
"\n"
"@EXAMPLES=\n"
"IMARCCOT(\"1+j\") igual a 0.553574+0.4023595j.\n"
"\n"
"@SEEALSO=IMARCSEC,IMARCCSC"

#: ../plugins/fn-complex/functions.c:1210
msgid ""
"@FUNCTION=IMARCSINH\n"
"@SYNTAX=IMARCSINH(inumber)\n"
"@DESCRIPTION=IMARCSINH returns the complex hyperbolic arcsine of the complex "
"number @inumber. The branch cuts are on the imaginary axis, below -i and "
"above i.\n"
"\n"
"* If @inumber is not a valid complex number, IMARCSINH returns #VALUE! "
"error.\n"
"\n"
"@EXAMPLES=\n"
"IMARCSINH(\"1+j\") equals 1.061275+0.6662394j.\n"
"\n"
"@SEEALSO=IMARCCOSH,IMARCTANH"
msgstr ""
"@FUNCTION=IMARCSINH\n"
"@SYNTAX=IMARCSINH(inum)\n"
"@DESCRIPTION=IMARCSINH devuelve el arco seno hiperbólico complejo del número "
"complejo < (@inum). Los cortes con el eje imaginario se encuentran por "
"debajo de -i y por encima de i.\n"
"\n"
"* Si @inum no es un número complejo válido, IMARCSINH devuelve un error "
"#VALOR!.\n"
"\n"
"@EXAMPLES=\n"
"IMARCSINH(\"1+j\") igual a 1.061275+0.6662394j.\n"
"\n"
"@SEEALSO=IMARCCOSH,IMARCTANH"

#: ../plugins/fn-complex/functions.c:1245
msgid ""
"@FUNCTION=IMARCCOSH\n"
"@SYNTAX=IMARCCOSH(inumber)\n"
"@DESCRIPTION=IMARCCOSH returns the complex hyperbolic arccosine of the "
"complex number @inumber. The branch cut is on the real axis, less than 1.\n"
"\n"
"* If @inumber is not a valid complex number, IMARCCOSH returns #VALUE! "
"error.\n"
"\n"
"@EXAMPLES=\n"
"IMARCCOSH(\"1+j\") equals 1.06127506+0.904557j.\n"
"\n"
"@SEEALSO=IMARCSINH,IMARCTANH"
msgstr ""
"@FUNCTION=IMARCCOSH\n"
"@SYNTAX=IMARCCOSH(inum)\n"
"@DESCRIPTION=Devuelve el arco hiperbólico del coseno del número complejo "
"@inum. El brazo de corte se encuentra en el eje real, menor que 1.\n"
"\n"
"* Si @inum no es un número complejo válido, IMARCCOSH \tdevuelve un error "
"#VALOR!.\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"IMARCCOSH(\"1+j\") devuelve 1.06127506+0.904557j.\n"
"\n"
"@SEEALSO=IMARCSINH,IMARCTANH"

#: ../plugins/fn-complex/functions.c:1280
msgid ""
"@FUNCTION=IMARCTANH\n"
"@SYNTAX=IMARCTANH(inumber)\n"
"@DESCRIPTION=IMARCTANH returns the complex hyperbolic arctangent of the "
"complex number @inumber. The branch cuts are on the real axis, less than -1 "
"and greater than 1.\n"
"\n"
"* If @inumber is not a valid complex number, IMARCTANH returns #VALUE! "
"error.\n"
"\n"
"@EXAMPLES=\n"
"IMARCTANH(\"1+j\") equals 0.4023595+1.0172220j.\n"
"\n"
"@SEEALSO=IMARCSINH,IMARCCOSH"
msgstr ""
"@FUNCTION=IMARCTANH\n"
"@SYNTAX=IMARCTANH(inum)\n"
"@DESCRIPTION=IMARCTANH devuelve el arco tangente hiperbólico imaginario del "
"número complejo @inum. El corte con los ejes se encuentra en el eje real, "
"menor que -1 y mayor que 1.\n"
"\n"
"* Si @inum no es un complejo válido, IMARCHTANH devuelve un error #VALOR!\n"
"\n"
"@EXAMPLES=\n"
"IMARCTANH(\"1+j\") es igual a 0.4023595+1.0172220j.\n"
"\n"
"@SEEALSO=IMARCSINH,IMARCCOSH"

#: ../plugins/fn-complex/functions.c:1315
msgid ""
"@FUNCTION=IMARCSECH\n"
"@SYNTAX=IMARCSECH(inumber)\n"
"@DESCRIPTION=IMARCSECH returns the complex hyperbolic arcsecant of the "
"complex number z (@inumber), where\n"
"\n"
"\tarcsech(z) = arccosh(1/z).\n"
"\n"
"* If @inumber is not a valid complex number, IMARCSECH returns #VALUE! "
"error.\n"
"\n"
"@EXAMPLES=\n"
"IMARCSECH(\"1+j\") equals 0.5306375-1.118518j.\n"
"\n"
"@SEEALSO=IMARCCSCH,IMARCCOTH"
msgstr ""
"@FUNCTION=IMARCSECH\n"
"@SYNTAX=IMARCSECH(inum)\n"
"@DESCRIPTION=IMARCSECH devuelve el arco secante hiperbólico complejo del "
"número complejo z (@inum), donde\n"
"\n"
"\tarcsech(z) = arccosh(1/z).\n"
"\n"
"* Si @inum no es un número complejo válido, IMARCSECH devuelve un error "
"#VALOR!.\n"
"\n"
"@EXAMPLES=\n"
"IMARCSECH(\"1+j\") igual a 0.5306375-1.118518j.\n"
"\n"
"@SEEALSO=IMARCCSCH,IMARCCOTH"

#: ../plugins/fn-complex/functions.c:1350
msgid ""
"@FUNCTION=IMARCCSCH\n"
"@SYNTAX=IMARCCSCH(inumber)\n"
"@DESCRIPTION=IMARCCSCH returns the complex hyperbolic arccosecant of the "
"complex number z (@inumber), where\n"
"\n"
"\tarccsch(z) = arcsinh(1/z).\n"
"\n"
"* If @inumber is not a valid complex number, IMARCCSCH returns #VALUE! "
"error.\n"
"\n"
"@EXAMPLES=\n"
"IMARCCSCH(\"1+j\") equals 0.5306375-0.452278j.\n"
"\n"
"@SEEALSO=IMARCSECH,IMARCCOTH"
msgstr ""
"@FUNCTION=IMARCCSCH\n"
"@SYNTAX=IMARCCSCH(inum)\n"
"@DESCRIPTION=IMARCCSCH devuelve el arco secante hiperbólico del número "
"complejo z (@inum), donde\n"
"\n"
"\tarccsch(z) = arcsin(1/z).\n"
"\n"
"* Si @inum no es un número complejo válido, IMARCCSCH devuelve un error "
"#VALOR!.\n"
"\n"
"@EXAMPLES=\n"
"IMARCCSCH(\"1+j\") igual a 0,5306375-0,452278j.\n"
"\n"
"@SEEALSO=IMARCSECH,IMARCCOTH"

#: ../plugins/fn-complex/functions.c:1384
msgid ""
"@FUNCTION=IMARCCOTH\n"
"@SYNTAX=IMARCCOTH(inumber)\n"
"@DESCRIPTION=IMARCCOTH returns the complex hyperbolic arccotangent of the "
"complex number z (@inumber), where\n"
"\n"
"\tarccoth(z) = arctanh(1/z).\n"
"\n"
"* If @inumber is not a valid complex number, IMARCCOTH returns #VALUE! "
"error.\n"
"\n"
"@EXAMPLES=\n"
"IMARCCOTH(\"1+j\") equals 0.40235948-0.5535744j.\n"
"\n"
"@SEEALSO=IMARCSECH,IMARCCSCH"
msgstr ""
"@FUNCTION=IMARCCOTH\n"
"@SYNTAX=IMARCCOTH(inum)\n"
"@DESCRIPTION=IMARCCOTH devuelve el arco cotangente hiperbólico complejo del "
"número z (@inum), donde \n"
"\n"
"\tarccoth(z) = arctanh(1/z).\n"
"\n"
"* Si @ncomplejo no es un número complejo válido, IMARCCOTH devuelve un error "
"#VALOR!.\n"
"\n"
"@EXAMPLES=\n"
"IMARCCOTH(\"1+j\") igual a 0.40235948-0.5535744j.\n"
"\n"
"@SEEALSO=IMARCSECH,IMARCCSCH"

#: ../plugins/fn-complex/functions.c:1419
msgid ""
"@FUNCTION=IMSQRT\n"
"@SYNTAX=IMSQRT(inumber)\n"
"@DESCRIPTION=IMSQRT returns the square root of a complex number.\n"
"\n"
"* If @inumber is not a valid complex number, IMSQRT returns #VALUE! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"IMSQRT(\"1+j\") equals 1.09868+0.4550899j.\n"
"\n"
"@SEEALSO=IMPOWER"
msgstr ""
"@FUNCTION=IMSQRT\n"
"@SYNTAX=IMSQRT(inum)\n"
"@DESCRIPTION=Devuelve la raíz cuadrada de un número complejo.\n"
"\n"
"* Si @inum no es un número complejo válido, IMSQRT devuelve un error "
"#VALOR!.\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"IMSQRT(\"1+i\") es igual a 1,09868+0,4550899i.\n"
"\n"
"@SEEALSO=IMPOWER"

#: ../plugins/fn-complex/functions.c:1453
msgid ""
"@FUNCTION=IMSUB\n"
"@SYNTAX=IMSUB(inumber1,inumber2)\n"
"@DESCRIPTION=IMSUB returns the difference of two complex numbers.\n"
"\n"
"* If @inumber1 or @inumber2 are not valid complex numbers, IMSUB returns "
"#VALUE! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"IMSUB(\"3-j\",\"2+j\") equals 1-2j.\n"
"\n"
"@SEEALSO=IMSUM"
msgstr ""
"@FUNCTION=IMSUB\n"
"@SYNTAX=IMSUB(complejo;complejo)\n"
"@DESCRIPTION=Devuelve la diferencia entre dos números complejos.\n"
"\n"
"* \n"
"Esta función es compatible con Excel. \n"
"@EXAMPLES=\n"
"IMSUB(\"2-4i\";\"9-i\") es igual a 11-5i.\n"
"\n"
"@SEEALSO=IMSUM"

#: ../plugins/fn-complex/functions.c:1490
msgid ""
"@FUNCTION=IMPRODUCT\n"
"@SYNTAX=IMPRODUCT(inumber1[,inumber2,...])\n"
"@DESCRIPTION=IMPRODUCT returns the product of given complex numbers.\n"
"\n"
"* If any of the @inumbers are not valid complex numbers, IMPRODUCT returns "
"#VALUE! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"IMPRODUCT(\"2-j\",\"4-2j\") equals 6-8j.\n"
"\n"
"@SEEALSO=IMDIV"
msgstr ""
"@FUNCTION=IMPRODUCT\n"
"@SYNTAX=IMPRODUCT(complejo1[;complejo2;…])\n"
"@DESCRIPTION=Devuelve el producto de los números complejos indicados.\n"
"\n"
"* Si cualquiera de los @complejos no es un número complejo válido, IMPRODUCT "
"devuelve el error #VALOR!.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"IMPRODUCT(\"2-i\";\"4-2i\") es igual a 6-8i.\n"
"\n"
"@SEEALSO=IMDIV"

#: ../plugins/fn-complex/functions.c:1567
msgid ""
"@FUNCTION=IMSUM\n"
"@SYNTAX=IMSUM(inumber1,inumber2)\n"
"@DESCRIPTION=IMSUM returns the sum of two complex numbers.\n"
"\n"
"* If @inumber1 or @inumber2 are not valid complex numbers, IMSUM returns "
"#VALUE! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"IMSUM(\"2-4j\",\"9-j\") equals 11-5j.\n"
"\n"
"@SEEALSO=IMSUB"
msgstr ""
"@FUNCTION=IMSUM\n"
"@SYNTAX=IMSUM(inum1,inum2)\n"
"@DESCRIPTION=Devuelve la suma de dos números complejos.\n"
"\n"
"* * Si @inum1 o @inum2 no es un número complejo válido, IMSUM devuelve el "
"error #VALOR!.\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"IMSUM(\"2-4i\";\"9-i\") es igual a 11-5i.\n"
"\n"
"@SEEALSO=IMSUB"

#: ../plugins/fn-database/functions.c:280
msgid ""
"@FUNCTION=DAVERAGE\n"
"@SYNTAX=DAVERAGE(database,field,criteria)\n"
"@DESCRIPTION=DAVERAGE function returns the average of the values in a list "
"or database that match conditions specified.\n"
"\n"
"@database is a range of cells in which rows of related information are "
"records and columns of data are fields. The first row of a database contains "
"labels for each column. \n"
"\n"
"@field specifies which column is used in the function.  If @field is an "
"integer, for example 2, the second column is used. Field can also be the "
"label of a column.  For example, ``Age'' refers to the column with the label "
"``Age'' in @database range. \n"
"\n"
"@criteria is the range of cells which contains the specified conditions.  "
"The first row of a @criteria should contain the labels of the fields for "
"which the criteria are for.  Cells below the labels specify conditions, for "
"example, ``>3'' or ``<9''.  Equality condition can be given simply by "
"specifying a value, e.g. ``3'' or ``John''. \n"
"Each row in @criteria specifies a separate condition. If a row in @database "
"matches a row in @criteria, then that row is counted. Technically speaking, "
"this a boolean OR operation between the rows in @criteria.\n"
"If @criteria specifies more than one column, then each of the conditions in "
"the specified columns must be true for the row in @database to match. "
"Technically speaking, this is a boolean AND operation between the columns in "
"@criteria.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the range A1:C7 contain the following values:\n"
"Name    Age     Salary\n"
"John    34      54342\n"
"Bill    35      22343\n"
"Clark   29      34323\n"
"Bob     43      47242\n"
"Susan   37      42932\n"
"Jill    45      45324\n"
"\n"
"In addition, the cells A9:B11 contain the following values:\n"
"Age     Salary\n"
"<30\n"
">40     >46000\n"
"\n"
"DAVERAGE(A1:C7, \"Salary\", A9:A11) equals 42296.3333.\n"
"DAVERAGE(A1:C7, \"Age\", A9:A11) equals 39.\n"
"DAVERAGE(A1:C7, \"Salary\", A9:B11) equals 40782.5.\n"
"DAVERAGE(A1:C7, \"Age\", A9:B11) equals 36.\n"
"\n"
"@SEEALSO=DCOUNT"
msgstr ""
"@FUNCTION=DAVERAGE\n"
"@SYNTAX=DAVERAGE(base-datos,campo,criterio)\n"
"@DESCRIPTION=La función DAVERAGE devuelve la media de los valores en una "
"lista o base de datos que coincida con las condiciones especificadas.\n"
"\n"
"@base-datos es un rango de celdas en las cuales las filas de información "
"relacionada son registros y las columnas de datos son campos. La primera "
"fila de la base de datos contiene etiquetas para cada columna.\n"
"\n"
"@campo especifica qué columna se usa en la función. Si @campo es un entero, "
"por ejemplo, 2, se usa la segunda columna. El campo puede ser también una "
"etiqueta de una columna. Por ejemplo, «Edad» se refiere a la columna con la "
"etiqueta «Edad» en el rango @base-datos.\n"
"\n"
"@criterio es el rango de celdas que contiene las condiciones especificadas. "
"La primera fila de un @criterio debe contener las etiquetas de los campos "
"para los que se aplican los criterios. Las celdas de abajo de las etiquetas "
"especifican condiciones, por ejemplo, «>3» o «<9». La condición de igualdad "
"puede darse simplemente dándole un valor, ej: «3» o «Juan».\n"
"Cada columna en @criterio especifica una condición distinta. Si una fila en "
"@base-datos coincide con una de las filas en @criterio entonces esa columna "
"se cuenta. Hablando técnicamente esto es un OR booleano entre las filas en "
"@criterio.\n"
"Si @criterio especifica más de una columna entonces cada una de las "
"condiciones en esa columna debe ser verdad para que la fila en @base-datos "
"coincida.Técnicamente hablando esto es un AND lógico entre las columnas en "
"cada fila de @criterios. \n"
"\n"
"@EXAMPLES=\n"
"Asumamos que el rango A1:C7 contiene los siguientes valores:\n"
"Nombre Edad  Salario\n"
"Juan   34   54342\n"
"Guillermo 35   22343\n"
"Clara   29   34323\n"
"Roberto 43   47242\n"
"Susana  37   42932\n"
"Julia    45   45324\n"
"\n"
"En suma, las celdas A9:B11 contienen los siguientes valores:\n"
"Edad  Salario\n"
"<30\n"
">40  >46000\n"
"\n"
"@EXAMPLES=\n"
"DAVERAGE(A1:C7, \"Salario\", A9:A11) es igual a 42296,3333.\n"
"DAVERAGE(A1:C7, \"Edad\", A9:A11) es igual a 39.\n"
"DAVERAGE(A1:C7, \"Salario\", A9:B11) es igual a 40782,5.\n"
"DAVERAGE(A1:C7, \"Edad\", A9:B11) es igual a 36.\n"
"\n"
"@SEEALSO=DCOUNT"

#: ../plugins/fn-database/functions.c:357
msgid ""
"@FUNCTION=DCOUNT\n"
"@SYNTAX=DCOUNT(database,field,criteria)\n"
"@DESCRIPTION=DCOUNT function counts the cells that contain numbers in a "
"database that match conditions specified.\n"
"\n"
"@database is a range of cells in which rows of related information are "
"records and columns of data are fields. The first row of a database contains "
"labels for each column. \n"
"\n"
"@field specifies which column is used in the function.  If @field is an "
"integer, for example 2, the second column is used. Field can also be the "
"label of a column.  For example, ``Age'' refers to the column with the label "
"``Age'' in @database range. \n"
"\n"
"@criteria is the range of cells which contains the specified conditions.  "
"The first row of a @criteria should contain the labels of the fields for "
"which the criteria are for.  Cells below the labels specify conditions, for "
"example, ``>3'' or ``<9''.  Equality condition can be given simply by "
"specifying a value, e.g. ``3'' or ``John''. \n"
"Each row in @criteria specifies a separate condition. If a row in @database "
"matches a row in @criteria, then that row is counted. Technically speaking, "
"this a boolean OR operation between the rows in @criteria.\n"
"If @criteria specifies more than one column, then each of the conditions in "
"the specified columns must be true for the row in @database to match. "
"Technically speaking, this is a boolean AND operation between the columns in "
"@criteria.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the range A1:C7 contain the following values:\n"
"Name    Age     Salary\n"
"John    34      54342\n"
"Bill    35      22343\n"
"Clark   29      34323\n"
"Bob     43      47242\n"
"Susan   37      42932\n"
"Jill    45      45324\n"
"\n"
"In addition, the cells A9:B11 contain the following values:\n"
"Age     Salary\n"
"<30\n"
">40     >46000\n"
"\n"
"DCOUNT(A1:C7, \"Salary\", A9:A11) equals 3.\n"
"DCOUNT(A1:C7, \"Salary\", A9:B11) equals 2.\n"
"DCOUNT(A1:C7, \"Name\", A9:B11) equals 0.\n"
"\n"
"@SEEALSO=DAVERAGE"
msgstr ""
"@FUNCTION=DCOUNT\n"
"@SYNTAX=DCOUNT(base-datos,campo,criterio)\n"
"@DESCRIPTION=La función DCOUNT cuenta las celdas que contienen números en "
"una base de datos que coincida con las condiciones especificadas.\n"
"\n"
"@base-datos es un rango de celdas en las cuales las filas de información "
"relacionada son registros y las columnas de datos son campos. La primera "
"fila de la base de datos contiene etiquetas para cada columna.\n"
"\n"
"@campo especifica qué columna se usa en la función. Si @campo es un entero, "
"por ejemplo, 2, se usa la segunda columna. El campo puede ser también una "
"etiqueta de una columna. Por ejemplo, «Edad» se refiere a la columna con la "
"etiqueta «Edad» en el rango @base-datos.\n"
"\n"
"@criterio es el rango de celdas que contiene las condiciones especificadas. "
"La primera fila de un @criterio debe contener las etiquetas de los campos "
"para los que se aplican los criterios. Las celdas de abajo de las etiquetas "
"especifican condiciones, por ejemplo, «>3» o «<9». La condición de igualdad "
"puede darse simplemente dándole un valor, ej: «3» o «Juan».\n"
"Cada columna en @criterio especifica una condición distinta. Si una fila en "
"@base-datos coincide con una de las filas en @criterio entonces esa columna "
"se cuenta. Hablando técnicamente esto es un OR booleano entre las filas en "
"@criterio.\n"
"Si @criterio especifica más de una columna entonces cada una de las "
"condiciones en esa columna debe ser verdad para que la fila en @base-datos "
"coincida.Técnicamente hablando esto es un AND lógico entre las columnas en "
"cada fila de @criterios. \n"
"\n"
"@EXAMPLES=\n"
"Asumamos que el rango A1:C7 contiene los siguientes valores:\n"
"Nombre Edad  Salario\n"
"Juan   34   54342\n"
"Guillermo 35   22343\n"
"Clara   29   34323\n"
"Roberto 43   47242\n"
"Susana  37   42932\n"
"Julia    45   45324\n"
"\n"
"En suma, las celdas A9:B11 contienen los siguientes valores:\n"
"Edad  Salario\n"
"<30\n"
">40  >46000\n"
"\n"
"@EXAMPLES=\n"
"DCOUNT(A1:C7, \"Salario\", A9:A11) es igual a 3.\n"
"DCOUNT(A1:C7, \"Salario\", A9:B11) es igual a 2.\n"
"DCOUNT(A1:C7, \"Nombre\", A9:B11) es igual a 0.\n"
"\n"
"@SEEALSO=DAVERAGE"

#: ../plugins/fn-database/functions.c:433
msgid ""
"@FUNCTION=DCOUNTA\n"
"@SYNTAX=DCOUNTA(database,field,criteria)\n"
"@DESCRIPTION=DCOUNTA function counts the cells that contain data in a "
"database that match conditions specified.\n"
"\n"
"@database is a range of cells in which rows of related information are "
"records and columns of data are fields. The first row of a database contains "
"labels for each column. \n"
"\n"
"@field specifies which column is used in the function.  If @field is an "
"integer, for example 2, the second column is used. Field can also be the "
"label of a column.  For example, ``Age'' refers to the column with the label "
"``Age'' in @database range. \n"
"\n"
"@criteria is the range of cells which contains the specified conditions.  "
"The first row of a @criteria should contain the labels of the fields for "
"which the criteria are for.  Cells below the labels specify conditions, for "
"example, ``>3'' or ``<9''.  Equality condition can be given simply by "
"specifying a value, e.g. ``3'' or ``John''. \n"
"Each row in @criteria specifies a separate condition. If a row in @database "
"matches a row in @criteria, then that row is counted. Technically speaking, "
"this a boolean OR operation between the rows in @criteria.\n"
"If @criteria specifies more than one column, then each of the conditions in "
"the specified columns must be true for the row in @database to match. "
"Technically speaking, this is a boolean AND operation between the columns in "
"@criteria.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the range A1:C7 contain the following values:\n"
"Name    Age     Salary\n"
"John    34      54342\n"
"Bill    35      22343\n"
"Clark   29      34323\n"
"Bob     43      47242\n"
"Susan   37      42932\n"
"Jill    45      45324\n"
"\n"
"In addition, the cells A9:B11 contain the following values:\n"
"Age     Salary\n"
"<30\n"
">40     >46000\n"
"\n"
"DCOUNTA(A1:C7, \"Salary\", A9:A11) equals 3.\n"
"DCOUNTA(A1:C7, \"Salary\", A9:B11) equals 2.\n"
"DCOUNTA(A1:C7, \"Name\", A9:B11) equals 2.\n"
"\n"
"@SEEALSO=DCOUNT"
msgstr ""
"@FUNCTION=DCOUNTA\n"
"@SYNTAX=DCOUNTA(base-datos,campo,criterio)\n"
"@DESCRIPTION=La función DCOUNTA cuenta las celdas que contienen datos en una "
"base de datos que coincide con las condiciones especificadas.\n"
"\n"
"@base-datos es un rango de celdas en las cuales las filas de información "
"relacionada son registros y las columnas de datos son campos. La primera "
"fila de la base de datos contiene etiquetas para cada columna.\n"
"\n"
"@campo especifica qué columna se usa en la función. Si @campo es un entero, "
"por ejemplo, 2, se usa la segunda columna. El campo puede ser también una "
"etiqueta de una columna. Por ejemplo, «Edad» se refiere a la columna con la "
"etiqueta «Edad» en el rango @base-datos.\n"
"\n"
"@criterio es el rango de celdas que contiene las condiciones especificadas. "
"La primera fila de un @criterio debe contener las etiquetas de los campos "
"para los que se aplican los criterios. Las celdas de abajo de las etiquetas "
"especifican condiciones, por ejemplo, «>3» o «<9». La condición de igualdad "
"puede darse simplemente dándole un valor, ej: «3» o «Juan».\n"
"Cada columna en @criterio especifica una condición distinta. Si una fila en "
"@base-datos coincide con una de las filas en @criterio entonces esa columna "
"se cuenta. Hablando técnicamente esto es un OR booleano entre las filas en "
"@criterio.\n"
"Si @criterio especifica más de una columna entonces cada una de las "
"condiciones en esa columna debe ser verdad para que la fila en @base-datos "
"coincida.Técnicamente hablando esto es un AND lógico entre las columnas en "
"cada fila de @criterios. \n"
"\n"
"@EXAMPLES=\n"
"Asumamos que el rango A1:C7 contiene los siguientes valores:\n"
"Nombre Edad  Salario\n"
"Juan   34   54342\n"
"Guillermo 35   22343\n"
"Clara   29   34323\n"
"Roberto 43   47242\n"
"Susana  37   42932\n"
"Julia    45   45324\n"
"\n"
"En suma, las celdas A9:B11 contienen los siguientes valores:\n"
"Edad  Salario\n"
"<30\n"
">40  >46000\n"
"\n"
"@EXAMPLES=\n"
"DCOUNTA(A1:C7, \"Salario\", A9:A11) es igual a 3.\n"
"DCOUNTA(A1:C7, \"Salario\", A9:B11) es igual a 2.\n"
"DCOUNTA(A1:C7, \"Nombre\", A9:B11) es igual a 2.\n"
"\n"
"@SEEALSO=DCOUNT"

#: ../plugins/fn-database/functions.c:507
msgid ""
"@FUNCTION=DGET\n"
"@SYNTAX=DGET(database,field,criteria)\n"
"@DESCRIPTION=DGET function returns a single value from a column that match "
"conditions specified.\n"
"\n"
"@database is a range of cells in which rows of related information are "
"records and columns of data are fields. The first row of a database contains "
"labels for each column. \n"
"\n"
"@field specifies which column is used in the function.  If @field is an "
"integer, for example 2, the second column is used. Field can also be the "
"label of a column.  For example, ``Age'' refers to the column with the label "
"``Age'' in @database range. \n"
"\n"
"@criteria is the range of cells which contains the specified conditions.  "
"The first row of a @criteria should contain the labels of the fields for "
"which the criteria are for.  Cells below the labels specify conditions, for "
"example, ``>3'' or ``<9''.  Equality condition can be given simply by "
"specifying a value, e.g. ``3'' or ``John''. \n"
"Each row in @criteria specifies a separate condition. If a row in @database "
"matches a row in @criteria, then that row is counted. Technically speaking, "
"this a boolean OR operation between the rows in @criteria.\n"
"If @criteria specifies more than one column, then each of the conditions in "
"the specified columns must be true for the row in @database to match. "
"Technically speaking, this is a boolean AND operation between the columns in "
"@criteria.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the range A1:C7 contain the following values:\n"
"Name    Age     Salary\n"
"John    34      54342\n"
"Bill    35      22343\n"
"Clark   29      34323\n"
"Bob     43      47242\n"
"Susan   37      42932\n"
"Jill    45      45324\n"
"\n"
"In addition, the cells A9:B11 contain the following values:\n"
"Age     Salary\n"
"<30\n"
">40     >46000\n"
"\n"
"* If none of the items match the conditions, DGET returns #VALUE! error.\n"
"* If more than one items match the conditions, DGET returns #NUM! error.\n"
"\n"
"DGET(A1:C7, \"Salary\", A9:A10) equals 34323.\n"
"DGET(A1:C7, \"Name\", A9:A10) equals \"Clark\".\n"
"\n"
"@SEEALSO=DCOUNT"
msgstr ""
"@FUNCTION=DGET\n"
"@SYNTAX=DGET(base-datos,campo,criterio)\n"
"@DESCRIPTION=La función DGET devuelve un valor sencillo de una columna que "
"coincida con las condiciones especificadas..\n"
"\n"
"@base-datos es un rango de celdas en las cuales las filas de información "
"relacionada son registros y las columnas de datos son campos. La primera "
"fila de la base de datos contiene etiquetas para cada columna.\n"
"\n"
"@campo especifica qué columna se usa en la función. Si @campo es un entero, "
"por ejemplo, 2, se usa la segunda columna. El campo puede ser también una "
"etiqueta de una columna. Por ejemplo, «Edad» se refiere a la columna con la "
"etiqueta «Edad» en el rango @base-datos.\n"
"\n"
"@criterio es el rango de celdas que contiene las condiciones especificadas. "
"La primera fila de un @criterio debe contener las etiquetas de los campos "
"para los que se aplican los criterios. Las celdas de abajo de las etiquetas "
"especifican condiciones, por ejemplo, «>3» o «<9». La condición de igualdad "
"puede darse simplemente dándole un valor, ej: «3» o «Juan».\n"
"Cada columna en @criterio especifica una condición distinta. Si una fila en "
"@base-datos coincide con una de las filas en @criterio entonces esa columna "
"se cuenta. Hablando técnicamente esto es un OR booleano entre las filas en "
"@criterio.\n"
"Si @criterio especifica más de una columna entonces cada una de las "
"condiciones en esa columna debe ser verdad para que la fila en @base-datos "
"coincida.Técnicamente hablando esto es un AND lógico entre las columnas en "
"cada fila de @criterios. \n"
"\n"
"@EXAMPLES=\n"
"Asumamos que el rango A1:C7 contiene los siguientes valores:\n"
"Nombre Edad  Salario\n"
"Juan 34  5434\n"
"Pedro 35  22343\n"
"Roberto 29  34323\n"
"María  43  47242\n"
"Susana 37  42932\n"
"Juliana 45  45324\n"
"\n"
"Además, las celdas A9:B11 contienen los siguientes valores:\n"
"Edad  Salario\n"
"<30\n"
">40  >46000\n"
"\n"
"* Si ninguno de los elementos coincide con las condiciones, DGET devuelve un "
"error #VALOR!.\n"
"* Si más de uno de los elementos coincide con las condiciones, DGET devuelve "
"un error #NÚM!.\n"
"\n"
"@EXAMPLES=\n"
"DGET(A1:C7, \"Salario\", A9:A10) igual a 34323.\n"
"DGET(A1:C7, \"Nombre\", A9:A10) igual a \"Roberto\".\n"
"\n"
"@SEEALSO=DCOUNT"

#: ../plugins/fn-database/functions.c:593
msgid ""
"@FUNCTION=DMAX\n"
"@SYNTAX=DMAX(database,field,criteria)\n"
"@DESCRIPTION=DMAX function returns the largest number in a column that match "
"conditions specified.\n"
"\n"
"@database is a range of cells in which rows of related information are "
"records and columns of data are fields. The first row of a database contains "
"labels for each column. \n"
"\n"
"@field specifies which column is used in the function.  If @field is an "
"integer, for example 2, the second column is used. Field can also be the "
"label of a column.  For example, ``Age'' refers to the column with the label "
"``Age'' in @database range. \n"
"\n"
"@criteria is the range of cells which contains the specified conditions.  "
"The first row of a @criteria should contain the labels of the fields for "
"which the criteria are for.  Cells below the labels specify conditions, for "
"example, ``>3'' or ``<9''.  Equality condition can be given simply by "
"specifying a value, e.g. ``3'' or ``John''. \n"
"Each row in @criteria specifies a separate condition. If a row in @database "
"matches a row in @criteria, then that row is counted. Technically speaking, "
"this a boolean OR operation between the rows in @criteria.\n"
"If @criteria specifies more than one column, then each of the conditions in "
"the specified columns must be true for the row in @database to match. "
"Technically speaking, this is a boolean AND operation between the columns in "
"@criteria.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the range A1:C7 contain the following values:\n"
"Name    Age     Salary\n"
"John    34      54342\n"
"Bill    35      22343\n"
"Clark   29      34323\n"
"Bob     43      47242\n"
"Susan   37      42932\n"
"Jill    45      45324\n"
"\n"
"In addition, the cells A9:B11 contain the following values:\n"
"Age     Salary\n"
"<30\n"
">40     >46000\n"
"\n"
"DMAX(A1:C7, \"Salary\", A9:A11) equals 47242.\n"
"DMAX(A1:C7, \"Age\", A9:A11) equals 45.\n"
"DMAX(A1:C7, \"Age\", A9:B11) equals 43.\n"
"\n"
"@SEEALSO=DMIN"
msgstr ""
"@FUNCTION=DMAX\n"
"@SYNTAX=DMAX(base-datos,campo,criterio)\n"
"@DESCRIPTION=La función DMAX devuelve el mayor número en una columna que "
"coincide con las condiciones especificadas.\n"
"\n"
"@base-datos es un rango de celdas en las cuales las filas de información "
"relacionada son registros y las columnas de datos son campos. La primera "
"fila de la base de datos contiene etiquetas para cada columna.\n"
"\n"
"@campo especifica qué columna se usa en la función. Si @campo es un entero, "
"por ejemplo, 2, se usa la segunda columna. El campo puede ser también una "
"etiqueta de una columna. Por ejemplo, «Edad» se refiere a la columna con la "
"etiqueta «Edad» en el rango @base-datos.\n"
"\n"
"@criterio es el rango de celdas que contiene las condiciones especificadas. "
"La primera fila de un @criterio debe contener las etiquetas de los campos "
"para los que se aplican los criterios. Las celdas de abajo de las etiquetas "
"especifican condiciones, por ejemplo, «>3» o «<9». La condición de igualdad "
"puede darse simplemente dándole un valor, ej: «3» o «Juan».\n"
"Cada columna en @criterio especifica una condición distinta. Si una fila en "
"@base-datos coincide con una de las filas en @criterio entonces esa columna "
"se cuenta. Hablando técnicamente esto es un OR booleano entre las filas en "
"@criterio.\n"
"Si @criterio especifica más de una columna entonces cada una de las "
"condiciones en esa columna debe ser verdad para que la fila en @base-datos "
"coincida.Técnicamente hablando esto es un AND lógico entre las columnas en "
"cada fila de @criterios. \n"
"\n"
"@EXAMPLES=\n"
"Asumamos que el rango A1:C7 contiene los siguientes valores:\n"
"Nombre Edad  Salario\n"
"Juan 34  5434\n"
"Pedro 35  22343\n"
"Roberto 29  34323\n"
"María  43  47242\n"
"Susana 37  42932\n"
"Juliana 45  45324\n"
"\n"
"Además, las celdas A9:B11 contienen los siguientes valores:\n"
"Edad  Salario\n"
"<30\n"
">40  >46000\n"
"\n"
"@EXAMPLES=\n"
"DMAX(A1:C7, \"Salario\", A9:A11) igual a 47242.\n"
"DMAX(A1:C7, \"Edad\", A9:A11) igual a a 45.\n"
"DMAX(A1:C7,\"Edad\",A9:B11) igual a 43.\n"
"\n"
"@SEEALSO=DMIN"

#: ../plugins/fn-database/functions.c:671
msgid ""
"@FUNCTION=DMIN\n"
"@SYNTAX=DMIN(database,field,criteria)\n"
"@DESCRIPTION=DMIN function returns the smallest number in a column that "
"match conditions specified.\n"
"\n"
"@database is a range of cells in which rows of related information are "
"records and columns of data are fields. The first row of a database contains "
"labels for each column. \n"
"\n"
"@field specifies which column is used in the function.  If @field is an "
"integer, for example 2, the second column is used. Field can also be the "
"label of a column.  For example, ``Age'' refers to the column with the label "
"``Age'' in @database range. \n"
"\n"
"@criteria is the range of cells which contains the specified conditions.  "
"The first row of a @criteria should contain the labels of the fields for "
"which the criteria are for.  Cells below the labels specify conditions, for "
"example, ``>3'' or ``<9''.  Equality condition can be given simply by "
"specifying a value, e.g. ``3'' or ``John''. \n"
"Each row in @criteria specifies a separate condition. If a row in @database "
"matches a row in @criteria, then that row is counted. Technically speaking, "
"this a boolean OR operation between the rows in @criteria.\n"
"If @criteria specifies more than one column, then each of the conditions in "
"the specified columns must be true for the row in @database to match. "
"Technically speaking, this is a boolean AND operation between the columns in "
"@criteria.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the range A1:C7 contain the following values:\n"
"Name    Age     Salary\n"
"John    34      54342\n"
"Bill    35      22343\n"
"Clark   29      34323\n"
"Bob     43      47242\n"
"Susan   37      42932\n"
"Jill    45      45324\n"
"\n"
"In addition, the cells A9:B11 contain the following values:\n"
"Age     Salary\n"
"<30\n"
">40     >46000\n"
"\n"
"DMIN(A1:C7, \"Salary\", A9:B11) equals 34323.\n"
"DMIN(A1:C7, \"Age\", A9:B11) equals 29.\n"
"\n"
"@SEEALSO=DMAX"
msgstr ""
"@FUNCTION=DMIN\n"
"@SYNTAX=DMIN(base-datos,campo,criterio)\n"
"@DESCRIPTION=La función DMIN devuelve el mínimo número en una columna que "
"coincide con las condiciones especificadas.\n"
"\n"
"@base-datos es un rango de celdas en las cuales las filas de información "
"relacionada son registros y las columnas de datos son campos. La primera "
"fila de la base de datos contiene etiquetas para cada columna.\n"
"\n"
"@campo especifica qué columna se usa en la función. Si @campo es un entero, "
"por ejemplo, 2, se usa la segunda columna. El campo puede ser también una "
"etiqueta de una columna. Por ejemplo, «Edad» se refiere a la columna con la "
"etiqueta «Edad» en el rango @base-datos.\n"
"\n"
"@criterio es el rango de celdas que contiene las condiciones especificadas. "
"La primera fila de un @criterio debe contener las etiquetas de los campos "
"para los que se aplican los criterios. Las celdas de abajo de las etiquetas "
"especifican condiciones, por ejemplo, «>3» o «<9». La condición de igualdad "
"puede darse simplemente dándole un valor, ej: «3» o «Juan».\n"
"Cada columna en @criterio especifica una condición distinta. Si una fila en "
"@base-datos coincide con una de las filas en @criterio entonces esa columna "
"se cuenta. Hablando técnicamente esto es un OR booleano entre las filas en "
"@criterio.\n"
"Si @criterio especifica más de una columna entonces cada una de las "
"condiciones en esa columna debe ser verdad para que la fila en @base-datos "
"coincida.Técnicamente hablando esto es un AND lógico entre las columnas en "
"cada fila de @criterios. \n"
"\n"
"@EXAMPLES=\n"
"Asumamos que el rango A1:C7 contiene los siguientes valores:\n"
"Nombre Edad  Salario\n"
"Juan 34  5434\n"
"Pedro 35  22343\n"
"Roberto 29  34323\n"
"María  43  47242\n"
"Susana 37  42932\n"
"Juliana 45  45324\n"
"\n"
"Además, las celdas A9:B11 contienen los siguientes valores:\n"
"Edad  Salario\n"
"<30\n"
">40  >46000\n"
"\n"
"@EXAMPLES=\n"
"DMIN(A1:C7, \"Salario\", A9:A11) igual a 34323.\n"
"DMIN(A1:C7, \"Edad\", A9:A11) igual a a 29.\n"
"\n"
"@SEEALSO=DMAX"

#: ../plugins/fn-database/functions.c:746
msgid ""
"@FUNCTION=DPRODUCT\n"
"@SYNTAX=DPRODUCT(database,field,criteria)\n"
"@DESCRIPTION=DPRODUCT function returns the product of numbers in a column "
"that match conditions specified.\n"
"\n"
"@database is a range of cells in which rows of related information are "
"records and columns of data are fields. The first row of a database contains "
"labels for each column. \n"
"\n"
"@field specifies which column is used in the function.  If @field is an "
"integer, for example 2, the second column is used. Field can also be the "
"label of a column.  For example, ``Age'' refers to the column with the label "
"``Age'' in @database range. \n"
"\n"
"@criteria is the range of cells which contains the specified conditions.  "
"The first row of a @criteria should contain the labels of the fields for "
"which the criteria are for.  Cells below the labels specify conditions, for "
"example, ``>3'' or ``<9''.  Equality condition can be given simply by "
"specifying a value, e.g. ``3'' or ``John''. \n"
"Each row in @criteria specifies a separate condition. If a row in @database "
"matches a row in @criteria, then that row is counted. Technically speaking, "
"this a boolean OR operation between the rows in @criteria.\n"
"If @criteria specifies more than one column, then each of the conditions in "
"the specified columns must be true for the row in @database to match. "
"Technically speaking, this is a boolean AND operation between the columns in "
"@criteria.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the range A1:C7 contain the following values:\n"
"Name    Age     Salary\n"
"John    34      54342\n"
"Bill    35      22343\n"
"Clark   29      34323\n"
"Bob     43      47242\n"
"Susan   37      42932\n"
"Jill    45      45324\n"
"\n"
"In addition, the cells A9:B11 contain the following values:\n"
"Age     Salary\n"
"<30\n"
">40     >46000\n"
"\n"
"DPRODUCT(A1:C7, \"Age\", A9:B11) equals 1247.\n"
"\n"
"@SEEALSO=DSUM"
msgstr ""
"@FUNCTION=DPRODUCT\n"
"@SYNTAX=DPRODUCT(base-datos,campo,criterio\n"
"@DESCRIPTION=La función DPRODUCT devuelve el producto de números en una "
"columna que coincide con las condiciones especificadas.\n"
"\n"
"@base-datos es un rango de celdas en las cuales las filas de información "
"relacionada son registros y las columnas de datos son campos. La primera "
"fila de la base de datos contiene etiquetas para cada columna.\n"
"\n"
"@campo especifica qué columna se usa en la función. Si @campo es un entero, "
"por ejemplo, 2, se usa la segunda columna. El campo puede ser también una "
"etiqueta de una columna. Por ejemplo, «Edad» se refiere a la columna con la "
"etiqueta «Edad» en el rango @base-datos.\n"
"\n"
"@criterio es el rango de celdas que contiene las condiciones especificadas. "
"La primera fila de un @criterio debe contener las etiquetas de los campos "
"para los que se aplican los criterios. Las celdas de abajo de las etiquetas "
"especifican condiciones, por ejemplo, «>3» o «<9». La condición de igualdad "
"puede darse simplemente dándole un valor, ej: «3» o «Juan».\n"
"Cada columna en @criterio especifica una condición distinta. Si una fila en "
"@base-datos coincide con una de las filas en @criterio entonces esa columna "
"se cuenta. Hablando técnicamente esto es un OR booleano entre las filas en "
"@criterio.\n"
"Si @criterio especifica más de una columna entonces cada una de las "
"condiciones en esa columna debe ser verdad para que la fila en @base-datos "
"coincida.Técnicamente hablando esto es un AND lógico entre las columnas en "
"cada fila de @criterios. \n"
"\n"
"@EXAMPLES=\n"
"Asumamos que el rango A1:C7 contiene los siguientes valores:\n"
"Nombre Edad  Salario\n"
"Juan 34  5434\n"
"Pedro 35  22343\n"
"Roberto 29  34323\n"
"María  43  47242\n"
"Susana 37  42932\n"
"Juliana 45  45324\n"
"\n"
"Además, las celdas A9:B11 contienen los siguientes valores:\n"
"Edad  Salario\n"
"<30\n"
">40  >46000\n"
"\n"
"@EXAMPLES=\n"
"DPRODUCT(A1:C7, \"Edad\", A9:B11) igual a 1247.\n"
"\n"
"@SEEALSO=DSUM"

#: ../plugins/fn-database/functions.c:821
msgid ""
"@FUNCTION=DSTDEV\n"
"@SYNTAX=DSTDEV(database,field,criteria)\n"
"@DESCRIPTION=DSTDEV function returns the estimate of the standard deviation "
"of a population based on a sample. The population consists of numbers that "
"match conditions specified.\n"
"\n"
"@database is a range of cells in which rows of related information are "
"records and columns of data are fields. The first row of a database contains "
"labels for each column. \n"
"\n"
"@field specifies which column is used in the function.  If @field is an "
"integer, for example 2, the second column is used. Field can also be the "
"label of a column.  For example, ``Age'' refers to the column with the label "
"``Age'' in @database range. \n"
"\n"
"@criteria is the range of cells which contains the specified conditions.  "
"The first row of a @criteria should contain the labels of the fields for "
"which the criteria are for.  Cells below the labels specify conditions, for "
"example, ``>3'' or ``<9''.  Equality condition can be given simply by "
"specifying a value, e.g. ``3'' or ``John''. \n"
"Each row in @criteria specifies a separate condition. If a row in @database "
"matches a row in @criteria, then that row is counted. Technically speaking, "
"this a boolean OR operation between the rows in @criteria.\n"
"If @criteria specifies more than one column, then each of the conditions in "
"the specified columns must be true for the row in @database to match. "
"Technically speaking, this is a boolean AND operation between the columns in "
"@criteria.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the range A1:C7 contain the following values:\n"
"Name    Age     Salary\n"
"John    34      54342\n"
"Bill    35      22343\n"
"Clark   29      34323\n"
"Bob     43      47242\n"
"Susan   37      42932\n"
"Jill    45      45324\n"
"\n"
"In addition, the cells A9:B11 contain the following values:\n"
"Age     Salary\n"
"<30\n"
">40     >46000\n"
"\n"
"DSTDEV(A1:C7, \"Age\", A9:B11) equals 9.89949.\n"
"DSTDEV(A1:C7, \"Salary\", A9:B11) equals 9135.112506.\n"
"\n"
"@SEEALSO=DSTDEVP"
msgstr ""
"@FUNCTION=DSTDEV\n"
"@SYNTAX=DSTDEV(base-datos,campo,criterio)\n"
"@DESCRIPTION=La función DSTDEV devuelve la estimación de la desviación "
"estándar de una población basada en una muestra. La población consiste en "
"números que coincidan con las condiciones especificadas\n"
"\n"
"@base-datos es un rango de celdas en las cuales las filas de información "
"relacionada son registros y las columnas de datos son campos. La primera "
"fila de la base de datos contiene etiquetas para cada columna.\n"
"\n"
"@campo especifica qué columna se usa en la función. Si @campo es un entero, "
"por ejemplo, 2, se usa la segunda columna. El campo puede ser también una "
"etiqueta de una columna. Por ejemplo, «Edad» se refiere a la columna con la "
"etiqueta «Edad» en el rango @base-datos.\n"
"\n"
"@criterio es el rango de celdas que contiene las condiciones especificadas. "
"La primera fila de un @criterio debe contener las etiquetas de los campos "
"para los que se aplican los criterios. Las celdas de abajo de las etiquetas "
"especifican condiciones, por ejemplo, «>3» o «<9». La condición de igualdad "
"puede darse simplemente dándole un valor, ej: «3» o «Juan».\n"
"Cada columna en @criterio especifica una condición distinta. Si una fila en "
"@base-datos coincide con una de las filas en @criterio entonces esa columna "
"se cuenta. Hablando técnicamente esto es un OR booleano entre las filas en "
"@criterio.\n"
"Si @criterio especifica más de una columna entonces cada una de las "
"condiciones en esa columna debe ser verdad para que la fila en @base-datos "
"coincida.Técnicamente hablando esto es un AND lógico entre las columnas en "
"cada fila de @criterios. \n"
"\n"
"@EXAMPLES=\n"
"Asumamos que el rango A1:C7 contiene los siguientes valores:\n"
"Nombre Edad Salario\n"
"Juan 34  5434\n"
"Pedro 35  22343\n"
"Roberto 29  34323\n"
"María 43  47242\n"
"Susana 37  42932\n"
"Juliana 45  45324\n"
"\n"
"Además, las celdas A9:B11 contienen los siguientes valores:\n"
"Edad  Salario\n"
"<30\n"
">40  >46000\n"
"\n"
"@EXAMPLES=\n"
"DSTDEV(A1:C7, \"Edad\", A9:B11) es igual a 9,89949.\n"
"DSTDEV(A1:C7, \"Salario\", A9:B11) es igual a 9135,112506.\n"
"\n"
"@SEEALSO=DSTDEVP"

#: ../plugins/fn-database/functions.c:897
msgid ""
"@FUNCTION=DSTDEVP\n"
"@SYNTAX=DSTDEVP(database,field,criteria)\n"
"@DESCRIPTION=DSTDEVP function returns the standard deviation of a population "
"based on the entire population. The population consists of numbers that "
"match conditions specified.\n"
"\n"
"@database is a range of cells in which rows of related information are "
"records and columns of data are fields. The first row of a database contains "
"labels for each column. \n"
"\n"
"@field specifies which column is used in the function.  If @field is an "
"integer, for example 2, the second column is used. Field can also be the "
"label of a column.  For example, ``Age'' refers to the column with the label "
"``Age'' in @database range. \n"
"\n"
"@criteria is the range of cells which contains the specified conditions.  "
"The first row of a @criteria should contain the labels of the fields for "
"which the criteria are for.  Cells below the labels specify conditions, for "
"example, ``>3'' or ``<9''.  Equality condition can be given simply by "
"specifying a value, e.g. ``3'' or ``John''. \n"
"Each row in @criteria specifies a separate condition. If a row in @database "
"matches a row in @criteria, then that row is counted. Technically speaking, "
"this a boolean OR operation between the rows in @criteria.\n"
"If @criteria specifies more than one column, then each of the conditions in "
"the specified columns must be true for the row in @database to match. "
"Technically speaking, this is a boolean AND operation between the columns in "
"@criteria.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the range A1:C7 contain the following values:\n"
"Name    Age     Salary\n"
"John    34      54342\n"
"Bill    35      22343\n"
"Clark   29      34323\n"
"Bob     43      47242\n"
"Susan   37      42932\n"
"Jill    45      45324\n"
"\n"
"In addition, the cells A9:B11 contain the following values:\n"
"Age     Salary\n"
"<30\n"
">40     >46000\n"
"\n"
"DSTDEVP(A1:C7, \"Age\", A9:B11) equals 7.\n"
"DSTDEVP(A1:C7, \"Salary\", A9:B11) equals 6459.5.\n"
"\n"
"@SEEALSO=DSTDEV"
msgstr ""
"@FUNCTION=DSTDEVP\n"
"@SYNTAX=DSTDEVP(base-datos,campo,criterio)\n"
"@DESCRIPTION=La función DSTDEVP devuelve la desviación estándar de una "
"población basada en poblaciones completas. Las poblaciones consisten en "
"números que coinciden con las condiciones especificadas\n"
"\n"
"@base-datos es un rango de celdas en las cuales las filas de información "
"relacionada son registros y las columnas de datos son campos. La primera "
"fila de la base de datos contiene etiquetas para cada columna.\n"
"\n"
"@campo especifica qué columna se usa en la función. Si @campo es un entero, "
"por ejemplo, 2, se usa la segunda columna. El campo puede ser también una "
"etiqueta de una columna. Por ejemplo, «Edad» se refiere a la columna con la "
"etiqueta «Edad» en el rango @base-datos.\n"
"\n"
"@criterio es el rango de celdas que contiene las condiciones especificadas. "
"La primera fila de un @criterio debe contener las etiquetas de los campos "
"para los que se aplican los criterios. Las celdas de abajo de las etiquetas "
"especifican condiciones, por ejemplo, «>3» o «<9». La condición de igualdad "
"puede darse simplemente dándole un valor, ej: «3» o «Juan».\n"
"Cada columna en @criterio especifica una condición distinta. Si una fila en "
"@base-datos coincide con una de las filas en @criterio entonces esa columna "
"se cuenta. Hablando técnicamente esto es un OR booleano entre las filas en "
"@criterio.\n"
"Si @criterio especifica más de una columna entonces cada una de las "
"condiciones en esa columna debe ser verdad para que la fila en @base-datos "
"coincida.Técnicamente hablando esto es un AND lógico entre las columnas en "
"cada fila de @criterios. \n"
"\n"
"@EXAMPLES=\n"
"Asumamos que el rango A1:C7 contiene los siguientes valores:\n"
"Nombre Edad Salario\n"
"Juan 34  5434\n"
"Pedro 35  22343\n"
"Roberto 29  34323\n"
"María 43  47242\n"
"Susana 37  42932\n"
"Juliana 45  45324\n"
"\n"
"Además, las celdas A9:B11 contienen los siguientes valores:\n"
"Edad  Salario\n"
"<30\n"
">40  >46000\n"
"\n"
"@EXAMPLES=\n"
"DSTDEVP(A1:C7, \"Edad\", A9:B11) igual a 7.\n"
"DSTDEVP(A1:C7, \"Salario\", A9:B11) igual a 6459.5.\n"
"\n"
"@SEEALSO=DSTDEV"

#: ../plugins/fn-database/functions.c:973
msgid ""
"@FUNCTION=DSUM\n"
"@SYNTAX=DSUM(database,field,criteria)\n"
"@DESCRIPTION=DSUM function returns the sum of numbers in a column that match "
"conditions specified.\n"
"\n"
"@database is a range of cells in which rows of related information are "
"records and columns of data are fields. The first row of a database contains "
"labels for each column. \n"
"\n"
"@field specifies which column is used in the function.  If @field is an "
"integer, for example 2, the second column is used. Field can also be the "
"label of a column.  For example, ``Age'' refers to the column with the label "
"``Age'' in @database range. \n"
"\n"
"@criteria is the range of cells which contains the specified conditions.  "
"The first row of a @criteria should contain the labels of the fields for "
"which the criteria are for.  Cells below the labels specify conditions, for "
"example, ``>3'' or ``<9''.  Equality condition can be given simply by "
"specifying a value, e.g. ``3'' or ``John''. \n"
"Each row in @criteria specifies a separate condition. If a row in @database "
"matches a row in @criteria, then that row is counted. Technically speaking, "
"this a boolean OR operation between the rows in @criteria.\n"
"If @criteria specifies more than one column, then each of the conditions in "
"the specified columns must be true for the row in @database to match. "
"Technically speaking, this is a boolean AND operation between the columns in "
"@criteria.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the range A1:C7 contain the following values:\n"
"Name    Age     Salary\n"
"John    34      54342\n"
"Bill    35      22343\n"
"Clark   29      34323\n"
"Bob     43      47242\n"
"Susan   37      42932\n"
"Jill    45      45324\n"
"\n"
"In addition, the cells A9:B11 contain the following values:\n"
"Age     Salary\n"
"<30\n"
">40     >46000\n"
"\n"
"DSUM(A1:C7, \"Age\", A9:B11) equals 72.\n"
"DSUM(A1:C7, \"Salary\", A9:B11) equals 81565.\n"
"\n"
"@SEEALSO=DPRODUCT"
msgstr ""
"@FUNCTION=DSUM\n"
"@SYNTAX=DSUM(base-datos,campo,criterio)\n"
"@DESCRIPTION=La función DSUM devuelve la suma de números en una columna que "
"coincida con condiciones especificadas.\n"
"\n"
"@base-datos es un rango de celdas en las cuales las filas de información "
"relacionada son registros y las columnas de datos son campos. La primera "
"fila de la base de datos contiene etiquetas para cada columna.\n"
"\n"
"@campo especifica qué columna se usa en la función. Si @campo es un entero, "
"por ejemplo, 2, se usa la segunda columna. El campo puede ser también una "
"etiqueta de una columna. Por ejemplo, «Edad» se refiere a la columna con la "
"etiqueta «Edad» en el rango @base-datos.\n"
"\n"
"@criterio es el rango de celdas que contiene las condiciones especificadas. "
"La primera fila de un @criterio debe contener las etiquetas de los campos "
"para los que se aplican los criterios. Las celdas de abajo de las etiquetas "
"especifican condiciones, por ejemplo, «>3» o «<9». La condición de igualdad "
"puede darse simplemente dándole un valor, ej: «3» o «Juan».\n"
"Cada columna en @criterio especifica una condición distinta. Si una fila en "
"@base-datos coincide con una de las filas en @criterio entonces esa columna "
"se cuenta. Hablando técnicamente esto es un OR booleano entre las filas en "
"@criterio.\n"
"Si @criterio especifica más de una columna entonces cada una de las "
"condiciones en esa columna debe ser verdad para que la fila en @base-datos "
"coincida.Técnicamente hablando esto es un AND lógico entre las columnas en "
"cada fila de @criterios. \n"
"\n"
"@EXAMPLES=\n"
"Asumamos que el rango A1:C7 contiene los siguientes valores:\n"
"Nombre Edad  Salario\n"
"Juan 34  5434\n"
"Pedro 35  22343\n"
"Roberto 29  34323\n"
"María  43  47242\n"
"Susana 37  42932\n"
"Juliana 45  45324\n"
"\n"
"Además, las celdas A9:B11 contienen los siguientes valores:\n"
"Edad  Salario\n"
"<30\n"
">40  >46000\n"
"\n"
"@EXAMPLES=\n"
"DSUM(A1:C7, \"Edad\", A9:B11) es igual a 72.\n"
"DSUM(A1:C7, \"Salario\", A9:B11) es igual a 81565.\n"
"\n"
"@SEEALSO=DPRODUCT"

#: ../plugins/fn-database/functions.c:1049
msgid ""
"@FUNCTION=DVAR\n"
"@SYNTAX=DVAR(database,field,criteria)\n"
"@DESCRIPTION=DVAR function returns the estimate of variance of a population "
"based on a sample. The population consists of numbers that match conditions "
"specified.\n"
"\n"
"@database is a range of cells in which rows of related information are "
"records and columns of data are fields. The first row of a database contains "
"labels for each column. \n"
"\n"
"@field specifies which column is used in the function.  If @field is an "
"integer, for example 2, the second column is used. Field can also be the "
"label of a column.  For example, ``Age'' refers to the column with the label "
"``Age'' in @database range. \n"
"\n"
"@criteria is the range of cells which contains the specified conditions.  "
"The first row of a @criteria should contain the labels of the fields for "
"which the criteria are for.  Cells below the labels specify conditions, for "
"example, ``>3'' or ``<9''.  Equality condition can be given simply by "
"specifying a value, e.g. ``3'' or ``John''. \n"
"Each row in @criteria specifies a separate condition. If a row in @database "
"matches a row in @criteria, then that row is counted. Technically speaking, "
"this a boolean OR operation between the rows in @criteria.\n"
"If @criteria specifies more than one column, then each of the conditions in "
"the specified columns must be true for the row in @database to match. "
"Technically speaking, this is a boolean AND operation between the columns in "
"@criteria.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the range A1:C7 contain the following values:\n"
"Name    Age     Salary\n"
"John    34      54342\n"
"Bill    35      22343\n"
"Clark   29      34323\n"
"Bob     43      47242\n"
"Susan   37      42932\n"
"Jill    45      45324\n"
"\n"
"In addition, the cells A9:B11 contain the following values:\n"
"Age     Salary\n"
"<30\n"
">40     >46000\n"
"\n"
"DVAR(A1:C7, \"Age\", A9:B11) equals 98.\n"
"DVAR(A1:C7, \"Salary\", A9:B11) equals 83450280.5.\n"
"\n"
"@SEEALSO=DVARP"
msgstr ""
"@FUNCTION=DVAR\n"
"@SYNTAX=DVAR(base-datos,campo,criterio)\n"
"@DESCRIPTION=La función DVAR devuelve la estimación de la varianza de una "
"población basada en una muestra. Las poblaciones consisten en números que "
"coinciden con las condiciones especificadas.\n"
"\n"
"@base-datos es un rango de celdas en las cuales las filas de información "
"relacionada son registros y las columnas de datos son campos. La primera "
"fila de la base de datos contiene etiquetas para cada columna.\n"
"\n"
"@campo especifica qué columna se usa en la función. Si @campo es un entero, "
"por ejemplo, 2, se usa la segunda columna. El campo puede ser también una "
"etiqueta de una columna. Por ejemplo, «Edad» se refiere a la columna con la "
"etiqueta «Edad» en el rango @base-datos.\n"
"\n"
"@criterio es el rango de celdas que contiene las condiciones especificadas. "
"La primera fila de un @criterio debe contener las etiquetas de los campos "
"para los que se aplican los criterios. Las celdas de abajo de las etiquetas "
"especifican condiciones, por ejemplo, «>3» o «<9». La condición de igualdad "
"puede darse simplemente dándole un valor, ej: «3» o «Juan».\n"
"Cada columna en @criterio especifica una condición distinta. Si una fila en "
"@base-datos coincide con una de las filas en @criterio entonces esa columna "
"se cuenta. Hablando técnicamente esto es un OR booleano entre las filas en "
"@criterio.\n"
"Si @criterio especifica más de una columna entonces cada una de las "
"condiciones en esa columna debe ser cierta para que la fila en @base-datos "
"coincida Técnicamente hablando esto es un AND lógico entre las columnas en "
"@criterios). \n"
"\n"
"@EXAMPLES=\n"
"Asumamos que el rango A1:C7 contiene los siguientes valores:\n"
"Nombre Edad Salario\n"
"Juan 34  5434\n"
"Pedro 35  22343\n"
"Roberto 29  34323\n"
"María 43  47242\n"
"Susana 37  42932\n"
"Juliana 45  45324\n"
"\n"
"Además, las celdas A9:B11 contienen los siguientes valores:\n"
"Edad  Salario\n"
"<30\n"
">40  >46000\n"
"\n"
"@EXAMPLES=\n"
"DVAR(A1:C7, \"Edad\", A9:B11) es igual a 98.\n"
"DVAR(A1:C7, \"Salario\", A9:B11) es igual a 83450280,5.\n"
"\n"
"@SEEALSO=DVARP"

#: ../plugins/fn-database/functions.c:1125
msgid ""
"@FUNCTION=DVARP\n"
"@SYNTAX=DVARP(database,field,criteria)\n"
"@DESCRIPTION=DVARP function returns the variance of a population based on "
"the entire population. The population consists of numbers that match "
"conditions specified.\n"
"\n"
"@database is a range of cells in which rows of related information are "
"records and columns of data are fields. The first row of a database contains "
"labels for each column. \n"
"\n"
"@field specifies which column is used in the function.  If @field is an "
"integer, for example 2, the second column is used. Field can also be the "
"label of a column.  For example, ``Age'' refers to the column with the label "
"``Age'' in @database range. \n"
"\n"
"@criteria is the range of cells which contains the specified conditions.  "
"The first row of a @criteria should contain the labels of the fields for "
"which the criteria are for.  Cells below the labels specify conditions, for "
"example, ``>3'' or ``<9''.  Equality condition can be given simply by "
"specifying a value, e.g. ``3'' or ``John''. \n"
"Each row in @criteria specifies a separate condition. If a row in @database "
"matches a row in @criteria, then that row is counted. Technically speaking, "
"this a boolean OR operation between the rows in @criteria.\n"
"If @criteria specifies more than one column, then each of the conditions in "
"the specified columns must be true for the row in @database to match. "
"Technically speaking, this is a boolean AND operation between the columns in "
"@criteria.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the range A1:C7 contain the following values:\n"
"Name    Age     Salary\n"
"John    34      54342\n"
"Bill    35      22343\n"
"Clark   29      34323\n"
"Bob     43      47242\n"
"Susan   37      42932\n"
"Jill    45      45324\n"
"\n"
"In addition, the cells A9:B11 contain the following values:\n"
"Age     Salary\n"
"<30\n"
">40     >46000\n"
"\n"
"DVARP(A1:C7, \"Age\", A9:B11) equals 49.\n"
"DVARP(A1:C7, \"Salary\", A9:B11) equals 41725140.25.\n"
"\n"
"@SEEALSO=DVAR"
msgstr ""
"@FUNCTION=DVARP\n"
"@SYNTAX=DVARP(base-datos,campo,criterio)\n"
"@DESCRIPTION=La función DVARP devuelve la varianza de una población basada "
"en poblaciones completas. Las poblaciones consisten en números que coinciden "
"con las condiciones especificadas.\n"
"\n"
"@base-datos es un rango de celdas en las cuales las filas de información "
"relacionada son registros y las columnas de datos son campos. La primera "
"fila de la base de datos contiene etiquetas para cada columna.\n"
"\n"
"@campo especifica qué columna se usa en la función. Si @campo es un entero, "
"por ejemplo, 2, se usa la segunda columna. El campo puede ser también una "
"etiqueta de una columna. Por ejemplo, «Edad» se refiere a la columna con la "
"etiqueta «Edad» en el rango @base-datos.\n"
"\n"
"@criterio es el rango de celdas que contiene las condiciones especificadas. "
"La primera fila de un @criterio debe contener las etiquetas de los campos "
"para los que se aplican los criterios. Las celdas de abajo de las etiquetas "
"especifican condiciones, por ejemplo, «>3» o «<9». La condición de igualdad "
"puede darse simplemente dándole un valor, ej: «3» o «Juan».\n"
"Cada columna en @criterio especifica una condición distinta. Si una fila en "
"@base-datos coincide con una de las filas en @criterio entonces esa columna "
"se cuenta. Hablando técnicamente, esto es un OR booleano entre las filas en "
"@criterio.\n"
"Si @criterio especifica más de una columna entonces cada una de las "
"condiciones en las columnas especificadas cierta para que la fila en @base-"
"datos coincida. Técnicamente hablando AND lógico entre las columnas en "
"@criterios). \n"
"\n"
"@EXAMPLES=\n"
"Asumamos que el rango A1:C7 contiene los siguientes valores:\n"
"Nombre Edad Salario\n"
"Juan 34  5434\n"
"Pedro 35  22343\n"
"Roberto 29  34323\n"
"María 43  47242\n"
"Susana 37  42932\n"
"Juliana 45  45324\n"
"\n"
"Además, las celdas A9:B11 contienen los siguientes valores:\n"
"Edad  Salario\n"
"<30\n"
">40  >46000\n"
"\n"
"@EXAMPLES=\n"
"DVARP(A1:C7, \"Edad\", A9:B11) es igual a 49.\n"
"DVARP(A1:C7, \"Salario\", A9:B11) es igual a 41725140,25.\n"
"\n"
"@SEEALSO=DVAR"

#: ../plugins/fn-database/functions.c:1201
msgid ""
"@FUNCTION=GETPIVOTDATA\n"
"@SYNTAX=GETPIVOTDATA(pivot_table,field_name)\n"
"@DESCRIPTION=GETPIVOTDATA function fetches summary data from a pivot table. "
"@pivot_table is a cell range containing the pivot table. @field_name is the "
"name of the field of which you want the summary data.\n"
"\n"
"* If the summary data is unavailable, GETPIVOTDATA returns #REF! error.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO="
msgstr ""
"@FUNCTION=GETPIVOTDATA\n"
"@SYNTAX=GETPIVOTDATA(tabla_pivote;nombre_campo)\n"
"@DESCRIPTION=Recupera un resumen de datos desde la tabla pivote. "
"@tabla_pivote es un rango de celdas que contienen la tabla pivote. "
"@nombre_campo es el nombre del campo del cual se desea el resumen de datos.\n"
"\n"
"* Si no está disponible el resumen de datos, GETPIVOTDATA devuelve el error "
"#REF!.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO="

#: ../plugins/fn-date/functions.c:99
msgid ""
"@FUNCTION=DATE\n"
"@SYNTAX=DATE (year,month,day)\n"
"@DESCRIPTION=DATE returns the number of days since the 1st of January of 1900"
"(the date serial number) for the given year, month and day.\n"
"\n"
"* If @month < 1 or @month > 12, the year will be corrected.  A similar "
"correction takes place for days.\n"
"* The @years should be at least 1900.  If @years < 1900, it is assumed to be "
"1900 + @years.\n"
"* If the given date is not valid, DATE returns #NUM! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"DATE(2001, 3, 30) returns 'Mar 30, 2001'.\n"
" \n"
"@SEEALSO=TODAY, NOW"
msgstr ""
"@FUNCTION=DATE\n"
"@SYNTAX=DATE (año,mes,día)\n"
"@DESCRIPTION=Calcula la cantidad de días desde el 1 de enero de 1900 (es "
"decir el número de serie de la fecha), para el año, mes, y día "
"especificados.\n"
"\n"
"* Si @mes < 1 o @mes >12, el año será corregido. Una corrección similar se "
"aplica a los días.\n"
"* El valor de @año debe ser al menos 1900. Si @año < 1900, se asume que es "
"1900 + @años.\n"
"* Si la fecha dada no es válida, DATE devuelve un error #NÚM!.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"DATE(2001; 3; 30) es igual a 'Mar 30, 2001'.\n"
"\n"
"@SEEALSO=TODAY, NOW"

#: ../plugins/fn-date/functions.c:166
msgid ""
"@FUNCTION=UNIX2DATE\n"
"@SYNTAX=UNIX2DATE(unixtime)\n"
"@DESCRIPTION=UNIX2DATE converts a unix time into a spreadsheet date and "
"time.\n"
"\n"
"A unix time is the number of seconds since midnight January 1, 1970.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=NOW, DATE, DATE2UNIX"
msgstr ""
"@FUNCTION=UNIX2DATE\n"
"@SYNTAX=UNIX2DATE(tiempo-Unix)\n"
"@DESCRIPTION=UNIX2DATE convierte un tiempo Unix en una fecha y hora de hoja "
"de datos.\n"
"\n"
"Un tiempo Unix es el número de segundos desde medianoche del 1 de enero de "
"1970.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=NOW, DATE, DATE2UNIX"

#: ../plugins/fn-date/functions.c:200
msgid ""
"@FUNCTION=DATE2UNIX\n"
"@SYNTAX=DATE2UNIX(serial)\n"
"@DESCRIPTION=DATE2UNIX converts a spreadsheet date and time serial number "
"into a unix time.\n"
"\n"
"A unix time is the number of seconds since midnight January 1, 1970.\n"
"\n"
"@EXAMPLES=\n"
"DATE2UNIX(\"01/01/2000\") equals 946656000.\n"
"\n"
"@SEEALSO=NOW, DATE, UNIX2DATE"
msgstr ""
"@FUNCTION=DATE2UNIX\n"
"@SYNTAX=DATE2UNIX(serie)\n"
"@DESCRIPTION=DATE2UNIX convierte la fecha y hora de uno hoja de datos a "
"tiempo Unix.\n"
"\n"
"El tiempo Unix es el número de segundos desde medianoche del 1 de enero de "
"1970.\n"
"\n"
"@EXAMPLES=\n"
"DATE2UNIX(\"01/01/2000\") es igual a 946656000.\n"
"\n"
"\n"
"@SEEALSO=NOW, DATE, UNIX2DATE"

#: ../plugins/fn-date/functions.c:237
msgid ""
"@FUNCTION=DATEVALUE\n"
"@SYNTAX=DATEVALUE(date_str)\n"
"@DESCRIPTION=DATEVALUE returns the serial number of the date.  @date_str is "
"the string that contains the date. The value depends on the date "
"convention.  The MS Excel 1900 convention dates things from Jan 1 1900 while "
"the 1904 convention uses Jan 1 1904.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"DATEVALUE(\"1/1/1999\") equals 36161 (in the 1900 convention).\n"
"@SEEALSO=DATE"
msgstr ""
"@FUNCTION=DATEVALUE\n"
"@SYNTAX=DATEVALUE(cadena_fecha)\n"
"@DESCRIPTION=DATEVALUE devuelve el número de serie de la fecha.@cadena_fecha "
"es la cadena que contiene la fecha. El valor depende del convenio de fechas. "
"El convenio de 1900 de MS Excel fecha las cosas desde el 1 de enero de 1900 "
"mientras que el convenio 1904 usa el 1 de enero de 1904.\n"
".\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"DATEVALUE(\"1/1/1999\") es igual a 36161 (con convenio de 1900). \n"
"@SEEALSO=DATE"

#: ../plugins/fn-date/functions.c:265
msgid ""
"@FUNCTION=DATEDIF\n"
"@SYNTAX=DATEDIF(date1,date2,interval)\n"
"@DESCRIPTION=DATEDIF returns the difference between two dates.  @interval is "
"one of six possible values:  \"y\", \"m\", \"d\", \"ym\", \"md\", and \"yd"
"\".\n"
"\n"
"The first three options will return the number of complete years, months, or "
"days, respectively, between the two dates specified.\n"
"\n"
"  \"ym\" will return the number of full months between the two dates, not "
"including the difference in years.\n"
"  \"md\" will return the number of full days between the two dates, not "
"including the difference in months.\n"
"  \"yd\" will return the number of full days between the two dates, not "
"including the difference in years.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"DATEDIF(DATE(2000,4,30),DATE(2003,8,4),\"d\") equals 1191.\n"
"DATEDIF(DATE(2000,4,30),DATE(2003,8,4),\"y\") equals 3.\n"
"\n"
"@SEEALSO=DATE"
msgstr ""
"@FUNCTION=DATEDIF\n"
"@SYNTAX=DATEDIF(fecha1;fecha2;intervalo)\n"
"@DESCRIPTION=DATEDIF devuelve la diferencia entre dos fechas. @intervalo "
"tiene seis posibles valores: \"y\", \"m\", \"d\", \"ym\", \"md\", y \"yd\".\n"
"\n"
"Las tres primeras opciones devuelven el número entero de años, meses o días, "
"respectivamente, entre las dos fechas especificadas.\n"
"\n"
" \"ym\" devuelve el número entero de meses entre dos fechas sin incluir la "
"diferencia en años.\n"
" \"md\" devuelve el número entero de días entre dos fechas sin incluir la "
"diferencia de meses.\n"
" \"yd\" devuelve el número entero de días entre dos fechas sin incluir la "
"diferencia en años.\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"DATEDIF(DATE(2000;4;30),DATE(2003;8;4),\"d\") es igual a 1191.\n"
"DATEDIF(DATE(2000;4;30),DATE(2003;8;4),\"y\") es igual a 3.\n"
"\n"
"@SEEALSO=DATE"

#: ../plugins/fn-date/functions.c:417
msgid ""
"@FUNCTION=EDATE\n"
"@SYNTAX=EDATE(date,months)\n"
"@DESCRIPTION=EDATE returns the serial number of the date that is the "
"specified number of months before or after a given date.  @date is the "
"serial number of the initial date and @months is the number of months before "
"(negative number) or after (positive number) the initial date.\n"
"\n"
"* If @months is not an integer, it is truncated.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"EDATE(DATE(2001,12,30),2) returns 'Feb 28, 2002'.\n"
"\n"
"@SEEALSO=DATE"
msgstr ""
"@FUNCTION=EDATE\n"
"@SYNTAX=EDATE(fecha;meses)\n"
"@DESCRIPTION=Devuelve el número de serie de la fecha correspondiente a la "
"fecha especificada por el número de meses antes o después de la fecha dada. "
"@fecha es el número de serie de la fecha inicial y @meses es el número de "
"meses antes (encaso de ser negativo) o después (si es positivo) de la fecha "
"inicial.\n"
"\n"
"* Si @meses no es un entero será truncado. \n"
"* Esta función es compatible con Excel\n"
"\n"
"@EXAMPLES=\n"
"EDATE(DATE(2001;12;30);2) devuelve 'Feb 28, 2002'.\n"
"\n"
"@SEEALSO=DATE"

#: ../plugins/fn-date/functions.c:466
msgid ""
"@FUNCTION=TODAY\n"
"@SYNTAX=TODAY()\n"
"@DESCRIPTION=TODAY returns the serial number for today (the number of days "
"elapsed since the 1st of January of 1900).\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"TODAY() returns 'Nov 6, 2001' on that particular day.\n"
" \n"
"@SEEALSO=NOW"
msgstr ""
"@FUNCTION=TODAY\n"
"@SYNTAX=TODAY ()\n"
"@DESCRIPTION=Devuelve el número de serie de la fecha de hoy (la cantidad de "
"días transcurridos desde el 1 de enero de 1900).\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"TODAY() devuelve '6 de Nov de 2001' en ese día en particular.\n"
"\n"
"@SEEALSO=NOW"

#: ../plugins/fn-date/functions.c:492
msgid ""
"@FUNCTION=NOW\n"
"@SYNTAX=NOW ()\n"
"@DESCRIPTION=NOW returns the serial number for the date and time at the time "
"it is evaluated.\n"
"\n"
"Serial Numbers in Gnumeric are represented as follows: The integral part is "
"the number of days since the 1st of January of 1900.  The decimal part "
"represent the fraction of the day and is mapped into hour, minutes and "
"seconds.\n"
"\n"
"For example: .0 represents the beginning of the day, and 0.5 represents "
"noon.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"NOW().\n"
"\n"
"@SEEALSO=TODAY"
msgstr ""
"@FUNCTION=NOW\n"
"@SYNTAX=NOW()\n"
"@DESCRIPTION=Devuelve el número de serie de la fecha y hora a la cual fue "
"evaluada la función.\n"
"\n"
"Los números de serie de las fechas en Gnumeric son representados de la "
"manera siguiente: La parte entera representa la cantidad de días "
"transcurridos desde el 1º de enero de 1900. La parte decimal representa la "
"fracción del día, y es convertida en horas, minutos y segundos.\n"
"\n"
"Por ejemplo: ,0 representa el inicio del día, mientras que 0,5 representa "
"mediodía\n"
"\n"
" *Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"NOW().\n"
"\n"
"@SEEALSO=TODAY"

#: ../plugins/fn-date/functions.c:526
msgid ""
"@FUNCTION=TIME\n"
"@SYNTAX=TIME (hours,minutes,seconds)\n"
"@DESCRIPTION=TIME returns a fraction representing the time of day.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"TIME(3, 5, 23) equals 3:05AM.\n"
"\n"
"@SEEALSO=HOUR"
msgstr ""
"@FUNCTION=TIME\n"
"@SYNTAX=TIME (horas,minutos,segundos)\n"
"@DESCRIPTION=Devuelve una fracción representando la hora.\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"TIME(3; 5; 23) es igual a 3:05 AM.\n"
"\n"
"@SEEALSO=HOUR"

#: ../plugins/fn-date/functions.c:558
msgid ""
"@FUNCTION=TIMEVALUE\n"
"@SYNTAX=TIMEVALUE (timetext)\n"
"@DESCRIPTION=TIMEVALUE returns a fraction representing the time of day, a "
"number between 0 and 1.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"TIMEVALUE(\"3:05\") equals 0.128472.\n"
"TIMEVALUE(\"2:24:53 PM\") equals 0.600613.\n"
"\n"
"@SEEALSO=HOUR,MINUTE"
msgstr ""
"@FUNCTION=TIMEVALUE\n"
"@SYNTAX=TIMEVALUE (texto-hora)\n"
"@DESCRIPTION=Devuelve una fracción representando la hora del día, un número "
"entre 0 y 1.\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"TIMEVALUE(\"3:05\") es igual a 0,128472.\n"
"TIMEVALUE(\"2:24:53 PM\") es igual a 0,600613.\n"
"\n"
"@SEEALSO=HOUR,MINUTE"

#: ../plugins/fn-date/functions.c:586
msgid ""
"@FUNCTION=HOUR\n"
"@SYNTAX=HOUR (date)\n"
"@DESCRIPTION=HOUR converts a serial number to an hour.  The hour is returned "
"as an integer in the range 0 (12:00 A.M.) to 23 (11:00 P.M.).\n"
"\n"
"* Note that Gnumeric will perform regular string to serial number conversion "
"for you, so you can enter a date as a string.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"HOUR(0.128472) equals 3.\n"
"\n"
"@SEEALSO=MINUTE, NOW, TIME, SECOND"
msgstr ""
"@FUNCTION=HOUR\n"
"@SYNTAX=HOUR (número-serie)\n"
"@DESCRIPTION=Convierte el número de serie en una hora. La hora se devuelve "
"como un entero en el rango 0 (12:00 A.M.) a 23 (11:00 P.M.).\n"
"\n"
"* Note que Gnumeric hará la conversión de una cadena de texto a un número de "
"serie; por lo tanto puede introducir la fecha como una cadena de texto.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"HOUR(0,128472) es igual a 3.\n"
"\n"
"@SEEALSO=MINUTE, NOW, TIME, SECOND"

#: ../plugins/fn-date/functions.c:623
msgid ""
"@FUNCTION=MINUTE\n"
"@SYNTAX=MINUTE (date)\n"
"@DESCRIPTION=MINUTE converts a serial number to a minute.  The minute is "
"returned as an integer in the range 0 to 59.\n"
"\n"
"* Note that Gnumeric will perform regular string to serial number conversion "
"for you, so you can enter a date as a string.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"MINUTE(0.128472) equals 5.\n"
"\n"
"@SEEALSO=HOUR, NOW, TIME, SECOND"
msgstr ""
"@FUNCTION=MINUTE\n"
"@SYNTAX=MINUTE (numero-serie)\n"
"@DESCRIPTION=Convierte el número de serie a minutos. Los minutos son dados "
"como un entero en el rango de 0 a 59.\n"
"\n"
"* Note que Gnumeric hará la conversión de una cadena de texto a un número de "
"serie; por lo tanto puede entrar la fecha como una cadena de texto.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"MINUTE(0,128472) es igual a 5.\n"
"\n"
"@SEEALSO=HOUR, NOW, TIME, SECOND"

#: ../plugins/fn-date/functions.c:660
msgid ""
"@FUNCTION=SECOND\n"
"@SYNTAX=SECOND (date)\n"
"@DESCRIPTION=SECOND converts a serial number to a second.  The second is "
"returned as an integer in the range 0 to 59.\n"
"\n"
"* Note that Gnumeric will perform regular string to serial number conversion "
"for you, so you can enter a date as a string.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"SECOND(0.600613) equals 53.\n"
"\n"
"@SEEALSO=HOUR, MINUTE, NOW, TIME"
msgstr ""
"@FUNCTION=SECOND\n"
"@SYNTAX=SECOND (numero-serie)\n"
"@DESCRIPTION=Convierte el número de serie a segundos. Los segundos son dados "
"como un entero dentro del rango de 0 a 59.\n"
"\n"
"* Note que Gnumeric hará la conversión de una cadena de texto a un número de "
"serie; por lo tanto puede entrar la fecha como una cadena de texto.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"SECOND(0,600613) es igual a 53.\n"
"\n"
"@SEEALSO=HOUR, MINUTE, NOW, TIME"

#: ../plugins/fn-date/functions.c:697
msgid ""
"@FUNCTION=YEAR\n"
"@SYNTAX=YEAR (date)\n"
"@DESCRIPTION=YEAR converts a serial number to a year.\n"
"\n"
"* Note that Gnumeric will perform regular string to serial number conversion "
"for you, so you can enter a date as a string.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"YEAR(DATE(2003, 4, 30)) equals 2003.\n"
"\n"
"@SEEALSO=DAY, MONTH, TIME, NOW"
msgstr ""
"@FUNCTION=YEAR\n"
"@SYNTAX=YEAR (numero-serie)\n"
"@DESCRIPTION=Convierte el número de serie a un año.\n"
"\n"
"* Note que Gnumeric hará la conversión de una cadena de texto a un número de "
"serie; por lo tanto puede entrar la fecha como una cadena de texto.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"YEAR(DATE(2003;4;30)) es igual a 2003.\n"
"\n"
"@SEEALSO=DAY, MONTH, TIME, NOW"

#: ../plugins/fn-date/functions.c:731
msgid ""
"@FUNCTION=MONTH\n"
"@SYNTAX=MONTH (date)\n"
"@DESCRIPTION=MONTH converts a serial number to a month.\n"
"\n"
"* Note that Gnumeric will perform regular string to serial number conversion "
"for you, so you can enter a date as a string.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"MONTH(DATE(2003, 4, 30)) equals 4.\n"
"\n"
"@SEEALSO=DAY, TIME, NOW, YEAR"
msgstr ""
"@FUNCTION=MONTH\n"
"@SYNTAX=MONTH (numero-serie)\n"
"@DESCRIPTION=Convierte el número de serie en un mes.\n"
"\n"
"* Note que Gnumeric hará la conversión de una cadena de texto a un número de "
"serie; por lo tanto puede entrar la fecha como una cadena de texto.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"MONTH(DATE(2003;4;30)) es igual a 4.\n"
"\n"
"@SEEALSO=DAY, TIME, NOW, YEAR"

#: ../plugins/fn-date/functions.c:765
msgid ""
"@FUNCTION=DAY\n"
"@SYNTAX=DAY (date)\n"
"@DESCRIPTION=DAY converts a serial number to a day of month.\n"
"\n"
"* Note that Gnumeric will perform regular string to serial number conversion "
"for you, so you can enter a date as a string.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"DAY(\"10/24/1968\") equals 24.\n"
"\n"
"@SEEALSO=MONTH, TIME, NOW, YEAR"
msgstr ""
"@FUNCTION=DAY\n"
"@SYNTAX=DAY (numero-serie)\n"
"@DESCRIPTION=Convierte el número de serie a un día del mes.\n"
"\n"
"* Note que Gnumeric hará la conversión de una cadena de texto a un número de "
"serie; por lo tanto, puede entrar la fecha como una cadena de texto.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"DAY(\"24/10/1968\") es igual a 24.\n"
"\n"
"@SEEALSO=MONTH, TIME, NOW, YEAR"

#: ../plugins/fn-date/functions.c:799
msgid ""
"@FUNCTION=WEEKDAY\n"
"@SYNTAX=WEEKDAY (date[, method])\n"
"@DESCRIPTION=WEEKDAY converts a serial number to a weekday.\n"
"\n"
"This function returns an integer indicating the day of week.\n"
"@METHOD indicates the numbering system.  It defaults to 1.\n"
"\n"
"  For @METHOD=1: Sunday is 1, Monday is 2, etc.\n"
"  For @METHOD=2: Monday is 1, Tuesday is 2, etc.\n"
"  For @METHOD=3: Monday is 0, Tuesday is 1, etc.\n"
"\n"
"* Note that Gnumeric will perform regular string to serial number conversion "
"for you, so you can enter a date as a string.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"WEEKDAY(\"10/24/1968\") equals 5 (Thursday).\n"
"\n"
"@SEEALSO=DAY, MONTH, TIME, NOW, YEAR"
msgstr ""
"@FUNCTION=WEEKDAY\n"
"@SYNTAX=WEEKDAY (fecha[, método])\n"
"@DESCRIPTION=Convierte un número de serie en un día de la semana.\n"
"\n"
"Esta función devuelve un entero indicando el día de la semana.\n"
"@MÉTODO indica el sistema de numeración. De forma predeterminada, es 1.\n"
"\n"
"\tPara @MÉTODO=1: domingo es 1, lunes es 2, etc.\n"
"\tPara @MÉTODO=2: lunes es 1, martes es 2, etc.\n"
"\tPara @MÉTODO=3: lunes es 0, martes es 2, etc.\n"
"\n"
"* Note que Gnumeric hará la conversión de una cadena de texto a un número de "
"serie; por lo tanto puede entrar la fecha como una cadena de texto.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"WEEKDAY(\"24/10/1968\") es igual a 5 (jueves).\n"
"\n"
"@SEEALSO=DAY, MONTH, TIME, NOW, YEAR"

#: ../plugins/fn-date/functions.c:853
msgid ""
"@FUNCTION=DAYS360 \n"
"@SYNTAX=DAYS360 (date1,date2,method)\n"
"@DESCRIPTION=DAYS360 returns the number of days from @date1 to @date2 "
"following a 360-day calendar in which all months are assumed to have 30 "
"days.\n"
"\n"
"* If @method is 1, the European method will be used.  In this case, if the "
"day of the month is 31 it will be considered as 30.\n"
"* If @method is 0 or omitted, the MS Excel (tm) US method will be used.  "
"This is a somewhat complicated industry standard method where the last day "
"of February is considered to be the 30th day of the month, but only for the "
"first date.\n"
"* If @method is 2, a saner version of the US method is used in which both "
"dates get the same February treatment.\n"
"* Note that Gnumeric will perform regular string to serial number conversion "
"for you, so you can enter a date as a string.\n"
"* This function is mostly Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"DAYS360(DATE(2003, 2, 3), DATE(2007, 4, 2)) equals 1499.\n"
"\n"
"@SEEALSO=MONTH, TIME, NOW, YEAR"
msgstr ""
"@FUNCTION=DAYS360\n"
"@SYNTAX=DAYS360 (fecha1,fecha2,método)\n"
"@DESCRIPTION=Devuelve la cantidad de días entre @fecha1 y @fecha2 siguiendo "
"un calendario de 360 días con todos los meses de 30 días.\n"
"\n"
"* Si @método es 1, se usa el método europeo. En ese caso, si el día del mes "
"es un 31, será considerado como un 30.\n"
"* Si @método es 0 o se omite, se usa el método estadounidense. Éste es un "
"método más complicado usado como método estandarizado en la industria en EE."
"UU, donde el último día de febrero se considera el día 30 del mes, pero sólo "
"para la primera fecha.\n"
"* Si el @método es 2, se usa una versión más simple del método "
"estadounidense en la cual ambas fechas tienen el mismo tratamiento para el "
"mes de febrero.\n"
"* Note que Gnumeric convertirá las fechas dadas como cadenas de texto al "
"número de serie de la fecha usado de manera interna; es decir que puede si "
"lo desea pasar las fechas como cadenas de texto.\n"
"* Esta función es compatible en su mayor parte con Excel.\n"
"\n"
"@EXAMPLES=\n"
"DAYS360(DATE(2003;2;3); DATE(2007;4;2)) es igual a 1499.\n"
"\n"
"@SEEALSO=MONTH, TIME, NOW, YEAR"

#: ../plugins/fn-date/functions.c:913
msgid ""
"@FUNCTION=EOMONTH\n"
"@SYNTAX=EOMONTH (start_date,months)\n"
"@DESCRIPTION=EOMONTH returns the last day of the month which is @months from "
"the @start_date.\n"
"\n"
"* EOMONTH returns #NUM! if @start_date or @months are invalid.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"If A1 contains 12/21/00 then EOMONTH(A1,0)=12/31/00, EOMONTH(A1,5)=5/31/01, "
"and EOMONTH(A1,2)=2/28/01\n"
"\n"
"@SEEALSO=MONTH"
msgstr ""
"@FUNCTION=EOMONTH\n"
"@SYNTAX=EOMONTH (fecha_inicio,meses)\n"
"@DESCRIPTION=Devuelve el último día del mes que viene @meses meses después "
"que @fecha_inicio .\n"
"\n"
"* EOMONTH devuelve un error #NÚM! si @fecha_inicio o @meses no son válidos.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"Si A1 contiene 21/12/00, entonces EOMONTH(A1;0)=31/12/00, EOMONTH(A1;5)"
"=31/5/01, y EOMONTH(A1;2)=28/2/01\n"
"\n"
"@SEEALSO=MONTH"

#: ../plugins/fn-date/functions.c:963
msgid ""
"@FUNCTION=WORKDAY\n"
"@SYNTAX=WORKDAY (start_date,days[,holidays])\n"
"@DESCRIPTION=WORKDAY returns the date which is @days working days from the "
"@start_date.  Weekends and holidays optionally supplied in @holidays are "
"respected.\n"
"\n"
"* WORKDAY returns #NUM! if @start_date or @days are invalid.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"DAY(WORKDAY(DATE(2001,1,5),30)) equals 16 and\n"
"MONTH(WORKDAY(DATE(2001,1,5),30)) equals 2.\n"
"\n"
"@SEEALSO=NETWORKDAYS"
msgstr ""
"@FUNCTION=WORKDAY\n"
"@SYNTAX=WORKDAY (fecha_inicio,días[,vacaciones])\n"
"@DESCRIPTION=Devuelve el día que viene @días días laborables después que "
"@fecha_inicio. Se respetan los fines de semana y los días de vacaciones "
"opcionales indicados en @vacaciones.\n"
"\n"
"* WORKDAY devuelve #NÚM! si @fecha_inicio o @días no son válidos.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"DAY(WORKDAY(DATE(2001,1,5),30)) es igual a 16 y\n"
"MONTH(WORKDAY(DATE(2001,1,5),30)) es igual a 2.\n"
"\n"
"@SEEALSO=NETWORKDAYS"

#: ../plugins/fn-date/functions.c:1136
msgid ""
"@FUNCTION=NETWORKDAYS\n"
"@SYNTAX=NETWORKDAYS (start_date,end_date[,holidays])\n"
"@DESCRIPTION=NETWORKDAYS returns the number of non-weekend non-holidays "
"between @start_date and @end_date including these dates. Holidays are "
"optionally supplied in @holidays.\n"
"\n"
"* NETWORKDAYS returns #NUM! if @start_date or @end_date are invalid.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"NETWORKDAYS(DATE(2001,1,2),DATE(2001,2,15)) equals 33.\n"
"\n"
"@SEEALSO=WORKDAY"
msgstr ""
"@FUNCTION=NETWORKDAYS\n"
"@SYNTAX=NETWORKDAYS (fecha_inicio,fecha_final[,vacaciones])\n"
"@DESCRIPTION=Devuelve la cantidad de días laborables entre @fecha_inicio y "
"@fecha_final, ambas inclusive. Las vacaciones se pueden indicar "
"opcionalmente en @vacaciones.\n"
"\n"
"* Devuelve #NÚM! si @fecha_inicio o @fecha_final no son válidos\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"NETWORKDAYS(DATE(2001,1,2);DATE(2001;2;15)) es igual a 33.\n"
"\n"
"@SEEALSO=WORKDAY"

#: ../plugins/fn-date/functions.c:1265
msgid ""
"@FUNCTION=ISOWEEKNUM\n"
"@SYNTAX=ISOWEEKNUM (date)\n"
"@DESCRIPTION=ISOWEEKNUM returns the ISO 8601 week number of @date.\n"
"\n"
"An ISO 8601 week starts on Monday. Weeks are numbered from 1. A week "
"including days from two different years is assigned to the year which "
"includes the most days. This means that Dec 31 could be in week 1 of the "
"following year, and Jan 1 could be in week 52 or 53 of the previous year. "
"ISOWEEKNUM returns the week number.\n"
"\n"
"* ISOWEEKNUM returns #NUM! if date is invalid.\n"
"\n"
"@EXAMPLES=\n"
"If A1 contains 12/21/00 then ISOWEEKNUM(A1)=51\n"
"@SEEALSO=WEEKNUM, ISOYEAR"
msgstr ""
"@FUNCTION=ISOWEEKNUM\n"
"@SYNTAX=ISOWEEKNUM (fecha)\n"
"@DESCRIPTION=ISOWEEKNUM devuelve el número de semana de la @fecha en formato "
"ISO 8601.\n"
"\n"
"Una semana ISO 8601 empieza el lunes. Las semanas se numeran a partir de 1. "
"Una semana que incluya días de dos años diferentes se asigna al año que "
"incluya la mayoría de los días. Esto significa que el 31 de diciembre podría "
"estar en la semana 1 del año siguiente, y que el 1 de enero podría estar en "
"la semana 52 ó 53 del año anterior.\n"
"ISOWEEKNUM devuelve el número de la semana, mientras que ISOYEAR devuelve el "
"año al que la semana se asigna.\n"
"\n"
"* Devuelve #NÚM! si la fecha no es válida.\n"
"\n"
"@EXAMPLES=\n"
"Si A1 contiene 21/12/00 entonces ISOWEEKNUM(A1)=51\n"
"@SEEALSO=WEEKNUM"

#: ../plugins/fn-date/functions.c:1302
msgid ""
"@FUNCTION=ISOYEAR\n"
"@SYNTAX=ISOYEAR (date)\n"
"@DESCRIPTION=ISOYEAR returns the year of the ISO 8601 week number of @date.\n"
"\n"
"An ISO 8601 week starts on Monday. Weeks are numbered from 1. A week "
"including days from two different years is assigned to the year which "
"includes the most days. This means that Dec 31 could be in week 1 of the "
"following year, and Jan 1 could be in week 52 or 53 of the previous year. "
"ISOYEAR returns the year the week is assigned to.\n"
"\n"
"* ISOYEAR returns #NUM! if date is invalid.\n"
"@EXAMPLES=\n"
"If A1 contains 12/31/2001 then ISOYEAR(A1)=2002\n"
"@SEEALSO=ISOWEEKNUM"
msgstr ""
"@FUNCTION=ISOYEAR\n"
"@SYNTAX=ISOYEAR (fecha)\n"
"@DESCRIPTION=ISOYEAR devuelve el año del número de semana ISO 8601 de la "
"@fecha.\n"
"\n"
"Una semana ISO 8601 comienza en lunes. Las semanas se numeran desde 1. Una "
"semana que incluya días de dos años distintos se asigna al año que incluye "
"mayor número de días. Esto significa que el 31 de diciembre podría estar en "
"la semana 1 del año siguiente y el 1 de enero podría estar en la semana 52 o "
"53 del año anterior. ISOYEAR devuelve el año al que la semana está asignada, "
"mientras que ISOWEEKNUM devuelve el número de la semana.\n"
"\n"
"* Si la fecha es inválida, ISOYEAR devuelve el error #NÚM!.\n"
"\n"
"@EXAMPLES=\n"
" Si A1 contiene 31/12/2001 entonces ISOYEAR(A1)=2002\n"
"\n"
"@SEEALSO=ISOWEEKNUM"

#: ../plugins/fn-date/functions.c:1352
msgid ""
"@FUNCTION=WEEKNUM\n"
"@SYNTAX=WEEKNUM (date[,method])\n"
"@DESCRIPTION=WEEKNUM returns the week number of @date according to the given "
"@method.\n"
"\n"
"@method defaults to 1.\n"
"\n"
"  For @method=1, week starts on Sunday, and days before first Sunday are in "
"week 0.\n"
"  For @method=2, week starts on Monday, and days before first Monday are in "
"week 0.\n"
"  For @method=150, the ISO 8601 week number is returned.\n"
"\n"
"* WEEKNUM returns #NUM! if @date or @method is invalid.\n"
"* This function is Excel compatible, except that Excel does not support ISO "
"8601 week numbers.\n"
"\n"
"@EXAMPLES=\n"
"If A1 contains 12/21/00 then WEEKNUM(A1,2)=51\n"
"@SEEALSO=ISOWEEKNUM"
msgstr ""
"@FUNCTION=WEEKNUM\n"
"@SYNTAX=WEEKNUM (fecha[,método])\n"
"@DESCRIPTION=WEEKNUM devuelve el número de semana de @fecha según el @método "
"dado.\n"
"\n"
"@método es 1 por omisión.\n"
"\n"
" Para el @método=1, la semana empieza el domingo, y los días anteriores al "
"domingo están en la semana 0.\n"
" Para el @método=2, la semana empieza el lunes, y los días anteriores al "
"lunes están en la semana 0.\n"
" Para el @método=150, se devuelve el número de semana ISO 8601.\n"
"\n"
"* Devuelve #NÚM! si la fecha o el método no son válidos.\n"
"* Esta función es compatible con Excel, salvo que Excel no soporta números "
"de semana ISO 8601.\n"
"\n"
"@EXAMPLES=\n"
"Si A1 contiene 21/12/00, entonces WEEKNUM(A1,2)=51\n"
"@SEEALSO=ISOWEEKNUM"

#: ../plugins/fn-date/functions.c:1400
msgid ""
"@FUNCTION=YEARFRAC\n"
"@SYNTAX=YEARFRAC (start_date, end_date [,basis])\n"
"@DESCRIPTION=YEARFRAC returns the number of full days between @start_date "
"and @end_date according to the @basis.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=DATEDIF"
msgstr ""
"@FUNCTION=YEARFRAC\n"
"@SYNTAX=YEARFRAC (fecha_inicio, fecha_final [,base])\n"
"@DESCRIPTION=YEARFRAC devuelve el número de días completos entre "
"@fecha_inicio y @fecha_final de acuerdo con la @base.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=DATEDIF"

#: ../plugins/fn-eng/functions.c:205
msgid ""
"@FUNCTION=BASE\n"
"@SYNTAX=BASE(number,base[,length])\n"
"@DESCRIPTION=BASE function converts a number to a string representing that "
"number in base @base.\n"
"\n"
"* @base must be an integer between 2 and 36.\n"
"* This function is OpenOffice.Org compatible.\n"
"* Optional argument @length specifies the minimum result length.  Leading  "
"zeroes will be added to reach this length.\n"
"\n"
"@EXAMPLES=\n"
"BASE(255,16,4) equals \"00FF\".\n"
"\n"
"@SEEALSO=DECIMAL"
msgstr ""
"@FUNCTION=BASE\n"
"@SYNTAX=BASE(número,base[,longitud])\n"
"@DESCRIPTION=La función BASE convierte un número a una cadena representando "
"ese número en base @base.\n"
"\n"
"* @base debe ser un entero entre 2 y 36.\n"
"* Esta función es compatible con OpenOffice.Org.\n"
"* El argumento opcional @longitud especifica la longitud mínima del "
"resultado. Se añadirán ceros para alcanzar esa longitud.\n"
"\n"
"@EXAMPLES=\n"
"BASE(255,16,4) es igual a \"00FF\".\n"
"\n"
"@SEEALSO=DECIMAL"

#: ../plugins/fn-eng/functions.c:243
msgid ""
"@FUNCTION=BIN2DEC\n"
"@SYNTAX=BIN2DEC(x)\n"
"@DESCRIPTION=BIN2DEC function converts a binary number in string or number "
"to its decimal equivalent.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"BIN2DEC(101) equals 5.\n"
"\n"
"@SEEALSO=DEC2BIN, BIN2OCT, BIN2HEX"
msgstr ""
"@FUNCTION=BIN2DEC\n"
"@SYNTAX=BIN2DEC(x)\n"
"@DESCRIPTION=La función BIN2DEC convierte un número binario (pasado como "
"número o como cadena de texto) a su equivalente decimal. \n"
"\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"BIN2DEC(101) devuelve 5.\n"
"\n"
"@SEEALSO=DEC2BIN, BIN2OCT, BIN2HEX"

#: ../plugins/fn-eng/functions.c:272
msgid ""
"@FUNCTION=BIN2OCT\n"
"@SYNTAX=BIN2OCT(number[,places])\n"
"@DESCRIPTION=BIN2OCT function converts a binary number to an octal number. "
"@places is an optional field, specifying to zero pad to that number of "
"spaces.\n"
"\n"
"* If @places is too small or negative #NUM! error is returned.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"BIN2OCT(110111) equals 67.\n"
"\n"
"@SEEALSO=OCT2BIN, BIN2DEC, BIN2HEX"
msgstr ""
"@FUNCTION=BIN2OCT\n"
"@SYNTAX=BIN2OCT(número[,dígitos])\n"
"@DESCRIPTION=La función BIN2OCT convierte un número binario a su equivalente "
"octal. @dígitos es un parámetro opcional, que indica el ancho del número "
"resultante, a rellenar con 0 si fuese necesario.\n"
"\n"
"* Si @dígitos es demasiado pequeño, o negativo, se devuelve el error "
"#NÚM!. \n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"BIN2OCT(110111) es igual a 67.\n"
"\n"
"@SEEALSO=OCT2BIN, BIN2DEC, BIN2HEX"

#: ../plugins/fn-eng/functions.c:304
msgid ""
"@FUNCTION=BIN2HEX\n"
"@SYNTAX=BIN2HEX(number[,places])\n"
"@DESCRIPTION=BIN2HEX function converts a binary number to a hexadecimal "
"number.  @places is an optional field, specifying to zero pad to that number "
"of spaces.\n"
"\n"
"* If @places is too small or negative #NUM! error is returned.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"BIN2HEX(100111) equals 27.\n"
"\n"
"@SEEALSO=HEX2BIN, BIN2OCT, BIN2DEC"
msgstr ""
"@FUNCTION=BIN2HEX\n"
"@SYNTAX=BIN2HEX(número[;dígitos])\n"
"@DESCRIPTION=La función BIN2HEX convierte un número binario a su equivalente "
"hexadecimal. @dígitos es un parámetro facultativo, que indica el ancho del "
"número resultante, a rellenar con 0 si es necesario.\n"
"\n"
"* Si @dígitos es demasiado pequeño, o negativo, el error #NÚM! es "
"devuelto. \n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"BIN2HEX(100111) devuelve 27.\n"
"\n"
"@SEEALSO=HEX2BIN, BIN2OCT, BIN2DEC"

#: ../plugins/fn-eng/functions.c:336
msgid ""
"@FUNCTION=DEC2BIN\n"
"@SYNTAX=DEC2BIN(number[,places])\n"
"@DESCRIPTION=DEC2BIN function converts a decimal number to a binary number. "
"@places is an optional field, specifying to zero pad to that number of "
"spaces.\n"
"\n"
"* If @places is too small or negative #NUM! error is returned.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"DEC2BIN(42) equals 101010.\n"
"\n"
"@SEEALSO=BIN2DEC, DEC2OCT, DEC2HEX"
msgstr ""
"@FUNCTION=DEC2BIN\n"
"@SYNTAX=DEC2BIN(número[,dígitos])\n"
"@DESCRIPTION=La función DEC2BIN convierte @número de decimal a binario. El "
"valor @dígitos es opcional y especifica el número de dígitos que tendrá el "
"número binario.\n"
"\n"
"* Si @dígitos es muy pequeño o negativo, se devuelve el error #NÚM!.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"DEC2BIN(42) es igual a 101010.\n"
"\n"
"@SEEALSO=BIN2DEC, DEC2OCT, DEC2HEX"

#: ../plugins/fn-eng/functions.c:368
msgid ""
"@FUNCTION=DEC2OCT\n"
"@SYNTAX=DEC2OCT(number[,places])\n"
"@DESCRIPTION=DEC2OCT function converts a decimal number to an octal number. "
"@places is an optional field, specifying to zero pad to that number of "
"spaces.\n"
"\n"
"* If @places is too small or negative #NUM! error is returned.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"DEC2OCT(42) equals 52.\n"
"\n"
"@SEEALSO=OCT2DEC, DEC2BIN, DEC2HEX"
msgstr ""
"@FUNCTION=DEC2OCT\n"
"@SYNTAX=DEC2OCT(número[,dígitos])\n"
"@DESCRIPTION=La función DEC2OCT convierte @número de decimal a octal. El "
"valor @dígitos es opcional y especifica el número de dígitos que tendrá el "
"número octal.\n"
"\n"
"* Si @dígitos es muy pequeño o negativo, se devuelve el error #NÚM!\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"DEC2OCT(42) es igual a 52.\n"
"\n"
"@SEEALSO=OCT2DEC, DEC2BIN, DEC2HEX"

#: ../plugins/fn-eng/functions.c:400
msgid ""
"@FUNCTION=DEC2HEX\n"
"@SYNTAX=DEC2HEX(number[,places])\n"
"@DESCRIPTION=DEC2HEX function converts a decimal number to a hexadecimal "
"number. @places is an optional field, specifying to zero pad to that number "
"of spaces.\n"
"\n"
"* If @places is too small or negative #NUM! error is returned.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"DEC2HEX(42) equals 2A.\n"
"\n"
"@SEEALSO=HEX2DEC, DEC2BIN, DEC2OCT"
msgstr ""
"@FUNCTION=DEC2HEX\n"
"@SYNTAX=DEC2HEX(número[,dígitos])\n"
"@DESCRIPTION=La función DEC2BIN convierte @número de decimal a hexadecimal. "
"El valor @dígitos es opcional y especifica el número de dígitos que tendrá "
"el número hexadecimal.\n"
"\n"
"* Si @dígitos es muy pequeño o negativo, se devuelve el error #NUM\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"DEC2HEX(42) es igual a 2A.\n"
"\n"
"@SEEALSO=HEX2DEC, DEC2BIN, DEC2OCT"

#: ../plugins/fn-eng/functions.c:432
msgid ""
"@FUNCTION=DECIMAL\n"
"@SYNTAX=DECIMAL(text,base)\n"
"@DESCRIPTION=DECIMAL function converts a number in base @base to decimal.\n"
"\n"
"* @base must be an integer between 2 and 36.\n"
"* This function is OpenOffice.Org compatible.\n"
"\n"
"@EXAMPLES=\n"
"DECIMAL(\"A1\",16) equals 161.\n"
"\n"
"@SEEALSO=BASE"
msgstr ""
"@FUNCTION=DECIMAL\n"
"@SYNTAX=DECIMAL(texto,base)\n"
"@DESCRIPTION=La función DECIMAL convierte un número en la base @base a "
"decimal.\n"
"\n"
"* @base debe ser un entero entre 2 y 36.\n"
"* Esta función es compatible con OpenOffice.Org.\n"
"\n"
"@EXAMPLES=\n"
"DECIMAL(\"A1\",16) igual a 161.\n"
"\n"
"@SEEALSO=BASE"

#: ../plugins/fn-eng/functions.c:464
msgid ""
"@FUNCTION=OCT2DEC\n"
"@SYNTAX=OCT2DEC(x)\n"
"@DESCRIPTION=OCT2DEC function converts an octal number in a string or number "
"to its decimal equivalent.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"OCT2DEC(\"124\") equals 84.\n"
"\n"
"@SEEALSO=DEC2OCT, OCT2BIN, OCT2HEX"
msgstr ""
"@FUNCTION=OCT2DEC\n"
"@SYNTAX=OCT2DEC(x)\n"
"@DESCRIPTION=La función OCT2DEC convierte un número octal a su equivalente "
"decimal.\n"
"\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"OCT2DEC(\"124\") es igual a 84.\n"
"\n"
"@SEEALSO=DEC2OCT, OCT2BIN, OCT2HEX"

#: ../plugins/fn-eng/functions.c:493
msgid ""
"@FUNCTION=OCT2BIN\n"
"@SYNTAX=OCT2BIN(number[,places])\n"
"@DESCRIPTION=OCT2BIN function converts an octal number to a binary number.  "
"@places is an optional field, specifying to zero pad to that number of "
"spaces.\n"
"\n"
"* If @places is too small or negative #NUM! error is returned.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"OCT2BIN(\"213\") equals 10001011.\n"
"\n"
"@SEEALSO=BIN2OCT, OCT2DEC, OCT2HEX"
msgstr ""
"@FUNCTION=OCT2BIN\n"
"@SYNTAX=OCT2BIN(número[,dígitos])\n"
"@DESCRIPTION=La función OCT2BIN convierte @número de octal a binario. El "
"valor @dígitos es opcional y especifica el número de dígitos que tendrá el "
"número binario.\n"
"\n"
"* Si @dígitos es muy pequeño o negativo, el error #NÚM! es devuelto.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"OCT2BIN(\"213\") es igual a 10001011.\n"
"\n"
"\n"
"@SEEALSO=BIN2OCT, DEC2OCT, OCT2HEX"

#: ../plugins/fn-eng/functions.c:525
msgid ""
"@FUNCTION=OCT2HEX\n"
"@SYNTAX=OCT2HEX(number[,places])\n"
"@DESCRIPTION=OCT2HEX function converts an octal number to a hexadecimal "
"number.  @places is an optional field, specifying to zero pad to that number "
"of spaces.\n"
"\n"
"* If @places is too small or negative #NUM! error is returned.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"OCT2HEX(132) equals 5A.\n"
"\n"
"@SEEALSO=HEX2OCT, OCT2BIN, OCT2DEC"
msgstr ""
"@FUNCTION=OCT2HEX\n"
"@SYNTAX=OCT2HEX(número[,dígitos])\n"
"@DESCRIPTION=La función OCT2HEX convierte @número de octal a hexadecimal. El "
"valor @dígitos es opcional y especifica el número de dígitos que tendrá el "
"número hexadecimal.\n"
"\n"
"* Si @dígitos es muy pequeño o negativo, el se devuelve el error #NÚM!\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"DEC2HEX(132) es igual a 5A.\n"
"\n"
"@SEEALSO=HEX2OCT, OCT2BIN, OCT2DEC"

#: ../plugins/fn-eng/functions.c:557
msgid ""
"@FUNCTION=HEX2BIN\n"
"@SYNTAX=HEX2BIN(number[,places])\n"
"@DESCRIPTION=HEX2BIN function converts a hexadecimal number to a binary "
"number.  @places is an optional field, specifying to zero pad to that number "
"of spaces.\n"
"\n"
"* If @places is too small or negative #NUM! error is returned.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"HEX2BIN(\"2A\") equals 101010.\n"
"\n"
"@SEEALSO=BIN2HEX, HEX2OCT, HEX2DEC"
msgstr ""
"@FUNCTION=HEX2BIN\n"
"@SYNTAX=HEX2BIN(número[;dígitos])\n"
"@DESCRIPTION=La función HEX2BIN convierte un número hexadecimal a binario. "
"@dígitos es un campo opcional y especifica el número de espacio de relleno.\n"
"\n"
"* Si @dígitos es muy pequeño o negativo, de devuelve el error #NÚM!.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"HEX2BIN(\"2A\") es igual a 101010.\n"
"\n"
"@SEEALSO=BIN2HEX, HEX2OCT, HEX2DEC"

#: ../plugins/fn-eng/functions.c:589
msgid ""
"@FUNCTION=HEX2OCT\n"
"@SYNTAX=HEX2OCT(number[,places])\n"
"@DESCRIPTION=HEX2OCT function converts a hexadecimal number to an octal "
"number.  @places is an optional field, specifying to zero pad to that number "
"of spaces.\n"
"\n"
"* If @places is too small or negative #NUM! error is returned.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"HEX2OCT(\"2A\") equals 52.\n"
"\n"
"@SEEALSO=OCT2HEX, HEX2BIN, HEX2DEC"
msgstr ""
"@FUNCTION=HEX2OCT\n"
"@SYNTAX=HEX2OCT(número[,dígitos])\n"
"@DESCRIPTION=La función HEX2OCT convierte un número hexadecimal a su "
"equivalente octal. @dígitos es un parámetro opcional, que indica el ancho "
"del número resultante, a rellenar con 0 si es necesario.\n"
"\n"
"* Si @dígitos es demasiado pequeño, o negativo, se devuelve un error #NÚM!.\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"HEX2OCT(\"2A\") devuelve 52.\n"
"\n"
"@SEEALSO=OCT2HEX, HEX2BIN, HEX2DEC"

#: ../plugins/fn-eng/functions.c:621
msgid ""
"@FUNCTION=HEX2DEC\n"
"@SYNTAX=HEX2DEC(x)\n"
"@DESCRIPTION=HEX2DEC function converts a hexadecimal number to its decimal "
"equivalent.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"HEX2DEC(\"2A\") equals 42.\n"
"\n"
"@SEEALSO=DEC2HEX, HEX2BIN, HEX2OCT"
msgstr ""
"@FUNCTION=HEX2DEC\n"
"@SYNTAX=HEX2DEC(x)\n"
"@DESCRIPTION=Convierte un número hexadecimal a su equivalente decimal.\n"
"\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"HEX2DEC(\"2A\") es igual a 42.\n"
"\n"
"@SEEALSO=DEC2HEX, HEX2BIN, HEX2OCT"

#: ../plugins/fn-eng/functions.c:650
msgid ""
"@FUNCTION=BESSELI\n"
"@SYNTAX=BESSELI(x,y)\n"
"@DESCRIPTION=BESSELI function returns the Neumann, Weber or Bessel "
"function.\n"
"\n"
"@x is where the function is evaluated. @y is the order of the Bessel "
"function.\n"
"\n"
"* If @x or @y are not numeric a #VALUE! error is returned.\n"
"* If @y < 0 a #NUM! error is returned.\n"
"* This function extends the Excel function of the same name to non-integer "
"orders.\n"
"\n"
"@EXAMPLES=\n"
"BESSELI(0.7,3) equals 0.007367374.\n"
"\n"
"@SEEALSO=BESSELJ,BESSELK,BESSELY"
msgstr ""
"@FUNCTION=BESSELI\n"
"@SYNTAX=BESSELI(x,y)\n"
"@DESCRIPTION=La función BESSELI devuelve la función de Neumann, Weber o "
"Bessel. \n"
"\n"
"@x es donde se evalúa la función. @y es el orden de la función Bessel.\n"
"\n"
"* Si @x o @y no son numéricos se devuelve un error #VALOR!. \n"
"* Si @y < 0, se devuelve un error #NÚM!.\n"
"* Esta función extiende la función Excel del mismo nombre a órdenes sobre no "
"enteros.\n"
"\n"
"@EXAMPLES=\n"
"BESSELI(0.7,3) igual a 0,007367374.\n"
"\n"
"@SEEALSO=BESSELJ,BESSELK,BESSELY"

#: ../plugins/fn-eng/functions.c:701
msgid ""
"@FUNCTION=BESSELK\n"
"@SYNTAX=BESSELK(x,y)\n"
"@DESCRIPTION=BESSELK function returns the Neumann, Weber or Bessel function. "
"@x is where the function is evaluated. @y is the order of the Bessel "
"function.\n"
"\n"
"* If @x or @y are not numeric a #VALUE! error is returned.\n"
"* If @y < 0 a #NUM! error is returned.\n"
"* This function extends the Excel function of the same name to non-integer "
"orders.\n"
"\n"
"@EXAMPLES=\n"
"BESSELK(3,9) equals 397.95880.\n"
"\n"
"@SEEALSO=BESSELI,BESSELJ,BESSELY"
msgstr ""
"@FUNCTION=BESSELK\n"
"@SYNTAX=BESSELK(x,y)\n"
"@DESCRIPTION=La función BESSELK devuelve la función de Neumann, Weber o "
"Bessel.\n"
"\n"
"@x es donde se evalúa la función. @y es el orden de la función Bessel.\n"
"\n"
"* Si x o n no son numéricos se devuelve un error #VALOR!.\n"
"* Si y < 0 se devuelve un error #NÚM!.\n"
"* Esta función extiende la función Excel del mismo nombre a órdenes sobre no "
"enteros.\n"
"\n"
"@EXAMPLES=\n"
"BESSELK(3,9) igual a 397,95880.\n"
"\n"
"@SEEALSO=BESSELI,BESSELJ,BESSELY"

#: ../plugins/fn-eng/functions.c:736
msgid ""
"@FUNCTION=BESSELJ\n"
"@SYNTAX=BESSELJ(x,y)\n"
"@DESCRIPTION=BESSELJ function returns the Bessel function with @x is where "
"the function is evaluated. @y is the order of the Bessel function, if non-"
"integer it is truncated.\n"
"\n"
"* If @x or @y are not numeric a #VALUE! error is returned.\n"
"* If @y < 0 a #NUM! error is returned.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"BESSELJ(0.89,3) equals 0.013974004.\n"
"\n"
"@SEEALSO=BESSELI,BESSELK,BESSELY"
msgstr ""
"@FUNCTION=BESSELJ\n"
"@SYNTAX=BESSELJ(x,y)\n"
"@DESCRIPTION=La función BESSELJ devuelve la función Bessel donde @x es donde "
"se evalúa la función. @y es el orden de la función Bessel, si no es entero "
"se trunca.\n"
"\n"
"* Si @x ó @y no son numéricos se devuelve un error #VALOR!.\n"
"* Si @y < 0, se devuelve un error #NÚM!\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"BESSELJ(0.89,3) igual a 0,013974004.\n"
"\n"
"@SEEALSO=BESSELJ,BESSELK,BESSELY"

#: ../plugins/fn-eng/functions.c:774
msgid ""
"@FUNCTION=BESSELY\n"
"@SYNTAX=BESSELY(x,y)\n"
"@DESCRIPTION=BESSELY function returns the Neumann, Weber or Bessel "
"function.\n"
"\n"
"@x is where the function is evaluated. @y is the order of the Bessel "
"function, if non-integer it is truncated.\n"
"\n"
"* If @x or @y are not numeric a #VALUE! error is returned.\n"
"* If @y < 0 a #NUM! error is returned.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"BESSELY(4,2) equals 0.215903595.\n"
"\n"
"@SEEALSO=BESSELI,BESSELJ,BESSELK"
msgstr ""
"@FUNCTION=BESSELY\n"
"@SYNTAX=BESSELY(x,y)\n"
"@DESCRIPTION=La función BESSELY devuelve la función de Neumann, Weber o "
"Bessel. @x es donde se evalúa la función. @y es el orden de la función "
"Bessel, si no es entero se trunca.\n"
"\n"
"* Si x o n no son numéricos se devuelve un error #VALOR!.\n"
"* Si n < 0, se devuelve un error #NÚM!.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"BESSELY(4,2) igual a 0,215903595.\n"
"\n"
"@SEEALSO=BESSELJ,BESSELK,BESSELY"

#: ../plugins/fn-eng/functions.c:816
msgid ""
"@FUNCTION=CONVERT\n"
"@SYNTAX=CONVERT(number,from_unit,to_unit)\n"
"@DESCRIPTION=CONVERT returns a conversion from one measurement system to "
"another.  For example, you can convert a weight in pounds to a weight in "
"grams.  @number is the value you want to convert, @from_unit specifies the "
"unit of the @number, and @to_unit is the unit for the result.\n"
"\n"
"@from_unit and @to_unit can be any of the following:\n"
"\n"
"Weight and mass:\n"
"\t'g'  \t\tGram\n"
"\t'sg' \t\tSlug\n"
"\t'lbm'\t\tPound\n"
"\t'u'  \t\tU (atomic mass)\n"
"\t'ozm'\t\tOunce\n"
"\n"
"Distance:\n"
"\t'm'   \t\tMeter\n"
"\t'mi'  \t\tStatute mile\n"
"\t'Nmi' \t\tNautical mile\n"
"\t'in'  \t\tInch\n"
"\t'ft'  \t\tFoot\n"
"\t'yd'  \t\tYard\n"
"\t'ang' \t\tAngstrom\n"
"\t'Pica'\t\tPica\n"
"\n"
"Time:\n"
"\t'yr'  \t\tYear\n"
"\t'day' \t\tDay\n"
"\t'hr'  \t\tHour\n"
"\t'mn'  \t\tMinute\n"
"\t'sec' \t\tSecond\n"
"\n"
"Pressure:\n"
"\t'Pa'  \t\tPascal\n"
"\t'atm' \t\tAtmosphere\n"
"\t'mmHg'\tmm of Mercury\n"
"\n"
"Force:\n"
"\t'N'   \t\tNewton\n"
"\t'dyn' \t\tDyne\n"
"\t'lbf' \t\tPound force\n"
"\n"
"Energy:\n"
"\t'J'    \t\tJoule\n"
"\t'e'    \t\tErg\n"
"\t'c'    \t\tThermodynamic calorie\n"
"\t'cal'  \t\tIT calorie\n"
"\t'eV'   \tElectron volt\n"
"\t'HPh'  \tHorsepower-hour\n"
"\t'Wh'   \tWatt-hour\n"
"\t'flb'  \t\tFoot-pound\n"
"\t'BTU'  \tBTU\n"
"\n"
"Power:\n"
"\t'HP'   \tHorsepower\n"
"\t'W'    \tWatt\n"
"\n"
"Magnetism:\n"
"\t'T'    \t\tTesla\n"
"\t'ga'   \tGauss\n"
"\n"
"Temperature:\n"
"\t'C'    \t\tDegree Celsius\n"
"\t'F'    \t\tDegree Fahrenheit\n"
"\t'K'    \t\tDegree Kelvin\n"
"\n"
"Liquid measure:\n"
"\t'tsp'  \t\tTeaspoon\n"
"\t'tbs'  \t\tTablespoon\n"
"\t'oz'   \t\tFluid ounce\n"
"\t'cup'  \tCup\n"
"\t'pt'   \t\tPint\n"
"\t'qt'   \t\tQuart\n"
"\t'gal'  \t\tGallon\n"
"\t'l'    \t\tLiter\n"
"\n"
"For metric units any of the following prefixes can be used:\n"
"\t'Y'  \tyotta \t1E+24\n"
"\t'Z'  \tzetta \t1E+21\n"
"\t'E'  \texa   \t1E+18\n"
"\t'P'  \tpeta  \t1E+15\n"
"\t'T'  \ttera  \t\t1E+12\n"
"\t'G'  \tgiga  \t1E+09\n"
"\t'M'  \tmega  \t1E+06\n"
"\t'k'  \tkilo  \t\t1E+03\n"
"\t'h'  \thecto \t1E+02\n"
"\t'e'  \tdeka  \t1E+01\n"
"\t'd'  \tdeci  \t1E-01\n"
"\t'c'  \tcenti \t\t1E-02\n"
"\t'm'  \tmilli \t\t1E-03\n"
"\t'u'  \tmicro \t1E-06\n"
"\t'n'  \tnano  \t1E-09\n"
"\t'p'  \tpico  \t1E-12\n"
"\t'f'  \tfemto \t1E-15\n"
"\t'a'  \tatto  \t\t1E-18\n"
"\t'z'  \tzepto \t\t1E-21\n"
"\t'y'  \tyocto \t\t1E-24\n"
"\n"
"* If @from_unit and @to_unit are different types, CONVERT returns #N/A "
"error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"CONVERT(3,\"lbm\",\"g\") equals 1360.7769.\n"
"CONVERT(5.8,\"m\",\"in\") equals 228.3465.\n"
"CONVERT(7.9,\"cal\",\"J\") equals 33.07567.\n"
"\n"
"@SEEALSO="
msgstr ""
"@FUNCTION=CONVERT\n"
"@SYNTAX=CONVERT(número,unidad_origen,unidad_destino)\n"
"@DESCRIPTION=CONVERT devuelve una conversión de un sistema de medida a otro. "
"Por ejemplo, puede convertir un peso en libras a un peso en gramos. @número "
"es el valor que quiere convertir, @unidad_origen especifica la unidad del "
"@número y @unidad_destino es la unidad del resultado.\n"
"\n"
"@unidad_origen e @unidad_destino pueden ser cualesquiera de las siguientes:\n"
"\n"
"Peso y masa:\n"
"\t'g'   \t\tGramo\n"
"\t'sg'   \t\tSlug\n"
"\t'lbm'  \t\tLibra\n"
"\t'u'  \t\tU (masa atómica)\n"
"\t'ozm'  \t\tOnza\n"
"\n"
"Distancia:\n"
"\t'm'    \t\tMetro\n"
"\t'mi'    \t\tMilla imperial\n"
"\t'Nmi'   \t\tMilla náutica\n"
"\t'in'     \t\tPulgada\n"
"\t'ft'    \t\tPie\n"
"\t'yd'    \t\tYarda\n"
"\t'ang'    \t\tAngstrom\n"
"\t'Pica'    \t\tPica\n"
"\n"
"Tiempo:\n"
"\t'yr'      \t\tAño\n"
"\t'day'    \t\tDía\n"
"\t'hr'      \t\tHora\n"
"\t'mn'    \t\tMinuto\n"
"\t'sec'    \t\tSegundo\n"
"\n"
"Presión:\n"
"\t'Pa'   \t\tPascal\n"
"\t'atm'    \t\tAtmósfera\n"
"\t'mmHg'    \t\tmm de mercurio\n"
"\n"
"Fuerza:\n"
"\t'N'   \t\tNewton\n"
"\t'dyn'   \t\tDina\n"
"\t'lbf'    \t\tLibra de fuerza\n"
"\n"
"Energía:\n"
"\t'J'    \t\tJulio\n"
"\t'e'   \t\tErgio\n"
"\t'c'    \t\tCaloría termodinámica\n"
"\t'cal'   \t\tCaloría IT\n"
"\t'eV'    \t\telectrón-voltio\n"
"\t'HPh'   \t\tCaballo de vapor por hora\n"
"\t'Wh'   \t\tWatios hora\n"
"\t'flb'    \t\tLibra pie\n"
"\t'BTU'  \t\tBTU\n"
"\n"
"Potencia:\n"
"\t'HP'    \t\tCaballos de vapor\n"
"\t'W'    \t\tWatios\n"
"\n"
"Magnetismo:\n"
"\t'T'      \t\tTesla\n"
"\t'ga'    \t\tGauss\n"
"\n"
"Temperatura:\n"
"\t'C'    \t\tGrado Celsius\n"
"\t'F'    \t\tGrado Fahrenheit\n"
"\t'K'    \t\tGrado Kelvin\n"
"\n"
"Medida líquida:\n"
"\t'tsp'  \t\tCuchara de té\n"
"\t'tbs'  \t\tCuchara de mesa\n"
"\t'oz'  \t\tOnza fluida\n"
"\t'cup'  \t\tTaza\n"
"\t'pt  '\t\tPinta\n"
"\t'qt  '\t\tCuarto\n"
"\t'gal'  \t\tGalón\n"
"\t'l'  \t\tLitro\n"
"\n"
"Se pueden emplear los siguiente prefijos para las unidades métricas:\n"
"\t'Y'  \tyotta \t1E+24\n"
"\t'Z'  \tzetta \t1E+21\n"
"\t'E'  \texa   \t1E+18\n"
"\t'P'  \tpeta  \t1E+15\n"
"\t'T'  \ttera  \t\t1E+12\n"
"\t'G'  \tgiga  \t1E+09\n"
"\t'M'  \tmega  \t1E+06\n"
"\t'k'  \tkilo  \t\t1E+03\n"
"\t'h'  \thecto \t1E+02\n"
"\t'e'  \tdeka  \t1E+01\n"
"\t'd'  \tdeci  \t1E-01\n"
"\t'c'  \tcenti \t\t1E-02\n"
"\t'm'  \tmilli \t\t1E-03\n"
"\t'u'  \tmicro \t1E-06\n"
"\t'n'  \tnano  \t1E-09\n"
"\t'p'  \tpico  \t1E-12\n"
"\t'f'  \tfemto \t1E-15\n"
"\t'a'  \tatto  \t\t1E-18\n"
"\t'z'  \tzepto \t\t1E-21\n"
"\t'y'  \tyocto \t\t1E-24\n"
"\n"
"* Si @unidad_origen y @unidad_destino son de tipos diferentes, CONVERT "
"devuelve el error #N/A.\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"CONVERT(3,\"lbm\",\"g\") es igual a 1360.7769.\n"
"CONVERT(5.8,\"m\",\"in\") es igual a 228.3465.\n"
"CONVERT(7.9,\"cal\",\"J\") es igual a 33.07567.\n"
"\n"
"@SEEALSO="

#: ../plugins/fn-eng/functions.c:1233
msgid ""
"@FUNCTION=ERF\n"
"@SYNTAX=ERF([lower limit,]upper_limit)\n"
"@DESCRIPTION=ERF returns the error function.  With a single argument ERF "
"returns the error function, defined as\n"
"\n"
"\terf(x) = 2/sqrt(pi)* integral from 0 to x of exp(-t*t) dt.\n"
"\n"
"If two arguments are supplied, they are the lower and upper limits of the "
"integral.\n"
"\n"
"* If either @lower_limit or @upper_limit is not numeric a #VALUE! error is "
"returned.\n"
"* This function is upward-compatible with that in Excel. (If two arguments "
"are supplied, Excel will not allow either to be negative.)\n"
"\n"
"@EXAMPLES=\n"
"ERF(0.4) equals 0.428392355.\n"
"ERF(1.6448536269515/SQRT(2)) equals 0.90.\n"
"\n"
"The second example shows that a random variable with a normal distribution "
"has a 90 percent chance of falling within approximately 1.645 standard "
"deviations of the mean.\n"
"@SEEALSO=ERFC"
msgstr ""
"@FUNCTION=ERF\n"
"@SYNTAX=ERF([límite inferior,]límite_superior)\n"
"@DESCRIPTION=ERF devuelve la función de error, Con un simple argumento ERF "
"devuelve la función de error definida como\n"
"\n"
"\terf(x) = 2/sqrt(pi)* integral de 0 a x de exp(-t*t) dt.\n"
"\n"
"Si se suministran dos argumentos, son los límites inferior y superior de la "
"integral.\n"
"\n"
"* Si @límite_inferior o @límite_superior no son numéricos se devuelve un "
"error #VALOR!.\n"
"* Esta función es compatible en parte con Excel. (Si se dan dos argumentos, "
"Excel no permitirá que alguno sea negativo.)\n"
"\n"
"@EXAMPLES=\n"
"ERF(0.4) igual a 0.428392355.\n"
"ERF(1.6448536269515/SQRT(2)) igual a 0.90.\n"
"\n"
"El segundo ejemplo muestra que una variable aleatoria con una distribución "
"normal tiene una oportunidad de un 90 por ciento de fallo en aproximadamente "
"1.645 desviaciones estándar de la media.\n"
"@SEEALSO=ERFC"

#: ../plugins/fn-eng/functions.c:1284
msgid ""
"@FUNCTION=ERFC\n"
"@SYNTAX=ERFC(x)\n"
"@DESCRIPTION=ERFC function returns the complementary error function, defined "
"as\n"
"\n"
"\t1 - erf(x).\n"
"\n"
"erfc(x) is calculated more accurately than 1 - erf(x) for arguments larger "
"than about 0.5.\n"
"\n"
"* If @x is not numeric a #VALUE! error is returned.  \n"
"@EXAMPLES=\n"
"ERFC(6) equals 2.15197367e-17.\n"
"\n"
"@SEEALSO=ERF"
msgstr ""
"@FUNCTION=ERFC\n"
"@SYNTAX=ERFC(x)\n"
"@DESCRIPTION=La función ERFC devuelve la función de error complementaria, "
"definida como:\n"
"\n"
"\t1 - erf(x).\n"
"\n"
"erfc(x) se calcula de forma más exacta que 1 - erf(x) para argumentos "
"mayores que 0.5.\n"
"\n"
"* Si @x no es numérico se devuelve un error #VALOR!.\n"
"\n"
"@EXAMPLES=\n"
"ERFC(6) igual a 2.15197367e-17.\n"
"\n"
"@SEEALSO=ERF"

#: ../plugins/fn-eng/functions.c:1315
msgid ""
"@FUNCTION=DELTA\n"
"@SYNTAX=DELTA(x[,y])\n"
"@DESCRIPTION=DELTA function tests for numerical equivalence of two "
"arguments, returning 1 in case of equality.\n"
"\n"
"* @y is optional, and defaults to 0.\n"
"* If either argument is non-numeric returns a #VALUE! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"DELTA(42.99,43) equals 0.\n"
"\n"
"@SEEALSO=EXACT,GESTEP"
msgstr ""
"@FUNCTION=DELTA\n"
"@SYNTAX=DELTA(x[,y])\n"
"@DESCRIPTION=Verifica la equivalencia numérica de dos argumentos, "
"devolviendo 1 en caso de igualdad. \n"
"\n"
"* @y es opcional, cuyo valor por omisión es 0.\n"
"* Si alguno de los argumentos no es numérico devuelve el error #VALOR!.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"DELTA(42.99,43) es igual a 0.\n"
"\n"
"@SEEALSO=EXACT, GESTEP"

#: ../plugins/fn-eng/functions.c:1347
msgid ""
"@FUNCTION=GESTEP\n"
"@SYNTAX=GESTEP(x[,y])\n"
"@DESCRIPTION=GESTEP function tests if @x is >= @y, returning 1 if it is so, "
"and 0 otherwise. @y is optional, and defaults to 0.\n"
"\n"
"* If either argument is non-numeric returns a #VALUE! error.\n"
"* This function is Excel compatible.\n"
"@EXAMPLES=\n"
"GESTEP(5,4) equals 1.\n"
"\n"
"@SEEALSO=DELTA"
msgstr ""
"@FUNCTION=GESTEP\n"
"@SYNTAX=GESTEP(x[,y])\n"
"@DESCRIPTION=GESTEP Evalúa si @x es >= @y, devolviendo 1 si es así y 0 en "
"caso contrario. @y es opcional y su valor predeterminado es 0.\n"
"\n"
"* Si alguno de los argumentos no es numérico, devuelve el error #VALOR!.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"GESTEP(5,4) es igual a 1.\n"
"\n"
"@SEEALSO=DELTA"

#: ../plugins/fn-eng/functions.c:1378
msgid ""
"@FUNCTION=INVSUMINV\n"
"@SYNTAX=INVSUMINV(x1,x2,...)\n"
"@DESCRIPTION=INVSUMINV sum calculates the inverse of the sum of inverses.\n"
"\n"
"The primary use of this is for calculating equivalent resistance for "
"parallel resistors or equivalent capacitance of a series of capacitors.\n"
"\n"
"* All arguments must be non-negative, or else a #VALUE! result is returned.\n"
"* If any argument is zero, the result is zero.\n"
"\n"
"@EXAMPLES=\n"
"INVSUMINV(2000,2000) equals 1000.\n"
"\n"
"@SEEALSO=HARMEAN"
msgstr ""
"@FUNCTION=INVSUMINV\n"
"@SYNTAX=INVSUMINV(x1,x2,…)\n"
"@DESCRIPTION=INVSUMINV calcula la suma de la inversa de la suma de "
"inversas.\n"
"\n"
"El uso principal de esta es para calcular la resistencia equivalente para "
"resistencias paralelas o la capacidad equivalente de condensadores en "
"serie.\n"
"\n"
"* Todos los argumentos deben ser no negativos, o si no se devuelve un "
"resultado #VALOR!.\n"
"* Si cualquier argumento es cero, el resultado es cero.\n"
"\n"
"@EXAMPLES=\n"
"INVSUMINV(2000,2000) igual a 1000.\n"
"\n"
"@SEEALSO=HARMEAN"

#: ../plugins/fn-erlang/functions.c:107
msgid ""
"@FUNCTION=PROBBLOCK\n"
"@SYNTAX=PROBBLOCK(traffic,circuits)\n"
"@DESCRIPTION=PROBBLOCK returns probability of blocking when a number of "
"@traffic loads into a number of @circuits (servers).\n"
"\n"
"* @traffic cannot exceed @circuits\n"
"\n"
"@EXAMPLES=\n"
"PROBBLOCK(24,30) returns 0.4012.\n"
"\n"
"@SEEALSO=OFFTRAF, DIMCIRC, OFFCAP"
msgstr ""
"@FUNCTION=PROBBLOCK\n"
"@SYNTAX=PROBBLOCK(tráfico,circuitos)\n"
"@DESCRIPTION=PROBBLOCK revuelve la probabilidad de bloqueo cuando se carga "
"un número de cargas de @tráfico en un número de @circuitos (servidores).\n"
"\n"
"* @tráfico no puede exceder @circuitos\n"
"\n"
"@EXAMPLES=\n"
"PROBBLOCK(24,30) devuelve 0,4012.\n"
"\n"
"@SEEALSO=OFFTRAF, DIMCIRC, OFFCAP"

#: ../plugins/fn-erlang/functions.c:139
msgid ""
"@FUNCTION=OFFTRAF\n"
"@SYNTAX=OFFTRAF(traffic,circuits)\n"
"@DESCRIPTION=OFFTRAF returns a predicted number of offered traffic from a "
"number of carried @traffic (taken from measurements) on a number of "
"@circuits.\n"
"\n"
"* @traffic cannot exceed @circuits\n"
"\n"
"@EXAMPLES=\n"
"OFFTRAF(24,30) returns 25.527.\n"
"\n"
"@SEEALSO=PROBBLOCK, DIMCIRC, OFFCAP"
msgstr ""
"@FUNCTION=OFFTRAF\n"
"@SYNTAX=OFFTRAF(tráfico,circuitos)\n"
"@DESCRIPTION=OFFTRAF devuelve la predicción de un número de tráfico ofrecido "
"un número de tráfico acarreado @tráfico (tomado de medidas) en un número de "
"@circuitos.\n"
"\n"
"* @tráfico no puede exceder @circuitos\n"
"\n"
"@EXAMPLES=\n"
"OFFTRAF(24,30) devuelve 25,527.\n"
"\n"
"@SEEALSO=PROBBLOCK, DIMCIRC, OFFCAP"

#: ../plugins/fn-erlang/functions.c:208
msgid ""
"@FUNCTION=DIMCIRC\n"
"@SYNTAX=DIMCIRC(traffic,gos)\n"
"@DESCRIPTION=DIMCIRC returns a number of circuits required from a number of "
"@traffic loads with @gos grade of service.\n"
"\n"
"@EXAMPLES=\n"
"DIMCIRC(24,1%) returns 35.\n"
"\n"
"@SEEALSO=OFFCAP, OFFTRAF, PROBBLOCK"
msgstr ""
"@FUNCTION=DIMCIRC\n"
"@SYNTAX=DIMCIRC(tráfico,gos)\n"
"@DESCRIPTION=DIMCIRC devuelve un número de circuitos requeridos desde un "
"número de cargas de @tráfico con grado de servicio @gos.\n"
"\n"
"@EXAMPLES=\n"
"DIMCIRC(24,1%) devuelve 35.\n"
"\n"
"@SEEALSO=OFFCAP, OFFTRAF, PROBBLOCK"

#: ../plugins/fn-erlang/functions.c:253
msgid ""
"@FUNCTION=OFFCAP\n"
"@SYNTAX=OFFCAP(circuits,gos)\n"
"@DESCRIPTION=OFFCAP returns a number of traffic capacity given by a number "
"of @circuits with @gos grade of service.\n"
"\n"
"@EXAMPLES=\n"
"OFFCAP(30,1%) returns 20.337.\n"
"\n"
"@SEEALSO=DIMCIRC, OFFTRAF, PROBBLOCK"
msgstr ""
"@FUNCTION=OFFCAP\n"
"@SYNTAX=OFFCAP(circuitos,gos)\n"
"@DESCRIPTION=OFFCAP devuelve un número de tráfico de capacidad dada por un "
"número de @circuitos con @gos de grados de servicio.\n"
"\n"
"@EXAMPLES=\n"
"OFFCAP(30,1%) devuelve 20.337.\n"
"\n"
"@SEEALSO=DIMCIRC, OFFTRAF, PROBBLOCK"

#: ../plugins/fn-financial/functions.c:353
msgid ""
"@FUNCTION=ACCRINT\n"
"@SYNTAX=ACCRINT(issue,first_interest,settlement,rate,par,frequency[,basis])\n"
"@DESCRIPTION=ACCRINT calculates the accrued interest for a security that "
"pays periodic interest.\n"
"\n"
"@issue is the issue date of the security.  @first_interest is the first "
"interest date of the security.  @settlement is the settlement date of the "
"security.  The settlement date is always after the issue date (the date when "
"the security is bought). @rate is the annual rate of the security and @par "
"is the par value of the security. @frequency is the number of coupon "
"payments per year.\n"
"\n"
"Allowed frequencies are:\n"
"  1 = annual,\n"
"  2 = semi,\n"
"  4 = quarterly.\n"
"\n"
"@basis is the type of day counting system you want to use:\n"
"\n"
"  0  US 30/360\n"
"  1  actual days/actual days\n"
"  2  actual days/360\n"
"  3  actual days/365\n"
"  4  European 30/360\n"
"\n"
"* If @issue date, @first_interest date, or @settlement date is not valid, "
"ACCRINT returns #NUM! error.\n"
"* The dates must be @issue < @first_interest < @settlement, or ACCRINT "
"returns #NUM! error.\n"
"* If @rate <= 0 or @par <= 0 , ACCRINT returns #NUM! error.\n"
"* If @basis is omitted, US 30/360 is applied.\n"
"* If @basis < 0 or @basis > 4, ACCRINT returns #NUM! error.\n"
"* If @issue date is after @settlement date or they are the same, ACCRINT "
"returns #NUM! error.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=ACCRINTM"
msgstr ""
"@FUNCTION=ACCRINT\n"
"@SYNTAX=ACCRINT(emisión,primer_interés, liquidación,tasa,par,frecuencia[,"
"base])\n"
"@DESCRIPTION=ACCRINT calcula el interés acumulado para una acción que paga "
"interés periódico.\n"
"\n"
"@emisión es la fecha de emisión de la acción. @primer_interés es la fecha de "
"primer interés de la acción. @liquidación es la fecha de liquidación de la "
"acción, La fecha de liquidación es siempre posterior a la de emisión, (la "
"fecha cuando se compró la acción) @tasa es la tasa anual de la acción y @par "
"es el valor par de la acción. @frecuencia es el número de pagos al cupón por "
"año.\n"
"Las frecuencias permitidas son:\n"
" 1 = anual,\n"
" 2 = semi,\n"
" 4 = cada cuatro meses.\n"
"\n"
"@base es el tipo de sistema de conteo de días que quiere usar:\n"
"\n"
" 0 US 30/360\n"
" 1 días actuales/días actuales\n"
" 2 días actuales/360\n"
" 3 días actuales/365\n"
" 4 Europeo 30/360\n"
"\n"
"* Si la fecha de @emisión, la fecha de @primer_interés o la fecha de "
"@vencimiento no es válida, ACCRINT devuelve un error #NÚM!\n"
"* Las fechas deben ser @emisión < @primer_interés < @vencimiento, o ACCRINT "
"devuelve un error #NÚM!\n"
"* Si @tasa <= 0 o @par <=0, ACCRINT revuelve un error #NÚM!.\n"
"* Si se omite la @base, se aplica US 30/360.\n"
"* Si @base < 0 o @base > 4, ACCRINT devuelve un error #NÚM!\n"
"* Si la fecha de @emisión es posterior a la fecha de @vencimiento o son la "
"misma, ACCRINT devuelve un error #NÚM!\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=ACCRINTM"

#: ../plugins/fn-financial/functions.c:442
msgid ""
"@FUNCTION=ACCRINTM\n"
"@SYNTAX=ACCRINTM(issue,maturity,rate[,par,basis])\n"
"@DESCRIPTION=ACCRINTM calculates and returns the accrued interest for a "
"security from @issue to @maturity date.\n"
"\n"
"@issue is the issue date of the security.  @maturity is the maturity date of "
"the security.  @rate is the annual rate of the security and @par is the par "
"value of the security. If you omit @par, ACCRINTM applies $1,000 instead.  "
"@basis is the type of day counting system you want to use:\n"
"\n"
"  0  US 30/360\n"
"  1  actual days/actual days\n"
"  2  actual days/360\n"
"  3  actual days/365\n"
"  4  European 30/360\n"
"\n"
"* If @issue date or @maturity date is not valid, ACCRINTM returns #NUM! "
"error.\n"
"* If @rate <= 0 or @par <= 0, ACCRINTM returns #NUM! error.\n"
"* If @basis is omitted, US 30/360 is applied.\n"
"* If @basis < 0 or @basis > 4, ACCRINTM returns #NUM! error.\n"
"* If @issue date is after @maturity date or they are the same, ACCRINTM "
"returns #NUM! error.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=ACCRINT"
msgstr ""
"@FUNCTION=ACCRINTM\n"
"@SYNTAX=ACCRINTM(emisión,vencimiento,tasa[,par,base])\n"
"@DESCRIPTION=ACCRINTM calcula y devuelve el interés acumulado para una "
"acción desde la fecha de @emisión hasta la fecha de @vencimiento.\n"
"\n"
"@vencimiento es la fecha de vencimiento de la acción, @tasa es la tasa anual "
"de la acción y @par es el valor par de la acción. Si omite @par, ACCRINTM "
"aplica 1.000$ en su lugar.@base es el tipo de sistema de conteo de días que "
"quiere usar:\n"
"\n"
" 0 US 30/360\n"
" 1 días actuales/días actuales\n"
" 2 días actuales/360\n"
" 3 días actuales/365\n"
" 4 Europeo 30/360\n"
"\n"
"* Si la fecha de @emisión o @vencimiento no es válida,ACCRINTM devuelve un "
"error #NÚM!\n"
"* Si @tasa <= 0 o @par <=0, ACCRINTM revuelve un error #NÚM!.\n"
"* Si se omite la @base, se aplica US 30/360.\n"
"* Si @base < 0 o @base > 4, ACCRINTM devuelve un error #NÚM!\n"
"* Si la fecha de @emisión es posterior a la fecha de @vencimiento o son la "
"misma, ACCRINTM devuelve un error #NÚM!\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=ACCRINT"

#: ../plugins/fn-financial/functions.c:500
msgid ""
"@FUNCTION=INTRATE\n"
"@SYNTAX=INTRATE(settlement,maturity,investment,redemption[,basis])\n"
"@DESCRIPTION=INTRATE calculates and returns the interest rate of a fully "
"vested security.\n"
"\n"
"@settlement is the settlement date of the security.  @maturity is the "
"maturity date of the security. @investment is the price of the security paid "
"at @settlement date and @redemption is the amount to be received at "
"@maturity date.\n"
"\n"
"@basis is the type of day counting system you want to use:\n"
"\n"
"  0  US 30/360\n"
"  1  actual days/actual days\n"
"  2  actual days/360\n"
"  3  actual days/365\n"
"  4  European 30/360\n"
"\n"
"* If @settlement date or @maturity date is not valid, INTRATE returns #NUM! "
"error.\n"
"* If @basis is omitted, US 30/360 is applied.\n"
"* If @basis < 0 or @basis > 4, INTRATE returns #NUM! error.\n"
"* If @settlement date is after @maturity date or they are the same, INTRATE "
"returns #NUM! error.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"If you had a bond with a settlement date of April 15, 2000, maturity date "
"September 30, 2000, investment of $100,000, redemption value $103,525, using "
"the actual/actual basis, the bond discount rate is:\n"
"=INTRATE(36631, 36799, 100000, 103525, 1) which equals 0.0648 or 6.48%\n"
"@SEEALSO=RECEIVED, DATE"
msgstr ""
"@FUNCTION=INTRATE\n"
"@SYNTAX=INTRATE(liquidación,vencimiento,inversión,amortización[,base])\n"
"@DESCRIPTION=INTRATE calcula y devuelve la tasa de interés de una acción "
"completamente invertida.\n"
"\n"
"@liquidación es la fecha de liquidación de la acción. @vencimiento es la "
"fecha de vencimiento de la acción. @inversión es el precio pagado por la "
"acción en la fecha de @liquidación y @amortización es la cantidad a ser "
"recibida en la fecha de @vencimiento.\n"
"\n"
"@base es el tipo de sistema de conteo de días que quiere usar:\n"
"\n"
" 0 US 30/360\n"
" 1 días actuales/días actuales\n"
" 2 días actuales/360\n"
" 3 días actuales/365\n"
" 4 Europeo 30/360\n"
"\n"
"* Si la fecha de @liquidación o @vencimiento no es válida, INTRATE devuelve "
"un error #NÚM!\n"
"* Si se omite la @base, se aplica US 30/360.\n"
"* Si @base < 0 o @base > 4, INTRATE devuelve un error #NÚM!\n"
"* Si la fecha de @liquidación es posterior a la fecha de @vencimiento o son "
"la misma, INTRATE devuelve un error #NÚM!\n"
"\n"
"@EXAMPLES=\n"
"\n"
"Si tuvo un bono con una fecha de liquidación el 15 de Abril de 2000, fecha "
"de vencimiento 20 de Spetiembre de 2000, inversión de 100.000 $, valor de "
"amortización 103.525$, usando la base actual/actual, la tasa de descuento "
"del bono es:\n"
"=INTRATE(36631, 36799, 100000, 103525, 1) que es igual a 0,0648 o 6,48%\n"
"@SEEALSO=RECEIVED, DATE"

#: ../plugins/fn-financial/functions.c:565
msgid ""
"@FUNCTION=RECEIVED\n"
"@SYNTAX=RECEIVED(settlement,maturity,investment,rate[,basis])\n"
"@DESCRIPTION=RECEIVED calculates and returns the amount to be received at "
"maturity date for a security bond.\n"
"\n"
"@settlement is the settlement date of the security.  @maturity is the "
"maturity date of the security.  The amount of investment is specified in "
"@investment.  @rate is the security's discount rate.\n"
"\n"
"@basis is the type of day counting system you want to use:\n"
"\n"
"  0  US 30/360\n"
"  1  actual days/actual days\n"
"  2  actual days/360\n"
"  3  actual days/365\n"
"  4  European 30/360\n"
"\n"
"* If @settlement date or @maturity date is not valid, RECEIVED returns #NUM! "
"error.\n"
"* If @basis is omitted, US 30/360 is applied.\n"
"* If @basis < 0 or @basis > 4, RECEIVED returns #NUM! error.\n"
"* If @settlement date is after @maturity date or they are the same, RECEIVED "
"returns #NUM! error.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=INTRATE"
msgstr ""
"@FUNCTION=RECEIVED\n"
"@SYNTAX=RECEIVED(liquidación,vencimiento,inversión,tasa[,base])\n"
"@DESCRIPTION=RECEIVED calcula y devuelve la cantidad a ser recibida a la "
"fecha de vencimiento para una acción bono.\n"
"\n"
"@liquidación es la fecha de liquidación de la acción. @vencimiento es la "
"fecha de vencimiento de la acción. La cantidad de inversión se especifica en "
"@inversión. @tasa es la tasa de descuento de la acción.\n"
"\n"
"@base es el tipo de sistema de conteo de días que quiere usar:\n"
"\n"
" 0 US 30/360\n"
" 1 días actuales/días actuales\n"
" 2 días actuales/360\n"
" 3 días actuales/365\n"
" 4 Europeo 30/360\n"
"\n"
"* Si la fecha de @liquidación o @vencimiento no es válida, RECEIVED devuelve "
"un error #NÚM!\n"
"* Si se omite la @base, se aplica US 30/360.\n"
"* Si @base < 0 o @base > 4, RECEIVED devuelve un error #NÚM!\n"
"* Si la fecha de @liquidación es posterior a la fecha de @vencimiento o son "
"la misma, RECEIVED devuelve un error #NÚM!\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=INTRATE"

#: ../plugins/fn-financial/functions.c:627
msgid ""
"@FUNCTION=PRICEDISC\n"
"@SYNTAX=PRICEDISC(settlement,maturity,discount,redemption[,basis])\n"
"@DESCRIPTION=PRICEDISC calculates and returns the price per $100 face value "
"of a security bond.  The security does not pay interest at maturity.\n"
"\n"
"@settlement is the settlement date of the security. @maturity is the "
"maturity date of the security.  @discount is the rate for which the security "
"is discounted.  @redemption is the amount to be received on @maturity date.\n"
"\n"
"@basis is the type of day counting system you want to use:\n"
"\n"
"  0  US 30/360\n"
"  1  actual days/actual days\n"
"  2  actual days/360\n"
"  3  actual days/365\n"
"  4  European 30/360\n"
"\n"
"* If @settlement date or @maturity date is not valid, PRICEDISC returns "
"#NUM! error.\n"
"* If @basis is omitted, US 30/360 is applied.\n"
"* If @basis < 0 or @basis > 4, PRICEDISC returns #NUM! error.\n"
"* If @settlement date is after @maturity date or they are the same, "
"PRICEDISC returns #NUM! error.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=PRICEMAT"
msgstr ""
"@FUNCTION=PRICEDISC\n"
"@SYNTAX=PRICEDISC(liquidación,vencimiento,descuento,amortización[,base])\n"
"@DESCRIPTION=PRICEDISC calcula y devuelve el precio de por cada 100$ de "
"valor facial de una acción bono. La acción no paga interés al vencimiento.\n"
"\n"
"@liquidación es la fecha de liquidación de la acción. @vencimiento es la "
"fecha de vencimiento de la acción. @descuento es la tasa para la que la "
"acción se descuenta. @amortización es la cantidad a ser recibida a la fecha "
"de @vencimiento.\n"
"\n"
"@base es el tipo de sistema de conteo de días que quiere usar:\n"
"\n"
" 0 US 30/360\n"
" 1 días actuales/días actuales\n"
" 2 días actuales/360\n"
" 3 días actuales/365\n"
" 4 Europeo 30/360\n"
"\n"
"* Si la fecha de @liquidación o @vencimiento no es válida, PRICEDISC "
"devuelve un error #NÚM!\n"
"* Si se omite la @base, se aplica US 30/360.\n"
"* Si @base < 0 o @base > 4, PRICEDISC devuelve un error #NÚM!\n"
"* Si la fecha de @liquidación es posterior a la fecha de @vencimiento o son "
"la misma, PRICEDISC devuelve un error #NÚM!\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=PRICEMAT"

#: ../plugins/fn-financial/functions.c:684
msgid ""
"@FUNCTION=PRICEMAT\n"
"@SYNTAX=PRICEMAT(settlement,maturity,issue,rate,yield[,basis])\n"
"@DESCRIPTION=PRICEMAT calculates and returns the price per $100 face value "
"of a security.  The security pays interest at maturity.\n"
"\n"
"@settlement is the settlement date of the security.  @maturity is the "
"maturity date of the security.  @issue is the issue date of the security.  "
"@rate is the discount rate of the security. @yield is the annual yield of "
"the security. @basis is the type of day counting system you want to use:\n"
"\n"
"  0  US 30/360\n"
"  1  actual days/actual days\n"
"  2  actual days/360\n"
"  3  actual days/365\n"
"  4  European 30/360\n"
"\n"
"* If @settlement date or @maturity date is not valid, PRICEMAT returns #NUM! "
"error.\n"
"* If @basis is omitted, US 30/360 is applied.\n"
"* If @basis < 0 or @basis > 4, PRICEMAT returns #NUM! error.\n"
"* If @settlement date is after @maturity date or they are the same, PRICEMAT "
"returns #NUM! error.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=PRICEDISC"
msgstr ""
"@FUNCTION=PRICEMAT\n"
"@SYNTAX=PRICEMAT(liquidación,vencimiento,emisión,tasa,margen[,base])\n"
"@DESCRIPTION=PRICEMAT calcula y devuelve el precio por cada 100$ de valor "
"facialde una acción. LA acción paga intereses al vencimiento.\n"
"\n"
"@liquidación es la fecha de liquidación de la acción. @vencimiento es la "
"fecha de vencimiento de la acción. @emisión es la fecha de emisión de la "
"acción. @tasa es la tasa de descuento de la acción. @margen es el margen "
"anual de la acción.\n"
"@base es el tipo de sistema de conteo de días que quiere usar:\n"
"\n"
" 0 US 30/360\n"
" 1 días actuales/días actuales\n"
" 2 días actuales/360\n"
" 3 días actuales/365\n"
" 4 Europeo 30/360\n"
"\n"
"* Si la fecha de @liquidación o @vencimiento no es válida, PRICEMAT devuelve "
"un error #NÚM!\n"
"* Si se omite la @base, se aplica US 30/360.\n"
"* Si @base < 0 o @base > 4, PRICEMAT devuelve un error #NÚM!\n"
"* Si la fecha de @liquidación es posterior a la fecha de @vencimiento o son "
"la misma, PRICEMAT devuelve un error #NÚM!\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=PRICEDISC"

#: ../plugins/fn-financial/functions.c:748
msgid ""
"@FUNCTION=DISC\n"
"@SYNTAX=DISC(settlement,maturity,par,redemption[,basis])\n"
"@DESCRIPTION=DISC calculates and returns the discount rate for a security. "
"@settlement is the settlement date of the security.\n"
"\n"
"@maturity is the maturity date of the security.  @par is the price per $100 "
"face value of the security.  @redemption is the redemption value per $100 "
"face value of the security.\n"
"\n"
"@basis is the type of day counting system you want to use:\n"
"\n"
"  0  US 30/360\n"
"  1  actual days/actual days\n"
"  2  actual days/360\n"
"  3  actual days/365\n"
"  4  European 30/360\n"
"\n"
"* If @settlement date or @maturity date is not valid, DISC returns #NUM! "
"error.\n"
"* If @basis is omitted, US 30/360 is applied.\n"
"* If @basis < 0 or @basis > 4, DISC returns #NUM! error.\n"
"* If @settlement date is after @maturity date or they are the same, DISC "
"returns #NUM! error.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO="
msgstr ""
"@FUNCTION=DISC\n"
"@SYNTAX=DISC (liquidación, vencimiento,par,amortización[,base])\n"
"@DESCRIPTION=DISC calcula y devuelve la tasa de descuento de una acción. "
"@liquidación es la fecha de liquidación de la acción.\n"
"\n"
"@vencimiento es la fecha de vencimiento de la acción. @par es el precio por "
"100$ de valor facial de la acción. @amortización es el valor de amortización "
"por cada 100$ de valor facial de la acción.\n"
"\n"
"@base es el tipo de sistema de conteo de días que quiere usar:\n"
"\n"
" 0 US 30/360\n"
" 1 días actuales/días actuales\n"
" 2 días actuales/360\n"
" 3 días actuales/365\n"
" 4 Europeo 30/360\n"
"\n"
"* Si la fecha de @liquidación o @vencimiento no es válida, DISC devuelve un "
"error#NUM! \n"
"* Si se omite la @base, se aplica US 30/360.\n"
"* Si @base < 0 o @base > 4, DISC devuelve un error #NUM!\n"
"* Si la fecha de @liquidación es posterior a la fecha de @vencimiento o son "
"la misma, DISC devuelve un error #NUM!\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO="

#: ../plugins/fn-financial/functions.c:804
msgid ""
"@FUNCTION=EFFECT\n"
"@SYNTAX=EFFECT(r,nper)\n"
"@DESCRIPTION=EFFECT calculates the effective interest rate from a given "
"nominal rate.\n"
"\n"
"Effective interest rate is calculated using this formula:\n"
"\n"
"    (1 + @r / @nper) ^ @nper - 1\n"
"\n"
"where:\n"
"\n"
"@r = nominal interest rate (stated in yearly terms)\n"
"@nper = number of periods used for compounding\n"
"\n"
"* If @rate < 0, EFFECT returns #NUM! error.\n"
"* If @nper <= 0, EFFECT returns #NUM! error.\n"
"\n"
"@EXAMPLES=\n"
"For example credit cards will list an APR (annual percentage rate) which is "
"a nominal interest rate.\n"
"For example if you wanted to find out how much you are actually paying "
"interest on your credit card that states an APR of 19% that is compounded "
"monthly you would type in:\n"
"=EFFECT(.19,12) and you would get .2075 or 20.75%. That is the effective "
"percentage you will pay on your loan.\n"
"@SEEALSO=NOMINAL"
msgstr ""
"@FUNCTION=EFFECT\n"
"@SYNTAX=EFFECT(r,nper)\n"
"@DESCRIPTION=EFFECT calcula la tasa de interés efectiva de una tasa nominal "
"dada.\n"
"\n"
"La tasa de interés efectiva se calcula usando esta fórmula:\n"
"\n"
"\t(1 + @r / @nper) ^ @nper - 1\n"
"\n"
"donde:\n"
"\n"
"@r = tasa nominal de interés (en términos anuales)\n"
"@nper = número de períodos usados para el cómputo\n"
"\n"
"@EXAMPLES=\n"
"Por ejemplo, las tarjetas de crédito listarán un TAE (Tasa Anual "
"Equivalente), que es un tasa de interés nominal.\n"
"Por ejemplo, si quiere averiguar qué interés está pagando actualmente por su "
"tarjeta de crédito que tiene un TAE del 19% que se computa mensualmente, "
"debería teclear:\n"
"=EFFECT(.19,12), y obtendría .2075 ó 20.75%. Este es el porcentaje efectivo "
"que pagará como arrendamiento.\n"
"@SEEALSO=NOMINAL"

#: ../plugins/fn-financial/functions.c:854
msgid ""
"@FUNCTION=NOMINAL\n"
"@SYNTAX=NOMINAL(r,nper)\n"
"@DESCRIPTION=NOMINAL calculates the nominal interest rate from a given "
"effective rate.\n"
"\n"
"Nominal interest rate is given by a formula:\n"
"\n"
"@nper * (( 1 + @r ) ^ (1 / @nper) - 1 )\n"
"where:\n"
"\n"
"@r = effective interest rate\n"
"@nper = number of periods used for compounding\n"
"\n"
"* If @rate < 0, NOMINAL returns #NUM! error.\n"
"* If @nper <= 0, NOMINAL returns #NUM! error.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=EFFECT"
msgstr ""
"@FUNCTION=NOMINAL\n"
"@SYNTAX=NOMINAL(r,nper)\n"
"@DESCRIPTION=NOMINAL calcula la tasa de interés nominal para un tasa "
"efectiva dada.\n"
"\n"
"La tasa de interés nominal es dada por la fórmula:\n"
"\n"
"\t@nper * (( 1 + @r ) ^ (1 / @nper) - 1 )\n"
"\n"
"donde:\n"
"\n"
"@r = tasa de interés efectiva\n"
"@nper = número de períodos usados para el cómputo\n"
"\n"
"* Si @tasa < 0, NOMINAL devuelve un error #NÚM!\n"
"* Si @nper <=0, NOMINAL devuelve un error #NÚM!\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=EFFECT"

#: ../plugins/fn-financial/functions.c:895
msgid ""
"@FUNCTION=ISPMT\n"
"@SYNTAX=ISPMT(rate,per,nper,pv)\n"
"@DESCRIPTION=ISPMT function returns the interest paid on a given period.\n"
"\n"
"* If @per < 1 or @per > @nper, ISPMT returns #NUM! error. \n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=PV"
msgstr ""
"@FUNCTION=ISPMT\n"
"@SYNTAX=ISPMT(índice,per,nper,pv)\n"
"@DESCRIPTION=La función ISPMT devuelve el interés pagado en un período "
"dado.\n"
"\n"
"* Si @per < 1 ó @per > @nper, ISMPT devuelve el error #NÚM!. \n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=PV"

#: ../plugins/fn-financial/functions.c:935
msgid ""
"@FUNCTION=DB\n"
"@SYNTAX=DB(cost,salvage,life,period[,month])\n"
"@DESCRIPTION=DB calculates the depreciation of an asset for a given period "
"using the fixed-declining balance method.  @cost is the initial value of the "
"asset.  @salvage is the value after the depreciation.\n"
"\n"
"@life is the number of periods overall.  @period is the period for which you "
"want the depreciation to be calculated.  @month is the number of months in "
"the first year of depreciation.\n"
"\n"
"* If @month is omitted, it is assumed to be 12.\n"
"* If @cost = 0, DB returns #NUM! error.\n"
"* If @life <= 0, DB returns #NUM! error.\n"
"* If @salvage / @cost < 0, DB returns #NUM! error.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=DDB,SLN,SYD"
msgstr ""
"@FUNCTION=DB\n"
"@SYNTAX=DB(coste,recuperación,vida,período[,mes])\n"
"@DESCRIPTION=DB calcula la depreciación de un activo para un período dado "
"usando el método de balance de declinación fija. @coste es el valor inicial "
"del activo. @recuperación es el valor tras la depreciación. \n"
"\n"
"@vida es el número de períodos totales. @período es el período para el que "
"quiere que se calcule la depreciación. @mes es el número de meses del primer "
"año de depreciación. \n"
"\n"
"* Si se omite @mes, se asume que es 12. \n"
"* Si @coste = 0, DB devuelve un error #NÚM!\n"
"* Si @vida <= 0, DB devuelve un error #NÚM!\n"
"* Si @recuperación / @coste <0, DB devuelve un error #NÚM!\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=DDB,SLN,SYD"

#: ../plugins/fn-financial/functions.c:999
msgid ""
"@FUNCTION=DDB\n"
"@SYNTAX=DDB(cost,salvage,life,period[,factor])\n"
"@DESCRIPTION=DDB returns the depreciation of an asset for a given period "
"using the double-declining balance method or some other similar method you "
"specify.\n"
"\n"
"@cost is the initial value of the asset, @salvage is the value after the "
"last period, @life is the number of periods, @period is the period for which "
"you want the depreciation to be calculated, and @factor is the factor at "
"which the balance declines.\n"
"\n"
"* If @factor is omitted, it is assumed to be two (double-declining balance "
"method).\n"
"* If @life <= 0, DDB returns #NUM! error.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=SLN,SYD"
msgstr ""
"@FUNCTION=DDB\n"
"@SYNTAX=DDB(coste,recuperación,vida,período[,factor])\n"
"@DESCRIPTION=DDB devuelve la depreciación de un activo para un período dado "
"usando el método de balance de declinación doble o algún otro método similar "
"que especifique.\n"
"\n"
"@coste es el valor inicial del activo, @recuperación es el valor tras el "
"último período, @vida es el número de períodos, @período es el período para "
"el que quiere que se calcule la depreciación y @factor es el factor al que "
"declina el balance.\n"
"\n"
"* Si se omite @factor, se asume que es dos (método de balance de doble "
"declinación).\n"
"* Si @vida <=0, DDB devuelve un error #NÚM!\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=SLN,SYD"

#: ../plugins/fn-financial/functions.c:1062
msgid ""
"@FUNCTION=SLN\n"
"@SYNTAX=SLN(cost,salvage_value,life)\n"
"@DESCRIPTION=SLN function will determine the straight line depreciation of "
"an asset for a single period.\n"
"\n"
"The formula is:\n"
"\n"
"Depreciation expense = ( @cost - @salvage_value ) / @life\n"
"\n"
"@cost is the cost of an asset when acquired (market value).\n"
"@salvage_value is the amount you get when asset is sold at the end of the "
"asset's useful life.\n"
"@life is the anticipated life of an asset.\n"
"\n"
"* If @life <= 0, SLN returns #NUM! error.\n"
"\n"
"@EXAMPLES=\n"
"For example, lets suppose your company purchases a new machine for $10,000, "
"which has a salvage value of $700 and will have a useful life of 10 years. "
"The SLN yearly depreciation is computed as follows:\n"
"=SLN(10000, 700, 10)\n"
"This will return the yearly depreciation figure of $930.\n"
"@SEEALSO=SYD"
msgstr ""
"@FUNCTION=SLN\n"
"@SYNTAX=SLN(coste,valor_recuperación,vida)\n"
"@DESCRIPTION=La función SLN determinará la recta de depreciación de un "
"activo para un solo período.\n"
"\n"
"La fórmula es:\n"
"\n"
"Coste de depreciación = (@coste - @valor_recuperación)/@vida\n"
"\n"
"@coste es el coste de un activo al adquirirlo (valor de mercado).\n"
"@valor_recuperación es la cantidad que obtiene cuando se vende el activo al "
"final de la vida útil del activo.\n"
"@vida es la vida anticipada de un activo.\n"
"\n"
"* Si @vida <=0, SLN devuelve un error #NÚM!\n"
"\n"
"@EXAMPLES=\n"
"\n"
"Por ejemplo, supongamos que su empresa compra una máquina nueva por 10.000$, "
"que tiene un valor de recuperación de 700$ y tendrá una vida útil de 10 "
"años. La depreciación anual SLN se calcula como sigue:\n"
"SLN(10000, 700, 10)\n"
"Esto devolverá la figura de depreciación anual de 930$.\n"
"\n"
"@SEEALSO=SYD"

#: ../plugins/fn-financial/functions.c:1115
msgid ""
"@FUNCTION=SYD\n"
"@SYNTAX=SYD(cost,salvage_value,life,period)\n"
"@DESCRIPTION=SYD function calculates the sum-of-years digits depreciation "
"for an asset based on its cost, salvage value, anticipated life and a "
"particular period. This method accelerates the rate of the depreciation, so "
"that more depreciation expense occurs in earlier periods than in later ones. "
"The depreciable cost is the actual cost minus the salvage value. The useful "
"life is the number of periods (typically years) over which the asset is "
"depreciated.\n"
"\n"
"The Formula used for sum-of-years digits depreciation is:\n"
"\n"
"Depreciation expense =\n"
"\n"
"\t ( @cost - @salvage_value ) * (@life - @period + 1) * 2 / @life * (@life + "
"1).\n"
"\n"
"@cost is the cost of an asset when acquired (market value).\n"
"@salvage_value is the amount you get when asset sold at the end of its "
"useful life.\n"
"@life is the anticipated life of an asset.\n"
"@period is the period for which we need the expense.\n"
"\n"
"* If @life <= 0, SYD returns #NUM! error.\n"
"\n"
"@EXAMPLES=\n"
"For example say a company purchases a new computer for $5000 which has a "
"salvage value of $200, and a useful life of five years. We would use the "
"following to calculate the second year's depreciation using the SYD method:\n"
"=SYD(5000, 200, 5, 2) which returns 1,280.00.\n"
"@SEEALSO=SLN"
msgstr ""
"@FUNCTION=SYD\n"
"@SYNTAX=SYD(coste,valor_recuperación,vida,período)\n"
"@DESCRIPTION=La función SYD calcula la depreciación en dígitos en la suma de "
"años para un activo en base a su coste, valor de recuperación, vida "
"anticipada y un período particular. Este método acelera la tasa de "
"depreciación, así que la mayor depreciación ocurre en los primeros períodos "
"en vez de en los últimos. El coste despreciable es el coste actual menos el "
"valor de recuperación. La vida útil es el número de períodos (típicamente "
"años) sobre los que se deprecia el activo.\n"
"\n"
"La fórmula usada para los dígitos de depreciación de la suma de años es:\n"
"\n"
"Coste de depreciación =\n"
"\n"
"\t ( @coste - @valor_recuperación ) * (@vida - @período + 1) * 2 / @vida * "
"(@vida + 1).\n"
"\n"
"@coste es el coste de un activo al adquirirlo (valor de mercado).\n"
"@valor_recuperación es la cantidad que obtiene al vender el activo al final "
"de su vida útil.\t\n"
"@vida es la vida anticipada de un activo.\t\n"
"@período es el período por el necesitamos el gasto.\n"
"\n"
"* Si @vida <=0 , SYD devuelve un error #NÚM!\n"
"\n"
"@EXAMPLES=\n"
"\n"
"Por ejemplo, digamos que una empresa compra un computador nuevo por 5000$ "
"que tiene un valor de recuperación de 200$, y una vida útil de tres años. "
"Usaríamos lo siguiente para calcular la depreciación del segundo año usando "
"el método SYD:\n"
"=SYD(5000, 200, 5, 2), que devuelve 1.280,00.\n"
"\n"
"@SEEALSO=SLN"

#: ../plugins/fn-financial/functions.c:1176
msgid ""
"@FUNCTION=DOLLARDE\n"
"@SYNTAX=DOLLARDE(fractional_dollar,fraction)\n"
"@DESCRIPTION=DOLLARDE converts a dollar price expressed as a fraction into a "
"dollar price expressed as a decimal number.\n"
"\n"
"@fractional_dollar is the fractional number to be converted. @fraction is "
"the denominator of the fraction.\n"
"\n"
"* If @fraction is non-integer it is truncated.\n"
"* If @fraction <= 0, DOLLARDE returns #NUM! error.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=DOLLARFR"
msgstr ""
"@FUNCTION=DOLLARDE\n"
"@SYNTAX=DOLLARDE(dólar_fraccional;fracción)\n"
"@DESCRIPTION=Convierte un precio en dólares expresado como fracción, a un "
"precio en dólares expresado con decimales. \n"
"\n"
"@dólar_fraccional número fraccional a ser convertido. @fracción es el "
"denominador de la fracción.\n"
"\n"
"* Si @fracción no es un entero, será truncado. * Si @fracción <= 0 DOLLARDE "
"devuelve el error #NÚM! .\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=DOLLARFR"

#: ../plugins/fn-financial/functions.c:1235
msgid ""
"@FUNCTION=DOLLARFR\n"
"@SYNTAX=DOLLARFR(decimal_dollar,fraction)\n"
"@DESCRIPTION=DOLLARFR converts a decimal dollar price into a dollar price "
"expressed as a fraction.\n"
"\n"
"* If @fraction is non-integer it is truncated.\n"
"* If @fraction <= 0, DOLLARFR returns #NUM! error.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=DOLLARDE"
msgstr ""
"@FUNCTION=DOLLARFR\n"
"@SYNTAX=DOLLARFR(decimal_dólar;fracción)\n"
"@DESCRIPTION=DOLLARFR convierte un precio en dólares expresado en decimales, "
"a un precio en dólares expresado como una fracción.\n"
"\n"
"* Si @fracción no es un entero, será truncado.\n"
"* Si @fracción <= 0 DOLLARFR devuelve el error #NÚM! .\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=DOLLARDE"

#: ../plugins/fn-financial/functions.c:1289
msgid ""
"@FUNCTION=MIRR\n"
"@SYNTAX=MIRR(values,finance_rate,reinvest_rate)\n"
"@DESCRIPTION=MIRR function returns the modified internal rate of return for "
"a given periodic cash flow. \n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=NPV"
msgstr ""
"@FUNCTION=MIRR\n"
"@SYNTAX=MIRR(valores,índice_financiero,índice_reinversión)\n"
"@DESCRIPTION=La función MIRR devuelve el índice interno modificado de "
"retorno para un flujo de caja periódico dado.\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=NPV"

#: ../plugins/fn-financial/functions.c:1352
msgid ""
"@FUNCTION=TBILLEQ\n"
"@SYNTAX=TBILLEQ(settlement,maturity,discount)\n"
"@DESCRIPTION=TBILLEQ function returns the bond-yield equivalent (BEY) for a "
"treasury bill.  TBILLEQ is equivalent to\n"
"\n"
"\t(365 * @discount) / (360 - @discount * DSM),\n"
"\n"
"where DSM is the days between @settlement and @maturity.\n"
"\n"
"* If @settlement is after @maturity or the @maturity is set to over one year "
"later than the @settlement, TBILLEQ returns #NUM! error.\n"
"* If @discount is negative, TBILLEQ returns #NUM! error.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=TBILLPRICE,TBILLYIELD"
msgstr ""
"@FUNCTION=TBILLEQ\n"
"@SYNTAX=TBILLEQ(liquidación,vencimiento,descuento)\n"
"@DESCRIPTION=La función TBILLEQ devuelve el equivalente bond-yield (BEY) "
"para una factura de tesorería. TBILLEQ es equivalente a \n"
"\n"
"\t(365 * @descuento) / (360 - @descuento * DSM),\n"
"\n"
"donde DSM representa los días entre @liquidación y @vencimiento. \n"
"\n"
"* Si la @liquidación es tras el @vencimiento o el @vencimiento está puesto "
"más allá de un año después de la @liquidación, TBILLEQ devuelve el error "
"#NÚM!.\n"
"* Si el @descuento es negativo, TBILLEQ devuelve el error #NÚM!. \n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=TBILLPRICE,TBILLYIELD"

#: ../plugins/fn-financial/functions.c:1403
msgid ""
"@FUNCTION=TBILLPRICE\n"
"@SYNTAX=TBILLPRICE(settlement,maturity,discount)\n"
"@DESCRIPTION=TBILLPRICE function returns the price per $100 value for a "
"treasury bill where @settlement is the settlement date and @maturity is the "
"maturity date of the bill.  @discount is the treasury bill's discount rate.\n"
"\n"
"* If @settlement is after @maturity or the @maturity is set to over one year "
"later than the @settlement, TBILLPRICE returns #NUM! error.\n"
"* If @discount is negative, TBILLPRICE returns #NUM! error.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=TBILLEQ,TBILLYIELD"
msgstr ""
"@FUNCTION=TBILLPRICE\n"
"@SYNTAX=TBILLPRICE(liquidación,madurez,descuento)\n"
"@DESCRIPTION=La función TBILLPRICE devuelve el precio por 100 dólares de "
"valor para una factura de tesorería donde la @liquidación es la fecha de la "
"liquidación y la @vencimiento es la fecha de madurez de la factura. "
"@descuento es el índice de descuento de tesorería de la factura. \n"
"\n"
"* Si la @liquidación es tras la @vencimiento o la @vencimiento está puesta "
"más allá de un año después de la @liquidación, TBILLPRICE devuelve el error "
"#NÚM!\n"
"* Si el @descuento es negativo, TBILLPRICE devuelve el error #NÚM!.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=TBILLEQ,TBILLYIELD"

#: ../plugins/fn-financial/functions.c:1449
msgid ""
"@FUNCTION=TBILLYIELD\n"
"@SYNTAX=TBILLYIELD(settlement,maturity,pr)\n"
"@DESCRIPTION=TBILLYIELD function returns the yield for a treasury bill. "
"@settlement is the settlement date and @maturity is the maturity date of the "
"bill.  @discount is the treasury bill's discount rate.\n"
"\n"
"* If @settlement is after @maturity or the @maturity is set to over one year "
"later than the @settlement, TBILLYIELD returns #NUM! error.\n"
"* If @pr is negative, TBILLYIELD returns #NUM! error.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=TBILLEQ,TBILLPRICE"
msgstr ""
"@FUNCTION=TBILLYIELD\n"
"@SYNTAX=TBILLYIELD(liquidación,madurez,pr)\n"
"@DESCRIPTION=La función TBILLYIELD devuelve el rendimiento de una factura de "
"tesorería. @liquidación es la fecha de liquidación y @vencimiento es la "
"fecha de madurez de la factura. @descuento es el índice de descuento de la "
"factura de tesorería.\n"
"\n"
"* Si la @liquidación es posterior a la @vencimiento o la @vencimiento está "
"puesta más allá de un año después de la @liquidación, TBILLYIELD devuelve el "
"error #NÚM!.\n"
"* Si @pr es negativo, TBILLYIELD devuelve el error #NÚM!. \n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=TBILLEQ,TBILLPRICE"

#: ../plugins/fn-financial/functions.c:1495
msgid ""
"@FUNCTION=RATE\n"
"@SYNTAX=RATE(nper,pmt,pv[,fv,type,guess])\n"
"@DESCRIPTION=RATE calculates the rate of an investment.\n"
"\n"
"* If @pmt is ommitted it defaults to 0\n"
"* If @nper <= 0, RATE returns #NUM! error.\n"
"* If @type != 0 and @type != 1, RATE returns #VALUE! error.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=PV,FV"
msgstr ""
"@FUNCTION=RATE\n"
"@SYNTAX=RATE(nper,pmt,pv[,fv,tipo,previsión])\n"
"@DESCRIPTION=RATE calcula la tasa de una inversión.\n"
"\n"
"* Si @pmt se omite, toma como valor predeterminado 0\n"
"* Si @nper <= 0, RATE devuelve un error #NÚM!.\n"
"* Si @type != 0 y @type != 1, RATE devuelve un error #VALOR!\n"
"\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=PV,FV"

#: ../plugins/fn-financial/functions.c:1611
msgid ""
"@FUNCTION=IRR\n"
"@SYNTAX=IRR(values[,guess])\n"
"@DESCRIPTION=IRR calculates and returns the internal rate of return of an "
"investment.  This function is closely related to the net present value "
"function (NPV).  The IRR is the interest rate for a series of cash flows "
"where the net preset value is zero.\n"
"\n"
"@values contains the series of cash flows generated by the investment.  The "
"payments should occur at regular intervals.  The optional @guess is the "
"initial value used in calculating the IRR.  You do not have to use that, it "
"is only provided for the Excel compatibility.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1:A8 contain the numbers -32432, 5324, 7432, "
"9332, 12324, 4334, 1235, -3422.  Then\n"
"IRR(A1:A8) returns 0.04375. \n"
"@SEEALSO=FV,NPV,PV"
msgstr ""
"@FUNCTION=IRR\n"
"@SYNTAX=IRR(valores[,estimación])\n"
"@DESCRIPTION=IRR calcula y devuelve la tasa interna de devolución de una "
"inversión. Esta función está relacionada con la función de valor neto actual "
"(NPV). La IRR es la tasa de interés para una serie de flujos de capital "
"donde el valor neto actual es cero.\n"
"\n"
"@valores contiene la serie de flujos de caja generados por la inversión. Los "
"pagos deberían ocurrir a intervalos regulares. El parámetro opcional "
"@estimación es el valor inicial para calcular la IRR. No tiene que usarlo, "
"sólo se proporciona para compatibilidad con Excel.\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"Asumamos que las celdas A1:A8 contienen los números -32432, 5324, 7432, "
"9332, 12324, 4334, 1235, -3422. Entonces\n"
"IRR(A1:A8) devuelve 0.04375. \n"
"\n"
"@SEEALSO=FV,NPV,PV"

#: ../plugins/fn-financial/functions.c:1745
msgid ""
"@FUNCTION=PV\n"
"@SYNTAX=PV(rate,nper,pmt[,fv,type])\n"
"@DESCRIPTION=PV calculates the present value of an investment. @rate is the "
"periodic interest rate, @nper is the number of periods used for compounding. "
"@pmt is the payment made each period, @fv is the future value and @type is "
"when the payment is made.\n"
"\n"
"* If @type = 1 then the payment is made at the beginning of the period.\n"
"* If @type = 0 (or omitted) it is made at the end of each period.\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=FV"
msgstr ""
"@FUNCTION=PV\n"
"@SYNTAX=PV(tasa,nper,pmt[,fv,tipo])\n"
"@DESCRIPTION=PV calcula el valor presente de una inversión. @tasa es la tasa "
"periódica de interés, @nper es el número de períodos usados para la "
"composición.@pmt es el pago hecho cada periodo, @fv es el valor futuro y "
"@tipo es cuándo se hace el pago.\n"
"\n"
"* Si @tipo = 1 entonces el pago se hace al principio del período.\n"
"* Si @tipo = 0 (u omitido) se hace al final de cada período.\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=FV"

#: ../plugins/fn-financial/functions.c:1793
msgid ""
"@FUNCTION=NPV\n"
"@SYNTAX=NPV(rate,v1,v2,...)\n"
"@DESCRIPTION=NPV calculates the net present value of an investment "
"generating periodic payments.  @rate is the periodic interest rate and @v1, "
"@v2, ... are the periodic payments.  If the schedule of the cash flows are "
"not periodic use the XNPV function. \n"
"@EXAMPLES=\n"
"NPV(0.17,-10000,3340,2941,2493,3233,1732,2932) equals 186.30673.\n"
"\n"
"@SEEALSO=PV,XNPV"
msgstr ""
"@FUNCTION=NPV\n"
"@SYNTAX=NPV(tasa,v1,v2,…)\n"
"@DESCRIPTION=NPV calcula el valor presente neto de una inversión que genera "
"pagos periódicos. @tasa es la tasa periódica de interés y @v1, @v2, … son "
"los pagos periódicos. Si la planificación de los flujos de capital no es "
"periódica use la función XNPV.\n"
"\n"
"@EXAMPLES=\n"
"NPV(0.17,-10000,3340,2941,2493,3233,1732,2932) es igual a 186.30673.\n"
"\n"
"@SEEALSO=PV,XNPV"

#: ../plugins/fn-financial/functions.c:1844
msgid ""
"@FUNCTION=XNPV\n"
"@SYNTAX=XNPV(rate,values,dates)\n"
"@DESCRIPTION=XNPV calculates the net present value of an investment.  The "
"schedule of the cash flows is given in @dates array.  The first date "
"indicates the beginning of the payment schedule.  @rate is the interest rate "
"and @values are the payments.\n"
"\n"
"* If @values and @dates contain unequal number of values, XNPV returns the "
"#NUM! error.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=NPV,PV"
msgstr ""
"@FUNCTION=XNPV\n"
"@SYNTAX=XNPV(tasa,valores,fechas)\n"
"@DESCRIPTION=XNPV calcula el valor neto actual de una inversión. La "
"planificación de los flujos de capital se da en el array @fechas. La primera "
"fecha indica el principio de la planificación de pagos.. @tasa es la tasa de "
"interés y @valores son los pagos.\n"
"\n"
"* Si @valores y @fechas contienen distinto número de valores, XNPV devuelve "
"el error #NÚM!\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=NPV,PV"

#: ../plugins/fn-financial/functions.c:1906
msgid ""
"@FUNCTION=XIRR\n"
"@SYNTAX=XIRR(values,dates[,guess])\n"
"@DESCRIPTION=XIRR calculates and returns the internal rate of return of an "
"investment that has not necessarily periodic payments.  This function is "
"closely related to the net present value function (NPV and XNPV).  The XIRR "
"is the interest rate for a series of cash flows where the XNPV is zero.\n"
"\n"
"@values contains the series of cash flows generated by the investment.  "
"@dates contains the dates of the payments.  The first date describes the "
"payment day of the initial payment and thus all the other dates should be "
"after this date. The optional @guess is the initial value used in "
"calculating the XIRR.  You do not have to use that, it is only provided for "
"the Excel compatibility.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1:A5 contain the numbers -6000, 2134, 1422, "
"1933, and 1422, and the cells B1:B5 contain the dates \"1999-01-15\", \"1999-"
"04-04\", \"1999-05-09\", \"2000-03-12\", and \"2000-05-1\". Then\n"
"XIRR(A1:A5,B1:B5) returns 0.224838. \n"
"@SEEALSO=IRR,XNPV"
msgstr ""
"@FUNCTION=XIRR\n"
"@SYNTAX=XIRR(valores,fechas[,estimar])\n"
"@DESCRIPTION=XIRR calcula y devuelve la tasa interna de retorno de una "
"inversión que no tiene necesariamente pagos periódicos. Esta función está "
"relacionada cercanamente con la función de valor presente (NPV y XNPV). La "
"función XIRR es la tasa de interés para una serie de flujo de caja donde el "
"XNPV es cero.\n"
"\n"
"@valores contiene la serie de flujo de capitales generados por la inversión. "
"@fechas contiene las fechas de pagos. La primera fecha describe el día de "
"pago del pago inicial así que todas las demás fechas deberán ir tras esta "
"fecha . El parámetro opcional @estimar es el valor inicial usado en el "
"cálculo de XIRR. No tiene que usar lo, tan sólo se proporciona por "
"compatibilidad con Excel.\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"Asumamos que las celdas A1:A5 contienen los números -6000, 2134, 1422, 1933, "
"y 1422, y las celdas B1:B5 contienen las fechas \"15-01-1991\", \"04-04-19991"
"\", \"05-09-1991\", \"12-03-2000\", y\"01-05-2000\". Entonces\n"
"XIRR(A1:A5,B1:B5) devuelve 0.224838. \n"
"\n"
"@SEEALSO=IRR,XNPV"

#: ../plugins/fn-financial/functions.c:2026
msgid ""
"@FUNCTION=FV\n"
"@SYNTAX=FV(rate,nper,pmt[,pv,type])\n"
"@DESCRIPTION=FV computes the future value of an investment. This is based on "
"periodic, constant payments and a constant interest rate. The interest rate "
"per period is @rate, @nper is the number of periods in an annuity, @pmt is "
"the payment made each period, @pv is the present value and @type is when the "
"payment is made.\n"
"\n"
"* If @type = 1 then the payment is made at the beginning of the period.\n"
"* If @type = 0 it is made at the end of each period.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=PV,PMT,PPMT"
msgstr ""
"@FUNCTION=FV\n"
"@SYNTAX=FV(tasa,nper,pmt[,pv,tipo])\n"
"@DESCRIPTION=FV calcula el valor futuro de una inversión. Esto se basa en "
"pagos periódicos, constantes y una tasa constante de interés. La tasa de "
"interés por periodo es @tasa, @nper es el número de períodos en una "
"anualidad, @pmt es el pago hecho cada período, @pv es el valor presente y "
"@tipo es cuándo se hace el pago.\n"
"\n"
"* Si @tipo = 1 entonces el pago se hace al principio del período.\n"
"* Si @tipo = 0 se hace al final de cada período.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=PV,PMT,PPMT"

#: ../plugins/fn-financial/functions.c:2070
msgid ""
"@FUNCTION=PMT\n"
"@SYNTAX=PMT(rate,nper,pv[,fv,type])\n"
"@DESCRIPTION=PMT returns the amount of payment for a loan based on a "
"constant interest rate and constant payments (each payment is equal "
"amount).\n"
"\n"
"@rate is the constant interest rate.\n"
"@nper is the overall number of payments.\n"
"@pv is the present value.\n"
"@fv is the future value.\n"
"@type is the type of the payment: 0 means at the end of the period and 1 "
"means at the beginning of the period.\n"
"\n"
"* If @fv is omitted, Gnumeric assumes it to be zero.\n"
"* If @type is omitted, Gnumeric assumes it to be zero.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=PPMT,PV,FV"
msgstr ""
"@FUNCTION=PMT\n"
"@SYNTAX=PMT(tasa,nper,vp[,vf,tipo])\n"
"@DESCRIPTION=PMT devuelve la cantidad de pago para un préstamo basado en una "
"tasa constante de interés y pagos constantes (cada pago es de la misma "
"cantidad).\n"
"\n"
"@tasa es la tasa constante de interés.\n"
"@nper es el número de pagos totales.\n"
"@vp es es valor presente.\n"
"@vf es el valor futuro\n"
"@tipo es es tipo de pago:0 significa al final del periodo y 1 significa al "
"principio del periodo.\n"
"\n"
"* Si se omite @vf, Gnumeric asume que es cero.\n"
"* Si se omite @tipo, Gnumeric asume que es cero.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=PPMT,PV,FV"

#: ../plugins/fn-financial/functions.c:2113
msgid ""
"@FUNCTION=IPMT\n"
"@SYNTAX=IPMT(rate,per,nper,pv[,fv,type])\n"
"@DESCRIPTION=IPMT calculates the amount of a payment of an annuity going "
"towards interest.\n"
"\n"
"Formula for IPMT is:\n"
"\n"
"IPMT(PER) = -PRINCIPAL(PER-1) * INTEREST_RATE\n"
"\n"
"where:\n"
"\n"
"PRINCIPAL(PER-1) = amount of the remaining principal from last period\n"
"\n"
"* If @fv is omitted, it is assumed to be 0.\n"
"* If @type is omitted, it is assumed to be 0.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=PPMT,PV,FV"
msgstr ""
"@FUNCTION=IPMT\n"
"@SYNTAX=IPMT(tasa,per,nper,vp[,vf,tipo])\n"
"@DESCRIPTION=IPMT calcula la cantidad de un pago de una anualidad con del "
"interés.\n"
"\n"
"La fórmula para IOPMT es:\n"
"\n"
"IPMT(PER) = -PRINCIPAL(PER-1) * INTEREST_RATE\n"
"\n"
"donde:\n"
"\n"
"PRINCIPAL(PER-1) = cantidad de remanente principal del último período\n"
"\n"
"* Si @vf se omite, se asume que es 0.\n"
"* Si @tipo se omite, se asume que es 0.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=PPMT,PV,FV"

#: ../plugins/fn-financial/functions.c:2165
msgid ""
"@FUNCTION=PPMT\n"
"@SYNTAX=PPMT(rate,per,nper,pv[,fv,type])\n"
"@DESCRIPTION=PPMT calculates the amount of a payment of an annuity going "
"towards principal.\n"
"\n"
"Formula for it is:\n"
"PPMT(per) = PMT - IPMT(per)\n"
"where:\n"
"\n"
"PMT = Payment received on annuity\n"
"IPMT(per) = amount of interest for period @per\n"
"\n"
"* If @fv is omitted, it is assumed to be 0.\n"
"* If @type is omitted, it is assumed to be 0.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=IPMT,PV,FV"
msgstr ""
"@FUNCTION=PPMT\n"
"@SYNTAX=PPMT(tasa,per,nper,vp[,vf,tipo])\n"
"@DESCRIPTION=PPMT calcula la cantidad de pago de una renta vitalicia.\n"
"\n"
"Fórmula para esto:\n"
"PPMT(per) = PMT - IPMT(per)\n"
"donde:\n"
"\n"
"PMT = Pago recibido en renta vitalicia\n"
"IPMT(per) = cantidad de interés para el periodo @per\n"
"\n"
"* Si se omite @vf, se asume que es 0.\n"
"* Si se omite @tipo, se asume que es 0.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=IPMT,PV,FV"

#: ../plugins/fn-financial/functions.c:2221
msgid ""
"@FUNCTION=NPER\n"
"@SYNTAX=NPER(rate,pmt,pv[,fv,type])\n"
"@DESCRIPTION=NPER calculates number of periods of an investment based on "
"periodic constant payments and a constant interest rate.\n"
"\n"
"The interest rate per period is @rate, @pmt is the payment made each period, "
"@pv is the present value, @fv is the future value and @type is when the "
"payments are due. If @type = 1, payments are due at the beginning of the "
"period, if @type = 0, payments are due at the end of the period.\n"
"\n"
"* If @rate <= 0, NPER returns #DIV0 error.\n"
"\n"
"@EXAMPLES=\n"
"For example, if you deposit $10,000 in a savings account that earns an "
"interest rate of 6%. To calculate how many years it will take to double your "
"investment use NPER as follows:\n"
"=NPER(0.06, 0, -10000, 20000,0)returns 11.895661046 which indicates that you "
"can double your money just before the end of the 12th year.\n"
"@SEEALSO=PPMT,PV,FV"
msgstr ""
"@FUNCTION=NPER\n"
"@SYNTAX=NPER(tasa,pmt,pv[,fv,tipo])\n"
"@DESCRIPTION=NPER calcula el número de periodos de una inversión basada en "
"pagos periódicos constantes y una tasa constante de interés.\n"
"\n"
"La tasa de interés por período es @tasa, @pmt es el pago hecho cada período, "
"@pv es el valor actual, @fv es el valor futuro y @tipo es cuándo se realizan "
"los pagos. Si tipo =1, los pagos se realizan al principio del periodo, si "
"@tipo =0, los pagos se realizan al final del período.\n"
"\n"
"* Si @tasa <= 0, NPER devuelve un error #DIV0.\n"
"\n"
"@EXAMPLES=\n"
"Por ejemplo, si deposita 10.000 $ en una cuenta de ahorro que tiene una tasa "
"de interés del 6%. Para calcular cuántos años se necesitan para doblar su "
"inversión, use NPER como se indica a continuación:\n"
"=NPER(0.06, 0, -10000, 20000,0) devuelve 11,895661046 que indica que puede "
"doblar su dinero justo antes del final del 12º año.\n"
"\n"
"@SEEALSO=PPMT,PV,FV"

#: ../plugins/fn-financial/functions.c:2281
msgid ""
"@FUNCTION=DURATION\n"
"@SYNTAX=DURATION(settlement,maturity,coup,yield,frequency[,basis])\n"
"@DESCRIPTION=DURATION calculates the duration of a security.\n"
"\n"
"@settlement is the settlement date of the security.\n"
"@maturity is the maturity date of the security.\n"
"@coup The annual coupon rate as a percentage.\n"
"@yield The annualized yield of the security as a percentage.\n"
"@frequency is the number of coupon payments per year. Allowed frequencies "
"are: 1 = annual, 2 = semi, 4 = quarterly. @basis is the type of day counting "
"system you want to use:\n"
"\n"
"  0  US 30/360\n"
"  1  actual days/actual days\n"
"  2  actual days/360\n"
"  3  actual days/365\n"
"  4  European 30/360\n"
"\n"
"* If @frequency is other than 1, 2, or 4, DURATION returns #NUM! error.\n"
"* If @basis is omitted, US 30/360 is applied.\n"
"* If @basis is not in between 0 and 4, #NUM! error is returned.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=G_DURATION,MDURATION"
msgstr ""
"@FUNCTION=DURATION\n"
"@SYNTAX=DURATION(liquidación,vencimiento,cupón,margen,frecuencia[,base])\n"
"@DESCRIPTION=DURATION calcula la duración de una acción.\n"
"\n"
"@liquidación es la fecha de liquidación de la acción. @vencimiento es la "
"fecha de vencimiento de la acción. @base es el tipo de sistema de conteo de "
"días que quiere usar:\n"
"\n"
" 0 US 30/360\n"
" 1 días actuales/días actuales\n"
" 2 días actuales/360\n"
" 3 días actuales/365\n"
" 4 europeo 30/360\n"
"\n"
"* Si @frecuencia es distinta de 1, 2 o 4, DURATION devuelve un error #NÚM!.\n"
"* Si se omite @base se usa US 30/360.\n"
"* Si @base no está entre 0 y 4, se devuelve un error #NÚM!.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=G_DURATION,MDURATION"

#: ../plugins/fn-financial/functions.c:2343
msgid ""
"@FUNCTION=G_DURATION\n"
"@SYNTAX=G_DURATION(rate,pv,fv)\n"
"@DESCRIPTION=G_DURATION calculates number of periods needed for an "
"investment to attain a desired value. This function is similar to FV and PV "
"with a difference that we do not need give the direction of cash flows e.g. -"
"100 for a cash outflow and +100 for a cash inflow.\n"
"\n"
"* If @rate <= 0, G_DURATION returns #DIV0 error.\n"
"* If @fv = 0 or @pv = 0, G_DURATION returns #DIV0 error.\n"
"* If @fv / @pv < 0, G_DURATION returns #VALUE error.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=PPMT,PV,FV,DURATION,MDURATION"
msgstr ""
"@FUNCTION=G_DURATION\n"
"@SYNTAX=G_DURATION(tasa,vp,vf)\n"
"@DESCRIPTION=G_DURATION calcula el número de periodos necesarios para con la "
"diferencia de que no damos la dirección del flujo de caja ej: -100 para "
"salidas de caja +100 para retornos de caja.\n"
"\n"
"* Si @tasa <= 0, G_DURATION devuelve un error #DIV0.\n"
"* Si @vf = 0 o @pv = 0, G_DURATION devuelve un error #DIV0.\n"
"* Si @vf / @vp < 0, G_DURATION devuelve un error #VALUE error.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=PPMT,PV,FV,DURATION,MDURATION"

#: ../plugins/fn-financial/functions.c:2387
msgid ""
"@FUNCTION=FVSCHEDULE\n"
"@SYNTAX=FVSCHEDULE(principal,schedule)\n"
"@DESCRIPTION=FVSCHEDULE returns the future value of given initial value "
"after applying a series of compound periodic interest rates. The argument "
"@principal is the present value; @schedule is an array of interest rates to "
"apply. The @schedule argument must be a range of cells.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1, A2, ..., A5 contain interest rates 0.11, "
"0.13, 0.09, 0.17, and 0.03.  Then\n"
"FVSCHEDULE(3000,A1:A5) equals 4942.7911611.\n"
"@SEEALSO=PV,FV"
msgstr ""
"@FUNCTION=FVSCHEDULE\n"
"@SYNTAX=FVSCHEDULE(principal,planificación)\n"
"@DESCRIPTION=FVSCHEDULE devuelve el valor futuro de un valor inicial dado "
"después de aplicarle una serie de tasas periódicas compuestas de interés. El "
"argumento @principal es el valor presente; @planificación es un array de "
"tasas de interés a aplicar.El argumento @planificación debe ser un rango de "
"celdas.\n"
"\n"
"@EXAMPLES=\n"
"Asumamos que las celdas A1, A2, …, A5 contienen las tasas de interés 0.11, "
"0.13, 0.09, 0.17, y 0.03. Entonces\n"
"FVSCHEDULE(3000,A1:A5) es igual a 4942,7911611.\n"
"@SEEALSO=PV,FV"

#: ../plugins/fn-financial/functions.c:2434
msgid ""
"@FUNCTION=EURO\n"
"@SYNTAX=EURO(currency)\n"
"@DESCRIPTION=EURO converts one Euro to a given national currency in the "
"European monetary union.\n"
"\n"
"@currency is one of the following:\n"
"\n"
"    ATS\t(Austria)\n"
"    BEF\t(Belgium)\n"
"    DEM\t(Germany)\n"
"    ESP\t(Spain)\n"
"    EUR\t(Euro)\n"
"    FIM\t(Finland)\n"
"    FRF\t(France)\n"
"    GRD\t(Greek)\n"
"    IEP\t(Ireland)\n"
"    ITL\t(Italy)\n"
"    LUF\t(Luxembourg)\n"
"    NLG\t(Netherlands)\n"
"    PTE\t(Portugal)\n"
"\n"
"* If the given @currency is other than one of the above, EURO returns #NUM! "
"error.\n"
"\n"
"@EXAMPLES=\n"
"EURO(\"DEM\") returns 1.95583.\n"
"@SEEALSO="
msgstr ""
"@FUNCTION=EURO\n"
"@SYNTAX=EURO(divisa)\n"
"@DESCRIPTION=Convierte un Euro a la moneda nacional especificada por la "
"unión económica europea. \n"
"@divisa se corresponde a alguno de los siguientes valores:\n"
"\n"
" ATS\t(Austria)\n"
" BEF\t(Bélgica)\n"
" DEM\t(Alemania)\n"
" ESP\t(España)\n"
" FIM\t(Finlandia)\n"
" FRF\t(Francia)\n"
" GRD\t(Grecia)\n"
" IEP\t(Irlanda)\n"
" ITL\t(Italia)\n"
" LUF\t(Luxemburgo)\n"
" NLG\t(Holanda)\n"
" PTE\t(Portugal)\n"
"\n"
"Si @divisa es distinto a alguno de los valores indicados anteriormente, "
"entonces EURO devuelve el error #NUM\n"
" \n"
"@EXAMPLES=\n"
"EURO(\"DEM\") es igual a 1,95583.\n"
"@SEEALSO=EUROCONVERT"

#: ../plugins/fn-financial/functions.c:2544
msgid ""
"@FUNCTION=EUROCONVERT\n"
"@SYNTAX=EUROCONVERT(n,source,target)\n"
"@DESCRIPTION=EUROCONVERT converts the currency value @n of @source currency "
"to a target currency @target. Both currencies are given as three-letter "
"strings using the ISO code system names.  The following currencies are "
"available:\n"
"\n"
"    ATS\t(Austria)\n"
"    BEF\t(Belgium)\n"
"    DEM\t(Germany)\n"
"    ESP\t(Spain)\n"
"    EUR\t(Euro)\n"
"    FIM\t(Finland)\n"
"    FRF\t(France)\n"
"    GRD\t(Greek)\n"
"    IEP\t(Ireland)\n"
"    ITL\t(Italy)\n"
"    LUF\t(Luxembourg)\n"
"    NLG\t(Netherlands)\n"
"    PTE\t(Portugal)\n"
"\n"
"* If the given @source or @target is other than one of the above, "
"EUROCONVERT returns #VALUE! error.\n"
"\n"
"@EXAMPLES=\n"
"EUROCONVERT(2.1,\"DEM\",\"EUR\") returns 1.07.\n"
"@SEEALSO=EURO"
msgstr ""
"@FUNCTION=EUROCONVERT\n"
"@SYNTAX=EUROCONVERT(n,origen,destino)\n"
"@DESCRIPTION=Convierte el valor de divisa @n de la divisa @origen a la "
"divisa @destino. Ambas divisas deben darse en cadenas de tres letras usando "
"la codificación de nombres ISO. Las siguientes divisas están disponibles:\n"
"\n"
" ATS\t(Austria)\n"
" BEF\t(Bélgica)\n"
" DEM\t(Alemania)\n"
" ESP\t(España)\n"
" FIM\t(Finlandia)\n"
" FRF\t(Francia)\n"
" GRD\t(Grecia)\n"
" IEP\t(Irlanda)\n"
" ITL\t(Italia)\n"
" LUF\t(Luxemburgo)\n"
" NLG\t(Holanda)\n"
" PTE\t(Portugal)\n"
"\n"
"Si el @origen dado o @destino es otro distinto a los de arriba, EUROCONVERT "
"devuelve un error #VALOR! \n"
"\n"
"@EXAMPLES=\n"
"EUROCONVERT(\"DEM\") es igual a 1,95583.\n"
"@SEEALSO=EURO"

#: ../plugins/fn-financial/functions.c:2594
msgid ""
"@FUNCTION=PRICE\n"
"@SYNTAX=PRICE(settle,mat,rate,yield,redemption_price,[frequency,basis])\n"
"@DESCRIPTION=PRICE returns price per $100 face value of a security. This "
"method can only be used if the security pays periodic interest.\n"
"\n"
"@frequency is the number of coupon payments per year. Allowed frequencies "
"are: 1 = annual, 2 = semi, 4 = quarterly. @basis is the type of day counting "
"system you want to use:\n"
"\n"
"  0  US 30/360\n"
"  1  actual days/actual days\n"
"  2  actual days/360\n"
"  3  actual days/365\n"
"  4  European 30/360\n"
"\n"
"* If @frequency is other than 1, 2, or 4, PRICE returns #NUM! error.\n"
"* If @basis is omitted, US 30/360 is applied.\n"
"* If @basis is not in between 0 and 4, #NUM! error is returned.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO="
msgstr ""
"@FUNCTION=PRICE\n"
"@SYNTAX=PRICE(liquido,vencimiento,tasa,margen,precio_amortización,"
"[frecuencia,base])\n"
"@DESCRIPTION=PRICE devuelve el precio por 100$ de valor facial de una "
"acción. Este método sólo puede usarse si la acción paga intereses "
"periódicos.\n"
"\n"
"@frecuencia es el número de pago al cupón por año. Las frecuencias "
"permitidas son: 1 = anual, 2 = semi, 4 = cuatro veces al año. @base es el "
"tipo de sistema de conteo de días que quiere usar:\n"
"\n"
" 0 US 30/360\n"
" 1 días actuales/días actuales\n"
" 2 días actuales/360\n"
" 3 días actuales/365\n"
" 4 europeo 30/360\n"
"\n"
"* Si @frecuencia es distinta de 1, 2 o 4, PRICE devuelve un error #NÚM!.\n"
"* Si se omite @base se usa US 30/360.\n"
"* Si @base no está entre 0 y 4, se devuelve un error #NÚM!.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO="

#: ../plugins/fn-financial/functions.c:2661
msgid ""
"@FUNCTION=YIELD\n"
"@SYNTAX=YIELD(settlement,maturity,rate,price,redemption_price,frequency[,"
"basis])\n"
"@DESCRIPTION=YIELD returns the yield on a security that pays periodic "
"interest.\n"
"\n"
"@frequency is the number of coupon payments per year. Allowed frequencies "
"are: 1 = annual, 2 = semi, 4 = quarterly. @basis is the type of day counting "
"system you want to use:\n"
"\n"
"  0  US 30/360\n"
"  1  actual days/actual days\n"
"  2  actual days/360\n"
"  3  actual days/365\n"
"  4  European 30/360\n"
"\n"
"* If @frequency is other than 1, 2, or 4, YIELD returns #NUM! error.\n"
"* If @basis is omitted, US 30/360 is applied.\n"
"* If @basis is not in between 0 and 4, #NUM! error is returned.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO="
msgstr ""
"@FUNCTION=YIELD\n"
"@SYNTAX=YIELD(liquidación,vencimiento,tasa,precio,precio_amortización,"
"frecuencia[,base])\n"
"@DESCRIPTION=YIELD devuelve el margen en una acción que paga intereses "
"periódicos.\n"
"\n"
"@frecuencia es el número de pago al cupón por año. Las frecuencias "
"permitidas son: 1 = anual, 2 = semi, 4 = cuatro veces al año. @base es el "
"tipo de sistema de conteo de días que quiere usar:\n"
"\n"
" 0 US 30/360\n"
" 1 días actuales/días actuales\n"
" 2 días actuales/360\n"
" 3 días actuales/365\n"
" 4 europeo 30/360\n"
"\n"
"* Si @frecuencia es distinta de 1, 2 o 4, YIELD devuelve un error #NÚM!.\n"
"* Si se omite @base se usa US 30/360.\n"
"* Si @base no está entre 0 y 4, se devuelve un error #NÚM!.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO="

#: ../plugins/fn-financial/functions.c:2784
msgid ""
"@FUNCTION=YIELDDISC\n"
"@SYNTAX=YIELDDISC(settlement,maturity,pr,redemption[,basis])\n"
"@DESCRIPTION=YIELDDISC calculates the annual yield of a security that is "
"discounted.\n"
"\n"
"@settlement is the settlement date of the security.  @maturity is the "
"maturity date of the security. @pr is the price per $100 face value of the "
"security. @redemption is the redemption value per $100 face value. @basis is "
"the type of day counting system you want to use:\n"
"\n"
"  0  US 30/360\n"
"  1  actual days/actual days\n"
"  2  actual days/360\n"
"  3  actual days/365\n"
"  4  European 30/360\n"
"\n"
"* If @frequency is other than 1, 2, or 4, YIELDDISC returns #NUM! error.\n"
"* If @basis is omitted, US 30/360 is applied.\n"
"* If @basis is not in between 0 and 4, #NUM! error is returned.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO="
msgstr ""
"@FUNCTION=YIELDDISC\n"
"@SYNTAX=YIELDDISC(liquidación,vencimiento,pr,amortización[,base])"
"@DESCRIPTION=YIELDMAT calcula el margen anual de una acción que es "
"descontada.\n"
"\n"
"@liquidación es la fecha de liquidación de la acción. @vencimiento es la "
"fecha de vencimiento de la acción. @pr es el precio por 100$ de valor facial "
"de la acción. @amortización es el valor de amortización por cada 100$ de "
"valor facial. @base es el tipo de sistema de conteo de días que quiere "
"usar:\n"
"\n"
" 0 US 30/360\n"
" 1 días actuales/días actuales\n"
" 2 días actuales/360\n"
" 3 días actuales/365\n"
" 4 europeo 30/360\n"
"\n"
"* Si @frecuencia es distinta de 1, 2 o 4, YIELDDISC devuelve un error "
"#NÚM!.\n"
"* Si se omite @base se usa US 30/360.\n"
"* Si @base no está entre 0 y 4, se devuelve un error #NÚM!.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO="

#: ../plugins/fn-financial/functions.c:2848
msgid ""
"@FUNCTION=YIELDMAT\n"
"@SYNTAX=YIELDMAT(settlement,maturity,issue,rate,pr[,basis])\n"
"@DESCRIPTION=YIELDMAT calculates the annual yield of a security for which "
"the interest is paid at maturity date.\n"
"\n"
"@settlement is the settlement date of the security. @maturity is the "
"maturity date of the security. @issue is the issue date of the security. "
"@rate is the interest rate set to the security. @pr is the price per $100 "
"face value of the security. @basis is the type of day counting system you "
"want to use:\n"
"\n"
"  0  US 30/360\n"
"  1  actual days/actual days\n"
"  2  actual days/360\n"
"  3  actual days/365\n"
"  4  European 30/360\n"
"\n"
"* If @basis is omitted, US 30/360 is applied.\n"
"* If @basis is not in between 0 and 4, #NUM! error is returned.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO="
msgstr ""
"@FUNCTION=YIELDMAT\n"
"@SYNTAX=YIELDMAT(liquidación,vencimiento,emisión,tasa,margen,pr[,base])\n"
"@DESCRIPTION=YIELDMAT calcula el margen anual de una acción para la que el "
"interés se paga en la fecha de vencimiento.\n"
"\n"
"@liquidación es la fecha de liquidación de la acción. @vencimiento es la "
"fecha de vencimiento de la acción. @emisión es la fecha de emisión de la "
"acción.@tasa es la tasa de interés de la acción. @pr es el precio por 100$ "
"de valor facial de la acción. @base es el tipo de sistema de conteo de días "
"que quiere usar:\n"
"\n"
" 0 US 30/360\n"
" 1 días actuales/días actuales\n"
" 2 días actuales/360\n"
" 3 días actuales/365\n"
" 4 europeo 30/360\n"
"\n"
"* Si @frecuencia es distinta de 1, 2 o 4, YIELDMAT devuelve un error #NÚM!.\n"
"* Si se omite @base se usa US 30/360.\n"
"* Si @base no está entre 0 y 4, se devuelve un error #NÚM!.\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO="

#: ../plugins/fn-financial/functions.c:2904
msgid ""
"@FUNCTION=ODDFPRICE\n"
"@SYNTAX=ODDFPRICE(settlement,maturity,issue,first_coupon,rate,yld,redemption,"
"frequency[,basis])\n"
"@DESCRIPTION=ODDFPRICE returns the price per $100 face value of a security. "
"The security should have an odd short or long first period.\n"
"\n"
"@settlement is the settlement date of the security. @maturity is the "
"maturity date of the security. @issue is the issue date of the security. "
"@frequency is the number of coupon payments per year. Allowed frequencies "
"are: 1 = annual, 2 = semi, 4 = quarterly. @basis is the type of day counting "
"system you want to use:\n"
"\n"
"  0  US 30/360\n"
"  1  actual days/actual days\n"
"  2  actual days/360\n"
"  3  actual days/365\n"
"  4  European 30/360\n"
"\n"
"* If @frequency is other than 1, 2, or 4, ODDFPRICE returns #NUM! error.\n"
"* If @basis is omitted, US 30/360 is applied.\n"
"* If @basis is not in between 0 and 4, #NUM! error is returned.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO="
msgstr ""
"@FUNCTION=ODDFPRICE\n"
"@SYNTAX=ODDFPRICE(liquidación,vencimiento,emisión,primera_acción,tasa,margen,"
"amortización,frecuencia[,base])\n"
"@DESCRIPTION=ODDFPRICE devuelve el precio por cada 100$ de valor facial de "
"una acción. La acción debería tener una imparidad corta o un largo primer "
"periodo.\n"
"\n"
"@liquidación es la fecha de liquidación de la acción. @vencimiento es la "
"fecha de vencimiento de la acción. @emisión es la fecha de emisión de la "
"acción.@frecuencia es el número de pagos al título al año. Las frecuencias "
"permitidas son: 1 = anual, 2 = semi, 4 = cada 4 meses. @base es el tipo de "
"sistema de conteo de días que quiere usar:\n"
"\n"
" 0 US 30/360\n"
" 1 días actuales/días actuales\n"
" 2 días actuales/360\n"
" 3 días actuales/365\n"
" 4 europeo 30/360\n"
"\n"
"* Si @frecuencia es distinto de 1, 2, o 4, ODDFPRICE devuelve un error "
"#NÚM!.\n"
"* Si se omite @base se usa US 30/360.\n"
"* Si @base no está entre 0 y 4, se devuelve un error #NÚM!.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO="

#: ../plugins/fn-financial/functions.c:3069
msgid ""
"@FUNCTION=ODDFYIELD\n"
"@SYNTAX=ODDFYIELD(settlement,maturity,issue,first_coupon,rate,pr,redemption,"
"frequency[,basis])\n"
"@DESCRIPTION=ODDFYIELD calculates the yield of a security having an odd "
"first period.\n"
"\n"
"@settlement is the settlement date of the security. @maturity is the "
"maturity date of the security. @frequency is the number of coupon payments "
"per year. Allowed frequencies are: 1 = annual, 2 = semi, 4 = quarterly. "
"@basis is the type of day counting system you want to use:\n"
"\n"
"  0  US 30/360\n"
"  1  actual days/actual days\n"
"  2  actual days/360\n"
"  3  actual days/365\n"
"  4  European 30/360\n"
"\n"
"* If @frequency is other than 1, 2, or 4, ODDFYIELD returns #NUM! error.\n"
"* If @basis is omitted, US 30/360 is applied.\n"
"* If @basis is not in between 0 and 4, #NUM! error is returned.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO="
msgstr ""
"@FUNCTION=ODDFYIELD\n"
"@SYNTAX=ODDFYIELD(liquidación,vencimiento,emisión,primera_acción,tasa,pr,"
"amortización,frecuencia[,base])\n"
"@DESCRIPTION=ODDFYIELD calcula el margen de una acción teniendo un primer "
"periodo impar.\n"
"\n"
"@liquidación es la fecha de liquidación de la acción. @vencimiento es la "
"fecha de vencimiento de la acción. @frecuencia es el número de pagos al "
"cupón por año. Las frecuencias permitidas son: 1 = anual, 2 = semi, 4 = "
"cuatro veces al año. @base es el tipo de sistema de conteo de días a usar:\n"
"\n"
" 0 US 30/360\n"
" 1 días actuales/días actuales\n"
" 2 días actuales/360\n"
" 3 días actuales/365\n"
" 4 europeo 30/360\n"
"\n"
"* Si @frecuencia es distinto de 1, 2, o 4, ODDFYIELD devuelve un "
"error#NUM!.\n"
"* Si se omite @base se aplica US 30/360.\n"
"* Si @base no está entre 0 y 4, se devuelve un error #NUM!.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO="

#: ../plugins/fn-financial/functions.c:3180
msgid ""
"@FUNCTION=ODDLPRICE\n"
"@SYNTAX=ODDLPRICE(settlement,maturity,last_interest,rate,yld,redemption,"
"frequency[,basis])\n"
"@DESCRIPTION=ODDLPRICE calculates the price per $100 face value of a "
"security that has an odd last coupon period.\n"
"\n"
"@settlement is the settlement date of the security. @maturity is the "
"maturity date of the security. @frequency is the number of coupon payments "
"per year. Allowed frequencies are: 1 = annual, 2 = semi, 4 = quarterly. "
"@basis is the type of day counting system you want to use:\n"
"\n"
"  0  US 30/360\n"
"  1  actual days/actual days\n"
"  2  actual days/360\n"
"  3  actual days/365\n"
"  4  European 30/360\n"
"\n"
"* If @frequency is other than 1, 2, or 4, ODDLPRICE returns #NUM! error.\n"
"* If @basis is omitted, US 30/360 is applied.\n"
"* If @basis is not in between 0 and 4, #NUM! error is returned.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO="
msgstr ""
"@FUNCTION=ODDLPRICE\n"
"@SYNTAX=ODDLPRICE(liquidación,vencimiento,último_interés,tasa,margen,"
"amortización,frecuencia[,base])\n"
"@DESCRIPTION=ODDLPRICE calcula el precio por 100$ de valor facial de una "
"acción que tienen un periodo de último cupón impar.\n"
"\n"
"@liquidación es la fecha de liquidación de la acción. @vencimiento es la "
"fecha de vencimiento de la acción. @frecuencia es el número de pagos al "
"cupón por año. Las frecuencias permitidas son: 1 = anual, 2 = semi, 4 = "
"cuatro veces al año. @base es el tipo de sistema de conteo de días a usar:\n"
"\n"
" 0 US 30/360\n"
" 1 días actuales/días actuales\n"
" 2 días actuales/360\n"
" 3 días actuales/365\n"
" 4 europeo 30/360\n"
"\n"
"* Si @frecuencia es distinto de 1, 2, o 4, ODDLPRICE devuelve un "
"error#NUM!.\n"
"* Si se omite @base se aplica US 30/360.\n"
"* Si @base no está entre 0 y 4, se devuelve un error #NUM!.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO="

#: ../plugins/fn-financial/functions.c:3274
msgid ""
"@FUNCTION=ODDLYIELD\n"
"@SYNTAX=ODDLYIELD(settlement,maturity,last_interest,rate,pr,redemption,"
"frequency[,basis])\n"
"@DESCRIPTION=ODDLYIELD calculates the yield of a security having an odd last "
"period.\n"
"\n"
"@settlement is the settlement date of the security. @maturity is the "
"maturity date of the security. @frequency is the number of coupon payments "
"per year. Allowed frequencies are: 1 = annual, 2 = semi, 4 = quarterly. "
"@basis is the type of day counting system you want to use:\n"
"\n"
"  0  US 30/360\n"
"  1  actual days/actual days\n"
"  2  actual days/360\n"
"  3  actual days/365\n"
"  4  European 30/360\n"
"\n"
"* If @frequency is other than 1, 2, or 4, ODDLYIELD returns #NUM! error.\n"
"* If @basis is omitted, US 30/360 is applied.\n"
"* If @basis is not in between 0 and 4, #NUM! error is returned.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO="
msgstr ""
"@FUNCTION=ODDLYIELD\n"
"@SYNTAX=ODDLYIELD(liquidación,vencimiento,último_interés,tasa,pr,"
"amortización,frecuencia[,base])\n"
"@DESCRIPTION=ODDLYIELD calcula el margen de una acción que tiene un último "
"periodo.\n"
"\n"
"@liquidación es la fecha de liquidación de la acción. @vencimiento es la "
"fecha de vencimiento de la acción. @frecuencia es el número de pagos al "
"cupón por año. Las frecuencias permitidas son: 1 = anual, 2 = semi, 4 = "
"cuatro veces al año. @base es el tipo de sistema de conteo de días a usar:\n"
"\n"
" 0 US 30/360\n"
" 1 días actuales/días actuales\n"
" 2 días actuales/360\n"
" 3 días actuales/365\n"
" 4 europeo 30/360\n"
"\n"
"* Si @frecuencia es distinto de 1, 2, o 4, ODDLYIELD devuelve un "
"error#NUM!.\n"
"* Si se omite @base se aplica US 30/360.\n"
"* Si @base no está entre 0 y 4, se devuelve un error #NUM!.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO="

#: ../plugins/fn-financial/functions.c:3368
msgid ""
"@FUNCTION=AMORDEGRC\n"
"@SYNTAX=AMORDEGRC(cost,purchase_date,first_period,salvage,period,rate[,"
"basis])\n"
"@DESCRIPTION=AMORDEGRC: Calculates depreciation for each accounting period "
"using French accounting conventions.   Assets purchased in the middle of a "
"period take prorated depreciation into account.  This is similar to "
"AMORLINC, except that a depreciation coefficient is applied in the "
"calculation depending on the life of the assets.\n"
"Named for AMORtissement DEGRessif Comptabilite\n"
"\n"
"@cost The value of the asset.\n"
"@purchase_date The date the asset was purchased.\n"
"@first_period The end of the first period.\n"
"@salvage Asset value at maturity.\n"
"@period The length of accounting periods.\n"
"@rate rate of depreciation as a percentage.\n"
"@basis is the type of day counting system you want to use:\n"
"\n"
"  0  US 30/360\n"
"  1  actual days/actual days\n"
"  2  actual days/360\n"
"  3  actual days/365\n"
"  4  European 30/360\n"
"\n"
"* If @basis is omitted, US 30/360 is applied.\n"
"* If @basis is not in between 0 and 4, #NUM! error is returned.\n"
"\n"
"@EXAMPLES=\n"
"AMORDEGRC(2400,DATE(1998,8,19),DATE(1998,12,30),300,1,0.14,1) = 733\n"
"\n"
"@SEEALSO=AMORLINC"
msgstr ""
"@FUNCTION=AMORDEGRC\n"
"@SYNTAX=AMORDEGRC(coste,fecha_compra,primer_periodo,recuperación,periodo,tasa"
"[,base])\n"
"@DESCRIPTION=AMORDEGRC: Calcula la depreciación para cada periodo de cuentas "
"usando convenciones francesas de cuentas. Los activos comprados en el medio "
"de un periodo toman una depreciación protasaada en la cuenta. Esto es "
"similar a AMORLINC, excepto que se aplica un coeficiente de depreciación en "
"el cálculo dependiendo de la vida del los activos.\n"
"El nombre viene por AMORtissement DEGRessif Comptabilite\n"
"\n"
"@coste El valor del activo.\n"
"@fecha_compra La fecha en que se compró el activo.\n"
"@primer_periodo El final del primer período.\n"
"@recuperación Valor del activo al vencimiento.\n"
"@periodo La longitud de los periodos de cuenta.\n"
"@tasa La tasa de depreciación como un porcentaje.\n"
"@base es el tipo de sistema de cuenta de días que quiere usar:\n"
"\n"
" 0 US 30/360\n"
" 1 días actuales/días actuales\n"
" 2 días actuales/360\n"
" 3 días actuales/365\n"
" 4 europeo 30/360\n"
"\n"
"* Si se omite @base, se aplica US 30/360.\n"
"* Si @base no está entre 0 y 4, se devuelve un error #NÚM!.\n"
"\n"
"@EXAMPLES=\n"
"AMORDEGRC(2400,DATE(1998,8,19),DATE(1998,12,30),300,1,0.14,1) = 733\n"
"\n"
"@SEEALSO=AMORLINC"

#: ../plugins/fn-financial/functions.c:3435
msgid ""
"@FUNCTION=AMORLINC\n"
"@SYNTAX=AMORLINC(cost,purchase_date,first_period,salvage,period,rate[,"
"basis])\n"
"@DESCRIPTION=AMORLINC: Calculates depreciation for each accounting period "
"using French accounting conventions.   Assets purchased in the middle of a "
"period take prorated depreciation into account.\n"
"Named for AMORtissement LINeaire Comptabilite.\n"
"\n"
"@cost The value of the asset.\n"
"@purchase_date The date the asset was purchased.\n"
"@first_period The end of the first period.\n"
"@salvage Asset value at maturity.\n"
"@period The length of accounting periods.\n"
"@rate rate of depreciation as a percentage.\n"
"@basis is the type of day counting system you want to use:\n"
"\n"
"  0  US 30/360\n"
"  1  actual days/actual days\n"
"  2  actual days/360\n"
"  3  actual days/365\n"
"  4  European 30/360\n"
"\n"
"* If @basis is omitted, US 30/360 is applied.\n"
"* If @basis is not in between 0 and 4, #NUM! error is returned.\n"
"\n"
"@EXAMPLES=\n"
"AMORLINC(2400,DATE(1998,8,19),DATE(1998,12,31),300,1,0.15,1) = 360\n"
"\n"
"@SEEALSO=AMORDEGRC"
msgstr ""
"@FUNCTION=AMORLINC\n"
"@SYNTAX=AMORLINC(coste,fecha_compra,primer_periodo,recuperación,periodo,tasa"
"[,base])\n"
"@DESCRIPTION=AMORLINC: Calcula la depreciación para cada periodo de cuenta "
"usando convenciones de cuenta francesas. Los activos comprados en el medio "
"de un período toman una depreciación protasaada en la cuenta.\n"
"El nombre viene por AMORtissement LINeaire Comptabilite.\n"
"\n"
"@coste El valor del activo.\n"
"@fecha_compra La fecha en que se compró el activo.\n"
"@primer_periodo El final del primer período.\n"
"@recuperación Valor del activo al vencimiento.\n"
"@periodo La longitud de los periodos de cuenta.\n"
"@tasa La tasa de depreciación como un porcentaje.\n"
"@base es el tipo de sistema de cuenta de días que quiere usar:\n"
"\n"
" 0 US 30/360\n"
" 1 días actuales/días actuales\n"
" 2 días actuales/360\n"
" 3 días actuales/365\n"
" 4 europeo 30/360\n"
"\n"
"* Si se omite @base, se aplica US 30/360.\n"
"* Si @base no está entre 0 y 4, se devuelve un error #NÚM!.\n"
"\n"
"@EXAMPLES=\n"
"AMORLINC(2400,DATE(1998,8,19),DATE(1998,12,31),300,1,0.15,1) = 360\n"
"\n"
"@SEEALSO=AMORDEGRC"

#: ../plugins/fn-financial/functions.c:3497
msgid ""
"@FUNCTION=COUPDAYBS\n"
"@SYNTAX=COUPDAYBS(settlement,maturity,frequency[,basis,eom])\n"
"@DESCRIPTION=COUPDAYBS returns the number of days from the beginning of the "
"coupon period to the settlement date.\n"
"\n"
"@settlement is the settlement date of the security.\n"
"@maturity is the maturity date of the security.\n"
"@frequency is the number of coupon payments per year.\n"
"@eom = TRUE handles end of month maturity dates special.\n"
"Allowed frequencies are: 1 = annual, 2 = semi, 4 = quarterly, 6 = bimonthly, "
"12 = monthly.\n"
"@basis is the type of day counting system you want to use:\n"
"\n"
"  0  MSRB 30/360 (MSRB Rule G33 (e))\n"
"  1  actual days/actual days\n"
"  2  actual days/360\n"
"  3  actual days/365\n"
"  4  European 30/360\n"
"  5  European+ 30/360\n"
"\n"
"(See the gnumeric manual for a detailed description of these bases).\n"
"\n"
"* If @frequency is invalid, COUPDAYBS returns #NUM! error.\n"
"* If @basis is omitted, MSRB 30/360 is applied.\n"
"* If @basis is invalid, #NUM! error is returned.\n"
"\n"
"@EXAMPLES=\n"
"COUPDAYBS (DATE(2002,11,29),DATE(2004,2,29),4,0) = 89\n"
"COUPDAYBS (DATE(2002,11,29),DATE(2004,2,29),4,0,FALSE) = 0\n"
"\n"
"@SEEALSO="
msgstr ""
"@FUNCTION=COUPDAYBS\n"
"@SYNTAX=COUPDAYBS(liquidación,vencimiento,frecuencia[,base,eom])\n"
"@DESCRIPTION=COUPDAYBS devuelve el número de días desde el principio del "
"periodo de cupón hasta la fecha de liquidación.\n"
"\n"
"@liquidación es la fecha de liquidación de la acción.\n"
"@vencimiento es la fecha de vencimiento de la acción.\n"
"@frecuencia es el número de pagos al cupón por año\n"
"@eom = VERDADERO trata el final de las fechas de vencimiento mensuales "
"especiales.\n"
"Las frecuencias permitidas son: 1 = anual, 2 = semi, 4 = 4 veces al año, 6 = "
"6 veces al año, 12 = 12 meses al año.\n"
"@base es el tipo de sistema de conteo de días que quiere usar:\n"
"\n"
" 0 MSRB 30/360 (MSRB Rule G33 (e))\n"
" 1 días actuales/días actuales\n"
" 2 días actuales/360\n"
" 3 días actuales/365\n"
" 4 europeo 30/360\n"
" 5 europeo+ 30/360\n"
"\n"
"(Vea el manual de Gnumeric para una descripción detallada de estas bases).\n"
"\n"
"* Si la @frecuencia es inválida, COUPDAYBS devuelve un error#NUM!\n"
"* Si la @base se omite, se aplica MSRB 30/360.\n"
"* Si la @base es inválida, se devuelve un error #NUM!\n"
"\n"
"@EXAMPLES=\n"
"COUPDAYBS (DATE(2002,11,29),DATE(2004,2,29),4,0) = 89\n"
"COUPDAYBS (DATE(2002,11,29),DATE(2004,2,29),4,0,FALSO) = 0\n"
"\n"
"@SEEALSO="

#: ../plugins/fn-financial/functions.c:3545
msgid ""
"@FUNCTION=COUPDAYS\n"
"@SYNTAX=COUPDAYS(settlement,maturity,frequency[,basis,eom])\n"
"@DESCRIPTION=COUPDAYS returns the number of days in the coupon period of the "
"settlement date.\n"
"\n"
"@settlement is the settlement date of the security.\n"
"@maturity is the maturity date of the security.\n"
"@frequency is the number of coupon payments per year.\n"
"@eom = TRUE handles end of month maturity dates special.\n"
"Allowed frequencies are: 1 = annual, 2 = semi, 4 = quarterly, 6 = bimonthly, "
"12 = monthly.\n"
"@basis is the type of day counting system you want to use:\n"
"\n"
"  0  MSRB 30/360 (MSRB Rule G33 (e))\n"
"  1  actual days/actual days\n"
"  2  actual days/360\n"
"  3  actual days/365\n"
"  4  European 30/360\n"
"  5  European+ 30/360\n"
"\n"
"(See the gnumeric manual for a detailed description of these bases).\n"
"\n"
"* If @frequency is invalid, COUPDAYS returns #NUM! error.\n"
"* If @basis is omitted, MSRB 30/360 is applied.\n"
"* If @basis is invalid, #NUM! error is returned.\n"
"\n"
"@EXAMPLES=\n"
"COUPDAYS (DATE(2002,11,29),DATE(2004,2,29),4,0) = 90\n"
"COUPDAYS (DATE(2002,11,29),DATE(2004,2,29),4,0,FALSE) = 90\n"
"COUPDAYS (DATE(2002,11,29),DATE(2004,2,29),4,1,FALSE) = 91\n"
"\n"
"@SEEALSO="
msgstr ""
"@FUNCTION=COUPDAYS\n"
"@SYNTAX=COUPDAYS(liquidación,vencimiento,frecuencia[,base,fdv])\n"
"@DESCRIPTION=COUPDAYS devuelve el número de días en el periodo de cupón de "
"la fecha de liquidación.\n"
"\n"
"@liquidación es la fecha de liquidación de la acción.\n"
"@vencimiento es la fecha de vencimiento de la acción.\n"
"@frecuencia es el número de pagos al cupón por año\n"
"@fdv = VERDADERO trata el final de las fechas de vencimiento mensuales "
"especiales.\n"
"Las frecuencias permitidas son: 1 = anual, 2 = semi, 4 = 4 veces al año, 6 = "
"6 veces al año, 12 = 12 meses al año.\n"
"@base es el tipo de sistema de conteo de días que quiere usar:\n"
"\n"
" 0 MSRB 30/360 (MSRB Rule G33 (e))\n"
" 1 días actuales/días actuales\n"
" 2 días actuales/360\n"
" 3 días actuales/365\n"
" 4 europeo 30/360\n"
" 5 europeo+ 30/360\n"
"\n"
"(Vea el manual de Gnumeric para una descripción detallada de estas bases).\n"
"\n"
"* Si la @frecuencia es inválida, COUPDAYS devuelve un error#NUM!\n"
"* Si la @base se omite, se aplica MSRB 30/360.\n"
"* Si la @base es inválida, se devuelve un error #NUM!\n"
"\n"
"@EXAMPLES=\n"
"COUPDAYS (DATE(2002,11,29),DATE(2004,2,29),4,0) = 90\n"
"COUPDAYS (DATE(2002,11,29),DATE(2004,2,29),4,0,FALSO) = 90\n"
"COUPDAYS (DATE(2002,11,29),DATE(2004,2,29),4,1,FALSO) = 91\n"
"\n"
"@SEEALSO="

#: ../plugins/fn-financial/functions.c:3594
msgid ""
"@FUNCTION=COUPDAYSNC\n"
"@SYNTAX=COUPDAYSNC(settlement,maturity,frequency[,basis,eom])\n"
"@DESCRIPTION=COUPDAYSNC returns the number of days from the settlement date "
"to the next coupon date.\n"
"\n"
"@settlement is the settlement date of the security.\n"
"@maturity is the maturity date of the security.\n"
"@frequency is the number of coupon payments per year.\n"
"@eom = TRUE handles end of month maturity dates special.\n"
"Allowed frequencies are: 1 = annual, 2 = semi, 4 = quarterly, 6 = bimonthly, "
"12 = monthly.\n"
"@basis is the type of day counting system you want to use:\n"
"\n"
"  0  MSRB 30/360 (MSRB Rule G33 (e))\n"
"  1  actual days/actual days\n"
"  2  actual days/360\n"
"  3  actual days/365\n"
"  4  European 30/360\n"
"  5  European+ 30/360\n"
"\n"
"(See the gnumeric manual for a detailed description of these bases).\n"
"\n"
"* If @frequency is invalid, COUPDAYSNC returns #NUM! error.\n"
"* If @basis is omitted, MSRB 30/360 is applied.\n"
"* If @basis is invalid, #NUM! error is returned.\n"
"\n"
"@EXAMPLES=\n"
"COUPDAYSNC (DATE(2002,11,29),DATE(2004,2,29),4,0) = 1\n"
"COUPDAYSNC (DATE(2002,11,29),DATE(2004,2,29),4,0,FALSE) = 89\n"
"\n"
"@SEEALSO="
msgstr ""
"@FUNCTION=COUPDAYSNC\n"
"@SYNTAX=COUPDAYSNC(liquidación,vencimiento,frecuencia[,base,fdv])\n"
"@DESCRIPTION=COUPDAYSNC devuelve el número de días desde la fecha de "
"liquidación hasta la siguiente fecha de cupón.\n"
"\n"
"@liquidación es la fecha de liquidación de la acción.\n"
"@vencimiento es la fecha de vencimiento de la acción.\n"
"@frecuencia es el número de pagos al cupón por año\n"
"@fdv = VERDADERO trata el final de las fechas de vencimiento mensuales "
"especiales.\n"
"Las frecuencias permitidas son: 1 = anual, 2 = semi, 4 = 4 veces al año, 6 = "
"6 veces al año, 12 = 12 meses al año.\n"
"@base es el tipo de sistema de conteo de días que quiere usar:\n"
"\n"
" 0 MSRB 30/360 (MSRB Rule G33 (e))\n"
" 1 días actuales/días actuales\n"
" 2 días actuales/360\n"
" 3 días actuales/365\n"
" 4 europeo 30/360\n"
" 5 europeo+ 30/360\n"
"\n"
"(Vea el manual de Gnumeric para una descripción detallada de estas bases).\n"
"\n"
"* Si la @frecuencia es inválida, COUPDAYSNC devuelve un error#NUM!\n"
"* Si la @base se omite, se aplica MSRB 30/360.\n"
"* Si la @base es inválida, se devuelve un error #NUM!\n"
"\n"
"@EXAMPLES=\n"
"COUPDAYSNC (DATE(2002,11,29),DATE(2004,2,29),4,0) = 1\n"
"COUPDAYSNC (DATE(2002,11,29),DATE(2004,2,29),4,0,FALSO) = 89\n"
"\n"
"@SEEALSO="

#: ../plugins/fn-financial/functions.c:3642
msgid ""
"@FUNCTION=COUPNCD\n"
"@SYNTAX=COUPNCD(settlement,maturity,frequency[,basis,eom])\n"
"@DESCRIPTION=COUPNCD returns the coupon date following settlement.\n"
"\n"
"@settlement is the settlement date of the security.\n"
"@maturity is the maturity date of the security.\n"
"@frequency is the number of coupon payments per year.\n"
"@eom = TRUE handles end of month maturity dates special.\n"
"Allowed frequencies are: 1 = annual, 2 = semi, 4 = quarterly, 6 = bimonthly, "
"12 = monthly.\n"
"@basis is the type of day counting system you want to use:\n"
"\n"
"  0  MSRB 30/360 (MSRB Rule G33 (e))\n"
"  1  actual days/actual days\n"
"  2  actual days/360\n"
"  3  actual days/365\n"
"  4  European 30/360\n"
"  5  European+ 30/360\n"
"\n"
"(See the gnumeric manual for a detailed description of these bases).\n"
"\n"
"* If @frequency is invalid, COUPNCD returns #NUM! error.\n"
"* If @basis is omitted, MSRB 30/360 is applied.\n"
"* If @basis is invalid, #NUM! error is returned.\n"
"\n"
"@EXAMPLES=\n"
"COUPNCD (DATE(2002,11,29),DATE(2004,2,29),4,0) = 30-Nov-2002\n"
"COUPNCD (DATE(2002,11,29),DATE(2004,2,29),4,0,FALSE) = 28-Feb-2003\n"
"\n"
"@SEEALSO="
msgstr ""
"@FUNCTION=COUPNCD\n"
"@SYNTAX=COUPNCD(liquidación,vencimiento,frecuencia[,base,fdv])\n"
"@DESCRIPTION=COUPNCD devuelve la fecha de cupón de la siguiente "
"liquidación.\n"
"\n"
"@liquidación es la fecha de liquidación de la acción.\n"
"@vencimiento es la fecha de vencimiento de la acción.\n"
"@frecuencia es el número de pagos al cupón por año\n"
"@fdv = VERDADERO trata el final de las fechas de vencimiento mensuales "
"especiales.\n"
"Las frecuencias permitidas son: 1 = anual, 2 = semi, 4 = 4 veces al año, 6 = "
"6 veces al año, 12 = 12 meses al año.\n"
"@base es el tipo de sistema de conteo de días que quiere usar:\n"
"\n"
" 0 MSRB 30/360 (MSRB Rule G33 (e))\n"
" 1 días actuales/días actuales\n"
" 2 días actuales/360\n"
" 3 días actuales/365\n"
" 4 europeo 30/360\n"
" 5 europeo+ 30/360\n"
"\n"
"(Vea el manual de Gnumeric para una descripción detallada de estas bases).\n"
"\n"
"* Si la @frecuencia es inválida, COUPNCD devuelve un error#NUM!\n"
"* Si la @base se omite, se aplica MSRB 30/360.\n"
"* Si la @base es inválida, se devuelve un error #NUM!\n"
"\n"
"@EXAMPLES=\n"
"COUPNCD (DATE(2002,11,29),DATE(2004,2,29),4,0) = 30-Nov-2002\n"
"COUPNCD (DATE(2002,11,29),DATE(2004,2,29),4,0,FALSO) = 28-Feb-2003\n"
"\n"
"@SEEALSO="

#: ../plugins/fn-financial/functions.c:3691
msgid ""
"@FUNCTION=COUPPCD\n"
"@SYNTAX=COUPPCD(settlement,maturity,frequency[,basis,eom])\n"
"@DESCRIPTION=COUPPCD returns the coupon date preceding settlement.\n"
"\n"
"@settlement is the settlement date of the security.\n"
"@maturity is the maturity date of the security.\n"
"@frequency is the number of coupon payments per year.\n"
"@eom = TRUE handles end of month maturity dates special.\n"
"Allowed frequencies are: 1 = annual, 2 = semi, 4 = quarterly, 6 = bimonthly, "
"12 = monthly.\n"
"@basis is the type of day counting system you want to use:\n"
"\n"
"  0  MSRB 30/360 (MSRB Rule G33 (e))\n"
"  1  actual days/actual days\n"
"  2  actual days/360\n"
"  3  actual days/365\n"
"  4  European 30/360\n"
"  5  European+ 30/360\n"
"\n"
"(See the gnumeric manual for a detailed description of these bases).\n"
"\n"
"* If @frequency is invalid, COUPPCD returns #NUM! error.\n"
"* If @basis is omitted, MSRB 30/360 is applied.\n"
"* If @basis is invalid, #NUM! error is returned.\n"
"\n"
"@EXAMPLES=\n"
"COUPPCD (DATE(2002,11,29),DATE(2004,2,29),4,0) = 31-Aug-2002\n"
"COUPPCD (DATE(2002,11,29),DATE(2004,2,29),4,0,FALSE) = 29-Nov-2002\n"
"\n"
"@SEEALSO="
msgstr ""
"@FUNCTION=COUPPCD\n"
"@SYNTAX=COUPPCD(liquidación,vencimiento,frecuencia[,base,eom])\n"
"@DESCRIPTION=COUPPCD devuelve la fecha de cupón precedente a la "
"liquidación.\n"
"\n"
"@liquidación es la fecha de liquidación de la acción.\n"
"@vencimiento es la fecha de vencimiento de la acción.\n"
"@frecuencia es el número de pagos al cupón por año\n"
"@eom = VERDADERO trata el final de las fechas de vencimiento mensuales "
"especiales.\n"
"Las frecuencias permitidas son: 1 = anual, 2 = semi, 4 = 4 veces al año, 6 = "
"6 veces al año, 12 = 12 meses al año.\n"
"@base es el tipo de sistema de conteo de días que quiere usar:\n"
"\n"
" 0 MSRB 30/360 (MSRB Rule G33 (e))\n"
" 1 días actuales/días actuales\n"
" 2 días actuales/360\n"
" 3 días actuales/365\n"
" 4 europeo 30/360\n"
" 5 europeo+ 30/360\n"
"\n"
"(Vea el manual de Gnumeric para una descripción detallada de estas bases).\n"
"\n"
"* Si la @frecuencia es inválida, COUPPCD devuelve un error#NUM!\n"
"* Si la @base se omite, se aplica MSRB 30/360.\n"
"* Si la @base es inválida, se devuelve un error #NUM!\n"
"\n"
"@EXAMPLES=\n"
"COUPPCD (DATE(2002,11,29),DATE(2004,2,29),4,0) = 31-AUG-2002\n"
"COUPPCD (DATE(2002,11,29),DATE(2004,2,29),4,0,FALSO) = 29-Nov-2002\n"
"\n"
"@SEEALSO="

#: ../plugins/fn-financial/functions.c:3741
msgid ""
"@FUNCTION=COUPNUM\n"
"@SYNTAX=COUPNUM(settlement,maturity,frequency[,basis,eom])\n"
"@DESCRIPTION=COUPNUM returns the numbers of coupons to be paid between the "
"settlement and maturity dates, rounded up.\n"
"\n"
"@settlement is the settlement date of the security.\n"
"@maturity is the maturity date of the security.\n"
"@frequency is the number of coupon payments per year.\n"
"@eom = TRUE handles end of month maturity dates special.\n"
"Allowed frequencies are: 1 = annual, 2 = semi, 4 = quarterly. 6 = bimonthly, "
"12 = monthly.\n"
"@basis is the type of day counting system you want to use:\n"
"\n"
"  0  MSRB 30/360 (MSRB Rule G33 (e))\n"
"  1  actual days/actual days\n"
"  2  actual days/360\n"
"  3  actual days/365\n"
"  4  European 30/360\n"
"  5  European+ 30/360\n"
"\n"
"* If @frequency is other than 1, 2, 4, 6 or 12, COUPNUM returns #NUM! "
"error.\n"
"* If @basis is omitted, MSRB 30/360 is applied.\n"
"* If @basis is not in between 0 and 5, #NUM! error is returned.\n"
"\n"
"@EXAMPLES=\n"
"COUPNUM (DATE(2002,11,29),DATE(2004,2,29),4,0) = 6\n"
"COUPNUM (DATE(2002,11,29),DATE(2004,2,29),4,0,FALSE) = 5\n"
"@SEEALSO="
msgstr ""
"@FUNCTION=COUPNUM\n"
"@SYNTAX=COUPNUM(liquidación,vencimiento,frecuencia[,base,eom])\n"
"@DESCRIPTION=COUPNUM devuelve el número de copones a ser pagados entre las "
"fechas de liquidación y vencimiento , redondeado arriba.\n"
"\n"
"@liquidación es la fecha de liquidación de la acción.\n"
"@vencimiento es la fecha de vencimiento de la acción.\n"
"@frecuencia es el número de pagos al cupón por año\n"
"@eom = VERDADERO trata el final de las fechas de vencimiento mensuales "
"especiales.\n"
"Las frecuencias permitidas son: 1 = anual, 2 = semi, 4 = 4 veces al año, 6 = "
"6 veces al año, 12 = 12 meses al año.\n"
"@base es el tipo de sistema de conteo de días que quiere usar:\n"
"\n"
" 0 MSRB 30/360 (MSRB Rule G33 (e))\n"
" 1 días actuales/días actuales\n"
" 2 días actuales/360\n"
" 3 días actuales/365\n"
" 4 europeo 30/360\n"
" 5 europeo+ 30/360\n"
"\n"
"(Vea el manual de Gnumeric para una descripción detallada de estas bases).\n"
"\n"
"* Si la @frecuencia es inválida, COUPPCD devuelve un error#NUM!\n"
"* Si la @base se omite, se aplica MSRB 30/360.\n"
"* Si la @base es inválida, se devuelve un error #NUM!\n"
"\n"
"@EXAMPLES=\n"
"COUPNUM (DATE(2002,11,29),DATE(2004,2,29),4,0) = 6\n"
"COUPNUM (DATE(2002,11,29),DATE(2004,2,29),4,0,FALSO) = 5\n"
"@SEEALSO="

#: ../plugins/fn-financial/functions.c:3785
msgid ""
"@FUNCTION=CUMIPMT\n"
"@SYNTAX=CUMIPMT(rate,nper,pv,start_period,end_period,type)\n"
"@DESCRIPTION=CUMIPMT returns the cumulative interest paid on a loan between "
"@start_period and @end_period.\n"
"\n"
"* If @rate <= 0, CUMIPMT returns #NUM! error.\n"
"* If @nper <= 0, CUMIPMT returns #NUM! error.\n"
"* If @pv <= 0, CUMIPMT returns #NUM! error.\n"
"* If @start_period < 1, CUMIPMT returns #NUM! error.\n"
"* If @end_period < @start_period, CUMIPMT returns #NUM! error.\n"
"* If @end_period > @nper, CUMIPMT returns #NUM! error.\n"
"* If @type <> 0 and @type <> 1, CUMIPMT returns #NUM! error.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO="
msgstr ""
"@FUNCTION=CUMIPMT\n"
"@SYNTAX=CUMIPMT(tasa,nper,pv,periodo_inicio,periodo_fin,tipo)\n"
"@DESCRIPTION=CUMIPMT devuelve el interés acumulado pagado en un préstamo "
"entre @periodo_inicio y @periodo_fin.\n"
"\n"
"* Si la @tasa <= 0, CUMPRINC devuelve un error #NÚM!\n"
"* Si @nper <= 0, CUMPRINC devuelve un error #NÚM!\n"
"* Si @pv <= 0, CUMPRINC devuelve un error #NÚM!\n"
"* Si @periodo_inicio < 1, CUMPRINC devuelve un error #NÚM!\n"
"* Si @periodo_fin < @periodo_inicio, CUMPRINC devuelve un error #NÚM!\n"
"* Si @periodo_fin > @nper, CUMPRINC devuelve un error #NÚM!\n"
"* Si @tipo <> 0 y @type <> 1, CUMPRINC devuelve un error#NUM!\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO="

#: ../plugins/fn-financial/functions.c:3838
msgid ""
"@FUNCTION=CUMPRINC\n"
"@SYNTAX=CUMPRINC(rate,nper,pv,start_period,end_period,type)\n"
"@DESCRIPTION=CUMPRINC returns the cumulative principal paid on a loan "
"between @start_period and @end_period.\n"
"\n"
"* If @rate <= 0, CUMPRINC returns #NUM! error.\n"
"* If @nper <= 0, CUMPRINC returns #NUM! error.\n"
"* If @pv <= 0, CUMPRINC returns #NUM! error.\n"
"* If @start_period < 1, CUMPRINC returns #NUM! error.\n"
"* If @end_period < @start_period, CUMPRINC returns #NUM! error.\n"
"* If @end_period > @nper, CUMPRINC returns #NUM! error.\n"
"* If @type <> 0 and @type <> 1, CUMPRINC returns #NUM! error.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO="
msgstr ""
"@FUNCTION=CUMPRINC\n"
"@SYNTAX=CUMPRINC(tasa,nper,pv,periodo_inicio,periodo_fin,tipo)\n"
"@DESCRIPTION=CUMPRINC devuelve el pago acumulativo director de un préstamo "
"entre @periodo_inicio y @periodo_fin.\n"
"\n"
"* Si la @tasa <= 0, CUMPRINC devuelve un error #NÚM!\n"
"* Si @nper <= 0, CUMPRINC devuelve un error #NÚM!\n"
"* Si @pv <= 0, CUMPRINC devuelve un error #NÚM!\n"
"* Si @periodo_inicio < 1, CUMPRINC devuelve un error #NÚM!\n"
"* Si @periodo_fin < @periodo_inicio, CUMPRINC devuelve un error #NÚM!\n"
"* Si @periodo_fin > @nper, CUMPRINC devuelve un error #NÚM!\n"
"* Si @tipo <> 0 y @type <> 1, CUMPRINC devuelve un error#NUM!\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO="

#: ../plugins/fn-financial/functions.c:3891
msgid ""
"@FUNCTION=MDURATION\n"
"@SYNTAX=MDURATION(settlement,maturity,coupon,yield,frequency[,basis])\n"
"@DESCRIPTION=MDURATION returns the Macauley duration for a security with par "
"value 100.\n"
"\n"
"@basis is the type of day counting system you want to use:\n"
"\n"
"  0  MSRB 30/360 (MSRB Rule G33 (e))\n"
"  1  actual days/actual days\n"
"  2  actual days/360\n"
"  3  actual days/365\n"
"  4  European 30/360\n"
"  5  European+ 30/360\n"
"\n"
"* If @settlement or @maturity are not valid dates, MDURATION returns #NUM! "
"error.\n"
"* If @frequency is other than 1, 2, or 4, MDURATION returns #NUM! error.\n"
"* If @basis is omitted, MSRB 30/360 is applied.\n"
"* If @basis is invalid, #NUM! error is returned.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=DURATION,G_DURATION"
msgstr ""
"@FUNCTION=MDURATION\n"
"@SYNTAX=MDURATION(liquidación,vencimiento,cupón,margen,frecuencia[,base])\n"
"@DESCRIPTION=MDURATION devuelve la duración de Macauley para una inversión "
"con valor par 100.\n"
"\n"
"@base es el tipo de sistema de conteo de días que quiere usar:\n"
"\n"
" 0 MSRB 30/360 (MSRB Rule G33 (e))\n"
" 1 días actuales/días actuales\n"
" 2 días actuales/360\n"
" 3 días actuales/365\n"
" 4 europeo 30/360\n"
" 5 europeo+ 30/360\n"
"\n"
"* Si la @liquidación o el @vencimiento no son fechas válidas, MDURATION "
"devuelve un error #NÚM!\n"
"* Si la @frecuencia es distinta de 1, 2, o 4, MDURATION devuelve un "
"error#NUM!\n"
"* Si la @base se omite, se aplica MSRB 30/360.\n"
"* Si la @base es inválida, se devuelve un error #NUM!\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=DURATION,G_DURATION"

#: ../plugins/fn-financial/functions.c:3952
msgid ""
"@FUNCTION=VDB\n"
"@SYNTAX=VDB(cost,salvage,life,start_period,end_period[,factor,switch])\n"
"@DESCRIPTION=VDB calculates the depreciation of an asset for a given period "
"or partial period using the double-declining balance method.\n"
"\n"
"* If @start_period < 0, VDB returns #NUM! error.\n"
"* If @start_period > @end_period, VDB returns #NUM! error.\n"
"* If @end_period > @life, VDB returns #NUM! error.\n"
"* If @cost < 0, VDB returns #NUM! error.\n"
"* If @salvage > @cost, VDB returns #NUM! error.\n"
"* If @factor <= 0, VDB returns #NUM! error.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=DB"
msgstr ""
"@FUNCTION=VDB\n"
"@SYNTAX=VDB(coste,recuperación,vida,período_inicio,período_fin[,factor,"
"cambio])\n"
"@DESCRIPTION=VDB calcula la depreciación de un activo para un período dado o "
"un período parcial usando el método de balance de la doble declinación.\n"
"\n"
"* Si @período_inicio < 0, VDB devuelve el error #NÚM!.\n"
"* Si @período_inicio > @período_fin, VDB devuelve el error #NÚM!.\n"
"* Si @periodo_fin > @vida, VDB devuelve un error #NÚM!\n"
"* Si @coste < 0, VDB devuelve un error #NÚM!\n"
"* Si @recuperación > @coste, VDB devuelve un error #NÚM!\n"
"* Si @factor <= 0, VDB devuelve un error #NÚM!\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=DB"

#: ../plugins/fn-info/functions.c:69
msgid ""
"@FUNCTION=CELL\n"
"@SYNTAX=CELL(type,ref)\n"
"@DESCRIPTION=CELL returns information about the formatting, location, or "
"contents of a cell.\n"
"\n"
"@type specifies the type of information you want to obtain:\n"
"\n"
"  address    \tReturns the given cell reference as text.\n"
"  col        \t\tReturns the number of the column in @ref.\n"
"  contents   \tReturns the contents of the cell in @ref.\n"
"  format     \t\tReturns the code of the format of the cell.\n"
"  parentheses\tReturns 1 if @ref contains a negative value\n"
"             \t\tand its format displays it with parentheses.\n"
"  row        \t\tReturns the number of the row in @ref.\n"
"  width      \t\tReturns the column width.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"Cell(\"format\",A1) returns the code of the format of the cell A1.\n"
"\n"
"@SEEALSO=INDIRECT"
msgstr ""
"@FUNCTION=CELL\n"
"@SYNTAX=CELL(tipo,ref)\n"
"@DESCRIPTION=CELL devuelve información sobre el formato, ubicación o "
"contenidos de una celda.\n"
"\n"
"@tipo especifica el tipo de información que se quiere obtener:\n"
"\n"
"  address  \tDevuelve la referencia de celda como texto.\n"
"  col   \tDevuelve el número de la columna de @ref.\n"
"  contents \tDevuelve los contenidos de la celda de @ref.\n"
"  format  \tDevuelve el código de formato de la celda.\n"
"  parentheses \tDevuelve 1 si @ref contiene un valor negativo y\n"
"     \tsu formato lo muestra con paréntesis.\n"
"  row  \t\tDevuelve el número de la fila de @ref.\n"
"  width  \t\tDevuelve el ancho de la columna.\n"
"\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"CELL(\"format\",A1) devuelve el código de formato de la celda A1.\n"
"\n"
"@SEEALSO=INDIRECT"

#: ../plugins/fn-info/functions.c:1166
msgid ""
"@FUNCTION=EXPRESSION\n"
"@SYNTAX=EXPRESSION(cell)\n"
"@DESCRIPTION=EXPRESSION returns expression in @cell as a string, or empty if "
"the cell is not an expression.\n"
"@EXAMPLES=\n"
"entering '=EXPRESSION(A3)' in A2 = empty (assuming there is nothing in A3).\n"
"entering '=EXPRESSION(A2)' in A1 = 'EXPRESSION(A3)'.\n"
"\n"
"@SEEALSO=TEXT"
msgstr ""
"@FUNCTION=EXPRESSION\n"
"@SYNTAX=EXPRESSION(celda)\n"
"@DESCRIPTION=Devuelve la expresión en @celda como una cadena, o vacío si la "
"celda no es una expresión.\n"
"@EXAMPLES=\n"
"Entrando '=EXPRESSION(A3)' en A2 = empty (aumiendo que no hay nada en A3).\n"
"Entrando '=EXPRESSION(A2)' en A1 = 'EXPRESSION(A3)'.\n"
"\n"
"@SEEALSO=TEXT"

#: ../plugins/fn-info/functions.c:1211
msgid ""
"@FUNCTION=GET.FORMULA\n"
"@SYNTAX=GET.FORMULA(cell)\n"
"@DESCRIPTION=EXPRESSION returns expression in @cell as a string, or empty if "
"the cell is not an expression.\n"
"@EXAMPLES=\n"
"entering '=GET.FORMULA(A3)' in A2 = empty (assuming there is nothing in "
"A3).\n"
"entering '=GET.FORMULA(A2)' in A1 = '=GET.FORMULA(A3)'.\n"
"\n"
"@SEEALSO=EXPRESSION"
msgstr ""
"@FUNCTION=GET.FORMULA\n"
"@SYNTAX=GET.FORMULA(celda)\n"
"@DESCRIPTION=Devuelve la expresión en @celda como una cadena, o vacío si la "
"celda no es una expresión.\n"
"@EXAMPLES=\n"
"Entrando '=GET.FORMULA(A3)' en A2 = empty (aumiendo que no hay nada en A3).\n"
"Entrando '=GET.FORMULA(A2)' en A1 = 'GET.FORMULA(A3)'.\n"
"\n"
"@SEEALSO=EXPRESSION"

#: ../plugins/fn-info/functions.c:1259
msgid ""
"@FUNCTION=COUNTBLANK\n"
"@SYNTAX=COUNTBLANK(range)\n"
"@DESCRIPTION=COUNTBLANK returns the number of blank cells in a @range.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"COUNTBLANK(A1:A20) returns the number of blank cell in A1:A20.\n"
"\n"
"@SEEALSO=COUNT"
msgstr ""
"@FUNCTION=COUNTBLANK\n"
"@SYNTAX=COUNTBLANK(rango)\n"
"@DESCRIPTION=COUNTBLANK devuelve la cantidad de celdas vacías en @rango.\n"
"\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"COUNTBLANK(A1:A20) devuelve el número de celdas vacías en A1:A20.\n"
"\n"
"@SEEALSO=COUNT"

#: ../plugins/fn-info/functions.c:1322
msgid ""
"@FUNCTION=INFO\n"
"@SYNTAX=INFO(type)\n"
"@DESCRIPTION=INFO returns information about the current operating "
"environment. \n"
"\n"
"@type is the type of information you want to obtain:\n"
"\n"
"  memavail \tReturns the amount of memory available, bytes.\n"
"  memused  \tReturns the amount of memory used (bytes).\n"
"  numfile  \t\tReturns the number of active worksheets.\n"
"  osversion\t\tReturns the operating system version.\n"
"  recalc   \t\tReturns the recalculation mode (automatic).\n"
"  release  \t\tReturns the version of Gnumeric as text.\n"
"  system   \t\tReturns the name of the environment.\n"
"  totmem   \t\tReturns the amount of total memory available.\n"
"\n"
"* This function is Excel compatible, except that types directory and origin "
"are not implemented.\n"
"\n"
"@EXAMPLES=\n"
"INFO(\"system\") returns \"Linux\" on a Linux system.\n"
"\n"
"@SEEALSO="
msgstr ""
"@FUNCTION=INFO\n"
"@SYNTAX=INFO(tipo)\n"
"@DESCRIPTION=Entrega información entrono de operación actual.\n"
"\n"
"@tipo es la información que se desea obtener:\n"
"\n"
" memavail  Devuelve la cantidad de memoria disponible (bytes).\n"
" memused   Devuelve la cantidad de memoria usada (bytes).\n"
" numfile   Devuelve el número de hojas de cálculo activas.\n"
" osversion  Devuelve la versión del sistema operativo.\n"
" recalc   Devuelve el modo de recalculo (automático).\n"
" release   Devuelve la versión de Gnumeric as text.\n"
" system   Devuelve el nombre del sistema.\n"
" totmem   Devuelve la cantidad de memoria total del sistema.\n"
"\n"
"* Esta función es compatible con Excel, exceptuando los tipos directorio y "
"origen, los cuales no están implementados.\n"
"\n"
"@EXAMPLES=\n"
"INFO(\"system\") es igual a \"Linux\" en un sistema GNU/Linux.\n"
"\n"
"@SEEALSO="

#: ../plugins/fn-info/functions.c:1430
msgid ""
"@FUNCTION=ISERROR\n"
"@SYNTAX=ISERROR(value)\n"
"@DESCRIPTION=ISERROR returns a TRUE value if the expression has an error.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"ISERROR(NA()) equals TRUE.\n"
"\n"
"@SEEALSO=ERROR"
msgstr ""
"@FUNCTION=ISERROR\n"
"@SYNTAX=ISERROR(valor)\n"
"@DESCRIPTION=Devuelve VERDADERO si la expresión contiene un error.\n"
"\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"ISERROR(NA()) es igual a VERDADERO.\n"
"\n"
"@SEEALSO=ERROR"

#: ../plugins/fn-info/functions.c:1455
msgid ""
"@FUNCTION=ISNA\n"
"@SYNTAX=ISNA(value)\n"
"@DESCRIPTION=ISNA returns TRUE if the value is the #N/A error value.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"ISNA(NA()) equals TRUE.\n"
"\n"
"@SEEALSO=NA"
msgstr ""
"@FUNCTION=ISNA\n"
"@SYNTAX=ISNA(valor)\n"
"@DESCRIPTION=ISNA devuelve VERDADERO si el valor es el error #N/D.\n"
"\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"ISNA(NA()) es igual a VERDADERO.\n"
"\n"
"@SEEALSO=NA"

#: ../plugins/fn-info/functions.c:1484
msgid ""
"@FUNCTION=ISERR\n"
"@SYNTAX=ISERR(value)\n"
"@DESCRIPTION=ISERR returns TRUE if the value is any error value except #N/"
"A.\n"
"\n"
"* This function is Excel compatible. \n"
"@EXAMPLES=\n"
"ISERR(NA()) return FALSE.\n"
"\n"
"@SEEALSO=ISERROR"
msgstr ""
"@FUNCTION=ISERR\n"
"@SYNTAX=ISERR(valor)\n"
"@DESCRIPTION=ISERR devuelve VERDADERO si @valor es un error cualquiera, "
"excepto #N/D.\n"
"\n"
"Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"ISERR(NA()) es igual a FALSO.\n"
"\n"
"@SEEALSO="

#: ../plugins/fn-info/functions.c:1510
msgid ""
"@FUNCTION=ERROR.TYPE\n"
"@SYNTAX=ERROR.TYPE(value)\n"
"@DESCRIPTION=ERROR.TYPE returns an error number corresponding to the given "
"error value.  The error numbers for error values are:\n"
"\n"
"\t#DIV/0!  \t\t2\n"
"\t#VALUE!  \t3\n"
"\t#REF!    \t\t4\n"
"\t#NAME?   \t5\n"
"\t#NUM!    \t\t6\n"
"\t#N/A     \t\t7\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"ERROR.TYPE(NA()) equals 7.\n"
"\n"
"@SEEALSO=ISERROR"
msgstr ""
"@FUNCTION=ERROR.TYPE\n"
"@SYNTAX=ERROR.TYPE(valor)\n"
"@DESCRIPTION=ERROR.TYPE devuelve un número de error que corresponde al valor "
"de error dado. Los números de errores según el valor de error son:\n"
"\n"
"\t#DIV/0! \t\t2\n"
"\t#VALOR! \t\t3\n"
"\t#REF! \t\t4\n"
"\t#NOMBRE? \t5\n"
"\t#NUM! \t\t6\n"
"\t#N/D! \t\t7\n"
"\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"ERROR.TYPE(NA()) es igual a 7.\n"
"\n"
"@SEEALSO=ISERROR"

#: ../plugins/fn-info/functions.c:1552
msgid ""
"@FUNCTION=NA\n"
"@SYNTAX=NA()\n"
"@DESCRIPTION=NA returns the error value #N/A.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"NA() equals #N/A error.\n"
"\n"
"@SEEALSO=ISNA"
msgstr ""
"@FUNCTION=NA\n"
"@SYNTAX=NA()\n"
"@DESCRIPTION=NA devuelve el valor de error #N/D. \n"
"\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"NA() es igual al error #N/D.\n"
"\n"
"@SEEALSO=ISNA"

#: ../plugins/fn-info/functions.c:1577
msgid ""
"@FUNCTION=ERROR\n"
"@SYNTAX=ERROR(text)\n"
"@DESCRIPTION=ERROR return the specified error.\n"
"\n"
"@EXAMPLES=\n"
"ERROR(\"#OWN ERROR\").\n"
"\n"
"@SEEALSO=ISERROR"
msgstr ""
"@FUNCTION=ERROR\n"
"@SYNTAX=ERROR(texto)\n"
"@DESCRIPTION=Devuelve el error especificado en @texto.\n"
"\n"
"@EXAMPLES=\n"
"ERROR(\"#ERROR PROPIO\").\n"
"\n"
"@SEEALSO=ISERRO"

#: ../plugins/fn-info/functions.c:1601
msgid ""
"@FUNCTION=ISBLANK\n"
"@SYNTAX=ISBLANK(value)\n"
"@DESCRIPTION=ISBLANK returns TRUE if the value is blank.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"ISBLANK(A1).\n"
"\n"
"@SEEALSO="
msgstr ""
"@FUNCTION=ISBLANK\n"
"@SYNTAX=ISBLANK(valor)\n"
"@DESCRIPTION=Devuelve VERDADERO si @valor está vacío. \n"
"\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"ISBLANK(A1).\n"
"\n"
"@SEEALSO="

#: ../plugins/fn-info/functions.c:1626
msgid ""
"@FUNCTION=ISEVEN\n"
"@SYNTAX=ISEVEN(value)\n"
"@DESCRIPTION=ISEVEN returns TRUE if the number is even.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"ISEVEN(4) equals TRUE.\n"
"\n"
"@SEEALSO=ISODD"
msgstr ""
"@FUNCTION=ISEVEN\n"
"@SYNTAX=ISEVEN(valor)\n"
"@DESCRIPTION=Devuelve VERDADERO si el @valor es par. \n"
"\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"ISEVEN(4) es igual a VERDADERO.\n"
"\n"
"@SEEALSO=ISODD"

#: ../plugins/fn-info/functions.c:1655
msgid ""
"@FUNCTION=ISLOGICAL\n"
"@SYNTAX=ISLOGICAL(value)\n"
"@DESCRIPTION=ISLOGICAL returns TRUE if the value is a logical value.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"ISLOGICAL(A1).\n"
"\n"
"@SEEALSO="
msgstr ""
"@FUNCTION=ISLOGICAL\n"
"@SYNTAX=ISLOGICAL(valor)\n"
"@DESCRIPTION=Devuelve VERDADERO si @valor es un valor lógico. \n"
"\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"ISLOGICAL(A1).\n"
"\n"
"@SEEALSO="

#: ../plugins/fn-info/functions.c:1680
msgid ""
"@FUNCTION=ISNONTEXT\n"
"@SYNTAX=ISNONTEXT(value)\n"
"@DESCRIPTION=ISNONTEXT Returns TRUE if the value is not text.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"ISNONTEXT(\"text\") equals FALSE.\n"
"\n"
"@SEEALSO=ISTEXT"
msgstr ""
"@FUNCTION=ISNONTEXT\n"
"@SYNTAX=ISNONTEXT(valor)\n"
"@DESCRIPTION=Devuelve VERDADERO si @valor no es una cadena de texto. \n"
"\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"ISNONTEXT(\"texto\") es igual a FALSO.\n"
"\n"
"@SEEALSO=ISTEXT"

#: ../plugins/fn-info/functions.c:1705
msgid ""
"@FUNCTION=ISNUMBER\n"
"@SYNTAX=ISNUMBER(value)\n"
"@DESCRIPTION=ISNUMBER returns TRUE if the value is a number.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"ISNUMBER(\"text\") equals FALSE.\n"
"\n"
"@SEEALSO="
msgstr ""
"@FUNCTION=ISNUMBER\n"
"@SYNTAX=ISNUMBER(valor)\n"
"@DESCRIPTION=Devuelve VERDADERO si @valor es un número.\n"
"\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"ISNUMBER(\"texto\") es igual a FALSO.\n"
"\n"
"@SEEALSO="

#: ../plugins/fn-info/functions.c:1730
msgid ""
"@FUNCTION=ISODD\n"
"@SYNTAX=ISODD(value)\n"
"@DESCRIPTION=ISODD returns TRUE if the number is odd.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"ISODD(3) equals TRUE.\n"
"\n"
"@SEEALSO=ISEVEN"
msgstr ""
"@FUNCTION=ISODD\n"
"@SYNTAX=ISODD(valor)\n"
"@DESCRIPTION=Devuelve VERDADERO si @valor es un número impar. \n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"ISODD(3) es igual a VERDADERO.\n"
"\n"
"@SEEALSO=ISEVEN"

#: ../plugins/fn-info/functions.c:1759
msgid ""
"@FUNCTION=ISREF\n"
"@SYNTAX=ISREF(value)\n"
"@DESCRIPTION=ISREF returns TRUE if the value is a reference.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"ISREF(A1) equals TRUE.\n"
"\n"
"@SEEALSO="
msgstr ""
"@FUNCTION=ISREF\n"
"@SYNTAX=ISREF(valor)\n"
"@DESCRIPTION=Devuelve VERDADERO si @valor es una referencia.\n"
"\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"ISREF(A1) es igual a VERDADERO.\n"
"\n"
"@SEEALSO="

#: ../plugins/fn-info/functions.c:1788
msgid ""
"@FUNCTION=ISTEXT\n"
"@SYNTAX=ISTEXT(value)\n"
"@DESCRIPTION=ISTEXT returns TRUE if the value is text.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"ISTEXT(\"text\") equals TRUE.\n"
"\n"
"@SEEALSO=ISNONTEXT"
msgstr ""
"@FUNCTION=ISTEXT\n"
"@SYNTAX=ISTEXT(valor)\n"
"@DESCRIPTION=Devuelve VERDADERO si @valor es una cadena de texto. \n"
"\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"ISTEXT(\"texto\") es igual a VERDADERO.\n"
"\n"
"@SEEALSO=ISNONTEXT"

#: ../plugins/fn-info/functions.c:1813
msgid ""
"@FUNCTION=N\n"
"@SYNTAX=N(value)\n"
"@DESCRIPTION=N returns a value converted to a number.  Strings containing "
"text are converted to the zero value.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"N(\"42\") equals 42.\n"
"\n"
"@SEEALSO="
msgstr ""
"@FUNCTION=N\n"
"@SYNTAX=N(valor)\n"
"@DESCRIPTION=Devuelve @valor convertido en un número. Las cadenas que "
"contienen texto son convertidas al valor cero.\n"
"\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"N(\"42\") es igual a 42.\n"
"\n"
"@SEEALSO="

#: ../plugins/fn-info/functions.c:1853
msgid ""
"@FUNCTION=TYPE\n"
"@SYNTAX=TYPE(value)\n"
"@DESCRIPTION=TYPE returns a number indicating the data type of a value.\n"
"\n"
"1  == number\n"
"2  == text\n"
"4  == boolean\n"
"16 == error\n"
"64 == array\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"TYPE(3) equals 1.\n"
"TYPE(\"text\") equals 2.\n"
"\n"
"@SEEALSO="
msgstr ""
"@FUNCTION=TYPE\n"
"@SYNTAX=TYPE(valor)\n"
"@DESCRIPTION=Devuelve un número que indica el tipo de dato de @valor.\n"
"\n"
"1 == numero\n"
"2 == texto\n"
"4 == booleano\n"
"16 == error\n"
"64 == array\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"TYPE(3) es igual a 1.\n"
"TYPE(\"texto\") es igual a 2.\n"
"\n"
"@SEEALSO="

#: ../plugins/fn-info/functions.c:1902
msgid ""
"@FUNCTION=GETENV\n"
"@SYNTAX=GETENV(string)\n"
"@DESCRIPTION=GETENV retrieves a value from the execution environment.\n"
"\n"
"* If the variable specified by @string does not exist, #N/A! will be "
"returned.  Note, that variable names are case sensitive.\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO="
msgstr ""
"@FUNCTION=GETENV\n"
"@SYNTAX=GETENV(cadena)\n"
"@DESCRIPTION=GETENV recupera un valor del entorno de ejecución.\n"
"\n"
"* Si la variable especificada por @cadena no existe, se devuelve #N/D!. Note "
"que los nombres de variable son sensibles a mayúsculas.\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO="

#: ../plugins/fn-logical/functions.c:45
msgid ""
"@FUNCTION=AND\n"
"@SYNTAX=AND(b1, b2, ...)\n"
"@DESCRIPTION=AND implements the logical AND function: the result is TRUE if "
"all of the expressions evaluate to TRUE, otherwise it returns FALSE.\n"
"\n"
"@b1 through @bN are expressions that should evaluate to TRUE or FALSE.  If "
"an integer or floating point value is provided, zero is considered FALSE and "
"anything else is TRUE.\n"
"\n"
"* If the values contain strings or empty cells those values are ignored.\n"
"* If no logical values are provided, then the error #VALUE! is returned.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"AND(TRUE,TRUE) equals TRUE.\n"
"AND(TRUE,FALSE) equals FALSE.\n"
"\n"
"Let us assume that A1 holds number five and A2 number one.  Then\n"
"AND(A1>3,A2<2) equals TRUE.\n"
"\n"
"@SEEALSO=OR, NOT"
msgstr ""
"@FUNCTION=AND\n"
"@SYNTAX=AND(b1, b2, …)\n"
"@DESCRIPTION=AND implementa la función lógica AND. El resultado es VERDADERO "
"si todas las expresiones se evalúan a VERDADERO; en otro caso, devuelve "
"FALSO.\n"
"\n"
"@b1 .. @bN son expresiones que se deberían evaluar a VERDADERO o FALSO, Si "
"se proporciona un entero o un valor en coma flotante, el cero se considera "
"FALSO y cualquier otra cosa es VERDADERO.\n"
"\n"
"* Si los valores contienen cadenas o celdas vacías, esos valores se "
"ignoran.\n"
"* Si no se proporcionan valores lógicos, entonces se devuelve el error "
"#VALOR!.\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"AND(VERDADERO,VERDADERO) igual a VERDADERO\n"
"AND(VERDADERO,FALSO) igual a FALSO\n"
"\n"
"Asumamos que A1 alberga el número cinco y A2 el número uno. Entonces\n"
"AND(A1>3,A2<2) igual a VERDADERO.\n"
"\n"
"@SEEALSO=OR, NOT"

#: ../plugins/fn-logical/functions.c:112
msgid ""
"@FUNCTION=NOT\n"
"@SYNTAX=NOT(number)\n"
"@DESCRIPTION=NOT implements the logical NOT function: the result is TRUE if "
"the @number is zero;  otherwise the result is FALSE.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"NOT(0) equals TRUE.\n"
"NOT(TRUE) equals FALSE.\n"
"\n"
"@SEEALSO=AND, OR"
msgstr ""
"@FUNCTION=NOT\n"
"@SYNTAX=NOT(número)\n"
"@DESCRIPTION=Implementa la función lógica NOT: el resultado es VERDADERO si "
"@número es cero; si no el resultado es FALSO. \n"
"\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"NOT(0) es igual a VERDADERO.\n"
"NOT(VERDADERO) es igual a FALSO.\n"
"\n"
"@SEEALSO=AND, OR"

#: ../plugins/fn-logical/functions.c:143
msgid ""
"@FUNCTION=OR\n"
"@SYNTAX=OR(b1, b2, ...)\n"
"@DESCRIPTION=OR implements the logical OR function: the result is TRUE if "
"any of the values evaluated to TRUE.\n"
"\n"
"@b1 through @bN are expressions that should evaluate to TRUE or FALSE. If an "
"integer or floating point value is provided, zero is considered FALSE and "
"anything else is TRUE.\n"
"\n"
"* If the values contain strings or empty cells those values are ignored.\n"
"* If no logical values are provided, then the error #VALUE! is returned.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"OR(TRUE,FALSE) equals TRUE.\n"
"OR(3>4,4<3) equals FALSE.\n"
"\n"
"@SEEALSO=AND, NOT"
msgstr ""
"@FUNCTION=OR\n"
"@SYNTAX=OR(b1, b2, …)\n"
"@DESCRIPTION=OR implementa la función lógica O: el resultado es VERDADERO si "
"cualquiera de los valores evaluados es VERDADERO.\n"
"\n"
"@b1 .. @bN son expresiones lógicas que se deberían evaluar a VERDADERO o "
"FALSO, Si se proporciona un entero o un valor en coma flotante, el cero se "
"considera FALSO y cualquier otra cosa es VERDADERO.\n"
"\n"
"* Si los valores contienen cadenas o celdas vacías, esos valores se "
"ignoran.\n"
"* Si no se proporcionan valores lógicos, entonces se devuelve el error "
"#VALOR!.\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"OR(VERDADERO,FALSO) igual a VERDADERO.\n"
"OR(3>4,4<3) igual a FALSO.\n"
"\n"
"@SEEALSO=AND, NOT"

#: ../plugins/fn-logical/functions.c:207
msgid ""
"@FUNCTION=XOR\n"
"@SYNTAX=XOR(b1, b2, ...)\n"
"@DESCRIPTION=XOR implements the logical exclusive OR function: the result is "
"TRUE if an odd number of the values evaluated to TRUE.\n"
"\n"
"@b1 through @bN are expressions that should evaluate to TRUE or FALSE. If an "
"integer or floating point value is provided, zero is considered FALSE and "
"anything else is TRUE.\n"
"\n"
"* If the values contain strings or empty cells those values are ignored.\n"
"* If no logical values are provided, then the error #VALUE! is returned.\n"
"@EXAMPLES=\n"
"XOR(TRUE,FALSE) equals TRUE.\n"
"XOR(3>4,4<3) equals FALSE.\n"
"\n"
"@SEEALSO=OR, AND, NOT"
msgstr ""
"@FUNCTION=XOR\n"
"@SYNTAX=XOR(b1, b2, …)\n"
"@DESCRIPTION=XOR implementa la función ORexclusiva: el resultado es "
"VERDADERO si hay un número impar de valores evaluados a VERDADERO.\n"
"\n"
"@b1 .. @bN son expresiones que se deberían evaluar a VERDADERO o FALSO, Si "
"se proporciona un entero o un valor en coma flotante, el cero se considera "
"FALSO y cualquier otra cosa es VERDADERO.\n"
"\n"
"* Si los valores contienen cadenas o celdas vacías, esos valores se "
"ignoran. \n"
"* Si no se proporcionan valores lógicos, entonces se devuelve el error "
"#VALOR!\n"
"\n"
"@EXAMPLES=\n"
"XOR(VERDADERO,FALSO) igual a VERDADERO.\n"
"XOR(3>4,4<3) igual a FALSO.\n"
"\n"
"@SEEALSO=OR, AND, NOT"

#: ../plugins/fn-logical/functions.c:269
msgid ""
"@FUNCTION=IF\n"
"@SYNTAX=IF(condition[,if-true,if-false])\n"
"@DESCRIPTION=IF function can be used to evaluate conditionally other "
"expressions. IF evaluates @condition.  If @condition returns a non-zero "
"value the result of the IF expression is the @if-true expression, otherwise "
"IF evaluates to the value of @if-false.\n"
"\n"
"* If omitted @if-true defaults to TRUE and @if-false to FALSE.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"IF(FALSE,TRUE,FALSE) equals FALSE.\n"
"\n"
"@SEEALSO="
msgstr ""
"@FUNCTION=IF\n"
"@SYNTAX=IF(condición[,si-cierto,si-falso])\n"
"@DESCRIPTION=Use la sentencia IF para evaluar condicionalmente otras "
"expresiones. IF evalúa la @condición. Si la @condición devuelve un valor "
"distinto de cero, el resultado de la expresión IF es la expresión @si-"
"cierto; en otro caso, IF evalúa al valor de @si-falso. \n"
"\n"
"* Si se omite @si-cierto por omisión se toma VERDADERO y si se omite @si-"
"falso se presupone FALSO.\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"IF(FALSO,VERDADERO,FALSO) igual a FALSO.\n"
"\n"
"@SEEALSO="

#: ../plugins/fn-logical/functions.c:309
msgid "IFERROR:Test for error."
msgstr "IFERROR: comprobación de error."

#: ../plugins/fn-logical/functions.c:310
msgid "x:value to test for error."
msgstr "x: valor con el que probar el error."

#: ../plugins/fn-logical/functions.c:311
msgid "y:alternate value."
msgstr "y: valor alternativo."

#: ../plugins/fn-logical/functions.c:312
msgid ""
"This function returns the first value, unless that is an error, in which "
"case it returns the second."
msgstr ""
"Esta función devuelve el primer valor, a no ser que sea un error, en cuyo "
"caso devuelve el segundo."

#: ../plugins/fn-logical/functions.c:327
msgid ""
"@FUNCTION=TRUE\n"
"@SYNTAX=TRUE()\n"
"@DESCRIPTION=TRUE returns boolean value true.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"TRUE() equals TRUE.\n"
"\n"
"@SEEALSO=FALSE"
msgstr ""
"@FUNCTION=VERDADERO\n"
"@SYNTAX=VERDADERO()\n"
"@DESCRIPTION=Devuelve el valor lógico verdad.\n"
"\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"VERDADERO() es igual a VERDADERO.\n"
"\n"
"@SEEALSO=FALSO"

#: ../plugins/fn-logical/functions.c:352
msgid ""
"@FUNCTION=FALSE\n"
"@SYNTAX=FALSE()\n"
"@DESCRIPTION=FALSE returns boolean value false.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"FALSE() equals FALSE.\n"
"\n"
"@SEEALSO=TRUE"
msgstr ""
"@FUNCTION=FALSO\n"
"@SYNTAX=FALSO()\n"
"@DESCRIPTION=Devuelve el valor lógico falso.\n"
"\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"FALSO() es igual a FALSO.\n"
"\n"
"@SEEALSO=VERDADERO"

#: ../plugins/fn-lookup/functions.c:490
msgid ""
"@FUNCTION=ADDRESS\n"
"@SYNTAX=ADDRESS(row_num,col_num[,abs_num,a1,text])\n"
"@DESCRIPTION=ADDRESS returns a cell address as text for specified row and "
"column numbers.\n"
"\n"
"@a1 is a logical value that specifies the reference style.  If @a1 is TRUE "
"or omitted, ADDRESS returns an A1-style reference, i.e. $D$4.  Otherwise "
"ADDRESS returns an R1C1-style reference, i.e. R4C4.\n"
"\n"
"@text specifies the name of the worksheet to be used as the external "
"reference.\n"
"\n"
"* If @abs_num is 1 or omitted, ADDRESS returns absolute reference.\n"
"* If @abs_num is 2 ADDRESS returns absolute row and relative column.\n"
"* If @abs_num is 3 ADDRESS returns relative row and absolute column.\n"
"* If @abs_num is 4 ADDRESS returns relative reference.\n"
"* If @abs_num is greater than 4 ADDRESS returns #VALUE! error.\n"
"* If @row_num or @col_num is less than one, ADDRESS returns #VALUE! error.\n"
"\n"
"@EXAMPLES=\n"
"ADDRESS(5,4) equals \"$D$5\".\n"
"ADDRESS(5,4,4) equals \"D5\".\n"
"ADDRESS(5,4,3,FALSE) equals \"R[5]C4\".\n"
"\n"
"@SEEALSO=COLUMNNUMBER"
msgstr ""
"@FUNCTION=ADDRESS\n"
"@SYNTAX=ADDRESS(num_fila,num_col[,num_bas,a1,texto])\n"
"@DESCRIPTION=ADDRESS devuelve una dirección de celda como texto para los "
"números de fila y columna especificados.\n"
"\n"
"\n"
"@a1 es un valor lógico que especifica el estilo de referencia. Si @a1 es "
"VERDADERO o se omite, ADDRESS devuelve una referencia de estilo A1, por "
"ejemplo $D$4. En otro caso, ADDRESS devuelve una referencia de estilo R1C1, "
"por ejemplo R4C4. \n"
"\n"
"@texto especifica el nombre de la hoja de trabajo a usar como referencia "
"externa.\n"
"\n"
"* Si @num_abs es 1 o se omite, ADDRESS devuelve la referencia absoluta.\n"
"* Si @num_abs es 2, ADDRESS devuelve la fila absoluta y la columna "
"relativa.\n"
"* Si @num_abs es 3, ADDRESS devuelve la fila relativa y la columna "
"absoluta.\n"
"* Si @num_abs es 4, ADDRESS devuelve la referencia relativa.\n"
"* Si @num_abs es mayor que 4, ADDRESS devuelve el error #VALOR!. \n"
"* Si @num_fila o @num_col es menor que uno, ADDRESS devuelve el error "
"#VALOR!.\n"
"\n"
"@EXAMPLES=\n"
"ADDRESS(5,4) igual a \"$D$5\".\n"
"ADDRESS(5,4,4) igual a \"D5\".\n"
"ADDRESS(5,4,3,FALSO) igual a \"R[5]C4\".\n"
"\n"
"@SEEALSO=COLUMNNUMBER"

#: ../plugins/fn-lookup/functions.c:592
msgid ""
"@FUNCTION=AREAS\n"
"@SYNTAX=AREAS(reference)\n"
"@DESCRIPTION=AREAS returns the number of areas in @reference. \n"
"\n"
"@EXAMPLES=\n"
"AREAS((A1,B2,C3)) equals 3.\n"
"\n"
"@SEEALSO=ADDRESS,INDEX,INDIRECT,OFFSET"
msgstr ""
"@FUNCTION=AREAS\n"
"@SYNTAX=AREAS(referencia)\n"
"@DESCRIPTION=AREAS devuelve el número de áreas en @referencia. .\n"
"\n"
"@EXAMPLES=\n"
"AREAS((A1,B2,C3)) es igual a .\n"
"\n"
"@SEEALSO=ADDRESS,INDEX,INDIRECT,OFFSET"

#: ../plugins/fn-lookup/functions.c:670
msgid ""
"@FUNCTION=CHOOSE\n"
"@SYNTAX=CHOOSE(index[,value1][,value2]...)\n"
"@DESCRIPTION=CHOOSE returns the value of index @index. @index is rounded to "
"an integer if it is not.\n"
"\n"
"* If @index < 1 or @index > number of values, CHOOSE returns #VALUE! error.\n"
"\n"
"@EXAMPLES=\n"
"CHOOSE(3,\"Apple\",\"Orange\",\"Grape\",\"Perry\") equals \"Grape\".\n"
"\n"
"@SEEALSO=IF"
msgstr ""
"@FUNCTION=CHOOSE\n"
"@SYNTAX=CHOOSE(índice[,valor1][,valor2]…)\n"
"@DESCRIPTION=CHOOSE devuelve el valor del índice @índice. @índice se "
"redondea a un entero si no lo es.\n"
"\n"
"* Si @índice < 1 ó @índice > número de valores, CHOOSE devuelve el error "
"#VALOR!.\n"
"\n"
"@EXAMPLES=\n"
"CHOOSE(3,\"Manzana\",\"Naranja\",\"Uva\",\"Melocotón\") igual a \"Uva\".\n"
"\n"
"@SEEALSO=IF"

#: ../plugins/fn-lookup/functions.c:724
msgid ""
"@FUNCTION=VLOOKUP\n"
"@SYNTAX=VLOOKUP(value,range,column[,approximate,as_index])\n"
"@DESCRIPTION=VLOOKUP function finds the row in range that has a first column "
"similar to @value.  If @approximate is not true it finds the row with an "
"exact equivalence.  If @approximate is true, then the values must be sorted "
"in order of ascending value for correct function; in this case it finds the "
"row with value less than @value.  It returns the value in the row found at a "
"1-based offset in @column columns into the @range.  @as_index returns the 0-"
"based offset that matched rather than the value.\n"
"\n"
"* VLOOKUP returns #NUM! if @column < 0.\n"
"* VLOOKUP returns #REF! if @column falls outside @range.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=HLOOKUP"
msgstr ""
"@FUNCTION=VLOOKUP\n"
"@SYNTAX=VLOOKUP(valor,rango,columna[,aproximado,como_índice])\n"
"@DESCRIPTION=La función VLOOKUP busca la fila en un rango que tiene una "
"primera columna similar al valor. Si @aproximado no es cierto, busca la fila "
"con una equivalencia exacta. Si @aproximado es cierto, entonces los valores "
"se deben ordenar ascendentemente para un funcionamiento correcto: en este "
"caso, busca la fila con valor menor que @valor. Devuelve el valor en la fila "
"buscando en con un desplazamiento de base 1 de @columna columnas en el "
"@rango. @como_índice devuelve el desplazamiento de base 0 que coincida con "
"el valor\n"
"\n"
"* VLOOKUP devuelve #NÚM! si @columna < 0. \n"
"* VLOOKUP devuelve #REF! si @columna cae fuera del @rango.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=HLOOKUP"

#: ../plugins/fn-lookup/functions.c:785
msgid ""
"@FUNCTION=HLOOKUP\n"
"@SYNTAX=HLOOKUP(value,range,row[,approximate,as_index])\n"
"@DESCRIPTION=HLOOKUP function finds the col in range that has a first row "
"cell similar to @value.  If @approximate is not true it finds the col with "
"an exact equivalence.  If @approximate is true, then the values must be "
"sorted in order of ascending value for correct function; in this case it "
"finds the col with value less than @value it returns the value in the col "
"found at a 1-based offset in @row rows into the @range.  @as_index returns "
"the 0-based offset that matched rather than the value.\n"
"\n"
"* HLOOKUP returns #NUM! if @row < 0.\n"
"* HLOOKUP returns #REF! if @row falls outside @range.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=VLOOKUP"
msgstr ""
"@FUNCTION=HLOOKUP\n"
"@SYNTAX=HLOOKUP(valor,rango,fila[,aproximado,como_índice])\n"
"@DESCRIPTION=La función HLOOKUP busca la columna del rango que tiene una "
"celda en la primera fila similar a @valor. Si @aproximado no es verdadero, "
"busca la columna con una equivalencia exacta. Si @aproximado es cierto, los "
"valores deben estar ordenados de forma ascendente para un funcionamiento "
"correcto; en este caso busca la columna con valor menor que @valor que "
"devuelve el valor de la columna encontrado con un desplazamiento 1 en @fila "
"@filas del @rango. @como_índice devuelve el desplazamiento que coincide con "
"el valor\n"
"\n"
"* HLOOKUP devuelve #NUM si @fila < 0.\n"
"* HLOOKUP devuelve #REF! si @fila cae fuera del @rango.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=VLOOKUP"

#: ../plugins/fn-lookup/functions.c:847
msgid ""
"@FUNCTION=LOOKUP\n"
"@SYNTAX=LOOKUP(value,vector1[,vector2])\n"
"@DESCRIPTION=LOOKUP function finds the row index of @value in @vector1 and "
"returns the contents of @vector2 at that row index. Alternatively a single "
"array can be used for @vector1. If the area is longer than it is wide then "
"the sense of the search is rotated. \n"
"\n"
"* If LOOKUP can't find @value it uses the largest value less than @value.\n"
"* The data must be sorted.\n"
"* If @value is smaller than the first value it returns #N/A.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=VLOOKUP,HLOOKUP"
msgstr ""
"@FUNCTION=LOOKUP\n"
"@SYNTAX=LOOKUP(valor,array1,array2)\n"
"@DESCRIPTION=La función LOOKUP busca el índice de la fila de «valor» en "
"@array1 y devuelve los contenidos del valor2 en ese índice de fila. Si el "
"área es mayor que su ancho se rota el sentido de la búsqueda. "
"Alternativamente se puede usar un array simple.\n"
"\n"
"* Si LOOKUP no encuentra el @valor usa el siguiente valor más grande menor "
"que el valor.\n"
"* Los datos deben estar ordenados.\n"
"* Si el @valor es menor que el primer valor devuelve #N/D\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=VLOOKUP,HLOOKUP"

#: ../plugins/fn-lookup/functions.c:913
msgid ""
"@FUNCTION=MATCH\n"
"@SYNTAX=MATCH(seek,vector[,type])\n"
"@DESCRIPTION=MATCH function finds the row index of @seek in @vector and "
"returns it.\n"
"\n"
"If the area is longer than it is wide then the sense of the search is "
"rotated. Alternatively a single array can be used.\n"
"\n"
"* The @type parameter, which defaults to +1, controls the search:\n"
"* If @type = 1, MATCH finds largest value <= @seek.\n"
"* If @type = 0, MATCH finds first value == @seek.\n"
"* If @type = -1, MATCH finds smallest value >= @seek.\n"
"* For @type = 0, the data can be in any order.  * For @type = -1 and @type = "
"+1, the data must be sorted.  (And in these cases, MATCH uses a binary "
"search to locate the index.)\n"
"* If @seek could not be found, #N/A is returned.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=LOOKUP"
msgstr ""
"@FUNCTION=MATCH\n"
"@SYNTAX=MATCH(buscar,vector[,tipo])\n"
"@DESCRIPTION=La función MATCH busca el índice de la fila del @objetivo en el "
"@vector y lo devuelve.\n"
"\n"
"Si el área es mayor que su ancho entonces se rota el sentido de la búsqueda. "
"Alternativamente se puede usar un array simple.\n"
"\n"
"* El parámetro @tipo, que por omisión vale +1, controla la búsqueda:\n"
"* Si @tipo = 1, busca el valor más grande <= @objetivo.\n"
"* Si @tipo = 0, busca el primer valor == @objetivo.\n"
"* Si @tipo = -1, busca el valor más pequeño >= @objetivo.\n"
"* Para el tipo 0, los datos pueden estar ordenados de cualquier forma.\n"
"* Para los tipos -1 y +1, los datos deben estar ordenados. (Y en este caso, "
"MATCH usa una búsqueda binaria para ubicar el índice.)\n"
"* Si el @objetivo no se encuentra, se devuelve el error #N/D.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=LOOKUP"

#: ../plugins/fn-lookup/functions.c:971
msgid ""
"@FUNCTION=INDIRECT\n"
"@SYNTAX=INDIRECT(ref_text[,format])\n"
"@DESCRIPTION=INDIRECT function returns the contents of the cell pointed to "
"by the @ref_text string. The string specifies a single cell reference the "
"format of which is either A1 or R1C1 style. The boolean @format controls how "
"@ref_text is to be interpreted: TRUE (the default) for A1 style and FALSE "
"for R1C1 style.\n"
"\n"
"* If @ref_text is not a valid reference in the style controlled by @format, "
"returns #REF! \n"
"@EXAMPLES=\n"
"If A1 contains 3.14 and A2 contains \"A1\", then\n"
"INDIRECT(A2) equals 3.14.\n"
"\n"
"If B1 contains 23 and A1 contains \"R1C2\", then\n"
"INDIRECT(A1,FALSE) equals 23.\n"
"@SEEALSO=AREAS,INDEX,CELL"
msgstr ""
"@FUNCTION=INDIRECT\n"
"@SYNTAX=INDIRECT(texto_ref[,formato])\n"
"@DESCRIPTION=La función INDIRECT devuelve los contenidos de la celda "
"apuntada por la cadena @texto_ref. La cadena especifica referencia a una "
"celda simple, el formato que es del estilo A1 o R1C1. El estilo lo pone el "
"@formato booleano, lo que por omisión es el anterior.\n"
"\n"
"* Si @texto_ref no es una referencia válida, devuelve #REF!\n"
"@EXAMPLES=\n"
"Si A1 contiene 3.14 y A2 contiene A1, entonces\n"
"INDIRECT(A2) es igual a 3.14.\n"
"\n"
"Si B1 contiene 23 y A1 contiene R1C2, tentones\n"
"INDIRECT(A1,FALSE) es igual a 23.\n"
"@SEEALSO=AREAS,INDEX,CELL"

#: ../plugins/fn-lookup/functions.c:1023
msgid ""
"@FUNCTION=INDEX\n"
"@SYNTAX=INDEX(array[,row, col, area])\n"
"@DESCRIPTION=INDEX gives a reference to a cell in the given @array.The cell "
"is pointed out by @row and @col, which count the rows and columns in the "
"array.\n"
"\n"
"* If @row and @col are omitted the are assumed to be 1.\n"
"* If the reference falls outside the range of the @array, INDEX returns a "
"#REF! error.\n"
"\n"
"@EXAMPLES=Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, "
"17.3, 21.3, 25.9, and 40.1. Then INDEX(A1:A5,4,1,1) equals 25.9\n"
"\n"
"@SEEALSO="
msgstr ""
"@FUNCTION=INDEX\n"
"@SYNTAX=INDEX(array,[fila, col, área])\n"
"@DESCRIPTION=INDEX da una referencia a una celda en el @array dado. La celda "
"es señalada por @fila y @col, que cuenta las filas y las columnas en el "
"array.\n"
"\n"
"* Si @fila y @col se omiten se asume que valen 1. @área tiene que ser 1\n"
"* Si la referencia cae fuera del rango del @array, INDEX devuelve un error "
"#REF!.\n"
"\n"
"@EXAMPLES=Supongamos que las celdas A1, A2, …, A5 contienen los números "
"11.4, 17.3,21.3, 25.9, y 40.1. Entonces INDEX(A1:A5,4,1,1) igual a 25.9\n"
"\n"
"@SEEALSO="

#: ../plugins/fn-lookup/functions.c:1111
msgid "COLUMN:vector of column numbers."
msgstr "COLUMN: vector de números columna."

#: ../plugins/fn-lookup/functions.c:1112 ../plugins/fn-lookup/functions.c:1291
msgid "[reference]."
msgstr "[referencia]."

#: ../plugins/fn-lookup/functions.c:1114
msgid ""
"COLUMN function returns a Nx1 array containing the series of integers from "
"the first column to the last column of @reference.\n"
"* @reference defaults to the position of the current expression.\n"
"\n"
"* If @reference is neither an array nor a reference nor a range, returns "
"#VALUE! error.\n"
msgstr ""
"La función COLUMN devuelve un vector de Nx1 que contiene la serie de enteros "
"desde la primera columna a la última columna de @reference.\n"
"* @reference es la posición de la expresión actual.\n"
"defaults to the position of the current expression.\n"
"\n"
"* Si @reference no es un vector ni una referencia ni un rango, devuelve el "
"error #VALUE!\n"

#: ../plugins/fn-lookup/functions.c:1121
msgid "COLUMN(A1:C4) equals {1,2,3}"
msgstr "COLUMN(A1:C4) equivale a {1,2,3}"

#: ../plugins/fn-lookup/functions.c:1122
msgid "COLUMN(A:C) equals {1,2,3}"
msgstr "COLUMN(A:C) equivale a {1,2,3}"

#: ../plugins/fn-lookup/functions.c:1123
msgid "COLUMN() in G13 equals 7."
msgstr "COLUMN() en G13 equivale a 7."

#: ../plugins/fn-lookup/functions.c:1164
msgid ""
"@FUNCTION=COLUMNNUMBER\n"
"@SYNTAX=COLUMNNUMBER(name)\n"
"@DESCRIPTION=COLUMNNUMBER function returns an integer corresponding to the "
"column name supplied as a string.\n"
"\n"
"* If @name is invalid, COLUMNNUMBER returns the #VALUE! error.\n"
"\n"
"@EXAMPLES=\n"
"COLUMNNUMBER(\"E\") equals 5.\n"
"\n"
"@SEEALSO=ADDRESS"
msgstr ""
"@FUNCTION=COLUMNNUMBER\n"
"@SYNTAX=COLUMNNUMBER(nombre)\n"
"@DESCRIPTION=La función COLUMNNUMBER devuelve un entero correspondiente al "
"nombre de columna suministrado como una cadena.\n"
"\n"
"*Si @nombre es inválido, COLUMNNUMBER devuelve un error #VALOR!.\n"
"\n"
"@EXAMPLES=\n"
"COLUMNNUMBERS(\"E\") es igual a 5.\n"
"\n"
"@SEEALSO=ADDRESS"

#: ../plugins/fn-lookup/functions.c:1199
msgid ""
"@FUNCTION=COLUMNS\n"
"@SYNTAX=COLUMNS(reference)\n"
"@DESCRIPTION=COLUMNS function returns the number of columns in area or array "
"reference.\n"
"\n"
"* If @reference is neither an array nor a reference nor a range, COLUMNS "
"returns #VALUE! error.\n"
"\n"
"@EXAMPLES=\n"
"COLUMNS(H2:J3) equals 3.\n"
"\n"
"@SEEALSO=COLUMN,ROW,ROWS"
msgstr ""
"@FUNCTION=COLUMNS\n"
"@SYNTAX=COLUMNS(referencia)\n"
"@DESCRIPTION=La función COLUMNS devuelve la cantidad de columnas en el área "
"o array @referencia.\n"
"\n"
"* Si @referencia no es ni un array, ni una referencia, ni un rango; la "
"función devuelve el error #VALOR!.\n"
"\n"
"@EXAMPLES=\n"
"COLUMNS(H2:J3) es igual a 3.\n"
"\n"
"@SEEALSO=COLUMN,ROW,ROWS"

#: ../plugins/fn-lookup/functions.c:1227
msgid ""
"@FUNCTION=OFFSET\n"
"@SYNTAX=OFFSET(range,row,col[,height[,width]])\n"
"@DESCRIPTION=OFFSET function returns a cell range. The cell range starts at "
"offset (@row,@col) from @range, and is of height @height and width @width.\n"
"\n"
"* If @range is neither a reference nor a range, OFFSET returns #VALUE!.\n"
"* If either @height or @width is omitted, the height or width of the "
"reference is used.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=COLUMN,COLUMNS,ROWS,INDEX,INDIRECT,ADDRESS"
msgstr ""
"@FUNCTION=OFFSET\n"
"@SYNTAX=OFFSET(rango,fila,col,altura,anchura)\n"
"@DESCRIPTION=La función OFFSET devuelve un rango de celdas. El rango de "
"celdas se inicia en el desplazamiento (@fila,@col) desde @rango, y es de "
"altura @altura y de anchura @anchura.\n"
"\n"
"* Si el rango no es una referencia ni un rango, OFFSET devuelve #VALOR!\n"
"* Si cualquiera de @altura o @anchura se omite se usa la altura o anchura de "
"referencia.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=COLUMN,COLUMNS,ROWS,INDEX,INDIRECT,ADDRESS"

#: ../plugins/fn-lookup/functions.c:1290
msgid "ROW:vector of row numbers."
msgstr "ROW: vector de números fila."

#: ../plugins/fn-lookup/functions.c:1293
msgid ""
"ROW function returns a 1xN array containing the series of integers from the "
"first row to the last row of @reference.\n"
"* @reference defaults to the position of the current expression.\n"
"\n"
"* If @reference is neither an array nor a reference nor a range, returns "
"#VALUE! error.\n"
msgstr ""
"La función ROW devuelve un vector de 1xN que contiene la serie de enteros "
"desde la primera fila a la última fila de @reference.\n"
"* @reference es la posición de la expresión actual.\n"
"defaults to the position of the current expression.\n"
"\n"
"* Si @reference no es un vector ni una referencia ni un rango, devuelve el "
"error #VALUE!\n"

#: ../plugins/fn-lookup/functions.c:1300
msgid "ROW(A1:D3) equals {1;2;3}"
msgstr "ROW(A1:D3) equivale a {1;2;3}"

#: ../plugins/fn-lookup/functions.c:1301
msgid "ROW(1:3) equals {1;2;3}"
msgstr "ROW(1:3) equivale a {1;2;3}"

#: ../plugins/fn-lookup/functions.c:1302
msgid "ROW() in G13 equals 13."
msgstr "ROW() en G13 equivale a 13."

#: ../plugins/fn-lookup/functions.c:1343
msgid ""
"@FUNCTION=ROWS\n"
"@SYNTAX=ROWS(reference)\n"
"@DESCRIPTION=ROWS function returns the number of rows in area or array "
"reference.\n"
"\n"
"* If @reference is neither an array nor a reference nor a range, ROWS "
"returns #VALUE! error.\n"
"\n"
"@EXAMPLES=\n"
"ROWS(H7:I13) equals 7.\n"
"\n"
"@SEEALSO=COLUMN,COLUMNS,ROW"
msgstr ""
"@FUNCTION=ROWS\n"
"@SYNTAX=ROWS(referencia)\n"
"@DESCRIPTION=La función ROWS devuelve la cantidad de filas en el área o "
"array de @referencia.\n"
"\n"
"* Si @referencia no es ni un array, ni una referencia, ni un rango, ROWS "
"devuelve el error #VALOR!.\n"
"\n"
"@EXAMPLES=\n"
"ROWS(H7:I13) es igual a 7.\n"
"\n"
"@SEEALSO=COLUMN,COLUMNS,ROW"

#: ../plugins/fn-lookup/functions.c:1371
msgid ""
"@FUNCTION=HYPERLINK\n"
"@SYNTAX=HYPERLINK(link_location[,optional_label])\n"
"@DESCRIPTION=HYPERLINK function currently returns its 2nd argument, or if "
"that is omitted the 1st argument.\n"
"\n"
"@EXAMPLES=\n"
"HYPERLINK(\"www.gnome.org\",\"GNOME\").\n"
"\n"
"@SEEALSO="
msgstr ""
"@FUNCTION=HYPERLINK\n"
"@SYNTAX=HYPERLINK(enlace [,etiqueta_opcional])\n"
"@DESCRIPTION=La función HYPERLINK devuelve su segundo argumento, o, en caso "
"de ser omitido, devuelve el primer argumento.\n"
"\n"
"@EXAMPLES=\n"
"HYPERLINK(\"www.gnome.org\";\"GNOME\").\n"
"\n"
"@SEEALSO="

#: ../plugins/fn-lookup/functions.c:1399
msgid ""
"@FUNCTION=TRANSPOSE\n"
"@SYNTAX=TRANSPOSE(matrix)\n"
"@DESCRIPTION=TRANSPOSE function returns the transpose of the input @matrix.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=MMULT"
msgstr ""
"@FUNCTION=TRANSPOSE\n"
"@SYNTAX=TRANSPOSE(matriz)\n"
"@DESCRIPTION=La función TRANSPOSE devuelve la matriz transpuesta de "
"@matriz.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=MMULT"

#: ../plugins/fn-math/functions.c:77
msgid ""
"@FUNCTION=GCD\n"
"@SYNTAX=GCD(number1,number2,...)\n"
"@DESCRIPTION=GCD returns the greatest common divisor of given numbers.\n"
"\n"
"* If any of the arguments is less than one, GCD returns #NUM! error.\n"
"* If any of the arguments is non-integer, it is truncated.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"GCD(470,770) equals 10.\n"
"GCD(470,770,1495) equals 5.\n"
"\n"
"@SEEALSO=LCM"
msgstr ""
"@FUNCTION=GCD\n"
"@SYNTAX=GCD(número1,numero2,…)\n"
"@DESCRIPTION=Devuelve el máximo común divisor de los números dados.\n"
"\n"
"* Si uno de los argumentos es menor que cero, GCD devuelve el error #NÚM!.\n"
"* Si alguno de los argumentos no es un entero, será truncado.\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"GCD(470;770) es igual a 10.\n"
"GCD(470;770;1495) es igual a 5.\n"
"\n"
"@SEEALSO=LCM"

#: ../plugins/fn-math/functions.c:148
msgid ""
"@FUNCTION=LCM\n"
"@SYNTAX=LCM(number1,number2,...)\n"
"@DESCRIPTION=LCM returns the least common multiple of integers.  The least "
"common multiple is the smallest positive number that is a multiple of all "
"integer arguments given.\n"
"\n"
"* If any of the arguments is less than one, LCM returns #NUM!.\n"
"* If any of the arguments is non-integer, it is truncated.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"LCM(2,13) equals 26.\n"
"LCM(4,7,5) equals 140.\n"
"\n"
"@SEEALSO=GCD"
msgstr ""
"@FUNCTION=LCM\n"
"@SYNTAX=LCM(número1,número2,…)\n"
"@DESCRIPTION=LCM devuelve el mínimo común múltiplo de enteros. El mínimo "
"común múltiplo es el número positivo más pequeño que es múltiplo de todos "
"los argumentos enteros dados. \n"
"\n"
"* Si alguno de los argumentos es menor de uno, LCM devuelve el error #NÚM!.\n"
"* Si cualquiera de los argumentos es no entero, se trunca.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"LCM(2,13) es igual a 26.\n"
"LCM(4,7,5) es igual a 140.\n"
"\n"
"@SEEALSO=GCD"

#: ../plugins/fn-math/functions.c:218
msgid ""
"@FUNCTION=HYPOT\n"
"@SYNTAX=HYPOT(number1,number2,...)\n"
"@DESCRIPTION=HYPOT returns the square root of the sum of the squares of the "
"arguments.\n"
"\n"
"@EXAMPLES=\n"
"HYPOT(3,4) equals 5.\n"
"\n"
"@SEEALSO=MIN,MAX"
msgstr ""
"@FUNCTION=HYPOT\n"
"@SYNTAX=HYPOT(número1, número2,…)\n"
"@DESCRIPTION=Devuelve la raíz cuadrada de la suma de los cuadrados de los "
"argumentos.\n"
"\n"
"@EXAMPLES=\n"
"HYPOT(3,4) es igual a 5.\n"
"\n"
"@SEEALSO=MIN,MAX"

#: ../plugins/fn-math/functions.c:248
msgid ""
"@FUNCTION=ABS\n"
"@SYNTAX=ABS(b1)\n"
"@DESCRIPTION=ABS implements the Absolute Value function:  the result is to "
"drop the negative sign (if present).  This can be done for integers and "
"floating point numbers.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"ABS(7) equals 7.\n"
"ABS(-3.14) equals 3.14.\n"
"\n"
"@SEEALSO=CEIL, CEILING, FLOOR, INT, MOD"
msgstr ""
"@FUNCTION=ABS\n"
"@SYNTAX=ABS(b1)\n"
"@DESCRIPTION=ABS implementa la función valor absoluto: el resultado se "
"obtiene dejando el signo negativo (si está presente). Se aplica a números "
"enteros y de coma flotante.\n"
"\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"ABS(7) es igual a 7.\n"
"ABS(-3,14) es igual a 3,14.\n"
"\n"
"@SEEALSO=CEIL, CEILING, FLOOR, INT, MOD"

#: ../plugins/fn-math/functions.c:276
msgid ""
"@FUNCTION=ACOS\n"
"@SYNTAX=ACOS(x)\n"
"@DESCRIPTION=ACOS function calculates the arc cosine of @x; that is the "
"value whose cosine is @x.\n"
"\n"
"* The value it returns is in radians.\n"
"* If @x falls outside the range -1 to 1, ACOS returns the #NUM! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"ACOS(0.1) equals 1.470629.\n"
"ACOS(-0.1) equals 1.670964.\n"
"\n"
"@SEEALSO=COS, SIN, DEGREES, RADIANS"
msgstr ""
"@FUNCTION=ACOS\n"
"@SYNTAX=ACOS(x)\n"
"@DESCRIPTION=Calcula el arco coseno de @x; o sea, el valor cuyo coseno es "
"@x. \n"
"\n"
"* Si @x cae fuera del rango de -1 a 1, ACOS devuelve el error #NÚM!. \n"
"* El valor devuelto se expresa en radianes.\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"ACOS(0.1) es igual a 1,470629.\n"
"ACOS(-0.1) es igual a 1,670964.\n"
"\n"
"@SEEALSO=COS, SIN, DEGREES, RADIANS"

#: ../plugins/fn-math/functions.c:312
msgid ""
"@FUNCTION=ACOSH\n"
"@SYNTAX=ACOSH(x)\n"
"@DESCRIPTION=ACOSH  function  calculates  the inverse hyperbolic cosine of "
"@x; that is the value whose hyperbolic cosine is @x.\n"
"\n"
"* If @x is less than 1.0, ACOSH() returns the #NUM! error.\n"
"* This function is Excel compatible.\n"
" \n"
"@EXAMPLES=\n"
"ACOSH(2) equals 1.31696.\n"
"ACOSH(5.3) equals 2.35183.\n"
"\n"
"@SEEALSO=ACOS, ASINH, DEGREES, RADIANS "
msgstr ""
"@FUNCTION=ACOSH\n"
"@SYNTAX=ACOSH(x)\n"
"@DESCRIPTION=Calcula el coseno hiperbólico inverso de @x; o sea, el valor "
"cuyo coseno hiperbólico es @x.\n"
"\n"
"* Si @x es inferior a 1.0, ACOSH devuelve el error #NÚM!. \n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"ACOSH(2) devuelve 1.31696.\n"
"ACOSH(5.3) devuelve 2.35183.\n"
"\n"
"@SEEALSO=ACOS, ASINH. DEGREES, RADIANS "

#: ../plugins/fn-math/functions.c:347
msgid ""
"@FUNCTION=ASIN\n"
"@SYNTAX=ASIN(x)\n"
"@DESCRIPTION=ASIN function calculates the arc sine of @x; that is the value "
"whose sine is @x.\n"
"\n"
"* If @x falls outside the range -1 to 1, ASIN returns the #NUM! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"ASIN(0.5) equals 0.523599.\n"
"ASIN(1) equals 1.570797.\n"
"\n"
"@SEEALSO=SIN, COS, ASINH, DEGREES, RADIANS"
msgstr ""
"@FUNCTION=ASIN\n"
"@SYNTAX=ASIN(x)\n"
"@DESCRIPTION=Calcula el arco seno de @x; o sea, el valor cuyo seno es @x.\n"
"\n"
"* Si @x cae fuera del rango de -1 a 1, ASIN devuelve el error #NÚM!.\n"
"* El valor devuelto se expresan en radianes. \n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"ASIN(0.5) es igual a 0.523599.\n"
"ASIN(1) es igual a 1.570797.\n"
"\n"
"@SEEALSO=SIN, COS, ASINH, DEGREES, RADIANS"

#: ../plugins/fn-math/functions.c:382
msgid ""
"@FUNCTION=ASINH\n"
"@SYNTAX=ASINH(x)\n"
"@DESCRIPTION=ASINH function calculates the inverse hyperbolic sine of @x; "
"that is the value whose hyperbolic sine is @x.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"ASINH(0.5) equals 0.481212.\n"
"ASINH(1.0) equals 0.881374.\n"
"\n"
"@SEEALSO=ASIN, ACOSH, SIN, COS, DEGREES, RADIANS"
msgstr ""
"@FUNCTION=ASINH\n"
"@SYNTAX=ASINH(x)\n"
"@DESCRIPTION=Calcula el seno hiperbólico inverso de @x; o sea el valor cuyo "
"seno hiperbólico es @x. \n"
"\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"ASINH(0.5) es igual a 0,481212.\n"
"ASINH(1.0) es igual a 0,881374.\n"
"\n"
"@SEEALSO=ASIN, ACOSH, SIN, COS, DEGREES, RADIANS"

#: ../plugins/fn-math/functions.c:409
msgid ""
"@FUNCTION=ATAN\n"
"@SYNTAX=ATAN(x)\n"
"@DESCRIPTION=ATAN function calculates the arc tangent of @x; that is the "
"value whose tangent is @x.\n"
"\n"
"* Return value is in radians.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"ATAN(0.5) equals 0,463648.\n"
"ATAN(1) equals 0,785398.\n"
"\n"
"@SEEALSO=TAN, COS, SIN, DEGREES, RADIANS"
msgstr ""
"@FUNCTION=ATAN\n"
"@SYNTAX=ATAN(x)\n"
"@DESCRIPTION=Calcula el arco tangente de @x; o sea el valor cuya tangente es "
"@x. \n"
"\n"
"* El valor devuelto se expresa en radianes. \n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"ATAN(0.5) es igual a 0,463648.\n"
"ATAN(1) es igual a 0,785398.\n"
"\n"
"@SEEALSO=TAN, COS, SIN, DEGREES, RADIANS"

#: ../plugins/fn-math/functions.c:437
msgid ""
"@FUNCTION=ATANH\n"
"@SYNTAX=ATANH(x)\n"
"@DESCRIPTION=ATANH function calculates the inverse hyperbolic tangent of @x; "
"that is the value whose hyperbolic tangent is @x.\n"
"\n"
"* If the absolute value of @x is greater than 1.0, ATANH returns #NUM! "
"error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"ATANH(0.5) equals 0.549306.\n"
"ATANH(0.8) equals 1.098612.\n"
"\n"
"@SEEALSO=ATAN, TAN, SIN, COS, DEGREES, RADIANS"
msgstr ""
"@FUNCTION=ATANH\n"
"@SYNTAX=ATANH(x)\n"
"@DESCRIPTION=Calcula el arco tangente hiperbólico inverso de @x; o sea, el "
"valor cuya tangente hiperbólica es @x. \n"
"\n"
"* Si el valor absoluto de @x es mayor que 1,0 ATANH devuelve el error "
"#NÚM!.\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"ATANH(0.5) es igual a 0,549306.\n"
"ATANH(0.8) es igual a 1,098612.\n"
"\n"
"@SEEALSO=ATAN, TAN, SIN, COS, DEGREES, RADIANS"

#: ../plugins/fn-math/functions.c:472
msgid ""
"@FUNCTION=ATAN2\n"
"@SYNTAX=ATAN2(b1,b2)\n"
"@DESCRIPTION=ATAN2 function calculates the arc tangent of the two variables "
"@b1 and @b2.  It is similar to calculating the arc tangent of @b2 / @b1, "
"except that the signs of both arguments are used to determine the quadrant "
"of the result.\n"
"\n"
"* The result is in radians.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"ATAN2(0.5,1.0) equals 1.107149.\n"
"ATAN2(-0.5,2.0) equals 1.815775.\n"
"\n"
"@SEEALSO=ATAN, ATANH, COS, SIN, DEGREES, RADIANS"
msgstr ""
"@FUNCTION=ATAN2\n"
"@SYNTAX=ATAN2(b1;b2)\n"
"@DESCRIPTION=Calcula el arco tangente de las dos variables @b1 y @b2. Es "
"similar a calcular el arco tangente de @b2 / @b1, salvo que el signo de "
"ambos argumentos es usado para determinar el cuadrante del resultado. \n"
"\n"
"* El valor devuelto se expresan en radianes.\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"ATAN2(0,5;1,0) es igual a 1,107149.\n"
"ATAN2(-0,5;2,0) es igual a 1,815775.\n"
"\n"
"@SEEALSO=ATAN, ATANH, COS, SIN, DEGREES, RADIANS"

#: ../plugins/fn-math/functions.c:508
msgid ""
"@FUNCTION=CEIL\n"
"@SYNTAX=CEIL(x)\n"
"@DESCRIPTION=CEIL function rounds @x up to the next nearest integer.\n"
"\n"
"\n"
"@EXAMPLES=\n"
"CEIL(0.4) equals 1.\n"
"CEIL(-1.1) equals -1.\n"
"CEIL(-2.9) equals -2.\n"
"\n"
"@SEEALSO=CEILING, FLOOR, ABS, INT, MOD"
msgstr ""
"@FUNCTION=CEIL\n"
"@SYNTAX=CEIL(x)\n"
"@DESCRIPTION=Redondea @x hacia el próximo valor entero.\n"
"\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"CEIL(0.4) es igual a 1.\n"
"CEIL(-1,1) es igual a -1.\n"
"CEIL(-2,9) es igual a -2.\n"
"\n"
"@SEEALSO=CEILING, FLOOR, ABS, INT, MOD"

#: ../plugins/fn-math/functions.c:534
msgid ""
"@FUNCTION=COUNTIF\n"
"@SYNTAX=COUNTIF(range,criteria)\n"
"@DESCRIPTION=COUNTIF function counts the number of cells in the given @range "
"that meet the given @criteria.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1, A2, ..., A5 contain numbers 23, 27, 28, 33, "
"and 39.  Then\n"
"COUNTIF(A1:A5,\"<=28\") equals 3.\n"
"COUNTIF(A1:A5,\"<28\") equals 2.\n"
"COUNTIF(A1:A5,\"28\") equals 1.\n"
"COUNTIF(A1:A5,\">28\") equals 2.\n"
"\n"
"@SEEALSO=COUNT,SUMIF"
msgstr ""
"@FUNCTION=COUNTIF\n"
"@SYNTAX=COUNTIF(rango;criterio)\n"
"@DESCRIPTION=Cuenta la cantidad de celdas en el @rango dado que corresponden "
"al @criterio dado.\n"
"\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"Suponiendo que las celdas A1, A2, …, A5 contienen los números 23, 27, 28, "
"33, y 39. Entonces\n"
"COUNTIF(A1:A5;\"<=28\") es igual a 3.\n"
"COUNTIF(A1:A5;\"<28\") es igual a 2.\n"
"COUNTIF(A1:A5;\"28\") es igual a 1.\n"
"COUNTIF(A1:A5;\">28\") es igual a 2.\n"
"\n"
"@SEEALSO=COUNT,SUMIF"

#: ../plugins/fn-math/functions.c:615
msgid ""
"@FUNCTION=SUMIF\n"
"@SYNTAX=SUMIF(range,criteria[,actual_range])\n"
"@DESCRIPTION=SUMIF function sums the values in the given @range that meet "
"the given @criteria.  If @actual_range is given, SUMIF sums the values in "
"the @actual_range whose corresponding components in @range meet the given "
"@criteria.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1, A2, ..., A5 contain numbers 23, 27, 28, 33, "
"and 39.  Then\n"
"SUMIF(A1:A5,\"<=28\") equals 78.\n"
"SUMIF(A1:A5,\"<28\") equals 50.\n"
"In addition, if the cells B1, B2, ..., B5 hold numbers 5, 3, 2, 6, and 7 "
"then:\n"
"SUMIF(A1:A5,\"<=27\",B1:B5) equals 8.\n"
"\n"
"@SEEALSO=COUNTIF, SUM"
msgstr ""
"@FUNCTION=SUMIF\n"
"@SYNTAX=SUMIF(rango;criterio[;rango_real])\n"
"@DESCRIPTION=Suma los valores de las celdas en el @rango que corresponden al "
"@criterio pasado como argumento. Si se usa @rango_real, SUMIF suma los "
"valores en el rango @rango_real cuyos componentes en @rango corresponden al "
"criterio pasado en argumento @criterio.\n"
"\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"Suponiendo que las celdas A1, A2, …, A5 contiene los números 23, 27, 28, 33, "
"y 39. Entonces\n"
"SUMIF(A1:A5;\"<=28\") es igual a 78.\n"
"SUMIF(A1:A5;\"<28\") es igual a 50.\n"
"Además, si las celdas B1, B2, …, B5 contienen los números 5, 3, 2, 6, y 7 "
"entonces:\n"
"SUMIF(A1:A5;\"<=27\",B1:B5) es igual a 8.\n"
"\n"
"@SEEALSO=COUNTIF,SUM"

#: ../plugins/fn-math/functions.c:742
msgid ""
"@FUNCTION=CEILING\n"
"@SYNTAX=CEILING(x[,significance])\n"
"@DESCRIPTION=CEILING function rounds @x up to the nearest multiple of "
"@significance.\n"
"\n"
"* If @x or @significance is non-numeric CEILING returns #VALUE! error.\n"
"* If @x and @significance have different signs CEILING returns #NUM! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"CEILING(2.43,1) equals 3.\n"
"CEILING(123.123,3) equals 126.\n"
"\n"
"@SEEALSO=CEIL, FLOOR, ABS, INT, MOD"
msgstr ""
"@FUNCTION=CEILING\n"
"@SYNTAX=CEILING(x;significante)\n"
"@DESCRIPTION=Redondea hacia arriba @x hasta al múltiplo de @significante más "
"cercano.\n"
"\n"
"* Si @x o @significante no es un valor numérico, CEILING devuelve el error "
"#VALOR!.\n"
"* Si @x y @significante son de signos contrarios, CEILING devuelve el error "
"#NÚM!. \n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"CEILING(2,43;1) es igual a 3.\n"
"CEILING(123,123;3) es igual a 126.\n"
"\n"
"@SEEALSO=CEIL, FLOOR, ABS, INT, MOD"

#: ../plugins/fn-math/functions.c:783
msgid ""
"@FUNCTION=COS\n"
"@SYNTAX=COS(x)\n"
"@DESCRIPTION=COS function returns the cosine of @x, where @x is given in "
"radians.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"COS(0.5) equals 0.877583.\n"
"COS(1) equals 0.540302.\n"
"\n"
"@SEEALSO=COSH, SIN, SINH, TAN, TANH, RADIANS, DEGREES"
msgstr ""
"@FUNCTION=COS\n"
"@SYNTAX=COS(x)\n"
"@DESCRIPTION=Devuelve el coseno de @x, @x se expresa en radianes. \n"
"\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"COS(0.5) es igual a 0,877583.\n"
"COS(1) es igual a 0,540302.\n"
"\n"
"@SEEALSO=COSH, SIN, SINH, TAN, TANH, RADIANS, DEGREES"

#: ../plugins/fn-math/functions.c:810
msgid ""
"@FUNCTION=COSH\n"
"@SYNTAX=COSH(x)\n"
"@DESCRIPTION=COSH function returns the hyperbolic cosine of @x, which is "
"defined mathematically as\n"
"\n"
"\t(exp(@x) + exp(-@x)) / 2.\n"
"\n"
"* @x is in radians.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"COSH(0.5) equals 1.127626.\n"
"COSH(1) equals 1.543081.\n"
"\n"
"@SEEALSO=COS, SIN, SINH, TAN, TANH, RADIANS, DEGREES, EXP"
msgstr ""
"@FUNCTION=COSH\n"
"@SYNTAX=COSH(x)\n"
"@DESCRIPTION=Devuelve el coseno hiperbólico de @x, el cual es definido "
"matemáticamente como \n"
"\n"
"\t(exp(@x) + exp(-@x)) / 2.\n"
"\n"
"* @x en radianes. \n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"COSH(0,5) es igual a 1,127626.\n"
"COSH(1) es igual a 1,543081.\n"
"\n"
"@SEEALSO=COS, SIN, SINH, TAN, TANH, RADIANS, DEGREES, EXP"

#: ../plugins/fn-math/functions.c:838
msgid ""
"@FUNCTION=DEGREES\n"
"@SYNTAX=DEGREES(x)\n"
"@DESCRIPTION=DEGREES computes the number of degrees equivalent to @x "
"radians.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"DEGREES(2.5) equals 143.2394.\n"
"\n"
"@SEEALSO=RADIANS, PI"
msgstr ""
"@FUNCTION=DEGREES\n"
"@SYNTAX=DEGREES(x)\n"
"@DESCRIPTION=Calcula el equivalente en grados del ángulo @x dado en "
"radianes. \n"
"\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"DEGREES(2,5) es igual a 143,2394.\n"
"\n"
"@SEEALSO=RADIANS, PI"

#: ../plugins/fn-math/functions.c:865
msgid ""
"@FUNCTION=EXP\n"
"@SYNTAX=EXP(x)\n"
"@DESCRIPTION=EXP computes the value of e (the base of natural logarithms) "
"raised to the power of @x.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"EXP(2) equals 7.389056.\n"
"\n"
"@SEEALSO=LOG, LOG2, LOG10"
msgstr ""
"@FUNCTION=EXP\n"
"@SYNTAX=EXP(x)\n"
"@DESCRIPTION=Calcula el valor de e (la base de los logaritmos naturales) "
"elevado a la potencia @x. \n"
"\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"EXP(2) es igual a 7,389056.\n"
"\n"
"@SEEALSO=LOG, LOG2, LOG10"

#: ../plugins/fn-math/functions.c:891
msgid ""
"@FUNCTION=EXPM1\n"
"@SYNTAX=EXPM1(x)\n"
"@DESCRIPTION=EXPM1 computes EXP(@x)-1 with higher resulting precision than "
"the direct formula.\n"
"\n"
"@EXAMPLES=\n"
"EXPM1(0.01) equals 0.01005.\n"
"\n"
"@SEEALSO=EXP, LN1P"
msgstr ""
"@FUNCTION=EXPM1\n"
"@SYNTAX=EXPM1(x)\n"
"@DESCRIPTION=Calcula el valor de EXP(@x)-1 con una precisión mayor que la "
"fórmula directa. \n"
"\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"EXPM1(0.01) es igual a 0,01005.\n"
"\n"
"@SEEALSO=EXP, LN1P"

#: ../plugins/fn-math/functions.c:915
msgid ""
"@FUNCTION=FACT\n"
"@SYNTAX=FACT(x)\n"
"@DESCRIPTION=FACT computes the factorial of @x. ie, @x!\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"FACT(3) equals 6.\n"
"FACT(9) equals 362880.\n"
"\n"
"@SEEALSO="
msgstr ""
"@FUNCTION=FACT\n"
"@SYNTAX=FACT(x)\n"
"@DESCRIPTION=Calcula el factorial de @x, es decir @x!\n"
"\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"FACT(3) es igual a 6.\n"
"FACT(9) es igual a 362880.\n"
"\n"
"@SEEALSO="

#: ../plugins/fn-math/functions.c:954
msgid ""
"@FUNCTION=BETA\n"
"@SYNTAX=BETA(a,b)\n"
"@DESCRIPTION=BETA function returns the value of the mathematical beta "
"function extended to all real numbers except 0 and negative integers.\n"
"\n"
"* If @a, @b, or (@a + @b) are non-positive integers, BETA returns #NUM! "
"error.\n"
"\n"
"@EXAMPLES=\n"
"BETA(2,3) equals 0.083333.\n"
"BETA(-0.5,0.5) equals #NUM!.\n"
"\n"
"@SEEALSO=BETALN,GAMMALN"
msgstr ""
"@FUNCTION=BETA\n"
"@SYNTAX=BETA(a,b)\n"
"@DESCRIPTION=La función BETA devuelve el valor de la función matemática beta "
"extendida a todos los números reales excepto el 0 y los enteros negativos.\n"
"\n"
"* Si @a, @b o (@a + @b) son enteros negativos, BETA devuelve el error "
"#NÚM!.\n"
"\n"
"@EXAMPLES=\n"
"BETA(2,3) es igual a 0,083333.\n"
"BETA(-0.5,0.5) es igual a #NÚM!.\n"
"\n"
"\n"
"@SEEALSO=BETALN,GAMMALN"

#: ../plugins/fn-math/functions.c:987
msgid ""
"@FUNCTION=BETALN\n"
"@SYNTAX=BETALN(a,b)\n"
"@DESCRIPTION=BETALN function returns the natural logarithm of the absolute "
"value of the beta function.\n"
"\n"
"* If @a, @b, or (@a + @b) are non-positive integers, BETALN returns #NUM! \n"
"@EXAMPLES=\n"
"BETALN(2,3) equals -2.48.\n"
"BETALN(-0.5,0.5) equals #NUM!.\n"
"\n"
"@SEEALSO=BETA,GAMMALN"
msgstr ""
"@FUNCTION=BETALN\n"
"@SYNTAX=BETALN(a,b)\n"
"@DESCRIPTION=La función BETALN devuelve el logaritmo natural del valor "
"absoluto de la función beta.\n"
"\n"
"* Si @a, @b o (@a + @b) no son enteros positivos, BETALN devuelve el error "
"#NÚM!. \n"
"\n"
"@EXAMPLES=\n"
"BETALN(2,3) es igual a -2.48.\n"
"BETALN(-0.5,0.5) es igual a #NÚM!.\n"
"\n"
"@SEEALSO=BETA,GAMMALN"

#: ../plugins/fn-math/functions.c:1019
msgid ""
"@FUNCTION=COMBIN\n"
"@SYNTAX=COMBIN(n,k)\n"
"@DESCRIPTION=COMBIN computes the number of combinations.\n"
"\n"
"* Performing this function on a non-integer or a negative number returns "
"#NUM! error.\n"
"* If @n is less than @k COMBIN returns #NUM! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"COMBIN(8,6) equals 28.\n"
"COMBIN(6,2) equals 15.\n"
"\n"
"@SEEALSO="
msgstr ""
"@FUNCTION=COMBIN\n"
"@SYNTAX=COMBIN(n;k)\n"
"@DESCRIPTION=Calcula la cantidad de combinaciones.\n"
"\n"
"* Efectuar esta función con números no enteros o negativos devuelve un error "
"#NÚM!.\n"
"* Si @n es menor que @k devuelve un error #NÚM!.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"COMBIN(8;6) es igual a 28.\n"
"COMBIN(6;2) es igual a 15.\n"
"\n"
"@SEEALSO="

#: ../plugins/fn-math/functions.c:1054
msgid "FLOOR:rounds down."
msgstr "FLOOR: redondea hacia abajo."

#: ../plugins/fn-math/functions.c:1055
msgid "x:value."
msgstr "x:valor."

#: ../plugins/fn-math/functions.c:1056
msgid "significance:base multiple (defaults to 1 for @x > 0 and -1 for @x <0)"
msgstr ""
"significancia: multiplo de la base (predeterminado a 1 para @x > 0 y -1 para "
"@x < 0)"

#: ../plugins/fn-math/functions.c:1058
msgid ""
"FLOOR function rounds @x down to the next nearest multiple of @significance."
msgstr ""
"La función FLOOR redondea @x hacia abajo al siguente entero múltiplo más "
"cercano de @significancia"

#: ../plugins/fn-math/functions.c:1060
msgid "FLOOR(0.5) equals 0."
msgstr "FLOOR (0,5) es igual a 0."

#: ../plugins/fn-math/functions.c:1061
msgid "FLOOR(5,2) equals 4."
msgstr "FLOOR(5,2) es igual a 4."

#: ../plugins/fn-math/functions.c:1062
msgid "FLOOR(-5,-2) equals -4."
msgstr "FLOOR(-5,-2) es igual a -4."

#: ../plugins/fn-math/functions.c:1063
msgid "FLOOR(-5,2) equals #NUM!."
msgstr "FLOOR(-5,2) es igual a #NUM!."

#: ../plugins/fn-math/functions.c:1090
msgid ""
"@FUNCTION=INT\n"
"@SYNTAX=INT(a)\n"
"@DESCRIPTION=INT function returns the largest integer that is not bigger "
"than its argument.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"INT(7.2) equals 7.\n"
"INT(-5.5) equals -6.\n"
"\n"
"@SEEALSO=CEIL, CEILING, FLOOR, ABS, MOD"
msgstr ""
"@FUNCTION=INT\n"
"@SYNTAX=INT(a)\n"
"@DESCRIPTION=La función INT devuelve el entero más alto que no es mayor a su "
"argumento.\n"
"\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"INT(7,2) es igual a 7.\n"
"INT(-5,5) es igual a -6.\n"
"\n"
"@SEEALSO=CEIL, CEILING, FLOOR, ABS, MOD"

#: ../plugins/fn-math/functions.c:1118
msgid ""
"@FUNCTION=LOG\n"
"@SYNTAX=LOG(x[,base])\n"
"@DESCRIPTION=LOG computes the logarithm of @x in the given base @base.  If "
"no @base is given LOG returns the logarithm in base 10. @base must be > 0. "
"and cannot equal 1.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"LOG(2) equals 0.30103.\n"
"LOG(8192,2) equals 13.\n"
"\n"
"@SEEALSO=LN, LOG2, LOG10"
msgstr ""
"@FUNCTION=LOG\n"
"@SYNTAX=LOG(x[;base])\n"
"@DESCRIPTION=Calcula el logaritmo de @x en la @base dada. Si la @base no se "
"especifica LOG devuelve el logaritmo en base 10. @base debe ser > 0 y no "
"puede ser igual a 1.\n"
"\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"LOG(2) es igual a 0,30103.\n"
"LOG(8192;2) es igual a 13.\n"
"\n"
"@SEEALSO=LN, LOG2, LOG10"

#: ../plugins/fn-math/functions.c:1155
msgid ""
"@FUNCTION=LN\n"
"@SYNTAX=LN(x)\n"
"@DESCRIPTION=LN returns the natural logarithm of @x.\n"
"\n"
"* If @x <= 0, LN returns #NUM! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"LN(7) equals 1.94591.\n"
"\n"
"@SEEALSO=EXP, LOG2, LOG10"
msgstr ""
"@FUNCTION=LN\n"
"@SYNTAX=LN(x)\n"
"@DESCRIPTION=Calcula el logaritmo natural de @x.\n"
"\n"
"* Si @x es <= 0, LN devuelve el error #NÚM!.\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"LN(7) es igual a 1,94591.\n"
"\n"
"@SEEALSO=EXP, LOG2, LOG10"

#: ../plugins/fn-math/functions.c:1187
msgid ""
"@FUNCTION=LN1P\n"
"@SYNTAX=LN1P(x)\n"
"@DESCRIPTION=LN1P computes LN(1+@x) with higher resulting precision than the "
"direct formula.\n"
"\n"
"* If @x <= -1, LN1P returns #NUM! error.\n"
"\n"
"@EXAMPLES=\n"
"LN1P(0.01) equals 0.00995.\n"
"\n"
"@SEEALSO=LN, EXPM1"
msgstr ""
"@FUNCTION=LN1P\n"
"@SYNTAX=LN1P(x)\n"
"@DESCRIPTION=Calcula el logaritmo LN(1+@x) con precisión más alta que la "
"fórmula directa. \n"
"\n"
"* Si @x <= -1, LN1P devuelve el error #NÚM!.\n"
"\n"
"@EXAMPLES=\n"
"LN1P(0.01) es igual a 0.00995.\n"
"\n"
"@SEEALSO=LN, EXPM1"

#: ../plugins/fn-math/functions.c:1219
msgid ""
"@FUNCTION=POWER\n"
"@SYNTAX=POWER(x,y)\n"
"@DESCRIPTION=POWER returns the value of @x raised to the power @y.\n"
"\n"
"\n"
"* If both @x and @y equal 0, POWER returns #NUM! error.\n"
"* If @x = 0 and @y < 0, POWER returns #DIV/0! error.\n"
"* If @x < 0 and @y is non-integer, POWER returns #NUM! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"POWER(2,7) equals 128.\n"
"POWER(3,3.141) equals 31.523749.\n"
"\n"
"@SEEALSO=EXP"
msgstr ""
"@FUNCTION=POWER\n"
"@SYNTAX=POWER(x,y)\n"
"@DESCRIPTION=Devuelve el valor de @x a la potencia @y.\n"
"\n"
"* Si ambos @x e @y son iguales a 0, POWER devuelve in error #NÚM!.\n"
"* Si @x = 0 e @y <0, POWER devuelve un error #DIV/0!.\n"
"* Si @x < 0 e @y no es entero, POWER devuelve un error #NÚM!\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"POWER(2;7) es igual a 128.\n"
"POWER(3,3.141) es igual a 31,523749.\n"
"\n"
"@SEEALSO=EXP"

#: ../plugins/fn-math/functions.c:1258
msgid ""
"@FUNCTION=LOG2\n"
"@SYNTAX=LOG2(x)\n"
"@DESCRIPTION=LOG2 computes the base-2 logarithm of @x.\n"
"\n"
"* If @x <= 0, LOG2 returns #NUM! error.\n"
"\n"
"@EXAMPLES=\n"
"LOG2(1024) equals 10.\n"
"\n"
"@SEEALSO=EXP, LOG10, LOG"
msgstr ""
"@FUNCTION=LOG2\n"
"@SYNTAX=LOG2(x)\n"
"@DESCRIPTION=Calcula el logaritmo en base 2 de @x. \n"
"\n"
"* Si @x <= 0, LOG2 devuelve el error #NÚM!.\n"
"\n"
"@EXAMPLES=\n"
"LOG2(1024) es igual a 10.\n"
"\n"
"@SEEALSO=EXP, LOG10, LOG"

#: ../plugins/fn-math/functions.c:1288
msgid ""
"@FUNCTION=LOG10\n"
"@SYNTAX=LOG10(x)\n"
"@DESCRIPTION=LOG10 computes the base-10 logarithm of @x.\n"
"\n"
"* If @x <= 0, LOG10 returns #NUM! error.\n"
"* This function is Excel compatible.\n"
" \n"
"@EXAMPLES=\n"
"LOG10(7) equals 0.845098.\n"
"\n"
"@SEEALSO=EXP, LOG2, LOG"
msgstr ""
"@FUNCTION=LOG10\n"
"@SYNTAX=LOG10(x)\n"
"@DESCRIPTION=Calcula el logaritmo en base 10 de @x. \n"
"\n"
"* Si @x <= 0, LOG10 devuelve el error #NÚM!.\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"LOG10(7) devuelve 0.845098.\n"
"\n"
"@SEEALSO=EXP, LOG2, LOG"

#: ../plugins/fn-math/functions.c:1319
msgid ""
"@FUNCTION=MOD\n"
"@SYNTAX=MOD(number,divisor)\n"
"@DESCRIPTION=MOD function returns the remainder when @divisor is divided "
"into @number.\n"
"\n"
"* MOD returns #DIV/0! if @divisor is zero.\n"
"* This function is Excel compatible.\n"
" \n"
"@EXAMPLES=\n"
"MOD(23,7) equals 2.\n"
"\n"
"@SEEALSO=CEIL, CEILING, FLOOR, ABS, INT, ABS"
msgstr ""
"@FUNCTION=MOD\n"
"@SYNTAX=MOD(número,divisor)\n"
"@DESCRIPTION=La función MOD devuelve el resto de efectuar la división "
"@número entre @divisor.\n"
"\n"
"* Si el @divisor es cero devuelve el error #DIV/0! .\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"MOD(23,7) es igual a 2.\n"
"\n"
"@SEEALSO=CEIL, CEILING, FLOOR, ABS, INT, ABS"

#: ../plugins/fn-math/functions.c:1372
msgid ""
"@FUNCTION=RADIANS\n"
"@SYNTAX=RADIANS(x)\n"
"@DESCRIPTION=RADIANS computes the number of radians equivalent to @x "
"degrees.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"RADIANS(180) equals 3.14159.\n"
"\n"
"@SEEALSO=PI,DEGREES"
msgstr ""
"@FUNCTION=RADIANS\n"
"@SYNTAX=RADIANS(x)\n"
"@DESCRIPTION=Calcula el número en radianes equivalente al ángulo de @x "
"grados.\n"
"\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"RADIANS(180) es igual a 3,14159.\n"
"\n"
"@SEEALSO=PI,DEGREES"

#: ../plugins/fn-math/functions.c:1399
msgid ""
"@FUNCTION=SIN\n"
"@SYNTAX=SIN(x)\n"
"@DESCRIPTION=SIN function returns the sine of @x, where @x is given in "
"radians.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"SIN(0.5) equals 0.479426.\n"
"\n"
"@SEEALSO=COS, COSH, SINH, TAN, TANH, RADIANS, DEGREES"
msgstr ""
"@FUNCTION=SIN\n"
"@SYNTAX=SIN(x)\n"
"@DESCRIPTION=La función SIN devuelve el seno de @x, con @x en radianes.\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"SIN(0,5) es igual a 0,479426.\n"
"\n"
"@SEEALSO=COS, COSH, SINH, TAN, TANH, RADIANS, DEGREES"

#: ../plugins/fn-math/functions.c:1425
msgid ""
"@FUNCTION=SINH\n"
"@SYNTAX=SINH(x)\n"
"@DESCRIPTION=SINH function returns the hyperbolic sine of @x, which is "
"defined mathematically as\n"
"\n"
"\t(exp(@x) - exp(-@x)) / 2.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"SINH(0.5) equals 0.521095.\n"
"\n"
"@SEEALSO=SIN, COS, COSH, TAN, TANH, DEGREES, RADIANS, EXP"
msgstr ""
"@FUNCTION=SINH\n"
"@SYNTAX=SINH(x)\n"
"@DESCRIPTION=La función SINH devuelve el seno hiperbólico de @x, el cual es "
"definido matemáticamente como \n"
"\n"
"\t(exp(@x) - exp(-@x)) / 2.\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"SINH(0,5) es igual a 0,521095.\n"
"\n"
"@SEEALSO=SIN, COS, COSH, TAN, TANH, DEGREES, RADIANS, EXP"

#: ../plugins/fn-math/functions.c:1452
msgid ""
"@FUNCTION=SQRT\n"
"@SYNTAX=SQRT(x)\n"
"@DESCRIPTION=SQRT function returns the square root of @x.\n"
"\n"
"* If @x is negative, SQRT returns #NUM! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"SQRT(2) equals 1.4142136.\n"
"\n"
"@SEEALSO=POWER"
msgstr ""
"@FUNCTION=SQRT\n"
"@SYNTAX=SQRT(x)\n"
"@DESCRIPTION=Devuelve la raíz cuadrada de @x.\n"
"\n"
"* Si @x es negativo devuelve el error #NÚM!.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"SQRT(2) es igual a 1,4142136.\n"
"\n"
"@SEEALSO=POWER"

#: ../plugins/fn-math/functions.c:1483
msgid ""
"@FUNCTION=SUMA\n"
"@SYNTAX=SUMA(value1, value2, ...)\n"
"@DESCRIPTION=SUMA computes the sum of all the values and cells referenced in "
"the argument list.  Numbers, text and logical values are included in the "
"calculation too.  If the cell contains text or the argument evaluates to "
"FALSE, it is counted as value zero (0). If the argument evaluates to TRUE, "
"it is counted as one (1).\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11, 15, 17, 21, "
"and 43.  Then\n"
"SUMA(A1:A5) equals 107.\n"
"\n"
"@SEEALSO=AVERAGE, SUM, COUNT"
msgstr ""
"@FUNCTION=SUMA\n"
"@SYNTAX=SUMA(valor1, valor2, …)\n"
"@DESCRIPTION=Calcula la suma de todos los valores y celdas referenciados en "
"la lista de argumentos. Se incluye en el cálculo los números y también los "
"textos y expresiones lógicas. Si la celda contiene texto o la expresión "
"lógica FALSO, se contará como un cero (0). Si contiene un valor lógico "
"VERDADERO, se contará como un uno (1). \n"
"\n"
"@EXAMPLES=\n"
"Suponiendo que las celdas A1, A2, …, A5 contienen los números 11, 15, 17, 21 "
"y 43. Entonces\n"
"SUMA(A1:A5) es igual a 107.\n"
"\n"
"@SEEALSO=AVERAGE, SUM, COUNT"

#: ../plugins/fn-math/functions.c:1518
msgid ""
"@FUNCTION=SUMSQ\n"
"@SYNTAX=SUMSQ(value1, value2, ...)\n"
"@DESCRIPTION=SUMSQ returns the sum of the squares of all the values and "
"cells referenced in the argument list.\n"
"\n"
"* This function is Excel compatible.\n"
" \n"
"@EXAMPLES=\n"
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11, 15, 17, 21, "
"and 43.  Then\n"
"SUMSQ(A1:A5) equals 2925.\n"
"\n"
"@SEEALSO=SUM, COUNT"
msgstr ""
"@FUNCTION=SUMSQ\n"
"@SYNTAX=SUMSQ(valor1;valor2;…)\n"
"@DESCRIPTION=Calcula la suma de los cuadrados de todos los valores y celdas "
"referenciados en la lista de argumentos.\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"Suponiendo que las celdas A1, A2, …, A5 contienen los números 11, 15, 17, "
"21, y 43. Entonces\n"
"SUMSQ(A1:A5) es igual a 2925.\n"
"\n"
"@SEEALSO=SUM, COUNT"

#: ../plugins/fn-math/functions.c:1552
msgid ""
"@FUNCTION=MULTINOMIAL\n"
"@SYNTAX=MULTINOMIAL(value1, value2, ...)\n"
"@DESCRIPTION=MULTINOMIAL returns the ratio of the factorial of a sum of "
"values to the product of factorials.\n"
"\n"
"* This function is Excel compatible.\n"
" \n"
"@EXAMPLES=\n"
"MULTINOMIAL(2,3,4) equals 1260.\n"
"\n"
"@SEEALSO=SUM"
msgstr ""
"@FUNCTION=MULTINOMIAL\n"
"@SYNTAX=MULTINOMIAL(valor1,valor2,…)\n"
"@DESCRIPTION=Devuelve el resultado de la división del factorial de la suma "
"de los valores, por el producto de los factoriales.\n"
"\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"MULTINOMIAL(2,3,4) es igual a 1260.\n"
"\n"
"@SEEALSO=SUM"

#: ../plugins/fn-math/functions.c:1584
msgid ""
"@FUNCTION=G_PRODUCT\n"
"@SYNTAX=G_PRODUCT(value1, value2, ...)\n"
"@DESCRIPTION=G_PRODUCT returns the product of all the values and cells "
"referenced in the argument list.\n"
"\n"
"* Empty cells are ignored and the empty product is 1.\n"
"\n"
"@EXAMPLES=\n"
"G_PRODUCT(2,5,9) equals 90.\n"
"\n"
"@SEEALSO=SUM, COUNT"
msgstr ""
"@FUNCTION=G_PRODUCT\n"
"@SYNTAX=G_PRODUCT(valor1, valor2, …)\n"
"@DESCRIPTION=Calcula el producto de todos los valores y celdas referenciados "
"en la lista de argumentos.\n"
"\n"
"* Las celdas vacías son ignoradas y el producto de celdas vacías es 1.\n"
"\n"
"@EXAMPLES=\n"
"G_PRODUCT(2,5,9) devuelve 90.\n"
"\n"
"@SEEALSO=SUM, COUNT"

#: ../plugins/fn-math/functions.c:1615
msgid ""
"@FUNCTION=TAN\n"
"@SYNTAX=TAN(x)\n"
"@DESCRIPTION=TAN function returns the tangent of @x, where @x is given in "
"radians.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"TAN(3) equals -0.1425465.\n"
"\n"
"@SEEALSO=TANH, COS, COSH, SIN, SINH, DEGREES, RADIANS"
msgstr ""
"@FUNCTION=TAN\n"
"@SYNTAX=TAN(x)\n"
"@DESCRIPTION=Devuelve la tangente de @x, donde @x está expresado en "
"radianes.\n"
"\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"TAN(3) es igual a -0,1425465.\n"
"\n"
"@SEEALSO=TANH, COS, COSH, SIN, SINH, DEGREES, RADIANS"

#: ../plugins/fn-math/functions.c:1641
msgid ""
"@FUNCTION=TANH\n"
"@SYNTAX=TANH(x)\n"
"@DESCRIPTION=TANH function returns the hyperbolic tangent of @x, which is "
"defined mathematically as \n"
"\n"
"\tsinh(@x) / cosh(@x).\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"TANH(2) equals 0.96402758.\n"
"\n"
"@SEEALSO=TAN, SIN, SINH, COS, COSH, DEGREES, RADIANS"
msgstr ""
"@FUNCTION=TANH\n"
"@SYNTAX=TANH(x)\n"
"@DESCRIPTION=Devuelve la tangente hiperbólica de @x, la cual es definida "
"matemáticamente como \n"
"\tsinh(@x) / cosh(@x).\n"
"\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"TANH(2) devuelve 0,96402758.\n"
"\n"
"@SEEALSO=TAN, SIN, SINH, COS, COSH, DEGREES, RADIANS"

#: ../plugins/fn-math/functions.c:1667
msgid ""
"@FUNCTION=PI\n"
"@SYNTAX=PI()\n"
"@DESCRIPTION=PI functions returns the value of pi.\n"
"\n"
"* This function is called with no arguments.\n"
"* This function is Excel compatible, except that it returns pi with a better "
"precision.\n"
"\n"
"@EXAMPLES=\n"
"PI() equals about 3.141593.\n"
"\n"
"@SEEALSO=SQRTPI"
msgstr ""
"@FUNCTION=PI\n"
"@SYNTAX=PI()\n"
"@DESCRIPTION=La función PI devuelve el valor de pi.\n"
"\n"
"* Esta función se llama sin argumentos.\n"
"* Esta función es compatible con Excel, salvo que devuelve pi con mejor "
"precisión.\n"
"\n"
"@EXAMPLES=\n"
"PI() es igual a 3,141593.\n"
"\n"
"@SEEALSO=SQRTPI"

#: ../plugins/fn-math/functions.c:1695
msgid ""
"@FUNCTION=TRUNC\n"
"@SYNTAX=TRUNC(number[,digits])\n"
"@DESCRIPTION=TRUNC function returns the value of @number truncated to the "
"number of digits specified.\n"
"\n"
"* If @digits is omitted or negative then @digits defaults to zero.\n"
"* If @digits is not an integer, it is truncated.\n"
"* This function is Excel compatible.\n"
" \n"
"@EXAMPLES=\n"
"TRUNC(3.12) equals 3.\n"
"TRUNC(4.15,1) equals 4.1.\n"
"\n"
"@SEEALSO=INT"
msgstr ""
"@FUNCTION=TRUNC\n"
"@SYNTAX=TRUNC(número[,dígitos])\n"
"@DESCRIPTION=Devuelve el valor de @número truncado a la cantidad de @dígitos "
"especificado.\n"
"\n"
"* Si se omite @dígitos o es menor que cero entonces @dígitos se asume cero.\n"
"* Si @dígitos no es enero, se trunca.\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"TRUNC(3,12) es igual a 3.\n"
"TRUNC(4,15;1) es igual a 4.1.\n"
"\n"
"@SEEALSO=INT"

#: ../plugins/fn-math/functions.c:1741
msgid ""
"@FUNCTION=EVEN\n"
"@SYNTAX=EVEN(number)\n"
"@DESCRIPTION=EVEN function returns the number rounded up to the nearest even "
"integer.  Negative numbers are rounded down.\n"
"\n"
"* This function is Excel compatible.\n"
" \n"
"@EXAMPLES=\n"
"EVEN(5.4) equals 6.\n"
"EVEN(-5.4) equals -6.\n"
"\n"
"@SEEALSO=ODD"
msgstr ""
"@FUNCTION=EVEN\n"
"@SYNTAX=EVEN(número)\n"
"@DESCRIPTION=Devuelve el número redondeado al entero par más próximo. Los "
"números negativos se redondean hacia abajo.\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"EVEN(5,4) es igual a 6.\n"
"EVEN(-5.4) igual a -6.\n"
"\n"
"@SEEALSO=ODD"

#: ../plugins/fn-math/functions.c:1785
msgid ""
"@FUNCTION=ODD\n"
"@SYNTAX=ODD(number)\n"
"@DESCRIPTION=ODD function returns the @number rounded up to the nearest odd "
"integer.  Negative numbers are rounded down.\n"
"\n"
"* This function is Excel compatible.\n"
" \n"
"@EXAMPLES=\n"
"ODD(4.4) equals 5.\n"
"ODD(-4.4) equals -5.\n"
"\n"
"@SEEALSO=EVEN"
msgstr ""
"@FUNCTION=ODD\n"
"@SYNTAX=ODD(número)\n"
"@DESCRIPTION=Devuelve el @número redondeado al entero impar más próximo. Los "
"números negativos se redondean hacia abajo.\n"
"\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"ODD(4,4) es igual a 5.\n"
"ODD(-4,4) es igual a -5.\n"
"\n"
"@SEEALSO=EVEN"

#: ../plugins/fn-math/functions.c:1829
msgid ""
"@FUNCTION=FACTDOUBLE\n"
"@SYNTAX=FACTDOUBLE(number)\n"
"@DESCRIPTION=FACTDOUBLE function returns the double factorial of a @number, "
"i.e., x!!.\n"
"\n"
"* If @number is not an integer, it is truncated.\n"
"* If @number is negative FACTDOUBLE returns #NUM! error.\n"
"* This function is Excel compatible.\n"
" \n"
"@EXAMPLES=\n"
"FACTDOUBLE(5) equals 15.\n"
"\n"
"@SEEALSO=FACT"
msgstr ""
"@FUNCTION=FACTDOUBLE\n"
"@SYNTAX=FACTDOUBLE(número)\n"
"@DESCRIPTION=La función FACTDOUBLE devuelve el factorial doble de un "
"@número, por ejemplo, x!!.\n"
"\n"
"* Si el @número no es un entero, se trunca.\n"
"* Si el @número es negativo, FACTDOUBLE devuelve el error #NÚM!.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"FACTDOUBLE(5) es igual a 15.\n"
"\n"
"@SEEALSO=FACT"

#: ../plugins/fn-math/functions.c:1876
msgid ""
"@FUNCTION=FIB\n"
"@SYNTAX=FIB(number)\n"
"@DESCRIPTION=FIB function computes Fibonacci numbers.\n"
"\n"
"* If @number is not an integer, it is truncated.\n"
"* If @number is negative or zero FIB returns #NUM! error.\n"
"\n"
"@EXAMPLES=\n"
"FIB(12) equals 144.\n"
"\n"
"@SEEALSO="
msgstr ""
"@FUNCTION=FIB\n"
"@SYNTAX=FIB(número)\n"
"@DESCRIPTION=La función FIB calcula la serie de Fibonacci.\n"
"\n"
"* Si el @número no es un entero, se trunca. \n"
"* Si el @número es negativo o cero, FIB devuelve el error #NÚM!.\n"
"\n"
"@EXAMPLES=\n"
"FIB(12) es igual a 144.\n"
"\n"
"@SEEALSO="

#: ../plugins/fn-math/functions.c:1927
msgid ""
"@FUNCTION=QUOTIENT\n"
"@SYNTAX=QUOTIENT(numerator,denominator)\n"
"@DESCRIPTION=QUOTIENT function returns the integer portion of a division.  "
"@numerator is the divided number and @denominator is the divisor.\n"
"\n"
"* This function is Excel compatible.\n"
" \n"
"@EXAMPLES=\n"
"QUOTIENT(23,5) equals 4.\n"
"\n"
"@SEEALSO=MOD"
msgstr ""
"@FUNCTION=QUOTIENT\n"
"@SYNTAX=QUOTIENT(numerador,denominador)\n"
"@DESCRIPTION=La función QUOTIENT devuelve la porción entera de la división. "
"@numerador es el número dividido y @denominador es el divisor.\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"QUOTIENT(23,5) es igual a 4.\n"
"\n"
"@SEEALSO=MOD"

#: ../plugins/fn-math/functions.c:1960
msgid ""
"@FUNCTION=SIGN\n"
"@SYNTAX=SIGN(number)\n"
"@DESCRIPTION=SIGN function returns 1 if the @number is positive, zero if the "
"@number is 0, and -1 if the @number is negative.\n"
"\n"
"* This function is Excel compatible.\n"
" \n"
"@EXAMPLES=\n"
"SIGN(3) equals 1.\n"
"SIGN(-3) equals -1.\n"
"SIGN(0) equals 0.\n"
"\n"
"@SEEALSO="
msgstr ""
"@FUNCTION=SIGN\n"
"@SYNTAX=SIGN(número)\n"
"@DESCRIPTION=La función SIGN devuelve 1 si el @número es positivo, cero si "
"se trata de 0, y -1 si el @número es negativo.\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"SIGN(3) es igual a 1.\n"
"SIGN(-3) es igual a -1.\n"
"SIGN(0) es igual a 0.\n"
"\n"
"@SEEALSO="

#: ../plugins/fn-math/functions.c:1995
msgid ""
"@FUNCTION=SQRTPI\n"
"@SYNTAX=SQRTPI(number)\n"
"@DESCRIPTION=SQRTPI function returns the square root of a @number multiplied "
"by pi.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"SQRTPI(2) equals 2.506628275.\n"
"\n"
"@SEEALSO=PI"
msgstr ""
"@FUNCTION=SQRTPI\n"
"@SYNTAX=SQRTPI(número)\n"
"@DESCRIPTION=Devuelve la raíz cuadrada de un @número multiplicado por pi.\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"SQRTPI(2) es igual a 2,506628275.\n"
"\n"
"@SEEALSO=PI"

#: ../plugins/fn-math/functions.c:2026
msgid ""
"@FUNCTION=ROUNDDOWN\n"
"@SYNTAX=ROUNDDOWN(number[,digits])\n"
"@DESCRIPTION=ROUNDDOWN function rounds a given @number towards 0.\n"
"\n"
"@number is the number you want rounded toward 0 and @digits is the number of "
"digits to which you want to round that number.\n"
"\n"
"* If @digits is greater than zero, @number is rounded toward 0 to the given "
"number of digits.\n"
"* If @digits is zero or omitted, @number is rounded toward 0 to the next "
"integer.\n"
"* If @digits is less than zero, @number is rounded toward 0 to the left of "
"the decimal point.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"ROUNDDOWN(5.5) equals 5.\n"
"ROUNDDOWN(-3.3) equals -3.\n"
"ROUNDDOWN(1501.15,1) equals 1501.1.\n"
"ROUNDDOWN(1501.15,-2) equals 1500.0.\n"
"\n"
"@SEEALSO=ROUND,ROUNDUP"
msgstr ""
"@FUNCTION=ROUNDDOWN\n"
"@SYNTAX=ROUNDDOWN(número[,cifras])\n"
"@DESCRIPTION=Redondea inferiormente el @número dado. @número es el número "
"que desea redondear y @cifras es la cantidad de cifras significativas a la "
"cual quiere redondearlo.\n"
"\n"
"* Si @cifras > 0, @número es redondeado inferiormente hasta una cantidad de "
"cifras decimales significativas de @cifras.\n"
"* Si @cifras = 0 o se omite, el número es redondeado al entero más cercano.\n"
"* Si @cifras < 0, @número se redondea hacia abajo a la izquierda de la coma "
"decimal.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"ROUNDDOWN(5.5) es igual 5.\n"
"ROUNDDOWN(-3.3) es igual a -4.\n"
"ROUNDDOWN(1501.15,1) es igual a 1501,1.\n"
"ROUNDDOWN(1501.15,-2) es igual a 1500.0.\n"
"\n"
"@SEEALSO=ROUND,ROUNDUP"

#: ../plugins/fn-math/functions.c:2063
msgid ""
"@FUNCTION=ROUND\n"
"@SYNTAX=ROUND(number[,digits])\n"
"@DESCRIPTION=ROUND function rounds a given number.\n"
"\n"
"@number is the number you want rounded and @digits is the number of digits "
"to which you want to round that number.\n"
"\n"
"* If @digits is greater than zero, @number is rounded to the given number of "
"digits.\n"
"* If @digits is zero or omitted, @number is rounded to the nearest integer.\n"
"* If @digits is less than zero, @number is rounded to the left of the "
"decimal point.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"ROUND(5.5) equals 6.\n"
"ROUND(-3.3) equals -3.\n"
"ROUND(1501.15,1) equals 1501.2.\n"
"ROUND(1501.15,-2) equals 1500.0.\n"
"\n"
"@SEEALSO=ROUNDDOWN,ROUNDUP"
msgstr ""
"@FUNCTION=ROUND\n"
"@SYNTAX=ROUND(número[;cifras])\n"
"@DESCRIPTION=Redondea el número dado.\n"
"\n"
"@número es el número que desea redondear y @cifras es la cantidad de cifras "
"significativas a la cual quiere redondearlo.\n"
"\n"
"* Si @cifras > 0, @número es redondeado hasta una cantidad de cifras "
"decimales significativas de @cifras.\n"
"* Si @cifras = 0, o se omite, el número es redondeado al entero más "
"próximo.\n"
"* Si @cifras < 0, indica las cifras a la izquierda del punto decimal, que se "
"desea redondear.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"ROUND(5,5) es igual a 6.\n"
"ROUND(-3,3) es igual a -3.\n"
"ROUND(1501,15;1) es igual a 1501,2.\n"
"ROUND(1501,15;-2) es igual a 1500,0.\n"
"\n"
"@SEEALSO=ROUNDDOWN,ROUNDUP"

#: ../plugins/fn-math/functions.c:2117
msgid ""
"@FUNCTION=ROUNDUP\n"
"@SYNTAX=ROUNDUP(number[,digits])\n"
"@DESCRIPTION=ROUNDUP function rounds a given number away from 0.\n"
"\n"
"@number is the number you want rounded away from 0 and @digits is the number "
"of digits to which you want to round that number.\n"
"\n"
"* If @digits is greater than zero, @number is rounded away from 0 to the "
"given number of digits.\n"
"* If @digits is zero or omitted, @number is rounded away from 0 to the next "
"integer.\n"
"* If @digits is less than zero, @number is rounded away from 0 to the left "
"of the decimal point.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"ROUNDUP(5.5) equals 6.\n"
"ROUNDUP(-3.3) equals -4.\n"
"ROUNDUP(1501.15,1) equals 1501.2.\n"
"ROUNDUP(1501.15,-2) equals 1600.0.\n"
"\n"
"@SEEALSO=ROUND,ROUNDDOWN"
msgstr ""
"@FUNCTION=ROUNDUP\n"
"@SYNTAX=ROUNDUP(número[,cifras])\n"
"@DESCRIPTION=Redondea superiormente el número dado\n"
"\n"
"@número es el número que desea redondear y @cifras es la cantidad de cifras "
"significativas a la cual quiere redondearlo.\n"
"\n"
"* Si @cifras es superior a cero, @número es redondeado superiormente hasta "
"una cantidad de cifras decimales significativas de @cifras.\n"
"* Si @cifras es cero o se omite, el número es redondeado al entero "
"superior.\n"
"* Si @cifras es negativo, indica las cifras a la izquierda del punto "
"decimal, que se desea redondear superiormente.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"ROUNDUP(5.5) es igual a 6.\n"
"ROUNDUP(-3.3) es igual a -3.\n"
"ROUNDUP(1501.15,1) es igual a 1501.2.\n"
"ROUNDUP(1501.15,-2) es igual a 1600.0.\n"
"\n"
"@SEEALSO=ROUND,ROUNDDOWN"

#: ../plugins/fn-math/functions.c:2178
msgid ""
"@FUNCTION=MROUND\n"
"@SYNTAX=MROUND(number,multiple)\n"
"@DESCRIPTION=MROUND function rounds a given number to the desired multiple.\n"
"\n"
"@number is the number you want rounded and @multiple is the the multiple to "
"which you want to round the number.\n"
"\n"
"* If @number and @multiple have different sign, MROUND returns #NUM! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"MROUND(1.7,0.2) equals 1.8.\n"
"MROUND(321.123,0.12) equals 321.12.\n"
"\n"
"@SEEALSO=ROUNDDOWN,ROUND,ROUNDUP"
msgstr ""
"@FUNCTION=MROUND\n"
"@SYNTAX=MROUND(número,múltiple)\n"
"@DESCRIPTION=Redondea el número dado @número al múltiplo de @múltiple más "
"cercano.\n"
"\n"
"* Si @número y @múltiple son de signos contrarios, MROUND devuelve el error "
"#NÚM!\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"MROUND(1,7;0,2) es igual a 1,8.\n"
"MROUND(321,123;0,12) es igual a 321,12.\n"
"\n"
"@SEEALSO=ROUNDDOWN,ROUND,ROUNDUP"

#: ../plugins/fn-math/functions.c:2235
msgid ""
"@FUNCTION=ROMAN\n"
"@SYNTAX=ROMAN(number[,type])\n"
"@DESCRIPTION=ROMAN function returns an arabic number in the roman numeral "
"style, as text. @number is the number you want to convert and @type is the "
"type of roman numeral you want.\n"
"\n"
"* If @type is 0 or it is omitted, ROMAN returns classic roman numbers.\n"
"* Type 1 is more concise than classic type, type 2 is more concise than type "
"1, and type 3 is more concise than type 2.  Type 4 is simplified type.\n"
"* If @number is negative or greater than 3999, ROMAN returns #VALUE! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"ROMAN(999) equals CMXCIX.\n"
"ROMAN(999,1) equals LMVLIV.\n"
"ROMAN(999,2) equals XMIX.\n"
"ROMAN(999,3) equals VMIV.\n"
"ROMAN(999,4) equals IM.\n"
"\n"
"@SEEALSO="
msgstr ""
"@FUNCTION=ROMAN\n"
"@SYNTAX=ROMAN(número[;tipo])\n"
"@DESCRIPTION=La función ROMAN devuelve una cifra en números árabes en su "
"representación en números romanos, bajo la forma de una cadena de texto. "
"@número es el número que desea convertir y @tipo es el tipo de números "
"romanos que desea usar. \n"
"\n"
"* Si @tipo es 0 o se omite, ROMAN devuelve números romanos clásicos.\n"
"* Tipo 1 es más conciso que el tipo clásico, el tipo 2 es más conciso que el "
"tipo 1, y el tipo 3 más conciso que el tipo 2. El tipo 4 es un tipo "
"simplificado.\n"
"* Si @número es negativo o superior a 3999, ROMAN devuelve el error "
"#VALOR!.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"ROMAN(999) es igual a CMXCIX.\n"
"ROMAN(999;1) es igual a LMVLIV.\n"
"ROMAN(999;2) es igual a XMIX.\n"
"ROMAN(999;3) es igual a VMIV.\n"
"ROMAN(999;4) es igual a IM.\n"
"\n"
"@SEEALSO="

#: ../plugins/fn-math/functions.c:2500
msgid ""
"@FUNCTION=SUMX2MY2\n"
"@SYNTAX=SUMX2MY2(array1,array2)\n"
"@DESCRIPTION=SUMX2MY2 function returns the sum of the difference of squares "
"of corresponding values in two arrays. @array1 is the first array or range "
"of data points and @array2 is the second array or range of data points. The "
"equation of SUMX2MY2 is SUM (x^2-y^2).\n"
"\n"
"* Strings and empty cells are simply ignored.\n"
"* If @array1 and @array2 have different number of data points, SUMX2MY2 "
"returns #N/A error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11, 15, 17, 21, "
"and 43 and the cells B1, B2, ..., B5 hold numbers 13, 22, 31, 33, and 39.  "
"Then\n"
"SUMX2MY2(A1:A5,B1:B5) equals -1299.\n"
"\n"
"@SEEALSO=SUMSQ,SUMX2PY2"
msgstr ""
"@FUNCTION=SUMX2MY2\n"
"@SYNTAX=SUMX2MY2(array1,array2)\n"
"@DESCRIPTION=Devuelve la suma de la diferencia de los cuadrados de los "
"valores correspondientes de los dos arrays. @array1 es el primer array o "
"rango de datos y @array2 es el segundo array o @rango de datos. La ecuación "
"de SUMX2MY2 es SUM(x^2 - y^2). \n"
"\n"
"* Las cadenas de texto y las celdas vacías son simplemente ignoradas.\n"
"* Si @array1 y @array2 tienen una cantidad diferente de elementos, SUMX2MY2 "
"devuelve el error #N/D.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"Suponiendo que las celdas A1, A2, …, A5 contengan los números 11, 15, 17, "
"21, y 43 y las celdas B1, B2, …, B5 los números 13, 22, 31, 33, y 39. "
"Entonces,\n"
"SUMX2MY2(A1:A5,B1:B5) es igual a -1299.\n"
"\n"
"@SEEALSO=SUMSQ,SUMX2PY2"

#: ../plugins/fn-math/functions.c:2617
msgid ""
"@FUNCTION=SUMX2PY2\n"
"@SYNTAX=SUMX2PY2(array1,array2)\n"
"@DESCRIPTION=SUMX2PY2 function returns the sum of the sum of squares of "
"corresponding values in two arrays. @array1 is the first array or range of "
"data points and @array2 is the second array or range of data points. The "
"equation of SUMX2PY2 is SUM (x^2+y^2).\n"
"\n"
"* Strings and empty cells are simply ignored.\n"
"* If @array1 and @array2 have different number of data points, SUMX2PY2 "
"returns #N/A error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11, 15, 17, 21, "
"and 43 and the cells B1, B2, ..., B5 hold numbers 13, 22, 31, 33, and 39.  "
"Then\n"
"SUMX2PY2(A1:A5,B1:B5) equals 7149.\n"
"\n"
"@SEEALSO=SUMSQ,SUMX2MY2"
msgstr ""
"@FUNCTION=SUMX2PY2\n"
"@SYNTAX=SUMX2PY2(array1,array2)\n"
"@DESCRIPTION=Devuelve la suma de la suma de los cuadrados de los valores "
"correspondientes de los dos arrays. @array1 es el primer array o rango de "
"datos y @array2 es el segundo array o @rango de datos. La ecuación de "
"SUMX2PY2 es SUM(x^2 + y^2).\n"
"\n"
"* Las cadenas de texto y las celdas vacías son simplemente ignoradas.\n"
"* Si @array1 y @array2 tienen una cantidad diferente de elementos, SUMX2PY2 "
"devuelve el error #N/D.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"Suponiendo que las celdas A1, A2, …, A5 contengan los números 11, 15, 17, "
"21, y 43 y las celdas B1, B2, …, B5 los números 13, 22, 31, 33, y 39. "
"Entonces,\n"
"SUMX2PY2(A1:A5,B1:B5) es igual a 7149.\n"
"\n"
"@SEEALSO=SUMSQ,SUMX2MY2"

#: ../plugins/fn-math/functions.c:2731
msgid ""
"@FUNCTION=SUMXMY2\n"
"@SYNTAX=SUMXMY2(array1,array2)\n"
"@DESCRIPTION=SUMXMY2 function returns the sum of squares of differences of "
"corresponding values in two arrays. @array1 is the first array or range of "
"data points and @array2 is the second array or range of data points. The "
"equation of SUMXMY2 is SUM (x-y)^2.\n"
"\n"
"* Strings and empty cells are simply ignored.\n"
"* If @array1 and @array2 have different number of data points, SUMXMY2 "
"returns #N/A error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11, 15, 17, 21, "
"and 43 and the cells B1, B2, ..., B5 hold numbers 13, 22, 31, 33, and 39.  "
"Then\n"
"SUMXMY2(A1:A5,B1:B5) equals 409.\n"
"\n"
"@SEEALSO=SUMSQ,SUMX2MY2,SUMX2PY2"
msgstr ""
"@FUNCTION=SUMXMY2\n"
"@SYNTAX=SUMXMY2(array1,array2)\n"
"@DESCRIPTION=Devuelve la suma de los cuadrados de las diferencias de los "
"valores correspondientes de los dos arrays. @array1 es el primer array o "
"rango de datos y @array2 es el segundo array o @rango de datos. La ecuación "
"de SUMXMY2 es SUM((x - y)^2).\n"
"\n"
"* Las cadenas de texto y las celdas vacías son simplemente ignoradas.\n"
"* Si @array1 y @array2 tienen una cantidad diferente de elementos, SUMXMY2 "
"devuelve el error #N/D.\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"Suponiendo que las celdas A1, A2, …, A5 contengan los números 11, 15, 17, "
"21, y 43 y las celdas B1, B2, …, B5 los números 13, 22, 31, 33, y 39. "
"Entonces\n"
"SUMXMY2(A1:A5,B1:B5) es igual a 409.\n"
"\n"
"@SEEALSO=SUMSQ,SUMX2MY2,SUMX2PY2"

#: ../plugins/fn-math/functions.c:2847
msgid ""
"@FUNCTION=SERIESSUM\n"
"@SYNTAX=SERIESSUM(x,n,m,coefficients)\n"
"@DESCRIPTION=SERIESSUM function returns the sum of a power series.  @x is "
"the base of the power series, @n is the initial power to raise @x, @m is the "
"increment to the power for each term in the series, and @coefficients are "
"the coefficients by which each successive power of @x is multiplied.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1, A2, ..., A5 contain numbers 1.23, 2.32, "
"2.98, 3.42, and 4.33.  Then\n"
"SERIESSUM(3,1,2.23,A1:A5) equals 251416.43018.\n"
"\n"
"@SEEALSO=COUNT,SUM"
msgstr ""
"@FUNCTION=SERIESSUM\n"
"@SYNTAX=SERIESSUM(x,n,m,coeficientes)\n"
"@DESCRIPTION=Devuelve la suma de serie de potencias. @x es la base de la "
"serie, @n es la potencia inicial a la cual elevar @x, @m es el incremento de "
"la potencia para cada término de la serie, y @coeficiente es el coeficiente "
"por el cual se multiplica cada potencia sucesiva de @x .\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"Suponiendo que las celdas A1, A2, …, A5 contengan los números 1.23, 2.32, "
"2.98, 3.42, y 4.33. Entonces\n"
"SERIESSUM(3,1,2.23,A1:A5) es igual a 251416.43018.\n"
"\n"
"@SEEALSO=COUNT,SUM"

#: ../plugins/fn-math/functions.c:2908
msgid ""
"@FUNCTION=MINVERSE\n"
"@SYNTAX=MINVERSE(matrix)\n"
"@DESCRIPTION=MINVERSE function returns the inverse matrix of @matrix.\n"
"\n"
"* If @matrix cannot be inverted, MINVERSE returns #NUM! error.\n"
"* If @matrix does not contain equal number of columns and rows, MINVERSE "
"returns #VALUE! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=MMULT, MDETERM"
msgstr ""
"@FUNCTION=MINVERSE\n"
"@SYNTAX=MINVERSE(matriz)\n"
"@DESCRIPTION=La función MINVERSE devuelve la matriz inversa de la @matriz.\n"
"\n"
"* Si la @matriz no se puede invertir, MINVERSE devuelve el error #NÚM!.\n"
"* Si la @matriz no contiene igual número de filas y columnas, MINVERSE "
"devuelve el error #VALOR!\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=MMULT, MDETERM"

#: ../plugins/fn-math/functions.c:3053
msgid ""
"@FUNCTION=MMULT\n"
"@SYNTAX=MMULT(array1,array2)\n"
"@DESCRIPTION=MMULT function returns the matrix product of two arrays. The "
"result is an array with the same number of rows as @array1 and the same "
"number of columns as @array2.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=TRANSPOSE,MINVERSE"
msgstr ""
"@FUNCTION=MMULT\n"
"@SYNTAX=MMULT(array1;array2)\n"
"@DESCRIPTION=Devuelve la matriz producto de dos arrays. El resultado es una "
"matriz con la misma cantidad de líneas que @array1 y la misma cantidad de "
"columnas que @array2.\n"
"\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=TRANSPOSE,MINVERSE"

#: ../plugins/fn-math/functions.c:3129
msgid ""
"@FUNCTION=MDETERM\n"
"@SYNTAX=MDETERM(matrix)\n"
"@DESCRIPTION=MDETERM function returns the determinant of a given matrix.\n"
"\n"
"* If the @matrix does not contain equal number of columns and rows, MDETERM "
"returns #VALUE! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that A1, ..., A4 contain numbers 2, 3, 7, and 3, B1, ..., B4 "
"4, 2, 4, and 1, C1, ..., C4 9, 4, 3, and 2, and D1, ..., D4 7, 3, 6, and 5. "
"Then\n"
"MDETERM(A1:D4) equals 148.\n"
"\n"
"@SEEALSO=MMULT, MINVERSE"
msgstr ""
"@FUNCTION=MDETERM\n"
"@SYNTAX=MDETERM(matriz)\n"
"@DESCRIPTION=Devuelve el determinante de la @matriz dada.\n"
"\n"
"* Si la @matriz no tiene la misma cantidad de líneas que de columnas MDETERM "
"devuelve el error #VALOR! .\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"Suponiendo que las celdas A1, …, A4 contengan los números 2, 3, 7, y 3, B1, "
"…, B4 4, 2, 4, y 1, C1, …, C4 9, 4, 3, y 2, y D1, …, D4 7, 3, 6, y 5. "
"Entonces,\n"
"MDETERM(A1:D4) es igual a 148.\n"
"\n"
"@SEEALSO=MMULT, MINVERSE"

#: ../plugins/fn-math/functions.c:3178
msgid "SUMPRODUCT:Multiplies components and adds the results."
msgstr "SUMPRODUCT:Multiplica componentes y añade el resultado."

#: ../plugins/fn-math/functions.c:3180
msgid ""
"Multiplies corresponding data entries in the given arrays or ranges, and "
"then returns the sum of those products."
msgstr ""
"Multiplica las entradas de datos correspondientes in los arrays dados o "
"rangos y entonces devuelve la suma de esos productos."

#: ../plugins/fn-math/functions.c:3183
msgid "If an entry is not numeric, the value zero is used instead."
msgstr "Si una entrada no es numérica, se usa el valor cero en su lugar."

#: ../plugins/fn-math/functions.c:3184
msgid ""
"If arrays or range arguments do not have the same dimensions, return #VALUE! "
"error."
msgstr ""
"Si los argumentos arrays o el rangos no tienen la misma dimension, devolver "
"un error #VALOR!"

#: ../plugins/fn-math/functions.c:3186
msgid ""
"SUMPRODUCTs arguments are arrays or ranges. Attempting to use A1:A5>0 will "
"not work, implicit intersection will kick in. Instead use --(A1:A5>0)"
msgstr ""
"Los argumentos de SUMPRODUCTs son arrays o rangos. Si se intenta usar A1:"
"A5>0 no funcionará, la intersección implícita fallará. En su lugar use --(A1:"
"A5>0)"

#: ../plugins/fn-r/functions.c:19
msgid "R.DNORM:probability density function of the normal distribution."
msgstr "R.DNORM:función de densidad de probabilidad de la distribución normal."

#: ../plugins/fn-r/functions.c:20 ../plugins/fn-r/functions.c:45
#: ../plugins/fn-r/functions.c:99 ../plugins/fn-r/functions.c:124
#: ../plugins/fn-r/functions.c:151 ../plugins/fn-r/functions.c:178
#: ../plugins/fn-r/functions.c:203 ../plugins/fn-r/functions.c:257
#: ../plugins/fn-r/functions.c:282 ../plugins/fn-r/functions.c:336
#: ../plugins/fn-r/functions.c:359 ../plugins/fn-r/functions.c:409
#: ../plugins/fn-r/functions.c:434 ../plugins/fn-r/functions.c:461
#: ../plugins/fn-r/functions.c:488 ../plugins/fn-r/functions.c:511
#: ../plugins/fn-r/functions.c:561 ../plugins/fn-r/functions.c:586
#: ../plugins/fn-r/functions.c:640 ../plugins/fn-r/functions.c:663
#: ../plugins/fn-r/functions.c:713 ../plugins/fn-r/functions.c:736
#: ../plugins/fn-r/functions.c:786 ../plugins/fn-r/functions.c:811
#: ../plugins/fn-r/functions.c:838 ../plugins/fn-r/functions.c:865
#: ../plugins/fn-r/functions.c:890 ../plugins/fn-r/functions.c:944
#: ../plugins/fn-r/functions.c:971 ../plugins/fn-r/functions.c:1029
#: ../plugins/fn-r/functions.c:1052 ../plugins/fn-r/functions.c:1102
#: ../plugins/fn-r/functions.c:1127
msgid "x:observation."
msgstr "x:observación."

#: ../plugins/fn-r/functions.c:21 ../plugins/fn-r/functions.c:46
#: ../plugins/fn-r/functions.c:73
msgid "mu:mean of the distribution."
msgstr "mu:media de la distribución."

#: ../plugins/fn-r/functions.c:22 ../plugins/fn-r/functions.c:47
#: ../plugins/fn-r/functions.c:74
msgid "sigma:standard deviation of the distribution."
msgstr "sigma:desviación estándar de la distribución."

#: ../plugins/fn-r/functions.c:23 ../plugins/fn-r/functions.c:102
#: ../plugins/fn-r/functions.c:181 ../plugins/fn-r/functions.c:260
#: ../plugins/fn-r/functions.c:338 ../plugins/fn-r/functions.c:412
#: ../plugins/fn-r/functions.c:490 ../plugins/fn-r/functions.c:564
#: ../plugins/fn-r/functions.c:642 ../plugins/fn-r/functions.c:715
#: ../plugins/fn-r/functions.c:789 ../plugins/fn-r/functions.c:868
#: ../plugins/fn-r/functions.c:948 ../plugins/fn-r/functions.c:1031
#: ../plugins/fn-r/functions.c:1105
msgid ""
"give_log:if true, log of the result will be returned instead.  This is "
"useful if the result would otherwise underflow to 0.  Defaults to false."
msgstr ""
"give_log:si es cierto, se devolverá el logarirmo del resultado en su lugar. "
"Esto es útil se el resultado baja de 0. Predeterminado a falso."

#: ../plugins/fn-r/functions.c:24
msgid ""
"This function returns the probability density function of the normal "
"distribution."
msgstr ""
"Esta función devuelve la función de densidad de probabilidad de la "
"distribución normal."

#: ../plugins/fn-r/functions.c:44
msgid "R.PNORM:cumulative distribution function of the normal distribution."
msgstr "R.PNORM:función de distribución acumulativa de la distribución normal."

#: ../plugins/fn-r/functions.c:48 ../plugins/fn-r/functions.c:75
#: ../plugins/fn-r/functions.c:127 ../plugins/fn-r/functions.c:154
#: ../plugins/fn-r/functions.c:206 ../plugins/fn-r/functions.c:233
#: ../plugins/fn-r/functions.c:285 ../plugins/fn-r/functions.c:312
#: ../plugins/fn-r/functions.c:361 ../plugins/fn-r/functions.c:386
#: ../plugins/fn-r/functions.c:437 ../plugins/fn-r/functions.c:464
#: ../plugins/fn-r/functions.c:513 ../plugins/fn-r/functions.c:538
#: ../plugins/fn-r/functions.c:589 ../plugins/fn-r/functions.c:616
#: ../plugins/fn-r/functions.c:665 ../plugins/fn-r/functions.c:690
#: ../plugins/fn-r/functions.c:738 ../plugins/fn-r/functions.c:763
#: ../plugins/fn-r/functions.c:814 ../plugins/fn-r/functions.c:841
#: ../plugins/fn-r/functions.c:893 ../plugins/fn-r/functions.c:920
#: ../plugins/fn-r/functions.c:975 ../plugins/fn-r/functions.c:1004
#: ../plugins/fn-r/functions.c:1054 ../plugins/fn-r/functions.c:1079
#: ../plugins/fn-r/functions.c:1130 ../plugins/fn-r/functions.c:1157
msgid ""
"lower_tail:if true (the default), the lower tail of the distribution is "
"considered."
msgstr ""
"lower_tail:se es cierto (lo predeterminado), la cola más baja de la "
"distribución es la que se considera."

#: ../plugins/fn-r/functions.c:49 ../plugins/fn-r/functions.c:76
#: ../plugins/fn-r/functions.c:128 ../plugins/fn-r/functions.c:155
#: ../plugins/fn-r/functions.c:207 ../plugins/fn-r/functions.c:234
#: ../plugins/fn-r/functions.c:286 ../plugins/fn-r/functions.c:313
#: ../plugins/fn-r/functions.c:362 ../plugins/fn-r/functions.c:387
#: ../plugins/fn-r/functions.c:438 ../plugins/fn-r/functions.c:465
#: ../plugins/fn-r/functions.c:514 ../plugins/fn-r/functions.c:539
#: ../plugins/fn-r/functions.c:590 ../plugins/fn-r/functions.c:617
#: ../plugins/fn-r/functions.c:666 ../plugins/fn-r/functions.c:691
#: ../plugins/fn-r/functions.c:739 ../plugins/fn-r/functions.c:764
#: ../plugins/fn-r/functions.c:815 ../plugins/fn-r/functions.c:842
#: ../plugins/fn-r/functions.c:894 ../plugins/fn-r/functions.c:921
#: ../plugins/fn-r/functions.c:976 ../plugins/fn-r/functions.c:1005
#: ../plugins/fn-r/functions.c:1055 ../plugins/fn-r/functions.c:1080
#: ../plugins/fn-r/functions.c:1131 ../plugins/fn-r/functions.c:1158
msgid ""
"log_p:if true, log of the probability is used.  This is useful if the "
"probability would otherwise underflow to 0.  Defaults to false."
msgstr ""
"log_p:si es verdadero, se usa el logaritmo de la probabilidad. Esto es útil "
"si la probabilidad de otro modo baja a cero. Lo predeterminado es falso."

#: ../plugins/fn-r/functions.c:50
msgid ""
"This function returns the cumulative distribution function of the normal "
"distribution."
msgstr ""
"Esta función devueleve una distribución acumulada de la distribución normal."

#: ../plugins/fn-r/functions.c:71
msgid "R.QNORM:probability quantile function of the normal distribution."
msgstr "R.QNORM:probabilidad de la función cuantil de la distribución normal."

#: ../plugins/fn-r/functions.c:72 ../plugins/fn-r/functions.c:230
#: ../plugins/fn-r/functions.c:309 ../plugins/fn-r/functions.c:384
#: ../plugins/fn-r/functions.c:536 ../plugins/fn-r/functions.c:613
#: ../plugins/fn-r/functions.c:688 ../plugins/fn-r/functions.c:761
#: ../plugins/fn-r/functions.c:917 ../plugins/fn-r/functions.c:1000
#: ../plugins/fn-r/functions.c:1077 ../plugins/fn-r/functions.c:1154
msgid "p:probability."
msgstr "p:probabilidad."

#: ../plugins/fn-r/functions.c:77
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the normal distribution."
msgstr ""
"Esta función devuelve la función de probabilidad del cuantil, por ejemplo, "
"la inversa de la función de distribución acumulada de la distribución normal."

#: ../plugins/fn-r/functions.c:98
msgid "R.DLNORM:probability density function of the log-normal distribution."
msgstr ""
"R.DLNORM:función de densidad de probabilidad de la distribución log-normal."

#: ../plugins/fn-r/functions.c:100 ../plugins/fn-r/functions.c:125
#: ../plugins/fn-r/functions.c:152
msgid "logmean:mean of the underlying normal distribution."
msgstr "logmean: media de la distribución normal subyacente."

#: ../plugins/fn-r/functions.c:101 ../plugins/fn-r/functions.c:126
#: ../plugins/fn-r/functions.c:153
msgid "logsd:standard deviation of the underlying normal distribution."
msgstr "logsd:desciación estándar de la distribución normal subyacente."

#: ../plugins/fn-r/functions.c:103
msgid ""
"This function returns the probability density function of the log-normal "
"distribution."
msgstr ""
"Esta función devuelve la función de densidad de probabilidad de la "
"distribución log-normal."

#: ../plugins/fn-r/functions.c:123
msgid ""
"R.PLNORM:cumulative distribution function of the log-normal distribution."
msgstr ""
"R.PLNORM:función de distribución acumulada de la distribución log-normal."

#: ../plugins/fn-r/functions.c:129
msgid ""
"This function returns the cumulative distribution function of the log-normal "
"distribution."
msgstr ""
"Esta función devuelve ela función de distribución acumulada de la "
"distribución log-normal."

#: ../plugins/fn-r/functions.c:150
msgid "R.QLNORM:probability quantile function of the log-normal distribution."
msgstr ""
"R.QLNORM:función de cuantil de probabilidad de la distribución log-normal."

#: ../plugins/fn-r/functions.c:156
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the log-normal distribution."
msgstr ""
"Esta función devuelve la función del cuantil de probabilidad, ej, la inversa "
"de la función de distribución acumulada de la distribución log-normal."

#: ../plugins/fn-r/functions.c:177
msgid "R.DGAMMA:probability density function of the gamma distribution."
msgstr "R.DGAMMA:función de densidad de probabilidad de la distribución gamma."

#: ../plugins/fn-r/functions.c:179 ../plugins/fn-r/functions.c:204
#: ../plugins/fn-r/functions.c:231 ../plugins/fn-r/functions.c:562
#: ../plugins/fn-r/functions.c:587 ../plugins/fn-r/functions.c:614
msgid "shape:the shape parameter of the distribution"
msgstr "forma: el parámetro de forma de la distribución"

#: ../plugins/fn-r/functions.c:180 ../plugins/fn-r/functions.c:205
#: ../plugins/fn-r/functions.c:232 ../plugins/fn-r/functions.c:563
#: ../plugins/fn-r/functions.c:588 ../plugins/fn-r/functions.c:615
#: ../plugins/fn-r/functions.c:714 ../plugins/fn-r/functions.c:737
#: ../plugins/fn-r/functions.c:762 ../plugins/fn-r/functions.c:1104
#: ../plugins/fn-r/functions.c:1129 ../plugins/fn-r/functions.c:1156
msgid "scale:the scale parameter of the distribution"
msgstr "escala: el parámetro de escala de la distribución"

#: ../plugins/fn-r/functions.c:182
msgid ""
"This function returns the probability density function of the gamma "
"distribution."
msgstr ""
"Esta función devuelve la función de densidad de probabilidad de la "
"distribución gamma."

#: ../plugins/fn-r/functions.c:202
msgid "R.PGAMMA:cumulative distribution function of the gamma distribution."
msgstr "R.PGAMMA:función de distribución acumulativa de la distribución gamma."

#: ../plugins/fn-r/functions.c:208
msgid ""
"This function returns the cumulative distribution function of the gamma "
"distribution."
msgstr ""
"Esta función devuelve la función de distribución acumulativa de la "
"distribución gamma."

#: ../plugins/fn-r/functions.c:229
msgid "R.QGAMMA:probability quantile function of the gamma distribution."
msgstr "R.QGAMMA:función del cuantil de probabilidad de la distribución gamma."

#: ../plugins/fn-r/functions.c:235
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the gamma distribution."
msgstr ""
"Esta función devuelve la función del cuantil de probabilidad, ej: la inversa "
"del la función de distribución acumulada, de la distribución gamma."

#: ../plugins/fn-r/functions.c:256
msgid "R.DBETA:probability density function of the beta distribution."
msgstr "R.DBETA:función de densidad de probabilidad de la distribución beta."

#: ../plugins/fn-r/functions.c:258 ../plugins/fn-r/functions.c:283
#: ../plugins/fn-r/functions.c:310
msgid "a:the first shape parameter of the distribution"
msgstr "a: el primer parámetro de forma de la distribución"

#: ../plugins/fn-r/functions.c:259 ../plugins/fn-r/functions.c:284
#: ../plugins/fn-r/functions.c:311
msgid "b:the second scale parameter of the distribution"
msgstr "b: El segundo parámetro de escala de la distribución"

#: ../plugins/fn-r/functions.c:261
msgid ""
"This function returns the probability density function of the beta "
"distribution."
msgstr ""
"Esta función devuelve la función de densidad de probabilidad de la "
"distribución beta."

#: ../plugins/fn-r/functions.c:281
msgid "R.PBETA:cumulative distribution function of the beta distribution."
msgstr "R.PBETA:función de distribución acumulada de la distribución beta."

#: ../plugins/fn-r/functions.c:287
msgid ""
"This function returns the cumulative distribution function of the beta "
"distribution."
msgstr ""
"Esta función devuelve la dunción de distribución acumulada de la "
"distribución beta."

#: ../plugins/fn-r/functions.c:308
msgid "R.QBETA:probability quantile function of the beta distribution."
msgstr "R.QBETA:función de cuantil de probabilidad de la distribución beta."

#: ../plugins/fn-r/functions.c:314
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the beta distribution."
msgstr ""
"Esta función devuelve la función del cuantil de probabilidad, ej, la inversa "
"de la función de distribución acumulada, o la distribución beta."

#: ../plugins/fn-r/functions.c:335
msgid "R.DT:probability density function of the Student t distribution."
msgstr ""
"R.DT:función de densidad de probabilidad de la distribución de T Student."

#: ../plugins/fn-r/functions.c:337 ../plugins/fn-r/functions.c:360
#: ../plugins/fn-r/functions.c:385
msgid "n:the number of degrees of freedom of the distribution"
msgstr "n: número de grados de libertad de la distribución"

#: ../plugins/fn-r/functions.c:339
msgid ""
"This function returns the probability density function of the Student t "
"distribution."
msgstr ""
"Esta función devuelve la función de densidad de probabilidad de la "
"distribución de T Student."

#: ../plugins/fn-r/functions.c:358
msgid "R.PT:cumulative distribution function of the Student t distribution."
msgstr ""
"R.PT:función de distribución acumulada de la distrivbución de T Student."

#: ../plugins/fn-r/functions.c:363
msgid ""
"This function returns the cumulative distribution function of the Student t "
"distribution."
msgstr ""
"Esta función devuelve la función de distribución acumulada de la "
"distribución de Student T."

#: ../plugins/fn-r/functions.c:383
msgid "R.QT:probability quantile function of the Student t distribution."
msgstr ""
"R.QT:función del cuantil de probabilidad de la distribución de Studen t."

#: ../plugins/fn-r/functions.c:388
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the Student t distribution."
msgstr ""
"Esta función devuelve la función del cuantil de probabilidad, ej, la inversa "
"de la función de distribución acumulada de la distribución de Student t."

#: ../plugins/fn-r/functions.c:408
msgid "R.DF:probability density function of the F distribution."
msgstr "R.DF: función de densidad de probabilidad de la distribución F."

#: ../plugins/fn-r/functions.c:410 ../plugins/fn-r/functions.c:435
#: ../plugins/fn-r/functions.c:462
msgid "n1:the first number of degrees of freedom of the distribution"
msgstr "n1:el primer número de grados de libertad de la distribución"

#: ../plugins/fn-r/functions.c:411 ../plugins/fn-r/functions.c:436
#: ../plugins/fn-r/functions.c:463
msgid "n2:the second number of degrees of freedom of the distribution"
msgstr "n2: el segundo número de grados de libertad de la distribución"

#: ../plugins/fn-r/functions.c:413
msgid ""
"This function returns the probability density function of the F distribution."
msgstr ""
"Esta función devuelve la función de densidad de probabilidad de la "
"distribución de F."

#: ../plugins/fn-r/functions.c:433
msgid "R.PF:cumulative distribution function of the F distribution."
msgstr "R.PF: función de distribucion acumulada de la distribución F."

#: ../plugins/fn-r/functions.c:439
msgid ""
"This function returns the cumulative distribution function of the F "
"distribution."
msgstr ""
"Esta función devuelve la función de distribución acumulativa de la "
"distribución F."

#: ../plugins/fn-r/functions.c:460
msgid "R.QF:probability quantile function of the F distribution."
msgstr "R.QF:función de cuantil de probabilidad de la distribución F."

#: ../plugins/fn-r/functions.c:466
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the F distribution."
msgstr ""
"Esta función devuelve la función del cuantil de probabilidad, la inversa de "
"la función de distribución acumulada, de la distribución F."

#: ../plugins/fn-r/functions.c:487
msgid "R.DCHISQ:probability density function of the chi-square distribution."
msgstr ""
"R.DCHISQ:función de densidad de probabilidad de la distribución chi cuadrado."

#: ../plugins/fn-r/functions.c:489 ../plugins/fn-r/functions.c:512
#: ../plugins/fn-r/functions.c:537
msgid "df:the number of degrees of freedom of the distribution"
msgstr "df:el número de grados de libertad de la distribución"

#: ../plugins/fn-r/functions.c:491
msgid ""
"This function returns the probability density function of the chi-square "
"distribution."
msgstr ""
"Esta función devuelve la función de densidad de probabilidad de la "
"distribución chi-cuadrado."

#: ../plugins/fn-r/functions.c:510
msgid ""
"R.PCHISQ:cumulative distribution function of the chi-square distribution."
msgstr ""
"R.PCHISQ:función de distribución acumulada de la distribución chi-cuadrado."

#: ../plugins/fn-r/functions.c:515
msgid ""
"This function returns the cumulative distribution function of the chi-square "
"distribution."
msgstr ""
"Esta función devuelve la función de distribución acumulada de la "
"distribución chi-cuadrado."

#: ../plugins/fn-r/functions.c:535
msgid "R.QCHISQ:probability quantile function of the chi-square distribution."
msgstr ""
"R.QCHISQ:función del cuantil de probabilidad de la distribución chi "
"cuadarado."

#: ../plugins/fn-r/functions.c:540
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the chi-square distribution."
msgstr ""
"Esta función devuelve la función del cuantil de probabilidad, ej, la inversa "
"de la función de distribución acumulada, de la distribución chi cuadrado."

#: ../plugins/fn-r/functions.c:560
msgid "R.DWEIBULL:probability density function of the Weibull distribution."
msgstr ""
"R.DWEIBULL:función de densidad de probabilidad de la distribución de Weibull."

#: ../plugins/fn-r/functions.c:565
msgid ""
"This function returns the probability density function of the Weibull "
"distribution."
msgstr ""
"Esta función devuelve la función de densidad de probabilidad de la "
"distribución de Weibull."

#: ../plugins/fn-r/functions.c:585
msgid ""
"R.PWEIBULL:cumulative distribution function of the Weibull distribution."
msgstr ""
"R.PWEIBULL:función acumulada de distribución de la distribución de Weibull."

#: ../plugins/fn-r/functions.c:591
msgid ""
"This function returns the cumulative distribution function of the Weibull "
"distribution."
msgstr ""
"Esta función devuelve la función de distribución acumulada de la "
"distribución de Weibull."

#: ../plugins/fn-r/functions.c:612
msgid "R.QWEIBULL:probability quantile function of the Weibull distribution."
msgstr ""
"R.QWEIBULL:función del cuantil de probabilidad de la distribución de Weibull."

#: ../plugins/fn-r/functions.c:618
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the Weibull distribution."
msgstr ""
"Esta función devuelve la función del cuantil de probabilidad, la función "
"inversa de la distribución acumulada de la distribución de Weibull."

#: ../plugins/fn-r/functions.c:639
msgid "R.DPOIS:probability density function of the Poisson distribution."
msgstr ""
"R.DPOIS:función de densidad de probabilidad de la distribución de Poisson."

#: ../plugins/fn-r/functions.c:641 ../plugins/fn-r/functions.c:664
#: ../plugins/fn-r/functions.c:689
msgid "lambda:the mean of the distribution"
msgstr "lambda:la media de la distribución"

#: ../plugins/fn-r/functions.c:643
msgid ""
"This function returns the probability density function of the Poisson "
"distribution."
msgstr ""
"Esta función devuelve la función de densidad de probabilidad de la "
"distribución de Poisson."

#: ../plugins/fn-r/functions.c:662
msgid "R.PPOIS:cumulative distribution function of the Poisson distribution."
msgstr ""
"R.PPOIS:función de distribución acumulada de la distribución de Poisson."

#: ../plugins/fn-r/functions.c:667
msgid ""
"This function returns the cumulative distribution function of the Poisson "
"distribution."
msgstr ""
"Esta función devuelve la función de distribución acumulada de la "
"distribución de Poisson."

#: ../plugins/fn-r/functions.c:687
msgid "R.QPOIS:probability quantile function of the Poisson distribution."
msgstr ""
"R.QPOIS:función del cualtil de probabilidad de la distribución de Poisson."

#: ../plugins/fn-r/functions.c:692
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the Poisson distribution."
msgstr ""
"Esta función devuelve la función del cuantil de probabilidad, la función "
"inversa de la función de distribución acumulada, de la distribución de "
"Poisson."

#: ../plugins/fn-r/functions.c:712
msgid "R.DEXP:probability density function of the exponential distribution."
msgstr ""
"R.DEXP:función de densidad de probabilidad de la distribución exponencial."

#: ../plugins/fn-r/functions.c:716
msgid ""
"This function returns the probability density function of the exponential "
"distribution."
msgstr ""
"Esta función devuelve la función de densidad de probabilidad de la "
"distribución exponencial"

#: ../plugins/fn-r/functions.c:735
msgid ""
"R.PEXP:cumulative distribution function of the exponential distribution."
msgstr ""
"R.PEXP:función de distribución acumulada de la distribución exponencial."

#: ../plugins/fn-r/functions.c:740
msgid ""
"This function returns the cumulative distribution function of the "
"exponential distribution."
msgstr ""
"Esta función devuelve la función de distribución acumulada de la "
"distribución exponencial."

#: ../plugins/fn-r/functions.c:760
msgid "R.QEXP:probability quantile function of the exponential distribution."
msgstr ""
"R.QEXP:función del cuantil de probabilidad de la distribución exponencial."

#: ../plugins/fn-r/functions.c:765
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the exponential distribution."
msgstr ""
"Esta función devuelve la funcio del cuantil de probabilidad , la inversa de "
"la función de distribución acumulada, de la distribución exponencial."

#: ../plugins/fn-r/functions.c:785
msgid "R.DBINOM:probability density function of the binomial distribution."
msgstr ""
"R.DBINOM:función que devuelve la función de densidad de probabilidad de la "
"distribución binomial."

#: ../plugins/fn-r/functions.c:787 ../plugins/fn-r/functions.c:812
#: ../plugins/fn-r/functions.c:839 ../plugins/fn-r/functions.c:866
#: ../plugins/fn-r/functions.c:891 ../plugins/fn-r/functions.c:918
msgid "n:the number of trials"
msgstr "n:el número de intentos"

#: ../plugins/fn-r/functions.c:788 ../plugins/fn-r/functions.c:813
#: ../plugins/fn-r/functions.c:840 ../plugins/fn-r/functions.c:867
#: ../plugins/fn-r/functions.c:892 ../plugins/fn-r/functions.c:919
#: ../plugins/fn-r/functions.c:1030 ../plugins/fn-r/functions.c:1053
#: ../plugins/fn-r/functions.c:1078
msgid "psuc:the probability of success in each trial"
msgstr "psuc:la probabilidad de éxito en cada intento"

#: ../plugins/fn-r/functions.c:790
msgid ""
"This function returns the probability density function of the binomial "
"distribution."
msgstr ""
"Esta función devuelve la función de densidad de probabilidad de la "
"distribución binomial."

#: ../plugins/fn-r/functions.c:810
msgid "R.PBINOM:cumulative distribution function of the binomial distribution."
msgstr ""
"R.PBINOM:función de distribución acumulada de la distribución binomial."

#: ../plugins/fn-r/functions.c:816
msgid ""
"This function returns the cumulative distribution function of the binomial "
"distribution."
msgstr ""
"Esta función devuelve la función de distribución acumulada de la "
"distribución binomial."

#: ../plugins/fn-r/functions.c:837
msgid "R.QBINOM:probability quantile function of the binomial distribution."
msgstr ""
"R.QBINOM:función del cuantil de probabilidad de la distribución binomial."

#: ../plugins/fn-r/functions.c:843
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the binomial distribution."
msgstr ""
"Esta función devuelve la función del cuantil de probabilidad, la inversa de "
"la función de distribución acumulada, de la distribución binomial."

#: ../plugins/fn-r/functions.c:864
msgid ""
"R.DNBINOM:probability density function of the negative binomial distribution."
msgstr ""
"R.DNBINOM:función de densidad de probabilidad de la distribución binomial "
"negativa."

#: ../plugins/fn-r/functions.c:869
msgid ""
"This function returns the probability density function of the negative "
"binomial distribution."
msgstr ""
"Esta función devuelve la función de densidad de probabilidad de la "
"distribución binomial negativa."

#: ../plugins/fn-r/functions.c:889
msgid ""
"R.PNBINOM:cumulative distribution function of the negative binomial "
"distribution."
msgstr ""
"R.PNBINOM:función de distribución acumulativa de la distribución binomial "
"negativa."

#: ../plugins/fn-r/functions.c:895
msgid ""
"This function returns the cumulative distribution function of the negative "
"binomial distribution."
msgstr ""
"Esta función devuelve la distribución acumulada negativa de la distribución "
"binomial negativa."

#: ../plugins/fn-r/functions.c:916
msgid ""
"R.QNBINOM:probability quantile function of the negative binomial "
"distribution."
msgstr ""
"R.QNBINOM:función del cuantil de probabilidad de la distribución binomial "
"negativa."

#: ../plugins/fn-r/functions.c:922
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the negative binomial "
"distribution."
msgstr ""
"Esta función devuelve la función del cuantil de probabilidad, la inversa de "
"la función acumulada de distribución de la distribución negativa binomial."

#: ../plugins/fn-r/functions.c:943
msgid ""
"R.DHYPER:probability density function of the hypergeometric distribution."
msgstr ""
"R.DHYPER:función de densidad de probabilidad de la distribución "
"hipergeométrica."

#: ../plugins/fn-r/functions.c:945 ../plugins/fn-r/functions.c:972
#: ../plugins/fn-r/functions.c:1001
msgid "r:the number of red balls"
msgstr "r:el número de bolas rojas"

#: ../plugins/fn-r/functions.c:946 ../plugins/fn-r/functions.c:973
#: ../plugins/fn-r/functions.c:1002
msgid "b:the number of black balls"
msgstr "b:el número de bolas negras"

#: ../plugins/fn-r/functions.c:947 ../plugins/fn-r/functions.c:974
#: ../plugins/fn-r/functions.c:1003
msgid "n:the number of balls drawn"
msgstr "n:el número de bolas dibujadas"

#: ../plugins/fn-r/functions.c:949
msgid ""
"This function returns the probability density function of the hypergeometric "
"distribution."
msgstr ""
"Esta función devuelve la función de densidad de probabilidad de la "
"distribución hipergeométrica."

#: ../plugins/fn-r/functions.c:970
msgid ""
"R.PHYPER:cumulative distribution function of the hypergeometric distribution."
msgstr ""
"R.PHYPER:función de distribución acumulada de la distribución "
"hipergeométrica."

#: ../plugins/fn-r/functions.c:977
msgid ""
"This function returns the cumulative distribution function of the "
"hypergeometric distribution."
msgstr ""
"Esta función devuelve la función de de distribución acumulada de la "
"distribución hipergeométrica."

#: ../plugins/fn-r/functions.c:999
msgid ""
"R.QHYPER:probability quantile function of the hypergeometric distribution."
msgstr ""
"R.QHYPER:función de cuantil de probabilidad de la distribución "
"hipergeométrica."

#: ../plugins/fn-r/functions.c:1006
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the hypergeometric distribution."
msgstr ""
"Esta función devuelve la función del cuantil de probabilidad, ej, la inversa "
"de la función de distribución acumulada, o la distribución hipergeométrica."

#: ../plugins/fn-r/functions.c:1028
msgid "R.DGEOM:probability density function of the geometric distribution."
msgstr ""
"R.DGEOM:función de densidad de probabilidad de la distribución geométrica."

#: ../plugins/fn-r/functions.c:1032
msgid ""
"This function returns the probability density function of the geometric "
"distribution."
msgstr ""
"Esta función devuelve la función de densidad de probabilidad de la "
"distribución geométrica."

#: ../plugins/fn-r/functions.c:1051
msgid "R.PGEOM:cumulative distribution function of the geometric distribution."
msgstr ""
"R.PGEOM:función de distribución acumulativa de la distribución geométrica."

#: ../plugins/fn-r/functions.c:1056
msgid ""
"This function returns the cumulative distribution function of the geometric "
"distribution."
msgstr ""
"Esta función devuelve la función de distribución acumulativa de la "
"distribución geométrica."

#: ../plugins/fn-r/functions.c:1076
msgid "R.QGEOM:probability quantile function of the geometric distribution."
msgstr ""
"R.QGEOM: función del cuantil de probabilidad de la distribución geométrica."

#: ../plugins/fn-r/functions.c:1081
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the geometric distribution."
msgstr ""
"Esta función devuelve la función del cuantil de probabilidad, o sea, la "
"inversa de la función de distribución acumulada, de la distribución "
"geométrica."

#: ../plugins/fn-r/functions.c:1101
msgid "R.DCAUCHY:probability density function of the Cauchy distribution."
msgstr ""
"R.DCAUCHY:función de densidad de probabilidad de la distribución de Cauchy."

#: ../plugins/fn-r/functions.c:1103 ../plugins/fn-r/functions.c:1128
#: ../plugins/fn-r/functions.c:1155
msgid "location:the center of the distribution"
msgstr "ubicación: el centro de la distribución"

#: ../plugins/fn-r/functions.c:1106
msgid ""
"This function returns the probability density function of the Cauchy "
"distribution."
msgstr ""
"Esta función devuelve la función de densidad de probabilidad de la "
"distribución de Cauchy."

#: ../plugins/fn-r/functions.c:1126
msgid "R.PCAUCHY:cumulative distribution function of the Cauchy distribution."
msgstr ""
"R.PCAUCHY:función de distribución acumulada  de la distribución de Cauchy."

#: ../plugins/fn-r/functions.c:1132
msgid ""
"This function returns the cumulative distribution function of the Cauchy "
"distribution."
msgstr ""
"Esta función devuelve la función de distribución acumulada de la "
"distribución de Cauchy."

#: ../plugins/fn-r/functions.c:1153
msgid "R.QCAUCHY:probability quantile function of the Cauchy distribution."
msgstr ""
"R.QCAUCHY:función de cuantil de probabilidad de la distribución de Cauchy."

#: ../plugins/fn-r/functions.c:1159
msgid ""
"This function returns the probability quantile function, i.e., the inverse "
"of the cumulative distribution function, of the Cauchy distribution."
msgstr ""
"Esta función devuelve la función del cuantil de probablidada, ejm el inverso "
"de la función de distribución acumulada, de la distribución de Cauchy."

#: ../plugins/fn-r/functions.c:1194
msgid "x,mu,sigma,give_log"
msgstr "x,mu,sigma,give_log"

#: ../plugins/fn-r/functions.c:1202
msgid "x,mu,sigma,lower_tail,log_p"
msgstr "x,mu,sigma,lower_tail,log_p"

#: ../plugins/fn-r/functions.c:1210
msgid "p,mu,sigma,lower_tail,log_p"
msgstr "p,mu,sigma,lower_tail,log_p"

#: ../plugins/fn-r/functions.c:1218
msgid "x,logmean,logsd,give_log"
msgstr "x,logmean,logsd,give_log"

#: ../plugins/fn-r/functions.c:1226 ../plugins/fn-r/functions.c:1234
msgid "x,logmean,logsd,lower_tail,log_p"
msgstr "x,logmean,logsd,lower_tail,log_p"

#: ../plugins/fn-r/functions.c:1242 ../plugins/fn-r/functions.c:1362
msgid "x,shape,scale,give_log"
msgstr "x,shape,scale,give_log"

#: ../plugins/fn-r/functions.c:1250 ../plugins/fn-r/functions.c:1370
msgid "x,shape,scale,lower_tail,log_p"
msgstr "x,shape,scale,lower_tail,log_p"

#: ../plugins/fn-r/functions.c:1258 ../plugins/fn-r/functions.c:1378
msgid "p,shape,scale,lower_tail,log_p"
msgstr "p,shape,scale,lower_tail,log_p"

#: ../plugins/fn-r/functions.c:1266
msgid "x,a,b,give_log"
msgstr "x,a,b,give_log"

#: ../plugins/fn-r/functions.c:1274
msgid "x,a,b,lower_tail,log_p"
msgstr "x,a,b,lower_tail,log_p"

#: ../plugins/fn-r/functions.c:1282
msgid "p,a,b,lower_tail,log_p"
msgstr "p,a,b,lower_tail,log_p"

#: ../plugins/fn-r/functions.c:1290
msgid "x,n,give_log"
msgstr "x,n,give_log"

#: ../plugins/fn-r/functions.c:1298
msgid "x,n,lower_tail,log_p"
msgstr "x,n,lower_tail,log_p"

#: ../plugins/fn-r/functions.c:1306
msgid "p,n,lower_tail,log_p"
msgstr "p,n,lower_tail,log_p"

#: ../plugins/fn-r/functions.c:1314
msgid "x,n1,n2,give_log"
msgstr "x,n1,n2,give_log"

#: ../plugins/fn-r/functions.c:1322 ../plugins/fn-r/functions.c:1330
msgid "x,n1,n2,lower_tail,log_p"
msgstr "x,n1,n2,lower_tail,log_p"

#: ../plugins/fn-r/functions.c:1338
msgid "x,df,give_log"
msgstr "x,df,give_log"

#: ../plugins/fn-r/functions.c:1346
msgid "x,df,lower_tail,log_p"
msgstr "x,df,lower_tail,log_p"

#: ../plugins/fn-r/functions.c:1354
msgid "p,df,lower_tail,log_p"
msgstr "p,df,lower_tail,log_p"

#: ../plugins/fn-r/functions.c:1386
msgid "x,lambda,give_log"
msgstr "x,lambda,give_log"

#: ../plugins/fn-r/functions.c:1394
msgid "x,lambda,lower_tail,log_p"
msgstr "x,lambda,lower_tail,log_p"

#: ../plugins/fn-r/functions.c:1402
msgid "p,lambda,lower_tail,log_p"
msgstr "p,lambda,lower_tail,log_p"

#: ../plugins/fn-r/functions.c:1410
msgid "x,scale,give_log"
msgstr "x,scale,give_log"

#: ../plugins/fn-r/functions.c:1418
msgid "x,scale,lower_tail,log_p"
msgstr "x,scale,lower_tail,log_p"

#: ../plugins/fn-r/functions.c:1426
msgid "p,scale,lower_tail,log_p"
msgstr "p,scale,lower_tail,log_p"

#: ../plugins/fn-r/functions.c:1434 ../plugins/fn-r/functions.c:1458
msgid "x,n,psuc,give_log"
msgstr "x,n,psuc,give_log"

#: ../plugins/fn-r/functions.c:1442 ../plugins/fn-r/functions.c:1450
#: ../plugins/fn-r/functions.c:1466
msgid "x,n,psuc,lower_tail,log_p"
msgstr "x,n,psuc,lower_tail,log_p"

#: ../plugins/fn-r/functions.c:1474
msgid "p,n,psuc,lower_tail,log_p"
msgstr "p,n,psuc,lower_tail,log_p"

#: ../plugins/fn-r/functions.c:1482
msgid "x,r,b,n,give_log"
msgstr "x,r,b,n,give_log"

#: ../plugins/fn-r/functions.c:1490
msgid "x,r,b,n,lower_tail,log_p"
msgstr "x,r,b,n,lower_tail,log_p"

#: ../plugins/fn-r/functions.c:1498
msgid "p,r,b,n,lower_tail,log_p"
msgstr "p,r,b,n,cola_menor,log_p"

#: ../plugins/fn-r/functions.c:1506
msgid "x,psuc,give_log"
msgstr "x,psuc,give_log"

#: ../plugins/fn-r/functions.c:1514
msgid "x,psuc,lower_tail,log_p"
msgstr "x,psuc,lower_tail,log_p"

#: ../plugins/fn-r/functions.c:1522
msgid "p,psuc,lower_tail,log_p"
msgstr "p,psuc,lower_tail,log_p"

#: ../plugins/fn-r/functions.c:1530
msgid "x,location,scale,give_log"
msgstr "x,location,scale,give_log"

#: ../plugins/fn-r/functions.c:1538
msgid "x,location,scale,lower_tail,log_p"
msgstr "x,location,scale,lower_tail,log_p"

#: ../plugins/fn-r/functions.c:1546
msgid "p,location,scale,lower_tail,log_p"
msgstr "p,location,scale,lower_tail,log_p"

#: ../plugins/fn-random/functions.c:47
msgid ""
"@FUNCTION=RAND\n"
"@SYNTAX=RAND()\n"
"@DESCRIPTION=RAND returns a random number between zero and one.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"RAND() returns a random number greater than zero but less than one.\n"
"\n"
"@SEEALSO=RANDBETWEEN"
msgstr ""
"@FUNCTION=RAND\n"
"@SYNTAX=RAND()\n"
"@DESCRIPTION=Devuelve un número aleatorio entre 0 y 1.\n"
"\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"RAND() devuelve un número aleatorio mayor que 0 y menor que uno.\n"
"\n"
"@SEEALSO=RANDBETWEEN"

#: ../plugins/fn-random/functions.c:73
msgid ""
"@FUNCTION=RANDUNIFORM\n"
"@SYNTAX=RANDUNIFORM(a,b)\n"
"@DESCRIPTION=RANDUNIFORM returns a random variate from the uniform (flat) "
"distribution from a to b. The distribution is,\n"
"\n"
"\tp(x) dx = {1 over (b-a)} dx : for a <= x < b.\n"
"p(x) dx = 0 : for x < a or b <= x.\n"
"* If @a > @b RANDUNIFORM returns #NUM! error.\n"
"\n"
"@EXAMPLES=\n"
"RANDUNIFORM(1.4,4.2) returns a random number greater than or equal to 1.4 "
"but less than 4.2.\n"
"\n"
"@SEEALSO=RANDBETWEEN,RAND"
msgstr ""
"@FUNCTION=RANDUNIFORM\n"
"@SYNTAX=RANDUNIFORM(a,b)\n"
"@DESCRIPTION=Devuelve un número aleatorio variando desde la distribución "
"(plana) desde «a» a «b».\n"
"La distribución es:\n"
"\n"
"\tp(x) dx = {1 elevado a (b-a)} dx : para a <= x <b \n"
"\tp(x) dx = 0 : para x < a o b <= x.\n"
"\n"
"* Si @a > @b RANDUNIFORM devuelve un error #NÚM!\n"
"\n"
"@EXAMPLES=\n"
"RANDUNIFORM(1.4,4.2) devuelve un número aleatorio mayor o igual que 1.4 pero "
"menor que 4.2.\n"
"\n"
"@SEEALSO=RANDBETWEEN,RAND"

#: ../plugins/fn-random/functions.c:108
msgid ""
"@FUNCTION=RANDDISCRETE\n"
"@SYNTAX=RANDDISCRETE(val_range[,prob_range])\n"
"@DESCRIPTION=RANDDISCRETE returns one of the values in the @val_range. The "
"probabilities for each value are given in the @prob_range.\n"
"\n"
"* If @prob_range is omitted, the uniform discrete distribution is assumed.\n"
"* If the sum of all values in @prob_range is other than one, RANDDISCRETE "
"returns #NUM! error.\n"
"* If @val_range and @prob_range are not the same size, RANDDISCRETE returns "
"#NUM! error.\n"
"* If @val_range or @prob_range is not a range, RANDDISCRETE returns #VALUE! "
"error.\n"
"\n"
"@EXAMPLES=\n"
"RANDDISCRETE(A1:A6) returns one of the values in the range A1:A6.\n"
"\n"
"@SEEALSO=RANDBETWEEN,RAND"
msgstr ""
"@FUNCTION=RANDDISCRETE\n"
"@SYNTAX=RANDDISCRETE(rango_val[,rango_prob])\n"
"@DESCRIPTION=RANDDISCRETE devuelve uno de los valores en @rango_val. La "
"probabilidades de cada valor se dan en el @rango_prob.\n"
"\n"
"* Si @rango_prob se omite, se asume la distribución discreta uniforme.\n"
"* Si la suma de todos los valores en @rango_prob es distinta de uno, "
"RANDDISCRETE devuelve el error #NÚM!.\n"
"* Si @rango_val y @rango_prob no son del mismo tamaño, RANDDISCRETE devuelve "
"el error #NÚM!.\n"
"* Si @rango_val o @rango_prob no es un rango, RANDDISCRETE devuelve un error "
"#VALOR!.\n"
"\n"
"@EXAMPLES=\n"
"RANDDISCRETE(A1:A6) devuelve uno de los valores en el rango A1:A6.\n"
"\n"
"@SEEALSO=RANDBETWEEN,RAND"

#: ../plugins/fn-random/functions.c:244
msgid ""
"@FUNCTION=RANDEXP\n"
"@SYNTAX=RANDEXP(b)\n"
"@DESCRIPTION=RANDEXP returns a exponentially-distributed random number.\n"
"\n"
"@EXAMPLES=\n"
"RANDEXP(0.5).\n"
"\n"
"@SEEALSO=RAND,RANDBETWEEN"
msgstr ""
"@FUNCTION=RANDEXP\n"
"@SYNTAX=RANDEXP(b)\n"
"@DESCRIPTION=RANDEXP devuelve un número aleatorio distribuido "
"exponencialmente.\n"
"\n"
"@EXAMPLES=\n"
"RANDEXP(0.5).\n"
"\n"
"@SEEALSO=RAND,RANDBETWEEN"

#: ../plugins/fn-random/functions.c:270
msgid ""
"@FUNCTION=RANDPOISSON\n"
"@SYNTAX=RANDPOISSON(lambda)\n"
"@DESCRIPTION=RANDPOISSON returns a Poisson-distributed random number.\n"
"\n"
"* If @lambda < 0 RANDPOISSON returns #NUM! error.\n"
"\n"
"@EXAMPLES=\n"
"RANDPOISSON(3).\n"
"\n"
"@SEEALSO=RAND,RANDBETWEEN"
msgstr ""
"@FUNCTION=RANDPOISSON\n"
"@SYNTAX=RANDPOISSON(lambda)\n"
"@DESCRIPTION=RANDPOISSON devuelve un número aleatorio distribuido según "
"Poisson. \n"
"\n"
"* Si @lambda < 0 RANDPOISSON devuelve el error #NÚM!\n"
"\n"
"@EXAMPLES=\n"
"RANDPOISSON(3).\n"
"\n"
"@SEEALSO=RAND,RANDBETWEEN"

#: ../plugins/fn-random/functions.c:301
msgid ""
"@FUNCTION=RANDBINOM\n"
"@SYNTAX=RANDBINOM(p,trials)\n"
"@DESCRIPTION=RANDBINOM returns a binomially-distributed random number.\n"
"\n"
"* If @p < 0 or @p > 1 RANDBINOM returns #NUM! error.\n"
"* If @trials < 0 RANDBINOM returns #NUM! error. \n"
"@EXAMPLES=\n"
"RANDBINOM(0.5,2).\n"
"\n"
"@SEEALSO=RAND,RANDBETWEEN"
msgstr ""
"@FUNCTION=RANDBINOM\n"
"@SYNTAX=RANDBINOM(p,intentos)\n"
"@DESCRIPTION=RANDBINOM devuelve un número aleatorio binomialmente "
"distribuido.\n"
"\n"
"* Si @p < 0 ó @p > 1, RANDBINOM devuelve el error #NÚM!.\n"
"* Si @intentos < 0, RANDBINOM devuelve el error #NÚM!. \n"
"\n"
"@EXAMPLES=\n"
"RANDBINOM(0.5,2).\n"
"\n"
"@SEEALSO=RAND,RANDBETWEEN"

#: ../plugins/fn-random/functions.c:334
msgid ""
"@FUNCTION=RANDBETWEEN\n"
"@SYNTAX=RANDBETWEEN(bottom,top)\n"
"@DESCRIPTION=RANDBETWEEN function returns a random integer number between "
"and including @bottom and @top.\n"
"\n"
"* If @bottom is non-integer, it is rounded up.\n"
"* If @top is non-integer, it is rounded down.\n"
"* If @bottom > @top, RANDBETWEEN returns #NUM! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"RANDBETWEEN(3,7).\n"
"\n"
"@SEEALSO=RAND,RANDUNIFORM"
msgstr ""
"@FUNCTION=RANDBETWEEN\n"
"@SYNTAX=RANDBETWEEN(inferior,superior)\n"
"@DESCRIPTION=La función RANDBETWEEN devuelve un entero aleatorio entre "
"@inferior y @superior ambos inclusive.\n"
"\n"
"* Si @inferior no es entero, se redondea arriba.\n"
"* Si @superior no es un entero de redondea abajo.\n"
"* Si @inferior > @superior, RANDBETWEEN de vuelve el error #NÚM!\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"RANDBETWEEN(3,7).\n"
"\n"
"@SEEALSO=RAND,RANDUNIFORM"

#: ../plugins/fn-random/functions.c:374
msgid ""
"@FUNCTION=RANDNEGBINOM\n"
"@SYNTAX=RANDNEGBINOM(p,failures)\n"
"@DESCRIPTION=RANDNEGBINOM returns a negative binomially-distributed random "
"number.\n"
"\n"
"* If @p < 0 or @p > 1, RANDNEGBINOM returns #NUM! error.\n"
"* If @failures < 1, RANDNEGBINOM returns #NUM! error.\n"
"\n"
"@EXAMPLES=\n"
"RANDNEGBINOM(0.5,2).\n"
"\n"
"@SEEALSO=RAND,RANDBETWEEN"
msgstr ""
"@FUNCTION=RANDNEGBINOM\n"
"@SYNTAX=RANDNEGBINOM(p,fallos)\n"
"@DESCRIPTION=RANDNEGBINOM devuelve un número aleatorio binomialmente "
"distribuido negativo. \n"
"\n"
"* Si @p < 0 ó @p > 1, RANDNEGBINOM devuelve el error #NÚM!.\n"
"* Si @fallos < 1, RANDNEGBINOM devuelve el error #NÚM!. \n"
"\n"
"@EXAMPLES=\n"
"RANDNEGBINOM(0.5,2).\n"
"\n"
"@SEEALSO=RAND,RANDBETWEEN"

#: ../plugins/fn-random/functions.c:408
msgid ""
"@FUNCTION=RANDBERNOULLI\n"
"@SYNTAX=RANDBERNOULLI(p)\n"
"@DESCRIPTION=RANDBERNOULLI returns a Bernoulli-distributed random number.\n"
"\n"
"* If @p < 0 or @p > 1 RANDBERNOULLI returns #NUM! error.\n"
"\n"
"@EXAMPLES=\n"
"RANDBERNOULLI(0.5).\n"
"\n"
"@SEEALSO=RAND,RANDBETWEEN"
msgstr ""
"@FUNCTION=RANDBERNOULLI\n"
"@SYNTAX=RANDBERNOULLI(p)\n"
"@DESCRIPTION=RANDBERNOULLI devuelve un número aleatorio distribuido según "
"Bernuolli.\n"
"\n"
"* Si @p < 0 ó @p > 1, RANDBERNUOLLI devuelve el error #NÚM!. \n"
"\n"
"@EXAMPLES=\n"
"RANDBERNOULLI(0.5).\n"
"\n"
"@SEEALSO=RAND,RANDBETWEEN"

#: ../plugins/fn-random/functions.c:439
msgid ""
"@FUNCTION=RANDNORM\n"
"@SYNTAX=RANDNORM(mean,stdev)\n"
"@DESCRIPTION=RANDNORM returns a normal-distributed random number.\n"
"\n"
"* If @stdev < 0 RANDNORM returns #NUM! error.\n"
"\n"
"@EXAMPLES=\n"
"RANDNORM(0,1).\n"
"\n"
"@SEEALSO=RAND"
msgstr ""
"@FUNCTION=RANDNORM\n"
"@SYNTAX=RANDNORM(media,desvst)\n"
"@DESCRIPTION=RANDNORM devuelve un número aleatorio distribuido según una "
"distribución gaussiana.\n"
"\n"
"* Si @desvst < 0 RANDNORM devuelve el error #NÚM!.\n"
"\n"
"@EXAMPLES=\n"
"RANDNORM(0,1).\n"
"\n"
"@SEEALSO=RAND"

#: ../plugins/fn-random/functions.c:471
msgid ""
"@FUNCTION=RANDCAUCHY\n"
"@SYNTAX=RANDCAUCHY(a)\n"
"@DESCRIPTION=RANDCAUCHY returns a Cauchy-distributed random number with "
"scale parameter a. The Cauchy distribution is also known as the Lorentz "
"distribution.\n"
"\n"
"* If @a < 0 RANDCAUCHY returns #NUM! error.\n"
"\n"
"@EXAMPLES=\n"
"RANDCAUCHY(1).\n"
"\n"
"@SEEALSO=RAND"
msgstr ""
"@FUNCTION=RANDCAUCHY\n"
"@SYNTAX=RANDCAUCHY(a)\n"
"@DESCRIPTION=RANDCAUCHY devuelve un número aleatorio según la distribución "
"de Cauchy con parámetro de escala a. La distribución de Cauchy también es "
"conocida como la distribución de Lorentz.\n"
"\n"
"* Si @a < 0 RANDCAUCHY devuelve el error #NÚM!.\n"
"\n"
"@EXAMPLES=\n"
"RANDCAUCHY(1).\n"
"\n"
"@SEEALSO=RAND"

#: ../plugins/fn-random/functions.c:504
msgid ""
"@FUNCTION=RANDLOGNORM\n"
"@SYNTAX=RANDLOGNORM(zeta,sigma)\n"
"@DESCRIPTION=RANDLOGNORM returns a lognormal-distributed random number.\n"
"\n"
"@EXAMPLES=\n"
"RANDLOGNORM(1,2).\n"
"\n"
"@SEEALSO=RAND"
msgstr ""
"@FUNCTION=RANDLOGNORM\n"
"@SYNTAX=RANDLOGNORM(zeta,sigma)\n"
"@DESCRIPTION=RANDLOGNORM devuelve un número aleatorio según una distribución "
"normal-logarítmica.\n"
"\n"
"@EXAMPLES=\n"
"RANDLOGNORM(1,2).\n"
"\n"
"@SEEALSO=RAND"

#: ../plugins/fn-random/functions.c:531
msgid ""
"@FUNCTION=RANDWEIBULL\n"
"@SYNTAX=RANDWEIBULL(a,b)\n"
"@DESCRIPTION=RANDWEIBULL returns a Weibull-distributed random number.\n"
"\n"
"@EXAMPLES=\n"
"RANDWEIBULL(1,2).\n"
"\n"
"@SEEALSO=RAND"
msgstr ""
"@FUNCTION=RANDWEIBULL\n"
"@SYNTAX=RANDWEIBULL(a,b)\n"
"@DESCRIPTION=RANDWEIBULL devuelve un número aleatorio según una distribución "
"Weibull.\n"
"\n"
"@EXAMPLES=\n"
"RANDWEIBULL(1,2).\n"
"\n"
"@SEEALSO=RAND"

#: ../plugins/fn-random/functions.c:558
msgid ""
"@FUNCTION=RANDLAPLACE\n"
"@SYNTAX=RANDLAPLACE(a)\n"
"@DESCRIPTION=RANDLAPLACE returns a Laplace-distributed random number. "
"Laplace distribution is also known as two-sided exponential probability "
"distribution.\n"
"\n"
"@EXAMPLES=\n"
"RANDLAPLACE(1).\n"
"\n"
"@SEEALSO=RAND"
msgstr ""
"@FUNCTION=RANDLAPLACE\n"
"@SYNTAX=RANDLAPLACE(a)\n"
"@DESCRIPTION=RANDLAPLACE devuelve un número aleatorio según la distribución "
"de Laplace. La distribución de Laplace es también conocida como distribución "
"de probabilidad exponencial doble.\n"
"\n"
"@EXAMPLES=\n"
"RANDLAPLACE(1).\n"
"\n"
"@SEEALSO=RAND"

#: ../plugins/fn-random/functions.c:586
msgid ""
"@FUNCTION=RANDRAYLEIGH\n"
"@SYNTAX=RANDRAYLEIGH(sigma)\n"
"@DESCRIPTION=RANDRAYLEIGH returns a Rayleigh-distributed random number.\n"
"\n"
"@EXAMPLES=\n"
"RANDRAYLEIGH(1).\n"
"\n"
"@SEEALSO=RAND"
msgstr ""
"@FUNCTION=RANDRAYLEIGH\n"
"@SYNTAX=RANDRAYLEIGH(sigma)\n"
"@DESCRIPTION=RANDRAYLEIGH devuelve un número aleatorio según la distribución "
"de Rayleigh\n"
"\n"
"@EXAMPLES=\n"
"RANDRAYLEIGH(1).\n"
"\n"
"@SEEALSO=RAND"

#: ../plugins/fn-random/functions.c:612
msgid ""
"@FUNCTION=RANDRAYLEIGHTAIL\n"
"@SYNTAX=RANDRAYLEIGHTAIL(a,sigma)\n"
"@DESCRIPTION=RANDRAYLEIGHTAIL returns  a random variate from the tail of the "
"Rayleigh distribution with scale parameter sigma and a lower limit of a. The "
"distribution is,\n"
"\n"
"\tp(x) dx = {x over sigma^2} exp ((a^2 - x^2) /(2 sigma^2)) dx,\n"
"\n"
"for x > a.\n"
"\n"
"@EXAMPLES=\n"
"RANDRAYLEIGHTAIL(0.3,1).\n"
"\n"
"@SEEALSO=RAND,RANDRAYLEIGH"
msgstr ""
"@FUNCTION=RANDRAYLEIGHTAIL\n"
"@SYNTAX=RANDRAYLEIGHTAIL(a,sigma)\n"
"@DESCRIPTION=RANDRAYLEIGHTAIL devuelve una variación aleatoria de la cola de "
"una distribución Rayleigh con parámetro de escala @sigma y límite inferior "
"@a. La distribución es:\n"
"\n"
"\tp(x) dx = {x sobre sigma^2} exp ((a^2 - x^2) /(2 sigma^2)) dx,\n"
"\n"
"para x > a.\n"
"\n"
"@EXAMPLES=\n"
"RANDRAYLEIGHTAIL(0.3,1).\n"
"\n"
"@SEEALSO=RAND,RANDRAYLEIGH"

#: ../plugins/fn-random/functions.c:643
msgid ""
"@FUNCTION=RANDGAMMA\n"
"@SYNTAX=RANDGAMMA(a,b)\n"
"@DESCRIPTION=RANDGAMMA returns a Gamma-distributed random number.\n"
"\n"
"* If @a <= 0 RANDGAMMA returns #NUM! error.\n"
"\n"
"@EXAMPLES=\n"
"RANDGAMMA(1,2).\n"
"\n"
"@SEEALSO=RAND"
msgstr ""
"@FUNCTION=RANDGAMMA\n"
"@SYNTAX=RANDGAMMA(a,b)\n"
"@DESCRIPTION=RANDGAMMA devuelve un número aleatorio según una distribución "
"Gamma.\n"
"\n"
"* Si @a <= 0 RANDGAMMA devuelve el error #NÚM!.\n"
"\n"
"@EXAMPLES=\n"
"RANDGAMMA(1,2).\n"
"\n"
"@SEEALSO=RAND"

#: ../plugins/fn-random/functions.c:675
msgid ""
"@FUNCTION=RANDPARETO\n"
"@SYNTAX=RANDPARETO(a,b)\n"
"@DESCRIPTION=RANDPARETO returns a Pareto-distributed random number.\n"
"\n"
"@EXAMPLES=\n"
"RANDPARETO(1,2).\n"
"\n"
"@SEEALSO=RAND"
msgstr ""
"@FUNCTION=RANDPARETO\n"
"@SYNTAX=RANDPARETO(a,b)\n"
"@DESCRIPTION=RANDPARETO devuelve un número aleatorio distribuido según "
"Pareto.\n"
"\n"
"@EXAMPLES=\n"
"RANDPARETO(1,2).\n"
"\n"
"@SEEALSO=RAND"

#: ../plugins/fn-random/functions.c:702
msgid ""
"@FUNCTION=RANDFDIST\n"
"@SYNTAX=RANDFDIST(nu1,nu2)\n"
"@DESCRIPTION=RANDFDIST returns a F-distributed random number.\n"
"\n"
"@EXAMPLES=\n"
"RANDFDIST(1,2).\n"
"\n"
"@SEEALSO=RAND,RANDGAMMA"
msgstr ""
"@FUNCTION=RANDFDIST\n"
"@SYNTAX=RANDFDIST(nu1,nu2)\n"
"@DESCRIPTION=RANDFDIST devuelve un número aleatorio F-distribuido.\n"
"\n"
"@EXAMPLES=\n"
"RANDFDIST(1,2).\n"
"\n"
"@SEEALSO=RAND,RANDGAMMA"

#: ../plugins/fn-random/functions.c:729
msgid ""
"@FUNCTION=RANDBETA\n"
"@SYNTAX=RANDBETA(a,b)\n"
"@DESCRIPTION=RANDBETA returns a Beta-distributed random number.\n"
"\n"
"@EXAMPLES=\n"
"RANDBETA(1,2).\n"
"\n"
"@SEEALSO=RAND,RANDGAMMA"
msgstr ""
"@FUNCTION=RANDBETA\n"
"@SYNTAX=RANDBETA(a,b)\n"
"@DESCRIPTION=RANDBETA devuelve un número aleatorio Beta- distribuido.\n"
"\n"
"@EXAMPLES=\n"
"RANDBETA(1,2).\n"
"\n"
"@SEEALSO=RAND,RANDGAMMA"

#: ../plugins/fn-random/functions.c:756
msgid ""
"@FUNCTION=RANDLOGISTIC\n"
"@SYNTAX=RANDLOGISTIC(a)\n"
"@DESCRIPTION=RANDLOGISTIC returns a logistic-distributed random number.  The "
"distribution function is,\n"
"\n"
"\tp(x) dx = { exp(-x/a) over a (1 + exp(-x/a))^2 } dx for -infty < x < "
"+infty.\n"
"\n"
"@EXAMPLES=\n"
"RANDLOGISTIC(1).\n"
"\n"
"@SEEALSO=RAND"
msgstr ""
"@FUNCTION=RANDLOGISTIC\n"
"@SYNTAX=RANDLOGISTIC(a)\n"
"@DESCRIPTION=RANDLOGISTIC devuelve un número aleatorio logísticamente "
"distribuido. La función de distribución es:\n"
"\n"
"\tp(x) dx = { exp(-x/a) sobre (1 + exp(-x/a))^2 } dx para -inf < x < +inf.\n"
"\n"
"@EXAMPLES=\n"
"RANDLOGISTIC(1).\n"
"\n"
"@SEEALSO=RAND"

#: ../plugins/fn-random/functions.c:785
msgid ""
"@FUNCTION=RANDGEOM\n"
"@SYNTAX=RANDGEOM(p)\n"
"@DESCRIPTION=RANDGEOM returns a geometric-distributed random number. The "
"number of independent trials with probability @p until the first success. "
"The probability distribution for geometric variates is, \n"
"\n"
"\tp(k) =  p (1-p)^(k-1), for k >= 1.\n"
"\n"
"* If @p < 0 or @p > 1 RANDGEOM returns #NUM! error. \n"
"@EXAMPLES=\n"
"RANDGEOM(0.4).\n"
"\n"
"@SEEALSO=RAND"
msgstr ""
"@FUNCTION=RANDGEOM\n"
"@SYNTAX=RANDGEOM(p)\n"
"@DESCRIPTION=RANDGEOM devuelve un número aleatorio geométricamente "
"distribuido. El número de intentos independientes con probabilidad @p hasta "
"el primer éxito. La distribución de probabilidad para variaciones "
"geométricas es:\n"
"\n"
"\tp(k) = p (1-p)^(k-1), para k >= 1.\n"
"\n"
"* Si @p < 0 o @p > 1 RANDGEOM devuelve un error #NÚM!. \n"
"\n"
"@EXAMPLES=\n"
"RANDGEOM(0.4).\n"
"\n"
"@SEEALSO=RAND"

#: ../plugins/fn-random/functions.c:819
msgid ""
"@FUNCTION=RANDHYPERG\n"
"@SYNTAX=RANDHYPERG(n1,n2,t)\n"
"@DESCRIPTION=RANDHYPERG returns a hypergeometric-distributed random number. "
"The probability distribution for hypergeometric random variates is,\n"
"\n"
"\tp(k) =  C(n_1,k) C(n_2, t-k) / C(n_1 + n_2,k), \n"
"\n"
"where C(a,b) = a!/(b!(a-b)!). \n"
"\n"
"The domain of k is max(0,t-n_2), ..., max(t,n_1).\n"
"@EXAMPLES=\n"
"RANDHYPERG(21,1,9).\n"
"\n"
"@SEEALSO=RAND"
msgstr ""
"@FUNCTION=RANDHYPERG\n"
"@SYNTAX=RANDHYPERG(n1,n2,t)\n"
"@DESCRIPTION=RANDHYPERG devuelve un número aleatorio según una distribución "
"hipergeométrica. La distribución de probabilidades para una variación "
"hipergeométrica aleatoria es:\n"
"\n"
"\tp(k) = C(n_1,k) C(n_2, t-k) / C(n_1 + n_2,k), \n"
"\n"
"donde C(a,b) = a!/(b!(a-b)!). \n"
"\n"
"El dominio de k es max(0,t-n_2), …, max(t,n_1).\n"
"@EXAMPLES=\n"
"RANDHYPERG(21,1,9).\n"
"\n"
"@SEEALSO=RAND"

#: ../plugins/fn-random/functions.c:854
msgid ""
"@FUNCTION=RANDLOG\n"
"@SYNTAX=RANDLOG(p)\n"
"@DESCRIPTION=RANDLOG returns a logarithmic-distributed random number.\n"
"\n"
"* If @p < 0 or @p > 1 RANDLOG returns #NUM! error.\n"
"\n"
"@EXAMPLES=\n"
"RANDLOG(0.72).\n"
"\n"
"@SEEALSO=RAND"
msgstr ""
"@FUNCTION=RANDLOG\n"
"@SYNTAX=RANDLOG(p)\n"
"@DESCRIPTION=RANDLOG devuelve un número aleatorio logarítmicamente "
"distribuido.\n"
"\n"
"* Si @p < 0 o @p > 1 RANDLOG devuelve un error #NÚM!\n"
"\n"
"@EXAMPLES=\n"
"RANDLOG(0.72).\n"
"\n"
"@SEEALSO=RAND"

#: ../plugins/fn-random/functions.c:885
msgid ""
"@FUNCTION=RANDCHISQ\n"
"@SYNTAX=RANDCHISQ(nu)\n"
"@DESCRIPTION=RANDCHISQ returns a Chi-Square-distributed random number.\n"
"\n"
"@EXAMPLES=\n"
"RANDCHISQ(0.5).\n"
"\n"
"@SEEALSO=RAND,RANDGAMMA"
msgstr ""
"@FUNCTION=RANDCHISQ\n"
"@SYNTAX=RANDCHISQ(nu)\n"
"@DESCRIPTION=RANDCHISQ devuelve un número aleatorio distribuido según chi-"
"cuadrado.\n"
"\n"
"@EXAMPLES=\n"
"RANDCHISQ(0.5).\n"
"\n"
"@SEEALSO=RAND,RANDGAMMA"

#: ../plugins/fn-random/functions.c:911
msgid ""
"@FUNCTION=RANDTDIST\n"
"@SYNTAX=RANDTDIST(nu)\n"
"@DESCRIPTION=RANDTDIST returns a T-distributed random number.\n"
"\n"
"@EXAMPLES=\n"
"RANDTDIST(0.5).\n"
"\n"
"@SEEALSO=RAND"
msgstr ""
"@FUNCTION=RANDTDIST\n"
"@SYNTAX=RANDTDIST(nu)\n"
"@DESCRIPTION=RANDTDIST devuelve un número aleatorio T distribuido.\n"
"\n"
"@EXAMPLES=\n"
"RANDTDIST(0.5).\n"
"\n"
"@SEEALSO=RAND"

#: ../plugins/fn-random/functions.c:937
msgid ""
"@FUNCTION=RANDGUMBEL\n"
"@SYNTAX=RANDGUMBEL(a,b[,type])\n"
"@DESCRIPTION=RANDGUMBEL returns a Type I or Type II Gumbel-distributed "
"random number. @type is either 1 or 2 and specifies the type of the "
"distribution (Type I or Type II).\n"
"\n"
"* If @type is neither 1 nor 2, RANDGUMBEL returns #NUM! error.\n"
"* If @type is omitted, Type I is assumed.\n"
"\n"
"@EXAMPLES=\n"
"RANDGUMBEL(0.5,1,2).\n"
"\n"
"@SEEALSO=RAND"
msgstr ""
"@FUNCTION=RANDGUMBEL\n"
"@SYNTAX=RANDGUMBEL(a,b[,tipo])\n"
"@DESCRIPTION=RANDGUMBEL devuelve un número aleatorio según una distribución "
"de Tipo I o Tipo II de Gumbel. @tipo es o 1 o 2 y especifica el tipo de "
"distribución (Tipo II o Tipo II).\n"
"\n"
"* Si @tipo no es 1 o 2, RANDGUMBEL devuelve un error #NÚM!\n"
"* Si @tipo se omite, se asume Tipo I.\n"
"\n"
"@EXAMPLES=\n"
"RANDGUMBEL(0.5,1,2).\n"
"\n"
"@SEEALSO=RAND"

#: ../plugins/fn-random/functions.c:975
msgid ""
"@FUNCTION=RANDLEVY\n"
"@SYNTAX=RANDLEVY(c,alpha[,beta])\n"
"@DESCRIPTION=RANDLEVY returns a Levy-distributed random number. If @beta is "
"omitted, it is assumed to be 0.\n"
"\n"
"* For @alpha = 1, @beta=0, we get the Lorentz distribution.\n"
"* For @alpha = 2, @beta=0, we get the normal distribution.\n"
"\n"
"* If @alpha <= 0 or @alpha > 2, RANDLEVY returns #NUM! error.\n"
"* If @beta < -1 or @beta > 1, RANDLEVY returns #NUM! error.\n"
"\n"
"@EXAMPLES=\n"
"RANDLEVY(0.5,0.1,1).\n"
"\n"
"@SEEALSO=RAND"
msgstr ""
"@FUNCTION=RANDLEVY\n"
"@SYNTAX=RANDLEVY(c,alfa[,beta])\n"
"@DESCRIPTION=RANDLEVY devuelve un número aleatorio distribuido según Levy. "
"Si se omite @beta, se asume que es 0.\n"
"\n"
"* Para alfa = 1, beta=0, se obtiene la distribución de Lorentz.\n"
"* Para alfa = 2, beta=0, se obtiene la distribución de Gauss.\n"
"\n"
"* Si @alfa <= 0 o @alfa > 2, RANDLEVY devuelve un error #NÚM!\n"
"* Si @beta < -1 o @beta > 1, RANDLEVY devuelve un error #NÚM!\n"
"\n"
"@EXAMPLES=\n"
"RANDLEVY(0.5,0.1,1).\n"
"\n"
"@SEEALSO=RAND"

#: ../plugins/fn-random/functions.c:1013
msgid ""
"@FUNCTION=RANDEXPPOW\n"
"@SYNTAX=RANDEXPPOW(a,b)\n"
"@DESCRIPTION=RANDEXPPOW returns a random variate from the exponential power "
"distribution with scale parameter @a and exponent @b. The distribution is,\n"
"\n"
"\tp(x) dx = {1 over 2 a Gamma(1+1/b)} exp(-|x/a|^b) dx, for x >= 0.\n"
"\n"
"* For @b = 1 this reduces to the Laplace distribution.\n"
"* For @b = 2 it has the same form as a normal distribution with sigma = a/"
"sqrt(2).\n"
"\n"
"@EXAMPLES=\n"
"RANDEXPPOW(0.5,0.1).\n"
"\n"
"@SEEALSO=RAND"
msgstr ""
"@FUNCTION=RANDEXPPOW\n"
"@SYNTAX=RANDEXPPOW(a,b)\n"
"@DESCRIPTION=RANDEXPPOW devuelve una variación aleatoria de la distribución "
"exponencial con parámetro de escala @a y exponente @b. La distribución es,\n"
"\n"
"\tp(x) dx = {1 sobre 2 a Gamma(1+1/b)} exp(-|x/a|^b) dx, para x >= 0.\n"
"\n"
"* Para @b = 1 esto se reduce a la distribución de Laplace.\n"
"* Para @b = 2 esto tiene la misma forma que una distribución gaussiana, pero "
"con sigma = a/ sqrt(2).\n"
"\n"
"@EXAMPLES=\n"
"RANDEXPPOW(0.5,0.1).\n"
"\n"
"@SEEALSO=RAND"

#: ../plugins/fn-random/functions.c:1047
msgid ""
"@FUNCTION=RANDLANDAU\n"
"@SYNTAX=RANDLANDAU()\n"
"@DESCRIPTION=RANDLANDAU returns a random variate from the Landau "
"distribution. The probability distribution for Landau random variates is "
"defined analytically by the complex integral,\n"
"\n"
"\tp(x) = (1/(2 pi i)) int_{c-i infty}^{c+i infty} ds exp(s log(s) + x s).\n"
"\n"
"For numerical purposes it is more convenient to use the following equivalent "
"form of the integral,\n"
"\n"
"\tp(x) = (1/pi) int_0^ infty dt exp(-t log(t) - x t) sin(pi t).\n"
"\n"
"@EXAMPLES=\n"
"RANDLANDAU().\n"
"\n"
"@SEEALSO=RAND"
msgstr ""
"@FUNCTION=RANDLANDAU\n"
"@SYNTAX=RANDLANDAU()\n"
"@DESCRIPTION=RANDLANDAU devuelve una variación aleatoria de una distribución "
"Landau. La distribución de probabilidad para la variaciones Landau "
"aleatorias se definen analíticamente por la integral compleja:\n"
"\n"
"\tp(x) = (1/(2 pi i)) int_{c-i infty}^{c+i infty} ds exp(s log(s) + x s).\n"
"\n"
"Para propósitos numéricos es más conveniente usar la siguiente forma "
"equivalente de la integral:\n"
"\n"
"\tp(x) = (1/pi) int_0^ infty dt exp(-t log(t) - x t) sin(pi t).\n"
"\n"
"@EXAMPLES=\n"
"RANDLANDAU().\n"
"\n"
"@SEEALSO=RAND"

#: ../plugins/fn-random/functions.c:1078
msgid ""
"@FUNCTION=RANDNORMTAIL\n"
"@SYNTAX=RANDNORMTAIL(a,sigma)\n"
"@DESCRIPTION=RANDNORMTAIL returns a random variates from the upper tail of a "
"normal distribution with standard deviation @sigma. The values returned are "
"larger than the lower limit @a, which must be positive. The method is based "
"on Marsaglia's famous rectangle-wedge-tail algorithm (Ann Math Stat 32, 894-"
"899 (1961)), with this aspect explained in Knuth, v2, 3rd ed, p139, 586 "
"(exercise 11).\n"
"\n"
"The probability distribution for normal tail random variates is,\n"
"\n"
"\tp(x) dx = {1 over N(a;sigma)} exp (- x^2/(2 sigma^2)) dx,\n"
"\n"
"for x > a where N(a;sigma) is the normalization constant, N(a;sigma) = (1/2) "
"erfc(a / sqrt(2 sigma^2)).\n"
"\n"
"@EXAMPLES=\n"
"RANDNORMTAIL(0.5,0.1).\n"
"\n"
"@SEEALSO=RAND"
msgstr ""
"@FUNCTION=RANDNORMTAIL\n"
"@SYNTAX=RANDNORMTAIL(a,sigma)\n"
"@DESCRIPTION=RANDNORMTAIL devuelve una variación aleatoria desde la cola "
"superior de una distribución gaussiana con desviación estándar sigma. Los "
"valores devueltos son más grandes que el límite inferior a, que debe ser "
"positivo. El método está basado en el famoso algoritmo rectángulo-borde-cola "
"de Margsalia (Ann Math Stat 32, 894-899 (1961)), con este aspecto explicado "
"en Knuth, v2, 3º ed, p139, 586 (ejercicio 11).\n"
"\n"
"La distribución de probabilidad para una variación de una cola Gaussiana "
"aleatoria es,\n"
"\n"
"\tp(x) dx = {1 over N(a;sigma)} exp (- x^2/(2 sigma^2)) dx,\n"
"\n"
"para x > a donde N(a;sigma) es la constante de normalización, N(a;sigma) = "
"(1/2) erfc(a / sqrt(2 sigma^2)).\n"
"\n"
"@EXAMPLES=\n"
"RANDNORMTAIL(0.5,0.1).\n"
"\n"
"@SEEALSO=RAND"

#: ../plugins/fn-random/functions.c:1117
msgid ""
"@FUNCTION=SIMTABLE\n"
"@SYNTAX=SIMTABLE(d1, d2, ..., dN)\n"
"@DESCRIPTION=SIMTABLE returns one of the values in the given argument list "
"depending on the round number of the simulation tool. When the simulation "
"tool is not activated, SIMTABLE returns @d1.\n"
"\n"
"With the simulation tool and the SIMTABLE function you can test given "
"decision variables. Each SIMTABLE function contains the possible values of a "
"simulation variable. In most valid simulation models you should have the "
"same number of values @dN for all decision variables.  If the simulation is "
"run more rounds than there are values defined, SIMTABLE returns #N/A! error "
"(e.g. if A1 contains `=SIMTABLE(1)' and A2 `=SIMTABLE(1,2)', A1 yields #N/A! "
"error on the second round).\n"
"\n"
"The successive use of the simulation tool also requires that you give to the "
"tool at least one input variable having RAND() or any other "
"RAND<distribution name>() function in it. On each round, the simulation tool "
"iterates for the given number of rounds over all the input variables to "
"reevaluate them. On each iteration, the values of the output variables are "
"stored, and when the round is completed, descriptive statistical information "
"is created according to the values.\n"
"\n"
"@EXAMPLES=\n"
"SIMTABLE(TRUE,FALSE) returns TRUE on the first simulation round and FALSE on "
"the second round.\n"
"SIMTABLE(223,225,227,229) returns 227 on the simulation round #3.\n"
"\n"
"@SEEALSO="
msgstr ""
"@FUNCTION=SIMTABLE\n"
"@SYNTAX=SIMTABLE(d1, d2, …, dN)\n"
"@DESCRIPTION=SIMTABLE devuelve uno de los valores en la lista de argumentos "
"dada dependiendo del redondeo de la herramienta de simulación. Cuando la "
"herramienta de simulación no es activada, SIMTABLE devuelve @d1.\n"
"\n"
"Con la herramienta de simulación y la función SIMTABLE puede probar "
"variables de decisión dadas. Cada función SIMTABLE contiene los posibles "
"valores de una variable de simulación. En la mayoría de los modelos de "
"simulación debería haber el mismo número de valores @dN para todas las "
"variables de decisión. Si la simulación se ejecuta más veces que los valores "
"que están definidos, SIMTABLE devuelve un error #N/A! (ej: si A1 contiene "
"`=SIMTABLE(1)' y A2 `=SIMTABLE(1,2)', A1 da un error #N/A! la segunda "
"ronda).\n"
"\n"
"El uso sucesivo de la herramienta de simulación también requiere que le dé a "
"la herramienta al menos una variable de entrada teniendo RAND() o cualquier "
"otra función RAND<nombre de distribución>() en ella. En cada ronda, la "
"herramienta de simulación itera el número dado de veces por las variables de "
"entrada para reevaluarlas. En cada iteración, los valores de las variables "
"de salida se almacenasen, y cuando la ronda termina, se crea información "
"estadística descriptiva de acuerdo con los valores.\n"
"\n"
"@EXAMPLES=\n"
"SIMTABLE(VERDADERO,FALSO) devuelve VERDADERO en la primera ronda de "
"simulación y FALSO en la segunda ronda.\n"
"SIMTABLE(223,225,227,229) devuelve 227 en la ronda de simulación #3.\n"
"\n"
"@SEEALSO="

#: ../plugins/fn-stat/functions.c:65
msgid ""
"@FUNCTION=VARP\n"
"@SYNTAX=VARP(b1, b2, ...)\n"
"@DESCRIPTION=VARP calculates the variance of an entire population.\n"
"VARP is also known as the N-variance.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
"21.3, 25.9, and 40.1.  Then\n"
"VARP(A1:A5) equals 94.112.\n"
"\n"
"@SEEALSO=AVERAGE,DVAR,DVARP,STDEV,VAR"
msgstr ""
"@FUNCTION=VARP\n"
"@SYNTAX=VARP(b1, b2, …)\n"
"@DESCRIPTION=VARP calcula la varianza de un conjunto de números, cada número "
"es el miembro de una población.\n"
"VARP también se conoce como N-varianza.\n"
"\n"
"@EXAMPLES=\n"
"Suponiendo que las celdas A1, A2, …, A5 contengan los números 11.4, 17.3, "
"21.3, 25.9 y 40.1. Entonces,\n"
"VARP(A1:A5) es igual a 94.112.\n"
"\n"
"@SEEALSO=AVERAGE,DVAR,DVARP,STDEV,VAR"

#: ../plugins/fn-stat/functions.c:97
msgid ""
"@FUNCTION=VAR\n"
"@SYNTAX=VAR(b1, b2, ...)\n"
"@DESCRIPTION=VAR calculates sample variance of the given sample. To get the "
"true variance of a complete population use VARP.\n"
"VAR is also known as the N-1-variance. Under reasonable conditions, it is "
"the maximum-likelihood estimator for the true variance.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
"21.3, 25.9, and 40.1.  Then\n"
"VAR(A1:A5) equals 117.64.\n"
"\n"
"@SEEALSO=VARP,STDEV"
msgstr ""
"@FUNCTION=VAR\n"
"@SYNTAX=VAR(b1, b2, …)\n"
"@DESCRIPTION=VAR estima la varianza de una muestra de población. Para "
"obtener la varianza real de una población completa, use @VARP.\n"
"* VAR también se conoce como varianza-N-1. En condiciones razonables, es el "
"estimador de bondad máximo de la verdadera varianza.\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"Supongamos que las celdas A1, A2, …, A5 contienen los números 11.4, 17.3, "
"21.3, 25.9, y 40.1. Entonces\n"
"VAR(A1:A5) igual a 117,64.\n"
"\n"
"@SEEALSO=VARP,STDEV"

#: ../plugins/fn-stat/functions.c:134
msgid ""
"@FUNCTION=STDEV\n"
"@SYNTAX=STDEV(b1, b2, ...)\n"
"@DESCRIPTION=STDEV returns the sample standard deviation of the given "
"sample.\n"
"To obtain the population standard deviation of a whole population use "
"STDEVP.\n"
"STDEV is also known as the N-1-standard deviation.\n"
"Under reasonable conditions, it is the maximum-likelihood estimator for the "
"true population standard deviation.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
"21.3, 25.9, and 40.1.  Then\n"
"STDEV(A1:A5) equals 10.84619749.\n"
"\n"
"@SEEALSO=AVERAGE,DSTDEV,DSTDEVP,STDEVA,STDEVPA,VAR"
msgstr ""
"@FUNCTION=STDEV\n"
"@SYNTAX=STDEV(b1, b2, …)\n"
"@DESCRIPTION=STDEV estima la desviación estándar de la muestra dada. Para "
"obtener la desviación de población estándar de una población completa use "
"STDEVP.\n"
"\n"
"STDEV también se conoce como la desviación estándar-N-1.\n"
". En condiciones razonables, es el estimador de bondad máximo de la "
"verdadera desviación estándar de la población.\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"Supongamos que las celdas A1, A2, …, A5 contienen los números 11.4, 17.3, "
"21.3, 25.9, y 40.1. Entonces\n"
"STDEV(A1:A5) igual a 10,84619749.\n"
"\n"
"@SEEALSO=VARP,STDEV"

#: ../plugins/fn-stat/functions.c:173
msgid ""
"@FUNCTION=STDEVP\n"
"@SYNTAX=STDEVP(b1, b2, ...)\n"
"@DESCRIPTION=STDEVP returns the population standard deviation of the given "
"population. \n"
"This is also known as the N-standard deviation\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
"21.3, 25.9, and 40.1.  Then\n"
"STDEVP(A1:A5) equals 9.701133954.\n"
"\n"
"@SEEALSO=STDEV,STDEVA,STDEVPA"
msgstr ""
"@FUNCTION=STDEVP\n"
"@SYNTAX=STDEVP(b1, b2, …)\n"
"@DESCRIPTION=STDEVP devuelve la desviación estándar de la población dada.\n"
"Esto se conoce también como la desviación N-Standar.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"Supongamos que las celdas A1, A2, …, A5 contienen los números 11.4, 17.3, "
"21.3, 25.9, y 40.1. Entonces\n"
"STDEVP(A1:A5) igual a 9.701133954.\n"
"\n"
"@SEEALSO=STDEV,STDEVA,STDEVPA"

#: ../plugins/fn-stat/functions.c:207
msgid ""
"@FUNCTION=RANK\n"
"@SYNTAX=RANK(x,ref[,order])\n"
"@DESCRIPTION=RANK returns the rank of a number in a list of numbers.  @x is "
"the number whose rank you want to find, @ref is the list of numbers, and "
"@order specifies how to rank numbers.  If @order is 0, numbers are ranked in "
"descending order, otherwise numbers are ranked in ascending order.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
"21.3, 25.9, and 40.1.  Then\n"
"RANK(17.3,A1:A5) equals 4.\n"
"\n"
"@SEEALSO=PERCENTRANK"
msgstr ""
"@FUNCTION=RANK\n"
"@SYNTAX=RANK(x,ref[,orden])\n"
"@DESCRIPTION=RANK devuelve la clasificación de un número en una lista de "
"números. @x es el número cuya clasificación quiere encontrar,@ref es la "
"lista de números y @orden especifica cómo clasificar los números. Si @orden "
"es 0, los números se clasifican en orden descendente. En otro caso, se "
"clasifican en orden ascendente.\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"Supongamos que las celdas A1, A2, …, A5 contienen los números 11.4, 17.3, "
"21.3, 25.9, y 40.1. Entonces\n"
"RANK(17.3,A1:A5) igual a 4.\n"
"\n"
"@SEEALSO=PERCENTRANK"

#: ../plugins/fn-stat/functions.c:262
msgid ""
"@FUNCTION=TRIMMEAN\n"
"@SYNTAX=TRIMMEAN(ref,fraction)\n"
"@DESCRIPTION=TRIMMEAN returns the mean of the interior of a data set. @ref "
"is the list of numbers whose mean you want to calculate and @fraction is the "
"fraction of the data set excluded from the mean. For example, if "
"@fraction=0.2 and the data set contains 40 numbers, 8 numbers are trimmed "
"from the data set (40 x 0.2): the 4 largest and the 4 smallest.  To avoid a "
"bias, the number of points to be excluded is always rounded down to the "
"nearest even number.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
"21.3, 25.9, and 40.1.  Then\n"
"TRIMMEAN(A1:A5,0.2) equals 23.2.\n"
"\n"
"@SEEALSO=AVERAGE,GEOMEAN,HARMEAN,MEDIAN,MODE"
msgstr ""
"@FUNCTION=TRIMMEAN\n"
"@SYNTAX=TRIMMEAN(ref,fracción)\n"
"@DESCRIPTION=TRIMMEAN devuelve la media del interior de un conjunto de "
"datos. @ref es la lista de los números cuya media se quiere calcular y "
"@fracción es la fracción del conjunto de datos excluido de la media. Por "
"ejemplo, si @fracción=0.2 y el conjunto de datos contiene 40 números, se "
"recortan 8 números del conjunto de datos (40 x 0.2), 4 de arriba y 4 de "
"abajo del conjunto. Para evitar un bias, el número de puntos a ser "
"ejecutados se redondea siempre hacia abajo hasta el número impar más "
"cercano.\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"Supongamos que las celdas A1, A2, …, A5 contienen los números 11.4, 17.3, "
"21.3, 25.9, y 40.1. Entonces\n"
"TRIMMEAN(A1:A5,0.2) igual a 23.2.\n"
"\n"
"@SEEALSO=AVERAGE,GEOMEAN,HARMEAN,MEDIAN,MODE"

#: ../plugins/fn-stat/functions.c:317
msgid ""
"@FUNCTION=COVAR\n"
"@SYNTAX=COVAR(array1,array2)\n"
"@DESCRIPTION=COVAR returns the covariance of two data sets.\n"
"\n"
"* Strings and empty cells are simply ignored.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
"21.3, 25.9, and 40.1, and the cells B1, B2, ... B5 23.2, 25.8, 29.9, 33.5, "
"and 42.7.  Then\n"
"COVAR(A1:A5,B1:B5) equals 65.858.\n"
"\n"
"@SEEALSO=CORREL,FISHER,FISHERINV"
msgstr ""
"@FUNCTION=COVAR\n"
"@SYNTAX=COVAR(array1,array2)\n"
"@DESCRIPTION=Devuelve la covarianza de dos conjuntos de datos.\n"
"\n"
"* Las celdas vacías o con texto siempre son ignoradas.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"Suponiendo que las celdas A1, A2, …, A5 contengan los números 11,4; 17,3; "
"21,3; 25,9; y 40,1; y las celdas B1, B2, …, B5 contengan 23,2; 25,8; 29,9; "
"33,5; y 42,7. Entonces\n"
"COVAR(A1:A5,B1:B5) es igual a 65,858.\n"
"\n"
"@SEEALSO=CORREL,FISHER,FISHERINV"

#: ../plugins/fn-stat/functions.c:353
msgid ""
"@FUNCTION=CORREL\n"
"@SYNTAX=CORREL(array1,array2)\n"
"@DESCRIPTION=CORREL returns the correlation coefficient of two data sets.\n"
"\n"
"* Strings and empty cells are simply ignored.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
"21.3, 25.9, and 40.1, and the cells B1, B2, ... B5 23.2, 25.8, 29.9, 33.5, "
"and 42.7.  Then\n"
"CORREL(A1:A5,B1:B5) equals 0.996124788.\n"
"\n"
"@SEEALSO=COVAR,FISHER,FISHERINV"
msgstr ""
"@FUNCTION=CORREL\n"
"@SYNTAX=CORREL(array1,array2)\n"
"@DESCRIPTION=Devuelve el coeficiente de correlación de dos conjuntos de "
"datos.\n"
"\n"
"* Las celdas vacías o con texto son ignoradas.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"Suponiendo que las celdas A1, A2, …, A5 contengan los números 11,4; 17,3; "
"21,3; 25,9; y 40,1; y las celdas B1, B2, …, B5 contengan 23,2; 25,8; 29,9; "
"33,5; y 42,7. Entonces\n"
"CORREL(A1:A5,B1:B5) es igual a 0,996124788.\n"
"\n"
"@SEEALSO=COVAR,FISHER,FISHERINV"

#: ../plugins/fn-stat/functions.c:389
msgid ""
"@FUNCTION=NEGBINOMDIST\n"
"@SYNTAX=NEGBINOMDIST(f,t,p)\n"
"@DESCRIPTION=NEGBINOMDIST function returns the negative binomial "
"distribution. @f is the number of failures, @t is the threshold number of "
"successes, and @p is the probability of a success.\n"
"\n"
"* If @f or @t is a non-integer it is truncated.\n"
"* If (@f + @t -1) <= 0 NEGBINOMDIST returns #NUM! error.\n"
"* If @p < 0 or @p > 1 NEGBINOMDIST returns #NUM! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"NEGBINOMDIST(2,5,0.55) equals 0.152872629.\n"
"\n"
"@SEEALSO=BINOMDIST,COMBIN,FACT,HYPGEOMDIST,PERMUT"
msgstr ""
"@FUNCTION=NEGBINOMDIST\n"
"@SYNTAX=NEGBINOMDIST(f,t,p)\n"
"@DESCRIPTION=La función NEGBINOMDIST devuelve la distribución binomial "
"negativa. @f es el número de fallos, @t es el número umbral de éxitos y @p "
"es la probabilidad de éxito.\n"
"\n"
"* Si @f ó @t no son enteros, se truncan.\n"
"* Si (@f + @t -1) <= 0, NEGBINOMDIST devuelve el error #NÚM!.\n"
"* Si @p < 0 ó @p > 1, NEGBINOMDIST devuelve el error #NÚM!.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"NEGBINOMDIST(2,5,0.55) igual a 0.152872629.\n"
"\n"
"@SEEALSO=BINOMDIST,COMBIN,FACT,HYPGEOMDIST,PERMUT"

#: ../plugins/fn-stat/functions.c:427
msgid ""
"@FUNCTION=NORMSDIST\n"
"@SYNTAX=NORMSDIST(x)\n"
"@DESCRIPTION=NORMSDIST function returns the standard normal cumulative "
"distribution. @x is the value for which you want the distribution.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"NORMSDIST(2) equals 0.977249868.\n"
"\n"
"@SEEALSO=NORMDIST"
msgstr ""
"@FUNCTION=NORMSDIST\n"
"@SYNTAX=NORMSDIST(x)\n"
"@DESCRIPTION=La función NORMSDIST devuelve la distribución normal estándar "
"acumulativa. @x es el valor para el que quiere la distribución.\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"NORMSDIST(2) igual a 0.977249868.\n"
"\n"
"@SEEALSO=NORMDIST"

#: ../plugins/fn-stat/functions.c:459
msgid ""
"@FUNCTION=NORMSINV\n"
"@SYNTAX=NORMSINV(p)\n"
"@DESCRIPTION=NORMSINV function returns the inverse of the standard normal "
"cumulative distribution. @p is the given probability corresponding to the "
"normal distribution.\n"
"\n"
"* If @p < 0 or @p > 1 NORMSINV returns #NUM! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"NORMSINV(0.2) equals -0.841621234.\n"
"\n"
"@SEEALSO=NORMDIST,NORMINV,NORMSDIST,STANDARDIZE,ZTEST"
msgstr ""
"@FUNCTION=NORMSINV\n"
"@SYNTAX=NORMSINV(p)\n"
"@DESCRIPTION=La función NORMSINV devuelve el inverso de la distribución "
"acumulativa normal estándar. @p es la probabilidad dada correspondiente a la "
"distribución normal.\n"
"\n"
"* Si @p < 0 ó @p > 1, NORMSINV devuelve el error #NÚM!. \n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"NORMSINV(0.2) igual a -0.841621234.\n"
"\n"
"@SEEALSO=NORMDIST,NORMINV,NORMSDIST,STANDARDIZE,ZTEST"

#: ../plugins/fn-stat/functions.c:494
msgid ""
"@FUNCTION=LOGNORMDIST\n"
"@SYNTAX=LOGNORMDIST(x,mean,stddev)\n"
"@DESCRIPTION=LOGNORMDIST function returns the lognormal distribution. @x is "
"the value for which you want the distribution, @mean is the mean of the "
"distribution, and @stddev is the standard deviation of the distribution.\n"
"\n"
"* If @stddev = 0 LOGNORMDIST returns #DIV/0! error.\n"
"* If @x <= 0, @mean < 0 or @stddev < 0 LOGNORMDIST returns #NUM! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"LOGNORMDIST(3,1,2) equals 0.519662338.\n"
"\n"
"@SEEALSO=NORMDIST"
msgstr ""
"@FUNCTION=LOGNORMDIST\n"
"@SYNTAX=LOGNORMDIST(x,media,desvest)\n"
"@DESCRIPTION=La función LOGNORMDIST devuelve la distribución lognormal. @x "
"es el valor para el que quiere la distribución, @media es la media de la "
"distribución y @desvest es la desviación estándar de la distribución.\n"
"\n"
"* Si @desvest = 0, LOGNORMDIST devuelve el error #DIV/0!.\n"
"* Si @x <= 0, @significado < 0 ó @desvest < 0, LOGNORMDIST devuelve el error "
"#NÚM!.\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"LOGNORMDIST(3,1,2) igual a 0,519662338.\n"
"\n"
"@SEEALSO=NORMDIST"

#: ../plugins/fn-stat/functions.c:532
msgid ""
"@FUNCTION=LOGINV\n"
"@SYNTAX=LOGINV(p,mean,stddev)\n"
"@DESCRIPTION=LOGINV function returns the inverse of the lognormal cumulative "
"distribution. @p is the given probability corresponding to the normal "
"distribution, @mean is the arithmetic mean of the distribution, and @stddev "
"is the standard deviation of the distribution.\n"
"\n"
"* If @p < 0 or @p > 1 or @stddev <= 0 LOGINV returns #NUM! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"LOGINV(0.5,2,3) equals 7.389056099.\n"
"\n"
"@SEEALSO=EXP,LN,LOG,LOG10,LOGNORMDIST"
msgstr ""
"@FUNCTION=LOGINV\n"
"@SYNTAX=LOGINV(p,media,desvest)\n"
"@DESCRIPTION=La función LOGINV devuelve la inversa de la distribución "
"acumulativa lognormal. @p es la probabilidad dada correspondiente a la "
"distribución normal. @media es la media aritmética de la distribución y "
"@desvest es la desviación estándar de la distribución.\n"
"\n"
"* Si @p < 0 ó @p > 1 ó @desvest <= 0, LOGINV devuelve el error #NÚM!.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"LOGINV(0.5,2,3) igual a 7,389056099.\n"
"\n"
"@SEEALSO=EXP,LN,LOG,LOG10,LOGNORMDIST"

#: ../plugins/fn-stat/functions.c:572
msgid ""
"@FUNCTION=FISHERINV\n"
"@SYNTAX=FISHERINV(x)\n"
"@DESCRIPTION=FISHERINV function returns the inverse of the Fisher "
"transformation at @x.\n"
"\n"
"* If @x is non-number FISHERINV returns #VALUE! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"FISHERINV(2) equals 0.96402758.\n"
"\n"
"@SEEALSO=FISHER"
msgstr ""
"@FUNCTION=FISHERINV\n"
"@SYNTAX=FISHERINV(x)\n"
"@DESCRIPTION=La función FISHERINV devuelve la inversa de la transformación "
"de Fisher en @x.\n"
"\n"
"* Si @x no es un número, FISHERINV devuelve el error @VALOR!.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"FISHERINV(2) igual a 0,96402758.\n"
"\n"
"@SEEALSO=FISHER"

#: ../plugins/fn-stat/functions.c:602
msgid ""
"@FUNCTION=MODE\n"
"@SYNTAX=MODE(n1, n2, ...)\n"
"@DESCRIPTION=MODE returns the most common number of the data set. If the "
"data set has many most common numbers MODE returns the first one of them.\n"
"\n"
"* Strings and empty cells are simply ignored.\n"
"* If the data set does not contain any duplicates MODE returns #N/A error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
"11.4, 25.9, and 40.1.  Then\n"
"MODE(A1:A5) equals 11.4.\n"
"\n"
"@SEEALSO=AVERAGE,MEDIAN"
msgstr ""
"@FUNCTION=MODE\n"
"@SYNTAX=MODE(n1, n2, …)\n"
"@DESCRIPTION=MODE devuelve el número más común del conjunto de datos. Si el "
"conjunto de datos tiene muchos números comunes, MODE devuelve el primero de "
"ellos.\n"
"\n"
"* Las cadenas y las celdas vacías, simplemente se ignoran.\n"
"* Si el conjunto de datos no contiene ningún duplicado, MODE devuelve el "
"error #N/D.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"Asumamos que las celdas A1, A2, …, A5 contienen los números 11.4, 17.3, "
"11.4, 25.9 y 40.1. Entonces\n"
"MODE(A1:A5) igual a 11,4.\n"
"\n"
"@SEEALSO=AVERAGE,MEDIAN"

#: ../plugins/fn-stat/functions.c:640
msgid ""
"@FUNCTION=HARMEAN\n"
"@SYNTAX=HARMEAN(b1, b2, ...)\n"
"@DESCRIPTION=HARMEAN returns the harmonic mean of the N data points (that "
"is, N divided by the sum of the inverses of the data points).\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
"21.3, 25.9, and 40.1.  Then\n"
"HARMEAN(A1:A5) equals 19.529814427.\n"
"\n"
"@SEEALSO=AVERAGE,GEOMEAN,MEDIAN,MODE,TRIMMEAN"
msgstr ""
"@FUNCTION=HARMEAN\n"
"@SYNTAX=HARMEAN(b1, b2, …)\n"
"@DESCRIPTION=HARMEAN devuelve la media armónica de los N puntos de datos "
"(esto es, N dividido por la suma de las inversas de los puntos de datos).\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"Supongamos que las celdas A1, A2, …, A5 contienen los números 11.4, 17.3, "
"21.3, 25.9, y 40.1. Entonces\n"
"HARMEAN(A1:A5) es igual a 19,529814427.\n"
"\n"
"@SEEALSO=AVERAGE,GEOMEAN,MEDIAN,MODE,TRIMMEAN"

#: ../plugins/fn-stat/functions.c:674
msgid ""
"@FUNCTION=GEOMEAN\n"
"@SYNTAX=GEOMEAN(b1, b2, ...)\n"
"@DESCRIPTION=GEOMEAN returns the geometric mean of the given arguments. This "
"is equal to the Nth root of the product of the terms.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
"21.3, 25.9, and 40.1.  Then\n"
"GEOMEAN(A1:A5) equals 21.279182482.\n"
"\n"
"@SEEALSO=AVERAGE,HARMEAN,MEDIAN,MODE,TRIMMEAN"
msgstr ""
"@FUNCTION=GEOMEAN\n"
"@SYNTAX=GEOMEAN(valor1, valor2, …)\n"
"@DESCRIPTION=Devuelve la media geométrica de los argumentos, es decir, la "
"raíz n-ésima del producto de los términos.\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"Suponiendo que las celdas A1, A2, …, A5 contengan los números 11,4; 17,3; "
"21,3; 25,9; y 40,1. Entonces\n"
"GEOMEAN(A1:A5) es igual a 21,279182482.\n"
"\n"
"@SEEALSO=AVERAGE,HARMEAN,MEDIAN,MODE,TRIMMEAN"

#: ../plugins/fn-stat/functions.c:707
msgid ""
"@FUNCTION=COUNT\n"
"@SYNTAX=COUNT(b1, b2, ...)\n"
"@DESCRIPTION=COUNT returns the total number of integer or floating point "
"arguments passed.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
"21.3, 25.9, and 40.1.  Then\n"
"COUNT(A1:A5) equals 5.\n"
"\n"
"@SEEALSO=AVERAGE"
msgstr ""
"@FUNCTION=COUNT\n"
"@SYNTAX=COUNT(valor1, valor2, …)\n"
"@DESCRIPTION=Devuelve el número total de argumentos enteros o de coma "
"flotante pasados.\n"
"\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"Suponiendo que las celdas A1, A2, …, A5 contienen los números 11,4; 17,3; "
"21,3; 25,9 y 40,1. Entonces\n"
"COUNT(A1:A5) es igual a 5.\n"
"\n"
"@SEEALSO=AVERAGE, COUNT"

#: ../plugins/fn-stat/functions.c:752
msgid ""
"@FUNCTION=COUNTA\n"
"@SYNTAX=COUNTA(b1, b2, ...)\n"
"@DESCRIPTION=COUNTA returns the number of arguments passed not including "
"empty cells.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1, A2, ..., A5 contain numbers and strings "
"11.4, \"missing\", \"missing\", 25.9, and 40.1.  Then\n"
"COUNTA(A1:A5) equals 5.\n"
"\n"
"@SEEALSO=AVERAGE,COUNT,DCOUNT,DCOUNTA,PRODUCT,SUM"
msgstr ""
"@FUNCTION=COUNTA\n"
"@SYNTAX=COUNTA(valor1, valor2, …)\n"
"@DESCRIPTION=Calcula el número de argumentos pasados sin incluir celdas "
"vacías.\n"
"\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"Suponiendo que las celdas A1, A2, …, A5 contienen los números 11,4; \"sin "
"datos\"; \"sin datos\"; 25,9 y 40,1. Entonces\n"
"COUNTA(A1:A5) es igual a 3.\n"
"\n"
"@SEEALSO=AVERAGE, COUNT, DCOUNT, DCOUNTA, PRODUCT, SUM"

#: ../plugins/fn-stat/functions.c:796
msgid ""
"@FUNCTION=AVERAGE\n"
"@SYNTAX=AVERAGE(value1, value2,...)\n"
"@DESCRIPTION=AVERAGE computes the average of all the values and cells "
"referenced in the argument list.  This is equivalent to the sum of the "
"arguments divided by the count of the arguments.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
"21.3, 25.9, and 40.1.  Then\n"
"AVERAGE(A1:A5) equals 23.2.\n"
"\n"
"@SEEALSO=SUM, COUNT"
msgstr ""
"@FUNCTION=AVERAGE\n"
"@SYNTAX=AVERAGE(valor1, valor2,…)\n"
"@DESCRIPTION=AVERAGE calcula el media de todos los valores y celdas "
"referenciadas en la lista de argumentos. Es equivalente a la suma de los "
"argumentos dividido por el número de argumentos.\n"
"\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"Suponiendo que las celdas A1, A2, …, A5 contienen los números 11.4, 17.3, "
"21.3, 25.9 y 40.1. Luego,\n"
"AVERAGE(A1:A5) es igual a 23.2.\n"
"\n"
"@SEEALSO=SUM, COUNT"

#: ../plugins/fn-stat/functions.c:830
msgid ""
"@FUNCTION=MIN\n"
"@SYNTAX=MIN(b1, b2, ...)\n"
"@DESCRIPTION=MIN returns the value of the element of the values passed that "
"has the smallest value, with negative numbers considered smaller than "
"positive numbers.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
"21.3, 25.9, and 40.1.  Then\n"
"MIN(A1:A5) equals 11.4.\n"
"\n"
"@SEEALSO=MAX,ABS"
msgstr ""
"@FUNCTION=MIN\n"
"@SYNTAX=MIN(b1;b2;…)\n"
"@DESCRIPTION=Devuelve el valor del elemento pasado en argumento cuyo valor "
"es menor a todos los demás. Los valores negativos se consideran menores a "
"los positivos.\n"
"\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"Suponiendo que las celdas A1, A2, …, A5 contengan los números 11,4; 17,3; "
"21,3; 25,9; y 40,1. Entonces\n"
"MIN(A1:A5) es igual a 11,4.\n"
"\n"
"@SEEALSO=MAX,ABS"

#: ../plugins/fn-stat/functions.c:875
msgid ""
"@FUNCTION=MAX\n"
"@SYNTAX=MAX(b1, b2, ...)\n"
"@DESCRIPTION=MAX returns the value of the element of the values passed that "
"has the largest value, with negative numbers considered smaller than "
"positive numbers.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
"21.3, 25.9, and 40.1.  Then\n"
"MAX(A1:A5) equals 40.1.\n"
"\n"
"@SEEALSO=MIN,ABS"
msgstr ""
"@FUNCTION=MAX\n"
"@SYNTAX=MAX(b1;b2;…)\n"
"@DESCRIPTION=Devuelve el valor del elemento de los valores pasados que es "
"mayor a todos los demás. Los valores negativos se consideran menores que los "
"números positivos.\n"
"\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"Suponiendo que las celdas A1, A2, …, A5 contengan los números 11,4; 17,3; "
"21,3; 25,9; y 40,1. Entonces\n"
"MAX(A1:A5) es igual a 40,1.\n"
"\n"
"@SEEALSO=MIN,ABS"

#: ../plugins/fn-stat/functions.c:920
msgid ""
"@FUNCTION=SKEW\n"
"@SYNTAX=SKEW(n1, n2, ...)\n"
"@DESCRIPTION=SKEW returns an unbiased estimate for skewness of a "
"distribution.\n"
"\n"
"Note, that this is only meaningful if the underlying distribution really has "
"a third moment.  The skewness of a symmetric (e.g., normal) distribution is "
"zero.\n"
"\n"
"* Strings and empty cells are simply ignored.\n"
"* If less than three numbers are given, SKEW returns #DIV/0! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
"21.3, 25.9, and 40.1.  Then\n"
"SKEW(A1:A5) equals 0.976798268.\n"
"\n"
"@SEEALSO=AVERAGE,VAR,SKEWP,KURT"
msgstr ""
"@FUNCTION=SKEW\n"
"@SYNTAX=SKEW(n1, n2, …)\n"
"@DESCRIPTION=SKEW devuelve una estimación de la desviación de una "
"distribución.\n"
"\n"
"Note que esto sólo tiene significado si la distribución subyacente realmente "
"tiene un tercer momento. La desviación de una distribución simétrica (ej., "
"normal) es cero.\n"
"\n"
"* Las cadenas y las celdas vacías se ignoran.\n"
"* Si se dan menos de tres números, SKEW devuelve un error #DIV/0!\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"Asumamos que las celdas A1, A2, …, A5 contienen los números 11,4; 17,3; "
"21,3; 25,9; y 40,1. entonces SKEW(A1:A5) es igual a 0,976798268.\n"
"\n"
"@SEEALSO=AVERAGE,VAR,SKEWP,KURT"

#: ../plugins/fn-stat/functions.c:960
msgid ""
"@FUNCTION=SKEWP\n"
"@SYNTAX=SKEWP(n1, n2, ...)\n"
"@DESCRIPTION=SKEWP returns the population skewness of a data set.\n"
"\n"
"* Strings and empty cells are simply ignored.\n"
"* If less than two numbers are given, SKEWP returns #DIV/0! error.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
"21.3, 25.9, and 40.1.  Then\n"
"SKEWP(A1:A5) equals 0.655256198.\n"
"\n"
"@SEEALSO=AVERAGE,VARP,SKEW,KURTP"
msgstr ""
"@FUNCTION=SKEWP\n"
"@SYNTAX=SKEWP(n1, n2, …)\n"
"@DESCRIPTION=SKEWP devuelve la desviación de la población de un conjunto de "
"datos.\n"
"\n"
"* Las cadenas y las celdas vacías se ignoran.\n"
"* Si se dan menos de dos números, SKEWP devuelve un error #DIV/0!\n"
"\n"
"@EXAMPLES=\n"
"Asumamos que las celdas A1, A2, …, A5 contienen los números 11,4; 17,3; "
"21,3; 25,9; y 40,1; Entonces\n"
"SKEWP(A1:A5) es igual a 0,655256198.\n"
"\n"
"@SEEALSO=AVERAGE,VARP,SKEW,KURTP"

#: ../plugins/fn-stat/functions.c:995
msgid ""
"@FUNCTION=EXPONDIST\n"
"@SYNTAX=EXPONDIST(x,y,cumulative)\n"
"@DESCRIPTION=EXPONDIST function returns the exponential distribution. If the "
"@cumulative boolean is false it will return:\n"
"\n"
"\t@y * exp (-@y*@x),\n"
"\n"
"otherwise it will return\n"
"\n"
"\t1 - exp (-@y*@x).\n"
"\n"
"* If @x < 0 or @y <= 0 this will return an error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"EXPONDIST(2,4,0) equals 0.001341851.\n"
"\n"
"@SEEALSO=POISSON"
msgstr ""
"@FUNCTION=EXPONDIST\n"
"@SYNTAX=EXPONDIST(x,y,acumulado)\n"
"@DESCRIPTION=La función EXPONDIST devuelve la distribución exponencial. Si "
"el booleano @acumulado es falso devuelve:\n"
"\n"
"\t@y * exp (-@y*@x),\n"
"\n"
" en otro caso, devuelve\n"
"\n"
"\t1 - exp (-@y*@x).\n"
"\n"
"* Si @x < 0 ó @y <= 0 esto devolverá un error.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"EXPONDIST(2,4,0) igual a 0.001341851.\n"
"\n"
"@SEEALSO=POISSON"

#: ../plugins/fn-stat/functions.c:1035
msgid ""
"@FUNCTION=BERNOULLI\n"
"@SYNTAX=BERNOULLI(k,p)\n"
"@DESCRIPTION=BERNOULLI returns the probability p(k) of obtaining @k from a "
"Bernoulli distribution with probability parameter @p.\n"
"\n"
"* If @k != 0 and @k != 1 BERNOULLI returns #NUM! error.\n"
"* If @p < 0 or @p > 1 BERNOULLI returns #NUM! error.\n"
"\n"
"@EXAMPLES=\n"
"BERNOULLI(0,0.5).\n"
"\n"
"@SEEALSO=RANDBERNOULLI"
msgstr ""
"@FUNCTION=BERNOULLI\n"
"@SYNTAX=BERNOULLI(k,p)\n"
"@DESCRIPTION=BERNOULLI devuelve la probabilidad p(k) de obtener @k de una "
"distribución de Bernoulli con parámetro de probabilidad @p.\n"
"\n"
"* Si @k != 0 y @k != 1, BERNUOLLI devuelve un error #NÚM!\n"
"* Si @p < 0 o @p > 1 BERNOULLI devuelve un error #NÚM!\n"
"\n"
"@EXAMPLES=\n"
"BERNOULLI(0,0.5).\n"
"\n"
"@SEEALSO=RANDBERNOULLI"

#: ../plugins/fn-stat/functions.c:1080
msgid ""
"@FUNCTION=GAMMALN\n"
"@SYNTAX=GAMMALN(x)\n"
"@DESCRIPTION=GAMMALN function returns the natural logarithm of the gamma "
"function.\n"
"\n"
"* If @x is non-number then GAMMALN returns #VALUE! error.\n"
"* If @x <= 0 then GAMMALN returns #NUM! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"GAMMALN(23) equals 48.471181352.\n"
"\n"
"@SEEALSO=POISSON"
msgstr ""
"@FUNCTION=GAMMALN\n"
"@SYNTAX=GAMMALN(x)\n"
"@DESCRIPTION=La función GAMMALN devuelve el logaritmo natural de la función "
"gamma.\n"
"\n"
"* Si @x no es un número, entonces GAMMALN devuelve el error #VALOR!.\n"
"* Si @x <= 0, entonces GAMMALN devuelve el error #NÚM!.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"GAMMALN(23) igual a 48.471181352.\n"
"\n"
"@SEEALSO=POISSON"

#: ../plugins/fn-stat/functions.c:1120
msgid ""
"@FUNCTION=GAMMADIST\n"
"@SYNTAX=GAMMADIST(x,alpha,beta,cum)\n"
"@DESCRIPTION=GAMMADIST function returns the gamma distribution. If @cum is "
"TRUE, GAMMADIST returns the incomplete gamma function, otherwise it returns "
"the probability mass function.\n"
"\n"
"* If @x < 0 GAMMADIST returns #NUM! error.\n"
"* If @alpha <= 0 or @beta <= 0, GAMMADIST returns #NUM! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"GAMMADIST(1,2,3,0) equals 0.07961459.\n"
"\n"
"@SEEALSO=GAMMAINV"
msgstr ""
"@FUNCTION=GAMMADIST\n"
"@SYNTAX=GAMMADIST(x,alfa,beta,acum)\n"
"@DESCRIPTION=La función GAMMADIST devuelve la distribución gamma. Si @acum "
"es VERDADERO, GAMMADIST devuelve la función gamma incompleta. En otro caso, "
"devuelve la función de probabilidad de masa.\n"
"\n"
"* Si @x < 0, GAMMADIST devuelve el error #NÚM!.\n"
"* Si @alfa <= 0 ó @beta <= 0, GAMMADIST devuelve el error #NÚM!\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"GAMMADIST(1,2,3,0) igual a 0,07961459.\n"
"\n"
"@SEEALSO=GAMMAINV"

#: ../plugins/fn-stat/functions.c:1161
msgid ""
"@FUNCTION=GAMMAINV\n"
"@SYNTAX=GAMMAINV(p,alpha,beta)\n"
"@DESCRIPTION=GAMMAINV function returns the inverse of the cumulative gamma "
"distribution.\n"
"\n"
"* If @p < 0 or @p > 1 GAMMAINV returns #NUM! error.\n"
"* If @alpha <= 0 or @beta <= 0 GAMMAINV returns #NUM! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"GAMMAINV(0.34,2,4) equals 4.829093908.\n"
"\n"
"@SEEALSO=GAMMADIST"
msgstr ""
"@FUNCTION=GAMMAINV\n"
"@SYNTAX=GAMMAINV(p,alfa,beta)\n"
"@DESCRIPTION=La función GAMMAINV devuelve la inversa de la distribución gama "
"acumulada.\n"
"\n"
"* Si @p < 0 ó @p > 1, GAMMAINV devuelve el error #NÚM!.\n"
"* Si @alfa <= 0 ó @beta <= 0, GAMMAINV devuelve el error #NÚM!.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"GAMMAINV(0.34,2,4) igual a 4,829093908.\n"
"\n"
"@SEEALSO=GAMMADIST"

#: ../plugins/fn-stat/functions.c:1199
msgid ""
"@FUNCTION=CHIDIST\n"
"@SYNTAX=CHIDIST(x,dof)\n"
"@DESCRIPTION=CHIDIST function returns the one-tailed probability of the chi-"
"squared distribution. @dof is the number of degrees of freedom.\n"
"\n"
"* If @dof is non-integer it is truncated.\n"
"* If @dof < 1 CHIDIST returns #NUM! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"CHIDIST(5.3,2) equals 0.070651213.\n"
"\n"
"@SEEALSO=CHIINV,CHITEST"
msgstr ""
"@FUNCTION=CHIDIST\n"
"@SYNTAX=CHIDIST(x,gdl)\n"
"@DESCRIPTION=La función CHIDIST devuelve la probabilidad con una cola de la "
"función chi cuadrado. @gdl es el número de grados de libertad.\n"
"\n"
"* Si @gdl no es entero, se trunca.\n"
"* Si @gdl < 1, CHIDIST devuelve el error #NÚM!\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"CHIDIST(5.3,2) igual a 0,070651213.\n"
"\n"
"@SEEALSO=CHIINV,CHITEST"

#: ../plugins/fn-stat/functions.c:1235
msgid ""
"@FUNCTION=CHIINV\n"
"@SYNTAX=CHIINV(p,dof)\n"
"@DESCRIPTION=CHIINV function returns the inverse of the one-tailed "
"probability of the chi-squared distribution.\n"
"\n"
"* If @p < 0 or @p > 1 or @dof < 1 CHIINV returns #NUM! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"CHIINV(0.98,7) equals 1.564293004.\n"
"\n"
"@SEEALSO=CHIDIST,CHITEST"
msgstr ""
"@FUNCTION=CHIINV\n"
"@SYNTAX=CHIINV(p,gdl)\n"
"@DESCRIPTION=La función CHIINV devuelve la inversa de la probabilidad de una "
"cola de la distribución chi cuadrado.\n"
"\n"
"* Si @p < 0 ó @p > 1 ó @gdl < 1, CHIINV devuelve el error #NÚM!.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"CHIINV(0.98,7) igual a 1,564293004.\n"
"\n"
"@SEEALSO=CHIDIST,CHITEST"

#: ../plugins/fn-stat/functions.c:1269
msgid ""
"@FUNCTION=CHITEST\n"
"@SYNTAX=CHITEST(actual_range,theoretical_range)\n"
"@DESCRIPTION=CHITEST function returns the test for independence of chi-"
"squared distribution.\n"
"\n"
"@actual_range is a range that contains the observed data points. "
"@theoretical_range is a range that contains the expected values of the data "
"points.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=CHIDIST,CHIINV"
msgstr ""
"@FUNCTION=CHITEST\n"
"@SYNTAX=CHITEST(rango_actual,rango_teórico)\n"
"@DESCRIPTION=La función CHITEST devuelve las pruebas para la independencia "
"de la distribución chi cuadrado.\n"
"\n"
"@rango_actual es un rango que contiene los puntos de datos observados. "
"@rango_teórico es un rango que contiene los valores esperados de los puntos "
"de datos.\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=CHIDIST,CHIINV"

#: ../plugins/fn-stat/functions.c:1364
msgid ""
"@FUNCTION=BETADIST\n"
"@SYNTAX=BETADIST(x,alpha,beta[,a,b])\n"
"@DESCRIPTION=BETADIST function returns the cumulative beta distribution. @a "
"is the optional lower bound of @x and @b is the optional upper bound of @x.\n"
"* If @a is not given, BETADIST uses 0.\n"
"* If @b is not given, BETADIST uses 1.\n"
"* If @x < @a or @x > @b BETADIST returns #NUM! error.\n"
"* If @alpha <= 0 or @beta <= 0, BETADIST returns #NUM! error.\n"
"* If @a >= @b BETADIST returns #NUM! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"BETADIST(0.12,2,3) equals 0.07319808.\n"
"\n"
"@SEEALSO=BETAINV"
msgstr ""
"@FUNCTION=BETADIST\n"
"@SYNTAX=BETADIST(x,alfa,beta[,a,b])\n"
"@DESCRIPTION=La función BETADIST devuelve la distribución beta acumulada. @a "
"es el límite inferior opcional de @x y @b es el límite superior opcional de "
"@x. \n"
"\n"
"* Si no se da @a, BETADIST usa 0. \n"
"* Si no se da @b, BETADIST usa 1.\n"
"* Si @x < @a ó @x > @b, BETADIST devuelve el error #NÚM!.\n"
"* Si @alfa <= 0 ó @beta <= 0, BETADIST devuelve el error #NÚM!.\n"
"* Si @a >= @b BETADIST devuelve el error #NÚM!.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"BETADIST(0.12,2,3) igual a 0,07319808.\n"
"\n"
"@SEEALSO=BETAINV"

#: ../plugins/fn-stat/functions.c:1410
msgid ""
"@FUNCTION=BETAINV\n"
"@SYNTAX=BETAINV(p,alpha,beta[,a,b])\n"
"@DESCRIPTION=BETAINV function returns the inverse of cumulative beta "
"distribution.  @a is the optional lower bound of @x and @b is the optional "
"upper bound of @x.\n"
"\n"
"* If @a is not given, BETAINV uses 0.\n"
"* If @b is not given, BETAINV uses 1.\n"
"* If @p < 0 or @p > 1 BETAINV returns #NUM! error.\n"
"* If @alpha <= 0 or @beta <= 0, BETAINV returns #NUM! error.\n"
"* If @a >= @b BETAINV returns #NUM! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"BETAINV(0.45,1.6,1) equals 0.607096629.\n"
"\n"
"@SEEALSO=BETADIST"
msgstr ""
"@FUNCTION=BETAINV\n"
"@SYNTAX=BETAINV(p,alfa,beta[,a,b])\n"
"@DESCRIPTION=La función BETAINV devuelve la inversa de la distribución beta "
"acumulada. @a es el límite inferior opcional de @x y @b es el límite "
"superior opcional de @x. \n"
"\n"
"* Si no se de @a, BETAINV usa 0. \n"
"* Si no se da @b, BETAINV usa 1.\n"
"* Si @p < 0 ó @p > 1, BETAINV devuelve el error #NÚM!.\n"
"* Si @alfa <= 0 o @beta <= 0, BETAINV devuelve el error #NUM.\n"
"* Si @a >= @b, BETAINV devuelve el error #NÚM!.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"BETAINV(0.45,1.6,1) igual a 0,607096629.\n"
"\n"
"@SEEALSO=BETADIST"

#: ../plugins/fn-stat/functions.c:1454
msgid ""
"@FUNCTION=TDIST\n"
"@SYNTAX=TDIST(x,dof,tails)\n"
"@DESCRIPTION=TDIST function returns the Student's t-distribution. @dof is "
"the degree of freedom and @tails is 1 or 2 depending on whether you want one-"
"tailed or two-tailed distribution.\n"
"@tails = 1 returns the size of the right tail.\n"
"\n"
"* If @dof < 1 TDIST returns #NUM! error.\n"
"* If @tails is neither 1 or 2 TDIST returns #NUM! error.\n"
"* This function is Excel compatible for non-negative @x.\n"
"\n"
"Warning: the parameterization of this function is different from what is "
"used for, e.g., NORMSDIST.  This is a common source of mistakes, but "
"necessary for compatibility.\n"
"\n"
"@EXAMPLES=\n"
"TDIST(2,5,1) equals 0.050969739.\n"
"TDIST(-2,5,1) equals 0.949030261.\n"
"TDIST(0,5,2) equals 1.\n"
"\n"
"@SEEALSO=TINV,TTEST"
msgstr ""
"@FUNCTION=TDIST\n"
"@SYNTAX=TDIST(x,dof,colas)\n"
"@DESCRIPTION=La función TDIST devuelve la distribución t de Student. @dof es "
"el grado de libertad y @colas es 1 ó 2 dependiendo de si quiere una "
"distribución de 1 ó 2 colas. @colas= 1 devuelve el tamaño de la cola "
"derecha.\n"
"\n"
"* Si @dof < 1, TDIST devuelve el error #NÚM!.\n"
"* Si @colas no es ni 1 ni 2, TDIST devuelve el error #NÚM!.\n"
"* Esta función es compatible con Excel para @x no negativos.\n"
"\n"
"Atención: La parametrización de esta función es diferente de la que se usa "
"por ejemplo en NORMSDIST. Esta es una fuente común de equivocaciones, pero "
"necesaria para la compatibilidad.\n"
"\n"
"@EXAMPLES=\n"
"TDIST(2,5,1) igual a 0,050969739.\n"
"TDIST(-2,5,1) igual a 0.949030261.\n"
"TDIST(0,5,2) igual a 1.\n"
"\n"
"@SEEALSO=TINV,TTEST"

#: ../plugins/fn-stat/functions.c:1499
msgid ""
"@FUNCTION=TINV\n"
"@SYNTAX=TINV(p,dof)\n"
"@DESCRIPTION=TINV function returns the inverse of the two-tailed Student's t-"
"distribution.\n"
"\n"
"* If @p < 0 or @p > 1 or @dof < 1 TINV returns #NUM! error.\n"
"* This function is Excel compatible.\n"
"\n"
"Warning: the parameterization of this function is different from what is "
"used for, e.g., NORMSINV.  This is a common source of mistakes, but "
"necessary for compatibility.\n"
"\n"
"@EXAMPLES=\n"
"TINV(0.4,32) equals 0.852998454.\n"
"\n"
"@SEEALSO=TDIST,TTEST"
msgstr ""
"@FUNCTION=TINV\n"
"@SYNTAX=TINV(p,gdl)\n"
"@DESCRIPTION=La función TINV devuelve la inversa de la distribución t de "
"Student de dos colas.\n"
"\n"
"* Si @p < 0 ó @p > 1 ó @gdl < 1, TINV devuelve el error #NÚM!.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"Atención: La parametrización de esta función es diferente de la que se usa "
"por ejemplo en NORMSDIST. Esta es una fuente común de equivocaciones, pero "
"necesaria para la compatibilidad.\n"
"\n"
"@EXAMPLES=\n"
"TINV(0.4,32) igual a 0,852998454.\n"
"\n"
"@SEEALSO=TDIST,TTEST"

#: ../plugins/fn-stat/functions.c:1543
msgid ""
"@FUNCTION=FDIST\n"
"@SYNTAX=FDIST(x,dof1,dof2)\n"
"@DESCRIPTION=FDIST function returns the F probability distribution. @dof1 is "
"the numerator degrees of freedom and @dof2 is the denominator degrees of "
"freedom.\n"
"\n"
"* If @x < 0 FDIST returns #NUM! error.\n"
"* If @dof1 < 1 or @dof2 < 1, FDIST returns #NUM! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"FDIST(2,5,5) equals 0.232511319.\n"
"\n"
"@SEEALSO=FINV"
msgstr ""
"@FUNCTION=FDIST\n"
"@SYNTAX=FDIST(x,gdl1,gdl2)\n"
"@DESCRIPTION=La función FDIST devuelve la distribución de probabilidad F. "
"@gdl1 son los grados de libertad del numerador y @gdl2 son los grados de "
"libertad del denominador.\n"
"\n"
"* Si @x < 0, FDIST devuelve el error #NÚM!.\n"
"* Si @gdl1 < 1 ó @gdl2 < 1, FDIST devuelve el error #NÚM!.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"FDIST(2,5,5) igual a 0.232511319.\n"
"\n"
"@SEEALSO=FINV"

#: ../plugins/fn-stat/functions.c:1580
msgid ""
"@FUNCTION=LANDAU\n"
"@SYNTAX=LANDAU(x)\n"
"@DESCRIPTION=LANDAU returns the probability density p(x) at @x for the "
"Landau distribution using an approximation method. \n"
"@EXAMPLES=\n"
"LANDAU(0.34).\n"
"\n"
"@SEEALSO=RANDLANDAU"
msgstr ""
"@FUNCTION=LANDAU\n"
"@SYNTAX=LANDAU(x)\n"
"@DESCRIPTION=LANDAU devuelve la densidad de probabilidad p(x) en @x para la "
"distribución de Landau usando un método de aproximación.\n"
"@EXAMPLES=\n"
"LANDAU(0.34).\n"
"\n"
"@SEEALSO=RANDLANDAU"

#: ../plugins/fn-stat/functions.c:1725
msgid ""
"@FUNCTION=FINV\n"
"@SYNTAX=FINV(p,dof1,dof2)\n"
"@DESCRIPTION=FINV function returns the inverse of the F probability "
"distribution.\n"
"\n"
"* If @p < 0 or @p > 1 FINV returns #NUM! error.\n"
"* If @dof1 < 1 or @dof2 < 1 FINV returns #NUM! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"FINV(0.2,2,4) equals 2.472135955.\n"
"\n"
"@SEEALSO=FDIST"
msgstr ""
"@FUNCTION=FINV\n"
"@SYNTAX=FINV(p,gdl1,gdl2)\n"
"@DESCRIPTION=La función FINV devuelve la inversa de la distribución de "
"probabilidad F.\n"
"\n"
"* Si @p < 0 ó @p > 1, FINV devuelve el error #NÚM!.\n"
"* Si @gdl1 < 1 ó @gdl2 < 1, FINV devuelve el error #NÚM!.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"FINV(0.2,2,4) igual a 2,472135955.\n"
"\n"
"@SEEALSO=FDIST"

#: ../plugins/fn-stat/functions.c:1761
msgid ""
"@FUNCTION=BINOMDIST\n"
"@SYNTAX=BINOMDIST(n,trials,p,cumulative)\n"
"@DESCRIPTION=BINOMDIST function returns the binomial distribution. @n is the "
"number of successes, @trials is the total number of independent trials, @p "
"is the probability of success in trials, and @cumulative describes whether "
"to return the sum of the binomial function from 0 to @n.\n"
"\n"
"* If @n or @trials are non-integer they are truncated.\n"
"* If @n < 0 or @trials < 0 BINOMDIST returns #NUM! error.\n"
"* If @n > @trials BINOMDIST returns #NUM! error.\n"
"* If @p < 0 or @p > 1 BINOMDIST returns #NUM! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"BINOMDIST(3,5,0.8,0) equals 0.2048.\n"
"\n"
"@SEEALSO=POISSON"
msgstr ""
"@FUNCTION=BINOMDIST\n"
"@SYNTAX=BINOMDIST(n,intentos,p,acumulado)\n"
"@DESCRIPTION=La función BINOMDIST devuelve la distribución binomial. @n es "
"el número de éxitos, @intentos es el número total de intentos "
"independientes, @p es la probabilidad de éxito en intentos, y @acumulado "
"describe si debe devolver la suma de las funciones binomiales de 0 a @n.\n"
"\n"
"* Si @n ó @intentos no son enteros, se truncan.\n"
"* Si @n < 0 ó @intentos < 0, BINOMIST devuelve el error #NÚM!.\n"
"* Si @n > intentos, BINODIST devuelve el error #NÚM!.\n"
"* Si @p < 0 ó @p > 1, BINOMIST devuelve el error #NÚM!.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"BINOMDIST(3,5,0.8,0) igual a 0,2048.\n"
"\n"
"@SEEALSO=POISSON"

#: ../plugins/fn-stat/functions.c:1806
msgid ""
"@FUNCTION=CAUCHY\n"
"@SYNTAX=CAUCHY(x,a,cum)\n"
"@DESCRIPTION=CAUCHY returns the Cauchy distribution with scale parameter @a. "
"If @cum is TRUE, CAUCHY returns the cumulative distribution.\n"
"\n"
"* If @a < 0 CAUCHY returns #NUM! error.\n"
"* If @cum != TRUE and @cum != FALSE CAUCHY returns #VALUE! error.\n"
"\n"
"@EXAMPLES=\n"
"CAUCHY(0.43,1,TRUE) returns 0.370735.\n"
"\n"
"@SEEALSO=RANDCAUCHY"
msgstr ""
"@FUNCTION=CAUCHY\n"
"@SYNTAX=CAUCHY(x,a,cum)\n"
"@DESCRIPTION=CAUCHY devuelve la distribución de Cauchy con parámetro de "
"escala @a. Si @cum es VERDADERO, CAUCHY devuelve la distribución acumulada.\n"
"\n"
"* Si @a < 0 CAUCHY devuelve un error #NÚM!.\n"
"* Si @cum != VERDADERO y @cum != FALSO CAUCHY devuelve un error #VALOR!.\n"
"\n"
"@EXAMPLES=\n"
"CAUCHY(0.43,1,VERDADERO) devuelve 0.370735.\n"
"\n"
"@SEEALSO=RANDCAUCHY"

#: ../plugins/fn-stat/functions.c:1844
msgid ""
"@FUNCTION=CRITBINOM\n"
"@SYNTAX=CRITBINOM(trials,p,alpha)\n"
"@DESCRIPTION=CRITBINOM function returns the smallest value for which the "
"cumulative is greater than or equal to a given value. @n is the number of "
"trials, @p is the probability of success in trials, and @alpha is the "
"criterion value.\n"
"\n"
"* If @trials is a non-integer it is truncated.\n"
"* If @trials < 0 CRITBINOM returns #NUM! error.\n"
"* If @p < 0 or @p > 1 CRITBINOM returns #NUM! error.\n"
"* If @alpha < 0 or @alpha > 1 CRITBINOM returns #NUM! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"CRITBINOM(10,0.5,0.75) equals 6.\n"
"\n"
"@SEEALSO=BINOMDIST"
msgstr ""
"@FUNCTION=CRITBINOM\n"
"@SYNTAX=CRITBINOM(intentos,p,alfa)\n"
"@DESCRIPTION=La función CRITBINOM devuelve el valor más pequeño para el que "
"el acumulado es mayor o igual que un valor dado. @n es el número de "
"intentos, @p es la probabilidad de éxito en intentos, y @alpha es el valor "
"de criterio. \n"
"\n"
"* Si @intentos no es entero, se trunca.\n"
"* Si @intentos < 0, CRITBINOM devuelve un error #NÚM!.\n"
"* Si @p < 0 ó @p > 1, CRITBINOM devuelve el error #NÚM!.\n"
"* Si @alfa < 0 ó @alfa > 1, CRITBINOM devuelve el error #NÚM!.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"CRITBINOM(10,0.5,0.75) igual a 6.\n"
"\n"
"@SEEALSO=BINOMDIST"

#: ../plugins/fn-stat/functions.c:1884
msgid ""
"@FUNCTION=PERMUT\n"
"@SYNTAX=PERMUT(n,k)\n"
"@DESCRIPTION=PERMUT function returns the number of permutations. @n is the "
"number of objects, @k is the number of objects in each permutation.\n"
"\n"
"* If @n = 0 PERMUT returns #NUM! error.\n"
"* If @n < @k PERMUT returns #NUM! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"PERMUT(7,3) equals 210.\n"
"\n"
"@SEEALSO=COMBIN"
msgstr ""
"@FUNCTION=PERMUT\n"
"@SYNTAX=PERMUT(n,k)\n"
"@DESCRIPTION=La función PERMUT devuelve el número de permutaciones. @n es el "
"número de objetos, @k es el número de objetos en cada permutación.\n"
"\n"
"* Si @n = 0, PERMUT devuelve el error #NÚM!.\n"
"* Si @n < @k, PERMUT devuelve el error #NÚM!.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"PERMUT(7,3) igual a 210.\n"
"\n"
"@SEEALSO=COMBIN"

#: ../plugins/fn-stat/functions.c:1920
msgid ""
"@FUNCTION=HYPGEOMDIST\n"
"@SYNTAX=HYPGEOMDIST(x,n,M,N[,cumulative])\n"
"@DESCRIPTION=HYPGEOMDIST function returns the hypergeometric distribution. "
"@x is the number of successes in the sample, @n is the number of trials, @M "
"is the number of successes overall, and @N is the population size.\n"
"\n"
"If the optional argument @cumulative is TRUE, the cumulative left tail will "
"be returned.\n"
"\n"
"* If @x,@n,@M or @N is a non-integer it is truncated.\n"
"* If @x,@n,@M or @N < 0 HYPGEOMDIST returns #NUM! error.\n"
"* If @x > @M or @n > @N HYPGEOMDIST returns #NUM! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"HYPGEOMDIST(1,2,3,10) equals 0.4666667.\n"
"\n"
"@SEEALSO=BINOMDIST,POISSON"
msgstr ""
"@FUNCTION=HYPGEOMDIST\n"
"@SYNTAX=HYPGEOMDIST(x,n,M,N[,cumulative])\n"
"@DESCRIPTION=La función HYPGEOMDIST devuelve la distribución "
"hipergeométrica. @x es el número de éxitos en la muestra, @n es el número de "
"intentos, @M es el número de éxitos en total y @N es el tamaño de la "
"población.\n"
"\n"
"si el argumento opcional @acumulativo es VERDADERO, la cola acumulativa "
"izquierda será devuelta.\n"
"\n"
"* Si @x, @n, @M ó @N no son enteros, se truncan.\n"
"* Si @x, @n, @M ó @N < 0, HYPGEOMDIST devuelve el error #NÚM!.\n"
"* Si @x > @M ó @n > @N, HYPGEOMDIST devuelve el error #NÚM!.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"HYPGEOMDIST(1,2,3,10) igual a 0.4666667.\n"
"\n"
"@SEEALSO=BINOMDIST,POISSON"

#: ../plugins/fn-stat/functions.c:1967
msgid ""
"@FUNCTION=CONFIDENCE\n"
"@SYNTAX=CONFIDENCE(x,stddev,size)\n"
"@DESCRIPTION=CONFIDENCE function returns the confidence interval for a mean. "
"@x is the significance level, @stddev is the population standard deviation, "
"and @size is the size of the sample.\n"
"\n"
"* If @size is non-integer it is truncated.\n"
"* If @size < 0 CONFIDENCE returns #NUM! error.\n"
"* If @size is 0 CONFIDENCE returns #DIV/0! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"CONFIDENCE(0.05,1,33) equals 0.341185936.\n"
"\n"
"@SEEALSO=AVERAGE"
msgstr ""
"@FUNCTION=CONFIDENCE\n"
"@SYNTAX=CONFIDENCE(x,desvstd,tamaño)\n"
"@DESCRIPTION=CONFIDENCE devuelve el intervalo de confianza de la media. @x "
"es el nivel de significancia, @desvstd es la desviación estándar de la "
"población y @tamaño corresponde al tamaño de la muestra.\n"
"\n"
"* Si @tamaño no es un número entero, entonces se trunca.\n"
"* Si @tamaño < 0, CONFIDENCE devuelve el error #NÚM!.\n"
"* Si @tamaño es 0, CONFIDENCE devuelve el error #DIV/0!.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"CONFIDENCE(0,05;1;33) es igual a 0,341185936.\n"
"\n"
"@SEEALSO=AVERAGE"

#: ../plugins/fn-stat/functions.c:2005
msgid ""
"@FUNCTION=STANDARDIZE\n"
"@SYNTAX=STANDARDIZE(x,mean,stddev)\n"
"@DESCRIPTION=STANDARDIZE function returns a normalized value. @x is the "
"number to be normalized, @mean is the mean of the distribution, @stddev is "
"the standard deviation of the distribution.\n"
"\n"
"* If @stddev is 0 STANDARDIZE returns #DIV/0! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"STANDARDIZE(3,2,4) equals 0.25.\n"
"\n"
"@SEEALSO=AVERAGE"
msgstr ""
"@FUNCTION=STANDARDIZE\n"
"@SYNTAX=STANDARDIZE(x,media,desvest)\n"
"@DESCRIPTION=La función STANDARDIZE devuelve un valor normalizado. @x es el "
"número a ser normalizado, @media es la media de la distribución, @desvest es "
"la desviación estándar de la distribución.\n"
"\n"
"* Si @desvest es 0, STANDARDIZE devuelve el error #DIV/0!.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"STANDARDIZE(3,2,4) igual a 0,25.\n"
"\n"
"@SEEALSO=AVERAGE"

#: ../plugins/fn-stat/functions.c:2042
msgid ""
"@FUNCTION=WEIBULL\n"
"@SYNTAX=WEIBULL(x,alpha,beta,cumulative)\n"
"@DESCRIPTION=WEIBULL function returns the Weibull distribution. If the "
"@cumulative boolean is true it will return:\n"
"\n"
"\t1 - exp (-(@x/@beta)^@alpha),\n"
"\n"
"otherwise it will return\n"
"\n"
"\t(@alpha/@beta^@alpha) * @x^(@alpha-1) * exp(-(@x/@beta^@alpha)).\n"
"\n"
"* If @x < 0 WEIBULL returns #NUM! error.\n"
"* If @alpha <= 0 or @beta <= 0 WEIBULL returns #NUM! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"WEIBULL(3,2,4,0) equals 0.213668559.\n"
"\n"
"@SEEALSO=POISSON"
msgstr ""
"@FUNCTION=WEIBULL\n"
"@SYNTAX=WEIBULL(x,alfa,beta,acumulado)\n"
"@DESCRIPTION=La función WEIBULL devuelve la distribución Weibull. Si el "
"booleano @acumulado es cierto, devolverá: \n"
"\n"
"\t1 - exp (-(@x/@beta)^@alfa),\n"
"\n"
"en otro caso, devolverá\n"
"\n"
"\t(@alfa/@beta^@alfa) * @x* (@alfa-1) * exp(-(@x/@beta^@alfa)).\n"
"\n"
"* Si @x < 0, WEIBULL devuelve el error #NÚM!.\n"
"* Si @alfa <= 0 ó @beta <= 0, WEIBULL devuelve el error #NÚM!.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"WEIBULL(3,2,4,0) igual a 0.213668559.\n"
"\n"
"@SEEALSO=POISSON"

#: ../plugins/fn-stat/functions.c:2084
msgid ""
"@FUNCTION=NORMDIST\n"
"@SYNTAX=NORMDIST(x,mean,stddev,cumulative)\n"
"@DESCRIPTION=The NORMDIST function returns the value of the probability "
"density function or the cumulative distribution function for the normal "
"distribution with the mean given by @mean, and the standard deviation given "
"by @stddev. If @cumulative is FALSE, NORMDIST returns the value of the "
"probability density function at the value @x. If @cumulative is TRUE, "
"NORMDIST returns the value of the cumulative distribution function at @x.\n"
"\n"
"* If @stddev is 0 NORMDIST returns #DIV/0! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"NORMDIST(2,1,2,0) equals 0.176032663.\n"
"\n"
"@SEEALSO=POISSON"
msgstr ""
"@FUNCTION=NORMDIST\n"
"@SYNTAX=NORMDIST(x,media,desvest,acumulado)\n"
"@DESCRIPTION=La función NORMDIST devuelve el valor de la función de densidad "
"de la distribución normal acumulada con la media dada por @media, y la "
"desviación estándar dada por @desvest. si @acumulado es FALSO, NORMDIST "
"devuelve el valor de la función de densidad de probabilidad en el valor @x. "
"Si @acumuilado es VERDADERO, NORMDIST devueleve el valor de la función de "
"distribución acumulativa en @x.\n"
"\n"
"* Si @desvest es 0, NORMDIST devuelve el error #DIV/0!.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"NORMDIST(2,1,2,0) igual a 0.176032663.\n"
"\n"
"@SEEALSO=POISSON"

#: ../plugins/fn-stat/functions.c:2130
msgid ""
"@FUNCTION=NORMINV\n"
"@SYNTAX=NORMINV(p,mean,stddev)\n"
"@DESCRIPTION=NORMINV function returns the inverse of the normal cumulative "
"distribution. @p is the given probability corresponding to the normal "
"distribution, @mean is the arithmetic mean of the distribution, and @stddev "
"is the standard deviation of the distribution.\n"
"\n"
"* If @p < 0 or @p > 1 or @stddev <= 0 NORMINV returns #NUM! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"NORMINV(0.76,2,3) equals 4.118907689.\n"
"\n"
"@SEEALSO=NORMDIST,NORMSDIST,NORMSINV,STANDARDIZE,ZTEST"
msgstr ""
"@FUNCTION=NORMINV\n"
"@SYNTAX=NORMINV(p,media,desvest)\n"
"@DESCRIPTION=La función NORMINV devuelve la inversa de la distribución "
"normal acumulada. @p es la probabilidad dada correspondiente a la "
"distribución normal, @media es la media aritmética de la distribución y "
"@desvest es la desviación estándar de la distribución.\n"
"\n"
"* Si @p < 0 ó @p > 1 ó @desvest <= 0, NORMINV devuelve el error #NÚM!.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"NORMINV(0.76,2,3) igual a 4.118907689.\n"
"\n"
"@SEEALSO=NORMDIST,NORMSDIST,NORMSINV,STANDARDIZE,ZTEST"

#: ../plugins/fn-stat/functions.c:2169
msgid ""
"@FUNCTION=KURT\n"
"@SYNTAX=KURT(n1, n2, ...)\n"
"@DESCRIPTION=KURT returns an unbiased estimate of the kurtosis of a data "
"set.\n"
"Note, that this is only meaningful if the underlying distribution really has "
"a fourth moment.  The kurtosis is offset by three such that a normal "
"distribution will have zero kurtosis.\n"
"\n"
"* Strings and empty cells are simply ignored.\n"
"* If fewer than four numbers are given or all of them are equal KURT returns "
"#DIV/0! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
"21.3, 25.9, and 40.1.  Then\n"
"KURT(A1:A5) equals 1.234546305.\n"
"\n"
"@SEEALSO=AVERAGE,VAR,SKEW,KURTP"
msgstr ""
"@FUNCTION=KURT\n"
"@SYNTAX=KURT(n1, n2, …)\n"
"@DESCRIPTION=KURT devuelve una estimación imparcial de la kurtosis de un "
"conjunto de datos.\n"
"Note que esto sólo tiene significado pleno si la distribución subyacente "
"tiene realmente un cuarto momento. La kurtosis se desplaza por tres así que "
"una distribución normal tendrá kurtosis cero.\n"
"\n"
"* Las cadenas y las celdas vacías, simplemente se ignoran.\n"
"* Si se dan menos de cuatro números o todos son iguales, KURT devuelve el "
"error #DIV/0!.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"Supongamos que las celdas A1, A2, …, A5 contienen los números 11.4, 17.3, "
"21.3, 25.9 y 40.1. Entonces\n"
"KURT(A1:A5) es igual a 1.234546305.\n"
"\n"
"@SEEALSO=AVERAGE,VAR,SKEW,KURTP"

#: ../plugins/fn-stat/functions.c:2210
msgid ""
"@FUNCTION=KURTP\n"
"@SYNTAX=KURTP(n1, n2, ...)\n"
"@DESCRIPTION=KURTP returns the population kurtosis of a data set.\n"
"\n"
"* Strings and empty cells are simply ignored.\n"
"* If fewer than two numbers are given or all of them are equal KURTP returns "
"#DIV/0! error.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
"21.3, 25.9, and 40.1.  Then\n"
"KURTP(A1:A5) equals -0.691363424.\n"
"\n"
"@SEEALSO=AVERAGE,VARP,SKEWP,KURT"
msgstr ""
"@FUNCTION=KURTP\n"
"@SYNTAX=KURTP(n1, n2, …)\n"
"@DESCRIPTION=KURTP devuelve la población kurtosis de un conjunto de datos.\n"
"\n"
"* Las cadenas y las celdas vacías simplemente se ignoran.\n"
"* Si se dan menos de dos números o todos son iguales, KURTP devuelve el "
"error #DIV/0!.\n"
"\n"
"@EXAMPLES=\n"
"Supongamos que las celdas A1, A2, …, A5 contienen los números 11.4, 17.3, "
"21.3, 25.9 y 40.1. Entonces\n"
"KURTP(A1:A5) es igual a -0.691363424.\n"
"\n"
"@SEEALSO=AVERAGE,VARP,SKEWP,KURT"

#: ../plugins/fn-stat/functions.c:2245
msgid ""
"@FUNCTION=AVEDEV\n"
"@SYNTAX=AVEDEV(n1, n2, ...)\n"
"@DESCRIPTION=AVEDEV returns the average of the absolute deviations of a data "
"set from their mean.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
"21.3, 25.9, and 40.1.  Then\n"
"AVEDEV(A1:A5) equals 7.84.\n"
"\n"
"@SEEALSO=STDEV"
msgstr ""
"@FUNCTION=AVEDEV\n"
"@SYNTAX=AVEDEV(n1, n2, …)\n"
"@DESCRIPTION=AVEDEV devuelve la media de las desviaciones absolutas de un "
"conjunto de datos de su media.\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"Supongamos que las celdas A1, A2, …, A5 contienen los números 11.4, 17.3, "
"21.3, 25.9 y 40.1. Entonces\n"
"AVEDEV(A1:A5) igual a 7.84.\n"
"\n"
"@SEEALSO=STDEV"

#: ../plugins/fn-stat/functions.c:2278
msgid ""
"@FUNCTION=DEVSQ\n"
"@SYNTAX=DEVSQ(n1, n2, ...)\n"
"@DESCRIPTION=DEVSQ returns the sum of squares of deviations of a data set "
"from the sample mean.\n"
"\n"
"* Strings and empty cells are simply ignored.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
"21.3, 25.9, and 40.1.  Then\n"
"DEVSQ(A1:A5) equals 470.56.\n"
"\n"
"@SEEALSO=STDEV"
msgstr ""
"@FUNCTION=DEVSQ\n"
"@SYNTAX=DEVSQ(n1, n2, …)\n"
"@DESCRIPTION=DEVSQ devuelve la suma de los cuadrados de las desviaciones de "
"un conjunto de datos de la media de su muestra.\n"
"\n"
"* Las cadenas y las celdas vacías simplemente se ignoran.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"Supongamos que las celdas A1, A2, …, A5 contienen los números 11.4, 17.3, "
"21.3, 25.9 y 40.1. Entonces\n"
"DEVSQ(A1:A5) igual a 470.56.\n"
"\n"
"@SEEALSO=STDEV"

#: ../plugins/fn-stat/functions.c:2313
msgid ""
"@FUNCTION=FISHER\n"
"@SYNTAX=FISHER(x)\n"
"@DESCRIPTION=FISHER function returns the Fisher transformation at @x.\n"
"\n"
"* If @x is not a number, FISHER returns #VALUE! error.\n"
"* If @x <= -1 or @x >= 1, FISHER returns #NUM! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"FISHER(0.332) equals 0.345074339.\n"
"\n"
"@SEEALSO=SKEW"
msgstr ""
"@FUNCTION=FISHER\n"
"@SYNTAX=FISHER(x)\n"
"@DESCRIPTION=La función FISHER devuelve la transformación de Fisher en @x.\n"
"\n"
"* Si @x no es un número, FISHER devuelve el error #VALOR!.\n"
"* Si @x <= -1 ó @x >=1, FISHER devuelve el error #NÚM!.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"FISHER(0.332) igual a 0.345074339.\n"
"\n"
"@SEEALSO=SKEW"

#: ../plugins/fn-stat/functions.c:2351
msgid ""
"@FUNCTION=POISSON\n"
"@SYNTAX=POISSON(x,mean,cumulative)\n"
"@DESCRIPTION=POISSON function returns the Poisson distribution. @x is the "
"number of events, @mean is the expected numeric value @cumulative describes "
"whether to return the sum of the Poisson function from 0 to @x.\n"
"\n"
"* If @x is a non-integer it is truncated.\n"
"* If @x < 0 POISSON returns #NUM! error.\n"
"* If @mean <= 0 POISSON returns the #NUM! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"POISSON(3,6,0) equals 0.089235078.\n"
"\n"
"@SEEALSO=NORMDIST, WEIBULL"
msgstr ""
"@FUNCTION=POISSON\n"
"@SYNTAX=POISSON(x,media,acumulativo)\n"
"@DESCRIPTION=Devuelve la distribución de Poisson, @x es la cantidad de "
"eventos, @media es el valor numérico esperado, @acumulativo describe si se "
"debe devolver la suma de la función de Poisson de 0 a @x.\n"
"\n"
"* Si @x no es un entero será truncado.\n"
"* Si @x <= 0 POISSON devuelve el error #NÚM!\n"
"* Si @media <= 0 POISSON devuelve el error #NÚM!\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"POISSON(3;6;0) es igual a 0,089235078.\n"
"\n"
"@SEEALSO=NORMDIST, WEIBULL"

#: ../plugins/fn-stat/functions.c:2393
msgid ""
"@FUNCTION=PEARSON\n"
"@SYNTAX=PEARSON(array1,array2)\n"
"@DESCRIPTION=PEARSON returns the Pearson correlation coefficient of two data "
"sets.\n"
"\n"
"* Strings and empty cells are simply ignored.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=INTERCEPT,LINEST,RSQ,SLOPE,STEYX"
msgstr ""
"@FUNCTION=PEARSON\n"
"@SYNTAX=PEARSON(array1;array2)\n"
"@DESCRIPTION=Devuelve el coeficiente de correlación de Pearson para dos "
"conjuntos de datos.\n"
"\n"
"* Se ignoran las cadenas de texto y las celdas vacías.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=INTERCEPT,LINEST,RSQ,SLOPE,STEYX"

#: ../plugins/fn-stat/functions.c:2421
msgid ""
"@FUNCTION=RSQ\n"
"@SYNTAX=RSQ(array1,array2)\n"
"@DESCRIPTION=RSQ returns the square of the Pearson correlation coefficient "
"of two data sets.\n"
"\n"
"* Strings and empty cells are simply ignored.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=CORREL,COVAR,INTERCEPT,LINEST,LOGEST,PEARSON,SLOPE,STEYX,TREND"
msgstr ""
"@FUNCTION=RSQ\n"
"@SYNTAX=RSQ(array1,array2)\n"
"@DESCRIPTION=RSQ devuelve el cuadrado del coeficiente de correlación de "
"Pearson de dos conjuntos de datos.\n"
"\n"
"* Las cadenas y las celdas vacías simplemente se ignoran.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=CORREL,COVAR,INTERCEPT,LINEST,LOGEST,PEARSON,SLOPE,STEYX,TREND"

#: ../plugins/fn-stat/functions.c:2455
msgid ""
"@FUNCTION=MEDIAN\n"
"@SYNTAX=MEDIAN(n1, n2, ...)\n"
"@DESCRIPTION=MEDIAN returns the median of the given data set.\n"
"\n"
"* Strings and empty cells are simply ignored.\n"
"* If even numbers are given MEDIAN returns the average of the two numbers in "
"the middle.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
"21.3, 25.9, and 40.1.  Then\n"
"MEDIAN(A1:A5) equals 21.3.\n"
"\n"
"@SEEALSO=AVERAGE,COUNT,COUNTA,DAVERAGE,MODE,SSMEDIAN,SUM"
msgstr ""
"@FUNCTION=MEDIAN\n"
"@SYNTAX=MEDIAN(n1;n2;…)\n"
"@DESCRIPTION=Devuelve la mediana del conjunto de datos.\n"
"\n"
"* Las cadenas y celdas vacías son ignoradas. \n"
"* Si el número de datos es par, MEDIAN devuelve el media de los dos números "
"del medio.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"Suponiendo que las celdas A1, A2, …, A5 contengan los números 11,4; 17,3, "
"21,3; 25,9 y 40,1. Entonces\n"
"MEDIAN(A1:A5) es igual a 21,3.\n"
"\n"
"@SEEALSO=AVERAGE,COUNT,COUNTA,DAVERAGE,MODE,SUM"

#: ../plugins/fn-stat/functions.c:2492
msgid ""
"@FUNCTION=SSMEDIAN\n"
"@SYNTAX=SSMEDIAN(array[,interval)]\n"
"@DESCRIPTION=The SSMEDIAN function returns the median for grouped data as "
"commonly determined in the social sciences. The data points given in @array "
"are assumed to be the result of grouping data into intervals of length "
"@interval\n"
"\n"
"* If @interval is not given, SSMEDIAN uses 1.\n"
"* If @array is empty, SSMEDIAN returns #NUM! error.\n"
"* If @interval <= 0, SSMEDIAN returns #NUM! error.\n"
"* SSMEDIAN does not check whether the data points are at least @interval "
"apart.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1, A2, A3 contain numbers 7, 8, 8.  Then\n"
"SSMEDIAN(A1:A3, 1) equals 7.75.\n"
"\n"
"@SEEALSO=MEDIAN"
msgstr ""
"@FUNCTION=SSMEDIAN\n"
"@SYNTAX=SSMEDIAN(array[,intervalo]))\n"
"@DESCRIPTION=La función SSMEDIAN devuelve la media para datos agrupados como "
"los que se determinan comúnmente en las ciencias sociales. Los puntos de "
"datos dados en e@array se asumen que son el resultado de la agrupación de "
"datos en intervalos de longitud @intervalo.\n"
"\n"
"* Si no se da @intervalo, SSMEDIAN usa 1.\n"
"* Si @array está vacío, SSMEDIAN devuelve el error #NÚM!.\n"
"* Si @intervalo <= 0, SSMEDIAN devuelve el error #NÚM!.\n"
"* ssmedian no comprueba si los puntos de datos son al menos un @intervalo a "
"parte.\n"
"\n"
"@EXAMPLES=\n"
"Supongamos que las celdas A1, A2, A3 contienen los números 7, 8, 8. "
"Entonces\n"
"SSMEDIAN(A1:A3, 1) igual a 7.75.\n"
"\n"
"@SEEALSO=MEDIAN"

#: ../plugins/fn-stat/functions.c:2598
msgid ""
"@FUNCTION=LARGE\n"
"@SYNTAX=LARGE(n, k)\n"
"@DESCRIPTION=LARGE returns the k-th largest value in a data set.\n"
"\n"
"* If data set is empty LARGE returns #NUM! error.\n"
"* If @k <= 0 or @k is greater than the number of data items given LARGE "
"returns #NUM! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
"21.3, 25.9, and 40.1.  Then\n"
"LARGE(A1:A5,2) equals 25.9.\n"
"LARGE(A1:A5,4) equals 17.3.\n"
"\n"
"@SEEALSO=PERCENTILE,PERCENTRANK,QUARTILE,SMALL"
msgstr ""
"@FUNCTION=LARGE\n"
"@SYNTAX=LARGE(n, k)\n"
"@DESCRIPTION=LARGE devuelve el k-ésimo mayor valor en un conjunto de datos.\n"
"\n"
"* Si el conjunto de datos está vacío, devuelve el error #NÚM!.\n"
"* Si @k <= 0 o @k es mayor que el número de términos, LARGE devuelve el "
"error #NÚM!.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"Suponiendo que las celdas A1, A2, …, A5 contengan los números 11,4; 17,3, "
"21,3; 25,9 y 40,1. Entonces\n"
"LARGE(A1:A5;2) es igual a 25,9.\n"
"LARGE(A1:A5;4) es igual a 17,3.\n"
"\n"
"@SEEALSO=PERCENTILE,PERCENTRANK,QUARTILE,SMALL"

#: ../plugins/fn-stat/functions.c:2654
msgid ""
"@FUNCTION=SMALL\n"
"@SYNTAX=SMALL(n, k)\n"
"@DESCRIPTION=SMALL returns the k-th smallest value in a data set.\n"
"\n"
"* If data set is empty SMALL returns #NUM! error.\n"
"* If @k <= 0 or @k is greater than the number of data items given SMALL "
"returns #NUM! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
"21.3, 25.9, and 40.1.  Then\n"
"SMALL(A1:A5,2) equals 17.3.\n"
"SMALL(A1:A5,4) equals 25.9.\n"
"\n"
"@SEEALSO=PERCENTILE,PERCENTRANK,QUARTILE,LARGE"
msgstr ""
"@FUNCTION=SMALL\n"
"@SYNTAX=SMALL(n, k)\n"
"@DESCRIPTION=SMALL devuelve el k-ésimo menor valor en un conjunto de datos.\n"
"\n"
"* Si el conjunto de datos está vacío, entonces devuelve el error #NÚM!.\n"
"* Si @k <= 0 o @k es mayor que el número de términos, SMALL devuelve el "
"error #NÚM!.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"Suponiendo que las celdas A1, A2, …, A5 contengan los números 11,4; 17,3, "
"21,3; 25,9 y 40,1. Entonces\n"
"LARGE(A1:A5;2) es igual a 17,3.\n"
"LARGE(A1:A5;4) es igual a 25,9.\n"
"\n"
"@SEEALSO=PERCENTILE,PERCENTRANK,QUARTILE,LARGE"

#: ../plugins/fn-stat/functions.c:2736
msgid ""
"@FUNCTION=PROB\n"
"@SYNTAX=PROB(x_range,prob_range,lower_limit[,upper_limit])\n"
"@DESCRIPTION=PROB function returns the probability that values in a range or "
"an array are between two limits. If @upper_limit is not given, PROB returns "
"the probability that values in @x_range are equal to @lower_limit.\n"
"\n"
"* If the sum of the probabilities in @prob_range is not equal to 1 PROB "
"returns #NUM! error.\n"
"* If any value in @prob_range is <=0 or > 1, PROB returns #NUM! error.\n"
"* If @x_range and @prob_range contain a different number of data entries, "
"PROB returns #N/A error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=BINOMDIST,CRITBINOM"
msgstr ""
"@FUNCTION=PROB\n"
"@SYNTAX=PROB(rango_x,rango_prob,límite_inf[,límite_sup])\n"
"@DESCRIPTION=La función PROB devuelve la probabilidad de que los valores de "
"un rango o un array estén entre dos límites. Si @límite_sup no se da, PROB "
"devuelve la probabilidad de que los valores de @rango_x sean iguales a "
"@límite_inf.\n"
"\n"
"* Si la suma de las probabilidades de @rango_prob no es igual a 1, PROB "
"devuelve el error #NÚM!.\n"
"* Si cualquier valor de @rango_prob es <= 0 ó > 1, PROB devuelve el error "
"#NÚM!.\n"
"* Si @rango_x y @rango_prob contiene un número diferentes de entradas de "
"datos, PROB devuelve el error #N/D.\n"
"* Esta función es compatible con Excel\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=BINOMDIST,CRITBINOM"

#: ../plugins/fn-stat/functions.c:2831
msgid ""
"@FUNCTION=STEYX\n"
"@SYNTAX=STEYX(known_y's,known_x's)\n"
"@DESCRIPTION=STEYX function returns the standard error of the predicted y-"
"value for each x in the regression.\n"
"\n"
"* If @known_y's and @known_x's are empty or have a different number of "
"arguments then STEYX returns #N/A error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
"21.3, 25.9, and 40.1, and the cells B1, B2, ... B5 23.2, 25.8, 29.9, 33.5, "
"and 42.7.  Then\n"
"STEYX(A1:A5,B1:B5) equals 1.101509979.\n"
"\n"
"@SEEALSO=PEARSON,RSQ,SLOPE"
msgstr ""
"@FUNCTION=STEYX\n"
"@SYNTAX=STEYX(y_conocido,x_conocido)\n"
"@DESCRIPTION=La función STEYX devuelve el error estándar de los valores de y "
"previstos por cada x en la regresión.\n"
"\n"
"* Si @y_conocido y @x_conocido están vacíos o tienen diferente número de "
"argumentos, STEYX devuelve el error #N/D.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"Supongamos que las celdas A1, A2, …, A5 contienen los números 11.4, 17.3, "
"21.3, 25.9 y 40.1, y las celdas B1, B2, … B5 23.2, 25.8, 29.9, 33.5 y 42.7. "
"Entonces\n"
"STEYX(A1:A5,B1:B5) igual a 1.101509979.\n"
"\n"
"@SEEALSO=PEARSON,RSQ,SLOPE"

#: ../plugins/fn-stat/functions.c:2989
msgid ""
"@FUNCTION=ZTEST\n"
"@SYNTAX=ZTEST(ref,x[,stddev])\n"
"@DESCRIPTION=ZTEST returns the two-tailed probability of a z-test.\n"
"\n"
"@ref is the data set and @x is the value to be tested.\n"
"@stddev is optionally an assumed standard deviation.\n"
"\n"
"* If @ref contains less than two data items ZTEST returns #DIV/0! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
"21.3, 25.9, and 40.1.  Then\n"
"ZTEST(A1:A5,20) equals 0.254717826.\n"
"\n"
"@SEEALSO=CONFIDENCE,NORMDIST,NORMINV,NORMSDIST,NORMSINV,STANDARDIZE"
msgstr ""
"@FUNCTION=ZTEST\n"
"@SYNTAX=ZTEST(ref,x[,stddev])\n"
"@DESCRIPTION=ZTEST devuelve la probabilidad de dos colas de una prueba Z.\n"
"\n"
"@ref es el conjunto de datos y @x es el valor a ser probado.\n"
"@stddev es opcional y representa una desviación estándar.\n"
"\n"
"* Si @ref contiene menos de dos elementos de datos, ZTEST devuelve el error "
"#DIV/0!.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"Supongamos que las celdas A1, A2, …, A5 contienen los números 11.4, 17.3, "
"21.3, 25.9 y 40.1. Entonces\n"
"ZTEST(A1:A5,20) igual a 0.254717826.\n"
"\n"
"@SEEALSO=CONFIDENCE,NORMDIST,NORMINV,NORMSDIST,NORMSINV,STANDARDIZE"

#: ../plugins/fn-stat/functions.c:3060
msgid ""
"@FUNCTION=AVERAGEA\n"
"@SYNTAX=AVERAGEA(number1,number2,...)\n"
"@DESCRIPTION=AVERAGEA returns the average of the given arguments.  Numbers, "
"text and logical values are included in the calculation too. If the cell "
"contains text or the argument evaluates to FALSE, it is counted as value "
"zero (0).  If the argument evaluates to TRUE, it is counted as one (1).  "
"Note that empty cells are not counted.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1, A2, ..., A5 contain numbers and strings "
"11.4, 17.3, \"missing\", 25.9, and 40.1.  Then\n"
"AVERAGEA(A1:A5) equals 18.94.\n"
"\n"
"@SEEALSO=AVERAGE"
msgstr ""
"@FUNCTION=AVERAGEA\n"
"@SYNTAX=AVERAGEA(valor1;valor2;…)\n"
"@DESCRIPTION=Calcula el media de los valores y celdas referenciados en la "
"lista de argumentos. Se incluyen en el cálculo los números y también los "
"textos y expresiones lógicas. Si la celda contiene texto o la expresión "
"lógica FALSO, se contará como un cero (0). Si contiene un valor lógico "
"VERDADERO se contará como un uno (1). Note que las celdas vacías no son "
"contadas.\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"Suponiendo que las celdas A1, A2, …, A5 contienen los números 11,4; 17,5; "
"\"vacío\"; 25,9 y 40,1. Entonces\n"
"AVERAGEA(A1:A5) es igual a 18,94.\n"
"\n"
"@SEEALSO=AVERAGE"

#: ../plugins/fn-stat/functions.c:3098
msgid ""
"@FUNCTION=MAXA\n"
"@SYNTAX=MAXA(number1,number2,...)\n"
"@DESCRIPTION=MAXA returns the largest value of the given arguments.  "
"Numbers, text and logical values are included in the calculation too. If the "
"cell contains text or the argument evaluates to FALSE, it is counted as "
"value zero (0).  If the argument evaluates to TRUE, it is counted as one "
"(1).  Note that empty cells are not counted.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1, A2, ..., A5 contain numbers and strings "
"11.4, 17.3, \"missing\", 25.9, and 40.1.  Then\n"
"MAXA(A1:A5) equals 40.1.\n"
"\n"
"@SEEALSO=MAX,MINA"
msgstr ""
"@FUNCTION=MAXA\n"
"@SYNTAX=MAXA(número1,número2,…)\n"
"@DESCRIPTION=MAXA devuelve el mayor valor de los argumentos dados. También "
"se incluyen en el cálculo números, texto y valores lógicos. Si la celda "
"contiene texto o el argumento se evalúa a FALSO, se cuenta como valor cero "
"(0). Si el argumento se evalúa a VERDADERO, se cuenta como uno (1). Note que "
"las celdas vacías no se cuentan.\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"Supongamos que las celdas A1, A2, …, A5 contienen los números y las cadenas "
"11.4, 17.3, \"missing\", 25.9 y 40.1. Entonces\n"
"MAXA(A1:A5) igual a 40.1.\n"
"\n"
"@SEEALSO=MAX,MINA"

#: ../plugins/fn-stat/functions.c:3137
msgid ""
"@FUNCTION=MINA\n"
"@SYNTAX=MINA(number1,number2,...)\n"
"@DESCRIPTION=MINA returns the smallest value of the given arguments.  "
"Numbers, text and logical values are included in the calculation too. If the "
"cell contains text or the argument evaluates to FALSE, it is counted as "
"value zero (0).  If the argument evaluates to TRUE, it is counted as one "
"(1).  Note that empty cells are not counted.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1, A2, ..., A5 contain numbers and strings "
"11.4, 17.3, \"missing\", 25.9, and 40.1.  Then\n"
"MINA(A1:A5) equals 0.\n"
"\n"
"@SEEALSO=MIN,MAXA"
msgstr ""
"@FUNCTION=MINA\n"
"@SYNTAX=MINA(número1,número2,…)\n"
"@DESCRIPTION=MINA devuelve el menor valor de los argumentos dados. También "
"se incluyen en el cálculo números, texto y valores lógicos. Si la celda "
"contiene texto o el argumento se evalúa a FALSO, se cuenta como valor cero "
"(0). Si el argumento se evalúa a VERDADERO, se cuenta como uno (1). Note que "
"las celdas vacías no se cuentan.\n"
"\n"
"Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"Supongamos que las celdas A1, A2, …, A5 contienen los números y las cadenas "
"11.4, 17.3, \"missing\", 25.9 y 40.1. Entonces\n"
"MINA(A1:A5) igual a 0.\n"
"\n"
"@SEEALSO=MIN,MAXA"

#: ../plugins/fn-stat/functions.c:3176
msgid ""
"@FUNCTION=VARA\n"
"@SYNTAX=VARA(number1,number2,...)\n"
"@DESCRIPTION=VARA calculates sample variance of the given sample.\n"
"To get the true variance of a complete population use VARPA.\n"
"VARA is also known as the N-1-variance.\n"
"Under reasonable conditions, it is the maximum-likelihood estimator for the "
"true variance.\n"
"Numbers, text and logical values are included in the calculation too. If the "
"cell contains text or the argument evaluates to FALSE, it is counted as "
"value zero (0).  If the argument evaluates to TRUE, it is counted as one "
"(1).  Note that empty cells are not counted.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1, A2, ..., A5 contain numbers and strings "
"11.4, 17.3, \"missing\", 25.9, and 40.1.  Then\n"
"VARA(A1:A5) equals 228.613.\n"
"\n"
"@SEEALSO=VAR,VARPA"
msgstr ""
"@FUNCTION=VARA\n"
"@SYNTAX=VARA(número1,número2,…)\n"
"@DESCRIPTION=VARA devuelve la varianza basada en una muestra. Para obtener "
"la varianza verdadera de una población completa use VARPA.\n"
"VARA también se conoce como la N-1 varianza. Bajo condiciones razonables, es "
"el estimador de semejanza máxima para la varianza verdadera.También se "
"incluyen en el cálculo números, texto y valores lógicos. Si la celda "
"contiene texto o el argumento se evalúa a FALSO, se cuenta como valor cero "
"(0). Si el argumento se evalúa a VERDADERO, se cuenta como uno (1). Note que "
"las celdas vacías no se cuentan.\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"Supongamos que las celdas A1, A2, …, A5 contienen los números y las cadenas "
"11.4, 17.3, \"missing\", 25.9 y 40.1. Entonces\n"
"VARA(A1:A5) igual a 228.613.\n"
"\n"
"@SEEALSO=VAR,VARPA"

#: ../plugins/fn-stat/functions.c:3220
msgid ""
"@FUNCTION=VARPA\n"
"@SYNTAX=VARPA(number1,number2,...)\n"
"@DESCRIPTION=VARPA calculates the variance of an entire population.\n"
"VARPA is also known as the N-variance.\n"
"Numbers, text and logical values are included in the calculation too.  If "
"the cell contains text or the argument evaluates to FALSE, it is counted as "
"value zero (0).  If the argument evaluates to TRUE, it is counted as one "
"(1).  Note that empty cells are not counted.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1, A2, ..., A5 contain numbers and strings "
"11.4, 17.3, \"missing\", 25.9, and 40.1.  Then\n"
"VARPA(A1:A5) equals 182.8904.\n"
"\n"
"@SEEALSO=VARA,VARP"
msgstr ""
"@FUNCTION=VARPA\n"
"@SYNTAX=VARPA(número1,número2,…)\n"
"@DESCRIPTION=VARPA devuelve la varianza basada en la población entera. VARPA "
"también se conoce como la N-varianza.\n"
" También se incluyen en el cálculo números, texto y valores lógicos. Si la "
"celda contiene texto o el argumento se evalúa a FALSO, se cuenta como valor "
"cero (0). Si el argumento se evalúa a VERDADERO, se cuenta como uno (1). "
"Note que las celdas vacías no se cuentan.\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"Supongamos que las celdas A1, A2, …, A5 contienen los números y las cadenas "
"11.4, 17.3, \"missing\", 25.9 y 40.1. Entonces\n"
"VARPA(A1:A5) igual a 182.8904.\n"
"\n"
"@SEEALSO=VARP,VARP"

#: ../plugins/fn-stat/functions.c:3259
msgid ""
"@FUNCTION=STDEVA\n"
"@SYNTAX=STDEVA(number1,number2,...)\n"
"@DESCRIPTION=STDEVA returns the sample standard deviation of the given "
"sample.\n"
"To obtain the population standard deviation of a whole population use "
"STDEVPA.\n"
"STDEVA is also known as the N-1-standard deviation.\n"
"Under reasonable conditions, it is the maximum-likelihood estimator for the "
"true population standard deviation.\n"
"Numbers, text and logical values are included in the calculation too.  If "
"the cell contains text or the argument evaluates to FALSE, it is counted as "
"value zero (0).  If the argument evaluates to TRUE, it is counted as one "
"(1).  Note that empty cells are not counted.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1, A2, ..., A5 contain numbers and strings "
"11.4, 17.3, \"missing\", 25.9, and 40.1.  Then\n"
"STDEVA(A1:A5) equals 15.119953704.\n"
"\n"
"@SEEALSO=STDEV,STDEVPA"
msgstr ""
"@FUNCTION=STDEVA\n"
"@SYNTAX=STDEVA(número1,número2,…)\n"
"@DESCRIPTION=STDEVA devuelve la desviación estándar basada en una muestra. "
"Para obtener la desviación de población estándar de una población complete "
"use STDEVPA.\n"
"STDEVA también se conoce como la N-1 desviación estándar.\n"
"También se incluyen en el cálculo números, texto y valores lógicos. Si la "
"celda contiene texto o el argumento se evalúa a FALSO, se cuenta como valor "
"cero (0). Si el argumento se evalúa a VERDADERO, se cuenta como uno (1). "
"Note que las celdas vacías no se cuentan.\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"Supongamos que las celdas A1, A2, …, A5 contienen los números y las cadenas "
"11.4, 17.3, \"missing\", 25.9 y 40.1. Entonces\n"
"STDEVA(A1:A5) igual a 15.119953704.\n"
"\n"
"@SEEALSO=STDEV,STDEVPA"

#: ../plugins/fn-stat/functions.c:3304
msgid ""
"@FUNCTION=STDEVPA\n"
"@SYNTAX=STDEVPA(number1,number2,...)\n"
"@DESCRIPTION=STDEVPA returns the population standard deviation of an entire "
"population.\n"
"This is also known as the N-standard deviation\n"
"Numbers, text and logical values are included in the calculation too.  If "
"the cell contains text or the argument evaluates to FALSE, it is counted as "
"value zero (0).  If the argument evaluates to TRUE, it is counted as one "
"(1).  Note that empty cells are not counted.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1, A2, ..., A5 contain numbers and strings "
"11.4, 17.3, \"missing\", 25.9, and 40.1.  Then\n"
"STDEVPA(A1:A5) equals 13.523697719.\n"
"\n"
"@SEEALSO=STDEVA,STDEVP"
msgstr ""
"@FUNCTION=STDEVPA\n"
"@SYNTAX=STDEVPA(número1,número2,…)\n"
"@DESCRIPTION=STDEVPA devuelve la desviación estándar basada en la población "
"entera. Esto también se conoce como la desviación N-estándar\n"
"También se incluyen en el cálculo números, texto y valores lógicos. Si la "
"celda contiene texto o el argumento se evalúa a FALSO, se cuenta como valor "
"cero (0). Si el argumento se evalúa a VERDADERO, se cuenta como uno (1). "
"Note que las celdas vacías no se cuentan.\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"Supongamos que las celdas A1, A2, …, A5 contienen los números y las cadenas "
"11.4, 17.3, \"missing\", 25.9 y 40.1. Entonces\n"
"STDEVPA(A1:A5) igual a 13.523697719.\n"
"\n"
"@SEEALSO=STDEVA,STDEVP"

#: ../plugins/fn-stat/functions.c:3344
msgid ""
"@FUNCTION=PERCENTRANK\n"
"@SYNTAX=PERCENTRANK(array,x[,significance])\n"
"@DESCRIPTION=PERCENTRANK function returns the rank of a data point in a data "
"set.  @array is the range of numeric values, @x is the data point which you "
"want to rank, and the optional @significance specifies the number of "
"significant digits for the returned value, truncating the remainder.  If "
"@significance is omitted, PERCENTRANK uses three digits.\n"
"\n"
"* If @array contains no data points, PERCENTRANK returns #NUM! error.\n"
"* If @significance is less than one, PERCENTRANK returns #NUM! error.\n"
"* If @x exceeds the largest value or is less than the smallest value in "
"@array, PERCENTRANK returns #NUM! error.\n"
"* If @x does not match any of the values in @array or @x matches more than "
"once, PERCENTRANK interpolates the returned value.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=LARGE,MAX,MEDIAN,MIN,PERCENTILE,QUARTILE,SMALL"
msgstr ""
"@FUNCTION=PERCENTRANK\n"
"@SYNTAX=PERCENTRANK(array,x[,significatividad])\n"
"@DESCRIPTION=La función PERCENTRANK devuelve el rango de un punto de datos "
"en un conjunto de datos. @array es el rango de valores numéricos, @x es el "
"punto de datos que quiere clasificar, y la @significatividad opcional "
"identifica el número de dígitos con significatividad para el valor devuelto, "
"truncando lo restante. Si se omite @significatividad, PERCENTRANK usa tres "
"dígitos.\n"
"\n"
"* Si @array no contiene puntos, PERCENTRANK devuelve el error #NÚM!.\n"
"* Si @signatividad < 1, PERCENTRANK devuelve el error #NÚM!.\n"
"* Si @x supera el valor más grande o es menor que el más pequeño del @array, "
"PERCENTRANK devuelve el error #NÚM!.\n"
"* Si @x no coincide con ninguno de los valores de @array ó @x coincide con "
"más de uno, PERCENTRANK interpola el valor devuelto.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=LARGE,MAX,MEDIAN,MIN,PERCENTILE,QUARTILE,SMALL"

#: ../plugins/fn-stat/functions.c:3453
msgid ""
"@FUNCTION=PERCENTILE\n"
"@SYNTAX=PERCENTILE(array,k)\n"
"@DESCRIPTION=PERCENTILE function returns the 100*@k-th percentile of the "
"given data points (that is, a number x such that a fraction @k of the data "
"points are less than x).\n"
"\n"
"* If @array is empty, PERCENTILE returns #NUM! error.\n"
"* If @k < 0 or @k > 1, PERCENTILE returns #NUM! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
"21.3, 25.9, and 40.1.  Then\n"
"PERCENTILE(A1:A5,0.42) equals 20.02.\n"
"\n"
"@SEEALSO=QUARTILE"
msgstr ""
"@FUNCTION=PERCENTILE\n"
"@SYNTAX=PERCENTILE(array,k)\n"
"@DESCRIPTION=La función PERCENTILE devuelve el 100*@k-ésimo percentil de los "
"puntos de datos dados (esto es, un número x tal que una fracción @k de los "
"puntos de datos es menor que x.). \n"
"\n"
"* Si @array está vacío, PERCENTILE devuelve el error #NÚM!.\n"
"* Si @k < 0 o @k > 1, PERCENTILE devuelve el error #NÚM!.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"Supongamos que las celdas A1, A2, …, A5 contienen los números 11.4, 17.3, "
"21.3, 25.9 y 40.1. Entonces\n"
"PERCENTILE(A1:A5,0.42) igual a 20.02.\n"
"\n"
"@SEEALSO=QUARTILE"

#: ../plugins/fn-stat/functions.c:3506
msgid ""
"@FUNCTION=QUARTILE\n"
"@SYNTAX=QUARTILE(array,quart)\n"
"@DESCRIPTION=QUARTILE function returns the quartile of the given data "
"points.\n"
"\n"
"If @quart is equal to: QUARTILE returns:\n"
"0                      the smallest value of @array.\n"
"1                      the first quartile\n"
"2                      the second quartile\n"
"3                      the third quartile\n"
"4                      the largest value of @array.\n"
"\n"
"* If @array is empty, QUARTILE returns #NUM! error.\n"
"* If @quart < 0 or @quart > 4, QUARTILE returns #NUM! error.\n"
"* If @quart is not an integer, it is truncated.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
"21.3, 25.9, and 40.1.  Then\n"
"QUARTILE(A1:A5,1) equals 17.3.\n"
"\n"
"@SEEALSO=LARGE,MAX,MEDIAN,MIN,PERCENTILE,SMALL"
msgstr ""
"@FUNCTION=QUARTILE\n"
"@SYNTAX=QUARTILE(array,cuart)\n"
"@DESCRIPTION=La función QUARTILE devuelve el cuartil de los puntos de datos "
"dados.\n"
"\n"
"Si @cuart es igual a: QUARTILE devuelve:\n"
"0      el valor más pequeño del @array.\n"
"1      el primer cuartil.\n"
"2      el segundo cuartil.\n"
"3      el tercer cuartil.\n"
"4      el valor más grande del @array.\n"
"\n"
"* Si @array está vacío, QUARTILE devuelve el error #NÚM!.\n"
"* Si @cuart < 0 ó @quart > 4, QUARTILE devuelve el error #NÚM!.\n"
"* Si @cuart no es un entero, se trunca.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"Supongamos que las celdas A1, A2, …, A5 contienen los números 11.4, 17.3, "
"21.3, 25.9 y 40.1. Entonces\n"
"QUARTILE(A1:A5,1) igual a 17.3.\n"
"\n"
"@SEEALSO=LARGE,MAX,MEDIAN,MIN,PERCENTILE,SMALL"

#: ../plugins/fn-stat/functions.c:3566
msgid ""
"@FUNCTION=FTEST\n"
"@SYNTAX=FTEST(array1,array2)\n"
"@DESCRIPTION=FTEST function returns the two-tailed probability that the "
"variances in the given two data sets are not significantly different.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
"21.3, 25.9, and 40.1, and the cells B1, B2, ... B5 23.2, 25.8, 29.9, 33.5, "
"and 42.7.  Then\n"
"FTEST(A1:A5,B1:B5) equals 0.510815017.\n"
"\n"
"@SEEALSO=FDIST,FINV"
msgstr ""
"@FUNCTION=FTEST\n"
"@SYNTAX=FTEST(array1,array2)\n"
"@DESCRIPTION=La función FTEST devuelve la probabilidad de que las varianzas "
"de los dos conjuntos de datos dados no se diferencien significativamente.\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"Supongamos que las celdas A1, A2, …, A5 contienen los números 11.4, 17.3, "
"21.3, 25.9 y 40.1, y las celdas B1, B2, … B5 23.2, 25.8, 29.9, 33.5 y 42.7. "
"Entonces\n"
"FTEST(A1:A5,B1:B5) igual a 0.510815017.\n"
"\n"
"@SEEALSO=FDIST,FINV"

#: ../plugins/fn-stat/functions.c:3631
msgid ""
"@FUNCTION=TTEST\n"
"@SYNTAX=TTEST(array1,array2,tails,type)\n"
"@DESCRIPTION=TTEST function returns the probability of a Student's t-Test. \n"
"@array1 is the first data set and @array2 is the second data set.  If @tails "
"is one, TTEST uses the one-tailed distribution and if @tails is two, TTEST "
"uses the two-tailed distribution.  @type determines the kind of the test:\n"
"\n"
"\t1  Paired test\n"
"\t2  Two-sample equal variance\n"
"\t3  Two-sample unequal variance\n"
"\n"
"* If the data sets contain a different number of data points and the test is "
"paired (@type one), TTEST returns the #N/A error.\n"
"* @tails and @type are truncated to integers.\n"
"* If @tails is not one or two, TTEST returns #NUM! error.\n"
"* If @type is any other than one, two, or three, TTEST returns #NUM! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
"21.3, 25.9, and 40.1, and the cells B1, B2, ... B5 23.2, 25.8, 29.9, 33.5, "
"and 42.7.  Then\n"
"TTEST(A1:A5,B1:B5,1,1) equals 0.003127619.\n"
"TTEST(A1:A5,B1:B5,2,1) equals 0.006255239.\n"
"TTEST(A1:A5,B1:B5,1,2) equals 0.111804322.\n"
"TTEST(A1:A5,B1:B5,1,3) equals 0.113821797.\n"
"\n"
"@SEEALSO=FDIST,FINV"
msgstr ""
"@FUNCTION=TTEST\n"
"@SYNTAX=TTEST(array1,array2,colas,tipo)\n"
"@DESCRIPTION=La función TTEST devuelve la probabilidad de una prueba t de "
"Student. \n"
"@array1 es el primer conjunto de datos y @array2 es el segundo conjunto de "
"datos. Si @colas es uno, TTEST usa la distribución de una cola y si @colas "
"es dos, TTEST usa la distribución de dos colas. @tipo determina la clase de "
"la prueba:\n"
"\n"
"\t1 Test de paridad\n"
"\t2 Varianza de igualdad de dos muestras\n"
"\t3 Varianza de desigualdad de dos muestras\n"
"\n"
"* Si los conjuntos de datos contienen un número diferente de puntos de datos "
"y la prueba es de paridad (@tipo uno), TTEST devuelve el error #N/A.\n"
"* @colas y @tipo se truncan a enteros.\n"
"* Si @colas no es ni uno ni dos, TTEST devuelve el error #NÚM!.\n"
"* Si @tipo es distinto de uno, dos o tres, TTEST devuelve el error #NÚM!.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"Supongamos que las celdas A1, A2, …, A5 contienen los números 11.4, 17.3, "
"21.3, 25.9 y 40.1, y que las celdas B1, B2, … B5 23.2, 25.8, 29.9, 33.5 y "
"42.7. Entonces\n"
"TTEST(A1:A5,B1:B5,1,1) igual a 0.003127619.\n"
"TTEST(A1:A5,B1:B5,2,1) igual a 0.006255239.\n"
"TTEST(A1:A5,B1:B5,1,2) igual a 0.111804322.\n"
"TTEST(A1:A5,B1:B5,1,3) igual a 0.113821797.\n"
"\n"
"@SEEALSO=FDIST,FINV"

#: ../plugins/fn-stat/functions.c:3815
msgid ""
"@FUNCTION=FREQUENCY\n"
"@SYNTAX=FREQUENCY(data_array,bins_array)\n"
"@DESCRIPTION=FREQUENCY function counts how often given values occur within a "
"range of values.  The results are given as an array.\n"
"\n"
"@data_array is a data array for which you want to count the frequencies.  "
"@bin_array is an array containing the intervals into which you want to group "
"the values in data_array.  If the @bin_array is empty, FREQUENCY returns the "
"number of data points in @data_array.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO="
msgstr ""
"@FUNCTION=FREQUENCY\n"
"@SYNTAX=FREQUENCY(array_datos,array_intervalos)\n"
"@DESCRIPTION=La función FREQUENCY cuenta cuantas veces aparecen los valores "
"dados en un rango de valores. Los resultados se devuelven en un array.\n"
"\n"
"@array_datos es un array de los datos de los cuales quiere contar las "
"frecuencias. @array_intervalos es un array que contiene los intervalos en "
"los cuales quiere reagrupar los valores de @array_datos. Si "
"@array_intervalos está vacío, FREQUENCY devuelve la cantidad de puntos de "
"datos en @array_datos. \n"
"\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO="

#: ../plugins/fn-stat/functions.c:3895
msgid ""
"@FUNCTION=LINEST\n"
"@SYNTAX=LINEST(known_y's[,known_x's[,const[,stat]]])\n"
"@DESCRIPTION=LINEST function calculates the ``least squares'' line that best "
"fit to your data in @known_y's.  @known_x's contains the corresponding x's "
"where y=mx+b.\n"
"\n"
"LINEST returns an array having two columns and one row.  The slope (m) of "
"the regression line y=mx+b is given in the first column and the y-intercept "
"(b) in the second.\n"
"\n"
"If @stat is TRUE, extra statistical information will be returned. Extra "
"statistical information is written below the regression line coefficients in "
"the result array.  Extra statistical information consists of four rows of "
"data.  In the first row the standard error values for the coefficients m1, "
"(m2, ...), b are represented.  The second row contains the square of R and "
"the standard error for the y estimate.  The third row contains the F-"
"observed value and the degrees of freedom.  The last row contains the "
"regression sum of squares and the residual sum of squares.\n"
"\n"
"* If @known_x's is omitted, an array {1, 2, 3, ...} is used.\n"
"* If @known_y's and @known_x's have unequal number of data points, LINEST "
"returns #NUM! error.\n"
"* If @const is FALSE, the line will be forced to go through the origin, i."
"e., b will be zero. The default is TRUE.\n"
"* The default of @stat is FALSE.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=LOGEST,TREND"
msgstr ""
"@FUNCTION=LINEST\n"
"@SYNTAX=LINEST(y_conocido[,x_conocido[,const[,estad]]])\n"
"@DESCRIPTION=La función LINEST calcula la línea de «cuadrados mínimos» que "
"mejor se ajuste a sus datos de @y_conocido. @x_conocido contiene las x "
"correspondientes donde y=mx+b.\n"
"\n"
"LINEST devuelve un array con dos columnas y una fila. La pendiente (m) de la "
"línea de regresión y=mx+b se da en la primera columna y la y intercepta a "
"(b) en la segunda.\n"
"\n"
"Si @estad es VERDADERO, se devolverá información estadística extra. Debajo "
"de la los coeficientes de la línea de regresión se escribe información "
"estadística extra en el array resultado. La información estadística extra "
"consiste en cuatro filas de datos. En la primera fila se representan los "
"valores estándar de error para los coeficientes m1, (m2, …), b. La segunda "
"fila contiene el cuadrado de R y el error estándar para la y estimada. La "
"tercera fila contiene el valor observado F y los grados de libertad. La "
"última fila contiene la suma de regresión de los cuadrados y la suma "
"residual de los cuadrados. \n"
"\n"
"* Si se omite @x_conocido, se usa un array {1, 2, 3, …}.\n"
"* Si @y_conocido y @x_conocido tienen distinto número de puntos de datos, "
"LINEST devuelve un error #NÚM!.\n"
"* Si @const es FALSO, se forzará que la línea pase por el origen, por "
"ejemplo, b será cero. De forma predeterminada, es VERDADERO.\n"
"* De forma predeterminada, @estad es FALSO.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=LOGEST,TREND"

#: ../plugins/fn-stat/functions.c:4158
msgid ""
"@FUNCTION=LOGREG\n"
"@SYNTAX=LOGREG(known_y's[,known_x's[,const[,stat]]])\n"
"@DESCRIPTION=LOGREG function transforms your x's to z=ln(x) and applies the "
"``least squares'' method to fit the linear equation\n"
"y = m * z + b \n"
"to your y's and z's --- equivalent to fitting the equation\n"
"y = m * ln(x) + b \n"
"to y's and x's. \n"
"\n"
"If @known_x's is omitted, an array {1, 2, 3, ...} is used. LOGREG returns an "
"array having two columns and one row. m is given in the first column and b "
"in the second. \n"
"\n"
"If @known_y's and @known_x's have unequal number of data points, LOGREG "
"returns #NUM! error.\n"
"\n"
"If @const is FALSE, the curve will be forced to go through [1; 0], i.e., b "
"will be zero. The default is TRUE.\n"
"\n"
"If @stat is TRUE, extra statistical information will be returned which "
"applies to the state AFTER transformation to z. Extra statistical "
"information is written below m and b in the result array.  Extra statistical "
"information consists of four rows of data.  In the first row the standard "
"error values for the coefficients m, b are represented.  The second row "
"contains the square of R and the standard error for the y estimate. The "
"third row contains the F-observed value and the degrees of freedom.  The "
"last row contains the regression sum of squares and the residual sum of "
"squares.The default of @stat is FALSE.\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=LOGFIT,LINEST,LOGEST"
msgstr ""
"@FUNCTION=LOGREG\n"
"@SYNTAX=LOGREG(y_conocido[,x_conocido[,const[,estad]]])\n"
"@DESCRIPTION=La función LOGREG transforma las x's a z=ln(x) y aplica el "
"método de los «cuadrados mínimos» para ajustar a la ecuación lineal\n"
"\ty = m * z + b\n"
"a sus y's y z's ---equivalente a ajustar la ecuación\n"
"\ty= m* ln(x) + b\n"
"a las y's y a las x's\n"
"\n"
"Si se omite @x_conocido, se usa un array {1, 2, 3, …}. LOGREG devuelve un "
"array conteniendo dos columnas y una fila. m se da en la primera columna y b "
"en la segunda.\n"
"\n"
"Si @y_conocido y @x_conocido tienen distintos números de puntos de datos, "
"LOGREG devuelve el error #NÚM!.\n"
"\n"
"Si @const es FALSO, la curva se forzará para que pase por [0,1], por "
"ejemplo, b sería cero. De forma predeterminada, es VERDADERO.\n"
"\n"
"Si @estad es VERDADERO, se devolverá información estadística extra. La "
"información estadística extra se aplica al estado ANTES de la transformación "
"a z.. La información estadística extra consiste en cuatro filas de datos. En "
"la primera fila, los valores de error estándar para los coeficientes m, b, "
"son representados La segunda fila contiene el cuadrado de R y el error "
"estándar para el y estimado. La tercera fila contiene el valor observado de "
"F y los grados de libertad. La última fila contiene la suma de regresión de "
"los cuadrados y la suma residual de los cuadrados. \n"
"El valor predeterminado de @estad es FALSO.\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=LOGFIT,LINEST,LOGEST"

#: ../plugins/fn-stat/functions.c:4428
msgid ""
"@FUNCTION=LOGFIT\n"
"@SYNTAX=LOGFIT(known_y's,known_x's)\n"
"@DESCRIPTION=LOGFIT function applies the ``least squares'' method to fit the "
"logarithmic equation\n"
"y = a + b * ln(sign * (x - c)) ,   sign = +1 or -1 \n"
"to your data. The graph of the equation is a logarithmic curve moved "
"horizontally by c and possibly mirrored across the y-axis (if sign = -1).\n"
"\n"
"LOGFIT returns an array having five columns and one row. `Sign' is given in "
"the first column, `a', `b', and `c' are given in columns 2 to 4. Column 5 "
"holds the sum of squared residuals.\n"
"\n"
"An error is returned when there are less than 3 different x's or y's, or "
"when the shape of the point cloud is too different from a ``logarithmic'' "
"one.\n"
"\n"
"You can use the above formula \n"
"= a + b * ln(sign * (x - c)) \n"
"or rearrange it to \n"
"= (exp((y - a) / b)) / sign + c \n"
"to compute unknown y's or x's, respectively. \n"
"\n"
"Technically, this is non-linear fitting by trial-and-error. The accuracy of "
"`c' is: width of x-range -> rounded to the next smaller (10^integer), times "
"0.000001. There might be cases in which the returned fit is not the best "
"possible.\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=LOGREG,LINEST,LOGEST"
msgstr ""
"@FUNCTION=LOGFIT\n"
"@SYNTAX=LOGFIT(known_y's,known_x's)\n"
"@DESCRIPTION=La función LOGFIT aplica el método de mínimos cuadrados para "
"ajustar la ecuación logarítmica \n"
"\t\n"
"\ty = a + b * ln(sign * (x - c)) ,  sign = +1 o -1 \n"
"\n"
"a sus datos. La gráfica de la ecuación es una curva logarítmica desplazada "
"horizontalmente por c y posiblemente reflejada a través del eje y (si sign = "
"-1).\n"
"\n"
"LOGFIT devuelve un array conteniendo cinco columnas y una fila. `Signo' se "
"da en la primera columna, `a', `b', y `c' se dan el las columnas 2 a 4. La "
"columna 5 contiene la suma de los residuos al cuadrado.\n"
"\n"
"Se devuelve un error cuando hay menos de 3 x's o y's diferentes, o cuando la "
"forma de la nube de puntos es demasiado diferente de una forma "
"«logarítmica».\n"
"\n"
"Puede usar la fórmula\n"
"\t= a + b * ln(sign * (x - c)) \n"
"o reordenarla a\n"
"\t= (exp((y - a) / b)) / sign + c \n"
"para calcular y's o x's desconocidas respectivamente.\n"
"\n"
"Técnicamente, esto es un ajuste no linear mediante prueba y error.. La "
"precisión de «c» es: el ancho de x-rango -> redondeado al siguiente más "
"pequeño (10^enteros), 0.000001 veces. Quizá haya casos en los que el ajuste "
"devuelto no sea el mejor posible.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=LOGREG,LINEST,LOGEST"

#: ../plugins/fn-stat/functions.c:4531
msgid ""
"@FUNCTION=TREND\n"
"@SYNTAX=TREND(known_y's[,known_x's[,new_x's[,const]]])\n"
"@DESCRIPTION=TREND function estimates future values of a given data set "
"using the ``least squares'' line that best fit to your data. @known_y's is "
"the y-values where y=mx+b and @known_x's contains the corresponding x-"
"values.  @new_x's contains the x-values for which you want to estimate the y-"
"values. If @const is FALSE, the line will be forced to go through the "
"origin, i.e., b will be zero.\n"
"\n"
"* If @known_x's is omitted, an array {1, 2, 3, ...} is used.\n"
"* If @new_x's is omitted, it is assumed to be the same as @known_x's.\n"
"* If @const is omitted, it is assumed to be TRUE.\n"
"* If @known_y's and @known_x's have unequal number of data points, TREND "
"returns #NUM! error.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
"21.3, 25.9, and 40.1, and the cells B1, B2, ... B5 23.2, 25.8, 29.9, 33.5, "
"and 42.7.  Then\n"
"TREND(A1:A5,B1:B5) equals {12.1, 15.7, 21.6, 26.7, 39.7}.\n"
"\n"
"@SEEALSO=LINEST"
msgstr ""
"@FUNCTION=TREND\n"
"@SYNTAX=TREND(y_conocido[,x_conocido[,x_nuevo[,const]]])\n"
"@DESCRIPTION=La función TREND estima los valores futuros de un conjunto de "
"datos dado usando la línea de «cuadrados mínimos» que mejor se ajuste a sus "
"datos. @y_conocido son los valores de y donde y=mx+b, y @x_conocido contiene "
"los valores correspondientes de x. @x_nuevo contiene los valores de x para "
"los que quiere estimar los valores de y.\n"
"\n"
"* Si se omite @x_conocido, se usa un array {1, 2, 3, …}.\n"
"* Si se omite @x_nuevo, se asume que es el mismo que @x_conocido.\n"
"* Si @y_conocido y @x_conocido tienen distinto número de puntos de datos, "
"TREND devuelve el error #NÚM!.\n"
"\n"
"@EXAMPLES=\n"
"Supongamos que las celdas A1, A2, …, A5 contienen los números 11.4, 17.3, "
"21.3, 25.9 y 40.1, y las celdas B1, B2, … B5 23.2, 25.8, 29.9, 33.5 y 42.7. "
"Entonces\n"
"TREND(A1:A5,B1:B5) igual a {12.1, 15.7, 21.6, 26.7, 39.7}.\n"
"\n"
"@SEEALSO=LINEST"

#: ../plugins/fn-stat/functions.c:4654
msgid ""
"@FUNCTION=LOGEST\n"
"@SYNTAX=LOGEST(known_y's[,known_x's,const,stat])\n"
"@DESCRIPTION=LOGEST function applies the ``least squares'' method to fit an "
"exponential curve of the form\n"
"\n"
"\ty = b * m{1}^x{1} * m{2}^x{2}... to your data.\n"
"\n"
"If @stat is TRUE, extra statistical information will be returned. Extra "
"statistical information is written below the regression line coefficients in "
"the result array.  Extra statistical information consists of four rows of "
"data.  In the first row the standard error values for the coefficients m1, "
"(m2, ...), b are represented.  The second row contains the square of R and "
"the standard error for the y estimate.  The third row contains the F-"
"observed value and the degrees of freedom.  The last row contains the "
"regression sum of squares and the residual sum of squares.\n"
"\n"
"* If @known_x's is omitted, an array {1, 2, 3, ...} is used. LOGEST returns "
"an array { m{n},m{n-1}, ...,m{1},b }.\n"
"* If @known_y's and @known_x's have unequal number of data points, LOGEST "
"returns #NUM! error.\n"
"* If @const is FALSE, the line will be forced to go through (0,1),i.e., b "
"will be one.  The default is TRUE.\n"
"* The default of @stat is FALSE.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=GROWTH,TREND"
msgstr ""
"@FUNCTION=LOGEST\n"
"@SYNTAX=LOGEST(y_conocido[,x_conocido,const,estad])\n"
"@DESCRIPTION=La función LOGEST aplica el método de «mínimos cuadrados» para "
"ajustar una curva exponencial de la forma:\n"
"\n"
"\ty = b * m{1}^x{1} * m{2}^x{2}… a sus datos.\n"
"\n"
"Si @estad es VERDADERO, se devuelve información estadística adicional. La "
"información estadística adicional se escribe bajo los coeficientes "
"deregresión lineal en el array de resultados. La información estadística "
"adicional consiste en cuatro líneas de datos. En la primera línea se "
"representan los valores de error estándar para los coeficientes m1, (m2, …), "
"b. La segunda fila contiene el cuadrado de R y el error estándar para la "
"estimación de y. La tercera línea el valor observado por F y los grados de "
"libertad. La última fila contiene suma de los cuadrados de la regresión y la "
"suma de los cuadrados residual.\n"
"\n"
"* Si @y_conocida se omite, se usa un array {1, 2, 3, …}. LOGEST devuelve un "
"array { m{n},m{n-1}, …,m{1},b }.\n"
"* Si alguna @y_conocida y @x_conocida tienen distinto número de puntos de "
"datos, LOGEST devuelve el error #NÚM!\n"
"* Si @const es FALSO, la línea será forzada a ir a través de (0,1), o sea, b "
"será uno.. Por omisión es VERDADERO.\n"
"* El valor predeterminado de @estad es FALSO.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=GROWTH,TREND"

#: ../plugins/fn-stat/functions.c:4899
msgid ""
"@FUNCTION=GROWTH\n"
"@SYNTAX=GROWTH(known_y's[,known_x's,new_x's,const])\n"
"@DESCRIPTION=GROWTH function applies the ``least squares'' method to fit an "
"exponential curve to your data and predicts the exponential growth by using "
"this curve. \n"
"GROWTH returns an array having one column and a row for each data point in "
"@new_x.\n"
"\n"
"* If @known_x's is omitted, an array {1, 2, 3, ...} is used.\n"
"* If @new_x's is omitted, it is assumed to be the same as @known_x's.\n"
"* If @known_y's and @known_x's have unequal number of data points, GROWTH "
"returns #NUM! error.\n"
"* If @const is FALSE, the line will be forced to go through the origin, i."
"e., b will be zero. The default is TRUE.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=LOGEST,GROWTH,TREND"
msgstr ""
"@FUNCTION=GROWTH\n"
"@SYNTAX=GROWTH(y_conocido[,x_conocido,x_nuevo,const])\n"
"@DESCRIPTION=La función GROWTH aplica el método de los «cuadrados mínimos» "
"para que se ajuste una curva exponencial a sus datos y prediga el "
"crecimiento exponencial usando esta curva. \n"
"GROWTH devuelve un array que tiene una columna y una fila por cada punto de "
"datos de @nuevo_x.\n"
"\n"
"* Si se omite @x_conocido, se usa un array {1, 2, 3, …}.\n"
"* Si se omite @x_nuevo, se asume que es el mismo que @x_conocido.\n"
"* Si @y_conocido y @x_conocido tienen distinto número de puntos de datos, "
"GROWTH devuelve el error #NÚM!.\n"
"* Si @const es FALSO, se forzará a que la línea pase por el origen, por "
"ejemplo, b sería cero. Por omisión es VERDADERO.\n"
"\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO=LOGEST,GROWTH,TREND"

#: ../plugins/fn-stat/functions.c:5021
msgid ""
"@FUNCTION=FORECAST\n"
"@SYNTAX=FORECAST(x,known_y's,known_x's)\n"
"@DESCRIPTION=FORECAST function estimates a future value according to "
"existing values using simple linear regression.  The estimated future value "
"is a y-value for a given x-value (@x).\n"
"\n"
"* If @known_x or @known_y contains no data entries or different number of "
"data entries, FORECAST returns #N/A error.\n"
"* If the variance of the @known_x is zero, FORECAST returns #DIV/0 error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
"21.3, 25.9, and 40.1, and the cells B1, B2, ... B5 23.2, 25.8, 29.9, 33.5, "
"and 42.7.  Then\n"
"FORECAST(7,A1:A5,B1:B5) equals -10.859397661.\n"
"\n"
"@SEEALSO=INTERCEPT,TREND"
msgstr ""
"@FUNCTION=FORECAST\n"
"@SYNTAX=FORECAST(x,y_conocidos,x_conocidos)\n"
"@DESCRIPTION=La función FORECAST estima un valor futuro, según los valores "
"existentes usando una regresión linear simple. El valor futuro estimado es "
"el valor de y para un valor de x dado (@x). \n"
"\n"
"* Si @x_conocidos o @y_conocidos no contienen datos o contienen cantidades "
"de datos diferentes, FORECAST devuelve el error #N/D! .\n"
"* Si la varianza de @x_conocidos es cero, FORECAST devuelve el error "
"#DIV/0 .\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"Suponiendo que las celdas A1, A2, …, A5 contengan los números 11.4, 17.3, "
"21.3, 25.9, y 40.1, y las celdas B1, B2, … B5 los números 23.2, 25.8, 29.9, "
"33.5, y 42.7. Entonces\n"
"FORECAST(7,A1:A5,B1:B5) es igual a -10.859397661.\n"
"\n"
"@SEEALSO=INTERCEPT,TREND"

#: ../plugins/fn-stat/functions.c:5095
msgid ""
"@FUNCTION=INTERCEPT\n"
"@SYNTAX=INTERCEPT(known_y's,known_x's)\n"
"@DESCRIPTION=INTERCEPT function calculates the point where the linear "
"regression line intersects the y-axis.\n"
"\n"
"* If @known_x or @known_y contains no data entries or different number of "
"data entries, INTERCEPT returns #N/A error.\n"
"* If the variance of the @known_x is zero, INTERCEPT returns #DIV/0 error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
"21.3, 25.9, and 40.1, and the cells B1, B2, ... B5 23.2, 25.8, 29.9, 33.5, "
"and 42.7.  Then\n"
"INTERCEPT(A1:A5,B1:B5) equals -20.785117212.\n"
"\n"
"@SEEALSO=FORECAST,TREND"
msgstr ""
"@FUNCTION=INTERCEPT\n"
"@SYNTAX=INTERCEPT(y_conocidos,x_conocidos)\n"
"@DESCRIPTION=La función INTERCEPT calcula el punto en el cual la regresión "
"lineal corta el eje y.\n"
"\n"
"* Si @x_conocidos o @y_conocidos no contienen datos o contienen diferente "
"número de entrada de datos, INTERCEPT devuelve el error #N/D!.\n"
"* Si la varianza de @x_conocidos es cero, INTERCEP devuelve el error "
"#DIV/0.\n"
"* Esta función es compatible con Excel \n"
"\n"
"@EXAMPLES=\n"
"Suponiendo que las celdas A1, A2, …, A5 contengan los números 11.4, 17.3, "
"21.3, 25.9, y 40.1, y las celdas B1, B2, … B5 23.2, 25.8, 29.9, 33.5, y "
"42.7. Entonces\n"
"INTERCEPT(A1:A5,B1:B5) devuelve -20.785117212.\n"
"\n"
"@SEEALSO=FORECAST,TREND"

#: ../plugins/fn-stat/functions.c:5150
msgid ""
"@FUNCTION=SLOPE\n"
"@SYNTAX=SLOPE(known_y's,known_x's)\n"
"@DESCRIPTION=SLOPE returns the slope of the linear regression line.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1, A2, ..., A5 contain numbers 11.4, 17.3, "
"21.3, 25.9, and 40.1, and the cells B1, B2, ... B5 23.2, 25.8, 29.9, 33.5, "
"and 42.7.  Then\n"
"SLOPE(A1:A5,B1:B5) equals 1.417959936.\n"
"\n"
"@SEEALSO=STDEV,STDEVPA"
msgstr ""
"@FUNCTION=SLOPE\n"
"@SYNTAX=SLOPE(y_conocidos,x_conocidos)\n"
"@DESCRIPTION=Devuelve la pendiente de la línea de regresión linear.\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"Suponiendo que las celdas A1, A2, …, A5 contengan los números 11,4; 17,3; "
"21,3; 25,9; y 40,1; y las celdas B1, B2, …, B5 contengan 23,2; 25,8; 29,9; "
"33,5; y 42,7. Entonces\n"
"SLOPE(A1:A5,B1:B5) es igual a 1,417959936.\n"
"\n"
"@SEEALSO=STDEV,STDEVPA"

#: ../plugins/fn-stat/functions.c:5199
msgid ""
"@FUNCTION=SUBTOTAL\n"
"@SYNTAX=SUBTOTAL(function_nbr,ref1,ref2,...)\n"
"@DESCRIPTION=SUBTOTAL function returns a subtotal of given list of "
"arguments. @function_nbr is the number that specifies which function to use "
"in calculating the subtotal.\n"
"\n"
"The following functions are available:\n"
"\n"
"\t1   AVERAGE\n"
"\t2   COUNT\n"
"\t3   COUNTA\n"
"\t4   MAX\n"
"\t5   MIN\n"
"\t6   PRODUCT\n"
"\t7   STDEV\n"
"\t8   STDEVP\n"
"\t9   SUM\n"
"\t10   VAR\n"
"\t11   VARP\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"Let us assume that the cells A1, A2, ..., A5 contain numbers 23, 27, 28, 33, "
"and 39.  Then\n"
"SUBTOTAL(1,A1:A5) equals 30.\n"
"SUBTOTAL(6,A1:A5) equals 22378356.\n"
"SUBTOTAL(7,A1:A5) equals 6.164414003.\n"
"SUBTOTAL(9,A1:A5) equals 150.\n"
"SUBTOTAL(11,A1:A5) equals 30.4.\n"
"\n"
"@SEEALSO=COUNT,SUM"
msgstr ""
"@FUNCTION=SUBTOTAL\n"
"@SYNTAX=SUBTOTAL(función_num,ref1,ref2,…)\n"
"@DESCRIPTION=La función SUBTOTAL devuelve el subtotal de la lista de "
"argumentos. @función_num es el número que especifica la función a usar para "
"calcular el subtotal.\n"
"\n"
"Las siguientes funciones están disponibles:\n"
"\n"
"\t1  AVERAGE\n"
"\t2  COUNT\n"
"\t3  COUNTA\n"
"\t4  MAX\n"
"\t5  MIN\n"
"\t6  PRODUCT\n"
"\t7  STDEV\n"
"\t8  STDEVP\n"
"\t9  SUM\n"
"\t10 VAR\n"
"\t11 VARP\n"
"\n"
"* Esta función es compatible con Excel. \n"
"\n"
"@EXAMPLES=\n"
"Suponiendo que las celdas A1, A2, …, A5 contengan los números 23, 27, 28, 33 "
"y 39. Entonces\n"
"SUBTOTAL(1,A1:A5) es igual a 30.\n"
"SUBTOTAL(6,A1:A5) es igual a 22378356.\n"
"SUBTOTAL(7,A1:A5) es igual a 6.164414003.\n"
"SUBTOTAL(9,A1:A5) es igual a 150.\n"
"SUBTOTAL(11,A1:A5) es igual a 30.4.\n"
"\n"
"@SEEALSO=COUNT,SUM"

#: ../plugins/fn-stat/functions.c:5305
msgid ""
"@FUNCTION=CRONBACH\n"
"@SYNTAX=CRONBACH(ref1,ref2,...)\n"
"@DESCRIPTION=CRONBACH returns Cronbach's alpha for the given cases.\n"
"@ref1 is a data set, @ref2 the second data set, etc..\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO="
msgstr ""
"@FUNCTION=CRONBACH\n"
"@SYNTAX=CRONBACH(ref1,ref2,…)\n"
"@DESCRIPTION=CRONBACH devuelve el alfa de Cronbach para los casos dados.\n"
"@ref1 es un conjunto de datos, @ref2 el segundo conjunto de datos, etc..\n"
"@EXAMPLES=\n"
"\n"
"@SEEALSO="

#: ../plugins/fn-stat/functions.c:5427
msgid ""
"@FUNCTION=GEOMDIST\n"
"@SYNTAX=GEOMDIST(k,p,cum)\n"
"@DESCRIPTION=GEOMDIST returns the probability p(k) of obtaining @k from a "
"geometric distribution with probability parameter @p.\n"
"\n"
"* If @k < 0 GEOMDIST returns #NUM! error.\n"
"* If @p < 0 or @p > 1 GEOMDIST returns #NUM! error.\n"
"* If @cum != TRUE and @cum != FALSE GEOMDIST returns #NUM! error.\n"
"\n"
"@EXAMPLES=\n"
"GEOMDIST(2,10.4,TRUE).\n"
"\n"
"@SEEALSO=RANDGEOM"
msgstr ""
"@FUNCTION=GEOMDIST\n"
"@SYNTAX=GEOMDIST(k,p,cum)\n"
"@DESCRIPTION=GEOMDIST devuelve la probabilidad p(k) de obtener @k de una "
"distribución geométrica con parámetro de probabilidad @p.\n"
"\n"
"* Si @k < 0 GEOMDIST devuelve un error #NÚM!\n"
"* Si @p < 0 o @p > 1 GEOMDIST devuelve un error #NÚM!\n"
"* Si @cum != VERDADERO y @cum != FALSO GEOMDIST devuelve #NÚM!\n"
"\n"
"@EXAMPLES=\n"
"GEOMDIST(2,10.4,VERDADERO).\n"
"\n"
"@SEEALSO=RANDGEOM"

#: ../plugins/fn-stat/functions.c:5466
msgid ""
"@FUNCTION=LOGISTIC\n"
"@SYNTAX=LOGISTIC(x,a)\n"
"@DESCRIPTION=LOGISTIC returns the probability density p(x) at @x for a "
"logistic distribution with scale parameter @a.\n"
"\n"
"@EXAMPLES=\n"
"LOGISTIC(0.4,1).\n"
"\n"
"@SEEALSO=RANDLOGISTIC"
msgstr ""
"@FUNCTION=LOGISTIC\n"
"@SYNTAX=LOGISTIC(x,a)\n"
"@DESCRIPTION=LOGISTIC devuelve la densidad de probabilidad p(x) en @x para "
"una distribución logística con parámetro de escala @\n"
"\n"
"\n"
"@EXAMPLES=\n"
"LOGISTIC(0.4,1).\n"
"\n"
"@SEEALSO=RANDLOGISTIC"

#: ../plugins/fn-stat/functions.c:5505
msgid ""
"@FUNCTION=PARETO\n"
"@SYNTAX=PARETO(x,a,b)\n"
"@DESCRIPTION=PARETO returns the probability density p(x) at @x for a Pareto "
"distribution with exponent @a and scale @b.\n"
"\n"
"@EXAMPLES=\n"
"PARETO(0.6,1,2).\n"
"\n"
"@SEEALSO=RANDPARETO"
msgstr ""
"@FUNCTION=PARETO\n"
"@SYNTAX=PARETO(x,a,b)\n"
"@DESCRIPTION=PARETO devuelve la densidad de probabilidad p(x) en @x para una "
"distribución Pareto con exponente @a y escala @b.\n"
"\n"
"@EXAMPLES=\n"
"PARETO(0.6,1,2).\n"
"\n"
"@SEEALSO=RANDPARETO"

#: ../plugins/fn-stat/functions.c:5546
msgid ""
"@FUNCTION=RAYLEIGH\n"
"@SYNTAX=RAYLEIGH(x,sigma)\n"
"@DESCRIPTION=RAYLEIGH returns the probability density p(x) at @x for a "
"Rayleigh distribution with scale parameter @sigma.\n"
"\n"
"@EXAMPLES=\n"
"RAYLEIGH(0.4,1).\n"
"\n"
"@SEEALSO=RANDRAYLEIGH"
msgstr ""
"@FUNCTION=RAYLEIGH\n"
"@SYNTAX=RAYLEIGH(x,sigma)\n"
"@DESCRIPTION=RAYLEIGH devuelve la densidad de probabilidad p(x) en @x para "
"una distribución de Rayleigh con parámetro de escala @sigma.\n"
"\n"
"@EXAMPLES=\n"
"RAYLEIGH(0.4,1).\n"
"\n"
"@SEEALSO=RANDRAYLEIGH"

#: ../plugins/fn-stat/functions.c:5589
msgid ""
"@FUNCTION=RAYLEIGHTAIL\n"
"@SYNTAX=RAYLEIGHTAIL(x,a,sigma)\n"
"@DESCRIPTION=RAYLEIGHTAIL returns the probability density p(x) at @x for a "
"Rayleigh tail distribution with scale parameter @sigma and lower limit @a.\n"
"\n"
"@EXAMPLES=\n"
"RAYLEIGHTAIL(0.6,0.3,1).\n"
"\n"
"@SEEALSO=RANDRAYLEIGHTAIL"
msgstr ""
"@FUNCTION=RAYLEIGHTAIL\n"
"@SYNTAX=RAYLEIGHTAIL(x,a,sigma)\n"
"@DESCRIPTION=RAYLEIGHTAIL devuelve la densidad de probabilidad p(x) en @x "
"para una distribución en cola Rayleigh con parámetro de escala @sigma y "
"límite inferior @a.\n"
"\n"
"@EXAMPLES=\n"
"RAYLEIGHTAIL(0.6,0.3,1).\n"
"\n"
"@SEEALSO=RANDRAYLEIGHTAIL"

#: ../plugins/fn-stat/functions.c:5635
msgid ""
"@FUNCTION=EXPPOWDIST\n"
"@SYNTAX=EXPPOWDIST(x,a,b)\n"
"@DESCRIPTION=EXPPOWDIST returns the probability density p(x) at @x for "
"Exponential Power distribution with scale parameter @a and exponent @b.\n"
"This distribution has been recommended for lifetime analysis when a U-shaped "
"hazard function is desired. This corresponds to rapid failure once the "
"product starts to wear out after a period of steady or even improving "
"reliability.\n"
"@EXAMPLES=\n"
"EXPPOWDIST(0.4,1,2).\n"
"\n"
"@SEEALSO=RANDEXPPOW"
msgstr ""
"@FUNCTION=EXPPOWDIST\n"
"@SYNTAX=EXPPOWDIST(x,a,b)\n"
"@DESCRIPTION=EXPPOWDIST devuelve la densidad de probabilidad p(x) en @x para "
"la distribución exponencial con el parámetro de escala @a y exponente @b. \n"
"\n"
"@EXAMPLES=\n"
"EXPPOWDIST(0.4,1,2).\n"
"\n"
"\n"
"@SEEALSO=RANDEXPPOW"

#: ../plugins/fn-stat/functions.c:5674
msgid ""
"@FUNCTION=LAPLACE\n"
"@SYNTAX=LAPLACE(x,a)\n"
"@DESCRIPTION=LAPLACE returns the probability density p(x) at @x for Laplace "
"distribution with mean @a. \n"
"@EXAMPLES=\n"
"LAPLACE(0.4,1).\n"
"\n"
"@SEEALSO=RANDLAPLACE"
msgstr ""
"@FUNCTION=LAPLACE\n"
"@SYNTAX=LAPLACE(x,a)\n"
"@DESCRIPTION=LAPLACE devuelve la densidad de probabilidad p(x) en @x para la "
"distribución de Laplace con media @a. \n"
"@EXAMPLES=\n"
"LAPLACE(0.4,1).\n"
"\n"
"@SEEALSO=RANDLAPLACE"

#: ../plugins/fn-string/functions.c:61
msgid ""
"@FUNCTION=CHAR\n"
"@SYNTAX=CHAR(x)\n"
"@DESCRIPTION=CHAR returns the ASCII character represented by the number @x.\n"
"\n"
"@EXAMPLES=\n"
"CHAR(65) equals A.\n"
"\n"
"@SEEALSO=CODE"
msgstr ""
"@FUNCTION=CHAR\n"
"@SYNTAX=CHAR(x)\n"
"@DESCRIPTION=Devuelve el carácter ASCII representado por el número @x.\n"
"\n"
"@EXAMPLES=\n"
"CHAR(65) es igual a A.\n"
"\n"
"@SEEALSO=CODE"

#: ../plugins/fn-string/functions.c:107
msgid ""
"@FUNCTION=UNICHAR\n"
"@SYNTAX=UNICHAR(x)\n"
"@DESCRIPTION=UNICHAR returns the Unicode character represented by the number "
"@x.\n"
"\n"
"@EXAMPLES=\n"
"UNICHAR(65) equals A.\n"
"UNICHAR(960) equals a small Greek pi.\n"
"\n"
"@SEEALSO=CHAR,UNICODE,CODE"
msgstr ""
"@FUNCTION=UNICHAR\n"
"@SYNTAX=UNICHAR(x)\n"
"@DESCRIPTION=Devuelve el carácter Unicode representado por el número @x.\n"
"\n"
"@EXAMPLES=\n"
"UNICHAR(65) devuelve A.\n"
"CHAR(960) devuelve un la letra griega pi pequeña\n"
"\n"
"@SEEALSO=CHAR,UNICODE,CODE"

#: ../plugins/fn-string/functions.c:142
msgid ""
"@FUNCTION=CODE\n"
"@SYNTAX=CODE(char)\n"
"@DESCRIPTION=CODE returns the ASCII number for the character @char.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"CODE(\"A\") equals 65.\n"
"\n"
"@SEEALSO=CHAR"
msgstr ""
"@FUNCTION=CODE\n"
"@SYNTAX=CODE(carácter)\n"
"@DESCRIPTION=Devuelve el valor ASCII del carácter @carácter.\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"CODE(\"A\") es igual a 65.\n"
"\n"
"@SEEALSO=CHAR"

#: ../plugins/fn-string/functions.c:190
msgid ""
"@FUNCTION=UNICODE\n"
"@SYNTAX=UNICODE(char)\n"
"@DESCRIPTION=UNICODE returns the Unicode number for the character @char.\n"
"\n"
"\n"
"@EXAMPLES=\n"
"UNICODE(\"A\") equals 65.\n"
"\n"
"@SEEALSO=UNICHAR,CODE,CHAR"
msgstr ""
"@FUNCTION=UNICODE\n"
"@SYNTAX=UNICODE(carácter)\n"
"@DESCRIPTION=Devuelve el valor Unicode del carácter @carácter.\n"
"\n"
"\n"
"@EXAMPLES=\n"
"UNICODE(\"A\") es igual a 65.\n"
"\n"
"@SEEALSO=UNICHAR,CODE,CHAR"

#: ../plugins/fn-string/functions.c:219
msgid ""
"@FUNCTION=EXACT\n"
"@SYNTAX=EXACT(string1, string2)\n"
"@DESCRIPTION=EXACT returns true if @string1 is exactly equal to @string2 "
"(this routine is case sensitive).\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"EXACT(\"key\",\"key\") equals TRUE.\n"
"EXACT(\"key\",\"Key\") equals FALSE.\n"
"\n"
"@SEEALSO=LEN, SEARCH, DELTA"
msgstr ""
"@FUNCTION=EXACT\n"
"@SYNTAX=EXACT(cadena1, cadena2)\n"
"@DESCRIPTION=Devuelve VERDADERO si la @cadena1 es exactamente idéntica a la "
"@cadena2 (esta rutina distingue mayúsculas y minúsculas).\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"EXACT(\"key\",\"key\") es igual a VERDADERO.\n"
"EXACT(\"key\",\"Key\") es igual a FALSO.\n"
"\n"
"@SEEALSO=LEN, SEARCH, DELTA"

#: ../plugins/fn-string/functions.c:247
msgid ""
"@FUNCTION=LEN\n"
"@SYNTAX=LEN(string)\n"
"@DESCRIPTION=LEN returns the length in characters of the string @string.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"LEN(\"Helsinki\") equals 8.\n"
"\n"
"@SEEALSO=CHAR, CODE, LENB"
msgstr ""
"@FUNCTION=LEN\n"
"@SYNTAX=LEN(cadena)\n"
"@DESCRIPTION=LEN Devuelve la longitud en caracteres de la cadena @cadena.\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"len(\"Helsinki\") es igual a 8.\n"
"\n"
"@SEEALSO=CHAR, CODE, LENB"

#: ../plugins/fn-string/functions.c:271
msgid ""
"@FUNCTION=LENB\n"
"@SYNTAX=LENB(string)\n"
"@DESCRIPTION=LENB returns the length in bytes of the string @string.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"LENB(\"Helsinki\") equals 8.\n"
"\n"
"@SEEALSO=CHAR, CODE, LEN"
msgstr ""
"@FUNCTION=LENB\n"
"@SYNTAX=LENB(cadena)\n"
"@DESCRIPTION=LENB Devuelve la longitud en bytes de la cadena @cadena.\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"len(\"Helsinki\") es igual a 8.\n"
"\n"
"@SEEALSO=CHAR, CODE, LEN"

#: ../plugins/fn-string/functions.c:296
msgid ""
"@FUNCTION=LEFT\n"
"@SYNTAX=LEFT(text[,num_chars])\n"
"@DESCRIPTION=LEFT returns the leftmost @num_chars characters or the left "
"character if @num_chars is not specified.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"LEFT(\"Directory\",3) equals \"Dir\".\n"
"\n"
"@SEEALSO=MID, RIGHT"
msgstr ""
"@FUNCTION=LEFT\n"
"@SYNTAX=LEFT(texto[,número])\n"
"@DESCRIPTION=Devuelve los @número caracteres a la izquierda del texto o el "
"primer carácter a la izquierda si @número no se especifica.\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"LEFT(\"Directorio\",3) es igual a \"Dir\".\n"
"\n"
"@SEEALSO=MID, RIGHT"

#: ../plugins/fn-string/functions.c:333
msgid ""
"@FUNCTION=LOWER\n"
"@SYNTAX=LOWER(text)\n"
"@DESCRIPTION=LOWER returns a lower-case version of the string in @text.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"LOWER(\"J. F. Kennedy\") equals \"j. f. kennedy\".\n"
"\n"
"@SEEALSO=UPPER"
msgstr ""
"@FUNCTION=LOWER\n"
"@SYNTAX=LOWER(texto)\n"
"@DESCRIPTION=Devuelve una versión en minúsculas de la cadena @texto.\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"LOWER(\"Ernesto Guevara\") es igual a \"ernesto guevara\".\n"
"\n"
"@SEEALSO=UPPER"

#: ../plugins/fn-string/functions.c:358
msgid ""
"@FUNCTION=MID\n"
"@SYNTAX=MID(string, position, length)\n"
"@DESCRIPTION=MID returns a substring from @string starting at @position for "
"@length characters.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"MID(\"testing\",2,3) equals \"est\".\n"
"\n"
"@SEEALSO=LEFT, RIGHT"
msgstr ""
"@FUNCTION=MID\n"
"@SYNTAX=MID(cadena, posición, long)\n"
"@DESCRIPTION=Devuelve una sub-cadena de texto de la @cadena, empezando por "
"@posición y contando @long caracteres.\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"MID(\"probando\",2,3) es igual a \"rob\".\n"
"\n"
"@SEEALSO=LEFT, RIGHT"

#: ../plugins/fn-string/functions.c:403
msgid ""
"@FUNCTION=RIGHT\n"
"@SYNTAX=RIGHT(text[,num_chars])\n"
"@DESCRIPTION=RIGHT returns the rightmost @num_chars characters or the right "
"character if @num_chars is not specified.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"RIGHT(\"end\") equals \"d\".\n"
"RIGHT(\"end\",2) equals \"nd\".\n"
"\n"
"@SEEALSO=MID, LEFT"
msgstr ""
"@FUNCTION=RIGHT\n"
"@SYNTAX=RIGHT(texto[,número])\n"
"@DESCRIPTION=Devuelve los @número caracteres a la derecha del texto o el "
"primer carácter a la derecha si @número no se especifica.\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"RIGHT(\"end\") es igual a \"d\".\n"
"RIGHT(\"end\",2) es igual a \"nd\".\n"
"\n"
"@SEEALSO=MID, LEFT"

#: ../plugins/fn-string/functions.c:445
msgid ""
"@FUNCTION=UPPER\n"
"@SYNTAX=UPPER(text)\n"
"@DESCRIPTION=UPPER returns a upper-case version of the string in @text.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"UPPER(\"cancelled\") equals \"CANCELLED\".\n"
"\n"
"@SEEALSO=LOWER"
msgstr ""
"@FUNCTION=UPPER\n"
"@SYNTAX=UPPER(texto)\n"
"@DESCRIPTION=Devuelve una versión en mayúsculas de la cadena @texto.\n"
"\n"
"Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"UPPER(\"cancelado\") devuelve \"CANCELADO\".\n"
"\n"
"@SEEALSO=LOWER"

#: ../plugins/fn-string/functions.c:470
msgid ""
"@FUNCTION=CONCATENATE\n"
"@SYNTAX=CONCATENATE(string1[,string2...])\n"
"@DESCRIPTION=CONCATENATE returns the string obtained by concatenation of the "
"given strings.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"CONCATENATE(\"aa\",\"bb\") equals \"aabb\".\n"
"\n"
"@SEEALSO=LEFT, MID, RIGHT"
msgstr ""
"@FUNCTION=CONCATENATE\n"
"@SYNTAX=CONCATENATE(cadena1[,cadena2…])\n"
"@DESCRIPTION=Devuelve la cadena resultado de concatenar todas las cadenas "
"pasadas como argumentos.\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"CONCATENATE(\"aa\",\"bb\") devuelve \"aabb\".\n"
"\n"
"@SEEALSO=LEFT, MID, RIGHT"

#: ../plugins/fn-string/functions.c:498
msgid ""
"@FUNCTION=REPT\n"
"@SYNTAX=REPT(string,num)\n"
"@DESCRIPTION=REPT returns @num repetitions of @string.\n"
"\n"
"* This function is Excel compatible.\n"
" \n"
"@EXAMPLES=\n"
"REPT(\".\",3) equals \"...\".\n"
"\n"
"@SEEALSO=CONCATENATE"
msgstr ""
"@FUNCTION=REPT\n"
"@SYNTAX=REPT(cadena,número)\n"
"@DESCRIPTION=Devuelve la cadena @cadena repetida @número veces.\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"REPT(\".\",3) es igual a \"…\".\n"
"\n"
"@SEEALSO=CONCATENATE"

#: ../plugins/fn-string/functions.c:548
msgid ""
"@FUNCTION=CLEAN\n"
"@SYNTAX=CLEAN(string)\n"
"@DESCRIPTION=CLEAN removes any non-printable characters from @string.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"CLEAN(\"one\"\\&char(7)) equals \"one\".\n"
"\n"
"@SEEALSO="
msgstr ""
"@FUNCTION=CLEAN\n"
"@SYNTAX=CLEAN(cadena)\n"
"@DESCRIPTION=Limpia la @cadena de todo carácter no imprimible.\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"CLEAN(\"uno\"\\&char(7)) devuelve \"uno\".\n"
"\n"
"@SEEALSO="

#: ../plugins/fn-string/functions.c:584
msgid ""
"@FUNCTION=FIND\n"
"@SYNTAX=FIND(string1,string2[,start])\n"
"@DESCRIPTION=FIND returns position of @string1 in @string2 (case-sensitive), "
"searching only from character @start onwards (assuming 1 if omitted).\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"FIND(\"ac\",\"Jack\") equals 2.\n"
"\n"
"@SEEALSO=EXACT, LEN, MID, SEARCH"
msgstr ""
"@FUNCTION=FIND\n"
"@SYNTAX=FIND(cadena1,cadena2[,inicio])\n"
"@DESCRIPTION=Devuelve la posición de @cadena1 en @cadena2 (distingue "
"mayúsculas y minúsculas), la búsqueda se hace sólo a partir de la posición "
"@inicio (se asume 1 si no se indica).\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"FIND(\"ac\",\"Jack\") es igual a 2.\n"
"\n"
"@SEEALSO=EXACT, LEN, MID, SEARCH"

#: ../plugins/fn-string/functions.c:628
msgid ""
"@FUNCTION=FIXED\n"
"@SYNTAX=FIXED(num,[decimals, no_commas])\n"
"@DESCRIPTION=FIXED returns @num as a formatted string with @decimals numbers "
"after the decimal point, omitting commas if requested by @no_commas.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"FIXED(1234.567,2) equals \"1,234.57\".\n"
"\n"
"@SEEALSO=TEXT, VALUE, DOLLAR"
msgstr ""
"@FUNCTION=FIXED\n"
"@SYNTAX=FIXED(número, [decimales, sin_separador])\n"
"@DESCRIPTION=Devuelve @número como una cadena formateada con @decimales "
"decimales después de la coma decimal. El separador de miles no se usará si "
"se pide @sin_separador.\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"FIXED(1234.567,2) devuelve \"1.234,57\".\n"
"\n"
"@SEEALSO=TEXT, VALUE, DOLLAR"

#: ../plugins/fn-string/functions.c:694
msgid ""
"@FUNCTION=PROPER\n"
"@SYNTAX=PROPER(string)\n"
"@DESCRIPTION=PROPER returns @string with initial of each word capitalised.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"PROPER(\"j. f. kennedy\") equals \"J. F. Kennedy\".\n"
"\n"
"@SEEALSO=LOWER, UPPER"
msgstr ""
"@FUNCTION=PROPER\n"
"@SYNTAX=PROPER(cadena)\n"
"@DESCRIPTION=Devuelve la @cadena con la primera letra de cada palabra en "
"mayúsculas.\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"PROPER(\"ernesto guevara\") es igual a \"Ernesto Guevara\".\n"
"\n"
"@SEEALSO=LOWER, UPPER"

#: ../plugins/fn-string/functions.c:749
msgid ""
"@FUNCTION=REPLACE\n"
"@SYNTAX=REPLACE(old,start,num,new)\n"
"@DESCRIPTION=REPLACE returns @old with @new replacing @num characters from "
"@start.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"REPLACE(\"testing\",2,3,\"*****\") equals \"t*****ing\".\n"
"\n"
"@SEEALSO=MID, SEARCH, SUBSTITUTE, TRIM"
msgstr ""
"@FUNCTION=REPLACE\n"
"@SYNTAX=REPLACE(antiguo,inicio,número,nuevo)\n"
"@DESCRIPTION=Devuelve la cadena @antiguo con @nuevo reemplazando @número "
"caracteres a partir de la posición @inicio.\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"REPLACE(\"testing\",2,3,\"*****\") es igual a \"t*****ing\".\n"
"\n"
"@SEEALSO=MID, SEARCH, SUBSTITUTE, TRIM"

#: ../plugins/fn-string/functions.c:805
msgid ""
"@FUNCTION=T\n"
"@SYNTAX=T(value)\n"
"@DESCRIPTION=T returns @value if and only if it is text, otherwise a blank "
"string.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"T(\"text\") equals \"text\".\n"
"T(64) returns an empty cell.\n"
"\n"
"@SEEALSO=CELL, N, VALUE"
msgstr ""
"@FUNCTION=T\n"
"@SYNTAX=T(valor)\n"
"@DESCRIPTION=Devuelve @valor únicamente si se trata de una cadena de texto; "
"si no devuelve una cadena vacía.\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"T(\"texto\") es igual a \"texto\".\n"
"T(64) devuelve una celda vacía.\n"
"\n"
"@SEEALSO=CELL, N, VALUE"

#: ../plugins/fn-string/functions.c:836
msgid ""
"@FUNCTION=TEXT\n"
"@SYNTAX=TEXT(value,format_text)\n"
"@DESCRIPTION=TEXT returns @value as a string with the specified format.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"TEXT(3.223,\"$0.00\") equals \"$3.22\".\n"
"TEXT(date(1999,4,15),\"mmmm, dd, yy\") equals \"April, 15, 99\".\n"
"\n"
"@SEEALSO=DOLLAR, FIXED, VALUE"
msgstr ""
"@FUNCTION=TEXT\n"
"@SYNTAX=TEXT(valor,formato_texto)\n"
"@DESCRIPTION=Devuelve @valor como una cadena de texto, según el formato "
"especificado.\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"TEXT(3.223,\"$0.00\") es igual a \"$3.22\".\n"
"TEXT(date(1999,4,15),\"mmmm, dd, yy\") es igual a \"Abril, 15, 99\".\n"
"\n"
"@SEEALSO=DOLLAR, FIXED, VALUE"

#: ../plugins/fn-string/functions.c:894
msgid ""
"@FUNCTION=TRIM\n"
"@SYNTAX=TRIM(text)\n"
"@DESCRIPTION=TRIM returns @text with only single spaces between words.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"TRIM(\"  a bbb  cc\") equals \"a bbb cc\".\n"
"\n"
"@SEEALSO=CLEAN, MID, REPLACE, SUBSTITUTE"
msgstr ""
"@FUNCTION=TRIM\n"
"@SYNTAX=TRIM(texto)\n"
"@DESCRIPTION=Devuelve la cadena @texto con un único un espacio entre cada "
"palabra.\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"TRIM(\" a bbb cc\") es igual a \"a bbb cc\".\n"
"\n"
"@SEEALSO=CLEAN, MID, REPLACE, SUBSTITUTE"

#: ../plugins/fn-string/functions.c:948
msgid ""
"@FUNCTION=VALUE\n"
"@SYNTAX=VALUE(text)\n"
"@DESCRIPTION=VALUE returns numeric value of @text.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"VALUE(\"$1,000\") equals 1000.\n"
"\n"
"@SEEALSO=DOLLAR, FIXED, TEXT"
msgstr ""
"@FUNCTION=VALUE\n"
"@SYNTAX=VALUE(texto)\n"
"@DESCRIPTION=Devuelve el valor numérico de @texto.\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"VALUE(\"$1,000\") es igual a 1000.\n"
"\n"
"@SEEALSO=DOLLAR, FIXED, TEXT"

#: ../plugins/fn-string/functions.c:988
msgid ""
"@FUNCTION=SUBSTITUTE\n"
"@SYNTAX=SUBSTITUTE(text, old, new [,num])\n"
"@DESCRIPTION=SUBSTITUTE replaces @old with @new in @text.  Substitutions are "
"only applied to instance @num of @old in @text, otherwise every one is "
"changed.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"SUBSTITUTE(\"testing\",\"test\",\"wait\") equals \"waiting\".\n"
"\n"
"@SEEALSO=REPLACE, TRIM"
msgstr ""
"@FUNCTION=SUBSTITUTE\n"
"@SYNTAX=SUBSTITUTE(texto, antiguo, nuevo [,número]\n"
"@DESCRIPTION=Reemplaza @antiguo con @nuevo en @texto. Las substituciones se "
"aplican únicamente a la instancia @número de @antiguo en @texto, si se omite "
"@número se reemplazan todas las instancias.\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"SUBSTITUTE(\"probando\",\"prob\",\"esper\") es igual a \"esperando\".\n"
"\n"
"@SEEALSO=REPLACE, TRIM"

#: ../plugins/fn-string/functions.c:1066
msgid ""
"@FUNCTION=DOLLAR\n"
"@SYNTAX=DOLLAR(num[,decimals])\n"
"@DESCRIPTION=DOLLAR returns @num formatted as currency.\n"
"\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"DOLLAR(12345) equals \"$12,345.00\".\n"
"\n"
"@SEEALSO=FIXED, TEXT, VALUE"
msgstr ""
"@FUNCTION=DOLLAR\n"
"@SYNTAX=DOLLAR(num,[decimales])\n"
"@DESCRIPTION=Devuelve @num formateado como divisa.\n"
"\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"DOLLAR(12345) es igual a \"$12,345.00\".\n"
"\n"
"@SEEALSO=FIXED, TEXT, VALUE"

#: ../plugins/fn-string/functions.c:1144
msgid ""
"@FUNCTION=SEARCH\n"
"@SYNTAX=SEARCH(search_string,text[,start_num])\n"
"@DESCRIPTION=SEARCH returns the location of the @search_ string within "
"@text. The search starts  with the @start_num character of text @text.  If "
"@start_num is omitted, it is assumed to be one.  The search is not case "
"sensitive.\n"
"\n"
"@search_string can contain wildcard characters (*) and question marks (?). A "
"question mark matches any character and a wildcard matches any string "
"including the empty string.  If you want the actual wildcard or question "
"mark to be found, use tilde (~) before the character.\n"
"\n"
"* If @search_string is not found, SEARCH returns #VALUE! error.\n"
"* If @start_num is less than one or it is greater than the length of @text, "
"SEARCH returns #VALUE! error.\n"
"* This function is Excel compatible.\n"
"\n"
"@EXAMPLES=\n"
"SEARCH(\"c\",\"Cancel\") equals 1.\n"
"SEARCH(\"c\",\"Cancel\",2) equals 4.\n"
"\n"
"@SEEALSO=FIND"
msgstr ""
"@FUNCTION=SEARCH\n"
"@SYNTAX=SEARCH(texto1,texto2[,inicio])\n"
"@DESCRIPTION=Devuelve la posición del carácter o cadena de texto en otra "
"cadena de texto. @texto1 es el carácter o texto a buscar. @texto2 es la "
"cadena de texto en la cual buscar. @inicio indica la posición en @texto2 a "
"partir de la cual iniciar la búsqueda. Si @inicio se omite, se asume como "
"igual a uno (1). La búsqueda considera de la misma manera mayúsculas y "
"minúsculas.\n"
"\n"
"@texto1 puede incluir caracteres comodín (*) y puntos de interrogación (?) "
"para controlar la búsqueda. Un punto de interrogación corresponde a un "
"carácter cualquiera; un asterisco corresponde a una cadena de texto "
"cualquiera, incluida la cadena vacía. Si desea buscar un punto de "
"interrogación o un asterisco use la virgulilla (~) antes del carácter.\n"
"\n"
"* Si @texto1 no se encuentra, SEARCH devuelve el error #VALOR! .\n"
"* Si @inicio es inferior a 1 o superior al tamaño de @texto2 , SEARCH "
"devuelve el error #VALOR!.\n"
"* Esta función es compatible con Excel.\n"
"\n"
"@EXAMPLES=\n"
"SEARCH(\"c\",\"Cancel\") es igual a 1.\n"
"SEARCH(\"c\",\"Cancel\",2) es igual a 4.\n"
"\n"
"@SEEALSO=FIND"

#: ../plugins/fn-string/functions.c:1221
msgid ""
"@FUNCTION=ASC\n"
"@SYNTAX=ASC(string)\n"
"@DESCRIPTION=ASC a compatibility function that is meaningless in Gnumeric.  "
"In MS Excel (tm) it converts 2 byte @string into single byte text.\n"
"\n"
"@EXAMPLES=\n"
"CHAR(\"Foo\") equals \"Foo\".\n"
"\n"
"@SEEALSO="
msgstr ""
"@FUNCTION=ASC\n"
"@SYNTAX=ASC(cadena)\n"
"@DESCRIPTION=ASC una función de compatibilidad que no tiene significado en "
"Gnumeric. En MS Excel (tm) convierte una @cadena de 2 bytes en texto de un "
"solo byte.\n"
"\n"
"@EXAMPLES=\n"
"CHAR(\"Foo\") igual a \"Foo\".\n"
"\n"
"@SEEALSO="

#: ../plugins/fn-tsa/functions.c:321
msgid ""
"@FUNCTION=interpolation\n"
"@SYNTAX=interpolation(abscissas,ordinates,targets[,interpolation])\n"
"@DESCRIPTION= \n"
"interpolation returns interpolated values corresponding\n"
"to the given abscissa targets as a one column matrix.\n"
"\n"
"@abscissas are the absicssas of the data to interpolate.\n"
"@ordinates are the ordinates of the data to interpolate.\n"
"* Strings and empty cells in @abscissas and @ordinates are simply ignored.\n"
"@targets are the abscissas of the interpolated data. If several data\n"
"are provided, they must be in the same column, in consecutive cells\n"
"@interpolation is the method to be used for the interpolation;\n"
"possible values are:\n"
"- 0: linear;\n"
"- 1: linear with averaging;\n"
"- 2: staircase;\n"
"- 3: staircase with averaging;\n"
"- 4: natural cubic spline;\n"
"- 5: natural cubic spline with averaging.\n"
"\n"
"If an averaging method is used, the number of returned values\n"
"is one less than the number of targets since the evaluation is made by\n"
"averaging the interpolation over the interval between two consecutive data;\n"
"in that case, the targets values must be given in increasing order."
msgstr ""

#: ../plugins/fn-tsa/functions.c:607
msgid ""
"@FUNCTION=periodogram\n"
"@SYNTAX=periodogram(ordinates,[filter,[abscissas,[interpolation,"
"[number]]]])\n"
"@DESCRIPTION= \n"
"periodogram returns the periodogram of the data\n"
"as a one column matrix.\n"
"\n"
"@ordinates are the ordinates of the data to interpolate.\n"
"@filter gives the window function to  be used. Possible values are:\n"
"- 0: no filter (rectangular window);\n"
"- 1: Bartlett (triangular window);\n"
"- 2: Hahn (cosine window);\n"
"- 3: Welch (parabolic window);\n"
"@abscissas are the absicssas of the data to interpolate. If no\n"
"abscissa is given, it is supposed that the data absicssas are regularly\n"
"spaced. Otherwise, an interpolation method will be used to evaluate\n"
"regularly spaced data.\n"
"* Strings and empty cells in @abscissas and @ordinates are simply ignored.\n"
"@interpolation is the method to be used for the interpolation;\n"
"possible values are:\n"
"- 0: linear;\n"
"- 1: linear with averaging;\n"
"- 2: staircase;\n"
"- 3: staircase with averaging;\n"
"- 4: natural cubic spline;\n"
"- 5: natural cubic spline with averaging.\n"
"@number is the number of interpolated data to be used. If not given,\n"
"a default number is automatically evaluated.\n"
msgstr ""

#: ../plugins/gda/plugin-gda.c:319
msgid ""
"@FUNCTION=EXECSQL\n"
"@SYNTAX=EXECSQL(dsn,username,password,sql)\n"
"@DESCRIPTION=The EXECSQL function lets you execute a command in a database "
"server, and show the results returned in current sheet. It uses libgda as "
"the means for accessing the databases.\n"
"For using it, you need first to set up a libgda data source.\n"
"@EXAMPLES=\n"
"To get all the data from the table \"Customers\" present in the "
"\"mydatasource\" GDA data source, you would use:\n"
"EXECSQL(\"mydatasource\",\"username\",\"password\",\"SELECT * FROM customers"
"\")\n"
"@SEEALSO=READDBTABLE"
msgstr ""
"@FUNCTION=EXECSQL\n"
"@SYNTAX=EXECSQL(dsn,nombre-usuario,contraseña,sql)\n"
"@DESCRIPTION=La función EXECSQL permite ejecutar un comando en un servidor "
"de bases de de datos, y mostrar los resultados devueltos en la hoja actual. "
"Usa libgda como medio para acceder a las bases de datos.\n"
"Para usarla, primero debe debe configurar un origen de datos libgda.\n"
"\n"
"@EXAMPLES=\n"
"Para obtener todos los datos de la tabla «Clientes» presente en el origen de "
"datos GDA «myorigendedatos» , tendría que hacer:\n"
"EXECSQL(\"miorigendedatos\",\"usuario\",\"contraseña\",\"SELECT * FROM "
"clientes\")\n"
"@SEEALSO="

#: ../plugins/gda/plugin-gda.c:391
msgid ""
"@FUNCTION=READDBTABLE\n"
"@SYNTAX=READDBTABLE(dsn,username,password,table)\n"
"@DESCRIPTION=The READDBTABLE function lets you get the contents of a table, "
"as stored in a database. For using it, you need first to set up a libgda "
"data source.\n"
"Note that this function returns all the rows in the given table. If you want "
"to get data from more than one table or want a more precise selection "
"(conditions), use the EXECSQL function.\n"
"@EXAMPLES=\n"
"To get all the data from the table \"Customers\" present in the "
"\"mydatasource\" GDA data source, you would use:\n"
"READDBTABLE(\"mydatasource\",\"username\",\"password\",\"customers\")\n"
"@SEEALSO=EXECSQL"
msgstr ""
"@FUNCTION=READDBTABLE\n"
"@SYNTAX=READDBTABLE(dsn,usuario,contraseña,tabla)\n"
"@DESCRIPTION=La función READDBTABLE le permite obtener el contenido de una "
"tabla almacenados en una base de datos. Para usarla, primero tiene que "
"configurar un origen de datos libgda.\n"
"Note que esta función devuelve todas las filas en la tabla dada. Si quiere "
"obtener datos de más de una tabla o quiere una selección más precisa "
"(condiciones), utilice la función EXECSQL.\n"
"\n"
"@EXAMPLES=\n"
"Para obtener todos los datos de la tabla «Clientes» presente en origen de "
"datos GDA \"miorigendedados\" debería hacer:\n"
"READDBTABLE(\"mydatasource\",\"usuario\",\"contraseña\",\"clientes\")\n"
"\n"
"@SEEALSO=EXECSQL"

#: ../plugins/numtheory/numtheory.c:206
msgid ""
"@FUNCTION=NT_PHI\n"
"@SYNTAX=NT_PHI(n)\n"
"@DESCRIPTION=NT_PHI function calculates the number of integers less than or "
"equal to @n that are relatively prime to @n.\n"
"\n"
"@EXAMPLES=\n"
"@SEEALSO=NT_D, ITHPRIME, NT_SIGMA"
msgstr ""
"@FUNCTION=NT_PHI\n"
"@SYNTAX=NT_PHI(n)\n"
"@DESCRIPTION=La función NT_PHI calcula el número de enteros menores o "
"iguales @n y que son primos relativos de @n.\n"
"\n"
"@EXAMPLES=\n"
"@SEEALSO=NT_D, ITHPRIME, NT_SIGMA"

#. xgettext: you can translate the funny character as an 'o' if unicode is not available.
#: ../plugins/numtheory/numtheory.c:244
msgid ""
"@FUNCTION=NT_MU\n"
"@SYNTAX=NT_MU(n)\n"
"@DESCRIPTION=NT_MU function (Möbius mu function) returns \n"
"0  if @n is divisible by the square of a prime .\n"
"Otherwise it returns: \n"
"\n"
"  -1 if @n has an odd  number of different prime factors .\n"
"   1  if @n has an even number of different prime factors .\n"
"\n"
"* If @n = 1 NT_MU returns 1.\n"
"\n"
"@EXAMPLES=\n"
"@SEEALSO=NT_D, ITHPRIME, NT_PHI"
msgstr ""
"@FUNCTION=NT_MU\n"
"@SYNTAX=NT_MU(n)\n"
"@DESCRIPTION=La función NT_MU (función mu de Möbius) devuelve 0 si @n es "
"divisible por el cuadrado de un primo.\n"
"En caso contrario devuelve:\n"
"\n"
" -1 si @n tiene un número impar de factores primos diferentes.\n"
" 1 si @n tiene un número par de factores primos diferentes.\n"
"\n"
"* Si @n=1, devuelve 1\n"
"\n"
"@EXAMPLES=\n"
"@SEEALSO=NT_D, ITHPRIME, NT_PHI"

#: ../plugins/numtheory/numtheory.c:286
msgid ""
"@FUNCTION=NT_D\n"
"@SYNTAX=NT_D(n)\n"
"@DESCRIPTION=NT_D function calculates the number of divisors of @n.\n"
"\n"
"@EXAMPLES=\n"
"@SEEALSO=ITHPRIME, NT_PHI, NT_SIGMA"
msgstr ""
"@FUNCTION=NT_D\n"
"@SYNTAX=NT_D(n)\n"
"@DESCRIPTION=La función NT_D calcula la cantidad de divisores de @n.\n"
"\n"
"* Esta función acepta sólo un argumento.\n"
"\n"
"@EXAMPLES=\n"
"@SEEALSO=ITHPRIME, NT_PHI, NT_SIGMA"

#: ../plugins/numtheory/numtheory.c:322
msgid ""
"@FUNCTION=NT_SIGMA\n"
"@SYNTAX=NT_SIGMA(n)\n"
"@DESCRIPTION=NT_SIGMA function calculates the sum of the divisors of @n.\n"
"\n"
"@EXAMPLES=\n"
"@SEEALSO=NT_D, ITHPRIME, NT_PHI"
msgstr ""
"@FUNCTION=NT_SIGMA\n"
"@SYNTAX=NT_SIGMA(n)\n"
"@DESCRIPTION=La función NT_SIGMA calcula la suma de los divisores de @n.\n"
"\n"
"* Esta función acepta sólo un argumento.\n"
"\n"
"@EXAMPLES=\n"
"@SEEALSO=NT_D, ITHPRIME, NT_PHI"

#: ../plugins/numtheory/numtheory.c:359
msgid ""
"@FUNCTION=ITHPRIME\n"
"@SYNTAX=ITHPRIME(i)\n"
"@DESCRIPTION=ITHPRIME function returns the @ith prime.\n"
"\n"
"@EXAMPLES=\n"
"@SEEALSO=NT_D, NT_SIGMA"
msgstr ""
"@FUNCTION=ITHPRIME\n"
"@SYNTAX=ITHPRIME(i)\n"
"@DESCRIPTION=La función ITHPRIME devuelve el @ith primo.\n"
"\n"
"@EXAMPLES=\n"
"@SEEALSO=NT_D, NT_SIGMA"

#: ../plugins/numtheory/numtheory.c:389
msgid ""
"@FUNCTION=ISPRIME\n"
"@SYNTAX=ISPRIME(i)\n"
"@DESCRIPTION=ISPRIME function returns TRUE if @i is prime and FALSE "
"otherwise.\n"
"\n"
"@EXAMPLES=\n"
"@SEEALSO=ITHPRIME, NT_D, NT_SIGMA"
msgstr ""
"@FUNCTION=ISPRIME\n"
"@SYNTAX=ISPRIME(i)\n"
"@DESCRIPTION=La función ISPRIME devuelve VERDADERO si @i es primo y FALSO en "
"caso contrario.\n"
"\n"
"@EXAMPLES=\n"
"@SEEALSO=ITHPRIME, NT_D, NT_SIGMA"

#: ../plugins/numtheory/numtheory.c:447
msgid ""
"@FUNCTION=PFACTOR\n"
"@SYNTAX=PFACTOR(n)\n"
"@DESCRIPTION=PFACTOR function returns the smallest prime factor of its "
"argument.\n"
"\n"
"The argument must be at least 2, or else a #VALUE! error is returned.\n"
"\n"
"@EXAMPLES=\n"
"@SEEALSO=ITHPRIME"
msgstr ""
"@FUNCTION=PFACTOR\n"
"@SYNTAX=PFACTOR(n)\n"
"@DESCRIPTION=La función PFACTOR devuelve el factor primo más pequeño de su "
"argumento.\n"
"\n"
"El argumento debe ser al menos 2 o de lo contrario se devuelve un error de "
"#VALOR!\n"
"\n"
"@EXAMPLES=\n"
"@SEEALSO=ITHPRIME"

#: ../plugins/numtheory/numtheory.c:483
msgid ""
"@FUNCTION=NT_PI\n"
"@SYNTAX=NT_PI(n)\n"
"@DESCRIPTION=NT_PI function returns the number of primes less than or equal "
"to @n.\n"
"\n"
"@EXAMPLES=\n"
"@SEEALSO=ITHPRIME, NT_PHI, NT_D, NT_SIGMA"
msgstr ""
"@FUNCTION=NT_PI\n"
"@SYNTAX=NT_PI(n)\n"
"@DESCRIPTION=La función NT_PI devuelve el número de primos menores o iguales "
"a @n.\n"
"\n"
"* Esta función emplea sólo un argumento.\n"
"\n"
"@EXAMPLES=\n"
"@SEEALSO=ITHPRIME, NT_PHI, NT_D, NT_SIGMA"

#: ../plugins/numtheory/numtheory.c:518
msgid ""
"@FUNCTION=BITOR\n"
"@SYNTAX=BITOR(a,b)\n"
"@DESCRIPTION=BITOR function returns bitwise or-ing of its arguments.\n"
"\n"
"@EXAMPLES=\n"
"@SEEALSO=BITXOR,BITAND"
msgstr ""
"@FUNCTION=BITOR\n"
"@SYNTAX=BITOR(a,b)\n"
"@DESCRIPTION=La función BITOR devuelve la operación de bit OR de sus "
"argumentos\n"
"\n"
"@EXAMPLES=\n"
"@SEEALSO=BITXOR,BITAND"

#: ../plugins/numtheory/numtheory.c:545
msgid ""
"@FUNCTION=BITXOR\n"
"@SYNTAX=BITXOR(a,b)\n"
"@DESCRIPTION=BITXOR function returns bitwise exclusive or-ing of its "
"arguments.\n"
"\n"
"@EXAMPLES=\n"
"@SEEALSO=BITOR,BITAND"
msgstr ""
"@FUNCTION=BITXOR\n"
"@SYNTAX=BITXOR(a,b)\n"
"@DESCRIPTION=La función BITXOR devuelve la operación de bit XOR (OR "
"exclusivo) de sus argumentos.\n"
"\n"
"@EXAMPLES=\n"
"@SEEALSO=BITOR,BITAND"

#: ../plugins/numtheory/numtheory.c:573
msgid ""
"@FUNCTION=BITAND\n"
"@SYNTAX=BITAND(a,b)\n"
"@DESCRIPTION=BITAND function returns bitwise and-ing of its arguments.\n"
"\n"
"@EXAMPLES=\n"
"@SEEALSO=BITOR,BITXOR"
msgstr ""
"@FUNCTION=BITAND\n"
"@SYNTAX=BITAND(a,b)\n"
"@DESCRIPTION=La función BITAND devuelve la operación de bit AND de sus "
"argumentos.\n"
"\n"
"@EXAMPLES=\n"
"@SEEALSO=BITOR,BITXOR"

#: ../plugins/numtheory/numtheory.c:601
msgid ""
"@FUNCTION=BITLSHIFT\n"
"@SYNTAX=BITLSHIFT(x,n)\n"
"@DESCRIPTION=BITLSHIFT function returns @x bit-shifted left by @n bits.\n"
"\n"
"* If @n is negative, a right shift will in effect be performed.\n"
"\n"
"@EXAMPLES=\n"
"@SEEALSO=BITRSHIFT"
msgstr ""
"@FUNCTION=BITLSHIFT\n"
"@SYNTAX=BITLSHIFT(x,n)\n"
"@DESCRIPTION=La función BITLSHIFT devuelve @x desplazado @n bits hacia la "
"izquierda.\n"
"\n"
"* Si @n es negativo, el desplazamiento de bits se hará hacia la derecha.\n"
"\n"
"@EXAMPLES=\n"
"@SEEALSO=BITRSHIFT"

#: ../plugins/numtheory/numtheory.c:634
msgid ""
"@FUNCTION=BITRSHIFT\n"
"@SYNTAX=BITRSHIFT(x,n)\n"
"@DESCRIPTION=BITRSHIFT function returns @x bit-shifted right by @n bits.\n"
"\n"
"* If @n is negative, a left shift will in effect be performed.\n"
"\n"
"@EXAMPLES=\n"
"@SEEALSO=BITLSHIFT"
msgstr ""
"@FUNCTION=BITRSHIFT\n"
"@SYNTAX=BITRSHIFT(x,n)\n"
"@DESCRIPTION=La función BITRSHIFT devuelve @x desplazado @n bits hacia la "
"derecha.\n"
"\n"
"* Si @n es negativo, el desplazamiento de bits se hará hacia la izquierda.\n"
"\n"
"@EXAMPLES=\n"
"@SEEALSO=BITLSHIFT"

#: ../plugins/sample_datasource/sample_datasource.c:272
#, no-c-format
msgid ""
"@FUNCTION=atl_last\n"
"@SYNTAX=ATL_LAST (tag)\n"
"@DESCRIPTION=ATL_LAST is a sample implemention of a real time data source. "
"It takes a string tag and monitors the named pipe /tmp/atl for changes to "
"the value of that tag.\n"
"\n"
"* This is not intended to be generally enabled and is OFF by default.\n"
"\n"
"@EXAMPLES=\n"
"ATL_LAST(\"IBM\")\n"
"@SEEALSO="
msgstr ""
"@FUNCTION=atl_last\n"
"@SYNTAX=ATL_LAST (etiqueta)\n"
"@DESCRIPTION=ATL_LAST es una implementación de muestra de una fuente de "
"datos de tiempo real. Toma una cadena etiquetada y monitoriza el pipe /tmp/"
"atl esperando cambios en el valor de esa etiqueta.\n"
"\n"
"* Esto no se intenta que esté generalmente activado y esta DESACTIVADO por "
"omisión.\n"
"\n"
"@EXAMPLES=\n"
"ATL_LAST(\"IBM\")\n"
"@SEEALSO="
